program print-int :
   ($package user)
   ($ls-extern print_int ($ls-fn (($ls-int)) ($none) ($ls-int)))
   ($ls-call-c print_int 42)

program def :
   ($package core)
   ($public
      ($ls-deftype Int () ($none)
         (($ls-int)) ($none)
         (value) ($none)))

   ($ls-defn cast-error () () ($ls-int) ()
      ($ls-return 0))
      
   ($package user
      ($import core))
   ($ls-extern print_int ($ls-fn (($ls-ref Int)) ($none) ($ls-int)))
   ($def x ($none) 32)
   ($ls-call-c print_int x)

program lsdefn :
   ($package core)
   ($public
      ($begin
         ($ls-deftype Int () ($none)
            (($ls-int)) ($none)
            (value) ($none))
         ($ls-deftype False () ($none)
            () ($none)
            () ($none))))

   ($ls-defn cast-error () () ($ls-int) ()
      ($ls-return 0))
      
   ($package user
      ($import core))
   ($ls-extern printf ($ls-fn (($ls-ptr ($ls-byte))) ($ls-?) ($ls-int)))

   ($ls-defn myfunction () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Hello World\n")
         ($ls-return 0)))
   
   ($ls-do myfunction)

program voidcheck :
   ($package core)
   ($public
      ($begin
         ($ls-deftype Int () ($none)
            (($ls-int)) ($none)
            (value) ($none))
         ($ls-deftype False () ($none)
            () ($none)
            () ($none))))

   ($ls-extern printf ($ls-fn (($ls-ptr ($ls-byte))) ($ls-?) ($ls-int)))
   ($ls-extern exit ($ls-fn (($ls-int)) ($none) ($ls-int)))
   ($ls-defn cast-error () () ($ls-int) ()
      ($ls-return 0))
   ($ls-defn variable-uninitialized-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Variable Uninitialized\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))      
      
   ($package user
      ($import core))

   ($defvar X ($?) ($none))
   ($def Y ($none) X)

common basic0 :
   ($package core)
   ($public
      ($begin
         ($ls-deftype Int () ($none)
            (($ls-int)) ($none)
            (value) ($none))
         ($ls-deftype False () ($none)
            () ($none)
            () ($none))
         ($ls-deftype Fn () ($none)
            (($ls-ptr ($ls-?))) ($ls-ref ($?))
            (code) free)))

   ($public ($ls-extern printf ($ls-fn (($ls-ptr ($ls-byte))) ($ls-?) ($ls-int))))
   ($ls-extern malloc ($ls-fn (($ls-long)) ($none) ($ls-ptr ($ls-?))))
   ($ls-extern exit ($ls-fn (($ls-int)) ($none) ($ls-int)))

   ($ls-defn cast-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Cast Error\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))

   ($ls-defn arity-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Arity Error\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))
         
   ($ls-defn variable-uninitialized-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Variable Uninitialized\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))
      
   ($package user
      ($import core))   

program new (basic0) :
   ($ls-defvar F ($ls-ref False) ($ls-new False))
   ($ls-call-c printf "F = 0x%lx\n" F)

program fn (basic0) :
   ($ls-defn print-random () () ($ls-ref False) ()
      ($begin
         ($ls-call-c printf "Random Message\n")
         ($ls-return ($ls-new False))))

   ($defn myfunction () () ($none) ()
      ($do print-random))
      
   ($do myfunction)

program ls-add (basic0) :
   ($ls-call-c printf "Result = %ld\n"
      ($ls-prim add ($ls-as 3 ($ls-long)) ($ls-as 39 ($ls-long))))

common basic1 :
   ($package core)
   ($public
      ($begin
         ($ls-deftype Int () ($none)
            (($ls-int)) ($none)
            (value) ($none))
         ($ls-deftype False () ($none)
            () ($none)
            () ($none))
         ($ls-deftype Fn () ($none)
            (($ls-ptr ($ls-?))) ($ls-ref ($?))
            (code) free)))

   ($public ($ls-extern printf ($ls-fn (($ls-ptr ($ls-byte))) ($ls-?) ($ls-int))))
   ($ls-extern malloc ($ls-fn (($ls-long)) ($none) ($ls-ptr ($ls-?))))
   ($ls-extern exit ($ls-fn (($ls-int)) ($none) ($ls-int)))

   ($ls-defn cast-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Cast Error\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))

   ($ls-defn arity-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Arity Error\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))
         
   ($ls-defn variable-uninitialized-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Variable Uninitialized\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))

   ;Initialize heap
   ($ls-let ($begin
      ($ls-def heap-mem ($none) ($ls-call-c malloc ($ls-as 1048576 ($ls-long))))
      ($ls-prim set-heap heap-mem)
      ($ls-prim set-heap-limit ($ls-prim add heap-mem ($ls-as 1048576 ($ls-long))))))

   ($ls-defn extend-heap () (($ls-long)) ($ls-long) (sz)
      ($begin
         ($ls-call-c printf "Extend Heap\n")
         ($ls-call-c exit -1)
         ($ls-return ($ls-as 0 ($ls-long)))))
      
   ($package user
      ($import core))   

program global-closure (basic1) :
   ($ls-defn print-random () () ($ls-ref False) ()
      ($begin
         ($ls-call-c printf "Random Message\n")
         ($ls-return ($ls-new False))))

   ($defn myfunction () () ($none) ()
      ($do print-random))

   ($def closure ($none) myfunction)
   ($do closure)

   

   

;1. Demonstrating argument inference using body of called function
;($def a ($none) ($new A))
;($do
;   ($fn (($none)) ($none) (f)
;      ($do f a))
;
;   ($fn (($none)) ($none) (x)
;      x))


;2. Demonstrating ambiguity selection using body of function
;($defmulti A! () (A) ($none))
;($defmulti f () (($-> (A) A)) ($none))
;($defmulti f () (($-> (B) B)) ($none))
;
;($do f
;   ($fn (($none)) ($none) (a)
;      ($do A! a)))


;3. Demonstrating calling ambiguous function using ambiguous arguments
;($deftype List (T) ($none))
;($deftype Array (T) ($none))
;($deftype Box (T) ($none))
;($deftype Tree (T) ($none))
;($deftype Int () ($none))
;($deftype String () ($none))
;
;($defmulti map (($cap T) ($cap S)) (($-> (T) ($cap S)) ($of List ($cap T))) ($of List S))
;($defmulti map (($cap T) ($cap S)) (($-> (T) ($cap S)) ($of Array ($cap T))) ($of Array S))
;($defmulti value (($cap T)) (($of Box ($cap T))) T)
;($defmulti value (($cap T)) (($of Tree ($cap T))) String)
;
;($def xs ($?) ($new ($of List ($of Box String))))
;($def result ($none) ($do map value xs))


;4. Demonstrating calling ambiguous function using ambiguous arguments
;($defmulti f () (($-> (A) A)) ($none))
;($defmulti f () (($-> (B) B)) ($none))
;($defmulti g () (A) A)
;($defmulti g () (B) B)
;($def result ($none) ($do f g))

;5. Demonstrating refering to ambiguous functions from LoStanza
;($defmulti f () (($-> (A) A)) ($none))
;($defmulti f () (($-> (B) B)) ($none))
;($defmulti g () (A) A)
;($defmulti g () (B) B)
;($ls-defn lf () (($ls-long)) ($ls-long) (x)
;   ($begin
;      ($ls-do f ($ls-func g))
;      ($ls-return x)))

