program print-int :
   ($package user)
   ($ls-extern print_int ($ls-fn (($ls-int)) ($none) ($ls-int)))
   ($ls-call-c print_int 42)

program def :
   ($package core)
   ($public
      ($ls-deftype Int () ($none)
         (($ls-int)) ($none)
         (value) ($none)))

   ($ls-defn cast-error () () ($ls-int) ()
      ($ls-return 0))
      
   ($package user
      ($import core))
   ($ls-extern print_int ($ls-fn (($ls-ref Int)) ($none) ($ls-int)))
   ($def x ($none) 32)
   ($ls-call-c print_int x)

program lsdefn :
   ($package core)
   ($public
      ($begin
         ($ls-deftype Int () ($none)
            (($ls-int)) ($none)
            (value) ($none))
         ($ls-deftype False () ($none)
            () ($none)
            () ($none))))

   ($ls-defn cast-error () () ($ls-int) ()
      ($ls-return 0))
      
   ($package user
      ($import core))
   ($ls-extern printf ($ls-fn (($ls-ptr ($ls-byte))) ($ls-?) ($ls-int)))

   ($ls-defn myfunction () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Hello World\n")
         ($ls-return 0)))
   
   ($ls-do myfunction)

program voidcheck :
   ($package core)
   ($public
      ($begin
         ($ls-deftype Int () ($none)
            (($ls-int)) ($none)
            (value) ($none))
         ($ls-deftype False () ($none)
            () ($none)
            () ($none))))

   ($ls-extern printf ($ls-fn (($ls-ptr ($ls-byte))) ($ls-?) ($ls-int)))
   ($ls-extern exit ($ls-fn (($ls-int)) ($none) ($ls-int)))
   ($ls-defn cast-error () () ($ls-int) ()
      ($ls-return 0))
   ($ls-defn variable-uninitialized-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Variable Uninitialized\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))      
      
   ($package user
      ($import core))

   ($defvar X ($?) ($none))
   ($def Y ($none) X)

common basic0 :
   ($package core)
   ($public
      ($begin
         ($ls-deftype Int () ($none)
            (($ls-int)) ($none)
            (value) ($none))
         ($ls-deftype False () ($none)
            () ($none)
            () ($none))
         ($ls-deftype Fn () ($none)
            (($ls-ptr ($ls-?))) ($ls-ref ($?))
            (code) free)))

   ($public ($ls-extern printf ($ls-fn (($ls-ptr ($ls-byte))) ($ls-?) ($ls-int))))
   ($ls-extern malloc ($ls-fn (($ls-long)) ($none) ($ls-ptr ($ls-?))))
   ($ls-extern exit ($ls-fn (($ls-int)) ($none) ($ls-int)))

   ($ls-defn cast-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Cast Error\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))

   ($ls-defn arity-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Arity Error\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))
         
   ($ls-defn variable-uninitialized-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Variable Uninitialized\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))
      
   ($package user
      ($import core))   

program new (basic0) :
   ($ls-defvar F ($ls-ref False) ($ls-new False))
   ($ls-call-c printf "F = 0x%lx\n" F)

program fn (basic0) :
   ($ls-defn print-random () () ($ls-ref False) ()
      ($begin
         ($ls-call-c printf "Random Message\n")
         ($ls-return ($ls-new False))))

   ($defn myfunction () () ($none) ()
      ($do print-random))
      
   ($do myfunction)

program ls-add (basic0) :
   ($ls-call-c printf "Result = %ld\n"
      ($ls-prim add ($ls-as 3 ($ls-long)) ($ls-as 39 ($ls-long))))

common basic1 :
   ($package core)
   ($public
      ($begin
         ($ls-deftype Int () ($none)
            (($ls-int)) ($none)
            (value) ($none))
         ($ls-deftype False () ($none)
            () ($none)
            () ($none))
         ($ls-deftype True () ($none)
            () ($none)
            () ($none))
         ($ls-deftype Fn () ($none)
            (($ls-ptr ($ls-?))) ($ls-ref ($?))
            (code) free)
         ($ls-deftype Type () ($none)
            (($ls-ptr ($ls-?))) ($ls-ref ($?))
            (code) free)))

   ($public ($ls-extern printf ($ls-fn (($ls-ptr ($ls-byte))) ($ls-?) ($ls-int))))
   ($ls-extern malloc ($ls-fn (($ls-long)) ($none) ($ls-ptr ($ls-?))))
   ($ls-extern exit ($ls-fn (($ls-int)) ($none) ($ls-int)))

   ($ls-defn cast-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Cast Error\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))

   ($ls-defn arity-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Arity Error\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))

   ($ls-defn branch-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Branch Error\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))
         
   ($ls-defn variable-uninitialized-error () () ($ls-int) ()
      ($begin
         ($ls-call-c printf "Variable Uninitialized\n")
         ($ls-call-c exit -1)
         ($ls-return 0)))

   ;Initialize heap
   ($ls-let ($begin
      ($ls-def heap-mem ($none) ($ls-call-c malloc ($ls-as 1048576 ($ls-long))))
      ($ls-prim set-heap heap-mem)
      ($ls-prim set-heap-limit ($ls-prim add heap-mem ($ls-as 1048576 ($ls-long))))))

   ($ls-defn extend-heap () (($ls-long)) ($ls-long) (sz)
      ($begin
         ($ls-call-c printf "Extend Heap\n")
         ($ls-call-c exit -1)
         ($ls-return ($ls-as 0 ($ls-long)))))
      
   ($package user
      ($import core))   

program global-closure (basic1) :
   ($ls-defn print-random () () ($ls-ref False) ()
      ($begin
         ($ls-call-c printf "Random Message\n")
         ($ls-return ($ls-new False))))

   ($defn myfunction () () ($none) ()
      ($do print-random))

   ($def closure ($none) myfunction)
   ($do closure)

program arity (basic1) :
   ($ls-defn print-random () () ($ls-ref False) ()
      ($begin
         ($ls-call-c printf "Random Message\n")
         ($ls-return ($ls-new False))))

   ($defn myfunction () () ($none) ()
      ($do print-random))

   ($def closure ($?) myfunction)
   ($do closure 0)

program not-a-function (basic1) :
   ($def closure ($?) 0)
   ($do closure 0)

program multifns (basic1) :
   ($ls-defn print-int () (($ls-ref Int)) ($ls-ref False) (x)
      ($begin
         ($ls-call-c printf "X = %ld\n", x)
         ($ls-return ($ls-new False))))
    
   ($def closure ($?)
      ($multi
         ($fn () ($none) ()
            ($do print-int 0))
         ($fn (Int) ($none) (x)
            ($do print-int x))))

   ($do closure)
   ($do closure 42)
   ($do closure 42 84)

program new-struct (basic1) :
   ($ls-deftype MyStruct () ($none)
      (($ls-int) ($ls-int)) ($none)
      (x y) ($none))
      
   ($ls-defn make-struct () (($ls-int) ($ls-int)) ($ls-ref MyStruct) (x, y)
      ($begin
         ($ls-def s ($none) ($ls-new MyStruct x y))
         ($ls-return s)))

   ($ls-let ($begin
      ($ls-def s1 ($none) ($ls-do make-struct 10 30))
      ($ls-def s2 ($none) ($ls-do make-struct 40 50))
      ($ls-call-c printf "s1 = (%d, %d)\n" ($ls-field s1 x) ($ls-field s1 y))
      ($ls-call-c printf "s2 = (%d, %d)\n" ($ls-field s2 x) ($ls-field s2 y))))

program new-array (basic1) :
   ($ls-deftype MyArray () ($none)
      () ($ls-int)
      () items)      

   ($ls-def zero ($ls-long) ($ls-as 0 ($ls-long)))
   ($ls-def one ($ls-long) ($ls-as 1 ($ls-long)))
   ($ls-def two ($ls-long) ($ls-as 2 ($ls-long)))
   ($ls-def three ($ls-long) ($ls-as 3 ($ls-long)))
   
   ($ls-defn make-array () () ($ls-ref MyArray) ()
      ($begin
         ($ls-def a ($none) ($ls-array MyArray () three))
         ($ls-set ($ls-slot ($ls-field a items) zero) 42)
         ($ls-set ($ls-slot ($ls-field a items) one) 43)
         ($ls-set ($ls-slot ($ls-field a items) two) 44)
         ($ls-return a)))

   ($ls-defn array-length () (($ls-ref ($?))) ($ls-long) (x)
      ($begin
         ($ls-defvar p ($ls-ptr ($ls-long)) ($ls-as x ($ls-ptr ($ls-long))))
         ($ls-set p ($ls-prim add p ($ls-as -9 ($ls-long))))
         ($ls-return ($ls-deref p))))

   ($ls-let ($begin
      ($ls-def a ($none) ($ls-do make-array))
      ($ls-call-c printf "a[0] = %d\n" ($ls-slot ($ls-field a items) zero))
      ($ls-call-c printf "a[1] = %d\n" ($ls-slot ($ls-field a items) one))
      ($ls-call-c printf "a[2] = %d\n" ($ls-slot ($ls-field a items) two))
      ($ls-call-c printf "length word = %ld\n" ($ls-do array-length a))))

program histanza-from-lostanza (basic1) :
   ($ls-defn say-hi () () ($ls-ref False) ()
      ($begin
         ($ls-call-c printf "Hi!\n")
         ($ls-return ($ls-new False))))
   ($defn say-hi-twice () () ($none) ()
      ($begin
         ($def f ($none) say-hi)
         ($do f)
         ($do f)))
   
   ($ls-let ($begin
      ($ls-def f ($none) ($ls-func say-hi-twice))
      ($ls-do ($ls-deref f))))

program parametric-structs (basic1) :
   ($ls-deftype MyBox (T) ($none)
      (($ls-ref T)) ($none)
      (item) ($none))

   ($ls-def NUM ($ls-ref Int) ($ls-as ($ls-as 336 ($ls-long)) ($ls-ref Int)))
   ($ls-def FALSE ($ls-ref False) ($ls-new False))
   ($ls-def BOXED-FALSE ($ls-ref ($of MyBox False)) ($ls-new ($ls-of MyBox False) FALSE))
   ($ls-def BOXED-NUM ($ls-ref ($of MyBox Int)) ($ls-new ($ls-of MyBox Int) NUM))
   ($ls-defn item (($cap T)) (($ls-ref ($of MyBox ($cap T)))) ($ls-ref T) (box)
      ($ls-return ($ls-field box item)))

   ($do item BOXED-NUM)
   ($do item ($as ($as BOXED-FALSE ($?)) ($of MyBox Int)))

program curried-globals (basic1) :
   ($ls-deftype MyBox (T) ($none)
      (($ls-ref T)) ($none)
      (item) ($none))
   ($ls-def NUM ($ls-ref Int) ($ls-as ($ls-as 336 ($ls-long)) ($ls-ref Int)))
   ($ls-def FALSE ($ls-ref False) ($ls-new False))
   ($ls-def BOXED-FALSE ($ls-ref ($of MyBox False)) ($ls-new ($ls-of MyBox False) FALSE))
   ($ls-def BOXED-NUM ($ls-ref ($of MyBox Int)) ($ls-new ($ls-of MyBox Int) NUM))
   ($ls-defn item (($cap T)) (($ls-ref ($of MyBox ($cap T)))) ($ls-ref T) (box)
      ($ls-return ($ls-field box item)))

   ($defn apply () (($-> (($of MyBox Int)) Int) ($of MyBox Int)) ($none) (f, b)
      ($do f b))
   ($do apply item BOXED-FALSE)   

program curried-ls-globals (basic1) :
   ($ls-deftype MyBox (T) ($none)
      (($ls-ref T)) ($none)
      (item) ($none))
   ($ls-def NUM ($ls-ref Int) ($ls-as ($ls-as 336 ($ls-long)) ($ls-ref Int)))
   ($ls-def FALSE ($ls-ref False) ($ls-new False))
   ($ls-def BOXED-FALSE ($ls-ref ($of MyBox False)) ($ls-new ($ls-of MyBox False) FALSE))
   ($ls-def BOXED-NUM ($ls-ref ($of MyBox Int)) ($ls-new ($ls-of MyBox Int) NUM))
   ($ls-defn item (($cap T)) (($ls-ref ($of MyBox ($cap T)))) ($ls-ref T) (box)
      ($ls-return ($ls-field box item)))

   ($defn apply () (($-> (($of MyBox Int)) Int) ($of MyBox Int)) ($none) (f, b)
      ($do f b))
   ($ls-do apply ($ls-func item) BOXED-NUM)   

program and-or-types (basic1) :
   ($defn check (T) (T) ($none) (x)
      x)

   ($defn check2 (T,S) (($?)) ($none) (x)
      ($do ($of check ($or T S)) x))

   ($ls-def FALSE ($ls-ref False) ($ls-new False))
   ($ls-def TRUE ($ls-ref True) ($ls-new True))

   ($do ($of check2 Int False) FALSE)
   ($do ($of check2 Int False) 42)
   ($do ($of check2 Int False) TRUE)

program no-method (basic1) :
   ($ls-defn say-hi () () ($ls-ref False) ()
      ($begin
         ($ls-call-c printf "Hi\n")
         ($ls-return ($ls-new False))))
   ($defmulti hi () () False)
   ($do hi)

program one-method (basic1) :
   ($ls-defn say-hi () () ($ls-ref False) ()
      ($begin
         ($ls-call-c printf "Hi\n")
         ($ls-return ($ls-new False))))
   ($defmulti hi () () False)
   ($defmethod hi () () ($none) ()
      ($do say-hi))
   ($do hi)

program two-methods (basic1) :
   ($ls-def FALSE ($ls-ref False) ($ls-new False))
   ($ls-defn say-hi () () ($ls-ref False) ()
      ($begin
         ($ls-call-c printf "Hi\n")
         ($ls-return ($ls-new False))))
   ($ls-defn say-int () (($ls-ref Int)) ($ls-ref False) (x)
      ($begin
         ($ls-call-c printf "X = %d\n" ($ls-prim shr ($ls-as x ($ls-long)) ($ls-as 3 ($ls-long))))
         ($ls-return ($ls-new False))))
         
   ($defmulti hi () (($?)) False)
   ($defmethod hi () (False) ($none) (x)
      ($do say-hi))
   ($defmethod hi () (Int) ($none) (x)
      ($do say-int x))
      
   ($do hi FALSE)
   ($do hi 42)
   ($do hi FALSE)
   ($do hi 40)

program instance-methods (basic1) :
   ($ls-defn say-int () (($ls-ref Int)) ($ls-ref False) (x)
      ($begin
         ($ls-call-c printf "X = %d\n" ($ls-prim shr ($ls-as x ($ls-long)) ($ls-as 3 ($ls-long))))
         ($ls-return ($ls-new False))))
         
   ($deftype Animal () ($none))
   ($defmulti bark () (Animal) False)
   ($defmethod bark () (Animal) ($none) (x)
      ($do say-int 0))

   ($defn Dog () (Int) ($none) (x)
      ($new Animal
         ($defmethod bark () (($none)) ($none) (this)
            ($do say-int x))))

   ($do bark ($new Animal))
   ($do bark ($do Dog 10))
   ($do bark ($do Dog 14))

program nested-functions (basic1) :
   ($ls-defn say-int () (($ls-ref Int)) ($ls-ref False) (x)
      ($begin
         ($ls-call-c printf "X = %d\n" ($ls-prim shr ($ls-as x ($ls-long)) ($ls-as 3 ($ls-long))))
         ($ls-return ($ls-new False))))

   ($defn function () (Int) ($none) (x)
      ($begin
         ($defn nested () () ($none) ()
            ($do say-int x))
         ($do nested)
         ($do nested)))

   ($do function 10)
   ($do function 13)

         
   

;1. Demonstrating argument inference using body of called function
;($def a ($none) ($new A))
;($do
;   ($fn (($none)) ($none) (f)
;      ($do f a))
;
;   ($fn (($none)) ($none) (x)
;      x))


;2. Demonstrating ambiguity selection using body of function
;($defmulti A! () (A) ($none))
;($defmulti f () (($-> (A) A)) ($none))
;($defmulti f () (($-> (B) B)) ($none))
;
;($do f
;   ($fn (($none)) ($none) (a)
;      ($do A! a)))


;3. Demonstrating calling ambiguous function using ambiguous arguments
;($deftype List (T) ($none))
;($deftype Array (T) ($none))
;($deftype Box (T) ($none))
;($deftype Tree (T) ($none))
;($deftype Int () ($none))
;($deftype String () ($none))
;
;($defmulti map (($cap T) ($cap S)) (($-> (T) ($cap S)) ($of List ($cap T))) ($of List S))
;($defmulti map (($cap T) ($cap S)) (($-> (T) ($cap S)) ($of Array ($cap T))) ($of Array S))
;($defmulti value (($cap T)) (($of Box ($cap T))) T)
;($defmulti value (($cap T)) (($of Tree ($cap T))) String)
;
;($def xs ($?) ($new ($of List ($of Box String))))
;($def result ($none) ($do map value xs))


;4. Demonstrating calling ambiguous function using ambiguous arguments
;($defmulti f () (($-> (A) A)) ($none))
;($defmulti f () (($-> (B) B)) ($none))
;($defmulti g () (A) A)
;($defmulti g () (B) B)
;($def result ($none) ($do f g))

;5. Demonstrating refering to ambiguous functions from LoStanza
;($defmulti f () (($-> (A) A)) ($none))
;($defmulti f () (($-> (B) B)) ($none))
;($defmulti g () (A) A)
;($defmulti g () (B) B)
;($ls-defn lf () (($ls-long)) ($ls-long) (x)
;   ($begin
;      ($ls-do f ($ls-func g))
;      ($ls-return x)))

