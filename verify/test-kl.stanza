#include<"core/stringeater.stanza">
#include<"compiler/stz-algorithms.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">
#include("compiler/stz-utils.stanza")
#include("compiler/stz-ids.stanza")
#include("compiler/stz-kl-ir.stanza")
#include("compiler/stz-kform.stanza")
#include("compiler/stz-padder.stanza")
#include("compiler/stz-tgt-ir.stanza")
#include("compiler/stz-tgt.stanza")
#include("compiler/stz-bb-ir.stanza")
#include("compiler/stz-bb.stanza")
#include("compiler/stz-backend.stanza")
#include("compiler/stz-asm-ir.stanza")
#include("compiler/stz-asm-emitter.stanza")

defpackage stz/test-kl :
   import core
   import stz/kl-ir
   import stz/lexer
   import stz/ids
   import stz/utils
   import stz/kform

;                          Parser
;                          ======

defsyntax kl-ir :
   val ut = unwrap-token

   defn exp-seqs (xs:List<KExp>) :
      if empty?(xs) : error("Empty Begin Expression")
      else if empty?(tail(xs)) : head(xs)
      else : KSeq(head(xs), exp-seqs(tail(xs)), false)
      
   defn comm-seqs (xs:List<KLSComm>) :
      if empty?(xs) : error("Empty Begin Expression")
      else if empty?(tail(xs)) : head(xs)
      else : KLSSeq(head(xs), comm-seqs(tail(xs)))

   defrule :
      sym = (?x) when ut(x) typeof Symbol : ut(x)
      int = (?x) when ut(x) typeof Int : ut(x)

      ;     Special Ints
      ;     ------------
      sint = ($extend-heap) : EXTEND-HEAP-ID
      sint = ($extend-stack) : EXTEND-STACK-ID
      sint = ($fn) : FN-TYPE-ID
      sint = ($int) : INT-TYPE-ID
      sint = ($box) : BOX-TYPE-ID
      sint = ($tuple) : TUPLE-TYPE-ID
      sint = ($type) : TYPE-TYPE-ID
      sint = ($variable-uninitialized-error) : VARIABLE-UNINITIALIZED-ERROR-ID
      sint = ($tuple-length-error) : TUPLE-LENGTH-ERROR-ID
      sint = ($branch-error) : BRANCH-ERROR-ID
      sint = ($cast-error) : CAST-ERROR-ID
      sint = ($arity-error) : ARITY-ERROR-ID
      sint = (?n:#int) : n

      ;     KTypes
      ;     ------
      type = (($var ?n:#int)) : KTVar(n)
      type = (($and ?a:#type ?b:#type)) : KAnd(a, b)
      type = (($or ?a:#type ?b:#type)) : KOr(a, b)
      type = (top) : KTop()
      type = (bot) : KBot()
      type = (($of ?n:#sint)) : KOf(n)

      ;     KCommands
      ;     ---------
      comm = (($def ?x:#int ?v:#exp)) : KDef(x, v) 
      comm = (($defvar ?x:#int)) : KDefVar(x, false)
      comm = (($defvar ?x:#int ?v:#exp)) : KDefVar(x, v)
      comm = (($defcode ?x:#int ?a:#int (?args:#int ...) ?body:#exp ...)) :
         KDefn(x, KCode(fresh-id(), a, args, exp-seqs(body)))
      comm = (($defcode ?x:#int (?a:#int (?args:#int ...) ?body:#exp ...) ...)) :
         val codes = map(KCode{fresh-id(), _, _, exp-seqs(_)}, a, args, body)
         KDefn(x, KMultifn(fresh-id(), codes))
      comm = (($defn ?x:#int (?targs:#int ...) ((?args:#int : ?a1:#type) @...) ?a2:#type
                  ?body:#exp ...)) :
         KDefn(x, KFn(fresh-id(), false, targs, a1, a2, false, args, exp-seqs(body)))
      comm = (($defn* ?x:#int (?targs:#int ...) ((?args:#int : ?a1:#type) @...) ?a2:#type
                  ?body:#exp ...)) :
         KDefn(x, KFn(fresh-id(), true, targs, a1, a2, false, args, exp-seqs(body)))
      comm = (($defmultifn ?x:#int
                 (((?args:#int : ?a1:#type) @...) ?a2:#type
                     ?body:#exp ...) ...)) :
         val a1-str = to-stream(a1)
         val a2-str = to-stream(a2)
         val body-str = to-stream(body)
         val funcs = for a in args map :
            KFn(fresh-id(), false, List(),
                next(a1-str), next(a2-str), false, a,
                exp-seqs(next(body-str)))
         KDefn(x, KMultifn(fresh-id(), funcs))
      comm = (($defmultifn* ?x:#int
                 (((?args:#int : ?a1:#type) @...) ?a2:#type
                     ?body:#exp ...) ...)) :
         val a1-str = to-stream(a1)
         val a2-str = to-stream(a2)
         val body-str = to-stream(body)
         val funcs = for a in args map :
            KFn(fresh-id(), true, List(),
                next(a1-str), next(a2-str), false, a,
                exp-seqs(next(body-str)))
         KDefn(x, KMultifn(fresh-id(), funcs))
               
      ;comm = (($defmulti ?x:#int (?targs:#int ...) (?a1:#type ...))) :
      ;   KDefmulti(x, targs, a1)
      ;this = (($this ?x:#int)) : x
      ;this = () : false
      ;comm = (($defmethod ?m:#int ?t:#this (?targs:#int ...) (?a1:#type ...) (?args:#int ...) ?body:#exp)) :
      ;   KDefmethod(fresh-id(), m, t, KFn(false, targs, a1, args, body))
      ;comm = (($defmethod* ?m:#int ?t:#this (?targs:#int ...) (?a1:#type ...) (?args:#int ...) ?body:#exp)) :
      ;   KDefmethod(fresh-id(), m, t, KFn(true, targs, a1, args, body))
      comm = (($deftype ?x:#int)) : KDefType(x, false)   
      comm = (($deftype ?x:#int ?p:#type)) : KDefType(x, p)
      comm = (($deftypeobj ?n:#int (?args:#int ...) ?t:#type)) :
         KDefTypeObject(n, args, t)
      comm = (($lsdef ?x:#int ?t:#lstype ?v:#lsexp)) :
         KLSDef(x, t, v)
      comm = (($lsdefvar ?x:#int ?t:#lstype)) :
         KLSDefVar(x, t, false)
      comm = (($lsdefvar ?x:#int ?t:#lstype ?v:#lsexp)) :
         KLSDefVar(x, t, v)
      comm = (($lsdefcode ?n:#sint ?a:#int ((?args:#int : ?ts:#lstype) @...) ?body:#lscomm ...)) :
         KLSDefCode(n, a, args, ts, comm-seqs(body))
      comm = (($lsdefn ?n:#sint (?targs:#int ...) ((?args:#int : ?a1:#lstype) @...) ?a2:#lstype 
                 ?body:#lscomm ...)) :
         KLSDefn(false, n, targs, a1, a2, args, comm-seqs(body))
      comm = (($lsdefn* ?n:#sint (?targs:#int ...) ((?args:#int : ?a1:#lstype) @...) ?a2:#lstype 
                 ?body:#lscomm ...)) :
         KLSDefn(true, n, targs, a1, a2, args, comm-seqs(body))
      lsparent = (($parent ?p:#type)) : p
      lsparent = () : false
      lsfield = ((?x:#int ?t:#lstype)) : StructField(x, t)
      lsfield? = (?f:#lsfield) : f
      lsfield? = () : false
      comm = (($lsdeftype ?x:#sint ?p:#lsparent (?f:#lsfield ...) ?rf:#lsfield?)) :
         KLSDefType(x, p, f, rf)
      comm = (($extern ?x:#int ?t:#lstype ?n:#sym)) : KExtern(x, t, n)
      comm = (($init ?cs:#lscomm ...)) : KLSInit(comm-seqs(cs))
      comm = (?e:#exp) : KInit(e)

      ;     KForm Expressions
      ;     -----------------
      fexp = (?n:#int) : n
      fexp = (?e:#exp) : e
      ;exp = (($set ?x:#int ?v:#var)) : KSet(x, v, false)
      exp = (($cast ?x:#exp ?t:#type)) : KCast(x, t, false)
      ;exp = (($begin ?es:#exp ...)) : seqs(es as List<KExp>)
      branch = (((?xs:#int : ?ts:#type) @...) ?body:#exp) : KBranch(xs, ts, body)
      exp = (($dispatch (?xs:#exp ...) ?bs:#branch ...)) : KDispatch(xs, bs, false)
      exp = (($match (?xs:#exp ...) ?bs:#branch ...)) : KMatch(xs, bs, false)
      ;exp = (($new ?c:#type ?m:#comm ...)) : KNew(c, m, false)
      exp = (($do ?a2:#type ?f:#exp (?targs:#type ...) (?args:#exp : ?a1:#type) @...)) :
         KDo(f, targs, args, a1, a2, false)
      ;exp = (($call-ls ?f:#var (?targs:#var ...) ?args:#var ...)) : KCallLS(f, targs, args, false)
      ;exp = (($tuple ?es:#var ...)) : KTuple(es, false)
      ;exp = (($tuple-get ?v:#var ?i:#int)) : KTupleGet(v, i, false)
      exp = (($int-add ?x:#exp ?y:#exp)) : KPrim(INT-ADD-OP, list(x, y), false)
      exp = (($int-sub ?x:#exp ?y:#exp)) : KPrim(INT-SUB-OP, list(x, y), false)
      exp = (($int-mul ?x:#exp ?y:#exp)) : KPrim(INT-MUL-OP, list(x, y), false)
      exp = (($int-div ?x:#exp ?y:#exp)) : KPrim(INT-DIV-OP, list(x, y), false)
      exp = (($int-mod ?x:#exp ?y:#exp)) : KPrim(INT-MOD-OP, list(x, y), false)
      exp = (($int-and ?x:#exp ?y:#exp)) : KPrim(INT-AND-OP, list(x, y), false)
      exp = (($int-or ?x:#exp ?y:#exp)) : KPrim(INT-OR-OP, list(x, y), false)
      exp = (($int-xor ?x:#exp ?y:#exp)) : KPrim(INT-XOR-OP, list(x, y), false)
      exp = (($int-shl ?x:#exp ?y:#exp)) : KPrim(INT-SHL-OP, list(x, y), false)
      exp = (($int-shr ?x:#exp ?y:#exp)) : KPrim(INT-SHR-OP, list(x, y), false)
      exp = (($int-ashr ?x:#exp ?y:#exp)) : KPrim(INT-ASHR-OP, list(x, y), false)
      exp = (($int-eq ?x:#exp ?y:#exp)) : KPrim(INT-EQ-OP, list(x, y), false)
      exp = (($int-ne ?x:#exp ?y:#exp)) : KPrim(INT-NE-OP, list(x, y), false)
      exp = (($int-le ?x:#exp ?y:#exp)) : KPrim(INT-LE-OP, list(x, y), false)
      exp = (($int-lt ?x:#exp ?y:#exp)) : KPrim(INT-LT-OP, list(x, y), false)
      exp = (($int-gt ?x:#exp ?y:#exp)) : KPrim(INT-GT-OP, list(x, y), false)
      exp = (($int-ge ?x:#exp ?y:#exp)) : KPrim(INT-GE-OP, list(x, y), false)
      exp = (($var ?n:#int)) : KVar(n, false)
      exp = (($value ?v)) : KLiteral(ut(v), false)
      exp = (($call ?a:#int ?f:#fexp ?args:#exp ...)) : KCall(false, a, f, args, false)
      exp = (($object ?n:#sint ?args:#exp ...)) : KObject(n, args, false)
      exp = (($object-get ?o:#exp ?i:#int)) : KObjectGet(o, i, false)
      exp = (($box)) : KBox(false, false)
      exp = (($box ?e:#exp)) : KBox(e, false)
      exp = (($box-get ?b:#exp)) : KBoxGet(b, false)
      exp = (($box-set ?b:#exp ?v:#exp)) : KBoxSet(b, v, false)
      exp = (($checkvoid ?e:#exp)) : KCheckVoid(e, false)
      exp = (($checklength ?e:#exp ?n:#int)) : KCheckLength(e, n, false)
      exp = (($tuple ?args:#exp ...)) : KTuple(args, false)
      exp = (($tuple-get ?t:#exp ?i:#int)) : KTupleGet(t, i, false)
      exp = (($closure ?n:#int ?args:#exp ...)) : KClosure(n, args, false)
      exp = (($closure-get ?e:#exp ?i:#int)) : KClosureGet(e, i, false)
      exp = (($branch-error)) : KBranchError(false)
      exp = (($let ?def:#comm ?body:#exp)) : KLet(def, body, false)
      exp = (($letrec (?defs:#comm ...) ?body:#exp)) : KLetRec(defs, body, false)
      exp = (($typeobj ?n:#sint ?args:#exp ...)) : KTypeObject(n, args, false)
      

      ;     KLSTypes
      ;     --------
      lstype = (byte) : KByteT()
      lstype = (int) : KIntT()
      lstype = (long) : KLongT()
      lstype = (float) : KFloatT()
      lstype = (double) : KDoubleT()
      lstype = (?) : KUnknownT()
      lstype = (($ptr ?t:#lstype)) : KPtrT(t)
      lstype = (($ref ?t:#type)) : KRefT(t)
      lstype = (($fn (?a:#lstype ...) ?r:#lstype ?b:#lstype)) : KFnT(a, r, b)
      lstype = (($fn (?a:#lstype ...) ?b:#lstype)) : KFnT(a, false, b)
      lstype = (($struct ?x:#sint)) : KStructT(x)
      
      ;     KLocs
      ;     -----
      loc = (($deref ?e:#lsexp ?t:#lstype)) : Deref(e, t) 
      loc = (($deptr ?e:#lsexp ?t:#lstype)) : Deptr(e, t)
      loc = (($slot ?e:#lsexp ?t:#lstype ?i:#lsexp)) : Slot(e, t, i)
      loc = (($field ?b:#loc ?x:#int)) : Field(b, x)
      loc = (?e:#lsexp) : Value(e)

      ;     LoStanza Commands
      ;     -----------------
      lscomm = (($set ?e:#loc ?v:#lsexp)) : KLSSet(e, v)
      lscomm = (($label ?x:#int)) : KLSLabel(x)
      lscomm = (($goto ?x:#int)) : KLSGoto(x)
      lscomm = (($return ?x:#lsexp)) : KLSReturn(x)
      lscomm = (($def ?n:#int ?v:#lsexp)) : KLSDefLocal(n, v)
      lscomm = (($defvar ?n:#int ?t:#lstype)) : KLSDefLocalVar(n, t, false)
      lscomm = (($defvar ?n:#int ?t:#lstype ?v:#lsexp)) : KLSDefLocalVar(n, t, v)
      lscomm = (($begin ?cs:#lscomm ...)) : comm-seqs(cs)
      lscomm = (($if ?p:#lsexp ?c:#lscomm ?a:#lscomm)) : KLSIf(p, c, a)
      lscomm = (($if ?p:#lsexp ?c:#lscomm)) : KLSIf(p, c, KLSSkip())
      lsbranch = (((?args:#int : ?ts:#type) @...) ?body:#lscomm) :
         KLSBranch(args, ts, body)
      lscomm = (($match (?args:#lsexp ...) ?b:#lsbranch ...)) : KLSMatch(args, b)
      ;Intrinsics
      lscomm = (($set-heap-lim ?x:#lsexp)) : KLSPrimComm(SET-HEAP-LIM, list(x))
      lscomm = (($set-heap-ptr ?x:#lsexp)) : KLSPrimComm(SET-HEAP-PTR, list(x))
      lscomm = (?e:#lsexp) : KLSCallComm(e)

      ;     LoStanza Expressions
      ;     --------------------
      farg = (?n:#int) : n
      farg = (?e:#lsexp) : e
      lsexp = (($ref ?x:#int ?args:#lsexp ...)) : KLSRef(x, args)
      lsexp = (($refarray ?x:#int ?len:#lsexp ?args:#lsexp ...)) : KLSRefArray(x, len, args)
      lsexp = (($struct ?x:#int ?args:#lsexp ...)) : KLSStruct(x, args)
      lsexp = (($ptr ?e:#loc)) : KLSPtr(e)
      lsexp = (($read ?e:#loc)) : KLSRead(e)
      lsexp = (($call-c ?t:#lstype ?f:#farg ?args:#lsexp ...)) : KLSCallC(f, args, t)
      lsexp = (($call ?t:#lstype ?f:#farg (?ts:#lstype ...) ?args:#lsexp ...)) :
         KLSCall(f, ts, args, t)
      lsexp = (($call-closure ?t:#lstype ?f:#farg (?ts:#lstype ...) ?args:#lsexp ...)) :
         KLSCallClosure(f, ts, args, t)
      lsexp = (($wcall ?a:#int ?t:#lstype ?f:#farg ?args:#lsexp ...)) :
         KLSWCall(false, a, f, args, t)
      lsexp = (($wcall* ?a:#int ?t:#lstype ?f:#farg ?args:#lsexp ...)) :
         KLSWCall(true, a, f, args, t)
      lsexp = (($wcall-closure ?a:#int ?t:#lstype ?f:#lsexp ?args:#lsexp ...)) :
         KLSWCallClosure(false, a, f, args, t)
      lsexp = (($wcall-closure* ?a:#int ?t:#lstype ?f:#lsexp ?args:#lsexp ...)) :
         KLSWCallClosure(true, a, f, args, t)
      lsexp = (($sizeof ?t:#lstype)) : KLSSizeof(t)
      lsexp = (($tagof ?x:#int)) : KLSTagof(x)
      lsexp = (($conv ?x:#lsexp ?t:#lstype)) : KLSConv(x, t)
      lsexp = (($cast ?x:#lsexp ?t:#type)) : KLSCast(x, t)
      lsexp = (($typeobj ?n:#sint ?args:#lsexp ...)) : KLSTypeObject(n, args)      
      lsexp = (($add ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(ADD-OP, list(x, y), t)
      lsexp = (($sub ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(SUB-OP, list(x, y), t)
      lsexp = (($mul ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(MUL-OP, list(x, y), t)
      lsexp = (($div ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(DIV-OP, list(x, y), t)
      lsexp = (($mod ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(MOD-OP, list(x, y), t)
      lsexp = (($and ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(AND-OP, list(x, y), t)
      lsexp = (($or ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(OR-OP, list(x, y), t)
      lsexp = (($xor ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(XOR-OP, list(x, y), t)
      lsexp = (($shl ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(SHL-OP, list(x, y), t)
      lsexp = (($shr ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(SHR-OP, list(x, y), t)
      lsexp = (($ashr ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(ASHR-OP, list(x, y), t)
      lsexp = (($eq ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(EQ-OP, list(x, y), t)
      lsexp = (($ne ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(NE-OP, list(x, y), t)
      lsexp = (($lt ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(LT-OP, list(x, y), t)
      lsexp = (($gt ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(GT-OP, list(x, y), t)
      lsexp = (($le ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(LE-OP, list(x, y), t)
      lsexp = (($ge ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(GE-OP, list(x, y), t)
      lsexp = (($ult ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(ULT-OP, list(x, y), t)
      lsexp = (($ugt ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(UGT-OP, list(x, y), t)
      lsexp = (($ule ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(ULE-OP, list(x, y), t)
      lsexp = (($uge ?t:#lstype ?x:#lsexp ?y:#lsexp)) : KLSPrim(UGE-OP, list(x, y), t)
      lsexp = (($string ?v)) : KLSLitString(ut(v))
      lsexp = (($float ?v)) : KLSLitFloat(ut(v))
      lsexp = (($double ?v)) : KLSLitDouble(ut(v))
      lsexp = (($int ?v)) : KLSLitInt(ut(v))
      lsexp = (($byte ?v)) : KLSLitByte(ut(v))
      lsexp = (($long ?v)) : KLSLitLong(ut(v))      
      lsexp = (($var ?x:#int)) : KLSVar(x)
      ;Intrinsics
      lsexp = (($heap-lim)) : KLSPrim(GET-HEAP-LIM, List(), KLongT())
      lsexp = (($heap-ptr)) : KLSPrim(GET-HEAP-PTR, List(), KLongT())
      


defn parse-kl-ir (file:String) -> List<KeyValue<Symbol,KProg>> :
   val lexed = lex-file(file)
   with-syntax(kl-ir) :
      match-syntax(lexed) :
         ((program ?ns:#sym :
              ?css:#comm ...) @...) :
            for (n in ns, cs in css) map :
               n => KProg(cs)


;                          Main Driver
;                          ===========
      
defn main () :
   val filename = commandline-arguments()[1]
   val name = to-symbol(commandline-arguments()[2])
   val program = lookup!(parse-kl-ir(filename), name)
   
   headline("Program")
   println(program)

   headline("Compile")

   #if-defined(LOWERED) :
      compile-lowered-form(program, "test.s")
   #else :
      compile(program, "test.s")

main()