#include("core/stringeater.stanza")
#include("compiler/stz-lexer.stanza")
#include("compiler/stz-parser.stanza")
#include("compiler/stz-algorithms.stanza")
#include("compiler/stz-il-ir.stanza")
#include("compiler/stz-utils.stanza")
#include("compiler/stz-ids.stanza")
#include("compiler/stz-input.stanza")
#include("compiler/lang-read.stanza")
#include("compiler/lang-check.stanza")
#include("compiler/stz-namemap.stanza")
#include("compiler/stz-renamer.stanza")
#include("compiler/stz-primitives.stanza")
#include("compiler/stz-resolver.stanza")
#include("compiler/stz-tl-ir.stanza")
#include("compiler/stz-type.stanza")
#include("compiler/stz-infer.stanza")
#include("compiler/stz-type-calculus.stanza")

;KType onwards
#include("compiler/stz-kl-ir.stanza")
#include("compiler/stz-kform.stanza")
#include("compiler/stz-padder.stanza")
#include("compiler/stz-tgt-ir.stanza")
#include("compiler/stz-tgt.stanza")
#include("compiler/stz-bb-ir.stanza")
#include("compiler/stz-bb.stanza")
#include("compiler/stz-backend.stanza")
#include("compiler/stz-asm-ir.stanza")
#include("compiler/stz-asm-emitter.stanza")


defpackage stz/test-type-kl :
   import core
   import verse
   import stz/il-ir
   import stz/input
   import stz/lexer
   import stz/renamer
   import stz/resolver
   import stz/type
   import stz/kform
   import stz/primitives

defstruct Common :
   name:Symbol
   exps:List
defstruct Prog :
   name:Symbol
   common:False|Symbol
   exps:List
defstruct Repo :
   common: List<Common>
   progs: List<Prog>

defn prog (r:Repo, progname:Symbol) :
   val p = let :
      val p = for p in progs(r) find : name(p) == progname
      error("No program by the name of ~" % [progname]) when p == false
      p as Prog
   val c = match(common(p)) :
      (c:Symbol) :
         val cm = for cm in common(r) find : c == name(cm)
         error("No common by the name of ~" % [c]) when cm == false
         cm as Common
      (c:False) : false
   match(c) :
      (c:Common) : List(`$begin, append(exps(c), exps(p)))
      (c:False) : List(`$begin, exps(p))   

defsyntax test-ir :
   val ut = unwrap-token
   defrule :   
      sym = (?x) when ut(x) typeof Symbol : ut(x)

      clause = (common ?name:#sym : (?exps ...)) :
         Common(name, exps)
      clause = (program ?name:#sym (?common:#sym) : (?exps ...)) :
         Prog(name, common, exps)
      clause = (program ?name:#sym : (?exps ...)) :
         Prog(name, false, exps)
         
      prog = (?clauses:#clause ...) :
         defn grab (f) : to-list(filter(f, clauses))
         Repo(grab({_ typeof Common}),
              grab({_ typeof Prog}))
   
defn parse-programs (file:String) -> Repo :
   val lexed = lex-file(file)
   with-syntax(test-ir) :
      match-syntax(lexed) :
         (?repo:#prog) : repo

defn main () -> ? :
   val filename = commandline-arguments()[1]
   val name = to-symbol(commandline-arguments()[2])
   val form = prog(parse-programs(filename), name)
   
   println("Reading:")
   println(form)
   println("Result:")
   try :
      val f = read(form)
      println(f)
      check(f)
      val [namemap renamed] = rename(f)
      println(renamed)
      val resolved = resolve(namemap, renamed)
      println(resolved)
      val typed = type-program(namemap, resolved)
      println(typed)
      compile(typed, namemap, "test.s")
   catch (e) :
      false
   println("\n")

main()
