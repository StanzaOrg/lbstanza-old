#include<"core/stringeater.stanza">
#include<"compiler/stz-algorithms.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">
#include("compiler/stz-utils.stanza")
#include("compiler/stz-tgt-ir.stanza")
#include("compiler/stz-tgt.stanza")
#include("compiler/stz-bb-ir.stanza")
#include("compiler/stz-bb.stanza")
#include("compiler/stz-asm-ir.stanza")
#include("compiler/stz-asm-emitter.stanza")
#include("compiler/stz-padder.stanza")
#include("compiler/stz-backend.stanza")

defpackage stz/test-tgt :
   import core
   import verse
   import stz/lexer
   import stz/utils   
   import stz/tgt-ir
   import stz/tgt


;                            Parser
;                            ======

defsyntax tgt-ir :
   val ut = unwrap-token

   val sym-table = HashTable<Symbol,Int>(symbol-hash)
   defn sym-num (x:Symbol) :
      match(get?(sym-table, x, false)) :
         (n:Int) :
            n
         (f:False) :
            val n = fresh-id()
            sym-table[x] = n
            n         

   defrule :
      sym = (?x) when ut(x) typeof Symbol : ut(x)
      int = (?x) when ut(x) typeof Int : ut(x)
      flt = (?x) when ut(x) typeof Float : ut(x)

      imm = (int(?n:#int)) : IntImm(n)
      imm = (mem<?x:#sym>) : Mem(sym-num(x))
      imm = (xmem<?x:#sym>) : ExMem(x)
      imm = (?x:#sym) : Var(sym-num(x))

      op = (add) : ADD-OP
      op = (sub) : SUB-OP
      op = (mul) : MUL-OP
      op = (div) : DIV-OP
      op = (mod) : MOD-OP
      op = (and) : AND-OP
      op = (or) : OR-OP
      op = (xor) : XOR-OP
      op = (shl) : SHL-OP
      op = (shr) : SHR-OP
      op = (ashr) : ASHR-OP
      op = (eq) : EQ-OP
      op = (ne) : NE-OP
      op = (lt) : LT-OP
      op = (gt) : GT-OP
      op = (le) : LE-OP
      op = (ge) : GE-OP
      op = (ule) : ULE-OP
      op = (ult) : ULT-OP
      op = (ugt) : UGT-OP
      op = (uge) : UGE-OP

      ins = (?x:#imm = load(?y:#imm, ?o:#int)) : Load(x, y, o)
      ins = (store(?x:#imm, ?y:#imm, ?o:#int)) : Store(x, y, o)
      ins = (?x:#imm = ?op:#op(?y:#imm, ?z:#imm)) : BinOp(x, op, y, z)
      ins = ((?xs:#imm ...) = Args) : ArgsIns(xs)
      ins = ((?xs:#imm ...) = callc ?f:#imm(?ys:#imm ...)) : CallC(0, xs, f, ys)
      ins = ((?xs:#imm ...) = ?f:#imm(?ys:#imm ...) / ?n:#int) : Call(n, xs, f, ys)
      ins = ((?xs:#imm ...) = ?f:#imm(?ys:#imm ...)) : Call(length(ys), xs, f, ys)
      ins = (?x:#imm = ?y:#imm) : SetIns(x, y)
      ins = (return (?xs:#imm ...)) : Return(xs)
      ins = (label<?n:#sym>) : Label(sym-num(n))
      ins = (goto label<?n:#sym>) : Goto(sym-num(n))
      ins = (branch label<?n:#sym> when ?op:#op(?x:#imm, ?y:#imm)) : Branch(sym-num(n), op, x, y)

      type = (byte) : BYTE-TYPE
      type = (int) : INT-TYPE
      type = (long) : LONG-TYPE
      type = (float) : FLOAT-TYPE
      type = (double) : DOUBLE-TYPE
      type = (ref) : REF-TYPE

      defvar = (?x:#sym : ?t:#type) : DefVar(sym-num(x), t)

      defins = (defn ?f:#sym :
                   locals: (?locals:#defvar ...)
                   ?body:#ins ...) :
         DefFn(sym-num(f), to-vector(locals), to-vector(body))
      defins = (label<?x:#sym>) :
         TLabel(sym-num(x))
      defins = (deffloat ?x:#flt) :
         DefFloat(x)
      defins = (defdouble ?x:#flt) :
         DefDouble(x)

      program = (program(?e:#sym) :
                    ?ins:#defins ...) :
         Program(to-vector(ins), sym-num(e))


defn parse-tgt-ir (file:String) :
   val lexed = lex-file(file)
   with-syntax(tgt-ir) :
      match-syntax(lexed) :
         (?p:#program) : p


;                          Main Driver
;                          ===========
      
defn main () :
   val filename = commandline-arguments()[1]
   val program = parse-tgt-ir(filename)
   
   headline("Program")
   println(program)

   headline("Compilation")
   compile(program, "test.s")   

main()