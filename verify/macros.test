program print-int2 :
   defpackage user         
   extern print_int: int -> int
   lostanza: call-c print_int(42)

program def :
   defpackage core
   public lostanza deftype Int :
      value: int

   lostanza defn cast-error () -> int :
      return 0

   defpackage user :
      import core
   extern print_int: ref<Int> -> int
   val x = 32
   lostanza: call-c print_int(x)

program lsdefn :
   defpackage core
   public :
      lostanza deftype Int :
         value: int
      lostanza deftype False
      
   lostanza defn cast-error () -> int :
      return 0

   defpackage user :
      import core
   extern printf: (ptr<byte>, ? ...) -> int
   lostanza defn myfunction () -> int :
      call-c printf("Hello World\n")
      return 0
      
   lostanza: myfunction()

program voidcheck :
   defpackage core
   public :
      lostanza deftype Int :
         value: int
      lostanza deftype False

   extern printf: (ptr<byte>, ? ...) -> int
   extern exit: int -> int
   lostanza defn cast-error () -> int :
      return 0
   lostanza defn variable-uninitialized-error () -> int :
      call-c printf("Variable Uninitialized\n")
      call-c exit(-1)
      return 0

   defpackage user :
      import core
   var X:?
   val Y = X

common basic0 :
   defpackage core
   public :
      lostanza deftype Int :
         value: int
      lostanza deftype False
      lostanza deftype Fn :
         code: ptr<?>
         free: ref<?> ...
         
   public extern printf : (ptr<byte>, ? ...) -> int
   extern malloc: long -> ptr<?>
   extern exit: int -> int

   lostanza defn cast-error () -> int :
      call-c printf("Cast Error\n")
      call-c exit(-1)
      return 0
      
   lostanza defn arity-error () -> int :
      call-c printf("Arity Error\n")
      call-c exit(-1)
      return 0

   lostanza defn variable-uninitialized-error () -> int :
      call-c printf("Variable Uninitialized\n")
      call-c exit(-1)
      return 0      

   defpackage user :
      import core         

program new (basic0) :
   lostanza var F:ref<False> = new False{}
   lostanza: call-c printf("F = 0x%lx\n", F)

program fn (basic0) :
   lostanza defn print-random () -> ref<False> :
      call-c printf("Random Message\n")
      return new False{}
      
   defn myfunction () :
      print-random()

   myfunction()

program ls-add (basic0) :
   lostanza:
      call-c printf("Result = %ld\n", (3 as long) + (39 as long))

common basic1 :
   defpackage core
   public :
      lostanza deftype Int :
         value:int
      lostanza deftype False
      lostanza deftype True
      lostanza deftype Box :
         item: ref<?>
      lostanza deftype Fn :
         code: ptr<?>
         free: ref<?> ...
      lostanza deftype Type :
         code: ptr<?>
         free: ref<?> ...
         
   public extern printf: (ptr<byte>, ? ...) -> int
   extern malloc: long -> ptr<?>
   extern exit: int -> int

   lostanza defn cast-error () -> int :
      call-c printf("Cast Error\n")
      call-c exit(-1)
      return 0

   lostanza defn arity-error () -> int :
      call-c printf("Arity Error\n")
      call-c exit(-1)
      return 0

   lostanza defn branch-error () -> int :
      call-c printf("Branch Error\n")
      call-c exit(-1)
      return 0

   lostanza defn variable-uninitialized-error () -> int :
      call-c printf("Variable Uninitialized Error\n")
      call-c exit(-1)
      return 0

   ;Initialize heap
   lostanza :
      val heap-mem = call-c malloc(1048576 as long)
      call-prim set-heap(heap-mem)
      call-prim set-heap-limit(heap-mem + (1048576 as long))

   ;Extend heap
   lostanza defn extend-heap (sz:long) -> long :
      call-c printf("Extend heap\n")
      call-c exit(-1)
      return (0 as long)

   defpackage user :
      import core


program global-closure (basic1) :
   lostanza defn print-random () -> ref<False> :
      call-c printf("Random Message\n")
      return new False{}
      
   defn myfunction () :
      print-random()

   val closure = myfunction
   closure()

   val closure2 = print-random
   closure2()
      

program arity (basic1) :
   lostanza defn print-random () -> ref<False> :
      call-c printf("Random Message\n")
      return new False{}

   defn myfunction () :
      print-random()

   val closure:? = myfunction
   closure(0)

program not-a-function (basic1) :
   val closure:? = 0
   closure(0)

program multifns (basic1) :
   lostanza defn print-int (x:ref<Int>) -> ref<False> :
      call-c printf("X = %ld\n", x)
      return new False{}
      
   val closure:? = multifn :
      () : print-int(0)
      (x:Int) : print-int(x)

   closure()
   closure(42)
   closure(42, 84)

program new-struct (basic1) :
   lostanza deftype MyStruct :
      x:int
      y:int
      
   lostanza defn make-struct (x:int, y:int) -> ref<MyStruct> :
      val s = new MyStruct{x, y}
      return s

   lostanza :
      val s1 = make-struct(10, 30)
      val s2 = make-struct(40, 50)
      call-c printf("s1 = (%d, %d)\n", s1.x, s1.y)
      call-c printf("s2 = (%d, %d)\n", s2.x, s2.y)

program new-array (basic1) :
   lostanza deftype MyArray :
      items:int ...

   lostanza val zero:long = 0 as long
   lostanza val one:long = 1 as long
   lostanza val two:long = 2 as long
   lostanza val three:long = 3 as long

   lostanza defn make-array () -> ref<MyArray> :
      val a = new MyArray{}[three]
      a.items[zero] = 42
      a.items[one] = 43
      a.items[two] = 44
      return a
      
   lostanza defn array-length (x:ref<?>) -> long :
      var p: ptr<long> = x as ptr<long>
      p = p - (9 as long)
      return [p]
      
   lostanza :
      val a = make-array()
      call-c printf("a[0] = %d\n", a.items[zero])
      call-c printf("a[1] = %d\n", a.items[one])
      call-c printf("a[2] = %d\n", a.items[two])
      call-c printf("length word = %d\n", array-length(a))

program histanza-from-lostanza (basic1) :
   lostanza defn say-hi () -> ref<False> :
      call-c printf("Hi!\n")
      return new False{}
   defn say-hi-twice () :
      val f = say-hi
      f()
      f()
   lostanza :
      val f = fn(say-hi-twice)
      [f]()

program parametric-structs (basic1) :
   lostanza deftype MyBox<T> :
      item: ref<T>
   lostanza val NUM:ref<Int> = 336 as long as ref<Int>
   lostanza val FALSE:ref<False> = new False{}
   lostanza val BOXED-FALSE:ref<MyBox<False>> = new MyBox<False>{FALSE}
   lostanza val BOXED-NUM:ref<MyBox<Int>> = new MyBox<Int>{NUM}
   lostanza defn item<?T> (box:ref<MyBox<?T>>) -> ref<T> :
      return box.item
      
   item(BOXED-NUM)
   item(BOXED-FALSE as ? as MyBox<Int>)

program curried-globals (basic1) :
   lostanza deftype MyBox<T> :
      item: ref<T>
   lostanza val NUM:ref<Int> = 336 as long as ref<Int>
   lostanza val FALSE:ref<False> = new False{}
   lostanza val BOXED-FALSE:ref<MyBox<False>> = new MyBox<False>{FALSE}
   lostanza val BOXED-NUM:ref<MyBox<Int>> = new MyBox<Int>{NUM}
   lostanza defn item<?T> (box:ref<MyBox<?T>>) -> ref<T> :
      return box.item

   defn apply (f: MyBox<Int> -> Int, b: MyBox<Int>) :
      f(b)
   apply(item, BOXED-FALSE)

program curried-ls-globals (basic1) :
   lostanza deftype MyBox<T> :
      item: ref<T>
   lostanza val NUM:ref<Int> = 336 as long as ref<Int>
   lostanza val FALSE:ref<False> = new False{}
   lostanza val BOXED-FALSE:ref<MyBox<False>> = new MyBox<False>{FALSE}
   lostanza val BOXED-NUM:ref<MyBox<Int>> = new MyBox<Int>{NUM}
   lostanza defn item<?T> (box:ref<MyBox<?T>>) -> ref<T> :
      return box.item

   defn apply (f: MyBox<Int> -> Int, b: MyBox<Int>) :
      f(b)
   lostanza: apply(fn(item), BOXED-NUM)

program and-or-types (basic1) :
   defn check<T> (x:T) :
      x
      
   defn check2<T,S> (x:?) :
      check<T|S>(x)

   lostanza val FALSE:ref<False> = new False{}
   lostanza val TRUE:ref<True> = new True{}
   check2<Int,False>(FALSE)
   check2<Int,False>(42)
   check2<Int,False>(TRUE)

program no-method (basic1) :
   lostanza defn say-hi () -> ref<False> :
      call-c printf("Hi\n")
      return new False{}
   defmulti hi () -> False
   hi()

program one-method (basic1) :
   lostanza defn say-hi () -> ref<False> :
      call-c printf("Hi\n")
      return new False{}
      
   defmulti hi () -> False
   defmethod hi () :
      say-hi()

   hi()

program two-methods (basic1) :
   lostanza val FALSE:ref<False> = new False{}
   lostanza defn say-hi () -> ref<False> :
      call-c printf("Hi\n")
      return new False{}
   lostanza defn say-int (x:ref<Int>) -> ref<False> :
      call-c printf("X = %d\n", (x as long) >> (3 as long))
      return new False{}
   
   defmulti hi (?) -> False
   defmethod hi (x:False) :
      say-hi()
   defmethod hi (x:Int) :
      say-int(x)

   hi(FALSE)
   hi(42)
   hi(FALSE)
   hi(40)

program instance-methods (basic1) :
   lostanza defn say-int (x:ref<Int>) -> ref<False> :
      call-c printf("X = %d\n", (x as long) >> (3 as long))
      return new False{}

   deftype Animal
   defmulti bark (x:Animal) -> False
   defmethod bark (x:Animal) : say-int(0)

   defn Dog (x:Int) :
      new Animal :
         defmethod bark (this) : say-int(x)

   bark(new Animal)
   bark(Dog(10))
   bark(Dog(14))

program nested-functions (basic1) :
   lostanza defn say-int (x:ref<Int>) -> ref<False> :
      call-c printf("X = %d\n", (x as long) >> (3 as long))
      return new False{}

   defn function (x:Int) :
      defn nested () :
         say-int(x)
      nested()
      nested()
      
   function(10)
   function(13)


program escaping-nested-functions (basic1) :
   lostanza defn say-int (x:ref<Int>) -> ref<False> :
      call-c printf("X = %d\n", (x as long) >> (3 as long))
      return new False{}

   defn function (x:Int) :
      defn nested () :
         say-int(x)
      nested

   val f = function(10)
   f()
   f()
         
program chained-inference (basic1) :
   lostanza val FALSE:ref<False> = new False{}
   lostanza defn say-int (x:ref<Int>) -> ref<False> :
      call-c printf("X = %d\n", (x as long) >> (3 as long))
      return new False{}

   defn call<?T,?S> (f: () -> ?T, g: T -> ?S) :
      g(f())

   call(
      fn () : 42
      fn (x) : say-int(x))

program closure-setting (basic1) :
   lostanza val FALSE:ref<False> = new False{}
   lostanza defn say-int (x:ref<Int>) -> ref<False> :
      call-c printf("X = %d\n", (x as long) >> (3 as long))
      return new False{}
   lostanza defn inc (x:ref<Int>) -> ref<Int> :
      return ((x as long) + (8 as long)) as ref<Int>

   defn counter () :
      var x = 0
      fn () :
         say-int(x)
         x = inc(x)

   val c = counter()
   c()
   c()
   c()
   c()

program mixing (basic1) :
   lostanza val FALSE:ref<False> = new False{}
   lostanza val TRUE:ref<True> = new True{}
   lostanza defn say-int (x:ref<Int>) -> ref<False> :
      call-c printf("X = %d\n", (x as long) >> (3 as long))
      return new False{}
   lostanza defn say-int (x:ref<False>) -> ref<False> :
      call-c printf("False!\n")
      return new False{}
      
   defn f (x) :
      say-int(x)

   lostanza defn g (x:ref<?>) -> ref<False> :
      return
         (let :
            call-c printf("Hi\n")
            say-int)(x)

   f(FALSE)
   f(42)
   g(FALSE)
   g(40)


program partial-mixing (basic1) :
   lostanza val FALSE:ref<False> = new False{}
   lostanza val TRUE:ref<True> = new True{}

   lostanza defn say-two (x:ref<False>, y:int) -> ref<False> :
      call-c printf("False arg = %ld\n", x)
      call-c printf("Int arg = %d\n", y)
      return new False{}

   lostanza defn say-two (x:ref<True>, y:int) -> ref<False> :
      call-c printf("True arg = %ld\n", x)
      call-c printf("Int arg = %d\n", y)
      return new False{}

   lostanza defn f (x:ref<?>, y:int) -> ref<False> :
      return say-two(x, y)

   lostanza :
      f(FALSE, 4)
      f(TRUE, 5)
      f(FALSE, 4)
      f(TRUE, 5)
      f(FALSE, 4)
      f(TRUE, 5)
