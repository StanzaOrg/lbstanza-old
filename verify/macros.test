program print-int2 :
   defpackage user         
   extern print_int: int -> int
   lostanza: call-c print_int(42)

program def :
   defpackage core
   public lostanza deftype Int :
      value: int

   lostanza defn cast-error () -> int :
      return 0

   defpackage user :
      import core
   extern print_int: ref<Int> -> int
   val x = 32
   lostanza: call-c print_int(x)

program lsdefn :
   defpackage core
   public :
      lostanza deftype Int :
         value: int
      lostanza deftype False
      
   lostanza defn cast-error () -> int :
      return 0

   defpackage user :
      import core
   extern printf: (ptr<byte>, ? ...) -> int
   lostanza defn myfunction () -> int :
      call-c printf("Hello World\n")
      return 0
      
   lostanza: myfunction()

program voidcheck :
   defpackage core
   public :
      lostanza deftype Int :
         value: int
      lostanza deftype False

   extern printf: (ptr<byte>, ? ...) -> int
   extern exit: int -> int
   lostanza defn cast-error () -> int :
      return 0
   lostanza defn variable-uninitialized-error () -> int :
      call-c printf("Variable Uninitialized\n")
      call-c exit(-1)
      return 0

   defpackage user :
      import core
   var X:?
   val Y = X

common basic0 :
   defpackage core
   public :
      lostanza deftype Int :
         value: int
      lostanza deftype False
      lostanza deftype Fn :
         code: ptr<?>
         free: ref<?> ...
         
   public extern printf : (ptr<byte>, ? ...) -> int
   extern malloc: long -> ptr<?>
   extern exit: int -> int

   lostanza defn cast-error () -> int :
      call-c printf("Cast Error\n")
      call-c exit(-1)
      return 0
      
   lostanza defn arity-error () -> int :
      call-c printf("Arity Error\n")
      call-c exit(-1)
      return 0

   lostanza defn variable-uninitialized-error () -> int :
      call-c printf("Variable Uninitialized\n")
      call-c exit(-1)
      return 0      

   defpackage user :
      import core         

program new (basic0) :
   lostanza var F:ref<False> = new False{}
   lostanza: call-c printf("F = 0x%lx\n", F)

program fn (basic0) :
   lostanza defn print-random () -> ref<False> :
      call-c printf("Random Message\n")
      return new False{}
      
   defn myfunction () :
      print-random()

   myfunction()

;program ls-add (basic0) :
;   ($ls-call-c printf "Result = %ld\n"
;      ($ls-prim add ($ls-as 3 ($ls-long)) ($ls-as 39 ($ls-long))))
;
;common basic1 :
;   ($package core)
;   ($public
;      ($ls-deftype Int ($none)
;         (value) ($none)
;         (($ls-int)) ($none))
;      ($ls-deftype False ($none)
;         () ($none)
;         () ($none))
;      ($ls-deftype True ($none)
;         () ($none)
;         () ($none))
;      ($ls-deftype Box ($none)
;         (item) ($none)
;         (($ls-ref ($?))) ($none))            
;      ($ls-deftype Fn ($none)
;         (code) free
;         (($ls-ptr ($ls-?))) ($ls-ref ($?)))
;      ($ls-deftype Type ($none)
;         (code) free
;         (($ls-ptr ($ls-?))) ($ls-ref ($?))))
;
;   ($public ($ls-extern printf ($ls-fn (($ls-ptr ($ls-byte))) ($ls-?) ($ls-int))))
;   ($ls-extern malloc ($ls-fn (($ls-long)) ($none) ($ls-ptr ($ls-?))))
;   ($ls-extern exit ($ls-fn (($ls-int)) ($none) ($ls-int)))
;
;   ($ls-defn cast-error () () ($ls-int)
;      ($ls-call-c printf "Cast Error\n")
;      ($ls-call-c exit -1)
;      ($ls-return 0))
;
;   ($ls-defn arity-error () () ($ls-int)
;      ($ls-call-c printf "Arity Error\n")
;      ($ls-call-c exit -1)
;      ($ls-return 0))
;
;   ($ls-defn branch-error () () ($ls-int)
;      ($ls-call-c printf "Branch Error\n")
;      ($ls-call-c exit -1)
;      ($ls-return 0))
;         
;   ($ls-defn variable-uninitialized-error () () ($ls-int)
;      ($ls-call-c printf "Variable Uninitialized\n")
;      ($ls-call-c exit -1)
;      ($ls-return 0))
;
;   ;Initialize heap
;   ($ls-let
;      ($ls-def heap-mem ($none) ($ls-call-c malloc ($ls-as 1048576 ($ls-long))))
;      ($ls-prim set-heap heap-mem)
;      ($ls-prim set-heap-limit ($ls-prim add heap-mem ($ls-as 1048576 ($ls-long)))))
;
;   ($ls-defn extend-heap (sz) (($ls-long)) ($ls-long)
;      ($ls-call-c printf "Extend Heap\n")
;      ($ls-call-c exit -1)
;      ($ls-return ($ls-as 0 ($ls-long))))
;      
;   ($package user
;      ($import core))   
;
;program global-closure (basic1) :
;   ($ls-defn print-random () () ($ls-ref False)
;      ($ls-call-c printf "Random Message\n")
;      ($ls-return ($ls-new False)))
;
;   ($defn myfunction () () ($none)
;      ($do print-random))
;
;   ($def closure ($none) myfunction)
;   ($do closure)
;
;program arity (basic1) :
;   ($ls-defn print-random () () ($ls-ref False)
;      ($ls-call-c printf "Random Message\n")
;      ($ls-return ($ls-new False)))
;
;   ($defn myfunction () () ($none)
;      ($do print-random))
;
;   ($def closure ($?) myfunction)
;   ($do closure 0)
;
;program not-a-function (basic1) :
;   ($def closure ($?) 0)
;   ($do closure 0)
;
;program multifns (basic1) :
;   ($ls-defn print-int (x) (($ls-ref Int)) ($ls-ref False)
;      ($ls-call-c printf "X = %ld\n", x)
;      ($ls-return ($ls-new False)))
;    
;   ($def closure ($?)
;      ($multi
;         ($fn () () ($none)
;            ($do print-int 0))
;         ($fn (x) (Int) ($none)
;            ($do print-int x))))
;
;   ($do closure)
;   ($do closure 42)
;   ($do closure 42 84)
;
;program new-struct (basic1) :
;   ($ls-deftype MyStruct ($none)
;      (x y) ($none)
;      (($ls-int) ($ls-int)) ($none))
;      
;   ($ls-defn make-struct (x, y) (($ls-int) ($ls-int)) ($ls-ref MyStruct)
;      ($ls-def s ($none) ($ls-new MyStruct x y))
;      ($ls-return s))
;
;   ($ls-let
;      ($ls-def s1 ($none) ($ls-do make-struct 10 30))
;      ($ls-def s2 ($none) ($ls-do make-struct 40 50))
;      ($ls-call-c printf "s1 = (%d, %d)\n" ($ls-field s1 x) ($ls-field s1 y))
;      ($ls-call-c printf "s2 = (%d, %d)\n" ($ls-field s2 x) ($ls-field s2 y)))
;
;program new-array (basic1) :
;   ($ls-deftype MyArray ($none)
;      () items
;      () ($ls-int))      
;
;   ($ls-def zero ($ls-long) ($ls-as 0 ($ls-long)))
;   ($ls-def one ($ls-long) ($ls-as 1 ($ls-long)))
;   ($ls-def two ($ls-long) ($ls-as 2 ($ls-long)))
;   ($ls-def three ($ls-long) ($ls-as 3 ($ls-long)))
;   
;   ($ls-defn make-array () () ($ls-ref MyArray)
;      ($ls-def a ($none) ($ls-array MyArray () three))
;      ($ls-set ($ls-slot ($ls-field a items) zero) 42)
;      ($ls-set ($ls-slot ($ls-field a items) one) 43)
;      ($ls-set ($ls-slot ($ls-field a items) two) 44)
;      ($ls-return a))
;
;   ($ls-defn array-length (x) (($ls-ref ($?))) ($ls-long)
;      ($ls-defvar p ($ls-ptr ($ls-long)) ($ls-as x ($ls-ptr ($ls-long))))
;      ($ls-set p ($ls-prim add p ($ls-as -9 ($ls-long))))
;      ($ls-return ($ls-deref p)))
;
;   ($ls-let
;      ($ls-def a ($none) ($ls-do make-array))
;      ($ls-call-c printf "a[0] = %d\n" ($ls-slot ($ls-field a items) zero))
;      ($ls-call-c printf "a[1] = %d\n" ($ls-slot ($ls-field a items) one))
;      ($ls-call-c printf "a[2] = %d\n" ($ls-slot ($ls-field a items) two))
;      ($ls-call-c printf "length word = %ld\n" ($ls-do array-length a)))
;
;program histanza-from-lostanza (basic1) :
;   ($ls-defn say-hi () () ($ls-ref False)
;      ($ls-call-c printf "Hi!\n")
;      ($ls-return ($ls-new False)))
;   ($defn say-hi-twice () () ($none)
;      ($def f ($none) say-hi)
;      ($do f)
;      ($do f))   
;   ($ls-let
;      ($ls-def f ($none) ($ls-func say-hi-twice))
;      ($ls-do ($ls-deref f)))
;
;program parametric-structs (basic1) :
;   ($ls-deftype ($ls-of MyBox T) ($none)
;      (item) ($none)
;      (($ls-ref T)) ($none))
;
;   ($ls-def NUM ($ls-ref Int) ($ls-as ($ls-as 336 ($ls-long)) ($ls-ref Int)))
;   ($ls-def FALSE ($ls-ref False) ($ls-new False))
;   ($ls-def BOXED-FALSE ($ls-ref ($of MyBox False)) ($ls-new ($ls-of MyBox False) FALSE))
;   ($ls-def BOXED-NUM ($ls-ref ($of MyBox Int)) ($ls-new ($ls-of MyBox Int) NUM))
;   ($ls-defn ($ls-of item ($cap T)) (box) (($ls-ref ($of MyBox ($cap T)))) ($ls-ref T)
;      ($ls-return ($ls-field box item)))
;
;   ($do item BOXED-NUM)
;   ($do item ($as ($as BOXED-FALSE ($?)) ($of MyBox Int)))
;
;program curried-globals (basic1) :
;   ($ls-deftype ($ls-of MyBox T) ($none)
;      (item) ($none)
;      (($ls-ref T)) ($none))
;
;   ($ls-def NUM ($ls-ref Int) ($ls-as ($ls-as 336 ($ls-long)) ($ls-ref Int)))
;   ($ls-def FALSE ($ls-ref False) ($ls-new False))
;   ($ls-def BOXED-FALSE ($ls-ref ($of MyBox False)) ($ls-new ($ls-of MyBox False) FALSE))
;   ($ls-def BOXED-NUM ($ls-ref ($of MyBox Int)) ($ls-new ($ls-of MyBox Int) NUM))
;   ($ls-defn ($ls-of item ($cap T)) (box) (($ls-ref ($of MyBox ($cap T)))) ($ls-ref T)
;      ($ls-return ($ls-field box item)))
;
;   ($defn apply (f, b) (($-> (($of MyBox Int)) Int) ($of MyBox Int)) ($none)
;      ($do f b))
;   ($do apply item BOXED-FALSE)   
;
;program curried-ls-globals (basic1) :
;   ($ls-deftype ($ls-of MyBox T) ($none)
;      (item) ($none)
;      (($ls-ref T)) ($none))
;
;   ($ls-def NUM ($ls-ref Int) ($ls-as ($ls-as 336 ($ls-long)) ($ls-ref Int)))
;   ($ls-def FALSE ($ls-ref False) ($ls-new False))
;   ($ls-def BOXED-FALSE ($ls-ref ($of MyBox False)) ($ls-new ($ls-of MyBox False) FALSE))
;   ($ls-def BOXED-NUM ($ls-ref ($of MyBox Int)) ($ls-new ($ls-of MyBox Int) NUM))
;   ($ls-defn ($ls-of item ($cap T)) (box) (($ls-ref ($of MyBox ($cap T)))) ($ls-ref T)
;      ($ls-return ($ls-field box item)))
;
;   ($defn apply (f, b) (($-> (($of MyBox Int)) Int) ($of MyBox Int)) ($none)
;      ($do f b))
;   ($ls-do apply ($ls-func item) BOXED-NUM)   
;
;program and-or-types (basic1) :
;   ($defn ($of check T) (x) (T) ($none)
;      x)
;
;   ($defn ($of check2 T S) (x) (($?)) ($none)
;      ($do ($of check ($or T S)) x))
;
;   ($ls-def FALSE ($ls-ref False) ($ls-new False))
;   ($ls-def TRUE ($ls-ref True) ($ls-new True))
;
;   ($do ($of check2 Int False) FALSE)
;   ($do ($of check2 Int False) 42)
;   ($do ($of check2 Int False) TRUE)
;
;program no-method (basic1) :
;   ($ls-defn say-hi () () ($ls-ref False)
;      ($ls-call-c printf "Hi\n")
;      ($ls-return ($ls-new False)))
;   ($defmulti hi () False)
;   ($do hi)
;
;program one-method (basic1) :
;   ($ls-defn say-hi () () ($ls-ref False)
;      ($ls-call-c printf "Hi\n")
;      ($ls-return ($ls-new False)))
;   ($defmulti hi () False)
;   ($defmethod hi () () ($none)
;      ($do say-hi))
;   ($do hi)
;
;program two-methods (basic1) :
;   ($ls-def FALSE ($ls-ref False) ($ls-new False))
;   ($ls-defn say-hi () () ($ls-ref False)
;      ($ls-call-c printf "Hi\n")
;      ($ls-return ($ls-new False)))
;   ($ls-defn say-int (x) (($ls-ref Int)) ($ls-ref False)
;      ($ls-call-c printf "X = %d\n" ($ls-prim shr ($ls-as x ($ls-long)) ($ls-as 3 ($ls-long))))
;      ($ls-return ($ls-new False)))
;         
;   ($defmulti hi (($?)) False)
;   ($defmethod hi (x) (False) ($none)
;      ($do say-hi))
;   ($defmethod hi (x) (Int) ($none)
;      ($do say-int x))
;      
;   ($do hi FALSE)
;   ($do hi 42)
;   ($do hi FALSE)
;   ($do hi 40)
;
;program instance-methods (basic1) :
;   ($ls-defn say-int (x) (($ls-ref Int)) ($ls-ref False)
;      ($ls-call-c printf "X = %d\n" ($ls-prim shr ($ls-as x ($ls-long)) ($ls-as 3 ($ls-long))))
;      ($ls-return ($ls-new False)))
;         
;   ($deftype Animal ($none))
;   ($defmulti bark (Animal) False)
;   ($defmethod bark (x) (Animal) ($none)
;      ($do say-int 0))
;
;   ($defn Dog (x) (Int) ($none)
;      ($new Animal
;         ($defmethod bark (this) (($none)) ($none)
;            ($do say-int x))))
;
;   ($do bark ($new Animal))
;   ($do bark ($do Dog 10))
;   ($do bark ($do Dog 14))
;
;program nested-functions (basic1) :
;   ($ls-defn say-int (x) (($ls-ref Int)) ($ls-ref False)
;      ($ls-call-c printf "X = %d\n" ($ls-prim shr ($ls-as x ($ls-long)) ($ls-as 3 ($ls-long))))
;      ($ls-return ($ls-new False)))
;
;   ($defn function (x) (Int) ($none)
;      ($defn nested () () ($none)
;         ($do say-int x))
;      ($do nested)
;      ($do nested))
;
;   ($do function 10)
;   ($do function 13)
;
;program escaping-nested-functions (basic1) :
;   ($ls-defn say-int (x) (($ls-ref Int)) ($ls-ref False)
;      ($ls-call-c printf "X = %d\n" ($ls-prim shr ($ls-as x ($ls-long)) ($ls-as 3 ($ls-long))))
;      ($ls-return ($ls-new False)))
;
;   ($defn function (x) (Int) ($none)
;      ($defn nested () () ($none)
;         ($do say-int x))
;      nested)
;
;   ($def f ($none) ($do function 10))
;   ($do f)
;   ($do f)
;         
;program chained-inference (basic1) :
;   ($ls-def FALSE ($ls-ref False) ($ls-new False))
;   ($ls-defn say-int (x) (($ls-ref Int)) ($ls-ref False)
;      ($ls-call-c printf "X = %d\n" ($ls-prim shr ($ls-as x ($ls-long)) ($ls-as 3 ($ls-long))))
;      ($ls-return ($ls-new False)))
;   
;   ($defn ($of call ($cap T) ($cap S)) (f, g) (($-> () ($cap T)), ($-> (T) ($cap S))) ($none)
;      ($do g ($do f)))
;
;   ($do call
;      ($fn () () ($none)
;         42)
;      ($fn (x) (($none)) ($none)
;         ($do say-int x)))
;
;program closure-setting (basic1) :
;   ($ls-def FALSE ($ls-ref False) ($ls-new False))
;   ($ls-defn say-int (x) (($ls-ref Int)) ($ls-ref False)
;      ($ls-call-c printf "X = %d\n" ($ls-prim shr ($ls-as x ($ls-long)) ($ls-as 3 ($ls-long))))
;      ($ls-return ($ls-new False)))
;   ($ls-defn inc (x) (($ls-ref Int)) ($ls-ref Int)
;      ($ls-return ($ls-as ($ls-prim add ($ls-as x ($ls-long)) ($ls-as 8 ($ls-long))) ($ls-ref Int))))
;
;   ($defn counter () () ($none)
;      ($defvar x ($none) 0)
;      ($fn () () ($none)
;         ($do say-int x)
;         ($set x ($do inc x))))
;
;   ($def c ($none) ($do counter))
;   ($do c)
;   ($do c)
;   ($do c)
;   ($do c)
;
;program mixing (basic1) :
;   ($ls-def FALSE ($ls-ref False) ($ls-new False))
;   ($ls-def TRUE ($ls-ref True) ($ls-new True))
;   ($ls-defn say-int (x) (($ls-ref Int)) ($ls-ref False)
;      ($ls-call-c printf "X = %d\n" ($ls-prim shr ($ls-as x ($ls-long)) ($ls-as 3 ($ls-long))))
;      ($ls-return ($ls-new False)))
;   ($ls-defn say-int (x) (($ls-ref False)) ($ls-ref False)
;      ($ls-call-c printf "False!\n" ($ls-prim shr ($ls-as x ($ls-long)) ($ls-as 3 ($ls-long))))
;      ($ls-return ($ls-new False)))
;
;   ($defn f (x) (($?)) ($none)
;      ($do say-int x))
;
;   ($ls-defn g (x) (($ls-ref ($?))) ($ls-ref False)
;      ($ls-return ($ls-do
;         ($ls-letexp
;            ($ls-call-c printf "Hi\n")
;            say-int)
;         x)))
;
;   ($do f FALSE)
;   ($do f 42)
;   ($do g FALSE)
;   ($do g 40)
;
;program partial-mixing (basic1) :
;   ($ls-def FALSE ($ls-ref False) ($ls-new False))
;   ($ls-def TRUE ($ls-ref True) ($ls-new True))
;   
;   ($ls-defn say-two (x, y) (($ls-ref False) ($ls-int)) ($ls-ref False)
;      ($ls-call-c printf "False arg = %ld\n" x)
;      ($ls-call-c printf "Int arg = %d\n" y)
;      ($ls-return ($ls-new False)))
;   ($ls-defn say-two (x, y) (($ls-ref True) ($ls-int)) ($ls-ref False)
;      ($ls-call-c printf "True arg = %ld\n" x)
;      ($ls-call-c printf "Int arg = %d\n" y)
;      ($ls-return ($ls-new False)))
;   ($ls-defn f (x, y) (($ls-ref ($?)) ($ls-int)) ($ls-ref False)
;      ($ls-return ($ls-do say-two x y)))
;         
;   ($ls-let
;      ($ls-do f FALSE 4)
;      ($ls-do f TRUE 5)
;      ($ls-do f FALSE 4)
;      ($ls-do f TRUE 5)
;      ($ls-do f FALSE 4)
;      ($ls-do f TRUE 5))
