defpackage core

;============================================================
;================== Core Types ==============================
;============================================================

public :
   lostanza deftype Byte :
      value: byte

   lostanza deftype Char :
      value: byte
      
   lostanza deftype Int :
      value: int
      
   lostanza deftype Long :
      value: long
      
   lostanza deftype Float :
      value: float

   lostanza deftype Double :
      value: double
      
   lostanza deftype String :
      length: long
      hash: int
      chars: byte ...

   lostanza deftype Symbol :
      length: long
      hash: int
      chars: byte ...      

   deftype List<T>
   lostanza deftype FullList<T> <: List<T> :
      head: ref<T>
      tail: ref<List<T>>
   lostanza deftype NilList <: List<Void>

   lostanza deftype True      
   lostanza deftype False
  
   lostanza deftype Tuple<T> :
      length: long
      items: ref<T> ...

   lostanza deftype Fn :
      code: ptr<?>
      free: ref<?> ...
      
   lostanza deftype Stack :
      position: int
      mark: int
      parent: ref<False|Stack>
      sp: ptr<?>
      frames: StackFrame ...

;============================================================
;================ Internal Types ============================
;============================================================

lostanza deftype Box :
   item: ref<?>
lostanza deftype Type :
   code: ptr<?>
   free: ref<?> ...
lostanza deftype StackFrame :
   ret: ptr<?>
   map: ptr<RefMap>
   items: long ...
lostanza deftype RefMap :
   length: long
   bits: long ...
lostanza deftype FileInfoTable :
   length: long
   entries: FileInfoEntry ...
lostanza deftype FileInfoEntry :
   lbl: ptr<?>
   file: ptr<byte>
   line: int
   column: int
      
public extern printf: (ptr<byte>, ? ...) -> int
extern malloc: long -> ptr<?>
extern free: ptr<?> -> int
public extern exit: int -> int

;============================================================
;==================== Initialization ========================
;============================================================

lostanza defn initialize-stanza () -> ref<False> :
   initialize-stacks()
   initialize-heaps()
   initialize-constants()
   return new False{}

initialize-stanza()

;                  Stack Initialization
;                  ====================

extern stanza_stack_size: long
lostanza var num-stacks:long

lostanza defn parent (s:ref<Stack>) -> ref<Stack> :
   return s.parent as ref<Stack>

lostanza defn initialize-stacks () -> int :
   ;Create stack pool
   num-stacks = 1024
   val pool:ptr<ref<Stack>> = call-c malloc(sizeof(ref<?>) * num-stacks)
   for (var i:int = 1, i < num-stacks, i = i + 1) :
      val p:ptr<long> = call-c malloc(stanza_stack_size)
      [p] = tagof(Stack) << 3 
      val s = (p + 1) as ref<Stack>
      s.position = i << 3
      s.mark = 0
      pool[i] = s

   ;Initialize current stack
   val s = call-prim stack()
   val p = (addr([s]) - 8) as ptr<long>
   [p] = tagof(Stack) << 3
   s.position = 0
   s.mark = 0
   s.parent = new False{}
   pool[0] = s

   ;Tell Stanza about stack pool
   call-prim set-num-free-stacks(num-stacks - 1)
   call-prim set-free-stacks(addr(pool[1]))
   call-prim set-stack-pool(pool)

   return 0

;                 Heap Initialization
;                 ===================

lostanza var mem-size:long
lostanza var heap-mem:ptr<long> 
lostanza var free-mem:ptr<long>
lostanza var free-ptr:ptr<long>
lostanza defn initialize-heaps () -> int :
   mem-size = 1024 * 1024
   heap-mem = call-c malloc(mem-size)
   free-mem = call-c malloc(mem-size)
   call-prim set-heap(heap-mem)
   call-prim set-heap-limit(heap-mem + mem-size)
   return 0

;                  Constant Initialization
;                  =======================

lostanza var const-ptr:ptr<?>
lostanza defn initialize-constants () -> int :
   ;Initialize read pointer to beginning of the constant table
   ;[num, constants ...]
   const-ptr = call-prim constant-table()
   val n-consts = read-const-int()
   
   ;First n-consts entries in the global table are for constants
   var gs:ptr<ref<?>> = call-prim globals()
   for (var i:int = 0, i < n-consts, i = i + 1) :
      gs[i] = read-const()   
   
   return 0
   
lostanza defn read-const () -> ref<?> :
   val tag = read-const-int()
   if tag == tagof(Byte) :
      return new Byte{read-const-byte()}
   else if tag == tagof(Char) :
      return new Char{read-const-byte()}      
   else if tag == tagof(Int) :
      return new Int{read-const-int()}
   else if tag == tagof(Long) :
      return new Long{read-const-long()}
   else if tag == tagof(Float) :
      return new Float{read-const-float()}
   else if tag == tagof(Double) :
      return new Double{read-const-double()}
   else if tag == tagof(True) :
      return new True{}
   else if tag == tagof(False) :
      return new False{}
   else if tag == tagof(FullList) :
      val len = read-const-int()
      return read-const-list(len)
   else if tag == tagof(String) :
      val len = read-const-long()
      val chars = read-const-chars(len)
      return String(len, chars)
   else if tag == tagof(Symbol) :
      val len = read-const-long()
      val chars = read-const-chars(len)
      return Symbol(len, chars)
   else :   
      call-c printf("Unknown constant tag: %ld\n", tag)      
      return error("Unknown constant tag")

lostanza defn read-const-list (n:int) -> ref<List> :
   if n == 0 : return new NilList{}
   else : return new FullList{read-const(), read-const-list(n - 1)}

lostanza defn read-const-byte () -> byte :
   val value = [const-ptr as ptr<byte>]
   const-ptr = const-ptr + sizeof(byte)
   return value

lostanza defn read-const-int () -> int :
   val value = [const-ptr as ptr<int>]
   const-ptr = const-ptr + sizeof(int)
   return value

lostanza defn read-const-long () -> long :
   val value = [const-ptr as ptr<long>]
   const-ptr = const-ptr + sizeof(long)
   return value

lostanza defn read-const-float () -> float :
   val value = [const-ptr as ptr<float>]
   const-ptr = const-ptr + sizeof(float)
   return value

lostanza defn read-const-double () -> double :
   val value = [const-ptr as ptr<double>]
   const-ptr = const-ptr + sizeof(double)
   return value

lostanza defn read-const-chars (len:long) -> ptr<byte> :
   val value = const-ptr as ptr<byte>
   ;length chars + 0 character + pad to nearest 4 bytes
   val n = (len + 4) & -4
   const-ptr = (const-ptr + n) as ptr<?>
   return value

;============================================================
;============== Generated Entry Points ======================
;============================================================

lostanza defn cast-error () -> ref<Void> :
   return error("Cannot cast value to type.")

lostanza defn arity-error () -> ref<Void> :
   return error("Wrong number of arguments.")

lostanza defn branch-error () -> ref<Void> :
   return error("Ambiguous or no matching branch.")

lostanza defn variable-uninitialized-error () -> ref<Void> :
   return error("Variable is uninitialized.")

;============================================================
;================== Stack Traces ============================
;============================================================

lostanza var trace-buffer:ptr<ptr<FileInfoEntry>>
lostanza var trace-size:int
lostanza val null:ptr<?> = 0 as long as ptr<?>

lostanza defn print-stack-trace () -> ref<False> :
   ;Allocate space for storing trace
   ;No trace can be larger than the size of a stack
   trace-buffer = call-c malloc(stanza_stack_size)
   
   ;Cap off current stack
   val s = call-prim stack()
   s.sp = call-prim sp()
   
   ;Print trace starting from current stack
   print-stack-trace(s)
   
   ;Free trace buffer and return
   call-c free(trace-buffer)   
   return new False{}

lostanza defn* print-stack-trace (s:ref<Stack>) -> int :
   ;Store trace into buffer
   trace-size = 0
   val f0 = s.frames + frame-size(s.frames) ;Skip intercepted return frame
   store-stack-trace(f0, s.sp)
   
   ;Print out trace
   for (var i:int = trace-size - 1, i >= 0, i = i - 1) :
      val e = trace-buffer[i]
      if e == null :
         call-c printf("   at [Unknown Source Location]\n")
      else :
         call-c printf("   at %s:%d.%d\n", e.file, e.line, e.column)

   ;Print parent stack trace
   match(s.parent) :
      (p:ref<Stack>) : return print-stack-trace(p)
      (p:ref<False>) : return 0

lostanza defn* store-stack-trace (stacks:ptr<StackFrame>, end:ptr<?>) -> int :
   ;Store the return address into trace buffer
   trace-buffer[trace-size] = info-entry(stacks.ret)
   trace-size = trace-size + 1

   ;Continue tracing next frame unless end is reached.
   if stacks == end :
      return 0
   else :
      val sz = frame-size(stacks)
      return store-stack-trace(stacks + sz, end)

lostanza defn frame-size (s:ptr<StackFrame>) -> long :
   val map = s.map
   return sizeof(StackFrame) + s.map.length * sizeof(long)

lostanza defn info-entry (p:ptr<?>) -> ptr<FileInfoEntry> :
   val table = call-prim info-table() as ptr<FileInfoTable>
   for (var i:long = 0, i < table.length, i = i + 1) :
      val e = table.entries[i]
      if e.lbl == p :
         return addr(table.entries[i])
   return null

;============================================================
;===================== Errors ===============================
;============================================================

public lostanza defn error (msg: ptr<byte>) -> ref<Void> :
   call-c printf("FATAL ERROR: %s\n", msg)
   print-stack-trace()
   call-c exit(-1)
   return null as ref<Void>

;============================================================
;=============== Garbage Collector ==========================
;============================================================

;              Generated Entry Points
;              ======================

;Called when attempting to allocate beyond the heap limit.
lostanza defn extend-heap (sz:long) -> int :
   new-stack<int>{run-garbage-collector()}
   if call-prim heap() + sz > call-prim heap-limit() :
      error("Out of heap memory")
   return 0

;Called when the number of free stacks is 2 or less.
;Running extend-stack uses two stacks (1 for GC, 1 for handling extend-stack during GC).
lostanza defn extend-stack () -> int :
   if gc-running :
      error("Stack overflow in garbage collector")
      return 0
   else :
      new-stack<int>{run-garbage-collector()}
      if call-prim num-free-stacks() <= 2 :
         error("Stack overflow")
      return 0

;                   Main Function
;                   =============

;Main function for garbage collector
lostanza var gc-running:long = 0
lostanza defn run-garbage-collector () -> int :
   ;Mark GC as running to detect stack extension within GC
   gc-running = 1

   ;Initialize free pointer to point to beginning of free memory before copying starts.
   free-ptr = free-mem

   ;Current stack is the collection stack, the stack that the GC runs in.
   ;Set its mark bit to indicate that it is active.
   val collection-stack = call-prim stack()
   collection-stack.mark = 1

   ;Scan roots
   scan-globals()
   scan-stack(parent(collection-stack))

   ;Scan internal pointers of all heap objects
   scan-heap()

   ;Swap free memory with heap
   val swap = heap-mem
   heap-mem = free-mem
   free-mem = swap
   call-prim set-heap(free-ptr)
   call-prim set-heap-limit(heap-mem + mem-size)

   ;All active stacks have their mark bits set.
   free-unmarked-stacks()

   ;Finish
   gc-running = 0   
   return 0

;                 Scanning Functions
;                 ==================

;Copy all global references to the free memory.
lostanza defn scan-globals () -> int :
   ;Get tables
   val globals = call-prim globals() as ptr<long>
   val map = call-prim global-map() as ptr<RefMap>
   ;Scan globals
   scan-map-words(map.bits, map.length, globals)   
   return 0
   
;Copy all stack references in this and parent stacks to free memory.
lostanza defn* scan-stack (s:ref<Stack>) -> int :
   if s.mark == 0 :
      s.mark = 1
      scan-stack-frames(s.frames, s.sp)
      match(s.parent) :
         (p:ref<Stack>) : return scan-stack(p)
         (p:ref<False>) : return 0
   else :      
      return 0

;Copy all internal references in heap to free memory.
lostanza defn scan-heap () -> int :
   var p: ptr<long> = free-mem
   while p < free-ptr :
      val tagbits = [p] & 3
      if tagbits == 0 :
         p = scan-object(p)
      else if tagbits == 1 :
         p = scan-array(p)
      else :
         call-c printf("Invalid tag bits in heap: %lx\n", tagbits)
         call-c exit(-1)
         return 0
   return 0      

;Copy all internal references in object to free memory.
lostanza defn scan-object (p:ptr<long>) -> ptr<long> :
   ;p is [tag-word, cells ...]   
   val tag = p[0] >>> 3
   val map = object-map(tag)
   scan-map-words(base-bits(map), base-nwords(map), p + 8)
   return p + 8 + map.base-size

;Copy all internal references in array to free memory.
lostanza defn scan-array (p:ptr<long>) -> ptr<long> :
   ;p is [len-word, tag-word, cells ...]
   val len = p[0] >>> 3
   val tag = p[1] >>> 3
   
   ;Calculate the total size of object, rounding up to nearest 8 bytes
   val map = object-map(tag)
   val bytes = ((map.base-size + map.tail-size * len) + 7) & -8   

   ;Scan base of array
   scan-map-words(base-bits(map), base-nwords(map), p + 16)
   
   ;Scan tail of array if it contains references.
   if tail-refs?(map) :
      var tail:ptr<long> = p + 16 + map.base-size
      val tbits = tail-bits(map)
      val tnwords = tail-nwords(map)
      for (var i:long = 0, i < len, i = i + 1) :
         scan-map-words(tbits, tnwords, tail)
         tail = tail + map.tail-size

   ;Return end of array
   return p + 16 + bytes

;Copy all internal references in stack frames, fs, until end pointer
lostanza defn* scan-stack-frames (fs:ptr<StackFrame>, end:ptr<?>) -> int :
   if fs < end :
      val map = [fs].map
      scan-map-words(map.bits, map.length, [fs].items)
      val next-fs = addr([fs].items[map.length]) as ptr<StackFrame>
      return scan-stack-frames(next-fs, end)
   else :   
      return 0

;Scan n references (marked with a 1 bit) from the given pointer
lostanza defn* scan-map-words (map:ptr<long>, n:long, refs:ptr<long>) -> int :
   if n > 64 :
      scan-map-word([map], 64, refs)
      return scan-map-words(addr(map[1]), n - 64, addr(refs[1]))
   else if n > 0 :
      scan-map-word([map], n, refs)
      return 0
   else :
      return 0

lostanza defn scan-map-word (map:long, n:long, refs:ptr<long>) -> int :
   var ref-ptr:ptr<long> = refs
   for (var i:long = 0, i < n, i = i + 1) :
      val b = (map >> i) & 1
      if b : [ref-ptr] = post-gc-object([ref-ptr])
      ref-ptr = ref-ptr + sizeof(long)
   return 0

;                Copying Functions
;                =================

lostanza defn post-gc-object (obj:long) -> long :
   val tagbits = obj & 3
   if tagbits == 1 :
      val obj-ptr = (obj - tagbits) as ptr<long>
      val tag = obj-ptr[0] >>> 3
      
      ;If broken heart, then return forwarding pointer
      if tag == -1 :
         return obj-ptr[1]
      ;Otherwise, copy object
      else :
         val map = object-map(tag)
         if tag == tagof(Stack) :
            scan-stack(obj as ref<Stack>)
            return obj
         else if finite?(map) :
            val obj* = copy-object-to-free(obj-ptr, map.base-size) + tagbits
            set-broken-heart(obj-ptr, obj*)
            return obj*
         else :
            val obj* = copy-array-to-free(obj-ptr, map.base-size, map.tail-size) + tagbits
            set-broken-heart(obj-ptr, obj*)
            return obj*
   else :
      return obj

lostanza defn set-broken-heart (old:ptr<long>, new:long) -> int :
   old[0] = -1
   old[1] = new
   return 0
      
lostanza defn copy-object-to-free (obj:ptr<long>, size:long) -> long :
   val ret = free-ptr
   copy-bytes-to-free(obj, size + 8)
   return ret as long

lostanza defn copy-array-to-free (obj:ptr<long>, size:long, tail:long) -> long :
   ;obj: [len, tag, items ...]   
   ;Returned pointer points to the tag word
   val ret = free-ptr + 8   
   val length = obj[-1] >>> 3
   
   ;Calculate the total size of object, rounding up to nearest 8 bytes
   val bytes = ((size + tail * length) + 7) & -8
   
   ;Copy the bytes to free including header
   copy-bytes-to-free(obj - 8, bytes + 16)
   
   return ret as long

lostanza defn copy-bytes-to-free (p:ptr<long>, n:long) -> int :
   if n & 3 != 0 :
      call-c exit(-1)
   val nwords = n >>> 3
   for (var i:long = 0, i < nwords, i = i + 1) :
      free-ptr[i] = p[i]
   free-ptr = free-ptr + n
   return 0

;               Utilities for ObjectMap
;               =======================

lostanza deftype ObjectMap :
   base-size: int
   tail-size: int
   bits: long ...
   
lostanza defn object-map (tag:long) -> ptr<ObjectMap> :
   val table = call-prim object-table() as ptr<ptr<ObjectMap>>
   return table[tag]

lostanza defn finite? (m:ptr<ObjectMap>) -> long :
   return m.tail-size == 0 

lostanza defn base-bits (m:ptr<ObjectMap>) -> ptr<long> :
   return m.bits

lostanza defn base-nwords (m:ptr<ObjectMap>) -> long :
   return m.base-size >>> 3

lostanza defn tail-bits (m:ptr<ObjectMap>) -> ptr<long> :
   return addr(m.bits[base-nwords(m)])

lostanza defn tail-nwords (m:ptr<ObjectMap>) -> long :
   return m.tail-size >>> 3

lostanza defn tail-refs? (m:ptr<ObjectMap>) -> long :
   val n = tail-nwords(m)
   val bits = tail-bits(m)
   for (var i:long = 0, i < n, i = i + 1) :
      if bits[i] != 0 :
         return 1
   return 0

;                  Releasing Stacks
;                  ================

;Free an active stack, and add back to the free stack list.
lostanza defn free-stack (s:ref<Stack>) -> long :
   ;Ensure s is the last active stack
   val stk-pool = call-prim stack-pool()
   val last-stk = (call-prim free-stacks())[-1]
   if s != last-stk :
      ;Swap locations of last-stk with s
      [stk-pool + s.position] = last-stk
      [stk-pool + last-stk.position] = s
      ;Swap positions of last-stk with s
      val s-position = s.position
      s.position = last-stk.position
      last-stk.position = s-position
   ;Free last active stack
   call-prim set-num-free-stacks(call-prim num-free-stacks() + 1)
   call-prim set-free-stacks(call-prim free-stacks() - 8)   
   return 0

;Free all unmarked stacks.
lostanza defn free-unmarked-stacks () -> int :
   var stk-ptr:ptr<ref<Stack>> = call-prim stack-pool()
   while stk-ptr < call-prim free-stacks() :
      val s = [stk-ptr]
      if s.mark == 0 :
         free-stack(s)
      else :
         stk-ptr = stk-ptr + 8
      s.mark = 0
   return 0

;============================================================
;======================= Error ==============================
;============================================================

lostanza defn error (msg: ref<String>) -> ref<Void> :
   return error(msg.chars)

;============================================================
;===================== Winders ==============================
;============================================================

defn fn-cons-0 (a: False|(() -> ?), b: False|(() -> ?)) -> False|(() -> ?) :
   match(a, b) :
      (a:False, b) : b
      (a, b:False) : a
      (a:() -> ?, b:() -> ?) : fn* () : (a(), b())

defn fn-cons-1 (a: False|(? -> ?), b: False|(? -> ?)) -> False|(? -> ?) :
   match(a, b) :
      (a:False, b) : b
      (a, b:False) : a
      (a:? -> ?, b:? -> ?) : fn* (x) : (a(x), b(x))

defn* call-if-function (f: False|(() -> ?)) :
   match(f) :
      (f:() -> ?) : f()
      (f:False) : false

defn* call-if-function (f: False|(? -> ?), x: ?) :
   match(f) :
      (f:? -> ?) : f(x)
      (f:False) : false

public lostanza defn dynamic-wind<?T> (in:ref<False|(() -> ?)>,
                                       body:ref<(() -> ?T)>,
                                       out:ref<False|(? -> ?)>) -> ref<T> :
   call-if-function(in)
   val w-in = current-coroutine.windin
   val w-out = current-coroutine.windout
   current-coroutine.windin = fn-cons-0(w-in, in)
   current-coroutine.windout = fn-cons-1(out, w-out)
   val result = [body]()
   current-coroutine.windin = w-in
   current-coroutine.windout = w-out
   call-if-function(out, new True{})
   return result

lostanza defn windin (c:ref<RawCoroutine>) -> ref<False|(() -> ?)> :
   match(c.parent) :
      (p:ref<RawCoroutine>) : return fn-cons-0(c.windin, windin(p))
      (p:ref<False>) : return c.windin

lostanza defn windout (c:ref<RawCoroutine>) -> ref<False|(? -> ?)> :
   match(c.parent) :
      (p:ref<RawCoroutine>) : return fn-cons-1(windout(p), c.windout)
      (p:ref<False>) : return c.windout

;============================================================
;===================== Coroutines ===========================
;============================================================

;                     Interface
;                     =========

public deftype Coroutine<I,O>
public defmulti active? (c:Coroutine) -> True|False
public defmulti open? (c:Coroutine) -> True|False
public defmulti resume<?I,?O> (c:Coroutine<?I,?O>, x:I) -> O
public defmulti suspend<?I,?O> (c:Coroutine<?I,?O>, x:O) -> I
public defmulti break<?O> (c:Coroutine<?,?O>, x:O) -> Void
public defmulti close (c:Coroutine) -> False

;                   Raw Coroutines
;                   ==============

public lostanza deftype RawCoroutine <: Coroutine :
   id: long
   parent: ref<False|RawCoroutine>
   top: ref<Stack|False>
   bottom: ref<Stack|False>
   windin: ref<False|(() -> ?)>
   windout: ref<False|(? -> ?)>
   status: long

defmethod active? (c:RawCoroutine) : co-active?(c)
defmethod open? (c:RawCoroutine) : co-open?(c)
defmethod resume (c:RawCoroutine, x) : co-resume(c, x)
defmethod suspend (c:RawCoroutine, x) : co-suspend(c, x)
defmethod break (c:RawCoroutine, x) : co-break(c, x)
defmethod close (c:RawCoroutine) : co-close(c)

;                  Wrapped Coroutines
;                  ==================

public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) :
   var rc
   val c = new Coroutine<I,O> :
      defmethod active? (this) : active?(rc)
      defmethod open? (this) : open?(rc)
      defmethod resume (this, x:I) : resume(rc, x)
      defmethod suspend (this, x:O) : suspend(rc, x)
      defmethod break (this, x:O) : break(rc, x)
      defmethod close (this) : close(rc)
   rc = RawCoroutine $ fn (rc, x0) :
      enter(c, x0)
   c
   
;                    Implementation
;                    ==============


lostanza deftype CoResult :
   value: ref<?>
   windout: ref<False|(? -> ?)>
   final?: ref<True|False>

lostanza val COROUTINE-ACTIVE:long = 0
lostanza val COROUTINE-CLOSED:long = 1
lostanza val COROUTINE-SUSPENDED:long = 2
lostanza val COROUTINE-OPEN:long = 3


lostanza var COROUTINE-COUNTER:long = 0
lostanza defn next-coroutine-id () -> long :
   val id = COROUTINE-COUNTER
   COROUTINE-COUNTER = COROUTINE-COUNTER + 1
   return id

lostanza var current-coroutine:ref<RawCoroutine> =
   new RawCoroutine{
      next-coroutine-id()
      new False{}
      call-prim stack()
      call-prim stack()
      new False{}
      new False{}
      COROUTINE-ACTIVE}
   
public lostanza defn RawCoroutine (enter: ref<((RawCoroutine, ?) -> ?)>) -> ref<RawCoroutine> :
   return new-stack<ref<RawCoroutine>>{setup-coroutine(enter)}

public lostanza defn co-active? (c:ref<RawCoroutine>) -> ref<True|False> :
   if c.status == COROUTINE-ACTIVE : return new True{}
   else : return new False{}

public lostanza defn co-open? (c:ref<RawCoroutine>) -> ref<True|False> :
   if c.status == COROUTINE-OPEN : return new True{}
   else : return new False{}

lostanza defn top (c:ref<RawCoroutine>) -> ref<Stack> :
   return c.top as ref<Stack>

lostanza defn bottom (c:ref<RawCoroutine>) -> ref<Stack> :
   return c.bottom as ref<Stack>

lostanza defn* setup-coroutine (enter: ref<((RawCoroutine,?) -> ?)>) -> ref<?> :
   val s = call-prim stack()
   val c = new RawCoroutine{next-coroutine-id(), new False{}, s, s, new False{}, new False{}, COROUTINE-OPEN}
   val x0 = switch-stack<ref<?>>{parent(s), c}
   return co-break(c, [enter](c, x0))

public lostanza defn co-resume (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
   ;Ensure coroutine is re-entrant
   if c.status != COROUTINE-OPEN :
      return error("Unresumable Coroutine")
      
   ;Call its windin
   call-if-function(windin(c))

   ;Connect stacks, and attach coroutine
   current-coroutine.top = call-prim stack()
   bottom(c).parent = current-coroutine.top
   attach(c)

   ;Switch stacks
   val result = switch-stack<CoResult>{top(current-coroutine), x}

   ;Call its windout
   call-if-function(result.windout, result.final?)

   ;Switch stacks
   return result.value

public lostanza defn* co-suspend (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
   ;Ensure coroutine is active
   if c.status != COROUTINE-ACTIVE :
      return error("Inactive Coroutine")

   ;Disconnect stacks, and Detach coroutine
   bottom(c).parent = new False{}
   detach(c, new False{})

   ;Return to resume
   val result = CoResult{x, windout(c), new False{}}
   return switch-stack<ref<?>>{top(current-coroutine), result}

public lostanza defn* co-break (c:ref<RawCoroutine>, x:ref<?>) -> ref<Void> :
   ;Ensure coroutine is active
   if c.status != COROUTINE-ACTIVE :
      return error("Inactive Coroutine")
      
   ;Detach coroutine
   detach(c, new False{})

   ;Result to return to resume
   val result = CoResult{x, windout(c), new True{}}

   ;Free the coroutine
   free(c)

   ;Switch stacks
   return switch-stack<ref<Void>>{top(current-coroutine), result}

public lostanza defn co-close (c:ref<RawCoroutine>) -> ref<False> :
   if c.status == COROUTINE-CLOSED :
      return new False{}
   else if c.status == COROUTINE-ACTIVE :
      return error("Cannot close active coroutine")
   else if c.status == COROUTINE-SUSPENDED :
      return error("Cannot close suspended coroutine")
   free(c)   
   return new False{}

lostanza defn* attach (c:ref<RawCoroutine>) -> int :
   val p = c.parent
   c.parent = current-coroutine
   c.status = COROUTINE-ACTIVE
   current-coroutine = c
   match(p) :
      (p:ref<RawCoroutine>) : return attach(p)
      (p:ref<False>) : return 0

lostanza defn* detach (c:ref<RawCoroutine>, tail:ref<RawCoroutine|False>) -> int :
   val cc = current-coroutine
   val ccp = current-coroutine.parent as ref<RawCoroutine>
   cc.parent = tail
   current-coroutine = ccp
   if c == cc :
      cc.status = COROUTINE-OPEN
      return 0
   else :
      cc.status = COROUTINE-SUSPENDED
      return detach(c, cc)

lostanza defn* free (c:ref<RawCoroutine>) -> int :
   val parent = c.parent
   c.status = COROUTINE-CLOSED
   free-stacks(top(c), bottom(c))
   c.top = new False{}
   c.bottom = new False{}
   c.parent = new False{}
   c.windin = new False{}
   c.windout = new False{}
   match(parent) :
      (p:ref<RawCoroutine>) : return free(p)
      (p:ref<False>) : return 0

lostanza defn* free-stacks (top:ref<Stack>, bottom:ref<Stack>) -> int :
   if top == bottom :
      free-stack(top)
      return 0
   else :
      val p = parent(top)
      free-stack(top)
      return free-stacks(p, bottom)


;============================================================
;===================== Sequences ============================
;============================================================

public deftype Seq<T>
public defmulti next<?T> (s:Seq<?T>) -> T
public defmulti peek<?T> (s:Seq<?T>) -> T
public defmulti empty? (s:Seq) -> True|False
public defmulti close (s:Seq) -> False

lostanza deftype Sentinel 
lostanza var sentinel:ref<Sentinel> = new Sentinel{}
public defn Generator<T> (thunk : (T -> False, (T -> Void) & (() -> Void)) -> ?) -> Seq<T> :
   ;State
   var item = sentinel
   
   ;Generator Coroutine
   val co = Coroutine<False, T|Sentinel> $ fn (co, x0) :
      defn co-yield (x:T) :
         suspend(co, x)
      val co-break = multifn :
         (x:T) : break(co, x)
         () : break(co, sentinel)
      thunk(co-yield, co-break)
      sentinel

   ;Fill state: Returns whether empty
   defn fill () :
      if (item typeof Sentinel) and open?(co) :
         item = resume(co, false)
      item typeof Sentinel

   ;Peek
   defn peek () :
      if item typeof Sentinel :
         error("Empty Sequence")
      item as T

   ;Empty bucket
   defn empty () :
      val x = peek()
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         peek()
      defmethod close (this) :
         item = sentinel
         close(co)
      defmethod empty? (this) :
         fill()


;============================================================
;====================== Labels ==============================
;============================================================

public defn* LabeledScope<T> (thunk: (T -> Void) -> T) -> T :
   val c = Coroutine<False,T> $ fn* (c, x0) :
      thunk(break{c, _})
   resume(c, false)

;============================================================
;====================== Strings =============================
;============================================================

public lostanza defn String (len:long, chars:ptr<byte>) -> ref<String> :
   val s = new String{len, 0}[len + 1]
   for (var i:long = 0, i < len, i = i + 1) :
      s.chars[i] = chars[i]
   s.chars[len] = 0 as byte
   return s

lostanza defn chars-hash (n:long, p:ptr<byte>) -> int :
   var h:int = 0
   for (var i:long = 0, i < n, i = i + 1) :
      h = (31 * h) + p[i]
   if h == 0 : return 1
   else : return h

public lostanza defn hash (s:ref<String>) -> ref<Int> :
   if s.hash == 0 :
      s.hash = chars-hash(s.length, s.chars)
   return new Int{s.hash}

;============================================================
;====================== Symbols =============================
;============================================================

public lostanza defn Symbol (len:long, chars:ptr<byte>) -> ref<Symbol> :
   return error("Not yet implemented")

public lostanza defn hash (s:ref<Symbol>) -> ref<Int> :
   if s.hash == 0 :
      s.hash = chars-hash(s.length, s.chars)
   return new Int{s.hash}

public lostanza defn println (s:ref<String>) -> ref<False> :
   call-c printf("%s\n", s.chars)
   return new False{}

public lostanza defn println (s:ref<String>, x:ref<?>) -> ref<False> :
   call-c printf("%s%p\n", s.chars, x)
   return new False{}

;============================================================
;====================== Scratch =============================
;============================================================

;              Example with Tail Recursion
;              ===========================
;
;lostanza defn plus (a:ref<Int>, b:ref<Int>) -> ref<Int> :
;   return new Int{a.value + b.value}
;
;lostanza defn ten? (a:ref<Int>) -> ref<True|False> :
;   if a.value == 10 : return new True{}
;   else : return new False{}
;
;lostanza defn print-sp () -> ref<False> :
;   call-c printf("sp = %p\n", call-prim sp())
;   return new False{}
;
;defn* loop (x:Int) :
;   if ten?(x) :
;      false
;   else :
;      print-sp()
;      loop(x + 1)
;
;loop(0)

;                Example with Sequences
;                ======================

lostanza defn plus (a:ref<Int>, b:ref<Int>) -> ref<Int> :
   return new Int{a.value + b.value}

lostanza defn ten? (a:ref<Int>) -> ref<True|False> :
   if a.value == 10 : return new True{}
   else : return new False{}

defn nums () -> Seq<Int> :
   generate<Int> :
      defn* loop (i:Int) :
         yield(i)
         loop(plus(i, 1))
      loop(0)

lostanza defn print-sp () -> ref<False> :
   call-c printf("sp = %p\n", call-prim sp())
   print-stack-trace()
   return new False{}

defn do-nums (f:Int -> ?) -> False :
   val xs = nums()
   dynamic-wind(
      false,
      fn* () :
         defn* loop () -> ? :
            print-sp()
            if empty?(xs) :
               false
            else :
               f(next(xs))
               loop()
         loop()
      fn* (final?) :
         close(xs) when final?)

label<False> break :
   do-nums $ fn (i) :
      println("i = ", i)
      break(false) when ten?(i)


;              Trickier Example with Dynamic Wind
;              ==================================

;lostanza defn plus (a:ref<Int>, b:ref<Int>) -> ref<Int> :
;   return new Int{a.value + b.value}
;
;lostanza defn ten? (a:ref<Int>) -> ref<True|False> :
;   if a.value == 10 : return new True{}
;   else : return new False{}
;
;lostanza defn five? (a:ref<Int>) -> ref<True|False> :
;   if a.value == 5 : return new True{}
;   else : return new False{}
;
;defn nums () -> Seq<Int> :
;   generate<Int> :
;      defn* loop (i:Int) :
;         if ten?(i) :
;            false
;         else :
;            yield(i)
;            loop(plus(i, 1))
;      loop(0)
;
;lostanza defn print-sp () -> ref<False> :
;   call-c printf("sp = %p\n", call-prim sp())
;   ;print-stack-trace()
;   return new False{}
;
;defn #do-nums (f:Int -> ?) -> False :
;   val xs = nums()
;   defn* loop () -> ? :
;      print-sp()
;      if empty?(xs) :
;         false
;      else :
;         f(next(xs))
;         loop()
;   loop()
;
;defn do-nums (f:Int -> ?) -> False :
;   val xs = nums()
;   dynamic-wind(
;      false,
;      fn* () :
;         defn* loop () -> ? :
;            print-sp()
;            if empty?(xs) :
;               false
;            else :
;               f(next(xs))
;               loop()
;         loop()
;      fn* (final?) :
;         #do-nums $ fn (i) :
;            println("Countdown = ", i)
;         close(xs) when final?)
;
;label<False> break :
;   do-nums $ fn (i) :
;      println("i = ", i)
;      break(false) when five?(i)


;             Garbage Collection on Coroutines
;             ================================

;lostanza defn blow-heap () -> ref<False> :
;   extend-heap(0)
;   return new False{}
;
;defn nums () -> Seq<Int> :
;   generate<Int> :
;      yield(0)
;      yield(1)
;      yield(2)
;      
;defn main () :
;   val xs = nums()
;   blow-heap()
;   blow-heap()
;   next(xs)
;   blow-heap()
;   next(xs)
;
;main()
         

;               Example with Coroutines
;               =======================
;
;lostanza defn plus (a:ref<Int>, b:ref<Int>) -> ref<Int> :
;   return new Int{a.value + b.value}
;
;lostanza defn ten? (a:ref<Int>) -> ref<True|False> :
;   if a.value == 10 : return new True{}
;   else : return new False{}
;
;defn nums () :
;   Coroutine<False,Int> $ fn (c, x0) :
;      defn* loop (i:Int) -> ? :
;         suspend(c, i)
;         loop(plus(i, 1))
;      dynamic-wind(
;         fn* () :
;            println("IN")
;         fn* () :
;            loop(0)
;         fn* (f) :
;            println("OUT ", f))
;
;defn do-nums (f: ? -> ?) :
;   val xs = nums()
;   dynamic-wind(
;      fn* () :
;         false
;      fn* () :
;         defn* loop () -> ? :
;            if open?(xs) :
;               f(resume(xs, false))
;               loop()
;         loop()      
;      fn* (final?) :
;         println("final = ", final?)
;         close(xs) when final?)
;
;let :
;   val in = Coroutine<False,False> $ fn (c, x0) :
;      do-nums $ fn (i) :
;         println("i = ", i)
;         break(c, false) when ten?(i)
;   resume(in, false)
        




defpackage user :
   import core

;lostanza deftype StructA :
;   a: byte
;   b: ref<?>
;   c: ref<?>
;   d: byte
;   e: ref<?>
;
;lostanza deftype StructB :
;   a: ref<?>
;   b: int
;   c: ref<?>
;
;lostanza deftype MyArray :
;   n: int
;   items: ref<?> ...
;
;lostanza deftype MyByteArray :
;   a: byte
;   b: byte
;   c: byte
;   items: byte ...
;
;lostanza deftype StructC


;lostanza val X:ref<False> = new False{}
;lostanza val Z:int = 0
;lostanza val W:int = 1
;lostanza val Y:ref<False> = new False{}
;lostanza val H:StructA = StructA{0 as byte, new Int{1}, new Int{2}, 1 as byte, new Int{3}}

;lostanza defn blow-heap () -> ref<False> :
;   for (var i:long = 0, i < 1024 * 1024, i = i + 1) :
;      val a = new StructB{new False{}, 0, new False{}}
;   return new False{}
;
;lostanza defn recur (n:int) -> ref<False> :
;   call-c printf("recur(%d)\n", n)
;   val a = n + n
;   val b = a + n + n
;   val c = new StructB{new False{}, a, new False{}}
;   val d = new StructB{c, a, c}
;   val e = new MyArray{10}[10]
;   for (var i:long = 0, i < 10, i = i + 1) :
;      e.items[i] = new False{}
;   e.items[5] = e
;   
;   val f = new MyByteArray{1 as byte, 2 as byte, 3 as byte}[10]
;   for (var i:long = 0, i < 10, i = i + 1) :
;      f.items[i] = 42 as byte
;
;   val g = new StructC{}
;
;   if n == 0 :
;      blow-heap()
;      return new False{}
;   else :
;      recur(n - 1)
;      val e5 = e.items[5] as ref<MyArray>
;      call-c printf("c.a = %p, c.c = %p, d.a = %p, d.c = %p, e.items[5].items[1] = %p, f.items[5] = %d, g = %p\n",
;                    c.a, c.c, d.a, d.c, e5.items[1], f.items[5] as int, g)
;      return new False{}

;lostanza: recur(40)

;lostanza defn print-list (r:ref<List>) -> ref<False> :
;   call-c printf("print-list(%p)\n", r)
;   match(r) :
;      (r:ref<FullList>) :
;         call-c printf("%p ", r.head)
;         return print-list(r.tail)
;      (r:ref<NilList>) :
;         call-c printf(".\n")
;         return new False{}
;
;print-list(`(1 2 3 4 5))
;
;lostanza defn typeof-num (n:ref<?>) -> ref<False> :
;   var name:ptr<byte>
;   match(n) :
;      (n:ref<Byte>) :
;         call-c printf("value = %d\n", n.value as int)
;         name = "Byte"
;      (n:ref<Char>) :
;         call-c printf("value = %c\n", n.value)
;         name = "Char"
;      (n:ref<Int>) :
;         call-c printf("value = %d\n", n.value)
;         name = "Int"
;      (n:ref<Float>) :
;         call-c printf("value = %g\n", n.value)
;         name = "Float"
;   call-c printf("%s\n", name)
;   return new False{}
;
;typeof-num(30)
;typeof-num(30.4)
;typeof-num('f')

;lostanza defn print-string (r:ref<String>) -> ref<False> :
;   call-c printf("%s\n", r.chars)
;   return new False{}
;
;print-string("hello world")
;lostanza :
;   val a = 30.4
;   call-c printf("a = %g\n", a as double)
;   call-c printf("value = %p\n", new False{})
;   call-c printf("value = %p\n", new True{})
;
;lostanza defn call-closure (f:ref<(() -> Int)>) -> ref<Int> :
;   val i = [f]()
;   call-c printf("i = %d\n", i.value)
;   return i
;
;call-closure $ fn () : 42
