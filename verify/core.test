defpackage core
public :
   lostanza deftype Int :
      value:int
   lostanza deftype False
   lostanza deftype True
   lostanza deftype Box :
      item: ref<?>
   lostanza deftype Fn :
      code: ptr<?>
      free: ref<?> ...
   lostanza deftype Type :
      code: ptr<?>
      free: ref<?> ...
   lostanza deftype Stack :
      position: int
      mark: int
      parent: ref<False|Stack>
      sp: ptr<?>
      frames: StackFrame ...
   lostanza deftype StackFrame :
      ret: long
      map: ptr<RefMap>
      items: long ...
   lostanza deftype RefMap :
      length: long
      bits: long ...
      
public extern printf: (ptr<byte>, ? ...) -> int
extern malloc: long -> ptr<?>
public extern exit: int -> int

extern stanza_stack_size: long
lostanza var num-stacks:long
lostanza defn initialize-stacks () -> int :
   ;Create stack pool
   num-stacks = 1024
   val pool:ptr<ref<Stack>> = call-c malloc(sizeof(ref<?>) * num-stacks)
   for (var i:int = 1, i < num-stacks, i = i + 1) :
      val p:ptr<long> = call-c malloc(stanza_stack_size)
      [p] = tagof(Stack) << 3 
      val s = (p + 1) as ref<Stack>
      s.position = i << 3
      s.mark = 0
      pool[i] = s

   ;Initialize current stack
   val s = call-prim stack()
   val p = (addr([s]) - 8) as ptr<long>
   [p] = tagof(Stack) << 3
   s.position = 0
   s.mark = 0
   s.parent = new False{}
   pool[0] = s

   ;Tell Stanza about stack pool
   call-prim set-num-free-stacks(num-stacks - 1)
   call-prim set-free-stacks(addr(pool[1]))
   call-prim set-stack-pool(pool)

   return 0

lostanza val mem-size:long = 1024 * 1024
lostanza var heap-mem:ptr<long> 
lostanza var free-mem:ptr<long>
lostanza var free-ptr:ptr<long>
lostanza defn initialize-heaps () -> int :
   heap-mem = call-c malloc(mem-size)
   free-mem = call-c malloc(mem-size)
   call-prim set-heap(heap-mem)
   call-prim set-heap-limit(heap-mem + mem-size)
   return 0

lostanza defn initialize-stanza () -> ref<False> :
   initialize-stacks()
   initialize-heaps()
   return new False{}

initialize-stanza()

lostanza defn cast-error () -> int :
   call-c printf("Cast Error\n")
   call-c exit(-1)
   return 0

lostanza defn arity-error () -> int :
   call-c printf("Arity Error\n")
   call-c exit(-1)
   return 0

lostanza defn branch-error () -> int :
   call-c printf("Branch Error\n")
   call-c exit(-1)
   return 0

lostanza defn variable-uninitialized-error () -> int :
   call-c printf("Variable Uninitialized Error\n")
   call-c exit(-1)
   return 0

;Extend heap
lostanza defn extend-heap (sz:long) -> int :
   call-c printf("Extend heap\n")   
   new-stack<int>{run-garbage-collector()}
   if call-prim heap() + sz > call-prim heap-limit() :
      call-c printf("Out of heap memory.\n")
      call-c exit(-1)
   return 0

lostanza defn run-garbage-collector () -> int :
   ;Initialize free pointer
   free-ptr = free-mem

   ;=== ? What happens if the garbage collector requires more stacks ? ===

   ;Mark collection stack
   val collection-stack = call-prim stack()
   collection-stack.mark = 1

   call-c printf("Print out the root set\n")
   call-c printf("Scan Globals\n")
   scan-globals()
   
   call-c printf("Scan Parent of Collection Stack\n")
   scan-stack(collection-stack.parent as ref<Stack>)

   call-c printf("Scan heap\n")
   scan-heap()

  ;Swap free memory with heap
   call-c printf("Swap free with heap\n")
   val swap = heap-mem
   heap-mem = free-mem
   free-mem = swap
   call-prim set-heap(free-ptr)
   call-prim set-heap-limit(heap-mem + mem-size)

   ;Free all unused stacks
   call-c printf("Free all unused stacks\n")
   free-unmarked-stacks()
   
   return 0

lostanza defn scan-globals () -> int :
   ;Get tables
   val globals = call-prim globals() as ptr<long>
   val map = call-prim global-map() as ptr<RefMap>
   ;Scan globals
   scan-map-words(map.bits, map.length, globals)   
   return 0

lostanza defn* scan-stack (s:ref<Stack>) -> int :
   if s.mark == 0 :
      s.mark = 1
      scan-stack-frames(s.frames, s.sp)
      match(s.parent) :
         (p:ref<Stack>) : return scan-stack(p)
         (p:ref<False>) : return 0
   else :      
      return 0

lostanza defn scan-heap () -> int :
   var p: ptr<long> = free-mem
   while p < free-ptr :
      call-c printf("free-ptr = %p\n", free-ptr)
      val tagbits = [p] & 3
      if tagbits == 0 :
         p = scan-object(p)
      else if tagbits == 1 :
         p = scan-array(p)
      else :
         call-c printf("Invalid tag bits in heap: %lx\n", tagbits)
         call-c exit(-1)
         return 0
   return 0      

lostanza defn scan-object (p:ptr<long>) -> ptr<long> :
   ;p is [tag-word, cells ...]
   val tag = p[0] >> 3
   call-c printf("scan-object(%p) with tag %ld\n", p, tag)
   val map = object-map(tag)
   scan-map-words(base-bits(map), base-nwords(map), p + 8)
   return p + 8 + map.base-size

lostanza defn scan-array (p:ptr<long>) -> ptr<long> :
   ;p is [len-word, tag-word, cells ...]
   val len = p[0] >> 3
   val tag = p[1] >> 3
   call-c printf("scan-array(%p) with tag %ld and length %ld\n", p, tag, len)
   
   ;Calculate the total size of object, rounding up to nearest 8 bytes
   val map = object-map(tag)
   val bytes = ((map.base-size + map.tail-size * len) + 7) & -8   

   ;Scan base of array
   scan-map-words(base-bits(map), base-nwords(map), p + 16)
   
   ;Scan tail of array if word aligned. (Only word aligned tails can contain references).
   if map.tail-size & 3 == 0 :
      var tail:ptr<long> = p + 16 + map.base-size
      val tbits = tail-bits(map)
      val tnwords = tail-nwords(map)
      for (var i:long = 0, i < len, i = i + 1) :
         scan-map-words(tbits, tnwords, tail)
         tail = tail + map.tail-size

   ;Return end of array
   return p + 16 + bytes

lostanza defn* scan-stack-frames (fs:ptr<StackFrame>, end:ptr<?>) -> int :
   if fs < end :
      val map = [fs].map
      scan-map-words(map.bits, map.length, [fs].items)
      val next-fs = addr([fs].items[map.length]) as ptr<StackFrame>
      return scan-stack-frames(next-fs, end)
   else :   
      return 0

lostanza defn* scan-map-words (map:ptr<long>, n:long, refs:ptr<long>) -> int :
   if n > 64 :
      scan-map-word([map], 64, refs)
      return scan-map-words(addr(map[1]), n - 64, addr(refs[1]))
   else if n > 0 :
      scan-map-word([map], n, refs)
      return 0
   else :
      return 0

lostanza defn scan-map-word (map:long, n:long, refs:ptr<long>) -> int :
   var ref-ptr:ptr<long> = refs
   for (var i:long = 0, i < n, i = i + 1) :
      val b = (map >> i) & 1
      if b : [ref-ptr] = post-gc-object([ref-ptr])
      ref-ptr = ref-ptr + sizeof(long)
   return 0

lostanza defn post-gc-object (obj:long) -> long :
   call-c printf("post-gc-object(%p)\n", obj)
   val tagbits = obj & 3
   if tagbits == 1 :
      val obj-ptr = (obj - tagbits) as ptr<long>
      val tag = obj-ptr[0] >> 3
      call-c printf("object tag = %ld\n", tag)
      ;If broken heart, then return forwarding pointer
      if tag == -1 :
         return obj-ptr[1]
      ;Otherwise, copy object
      else :
         val map = object-map(tag)
         if tag == tagof(Stack) :
            call-c printf("object is stack\n")
            return obj
         else if finite?(map) :
            call-c printf("object is finite\n")
            call-c printf("base size = %ld bytes\n", map.base-size)
            val obj* = copy-object-to-free(obj-ptr, map.base-size) + tagbits
            obj-ptr[0] = -1
            obj-ptr[1] = obj*
            call-c printf("post-gc-object(%p) = %p\n", obj, obj*)
            return obj*
         else :
            call-c printf("object is infinite\n")
            call-c printf("base size = %ld bytes, tail size = %ld bytes\n", map.base-size, map.tail-size)
            val obj* = copy-array-to-free(obj-ptr, map.base-size, map.tail-size) + tagbits
            obj-ptr[0] = -1
            obj-ptr[1] = obj*
            call-c printf("post-gc-object(%p) = %p\n", obj, obj*)
            return obj*
   else :
      return obj

lostanza deftype ObjectMap :
   base-size: int
   tail-size: int
   bits: long ...
   
lostanza defn object-map (tag:long) -> ptr<ObjectMap> :
   val table = call-prim object-table() as ptr<ptr<ObjectMap>>
   return table[tag]

lostanza defn finite? (m:ptr<ObjectMap>) -> long :
   return m.tail-size == 0 

lostanza defn base-bits (m:ptr<ObjectMap>) -> ptr<long> :
   return m.bits

lostanza defn base-nwords (m:ptr<ObjectMap>) -> long :
   return m.base-size & 3

lostanza defn tail-bits (m:ptr<ObjectMap>) -> ptr<long> :
   return addr(m.bits[base-nwords(m)])

lostanza defn tail-nwords (m:ptr<ObjectMap>) -> long :
   return m.tail-size & 3

lostanza defn copy-object-to-free (obj:ptr<long>, size:long) -> long :
   val ret = free-ptr
   copy-bytes-to-free(obj, size + 8)
   return ret as long

lostanza defn copy-array-to-free (obj:ptr<long>, size:long, tail:long) -> long :
   val ret = free-ptr + 8   ;Returned pointer points to the tag word
   val length = obj[-1] >> 3   ;Retrieve length from header word
   val bytes = ((size + tail * length) + 7) & -8   ;Calculate the total size of object, rounding up to nearest 8 bytes
   copy-bytes-to-free(obj - 8, bytes + 16)   ;Copy the bytes to free including header
   return ret as long

lostanza defn copy-bytes-to-free (p:ptr<long>, n:long) -> int :
   if n & 3 != 0 :
      call-c printf("Copy bytes must take a multiple of 8.\n")
      call-c exit(-1)
   val nwords = n >> 3
   for (var i:long = 0, i < nwords, i = i + 1) :
      free-ptr[i] = p[i]
   free-ptr = free-ptr + n
   return 0

lostanza defn free-stack (s:ref<Stack>) -> long :
   ;Ensure s is the last active stack
   val stk-pool = call-prim stack-pool()
   val last-stk = (call-prim free-stacks())[-1]
   if s != last-stk :
      ;Swap locations of last-stk with s
      [stk-pool + s.position] = last-stk
      [stk-pool + last-stk.position] = s
      ;Swap positions of last-stk with s
      val s-position = s.position
      s.position = last-stk.position
      last-stk.position = s-position
   ;Free last active stack
   call-prim set-num-free-stacks(call-prim num-free-stacks() + 1)
   call-prim set-free-stacks(call-prim free-stacks() - 8)   
   return 0

lostanza defn free-unmarked-stacks () -> int :
   var stk-ptr:ptr<ref<Stack>> = call-prim stack-pool()
   while stk-ptr < call-prim free-stacks() :
      val s = [stk-ptr]
      if s.mark == 0 :
         free-stack(s)
      else :
         stk-ptr = stk-ptr + 8
      s.mark = 0
   return 0


;Extend stack
lostanza defn extend-stack () -> int :
   call-c printf("Extend stack\n")
   call-c exit(-1)
   return 0

defpackage user :
   import core

lostanza deftype StructA :
   a: byte
   b: ref<?>
   c: ref<?>
   d: byte
   e: ref<?>

lostanza deftype StructB :
   a: ref<?>
   b: int
   c: ref<?>

lostanza deftype StructC

;1. Loop that creates objects.
;2. Objects with variable length.
;2.b Objects with variable length of only primitives.
;3. Loops in object graph.
;4. Object with self loop.
;5. Empty Objects.
;6. Other stacks.


lostanza val X:ref<False> = new False{}
lostanza val Z:int = 0
lostanza val W:int = 1
lostanza val Y:ref<False> = new False{}
lostanza val H:StructA = StructA{0 as byte, new Int{1}, new Int{2}, 1 as byte, new Int{3}}

lostanza defn make-objects () -> ref<False> :
   while 1 :
      val a = new StructA{0 as byte, new Int{1}, new Int{2}, 1 as byte, new Int{3}}
      val b = new StructB{a, 42, a}
   return new False{}

lostanza defn recur (n:int) -> ref<False> :
   call-c printf("recur(%d)\n", n)
   val a = n + n
   val b = a + n + n
   val c = new StructB{new False{}, a, new False{}}
   val d = new StructB{c, a, c}
   if n == 0 :
      make-objects()
      return new False{}
   else :
      recur(n - 1)
      call-c printf("c.a = %p, c.c = %p, d.a = %p, d.c = %p\n",
                    c.a, c.c, d.a, d.c)
      return new False{}

lostanza: recur(40)



