defpackage core

;============================================================
;================== Core Types ==============================
;============================================================

public :
   lostanza deftype Byte :
      value: byte

   lostanza deftype Char :
      value: byte
      
   lostanza deftype Int :
      value: int
      
   lostanza deftype Long :
      value: long
      
   lostanza deftype Float :
      value: float

   lostanza deftype Double :
      value: double
      
   lostanza deftype String :
      length: long
      hash: int
      chars: byte ...

   lostanza deftype Symbol :
      length: long
      hash: int
      chars: byte ...      

   deftype List
   lostanza deftype FullList <: List :
      head: ref<?>
      tail: ref<List>
   lostanza deftype NilList <: List   

   lostanza deftype True      
   lostanza deftype False
  
   lostanza deftype Tuple<T> :
      length: long
      items: ref<T> ...

   lostanza deftype Fn :
      code: ptr<?>
      free: ref<?> ...
      
   lostanza deftype Stack :
      position: int
      mark: int
      parent: ref<False|Stack>
      sp: ptr<?>
      frames: StackFrame ...

;============================================================
;================ Internal Types ============================
;============================================================

lostanza deftype Box :
   item: ref<?>
lostanza deftype Type :
   code: ptr<?>
   free: ref<?> ...
lostanza deftype StackFrame :
   ret: long
   map: ptr<RefMap>
   items: long ...
lostanza deftype RefMap :
   length: long
   bits: long ...
      
public extern printf: (ptr<byte>, ? ...) -> int
extern malloc: long -> ptr<?>
public extern exit: int -> int

;============================================================
;==================== Initialization ========================
;============================================================

lostanza defn initialize-stanza () -> ref<False> :
   initialize-stacks()
   initialize-heaps()
   initialize-constants()
   return new False{}

initialize-stanza()

;                  Stack Initialization
;                  ====================

extern stanza_stack_size: long
lostanza var num-stacks:long
lostanza defn initialize-stacks () -> int :
   ;Create stack pool
   num-stacks = 1024
   val pool:ptr<ref<Stack>> = call-c malloc(sizeof(ref<?>) * num-stacks)
   for (var i:int = 1, i < num-stacks, i = i + 1) :
      val p:ptr<long> = call-c malloc(stanza_stack_size)
      [p] = tagof(Stack) << 3 
      val s = (p + 1) as ref<Stack>
      s.position = i << 3
      s.mark = 0
      pool[i] = s

   ;Initialize current stack
   val s = call-prim stack()
   val p = (addr([s]) - 8) as ptr<long>
   [p] = tagof(Stack) << 3
   s.position = 0
   s.mark = 0
   s.parent = new False{}
   pool[0] = s

   ;Tell Stanza about stack pool
   call-prim set-num-free-stacks(num-stacks - 1)
   call-prim set-free-stacks(addr(pool[1]))
   call-prim set-stack-pool(pool)

   return 0

;                 Heap Initialization
;                 ===================

lostanza var mem-size:long
lostanza var heap-mem:ptr<long> 
lostanza var free-mem:ptr<long>
lostanza var free-ptr:ptr<long>
lostanza defn initialize-heaps () -> int :
   mem-size = 1024 * 1024
   heap-mem = call-c malloc(mem-size)
   free-mem = call-c malloc(mem-size)
   call-prim set-heap(heap-mem)
   call-prim set-heap-limit(heap-mem + mem-size)
   return 0

;                  Constant Initialization
;                  =======================

lostanza var const-ptr:ptr<?>
lostanza defn initialize-constants () -> int :
   ;Initialize read pointer to beginning of the constant table
   ;[num, constants ...]
   const-ptr = call-prim constant-table()
   val n-consts = read-const-int()
   call-c printf("n-consts = %d\n", n-consts)
   
   ;First n-consts entries in the global table are for constants
   var gs:ptr<ref<?>> = call-prim globals()
   for (var i:int = 0, i < n-consts, i = i + 1) :
      call-c printf("initializing constant %p\n", addr(gs[i]))
      gs[i] = read-const()   
      call-c printf("initialized constant %p to %p\n", addr(gs[i]), gs[i])
   
   return 0
   
lostanza defn read-const () -> ref<?> :
   val tag = read-const-int()
   if tag == tagof(Int) :
      return new Int{read-const-int()}
   else if tag == tagof(True) :
      return new True{}
   else if tag == tagof(False) :
      return new False{}
   else if tag == tagof(Long) :
      return new Long{read-const-long()}
   else if tag == tagof(FullList) :
      val len = read-const-int()
      return read-const-list(len)
   else :
      call-c printf("Unknown constant tag: %ld\n", tag)
      call-c exit(-1)
      return new False{}

lostanza defn read-const-list (n:int) -> ref<List> :
   if n == 0 : return new NilList{}
   else : return new FullList{read-const(), read-const-list(n - 1)}

lostanza defn read-const-int () -> int :
   val value = [const-ptr as ptr<int>]
   const-ptr = const-ptr + sizeof(int)
   return value

lostanza defn read-const-long () -> long :
   val value = [const-ptr as ptr<long>]
   const-ptr = const-ptr + sizeof(long)
   return value

;lostanza defn read-const-ref () -> ref<?> :
;   val value = [const-ptr as ptr<ref<?>>]
;   const-ptr = const-ptr + sizeof(ref<?>)
;   return value



;============================================================
;============== Generated Entry Points ======================
;============================================================

lostanza defn cast-error () -> int :
   call-c printf("Cast Error\n")
   call-c exit(-1)
   return 0

lostanza defn arity-error () -> int :
   call-c printf("Arity Error\n")
   call-c exit(-1)
   return 0

lostanza defn branch-error () -> int :
   call-c printf("Branch Error\n")
   call-c exit(-1)
   return 0

lostanza defn variable-uninitialized-error () -> int :
   call-c printf("Variable Uninitialized Error\n")
   call-c exit(-1)
   return 0

;============================================================
;=============== Garbage Collector ==========================
;============================================================

;              Generated Entry Points
;              ======================

;Called when attempting to allocate beyond the heap limit.
lostanza defn extend-heap (sz:long) -> int :
   new-stack<int>{run-garbage-collector()}
   if call-prim heap() + sz > call-prim heap-limit() :
      call-c printf("Out of heap memory.\n")
      call-c exit(-1)
   return 0

;Called when the number of free stacks is 2 or less.
;Running extend-stack uses two stacks (1 for GC, 1 for handling extend-stack during GC).
lostanza defn extend-stack () -> int :   
   if gc-running :
      call-c printf("Stack Overflow in Garbage Collector\n")
      call-c exit(-1)
      return 0
   else :
      new-stack<int>{run-garbage-collector()}
      if call-prim num-free-stacks() <= 1 :
         call-c printf("Out of stack segments.\n")
         call-c exit(-1)
      return 0

;                   Main Function
;                   =============

;Main function for garbage collector
lostanza var gc-running:long = 0
lostanza defn run-garbage-collector () -> int :
   ;Mark GC as running to detect stack extension within GC
   gc-running = 1

   ;Initialize free pointer to point to beginning of free memory before copying starts.
   free-ptr = free-mem

   ;Current stack is the collection stack, the stack that the GC runs in.
   ;Set its mark bit to indicate that it is active.
   val collection-stack = call-prim stack()
   collection-stack.mark = 1

   ;Scan roots
   scan-globals()
   scan-stack(collection-stack.parent as ref<Stack>)

   ;Scan internal pointers of all heap objects
   scan-heap()

   ;Swap free memory with heap
   val swap = heap-mem
   heap-mem = free-mem
   free-mem = swap
   call-prim set-heap(free-ptr)
   call-prim set-heap-limit(heap-mem + mem-size)

   ;All active stacks have their mark bits set.
   free-unmarked-stacks()

   ;Finish
   gc-running = 0   
   return 0

;                 Scanning Functions
;                 ==================

;Copy all global references to the free memory.
lostanza defn scan-globals () -> int :
   ;Get tables
   val globals = call-prim globals() as ptr<long>
   val map = call-prim global-map() as ptr<RefMap>
   ;Scan globals
   scan-map-words(map.bits, map.length, globals)   
   return 0
   
;Copy all stack references in this and parent stacks to free memory.
lostanza defn* scan-stack (s:ref<Stack>) -> int :
   if s.mark == 0 :
      s.mark = 1
      scan-stack-frames(s.frames, s.sp)
      match(s.parent) :
         (p:ref<Stack>) : return scan-stack(p)
         (p:ref<False>) : return 0
   else :      
      return 0

;Copy all internal references in heap to free memory.
lostanza defn scan-heap () -> int :
   var p: ptr<long> = free-mem
   while p < free-ptr :
      val tagbits = [p] & 3
      if tagbits == 0 :
         p = scan-object(p)
      else if tagbits == 1 :
         p = scan-array(p)
      else :
         call-c printf("Invalid tag bits in heap: %lx\n", tagbits)
         call-c exit(-1)
         return 0
   return 0      

;Copy all internal references in object to free memory.
lostanza defn scan-object (p:ptr<long>) -> ptr<long> :
   ;p is [tag-word, cells ...]   
   val tag = p[0] >>> 3
   val map = object-map(tag)
   scan-map-words(base-bits(map), base-nwords(map), p + 8)
   return p + 8 + map.base-size

;Copy all internal references in array to free memory.
lostanza defn scan-array (p:ptr<long>) -> ptr<long> :
   ;p is [len-word, tag-word, cells ...]
   val len = p[0] >>> 3
   val tag = p[1] >>> 3
   
   ;Calculate the total size of object, rounding up to nearest 8 bytes
   val map = object-map(tag)
   val bytes = ((map.base-size + map.tail-size * len) + 7) & -8   

   ;Scan base of array
   scan-map-words(base-bits(map), base-nwords(map), p + 16)
   
   ;Scan tail of array if it contains references.
   if tail-refs?(map) :
      var tail:ptr<long> = p + 16 + map.base-size
      val tbits = tail-bits(map)
      val tnwords = tail-nwords(map)
      for (var i:long = 0, i < len, i = i + 1) :
         scan-map-words(tbits, tnwords, tail)
         tail = tail + map.tail-size

   ;Return end of array
   return p + 16 + bytes

;Copy all internal references in stack frames, fs, until end pointer
lostanza defn* scan-stack-frames (fs:ptr<StackFrame>, end:ptr<?>) -> int :
   if fs < end :
      val map = [fs].map
      scan-map-words(map.bits, map.length, [fs].items)
      val next-fs = addr([fs].items[map.length]) as ptr<StackFrame>
      return scan-stack-frames(next-fs, end)
   else :   
      return 0

;Scan n references (marked with a 1 bit) from the given pointer
lostanza defn* scan-map-words (map:ptr<long>, n:long, refs:ptr<long>) -> int :
   if n > 64 :
      scan-map-word([map], 64, refs)
      return scan-map-words(addr(map[1]), n - 64, addr(refs[1]))
   else if n > 0 :
      scan-map-word([map], n, refs)
      return 0
   else :
      return 0

lostanza defn scan-map-word (map:long, n:long, refs:ptr<long>) -> int :
   var ref-ptr:ptr<long> = refs
   for (var i:long = 0, i < n, i = i + 1) :
      val b = (map >> i) & 1
      if b : [ref-ptr] = post-gc-object([ref-ptr])
      ref-ptr = ref-ptr + sizeof(long)
   return 0

;                Copying Functions
;                =================

lostanza defn post-gc-object (obj:long) -> long :
   val tagbits = obj & 3
   if tagbits == 1 :
      val obj-ptr = (obj - tagbits) as ptr<long>
      val tag = obj-ptr[0] >>> 3
      
      ;If broken heart, then return forwarding pointer
      if tag == -1 :
         return obj-ptr[1]
      ;Otherwise, copy object
      else :
         val map = object-map(tag)
         if tag == tagof(Stack) :
            return obj
         else if finite?(map) :
            val obj* = copy-object-to-free(obj-ptr, map.base-size) + tagbits
            set-broken-heart(obj-ptr, obj*)
            return obj*
         else :
            val obj* = copy-array-to-free(obj-ptr, map.base-size, map.tail-size) + tagbits
            set-broken-heart(obj-ptr, obj*)
            return obj*
   else :
      return obj

lostanza defn set-broken-heart (old:ptr<long>, new:long) -> int :
   old[0] = -1
   old[1] = new
   return 0
      
lostanza defn copy-object-to-free (obj:ptr<long>, size:long) -> long :
   val ret = free-ptr
   copy-bytes-to-free(obj, size + 8)
   return ret as long

lostanza defn copy-array-to-free (obj:ptr<long>, size:long, tail:long) -> long :
   ;obj: [len, tag, items ...]   
   ;Returned pointer points to the tag word
   val ret = free-ptr + 8   
   val length = obj[-1] >>> 3
   
   ;Calculate the total size of object, rounding up to nearest 8 bytes
   val bytes = ((size + tail * length) + 7) & -8
   
   ;Copy the bytes to free including header
   copy-bytes-to-free(obj - 8, bytes + 16)
   
   return ret as long

lostanza defn copy-bytes-to-free (p:ptr<long>, n:long) -> int :
   if n & 3 != 0 :
      call-c exit(-1)
   val nwords = n >>> 3
   for (var i:long = 0, i < nwords, i = i + 1) :
      free-ptr[i] = p[i]
   free-ptr = free-ptr + n
   return 0

;               Utilities for ObjectMap
;               =======================

lostanza deftype ObjectMap :
   base-size: int
   tail-size: int
   bits: long ...
   
lostanza defn object-map (tag:long) -> ptr<ObjectMap> :
   val table = call-prim object-table() as ptr<ptr<ObjectMap>>
   return table[tag]

lostanza defn finite? (m:ptr<ObjectMap>) -> long :
   return m.tail-size == 0 

lostanza defn base-bits (m:ptr<ObjectMap>) -> ptr<long> :
   return m.bits

lostanza defn base-nwords (m:ptr<ObjectMap>) -> long :
   return m.base-size >>> 3

lostanza defn tail-bits (m:ptr<ObjectMap>) -> ptr<long> :
   return addr(m.bits[base-nwords(m)])

lostanza defn tail-nwords (m:ptr<ObjectMap>) -> long :
   return m.tail-size >>> 3

lostanza defn tail-refs? (m:ptr<ObjectMap>) -> long :
   val n = tail-nwords(m)
   val bits = tail-bits(m)
   for (var i:long = 0, i < n, i = i + 1) :
      if bits[i] != 0 :
         return 1
   return 0

;                  Releasing Stacks
;                  ================

;Free an active stack, and add back to the free stack list.
lostanza defn free-stack (s:ref<Stack>) -> long :
   ;Ensure s is the last active stack
   val stk-pool = call-prim stack-pool()
   val last-stk = (call-prim free-stacks())[-1]
   if s != last-stk :
      ;Swap locations of last-stk with s
      [stk-pool + s.position] = last-stk
      [stk-pool + last-stk.position] = s
      ;Swap positions of last-stk with s
      val s-position = s.position
      s.position = last-stk.position
      last-stk.position = s-position
   ;Free last active stack
   call-prim set-num-free-stacks(call-prim num-free-stacks() + 1)
   call-prim set-free-stacks(call-prim free-stacks() - 8)   
   return 0

;Free all unmarked stacks.
lostanza defn free-unmarked-stacks () -> int :
   var stk-ptr:ptr<ref<Stack>> = call-prim stack-pool()
   while stk-ptr < call-prim free-stacks() :
      val s = [stk-ptr]
      if s.mark == 0 :
         free-stack(s)
      else :
         stk-ptr = stk-ptr + 8
      s.mark = 0
   return 0


;============================================================
;====================== Strings =============================
;============================================================

;lostanza defn literal-string (length:long, chars:ptr<byte>) -> ref<String> :

;============================================================
;====================== Scratch =============================
;============================================================

defpackage user :
   import core

;lostanza deftype StructA :
;   a: byte
;   b: ref<?>
;   c: ref<?>
;   d: byte
;   e: ref<?>
;
;lostanza deftype StructB :
;   a: ref<?>
;   b: int
;   c: ref<?>
;
;lostanza deftype MyArray :
;   n: int
;   items: ref<?> ...
;
;lostanza deftype MyByteArray :
;   a: byte
;   b: byte
;   c: byte
;   items: byte ...
;
;lostanza deftype StructC


;lostanza val X:ref<False> = new False{}
;lostanza val Z:int = 0
;lostanza val W:int = 1
;lostanza val Y:ref<False> = new False{}
;lostanza val H:StructA = StructA{0 as byte, new Int{1}, new Int{2}, 1 as byte, new Int{3}}

;lostanza defn blow-heap () -> ref<False> :
;   for (var i:long = 0, i < 1024 * 1024, i = i + 1) :
;      val a = new StructB{new False{}, 0, new False{}}
;   return new False{}
;
;lostanza defn recur (n:int) -> ref<False> :
;   call-c printf("recur(%d)\n", n)
;   val a = n + n
;   val b = a + n + n
;   val c = new StructB{new False{}, a, new False{}}
;   val d = new StructB{c, a, c}
;   val e = new MyArray{10}[10]
;   for (var i:long = 0, i < 10, i = i + 1) :
;      e.items[i] = new False{}
;   e.items[5] = e
;   
;   val f = new MyByteArray{1 as byte, 2 as byte, 3 as byte}[10]
;   for (var i:long = 0, i < 10, i = i + 1) :
;      f.items[i] = 42 as byte
;
;   val g = new StructC{}
;
;   if n == 0 :
;      blow-heap()
;      return new False{}
;   else :
;      recur(n - 1)
;      val e5 = e.items[5] as ref<MyArray>
;      call-c printf("c.a = %p, c.c = %p, d.a = %p, d.c = %p, e.items[5].items[1] = %p, f.items[5] = %d, g = %p\n",
;                    c.a, c.c, d.a, d.c, e5.items[1], f.items[5] as int, g)
;      return new False{}

;lostanza: recur(40)

;lostanza defn print-list (r:ref<List>) -> ref<False> :
;   call-c printf("print-list(%p)\n", r)
;   match(r) :
;      (r:ref<FullList>) :
;         call-c printf("%p ", r.head)
;         return print-list(r.tail)
;      (r:ref<NilList>) :
;         call-c printf(".\n")
;         return new False{}
;
;print-list(`(1 2 3 4 5))
;
;lostanza defn typeof-num (n:ref<?>) -> ref<False> :
;   var name:ptr<byte>
;   match(n) :
;      (n:ref<Byte>) :
;         call-c printf("value = %d\n", n.value as int)
;         name = "Byte"
;      (n:ref<Char>) :
;         call-c printf("value = %c\n", n.value)
;         name = "Char"
;      (n:ref<Int>) :
;         call-c printf("value = %d\n", n.value)
;         name = "Int"
;      (n:ref<Float>) :
;         call-c printf("value = %g\n", n.value)
;         name = "Float"
;   call-c printf("%s\n", name)
;   return new False{}
;
;typeof-num(30)
;typeof-num(30.4)
;typeof-num('f')

val a = 30.4
lostanza :
   call-c printf("a = %g\n", a.value as double)
