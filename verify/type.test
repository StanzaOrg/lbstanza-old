($begin

($package a)

($deftype A () ($none))
($deftype B () ($none))
($deftype C () ($none))


;Demonstrating argument inference using body of called function
;($def a ($none) ($new A))
;($do
;   ($fn (($none)) ($none) (f)
;      ($do f a))
;
;   ($fn (($none)) ($none) (x)
;      x))


;Demonstrating ambiguity selection using body of function
;($defmulti A! () (A) ($none))
;($defmulti f () (($-> (A) A)) ($none))
;($defmulti f () (($-> (B) B)) ($none))
;
;($do f
;   ($fn (($none)) ($none) (a)
;      ($do A! a)))


;Demonstrating calling ambiguous function using ambiguous arguments
;($deftype List (T) ($none))
;($deftype Array (T) ($none))
;($deftype Box (T) ($none))
;($deftype Tree (T) ($none))
;($deftype Int () ($none))
;($deftype String () ($none))
;
;($defmulti map (($cap T) ($cap S)) (($-> (T) ($cap S)) ($of List ($cap T))) ($of List S))
;($defmulti map (($cap T) ($cap S)) (($-> (T) ($cap S)) ($of Array ($cap T))) ($of Array S))
;($defmulti value (($cap T)) (($of Box ($cap T))) T)
;($defmulti value (($cap T)) (($of Tree ($cap T))) String)
;
;($def xs ($?) ($new ($of List ($of Box String))))
;($def result ($none) ($do map value xs))


;Demonstrating calling ambiguous function using ambiguous arguments
;($defmulti f () (($-> (A) A)) ($none))
;($defmulti f () (($-> (B) B)) ($none))
;($defmulti g () (A) A)
;($defmulti g () (C) C)
;($def result ($none) ($do f g))



;($defmulti func (x, ($cap y), ($cap z)) (X, ($cap ($cap z)), ($none)) ($none))

;($defn func () () ($none) ()
;   ($begin 3 ($begin)))

;($ls-let
;   ($ls-begin
;      ($ls-return 2)
;      ($ls-do ($of f X Y))))

;($ls-defn func () (A B C) D (x, y, z)
;   ($ls-do f))

;($deftype a (a b) ($none))
;($deftype A () ($and A B))
;($deftype B () ($none))
;($deftype D () ($none))
;($deftype E () A)
;
;($ls-deftype Animal () ($none)
;   (($ls-ref A) ($ls-ref B)) ($none)
;   (x, y) ($none))
;
;($ls-deftype Animal2 () ($none)
;   (($ls-ref A) ($ls-ref B)) ($ls-ref D)
;   (x, y) z)
;
;($ls-def z Animal 3)


;($deftype x)
;($deftype a (a b) ($none))
;($deftype a (a b) ($and ($none) a))
;($deftype a () ($of a))
;($deftype a () ($of a ($and a b)))
;($deftype a () ($of a ($or a b)))
;($deftype a () ($of a ($-> a b)))
;($deftype a () ($of a ($-> (a b) b)))
;($deftype a () ($of a ($?)))
;($deftype a () ($of a ($void)))
;($deftype a () ($of a ($cap x)))
;($deftype a () ($of a ($cap (x))))
;($deftype a () ($cap (x)))
;($import ($of))
;($import ($of a)
;   ($prefix st/)
;   ($prefix st- 3)
;   ($prefix-of a 10)
;   ($prefix-of))
;($import ($of a)
;   ($prefix st/)
;   ($prefix st-)
;   ($prefix-of (a) A))
;($import A
;   ($prefix st/)
;   ($prefix st-)
;   ($prefix-of (a) A))
;($begin
;   ($package a
;      ($import b
;         ($prefix p)
;         ($prefix-of (a b c) p2))
;      ($import c
;         ($prefix-of (a b c) p2))
;      ($package d))
;   ($package a
;      ($import b
;         ($prefix p)
;         ($prefix-of (a b c) p2))
;      ($import c
;         ($prefix-of (a b c) p2))
;      ($package d))
;   ($public
;      ($begin
;         ($deftype a () ($of a ($cap x)))
;         ($package d))))

;($defmulti f (a c ($cap b)) (($-> (($of a)) ($cap b))) b)
;($defn f () (Animal Animal) ($none) (x y)
;   ($begin
;      ($def z ($none) 3)
;      ($def w ($none) 4)
;      ($do x)
;      y))
;
;($ls-defn f () (Animal Animal) Animal (x y)
;   ($begin
;      ($ls-return ($ls-do x))))

;($defmethod f (f) (Animal Animal) ($none) (f y) ($begin
;   ($defn g () (a) ($none) (x) x)   
;   ($defn g () (Animal) ($none) (x) x)
;   ($fn (a Animal) ($none) (x y) x)
;   ($begin)))
;
)