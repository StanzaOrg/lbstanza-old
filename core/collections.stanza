;See License.txt for details about licensing.

defpackage collections :
  import core

;============================================================
;===================== Utilities ============================
;============================================================

;Sentinel object
deftype Sentinel
defn sentinel () : new Sentinel
defmethod print (o:OutputStream, s:Sentinel) : print(o, "XXX")

;Table Item Structure
defstruct TableItem<K,V> :
  hash: Int
  key: K
  value: V

defmethod print (o:OutputStream, i:TableItem) :
  print(o, "(%_) %~ => %~" % [hash(i), key(i), value(i)])

;Int Item Structure
defstruct IntItem<V> :
  key: Int
  value: V

defmethod print (o:OutputStream, i:IntItem) :
  print(o, "%~ => %~" % [key(i), value(i)])

;Set Item Structure
defstruct SetItem<K> :
  hash: Int
  key: K

defmethod print (o:OutputStream, x:SetItem) :
  print(o, "(%_) %_" % [hash(x), key(x)])

;Binary search
;Returns n such that the first n numbers in xs < v
defn bsearch<?T,?S> (less?: (T, S) -> True|False,
                     xs:Array<?T>,
                     n:Int,
                     v:?S) -> Int :
  defn* num-smaller (i:Int, n:Int) :
    if not xs[i] < v :
      0
    else if n == 1 :
      1
    else :
      val m = n / 2
      val d = num-smaller(i + m, n - m)
      if d > 0 : m + d
      else : num-smaller(i, m)
  if n == 0 : 0    
  else : num-smaller(0, n)


;============================================================
;===================== Vectors ==============================
;============================================================

;                     Interface
;                     =========

public deftype Vector<T> <: IndexedCollection<T>
public defmulti add<?T> (v:Vector<?T>, value:T) -> False
public defmulti add-all<?T> (v:Vector<?T>, vs:Seqable<T>) -> False
public defmulti clear (v:Vector) -> False
public defmulti clear<?T> (v:Vector<?T>, n:Int, x0:T) -> False
public defmulti pop<?T> (v:Vector<?T>) -> T
public defmulti peek<?T> (v:Vector<?T>) -> T

public defmulti remove<?T> (v:Vector<?T>, i:Int) -> T
public defmulti remove (v:Vector, r:Range) -> False
public defmulti update<?T> (f: T -> Maybe<T>, v:Vector<?T>) -> False
public defmulti remove-item<?T> (v:Vector<?T&Equalable>, x:T&Equalable) -> True|False
public defmulti remove-when<?T> (f: T -> True|False, v:Vector<?T>) -> False
public defmulti trim (v:Vector) -> False
public defmulti shorten (v:Vector, size:Int) -> False
public defmulti lengthen<?T> (v:Vector<?T>, size:Int, x:T) -> False
public defmulti set-length<?T> (v:Vector<?T>, length:Int, x:T) -> False

;                   Implementation
;                   ==============

public defn Vector<T> (cap:Int) -> Vector<T> :
   core/ensure-non-negative("capacity", cap)
   var array = Array<T>(cap)
   var size = 0

   defn set-capacity (c:Int) :
      val new-array = Array<T>(c)
      new-array[0 to size] = array
      array = new-array
         
   defn ensure-capacity (c:Int) :
      val cur-c = length(array)
      set-capacity(max(c, 2 * cur-c)) when c > cur-c

   new Vector<T> :
      defmethod get (this, i:Int) :
         core/ensure-index-in-bounds(this, i)
         array[i]

      defmethod set (this, i:Int, value:T) :
         if i == size :
            add(this, value)
         else :
            core/ensure-index-in-bounds(this, i)
            array[i] = value
            
      defmethod set-all (this, r:Range, v:T) :
         core/ensure-index-range(this, r)
         set-all(array, r, v)         

      defmethod length (this) :
         size

      defmethod trim (this) :
         set-capacity(size)

      defmethod set-length (this, len:Int, value:T) :
         if len > size : lengthen(this, len, value)
         else : shorten(this, len)

      defmethod shorten (this, new-size:Int) :
         #if-not-defined(OPTIMIZE) :
            core/ensure-non-negative("size", new-size)
            if new-size > size :
               fatal("Given size (%_) is larger than current size (%_)." % [new-size, size])
         size = new-size
         
      defmethod lengthen (this, new-size:Int, x:T) :
         #if-not-defined(OPTIMIZE) :
            if new-size < size :
               fatal("Given size (%_) is smaller than current size (%_)." % [new-size, size])
         ensure-capacity(new-size)
         set-all(array, size to new-size, x)
         size = new-size

      defmethod add (this, value:T) :
         ensure-capacity(size + 1)
         array[size] = value
         size = size + 1

      defmethod add-all (this, vs:Seqable<T>) :
         match(vs) :
            (vs:Seqable<T> & Lengthable) :
               val n = length(vs)
               ensure-capacity(size + n)
               array[size to (size + n)] = vs
               size = size + n
            (vs) :
               do(add{this, _}, vs)

      defmethod pop (this) :
         #if-not-defined(OPTIMIZE) :
            fatal("Empty Vector") when size == 0
         size = size - 1
         array[size]

      defmethod peek (this) :
         #if-not-defined(OPTIMIZE) :
            fatal("Empty Vector") when size == 0
         array[size - 1]

      defmethod clear (this) :
         size = 0
         
      defmethod clear (this, n:Int, x0:T) :
         if length(array) < n :
            val cap = max(n, 2 * length(array))
            array = Array<T>(cap, x0)
            size = n
         else :
            set-all(array, 0 to n, x0)
            size = n         

      defmethod remove-when (f: T -> True|False, this) :
         for x in this update :
            if f(x) : None()
            else : One(x)

      defmethod remove (this, i:Int) :
         core/ensure-index-in-bounds(this, i)
         val x = array[i]   
         for i in i to (size - 1) do :
            array[i] = array[i + 1]
         size = size - 1
         x

      defmethod remove (this, r:Range) :
         core/ensure-index-range(this, r)
         val [s,e] = core/range-bound(this, r)
         val n = e - s
         if n > 0 :
            for i in s to (size - n) do :
               array[i] = array[i + n]
            size = size - n

      defmethod remove-item (this:Vector<T&Equalable>, x:T&Equalable) :
         match(index-of(this, x)) :
            (i:Int) : (remove(this, i), true)
            (i:False) : false

      defmethod update (f: T -> Maybe<T>, this) :
         defn* loop (dst:Int, src:Int) :
            if src < size :
               match(f(array[src])) :
                  (x:One<T>) :
                     array[dst] = value(x)
                     loop(dst + 1, src + 1)
                  (x:None) :
                     loop(dst, src + 1)
            else :
               size = dst
         loop(0, 0)

      defmethod do (f: T -> ?, this) :
         val n = size
         let loop (i:Int = 0) :
            if i < n :
               f(array[i])
               loop(i + 1)

public defn Vector<T> () -> Vector<T> :
   Vector<T>(8)

public defn to-vector<T> (xs:Seqable<T>) -> Vector<T> :
   val v = Vector<T>()
   add-all(v, xs)
   v

public defn map<R,?T> (f: T -> R, v:Vector<?T>) -> Vector<R> :
   val ret = Vector<R>(length(v))
   add-all(ret, seq(f, v))
   ret


;============================================================
;====================== Queues ==============================
;============================================================

;                      Interface
;                      =========

public deftype Queue<T> <: IndexedCollection<T>
public defmulti add<?T> (q:Queue<?T>, x:T) -> False
public defmulti clear (q:Queue) -> False
public defmulti pop<?T> (q:Queue<?T>) -> T
public defmulti peek<?T> (q:Queue<?T>) -> T

;                    Implementation
;                    ==============

public defn Queue<T> (initial-cap:Int) -> Queue<T> :
   core/ensure-non-negative("capacity", initial-cap)
   var cap:Int = next-pow2(initial-cap)
   var array:Array<T> = Array<T>(cap)
   var begin:Int = 0
   var size:Int = 0

   defn ensure-capacity (c:Int) :
      defn set-capacity (c:Int) :
         val new-array = Array<T>(c)
         for i in 0 to size do :
            new-array[i] = array[wrapped-index(i)]
         array = new-array
         cap = c
         begin = 0
      set-capacity(next-pow2(c)) when c > cap         

   defn wrapped-index (i:Int) :
      (begin + i) & (cap - 1)

   new Queue<T> :
      defmethod get (this, i:Int) :
         core/ensure-index-in-bounds(this, i)
         array[wrapped-index(i)]
         
      defmethod set (this, i:Int, value:T) :
         if i == -1 :
            add(this, value)
         else :
            core/ensure-index-in-bounds(this, i)
            array[wrapped-index(i)] = value

      defmethod add (this, x:T) :
         ensure-capacity(size + 1)
         begin = wrapped-index(-1 + cap)
         array[begin] = x
         size = size + 1

      defmethod pop (this) :
         #if-not-defined(OPTIMIZE) :
            fatal("Empty Queue") when size == 0
         size = size - 1
         array[wrapped-index(size)]
         
      defmethod peek (this) :
         #if-not-defined(OPTIMIZE) :
            fatal("Empty Queue") when size == 0
         array[wrapped-index(size - 1)]

      defmethod length (this) :
         size

      defmethod clear (this) :
         size = 0

public defn Queue<T> () -> Queue<T> :
   Queue<T>(8)

;============================================================
;======================== Tables ============================
;============================================================

;==============================
;==== Mandatory Operations ====
;==============================

public deftype Table<K,V> <: Collection<KeyValue<K,V>> & Lengthable
public defmulti set<?K,?V> (t:Table<?K,?V>, k:K, v:V) -> False
public defmulti get?<?K,?V> (t:Table<?K,?V>, k:K, d:?V) -> V
public defmulti default<?K,?V> (t:Table<?K,?V>, k:K) -> V
public defmulti remove<?K> (t:Table<?K,?>, k:K) -> True|False
public defmulti clear (t:Table) -> False

;=============================
;==== Abstract Operations ====
;=============================

public defmulti key?<?K> (t:Table<?K,?>, k:K) -> True|False
public defmulti get<?K,?V> (t:Table<?K,?V>, k:K) -> V
public defmulti update<?K,?V> (t:Table<?K,?V>, f:V -> V, k:K) -> V
public defmulti keys<?K> (t:Table<?K,?>) -> Seqable<K>
public defmulti values<?V> (t:Table<?,?V>) -> Seqable<V>
public defmulti set?<?K,?V> (t:Table<?K,?V>, k:K, f:() -> V) -> V
public defmulti map!<?K,?V> (f:KeyValue<K,V> -> V, t:Table<?K,?V>) -> False

;==================================
;==== Abstract Implementations ====
;==================================
defmethod key?<?K> (t:Table<?K,?>, k:K) :
  get?(t, k, sentinel()) is-not Sentinel
  
defmethod get<?K,?V> (t:Table<?K,?V>, k:K) -> V :
  match(get?(t, k, sentinel())) :
    (v:Sentinel) : default(t, k)
    (v:V) : v

defmethod update<?K,?V> (t:Table<?K,?V>, f:V -> V, k:K) -> V :
  val v* = f(t[k])
  t[k] = v*
  v*

defmethod set?<?K,?V> (t:Table<?K,?V>, k:K, f:() -> V) -> V :
  match(get?(t, k, sentinel())) :
    (v:Sentinel) :
      val v* = f()
      t[k] = v*
      v*
    (v:V) :
      v

defmethod keys<?K> (t:Table<?K,?>) :
  seq(key, t)

defmethod values<?V> (t:Table<?,?V>) :
  seq(value, t)

public defn get?<?K,?V> (t:Table<?K,?V>, k:K) :
  get?(t, k, false)

public defn empty? (t:Table) :
  length(t) == 0

defmethod map!<?K,?V> (f:KeyValue<K,V> -> V, t:Table<?K,?V>) :
  for entry in t do :
    t[key(entry)] = f(entry)

public defn set-all<?K,?V> (t:Table<?K,?V>, ks:Seqable<K>, vs:Seqable<V>) :
  for (k in ks, v in vs) do :
    t[k] = v

;============================================================
;====================== HashTables ==========================
;============================================================

public deftype HashTable<K,V> <: Table<K,V>

public defn HashTable<K,V> (cap0:Int
                            key-hash: K -> Int
                            key-equal?: (K,K) -> True|False
                            default: K -> V,
                            create-on-default:True|False) :
  ;=====================
  ;==== Table State ====
  ;=====================
  var cap
  var limit
  var mask
  var slots
  var sizes
  var size

  defn init (c:Int) :
    cap = c
    limit = c * 5
    mask = cap - 1
    slots = Array<Sentinel|TableItem<K,V>|Array<TableItem<K,V>>>(cap, sentinel())
    sizes = Array<Int>(cap, 0)
    size = 0

  defn clear () :
    size = 0
    set-all(slots, 0 to false, sentinel())

  init(next-pow2(max(8, cap0)))

  ;===================
  ;==== Utilities ====
  ;===================
  defn loc (h:Int) :
    h & mask

  ;Matching predicate for TableItem
  defn match? (a:TableItem<K,V>, h:Int, k:K) :
    hash(a) == h and
    key-equal?(key(a), k)
  defn match? (a:TableItem<K,V>, b:TableItem<K,V>) :
    match?(a, hash(b), key(b))

  ;Find number of items whose hash is less than h
  defn num-before (xs:Array<TableItem<K,V>>, n:Int, h:Int) :
    bsearch({hash(_) < _}, xs, n, h)

  ;Look for item with given hash and key starting from i
  defn* index-of-item (xs:Array<TableItem<K,V>>, i:Int, n:Int, h:Int, k:K) :
    if i < n :
      val x = xs[i]
      if hash(x) == h :
        if key-equal?(key(x), k) : i
        else : index-of-item(xs, i + 1, n, h, k)

  ;Shift items in xs from i to n right by one element
  defn* shift-right (xs:Array<TableItem<K,V>>, i:Int, n:Int) :
    for j in n to i by -1 do :
      xs[j] = xs[j - 1]

  ;Shift items in xs from (i + 1) to n left by one element
  defn* shift-left (xs:Array<TableItem<K,V>>, i:Int, n:Int) :
    for j in i to (n - 1) do :
      xs[j] = xs[j + 1]    

  ;Copy to new array with hole in position i
  defn* copy-with-hole (xs:Array<TableItem<K,V>>, i:Int, n:Int) :
    val xs* = Array<TableItem<K,V>>(length(xs) * 2)
    xs*[0 to i] = xs[0 to i]
    xs*[(i + 1) to (n + 1)] = xs[i to n]
    xs*

  ;==========================
  ;==== Entry Operations ====
  ;==========================
  defn increment-size () :
    size = size + 1
    increase-capacity() when size >= limit
    
  defn decrement-size () :
    size = size - 1

  defn increase-capacity () :
    val items = sequence({_})
    init(cap * 2)
    do(put, items)

  defn create-bucket (slot:Int, x0:TableItem<K,V>, x1:TableItem<K,V>) :
    val bucket = Array<TableItem<K,V>>(4)
    slots[slot] = bucket
    sizes[slot] = 2
    ;Populate bucket
    if hash(x0) < hash(x1) :
      ;Add in front
      bucket[0] = x0
      bucket[1] = x1
    else :
      ;Add in back
      bucket[0] = x1
      bucket[1] = x0

  defn add-to-bucket (slot:Int, bucket:Array<TableItem<K,V>>, i:Int, n:Int, x:TableItem<K,V>) :
    ;Case 1 of 2: Bucket has space.
    if n + 1 < length(bucket) :
      shift-right(bucket, i, n)
      bucket[i] = x
    ;Case 2 of 2: Bucket is full.
    else :
      val bucket* = copy-with-hole(bucket, i, n)
      slots[slot] = bucket*
      bucket*[i] = x
    sizes[slot] = n + 1

  ;=======================
  ;==== Put Operation ====
  ;=======================
  defn put (x:TableItem<K,V>) :
    val slot = loc(hash(x))
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        ;New Entry
        slots[slot] = x
        increment-size()
      ;Case 2 of 3: Single item bucket
      (s:TableItem<K,V>) :
        ;Case 1 of 2: Item matches
        if match?(s,x) :
          ;Replace Entry
          slots[slot] = x
        ;Case 2 of 2: Add Item
        else :
          create-bucket(slot, s, x)
          increment-size()
      ;Case 3 of 3: Multiple item bucket
      (s:Array<TableItem<K,V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, hash(x))
        match(index-of-item(s, i, n, hash(x), key(x))) :
          ;Case 1 of 2: Item exists in bucket
          (idx:Int) :
            s[idx] = x
          ;Case 2 of 2: Add new item to bucket
          (idx:False) :
            add-to-bucket(slot, s, i, n, x)
            increment-size()

  ;===========================
  ;==== Lookup? Operation ====
  ;===========================
  defn lookup?<?D> (k:K, default:?D) :
    val h = key-hash(k)
    val slot = loc(h)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        default
      ;Case 2 of 3: Single item bucket
      (s:TableItem<K,V>) :
        ;Case 1 of 2: Item matches
        if match?(s,h,k) : value(s)
        else : default
      ;Case 3 of 3: Multiple item bucket
      (s:Array<TableItem<K,V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, h)
        match(index-of-item(s, i, n, h, k)) :
          (idx:Int) : value(s[idx])
          (idx:False) : default

  ;==========================
  ;==== Lookup Operation ====
  ;==========================
  defn lookup (k:K) :
    val h = key-hash(k)
    defn item (v:V) : TableItem<K,V>(h,k,v)
    val slot = loc(h)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        val v = default(k)
        if create-on-default :
          slots[slot] = item(v)
          increment-size()
        v
      ;Case 2 of 3: Single item bucket
      (s:TableItem<K,V>) :
        ;Case 1 of 2: Item matches
        if match?(s,h,k) :
          value(s)
        else :
          val v = default(k)
          if create-on-default :
            create-bucket(slot, s, item(v))
            increment-size()
          v          
      ;Case 3 of 3: Multiple item bucket
      (s:Array<TableItem<K,V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, h)
        match(index-of-item(s, i, n, h, k)) :
          (idx:Int) :
            value(s[idx])
          (idx:False) :
            val v = default(k)
            if create-on-default :
              add-to-bucket(slot, s, i, n, item(v))
              increment-size()
            v

  ;==========================
  ;==== Update Operation ====
  ;==========================
  defn update (f:V -> V, k:K) :
    val h = key-hash(k)
    defn item (v:V) : TableItem<K,V>(h,k,v)
    val slot = loc(h)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        val v = f(default(k))
        slots[slot] = item(v)
        increment-size()
        v
      ;Case 2 of 3: Single item bucket
      (s:TableItem<K,V>) :
        ;Case 1 of 2: Item matches
        if match?(s,h,k) :
          val v = f(value(s))
          slots[slot] = item(v)
          v
        else :
          val v = f(default(k))
          create-bucket(slot, s, item(v))
          increment-size()
          v
      ;Case 3 of 3: Multiple item bucket
      (s:Array<TableItem<K,V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, h)
        match(index-of-item(s, i, n, h, k)) :
          (idx:Int) :
            val v = f(value(s[idx]))
            s[idx] = item(v)
            v
          (idx:False) :
            val v = f(default(k))
            add-to-bucket(slot, s, i, n, item(v))
            increment-size()
            v

  ;========================
  ;==== Key? Operation ====
  ;========================
  defn key? (k:K) :
    val h = key-hash(k)
    val slot = loc(h)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) : false
      ;Case 2 of 3: Single item bucket
      (s:TableItem<K,V>) : match?(s,h,k)
      ;Case 3 of 3: Multiple item bucket
      (s:Array<TableItem<K,V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, h)
        index-of-item(s, i, n, h, k) is Int

  ;==========================
  ;==== Remove Operation ====
  ;==========================
  defn remove (k:K) :
    val h = key-hash(k)
    val slot = loc(h)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        false
      ;Case 2 of 3: Single item bucket
      (s:TableItem<K,V>) :
        if match?(s,h,k) :
          slots[slot] = sentinel()
          decrement-size()
          true
      ;Case 3 of 3: Multiple item bucket
      (s:Array<TableItem<K,V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, h)
        match(index-of-item(s, i, n, h, k)) :
          (idx:False) : false
          (idx:Int) :
            shift-left(s, idx, n)
            sizes[slot] = n - 1
            decrement-size()
            true

  ;========================
  ;==== Map! Operation ====
  ;========================
  defn map! (f:KeyValue<K,V> -> V) :
    for (slot in slots, idx in 0 to false) do :
      match(slot) :
        ;Case 1 of 3: Unoccupied bucket
        (s:Sentinel) :
          false
        ;Case 2 of 3: Single item bucket
        (s:TableItem<K,V>) :
          val v = f(key(s) => value(s))
          slots[idx] = TableItem<K,V>(hash(s), key(s), v)
        ;Case 3 of 3: Multiple item bucket
        (s:Array<TableItem<K,V>>) :
          val n = sizes[idx]
          for i in 0 to n do :
            val x = s[i]
            val v = f(key(x) => value(x))
            s[i] = TableItem<K,V>(hash(x), key(x), v)

  ;=============================
  ;==== Iteration Operation ====
  ;=============================
  defn sequence<?T> (f:TableItem<K,V> -> ?T) :
    val sizes = sizes
    for (s in slots, idx in 0 to false) seq-cat :
      match(s) :
        (s:Sentinel) : List()
        (s:TableItem<K,V>) : List(f(s))
        (s:Array<TableItem<K,V>>) : seq(f, take-n(sizes[idx], s))

  ;======================
  ;==== Table Object ====
  ;======================
  new HashTable<K,V> :
    defmethod set (this, k:K, v:V) :
      put(TableItem<K,V>(key-hash(k), k, v))
    defmethod get?<?D> (this, k:K, d:?D) :
      lookup?(k, d)
    defmethod get (this, k:K) :
      lookup(k)
    defmethod remove (this, k:K) :
      remove(k)
    defmethod clear (this) :
      clear()
    defmethod key? (this, k:K) :
      key?(k)
    defmethod update (this, f:V -> V, k:K) :
      update(f, k)
    defmethod map! (f:KeyValue<K,V> -> V, this) :
      map!(f)
    defmethod to-seq (this) :
      defn make-entry (x:TableItem<K,V>) : key(x) => value(x)
      sequence(make-entry)
    defmethod keys (this) :
      sequence(key)
    defmethod values (this) :
      sequence(value)
    defmethod length (this) :
      size
    defmethod default (this, k:K) :
      val v = default(k)
      if create-on-default : this[k] = v
      v

;==================================
;==== Convenience Constructors ====
;==================================
defn no-such-key (k) : fatal("Key %_ does not exist in table." % [k])

public defn HashTable<K,V> (initial-cap:Int, hash: K -> Int, equal?: (K,K) -> True|False) :
  HashTable<K,V>(initial-cap, hash, equal?, no-such-key, false)

public defn HashTable<K,V> (hash: K -> Int, equal?: (K,K) -> True|False) :
  HashTable<K,V>(8, hash, equal?, no-such-key, false)

public defn HashTable<K,V> () -> HashTable<K,V> :
  HashTable<K&Hashable&Equalable,V>(8, hash, equal?, no-such-key, false)

public defn HashTable<K,V> (default:V) -> HashTable<K,V> :
  HashTable<K&Hashable&Equalable,V>(8, hash, equal?, {default}, false)

public defn HashTable<K,V> (hash: K -> Int,
                            equal?: (K,K) -> True|False,
                            default:V) ->
                            HashTable<K,V> :
  HashTable<K,V>(8, hash, equal?, {default}, false)

public defn HashTable-init<K,V> (init: K -> V) -> HashTable<K,V> :
  HashTable<K&Hashable&Equalable,V>(8, hash, equal?, init, true)

public defn HashTable-init<K,V> (hash: K -> Int,
                                 equal?: (K,K) -> True|False,
                                 init: K -> V) ->
                                 HashTable<K,V> :
  HashTable<K,V>(8, hash, equal?, init, true)

public defn to-hashtable<K,V> (es:Seqable<KeyValue<K,V>>) -> HashTable<K,V> :
  val t = HashTable<K,V>()
  for e in es do :
    t[key(e)] = value(e)
  t

public defn to-hashtable<K,V> (ks:Seqable<K>, vs:Seqable<V>) -> HashTable<K,V> :
  val t = HashTable<K,V>()
  set-all(t, ks, vs)
  t

;============================================================
;===================== Int Tables ===========================
;============================================================

public deftype IntTable<V> <: Table<Int,V>

public defn IntTable<V> (cap0:Int
                         default: Int -> V,
                         create-on-default:True|False) :
  ;=====================
  ;==== Table State ====
  ;=====================
  var cap
  var limit
  var mask
  var slots
  var sizes
  var size

  defn init (c:Int) :
    cap = c
    limit = c * 5
    mask = cap - 1
    slots = Array<Sentinel|IntItem<V>|Array<IntItem<V>>>(cap, sentinel())
    sizes = Array<Int>(cap, 0)
    size = 0

  defn clear () :
    size = 0
    set-all(slots, 0 to false, sentinel())

  init(next-pow2(max(8, cap0)))

  ;===================
  ;==== Utilities ====
  ;===================
  defn loc (h:Int) :
    h & mask

  ;Matching predicate for IntItem
  defn match? (a:IntItem<V>, k:Int) :
    key(a) == k
  defn match? (a:IntItem<V>, b:IntItem<V>) :
    match?(a, key(b))

  ;Find number of items whose hash is less than h
  defn num-before (xs:Array<IntItem<V>>, n:Int, k:Int) :
    bsearch({key(_) < _}, xs, n, k)

  ;Look for item with given hash and key starting from i
  defn* index-of-item (xs:Array<IntItem<V>>, i:Int, n:Int, k:Int) :
    if i < n :
      val x = xs[i]
      if key(x) == k : i

  ;Shift items in xs from i to n right by one element
  defn* shift-right (xs:Array<IntItem<V>>, i:Int, n:Int) :
    for j in n to i by -1 do :
      xs[j] = xs[j - 1]

  ;Shift items in xs from (i + 1) to n left by one element
  defn* shift-left (xs:Array<IntItem<V>>, i:Int, n:Int) :
    for j in i to (n - 1) do :
      xs[j] = xs[j + 1]    

  ;Copy to new array with hole in position i
  defn* copy-with-hole (xs:Array<IntItem<V>>, i:Int, n:Int) :
    val xs* = Array<IntItem<V>>(length(xs) * 2)
    xs*[0 to i] = xs[0 to i]
    xs*[(i + 1) to (n + 1)] = xs[i to n]
    xs*

  ;==========================
  ;==== Entry Operations ====
  ;==========================
  defn increment-size () :
    size = size + 1
    increase-capacity() when size >= limit
    
  defn decrement-size () :
    size = size - 1

  defn increase-capacity () :
    val items = sequence({_})
    init(cap * 2)
    do(put, items)

  defn create-bucket (slot:Int, x0:IntItem<V>, x1:IntItem<V>) :
    val bucket = Array<IntItem<V>>(4)
    slots[slot] = bucket
    sizes[slot] = 2
    ;Populate bucket
    if key(x0) < key(x1) :
      ;Add in front
      bucket[0] = x0
      bucket[1] = x1
    else :
      ;Add in back
      bucket[0] = x1
      bucket[1] = x0

  defn add-to-bucket (slot:Int, bucket:Array<IntItem<V>>, i:Int, n:Int, x:IntItem<V>) :
    ;Case 1 of 2: Bucket has space.
    if n + 1 < length(bucket) :
      shift-right(bucket, i, n)
      bucket[i] = x
    ;Case 2 of 2: Bucket is full.
    else :
      val bucket* = copy-with-hole(bucket, i, n)
      slots[slot] = bucket*
      bucket*[i] = x
    sizes[slot] = n + 1

  ;=======================
  ;==== Put Operation ====
  ;=======================
  defn put (x:IntItem<V>) :
    val slot = loc(key(x))
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        ;New Entry
        slots[slot] = x
        increment-size()
      ;Case 2 of 3: Single item bucket
      (s:IntItem<V>) :
        ;Case 1 of 2: Item matches
        if match?(s,x) :
          ;Replace Entry
          slots[slot] = x
        ;Case 2 of 2: Add Item
        else :
          create-bucket(slot, s, x)
          increment-size()
      ;Case 3 of 3: Multiple item bucket
      (s:Array<IntItem<V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, key(x))
        match(index-of-item(s, i, n, key(x))) :
          ;Case 1 of 2: Item exists in bucket
          (idx:Int) :
            s[idx] = x
          ;Case 2 of 2: Add new item to bucket
          (idx:False) :
            add-to-bucket(slot, s, i, n, x)
            increment-size()

  ;===========================
  ;==== Lookup? Operation ====
  ;===========================
  defn lookup?<?D> (k:Int, default:?D) :
    val slot = loc(k)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        default
      ;Case 2 of 3: Single item bucket
      (s:IntItem<V>) :
        ;Case 1 of 2: Item matches
        if match?(s,k) : value(s)
        else : default
      ;Case 3 of 3: Multiple item bucket
      (s:Array<IntItem<V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, k)
        match(index-of-item(s, i, n, k)) :
          (idx:Int) : value(s[idx])
          (idx:False) : default

  ;==========================
  ;==== Lookup Operation ====
  ;==========================
  defn lookup (k:Int) :
    defn item (v:V) : IntItem<V>(k,v)
    val slot = loc(k)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        val v = default(k)
        if create-on-default :
          slots[slot] = item(v)
          increment-size()
        v
      ;Case 2 of 3: Single item bucket
      (s:IntItem<V>) :
        ;Case 1 of 2: Item matches
        if match?(s,k) :
          value(s)
        else :
          val v = default(k)
          if create-on-default :
            create-bucket(slot, s, item(v))
            increment-size()
          v          
      ;Case 3 of 3: Multiple item bucket
      (s:Array<IntItem<V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, k)
        match(index-of-item(s, i, n, k)) :
          (idx:Int) :
            value(s[idx])
          (idx:False) :
            val v = default(k)
            if create-on-default :
              add-to-bucket(slot, s, i, n, item(v))
              increment-size()
            v

  ;==========================
  ;==== Update Operation ====
  ;==========================
  defn update (f:V -> V, k:Int) :
    defn item (v:V) : IntItem<V>(k,v)
    val slot = loc(k)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        val v = f(default(k))
        slots[slot] = item(v)
        increment-size()
        v
      ;Case 2 of 3: Single item bucket
      (s:IntItem<V>) :
        ;Case 1 of 2: Item matches
        if match?(s,k) :
          val v = f(value(s))
          slots[slot] = item(v)
          v
        else :
          val v = f(default(k))
          create-bucket(slot, s, item(v))
          increment-size()
          v
      ;Case 3 of 3: Multiple item bucket
      (s:Array<IntItem<V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, k)
        match(index-of-item(s, i, n, k)) :
          (idx:Int) :
            val v = f(value(s[idx]))
            s[idx] = item(v)
            v
          (idx:False) :
            val v = f(default(k))
            add-to-bucket(slot, s, i, n, item(v))
            increment-size()
            v

  ;========================
  ;==== Key? Operation ====
  ;========================
  defn key? (k:Int) :
    val slot = loc(k)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) : false
      ;Case 2 of 3: Single item bucket
      (s:IntItem<V>) : match?(s,k)
      ;Case 3 of 3: Multiple item bucket
      (s:Array<IntItem<V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, k)
        index-of-item(s, i, n, k) is Int

  ;==========================
  ;==== Remove Operation ====
  ;==========================
  defn remove (k:Int) :
    val slot = loc(k)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        false
      ;Case 2 of 3: Single item bucket
      (s:IntItem<V>) :
        if match?(s,k) :
          slots[slot] = sentinel()
          decrement-size()
          true
      ;Case 3 of 3: Multiple item bucket
      (s:Array<IntItem<V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, k)
        match(index-of-item(s, i, n, k)) :
          (idx:False) : false
          (idx:Int) :
            shift-left(s, idx, n)
            sizes[slot] = n - 1
            decrement-size()
            true

  ;========================
  ;==== Map! Operation ====
  ;========================
  defn map! (f:KeyValue<Int,V> -> V) :
    for (slot in slots, idx in 0 to false) do :
      match(slot) :
        ;Case 1 of 3: Unoccupied bucket
        (s:Sentinel) :
          false
        ;Case 2 of 3: Single item bucket
        (s:IntItem<V>) :
          val v = f(key(s) => value(s))
          slots[idx] = IntItem<V>(key(s), v)
        ;Case 3 of 3: Multiple item bucket
        (s:Array<IntItem<V>>) :
          val n = sizes[idx]
          for i in 0 to n do :
            val x = s[i]
            val v = f(key(x) => value(x))
            s[i] = IntItem<V>(key(x), v)

  ;=============================
  ;==== Iteration Operation ====
  ;=============================
  defn sequence<?T> (f:IntItem<V> -> ?T) :
    val sizes = sizes
    for (s in slots, idx in 0 to false) seq-cat :
      match(s) :
        (s:Sentinel) : List()
        (s:IntItem<V>) : List(f(s))
        (s:Array<IntItem<V>>) : seq(f, take-n(sizes[idx], s))

  ;======================
  ;==== Table Object ====
  ;======================
  new IntTable<V> :
    defmethod set (this, k:Int, v:V) :
      put(IntItem<V>(k, v))
    defmethod get?<?D> (this, k:Int, d:?D) :
      lookup?(k, d)
    defmethod get (this, k:Int) :
      lookup(k)
    defmethod remove (this, k:Int) :
      remove(k)
    defmethod clear (this) :
      clear()
    defmethod key? (this, k:Int) :
      key?(k)
    defmethod update (this, f:V -> V, k:Int) :
      update(f, k)
    defmethod map! (f:KeyValue<Int,V> -> V, this) :
      map!(f)
    defmethod to-seq (this) :
      defn make-entry (x:IntItem<V>) : key(x) => value(x)
      sequence(make-entry)
    defmethod keys (this) :
      sequence(key)
    defmethod values (this) :
      sequence(value)
    defmethod length (this) :
      size
    defmethod default (this, k:Int) :
      val v = default(k)
      if create-on-default : this[k] = v
      v

;==================================
;==== Convenience Constructors ====
;==================================
public defn IntTable<V> () :
  IntTable<V>(8, no-such-key, false)

public defn IntTable<V> (default:V) :
  IntTable<V>(8, {default}, false)

public defn IntTable-init<V> (init: Int -> V) :
  IntTable<V>(8, init, true)

public defn to-inttable<V> (es:Seqable<KeyValue<Int,V>>) -> IntTable<V> :
  val t = IntTable<V>()
  for e in es do :
    t[key(e)] = value(e)
  t

public defn to-inttable<V> (ks:Seqable<Int>, vs:Seqable<V>) -> IntTable<V> :
  val t = IntTable<V>()
  set-all(t, ks, vs)
  t

;============================================================
;======================== Sets ==============================
;============================================================

;==============================
;==== Mandatory Operations ====
;==============================

public deftype Set<K> <: Collection<K> & Lengthable
public defmulti add<?K> (s:Set<?K>, k:K) -> True|False
public defmulti remove<?K> (s:Set<?K>, k:K) -> True|False
public defmulti get<?K> (s:Set<?K>, k:K) -> True|False
public defmulti clear (s:Set) -> False

;==================================
;==== Abstract Implementations ====
;==================================
public defn empty? (s:Set) :
  length(s) == 0

public defmulti add-all<?K> (s:Set<?K>, ks:Seqable<K>) -> False
defmethod add-all<?K> (s:Set<?K>, ks:Seqable<K>) :
  for k in ks do : add(s, k)

;============================================================
;====================== HashSets ============================
;============================================================

public deftype HashSet<K> <: Set<K>

public defn HashSet<K> (cap0:Int
                        key-hash: K -> Int
                        key-equal?: (K,K) -> True|False) :
  ;=====================
  ;==== Table State ====
  ;=====================
  var cap
  var limit
  var mask
  var slots
  var sizes
  var size

  defn init (c:Int) :
    cap = c
    limit = c * 5
    mask = cap - 1
    slots = Array<Sentinel|SetItem<K>|Array<SetItem<K>>>(cap, sentinel())
    sizes = Array<Int>(cap, 0)
    size = 0

  defn clear () :
    size = 0
    set-all(slots, 0 to false, sentinel())

  init(next-pow2(max(8, cap0)))

  ;===================
  ;==== Utilities ====
  ;===================
  defn set-item (k:K) :
    SetItem<K>(key-hash(k), k)
    
  defn loc (h:Int) :
    h & mask

  ;Matching predicate for TableItem
  defn match? (a:SetItem<K>, b:SetItem<K>) :
    hash(a) == hash(b) and
    key-equal?(key(a), key(b))

  ;Find number of items whose hash is less than h
  defn num-before (xs:Array<SetItem<K>>, n:Int, x:SetItem<K>) :
    bsearch({hash(_) < hash(_)}, xs, n, x)

  ;Look for item with given hash and key starting from i
  defn* index-of-item (xs:Array<SetItem<K>>, i:Int, n:Int, y:SetItem<K>) :
    if i < n :
      val x = xs[i]
      if hash(x) == hash(y) :
        if key-equal?(key(x), key(y)) : i
        else : index-of-item(xs, i + 1, n, y)

  ;Shift items in xs from i to n right by one element
  defn* shift-right (xs:Array<SetItem<K>>, i:Int, n:Int) :
    for j in n to i by -1 do :
      xs[j] = xs[j - 1]

  ;Shift items in xs from (i + 1) to n left by one element
  defn* shift-left (xs:Array<SetItem<K>>, i:Int, n:Int) :
    for j in i to (n - 1) do :
      xs[j] = xs[j + 1]    

  ;Copy to new array with hole in position i
  defn* copy-with-hole (xs:Array<SetItem<K>>, i:Int, n:Int) :
    val xs* = Array<SetItem<K>>(length(xs) * 2)
    xs*[0 to i] = xs[0 to i]
    xs*[(i + 1) to (n + 1)] = xs[i to n]
    xs*

  ;==========================
  ;==== Entry Operations ====
  ;==========================
  defn increment-size () :
    size = size + 1
    increase-capacity() when size >= limit
    
  defn decrement-size () :
    size = size - 1

  defn increase-capacity () :
    val items = sequence({_})
    init(cap * 2)
    do(put, items)

  defn create-bucket (slot:Int, x0:SetItem<K>, x1:SetItem<K>) :
    val bucket = Array<SetItem<K>>(4)
    slots[slot] = bucket
    sizes[slot] = 2
    ;Populate bucket
    if hash(x0) < hash(x1) :
      ;Add in front
      bucket[0] = x0
      bucket[1] = x1
    else :
      ;Add in back
      bucket[0] = x1
      bucket[1] = x0

  defn add-to-bucket (slot:Int, bucket:Array<SetItem<K>>, i:Int, n:Int, x:SetItem<K>) :
    ;Case 1 of 2: Bucket has space.
    if n + 1 < length(bucket) :
      shift-right(bucket, i, n)
      bucket[i] = x
    ;Case 2 of 2: Bucket is full.
    else :
      val bucket* = copy-with-hole(bucket, i, n)
      slots[slot] = bucket*
      bucket*[i] = x
    sizes[slot] = n + 1

  ;=======================
  ;==== Put Operation ====
  ;=======================
  ;Returns true if new item is added
  defn put (x:SetItem<K>) :
    val slot = loc(hash(x))
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        ;New Entry
        slots[slot] = x
        increment-size()
        true
      ;Case 2 of 3: Single item bucket
      (s:SetItem<K>) :
        ;Case 1 of 2: Item matches
        if match?(s,x) :
          false
        ;Case 2 of 2: Add Item
        else :
          create-bucket(slot, s, x)
          increment-size()
          true
      ;Case 3 of 3: Multiple item bucket
      (s:Array<SetItem<K>>) :
        val n = sizes[slot]
        val i = num-before(s, n, x)
        match(index-of-item(s, i, n, x)) :
          ;Case 1 of 2: Item exists in bucket
          (idx:Int) :
            false
          ;Case 2 of 2: Add new item to bucket
          (idx:False) :
            add-to-bucket(slot, s, i, n, x)
            increment-size()
            true

  ;========================
  ;==== Key? Operation ====
  ;========================
  defn exists? (x:SetItem<K>) :
    val slot = loc(hash(x))
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) : false
      ;Case 2 of 3: Single item bucket
      (s:SetItem<K>) : match?(s,x)
      ;Case 3 of 3: Multiple item bucket
      (s:Array<SetItem<K>>) :
        val n = sizes[slot]
        val i = num-before(s, n, x)
        index-of-item(s, i, n, x) is Int

  ;==========================
  ;==== Remove Operation ====
  ;==========================
  ;Returns true if item was removed
  defn remove (x:SetItem<K>) :
    val slot = loc(hash(x))
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        false
      ;Case 2 of 3: Single item bucket
      (s:SetItem<K>) :
        if match?(s,x) :
          slots[slot] = sentinel()
          decrement-size()
          true
      ;Case 3 of 3: Multiple item bucket
      (s:Array<SetItem<K>>) :
        val n = sizes[slot]
        val i = num-before(s, n, x)
        match(index-of-item(s, i, n, x)) :
          (idx:False) : false
          (idx:Int) :
            shift-left(s, idx, n)
            sizes[slot] = n - 1
            decrement-size()
            true

  ;=============================
  ;==== Iteration Operation ====
  ;=============================
  defn sequence<?T> (f:SetItem<K> -> ?T) :
    val sizes = sizes
    for (s in slots, idx in 0 to false) seq-cat :
      match(s) :
        (s:Sentinel) : List()
        (s:SetItem<K>) : List(f(s))
        (s:Array<SetItem<K>>) : seq(f, take-n(sizes[idx], s))

  ;======================
  ;==== Table Object ====
  ;======================
  new HashSet<K> :
    defmethod add (this, k:K) :
      put(set-item(k))
    defmethod get (this, k:K) :
      exists?(set-item(k))
    defmethod remove (this, k:K) :
      remove(set-item(k))     
    defmethod clear (this) :
      clear()
    defmethod to-seq (this) :
      sequence(key)
    defmethod length (this) :
      size

;==================================
;==== Convenience Constructors ====
;==================================
public defn HashSet<K> (hash: K -> Int, equal?: (K,K) -> True|False) :
  HashSet<K>(8, hash, equal?)

public defn HashSet<K> () -> HashSet<K> :
  HashSet<K&Hashable&Equalable>(8, hash, equal?)

public defn to-hashset<K> (xs:Seqable<K>) -> HashSet<K> :
  val s = HashSet<K>()
  do(add{s, _}, xs)
  s

;============================================================
;====================== IntSets =============================
;============================================================

public deftype IntSet <: Set<Int>

public defn IntSet (cap0:Int) :
  ;=====================
  ;==== Table State ====
  ;=====================
  var cap
  var limit
  var mask
  var slots
  var sizes
  var size

  defn init (c:Int) :
    cap = c
    limit = c * 5
    mask = cap - 1
    slots = Array<Sentinel|Int|Array<Int>>(cap, sentinel())
    sizes = Array<Int>(cap, 0)
    size = 0

  defn clear () :
    size = 0
    set-all(slots, 0 to false, sentinel())

  init(next-pow2(max(8, cap0)))

  ;===================
  ;==== Utilities ====
  ;===================    
  defn loc (h:Int) :
    h & mask

  ;Find number of items whose hash is less than h
  defn num-before (xs:Array<Int>, n:Int, x:Int) :
    bsearch(less?, xs, n, x)

  ;Look for item with given hash and key starting from i
  defn* index-of-item (xs:Array<Int>, i:Int, n:Int, y:Int) :
    if i < n :
      val x = xs[i]
      if x == y : i

  ;Shift items in xs from i to n right by one element
  defn* shift-right (xs:Array<Int>, i:Int, n:Int) :
    for j in n to i by -1 do :
      xs[j] = xs[j - 1]

  ;Shift items in xs from (i + 1) to n left by one element
  defn* shift-left (xs:Array<Int>, i:Int, n:Int) :
    for j in i to (n - 1) do :
      xs[j] = xs[j + 1]    

  ;Copy to new array with hole in position i
  defn* copy-with-hole (xs:Array<Int>, i:Int, n:Int) :
    val xs* = Array<Int>(length(xs) * 2)
    xs*[0 to i] = xs[0 to i]
    xs*[(i + 1) to (n + 1)] = xs[i to n]
    xs*

  ;==========================
  ;==== Entry Operations ====
  ;==========================
  defn increment-size () :
    size = size + 1
    increase-capacity() when size >= limit
    
  defn decrement-size () :
    size = size - 1

  defn increase-capacity () :
    val items = sequence()
    init(cap * 2)
    do(put, items)

  defn create-bucket (slot:Int, x0:Int, x1:Int) :
    val bucket = Array<Int>(4)
    slots[slot] = bucket
    sizes[slot] = 2
    ;Populate bucket
    if x0 < x1 :
      ;Add in front
      bucket[0] = x0
      bucket[1] = x1
    else :
      ;Add in back
      bucket[0] = x1
      bucket[1] = x0

  defn add-to-bucket (slot:Int, bucket:Array<Int>, i:Int, n:Int, x:Int) :
    ;Case 1 of 2: Bucket has space.
    if n + 1 < length(bucket) :
      shift-right(bucket, i, n)
      bucket[i] = x
    ;Case 2 of 2: Bucket is full.
    else :
      val bucket* = copy-with-hole(bucket, i, n)
      slots[slot] = bucket*
      bucket*[i] = x
    sizes[slot] = n + 1

  ;=======================
  ;==== Put Operation ====
  ;=======================
  ;Returns true if new item is added
  defn put (x:Int) :
    val slot = loc(x)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        ;New Entry
        slots[slot] = x
        increment-size()
        true
      ;Case 2 of 3: Single item bucket
      (s:Int) :
        ;Case 1 of 2: Item matches
        if s == x :
          false
        ;Case 2 of 2: Add Item
        else :
          create-bucket(slot, s, x)
          increment-size()
          true
      ;Case 3 of 3: Multiple item bucket
      (s:Array<Int>) :
        val n = sizes[slot]
        val i = num-before(s, n, x)
        match(index-of-item(s, i, n, x)) :
          ;Case 1 of 2: Item exists in bucket
          (idx:Int) :
            false
          ;Case 2 of 2: Add new item to bucket
          (idx:False) :
            add-to-bucket(slot, s, i, n, x)
            increment-size()
            true

  ;========================
  ;==== Key? Operation ====
  ;========================
  defn exists? (x:Int) :
    val slot = loc(x)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) : false
      ;Case 2 of 3: Single item bucket
      (s:Int) : s == x
      ;Case 3 of 3: Multiple item bucket
      (s:Array<Int>) :
        val n = sizes[slot]
        val i = num-before(s, n, x)
        index-of-item(s, i, n, x) is Int

  ;==========================
  ;==== Remove Operation ====
  ;==========================
  ;Returns true if item was removed
  defn remove (x:Int) :
    val slot = loc(hash(x))
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        false
      ;Case 2 of 3: Single item bucket
      (s:Int) :
        if s == x :
          slots[slot] = sentinel()
          decrement-size()
          true
      ;Case 3 of 3: Multiple item bucket
      (s:Array<Int>) :
        val n = sizes[slot]
        val i = num-before(s, n, x)
        match(index-of-item(s, i, n, x)) :
          (idx:False) : false
          (idx:Int) :
            shift-left(s, idx, n)
            sizes[slot] = n - 1
            decrement-size()
            true

  ;=============================
  ;==== Iteration Operation ====
  ;=============================
  defn sequence () :
    val sizes = sizes
    for (s in slots, idx in 0 to false) seq-cat :
      match(s) :
        (s:Sentinel) : List()
        (s:Int) : List(s)
        (s:Array<Int>) : take-n(sizes[idx], s)

  ;======================
  ;==== Table Object ====
  ;======================
  new IntSet :
    defmethod add (this, k:Int) :
      put(k)
    defmethod get (this, k:Int) :
      exists?(k)
    defmethod remove (this, k:Int) :
      remove(k)     
    defmethod clear (this) :
      clear()
    defmethod to-seq (this) :
      sequence()
    defmethod length (this) :
      size

;==================================
;==== Convenience Constructors ====
;==================================
public defn IntSet () :
  IntSet(8)

public defn to-intset (xs:Seqable<Int>) -> IntSet :
  val s = IntSet()
  do(add{s, _}, xs)
  s
