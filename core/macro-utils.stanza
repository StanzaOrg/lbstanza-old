;See License.txt for details about licensing.

defpackage core/macro-utils :
   import core
   import verse

;================= PUBLIC INTERFACE ========================
public defn splice (item:Streamable|Token<Streamable>) :
   SpliceTemplate(to-list(unwrap-token(item)))

public defn nested (items:Streamable<Streamable<KeyValue<Symbol,?>>>) :
   NestedTemplate(to-list(items))

public defn choice (n:Int) :
   ChoiceTemplate(n)
public defn choice (b:True|False) :
   ChoiceTemplate(0 when b else 1)

public defn collect (entries: Streamable<KeyValue<Symbol, Streamable>>) :
   ;Collect keys and values
   val keys = Vector<Symbol>()
   val values = Vector<Vector<?>>()
   for entry in entries do :
      add(keys, key(entry))
      add(values, to-vector(value(entry)))

   if empty?(keys) :
      nested(List())
   else :      
      ;Ensure that all values have same length
      val n = length(values[0])
      if not all?({length(_) == n}, values) :
         error("All entries in a collect template must have same length.")
    
      ;Make templates
      nested $ for i in 0 to n stream :
         to-list $ for (k in keys, v in values) stream :
            k => v[i]
   
;================== TEMPLATES ==============================   
defstruct SpliceTemplate :
   item:List   

defstruct NestedTemplate :
   items:List<Streamable<KeyValue<Symbol,?>>>   

defstruct ChoiceTemplate :
   selection: Int

;================ FILL INTERPRETER =========================
public defn fill-template (template, replacements: Streamable<KeyValue<Symbol,?>>) -> ? :
   ;=== Choice ===
   defn following-do-afns (xs:List) -> [List<List>, List] :
      if empty?(xs) :
         [List(), xs]
      else if tagged-list?(head(xs), `@do-afn) :
         val x = tail(unwrap-token(head(xs)))
         val [xs, rest] = following-do-afns(tail(xs))
         [List(x,xs), rest]
      else :
         [List(), xs]

   defn select-choice (t:ChoiceTemplate, xs:List) -> [List, List] :
      val [forms, rest*] = following-do-afns(xs)
      if selection(t) >= length(forms) :
         error("ChoiceTemplate index is out of bounds.")
      val filled = fill-template(forms[selection(t)], replacements)
      [filled, rest*]   

   ;=== Nested Template ===
   defn replace-nested (t:NestedTemplate, rest:List) -> [List, List] :
      if (not empty?(rest)) and tagged-list?(head(rest), `@do-afn) :
         val form = tail(unwrap-token(head(rest)))
         val rest* = tail(rest)
         val filled = for r in items(t) map-append :
            val r* = to-list(concat(r, replacements))
            fill-template(form, r*)
         [filled, rest*]   
      else :
         error("Nested keyword is not followed with a template.")
         
   ;=== Processing Loop ===
   val flag = gensym()
   defn get-template (x) :
      match(unwrap-token(x)) :
         (x:Symbol) :
            val e = lookup(replacements, x, flag)
            [e != flag, e]
         (x) :
            [false, false]
         
   defn loop (form) -> ? :
      match(form) :
         (t:Token) :
            map(loop, t)
         (xs:FullList) :
            val [t?, t] = get-template(head(xs))
            val rest = tail(xs)
            if t? :
               match(t) :
                  (t:SpliceTemplate) :
                     append(item(t), loop(rest))
                  (t:NestedTemplate) :
                     val [x*, rest*] = replace-nested(t, rest)
                     append(x*, loop(rest*))
                  (t:ChoiceTemplate) :
                     val [x*, rest*] = select-choice(t, rest)
                     append(x*, loop(rest*))
                  (t) :
                     List(t, loop(rest))
            else :
               List(loop(head(xs)), loop(rest))
         (x) :
            x
   loop(template)