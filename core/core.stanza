;################################################################################
;############################## C Library #######################################
;################################################################################

;================================================================================
;================================ Boot Sequence =================================
;================================================================================

defpackage clib

protected extern malloc: long -> ptr<?>
protected extern free: ptr<?> -> int
protected extern realloc: (ptr<?>, long) -> ptr<?>
protected extern memcpy: (ptr<?>, ptr<?>, long) -> ptr<?>
protected extern memset: (ptr<?>, long, long) -> ptr<?>
protected extern rmdir: (ptr<byte>) -> int
protected extern remove: (ptr<byte>) -> int
protected extern rename: (ptr<byte>, ptr<byte>) -> int
protected extern symlink: (ptr<byte>, ptr<byte>) -> int
protected extern ftell: (ptr<?>) -> long
protected extern fclose: (ptr<?>) -> int
protected extern fflush: (ptr<?>) -> int
protected extern fopen: (ptr<byte>, ptr<byte>) -> ptr<?>
protected extern fputs: (ptr<byte>, ptr<?>) -> int
protected extern fputc: (byte, ptr<?>) -> int
protected extern fgetc: (ptr<?>) -> int
protected extern ferror: (ptr<?>) -> int
protected extern fprintf: (ptr<?>, ptr<byte>, ? ...) -> int
protected extern sprintf: (ptr<byte>, ptr<byte>, ? ...) -> int
protected extern sscanf: (ptr<byte>, ptr<byte>, ptr<?> ...) -> int
protected extern printf: (ptr<byte>, ? ...) -> int
protected extern exit: int -> int
protected extern get_stdout: () -> ptr<?>
protected extern get_stderr: () -> ptr<?>
protected extern get_stdin: () -> ptr<?>
protected extern get_eof: () -> int
protected extern input_argc: int
protected extern input_argv: ptr<ptr<byte>>
protected extern input_argv_needs_free: int
protected extern strlen: ptr<byte> -> int
protected extern current_time_us: () -> long
protected extern current_time_ms: () -> long
protected extern getenv: (ptr<byte>) -> ptr<byte>
protected extern setenv: (ptr<byte>, ptr<byte>, int) -> int
protected extern unsetenv: (ptr<byte>) -> int
protected extern system: (ptr<byte>) -> int
protected extern strerror: (int) -> ptr<byte>
protected extern get_errno: () -> int
protected extern get_file_size: ptr<?> -> long
protected extern file_set_length: (ptr<?>, long) -> int
protected extern file_seek: (ptr<?>, long) -> int
protected extern file_skip: (ptr<?>, long) -> int
protected extern file_read_block: (ptr<?>, ptr<byte>, long) -> long
protected extern file_write_block: (ptr<?>, ptr<byte>, long) -> long
protected extern file_time_modified: ptr<byte> -> long
protected extern execvp: (ptr<byte>, ptr<ptr<byte>>) -> int
protected extern execv: (ptr<byte>, ptr<ptr<byte>>) -> int

;Path Resolution
#if-defined(PLATFORM-WINDOWS) :
  protected extern windows_final_path_name: ptr<byte> -> ptr<byte>
  protected extern windows_full_path_name: ptr<byte> -> ptr<byte>
  protected extern windows_logical_drives_bitmask: () -> int
#else :
  protected extern resolve_path: ptr<byte> -> ptr<byte>

;Retrieve File Type
#if-defined(PLATFORM-WINDOWS) :
  protected extern get_file_type: ptr<byte> -> int
#else :
  protected extern get_file_type: (ptr<byte>, int) -> int

;Memory mapping
protected extern stz_memory_map: (long, long) -> ptr<?>
protected extern stz_memory_unmap: (ptr<?>, long) -> int
protected extern stz_memory_resize: (ptr<?>, long, long) -> int

;Process libraries
#if-defined(PLATFORM-WINDOWS):
  protected extern launch_process: (ptr<byte>, int, int, int, ptr<byte>, ptr<?>) -> int
#else:
  protected extern launch_process: (ptr<byte>, ptr<ptr<byte>>, int, int, int, int, ptr<byte>, ptr<?>) -> int
  protected extern delete_process_pipes: (ptr<?>, ptr<?>, ptr<?>, int) -> int
  protected extern initialize_launcher_process: () -> int
protected extern retrieve_process_state: (long, ptr<?>, int) -> int


;Math libraries
protected extern exp: double -> double
protected extern log: double -> double
protected extern log10: double -> double
protected extern sqrt: double -> double
protected extern pow: (double, double) -> double
protected extern sin: double -> double
protected extern cos: double -> double
protected extern tan: double -> double
protected extern asin: double -> double
protected extern acos: double -> double
protected extern atan: double -> double
protected extern atan2: (double, double) -> double
protected extern sinh: double -> double
protected extern cosh: double -> double
protected extern tanh: double -> double
protected extern ceil: double -> double
protected extern floor: double -> double
protected extern round: double -> double

;################################################################################
;############################## Core Library ####################################
;################################################################################

;================================================================================
;=============================== Boot Sequence ==================================
;================================================================================

defpackage core :
  import collections
  import core/stack-trace

;============================================================
;===================== Internal Types =======================
;============================================================

protected lostanza deftype Fn :
   length: long
   code: ptr<?>
   free: ref<?> ...
protected lostanza deftype Box :
   item: ref<?>
protected lostanza deftype Type :
   length: long
   code: ptr<?>
   free: ref<?> ...
protected lostanza deftype StackFrame :
  var return: long
  var liveness-map: long
  var slots: long ...
protected lostanza deftype Stack :
  var size: long
  var frames: ptr<StackFrame>
  var stack-pointer: ptr<StackFrame>
  var pc: long
  var tail: ptr<Stack>

;Global list of live Stacks.
;New Stacks are added to this list when they are created.
lostanza var STACKS:ptr<Stack> = null

lostanza defn allocate-stack () -> ref<Stack> :
  val stack-size = INITIAL-STACK-SIZE
  val frames = allocate-stack-frames(stack-size)
  frames.return = -1L
  frames.liveness-map = 0L
  val stack = new Stack{stack-size, frames, null, 0, STACKS}
  STACKS = addr!([stack])
  return stack

lostanza defn iterate-references-in-stack-frames (stack:ptr<Stack>,
                                                  f:ptr<((ptr<long>, ptr<VMState>) -> ref<False>)>,
                                                  vms:ptr<VMState>) -> ref<False> :
  var frame:ptr<StackFrame> = stack.frames
  if frame == null : return false

  val current-stack = (vms.current-stack - 1) as ptr<Stack> ;Tag
  if stack == current-stack : return false

  var end-frame:ptr<StackFrame> = stack.stack-pointer
  val stackmap-table = vms.stackmap-table
  while frame <= end-frame :
    val map = stackmap-table[frame.liveness-map]
    val num-live = map.num-roots
    for (var i:int = 0, i < num-live, i = i + 1) :
      val r = map.roots[i]
      [f](addr(frame.slots[r]), vms)
    frame = frame + map.size
  ;No meaningful return value
  return false


;Scan through the global list STACK and update them.
;After this function finishes:
;1) The STACKS list shall contain only Stacks that are still live.
lostanza defn scan-stacks (vms:ptr<VMState>) -> ref<False> :
  var live-stacks:ptr<Stack> = null
  var previous-stacks:ptr<Stack> = STACKS
  ;Some stacks were marked at previous iteration
  while live-stacks != previous-stacks :
    ;Remember current state of live-staks list
    previous-stacks = live-stacks
    ;Complete previous marking before testing if the stacks are marked.
    complete-marking(vms)
    var p:ptr<ptr<Stack>> = addr(STACKS)
    while [p] != null :
      val stack = [p]
      val stack-obj = stack as ptr<?> - sizeof(long)
      if test-mark(stack-obj, vms) == 0 :
        ;Proceed to next stack in STACKS list
        p = addr(stack.tail)
      else :
        ;Mark references in stack frames
        iterate-references-in-stack-frames(stack, addr(mark-from-root), vms)
        ;Remove stack from STACKS list
        [p] = stack.tail
        ;Insert stack to live-stacks list
        stack.tail = live-stacks
        live-stacks = stack
  ;Now STACKS contains unreachable stacks only. Dispose their frames.
  for (var stack:ptr<Stack> = STACKS, stack != null, stack = stack.tail) :
    free-stack-frames(stack.frames, stack.size)
  STACKS = live-stacks
  ;No meaningful return value
  return false

lostanza defn relocate-stacks (vms:ptr<VMState>) -> ref<False> :
  val compaction-start = vms.heap.compaction-start
  ;p is a pointer to the list being scanned.
  var p:ptr<ptr<Stack>> = addr(STACKS)
  while [p] != null :
    val stack = [p]
    if stack > compaction-start :
      [p] = stack + relocation-offset(stack, vms)
    iterate-references-in-stack-frames(stack, addr(relocate-reference), vms)
    ;Go to the next element in the list.
    p = addr(stack.tail)
  ;No meaningful return value
  return false


lostanza deftype GlobalRoots :
  length: int
  roots: int ...

lostanza deftype StackMap :
  size: int
  num-roots: int
  roots: int ...

lostanza deftype StackTraceTable :
  length: long
  entries: StackTraceTableEntry ...

lostanza deftype StackTraceTableEntry :
  lbl: ptr<?>
  record: StackTraceRecord

lostanza deftype ClassRecord :
  name:ptr<byte>
  size:int
  item-size:int
  num-roots:int
  roots:int ...

lostanza deftype ArrayRecord :
  name:ptr<byte>
  base-size:int
  item-size:int
  num-base-roots:int
  num-item-roots:int
  roots:int ...

protected lostanza deftype VMState :
  ;Permanent State
  ;Changes in-between each code load
  instructions: ptr<byte>
  registers: ptr<long>
  global-offsets: ptr<long>
  global-mem: ptr<byte>
  const-table: ptr<long>
  const-mem: ptr<byte>
  data-offsets: ptr<int>
  data-mem: ptr<byte>
  code-offsets: ptr<int>
  ;Variable State
  ;Changes in-between each boundary change
  var heap: Heap
  var current-stack: long
  ;Need for system stubs
  var system-stack: long
  system-registers: ptr<long>
  ;Tables
  class-table: ptr<ptr<ClassRecord>>
  global-root-table: ptr<GlobalRoots>
  stackmap-table: ptr<ptr<StackMap>>
  stack-trace-table: ptr<StackTraceTable>
  extern-table: ptr<ExternTable>
  callback-index-table: ptr<ExternDefnTable>

lostanza deftype ExternTable :
  length: long
  entries: ExternEntry ...

lostanza deftype ExternEntry :
  name:ptr<byte>
  address:long

lostanza deftype ExternDefnTable :
  length: long
  entries: ExternDefnEntry ...

lostanza deftype ExternDefnEntry :
  name:ptr<byte>
  index:long

;============================================================
;================== Internal Callbacks ======================
;============================================================

protected lostanza defn arity-error (arity:long) -> ref<Void> :
  return fatal(arity-message(new Int{arity as int}))
defn arity-message (arity:Int) :
  "Function cannot be called with %_ arguments." % [arity]

protected defn no-method-error (multi:String, args:Tuple) :
  fatal("Multi %_ has no appropriate method for arguments of type (%,)." % [multi, seq(object-type,args)])

protected defn amb-method-error (multi:String, args:Tuple) :
  fatal("Multi %_ has multiple appropriate methods for arguments of type (%,)." % [multi, seq(object-type,args)])

protected defn no-branch-error (args:Tuple) :
  fatal("No appropriate branch for arguments of type (%,)." % [seq(object-type, args)])

protected defn amb-branch-error (args:Tuple) :
  fatal("Multiple appropriate branches for arguments of type (%,)." % [seq(object-type, args)])

protected lostanza defn tuple-length-error (actual-len:long, expected-len:long) -> ref<Void> :
  return fatal(tuple-length-message(new Int{actual-len as int}, new Int{expected-len as int}))
defn tuple-length-message (actual-len:Int, expected-len:Int) :
  "Cannot destructure tuple of length %_ into %_ items." % [actual-len, expected-len]

protected defn variable-uninitialized-error (name:String|False) -> Void :
  match(name) :
    (name:String) : fatal("Variable %_ has not been initialized." % [name])
    (name:False) : fatal("Variable has not been initialized.")

protected lostanza defn cast-error (type:ref<Type>, obj:ref<?>, ctxt:int) -> ref<Void> :
  return fatal(cast-message(type, obj, new Int{ctxt}))

protected lostanza defn invalid-return-error () -> ref<Void> :
  return fatal("Unexpected return from function declared with Void return type.")

defn cast-message (t:Type, x, ctxt:Int) :
  val objt = object-type(x)
  switch(ctxt) :
    0 : "Cannot cast value of type %_ to type %_." % [objt, t]
    1 : "Argument was expected to be of type %_, but was passed a value of type %_." % [
          t, objt]
    2 : "The expected return type of this function is %_, but a value of type %_ was returned." % [
          t, objt]
    3 : "Cannot initialize a variable of type %_ with a value of type %_." % [t, objt]
    4 : "Cannot assign a value of type %_ to a variable with declared type %_." % [objt, t]
    5 : "Cannot call a value of type %_ as if it were a function." % [objt]
    6 : "Cannot deconstruct a value of type %_ into a tuple." % [objt]
    7 : "The variable was expected to have type %_, but we retrieved a value of type %_ from it." % [
          t, objt]
    8 : "Branch argument was expected to be of type %_, but was passed a value of type %_." % [
          t, objt]

;============================================================
;=================== Stack Traces ===========================
;============================================================

;Function for printing out the stack trace right now.
;Does not call any GC constructs. Does not obey stack trace
;filters.
public lostanza defn print-stack-trace! () -> ref<False> :
  call-prim flush-vm()
  labels :
    begin :
      goto loop(current-coroutine)
    loop (co:ref<RawCoroutine>) :
      call-prim print-stack-trace(co.stack)
      match(co.parent) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : ()
  return false

;Function for printing out the stack trace during
;normal operation. Respects the stack trace filter.
public defn print-stack-trace (o:OutputStream) -> False :
  val trace = collect-stack-trace()
  print-stack-trace(o, trace, STACK-TRACE-FILTER)

;Function for printing out the stack trace during
;normal operation. Respects the stack trace filter.
public defn print-stack-trace () -> False :
  print-stack-trace(CURRENT-ERROR-STREAM)

;Collect the stack trace into an object.
public lostanza defn collect-stack-trace () -> ref<StackTrace> :
  call-prim flush-vm()
  val traces = Vector<SingleStackTrace>()
  labels :
    begin: goto loop(current-coroutine)
    loop (co:ref<RawCoroutine>) :
      val trace = call-prim collect-stack-trace(co.stack)
      add(traces, StackTrace(trace))
      match(co.parent) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : ()
  return append-all(traces)

;============================================================
;====================== Fatal Errors ========================
;============================================================

var ERROR-HANDLER: String -> Void

;Initialize the ERROR-HANDLER with the default error handling
;callback.
defn initialize-error-handler () :
  ERROR-HANDLER = fn (error-msg) :
    print(CURRENT-ERROR-STREAM, "FATAL ERROR: ")
    println(CURRENT-ERROR-STREAM, error-msg)
    print-stack-trace()
    exit(-1)

;Hard unrecoverable system error. Used only when error is
;so serious that we cannot run the standard error-handling
;process. For example, out of memory, stack overflow, failed system
;invariance conditions.
lostanza defn fatal! (msg:ptr<byte>) -> ref<Void> :
  call-c clib/fflush(stdout)
  call-c clib/fprintf(current-err, "FATAL ERROR: %s\n", msg)
  call-c clib/fflush(current-err)
  print-stack-trace!()
  call-c clib/exit(-1)
  ;Unreachable
  return false as ref<?>

;Standard fatal error.
public defn fatal (msg) -> Void :
  flush(STANDARD-OUTPUT-STREAM as FileOutputStream)
  ERROR-HANDLER(to-string(msg))

;Fatal error from LoStanza context.
public lostanza defn fatal (msg:ptr<byte>) -> ref<Void> :
  return fatal(String(msg))

;Execute the given body after arming context with the given
;error handler.
;Error handler has this type:
;- handle-error (msg:String) -> ?T
;- msg is the error message passed to fatal.
;- The return value of handle-error is returned by execute-with-error-handler.
public defn execute-with-error-handler<?T> (body:() -> ?T,
                                            handle-error:String -> ?T) :
  label<T> break :
    let-var ERROR-HANDLER = break{handle-error(_)} :
      body()

;Convenience function. Just prints the stack trace and then calls halt-function.
;public defn execute-with-halt-interceptor<?T> (body:() -> ?T, halt-function:() -> Void) -> T :
;  defn handle-error (error-msg:String, break:T -> Void) -> Void :
;    print(CURRENT-ERROR-STREAM, "FATAL ERROR: ")
;    println(CURRENT-ERROR-STREAM, error-msg)
;    print-stack-trace()
;    halt-function()
;  execute-with-error-handler<T>(body, handle-error)

;============================================================
;================ Top Level Commands ========================
;============================================================

;The current command launcher
var COMMAND-LAUNCHER: (() -> False) -> True|False

;Returns false if fatal is called during execution.
defn initialize-command-launcher () :
  COMMAND-LAUNCHER = fn (body) :
    defn handle-error (error-msg:String) -> False :
      print(CURRENT-ERROR-STREAM, "FATAL ERROR: ")
      println(CURRENT-ERROR-STREAM, error-msg)
      print-stack-trace()
      false
    within execute-with-error-handler(handle-error) :
      body()
      true

;Set the current command launcher for the REPL.
public defn set-command-launcher (launcher:(() -> False) -> True|False) :
  COMMAND-LAUNCHER = launcher

;Execute the given top level command with the current
;command launcher
defn execute-toplevel-command (body:() -> False) -> True|False :
  COMMAND-LAUNCHER(body)

;============================================================
;===================== Stack Trace ==========================
;============================================================

;------------------------------------------------------------
;-------------------- Stack Trace Filter --------------------
;------------------------------------------------------------

var STACK-TRACE-FILTER: ((Symbol, String|False) -> True|False)|False = false

public defn set-stack-trace-filter (f:((Symbol, String|False) -> True|False)|False) :
  STACK-TRACE-FILTER = f

public defn current-stack-trace-filter () -> ((Symbol, String|False) -> True|False)|False :
  STACK-TRACE-FILTER

;------------------------------------------------------------
;------------------------ Printing --------------------------
;------------------------------------------------------------

lostanza defn print-stack-trace (stack:ref<Stack>) -> ref<False> :
  val vms:ptr<VMState> = call-prim flush-vm()

  ;Discover return addresses
  val buffer = stack-trace-return-addresses(vms,stack)

  ;Print buffer
  for (var i:long = buffer.length - 1, i >= 0, i = i - 1) :
    val entry = stack-trace-record(buffer.items[i], vms.stack-trace-table)
    if entry != null :
      print-record(entry)

  ;Free the buffer
  free(buffer)
  return false

lostanza defn print-record (record:ptr<StackTraceRecord>) -> ref<False> :
  call-c clib/fprintf(current-err, "  in %s", record.package)
  if record.signature != null :
    call-c clib/fprintf(current-err, "/%s", record.signature)
  call-c clib/fprintf(current-err, "\n")
  if record.file != null :
    call-c clib/fprintf(current-err, "    at %s:%d.%d\n", record.file, record.line, record.column)
  return false

;------------------------------------------------------------
;------------------------ Collecting ------------------------
;------------------------------------------------------------

lostanza defn collect-stack-trace (stack:ref<Stack>) -> ptr<PackedStackTrace> :
  val vms:ptr<VMState> = call-prim flush-vm()

  ;Discover return addresses
  val buffer = stack-trace-return-addresses(vms,stack)

  ;Build stack trace
  val builder = StackTraceBuilder()
  for (var i:long = buffer.length - 1, i >= 0, i = i - 1) :
    val entry = stack-trace-record(buffer.items[i], vms.stack-trace-table)
    if entry != null :
      add-entry(builder, entry)

  ;Pack stack trace into stable memory
  val trace = pack(builder)

  ;Free the buffer
  free(buffer)

  ;Return the packed trace.
  return trace

;------------------------------------------------------------
;------------------------ Utilities -------------------------
;------------------------------------------------------------

lostanza defn stack-trace-return-addresses (vms:ptr<VMState>, stack:ref<Stack>) -> ptr<LSLongVector> :
  ;Discover return addresses
  val buffer = LSLongVector()

  val end-sp = stack.stack-pointer
  labels :
    begin : goto loop(stack.frames)
    loop (sp:ptr<StackFrame>) :
      ;Store in return buffer
      add(buffer, sp.return)

      ;Continue if we're not at the end of the stack
      if sp < end-sp :
        val map-index = sp.liveness-map
        val stackmap = vms.stackmap-table[map-index]
        goto loop(sp + stackmap.size)

  ;Return the buffer
  return buffer

lostanza defn stack-trace-record (ret:long, trace-table:ptr<StackTraceTable>) -> ptr<StackTraceRecord> :
  for (var i:int = 0, i < trace-table.length, i = i + 1) :
    val entry = addr(trace-table.entries[i])
    if ret == (entry.lbl as long) :
      return addr(entry.record)
  return null

;============================================================
;====================== LS Long Vector ======================
;============================================================

lostanza defn realloc (p:ptr<?>, size*:long) -> ptr<?> :
  val p* = call-c clib/realloc(p, size*)
  if p* == null : fatal!("Failed to realloc")
  return p*

lostanza deftype LSLongVector :
  var capacity: int
  var length: int
  var items: ptr<long>

lostanza defn LSLongVector (capacity:int) -> ptr<LSLongVector> :
  val v:ptr<LSLongVector> = call-c clib/malloc(sizeof(LSLongVector))
  v.capacity = capacity
  v.length = 0
  v.items = call-c clib/malloc(capacity * sizeof(long))
  return v

lostanza defn LSLongVector () -> ptr<LSLongVector> :
  return LSLongVector(8)

lostanza defn ensure-capacity (v:ptr<LSLongVector>, new-capacity:int) -> int :
  if v.capacity < new-capacity :
    var c:int = v.capacity
    while c < new-capacity : c = c << 1
    v.capacity = c
    v.items = realloc(v.items, c * sizeof(long))
  return 0

lostanza defn add (v:ptr<LSLongVector>, x:long) -> int :
  ensure-capacity(v, v.length + 1)
  v.items[v.length] = x
  v.length = v.length + 1
  return 0

lostanza defn free (v:ptr<LSLongVector>) -> int :
  call-c clib/free(v.items)
  call-c clib/free(v)
  return 0

;============================================================
;==================== Class Name ============================
;============================================================

lostanza defn class-name (x:int) -> ptr<byte> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val record = vms.class-table[x]
  return record.name

;============================================================
;======================= Core Types =========================
;============================================================

public lostanza deftype Byte :
  value: byte

public lostanza deftype Char :
  value: byte

public lostanza deftype Int :
  value: int

public lostanza deftype Long :
  value: long

public lostanza deftype Float :
  value: float

public lostanza deftype Double :
  value: double

public lostanza deftype String :
  length: long
  var hash: int
  var chars: byte ...

public deftype Symbol
public lostanza deftype StringSymbol <: Symbol :
  name: ref<String>
public deftype GenSymbol <: Symbol

public lostanza deftype True
public lostanza deftype False

public lostanza deftype Tuple<T> :
  length: long
  var items: ref<T> ...

public deftype List<T>
lostanza deftype FullList<T> <: List<T> :
  head: ref<T>
  tail: ref<List<T>>
lostanza deftype NilList <: List<Void>

public deftype Coroutine<I,O>

;============================================================
;============== Standard Streams ============================
;============================================================

lostanza val stdout:ptr<?> = call-c clib/get_stdout()
lostanza val stderr:ptr<?> = call-c clib/get_stderr()
lostanza val stdin:ptr<?> = call-c clib/get_stdin()
lostanza val EOF:int = call-c clib/get_eof()
lostanza var current-err:ptr<?> = stderr

;============================================================
;================ Constant Initialization ===================
;============================================================

lostanza var const-ptr:ptr<?>
lostanza val BYTE-CONST-TAG : int = 0
lostanza val CHAR-CONST-TAG : int = 1
lostanza val INT-CONST-TAG : int = 2
lostanza val LONG-CONST-TAG : int = 3
lostanza val FLOAT-CONST-TAG : int = 4
lostanza val DOUBLE-CONST-TAG : int = 5
lostanza val TRUE-CONST-TAG : int = 6
lostanza val FALSE-CONST-TAG : int = 7
lostanza val LIST-CONST-TAG : int = 8
lostanza val STRING-CONST-TAG : int = 9
lostanza val SYMBOL-CONST-TAG : int = 10
lostanza val TYPE-CONST-TAG : int = 11
lostanza val FN-CONST-TAG : int = 12
lostanza val INTERNED-CONST-TAG : int = 13
lostanza var initialized-symbol-table? : long = 0L
lostanza var consts-top : long = 4L
lostanza var num-loaded-consts : long = 0L

protected lostanza defn initialize-constants () -> ref<False> :
  ;Initialize read pointer to beginning of the constant table
  ;[num, constants ...]
  val vms:ptr<VMState> = call-prim flush-vm()
  val consts-data = vms.const-mem

  ;Read total number of constants
  const-ptr = consts-data
  val n-consts = read-const-int()

  ;Populate constants vector
  const-ptr = consts-data + consts-top
  var cs:ptr<ref<?>> = vms.const-table as ptr<ref<?>>
  while num-loaded-consts < n-consts :
    cs[num-loaded-consts] = read-const(vms)
    num-loaded-consts = num-loaded-consts + 1

  ;Set new top
  consts-top = const-ptr - consts-data
  return false

lostanza defn read-const (vms:ptr<VMState>) -> ref<?> :
  val tag = read-const-int()
  if tag == BYTE-CONST-TAG :
    return new Byte{read-const-byte()}
  else if tag == CHAR-CONST-TAG :
    return new Char{read-const-byte()}
  else if tag == INT-CONST-TAG :
    return new Int{read-const-int()}
  else if tag == LONG-CONST-TAG :
    return new Long{read-const-long()}
  else if tag == FLOAT-CONST-TAG :
    return new Float{read-const-float()}
  else if tag == DOUBLE-CONST-TAG :
    return new Double{read-const-double()}
  else if tag == TRUE-CONST-TAG :
    return true
  else if tag == FALSE-CONST-TAG :
    return false
  else if tag == LIST-CONST-TAG :
    val len = read-const-int()
    return read-const-list(len, vms)
  else if tag == STRING-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)
    return String(len, chars)
  else if tag == SYMBOL-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)
    val str = String(len, chars)
    if initialized-symbol-table? : return to-symbol(str)
    else : return new StringSymbol{str}
  else if tag == TYPE-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Type{0, code}
  else if tag == FN-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Fn{0, code}
  else if tag == INTERNED-CONST-TAG :
    val i = read-const-int()
    val cs = vms.const-table as ptr<ref<?>>
    return cs[i]
  else :
    call-c clib/printf("Unknown constant tag: %d\n", tag)
    return fatal("Unknown constant tag")

lostanza defn read-const-list (n:int, vms:ptr<VMState>) -> ref<List> :
  if n == 0 : return new NilList{}
  else : return new FullList{read-const(vms), read-const-list(n - 1, vms)}

lostanza defn read-const-byte () -> byte :
  val value = [const-ptr as ptr<byte>]
  const-ptr = const-ptr + sizeof(byte)
  return value

lostanza defn read-const-int () -> int :
  val value = [const-ptr as ptr<int>]
  const-ptr = const-ptr + sizeof(int)
  return value

lostanza defn read-const-long () -> long :
  val value = [const-ptr as ptr<long>]
  const-ptr = const-ptr + sizeof(long)
  return value

lostanza defn read-const-float () -> float :
  val value = [const-ptr as ptr<float>]
  const-ptr = const-ptr + sizeof(float)
  return value

lostanza defn read-const-double () -> double :
  val value = [const-ptr as ptr<double>]
  const-ptr = const-ptr + sizeof(double)
  return value

lostanza defn read-const-chars (len:long) -> ptr<byte> :
  val value = const-ptr as ptr<byte>
  ;length chars + pad to nearest 4 bytes
  val n = (len + 3) & -4
  const-ptr = (const-ptr + n) as ptr<?>
  return value

;============================================================
;=================== Garbage Collection =====================
;============================================================

lostanza var initialized-gc-notifiers? : long = 0L
public lostanza var MAXIMUM-HEAP-SIZE : long = 4L * 1024L * 1024L * 1024L
lostanza val SYSTEM-PAGE-SIZE : long = 4096

public lostanza defn round-up-to-whole-pages (x:long) -> long :
  return (x + (SYSTEM-PAGE-SIZE - 1)) & ( ~ (SYSTEM-PAGE-SIZE - 1));

;Explicitly request a garbage collection cycle.
public lostanza defn run-garbage-collector () -> ref<False> :
  extend-heap(0L)
  return false

;This hook is called automatically by the generated code (and the
;VM) when we need to allocate a new object and there isn't
;enough space on the heap for its allocation.
;- size: the number of bytes that we need to reserve.
;The return value is unused.
;The system tries to free at least 'size' number of bytes.
;If it cannot do that, then it fails with an unrecoverable
;"Out Of Memory" error.
lostanza defn extend-heap (size:long) -> long :
  ;Ensure that the stack pool is wellformed.
    ;Collect garbage, and ensure we freed enough space
  val remaining = call-prim collect-garbage(size)
  if remaining < size : fatal!("Out of memory.")
  ;Now run the GC notifiers, if they have been initialized
  if initialized-gc-notifiers? :
    run-gc-notifiers()
  ;If GC notifiers allocated too much space, then collect the garbage again
  ;(Happens rarely.)
  val vms:ptr<VMState> = call-prim flush-vm()
  val remaining-after-notifiers = vms.heap.limit - vms.heap.top
  if remaining-after-notifiers < size :
    ;Collect garbage, and ensure we freed enough space
    val remaining = call-prim collect-garbage(size)
    if remaining < size : fatal!("Out of memory.")
  ;Unused return value
  return 0

;============================================================
;================== GC Notifiers ============================
;============================================================

var GC-NOTIFIERS:Vector<(() -> ?)>

lostanza defn initialize-gc-notifiers () -> ref<False> :
  GC-NOTIFIERS = Vector<(() -> ?)>()
  initialized-gc-notifiers? = 1L
  return false

defn run-gc-notifiers () :
  for f in GC-NOTIFIERS do :
    f()

public defn add-gc-notifier (f: () -> ?) :
   add(GC-NOTIFIERS, f)

;====>=======================================================
;====================== Stack Pool ==========================
;============================================================

lostanza defn allocate-stack-frames (size:long) -> ptr<StackFrame> :
  if size == INITIAL-STACK-SIZE :
    if FREE-STACK-LIST == null :
      var block:ptr<long> = call-c clib/malloc(STACK-BLOCK-SIZE)
      if block == null : fatal("Cannot allocate stack block")
      val block-end:ptr<?> = block + STACK-BLOCK-SIZE
      while block < block-end :
        [block] = FREE-STACK-LIST as long
        FREE-STACK-LIST = block
        block = block + INITIAL-STACK-SIZE
    val frames = FREE-STACK-LIST
    FREE-STACK-LIST = [frames] as ptr<long>
    return frames as ptr<StackFrame>
  else :
    val frames:ptr<StackFrame> = call-c clib/malloc(size)
    if frames == null : fatal("Cannot allocate stack frames")
    return frames

lostanza defn free-stack-frames (frames:ptr<StackFrame>, size:long) -> ref<False> :
  if frames == null : return false
  if size == INITIAL-STACK-SIZE :
    [frames as ptr<long>] = FREE-STACK-LIST as long
    FREE-STACK-LIST = frames as ptr<long>
  else :
    call-c clib/free(frames)
  return false

lostanza defn extend-stack-frames (frames:ptr<StackFrame>, size:long, new-size:long) -> ptr<StackFrame> :
  if (size == INITIAL-STACK-SIZE) or (new-size == INITIAL-STACK-SIZE) :
    ;Allocate new frames and copy over old frames
    val new-frames = allocate-stack-frames(new-size)
    call-c clib/memcpy(new-frames, frames, size)
    free-stack-frames(frames, size)
    return new-frames
  else :
    return realloc(frames, new-size)

lostanza defn free (s:ref<Stack>) -> ref<False> :
  ;call-c clib/printf("freeing coroutine\n")
  free-stack-frames(s.frames, s.size)
  s.frames = null
  s.stack-pointer = null
  return false

;Global stack pool
lostanza val INITIAL-STACK-SIZE:long = 4L * 1024L
lostanza val STACKS-IN-BLOCK:long = 64L
lostanza val STACK-BLOCK-SIZE:long = INITIAL-STACK-SIZE * STACKS-IN-BLOCK
lostanza var FREE-STACK-LIST:ptr<long> = null

lostanza defn initialize-stack-pool () -> ref<False> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val entry-stack:ptr<Stack> = untag(vms.current-stack)
  val entry-system-stack:ptr<Stack> = untag(vms.system-stack)
  entry-stack.tail = entry-system-stack
  STACKS = entry-stack
  ;call-c clib/printf("Entry stack frames %p\n", entry-stack.frames)
  ;call-c clib/printf("Entry system stack frames %p\n", entry-system-stack.frames)
  ;No meaningful return value.
  return false
initialize-stack-pool()

;<doc>=======================================================
;====================== Stack Extension =====================
;============================================================

Computing the new size of the stack:
  - The desired-size is:
      stack-pointer + size - frames
  - Double the current size until it is larger than the
    desired size, and then cap it at the maximum allowable size.
  - If the new size is still less than the desired size, then
    stack overflow.

;============================================================
;=======================================================<doc>

lostanza defn extend-stack (size:long) -> long :
  ;Retrieve stack
  val vms:ptr<VMState> = call-prim flush-vm()
  val s:ptr<Stack> = addr!([vms.system-stack as ref<Stack>])

  ;Compute new size of stack
  val maximum-size = 1024L * 1024L * 1024L
  val desired-size = s.stack-pointer + size - s.frames
  var new-size:long = s.size
  while new-size < desired-size : new-size = new-size << 1
  new-size = min(new-size, maximum-size)

  ;Check for stack overflow
  if new-size < desired-size : fatal!("Stack overflow")

  val new-frames = extend-stack-frames(s.frames, s.size, new-size)
  ;Swap in new frames
  s.stack-pointer = s.stack-pointer + (new-frames - s.frames)
  s.size = new-size
  s.frames = new-frames

  ;Return
  return 0

;============================================================
;============= Garbage Collector with Resizing ==============
;============================================================

;Uses virtual memory system to allocate more pages.
;- space is a pointer to a virtual address region created using mmap.
;- current-size is the current number of bytes that has been concretely allocated.
;- desired-size is the new number of bytes that we want to be concretely allocated.
public lostanza defn stz-memory-resize (space:ptr<long>, current-size:long, desired-size:long) -> ptr<long> :
  call-c clib/stz_memory_resize(space, current-size, desired-size)
  return space + desired-size

;This function is called by the "call-prim collect-garbage" primitive.
;It runs the garbage collector, and returns the new number of bytes
;remaining after the garbage collector runs.
;- size: the number of bytes that we desire from the heap. This is
;  used to compute whether or not to grow the heap.
lostanza defn collect-garbage (size:long) -> long :
  ;Retrieve state
  val vms:ptr<VMState> = call-prim flush-vm()

  ;First run the garbage collector,
  collect-garbage(vms)

  ;Compute the new desired size of the heap.
  val available-space = vms.heap.limit - vms.heap.start
  var desired-space:long = vms.heap.top + size - vms.heap.start
  ;Increase the desired space if it is insufficient
  ;to satisfy the requested size.
  if available-space < desired-space :
    ;Double the desired space until it is sufficient.
    val requested-space = desired-space
    desired-space = available-space * 2
    while desired-space < requested-space :
      desired-space = desired-space * 2
  ;Increase the desired space if the usage ratio
  ;is too high.
  else :
    val usage-ratio = (desired-space as float) / (available-space as float)
    if usage-ratio > 0.5f :
      desired-space = available-space * 2
  ;Ensure that the desired space
  desired-space = min(desired-space, MAXIMUM-HEAP-SIZE)

  ;Increase the heap size if desired.
  if desired-space > available-space :
    expand-heap(desired-space, vms)

  ;Return the remaining space
  return vms.heap.limit - vms.heap.top

;============================================================
;================== New Garbage Collector ===================
;============================================================

;Define various constants for the relations between
;bits, bytes, and longs.
lostanza val LOG-BITS-IN-BYTE:long = 3
lostanza val LOG-BYTES-IN-LONG:long = 3
lostanza val LOG-BITS-IN-LONG:long = LOG-BYTES-IN-LONG + LOG-BITS-IN-BYTE
lostanza val BYTES-IN-LONG:long = 1 << LOG-BYTES-IN-LONG
lostanza val BITS-IN-LONG:long = 1 << LOG-BITS-IN-LONG

;Structure for representing a Heap space.
;- start is the starting address of the heap.
;- top is the top address of the heap.
;- limit is equal to start + number of currently available bytes in the heap.
;- size is the maximum size that the heap can be expanded to.
;- bitset is the starting address of the marking bits for the heap.
;- compaction-start is the lowest moving object in collection area.
;- log2-bucket-size: The heap is divided into equal-sized buckets for
;  enabling fast lookup in the break table. Each bucket is sized to be
;  a power-of-2 number of bytes. log2-bucket-size holds the log2 of the
;  size of the bucket.
public lostanza deftype Heap :
  var top: ptr<long>
  var limit: ptr<long>
  var start: ptr<long>
  var bitset: ptr<long>
  var size: long
  var compaction-start: ptr<long>
  var log2-bucket-size: long

  ;Marking stack
  ;Note that the stack grows downwards so stack-bottom is equal to
  ;stack-start + stack-size, and stack-top decreases as we push new items.
  var stack-start: ptr<long>
  var stack-bottom: ptr<long>
  var stack-top: ptr<long>

  ;Heap segment with the objects incompletely marked due to stack overflow
  var min-incomplete: ptr<?>
  var max-incomplete: ptr<?>

;Given the current number of bytes in the heap, return
;the number of bytes in the heap's bitset, rounded up
;to the nearest long.
lostanza defn bitset-size (heap-size:long) -> long :
  ;heap-size-in-longs = ceil( heap-size * (1 long / 8 bytes) )
  val heap-size-in-longs = ((heap-size + (BYTES-IN-LONG - 1)) >> LOG-BYTES-IN-LONG)
  ;bitset-size-in-longs = ceil( heap-size-in-longs * (1 bit-in-bitset / 1 long) * (1 long / 64 bits) )
  val bitset-size-in-longs = (heap-size-in-longs + (BITS-IN-LONG - 1)) >> LOG-BITS-IN-LONG
  ;return bitset-size-in-longs * bytes-in-long
  return bitset-size-in-longs << LOG-BYTES-IN-LONG

;Sets the first 'size' bytes in the address range starting from 'start' to 0.
;Returns 'start'.
lostanza defn clear (start:ptr<?>, size:long) -> ptr<?> :
  return call-c clib/memset(start, 0, size)

;Initialize the current heap structure.
;- min-size is the initial size of the heap.
;- max-size is the maximum size that heap can be expanded to.
public lostanza defn initialize-heap (min-size:long, max-size:long, vms:ptr<VMState>) -> ref<False> :
  ;Precondition: Assert 0 <= min-size && min-size <= max-size
  #if-not-defined(OPTIMIZE) :
    if min-size < 0L or max-size < min-size :
      fatal("Illegal arguments to initialize-heap.")
  ;Round up sizes to the nearest page size so that it behaves wrt. mmap.
  val min-heap-size = round-up-to-whole-pages(min-size)
  val max-heap-size = round-up-to-whole-pages(max-size)
  ;Initialize the memory for the main heap.
  vms.heap.size = max-heap-size
  vms.heap.start = call-c clib/stz_memory_map(min-heap-size, max-heap-size)
  vms.heap.top = vms.heap.start
  vms.heap.limit = vms.heap.start + min-heap-size
  ;Initialize the memory for the heap's bitset.
  val min-bitset-size = round-up-to-whole-pages(bitset-size(min-heap-size))
  val max-bitset-size = round-up-to-whole-pages(bitset-size(max-heap-size))
  vms.heap.bitset = call-c clib/stz_memory_map(min-bitset-size, max-bitset-size)
  clear(vms.heap.bitset, min-bitset-size)
  ;Allocate space for marking stack (1024L * sizeof(long))
  ;Initialize stack-top and stack-bottom to just past the allocated memory.
  ;TODO: If marking stack were reserved right above the heap end, the entire address
  ;range from heap-top to stack-bottom could be occupied by the stack.
  val stack-size = round-up-to-whole-pages(1024L << LOG-BYTES-IN-LONG)
  vms.heap.stack-start = call-c clib/stz_memory_map(stack-size, stack-size)
  vms.heap.stack-bottom = vms.heap.stack-start + stack-size
  vms.heap.stack-top = vms.heap.stack-bottom
  ;No meaningful return value.
  return false

;Remove all associated memory reserved for the current heap structure.
public lostanza defn finalize-heap (vms:ptr<VMState>) -> ref<False> :
  ;Compute the current size of the heap and it's bitset.
  val current-heap-size = vms.heap.limit - vms.heap.start
  val current-bitset-size = bitset-size(current-heap-size)
  ;Unmap the currently reserved pages.
  call-c clib/stz_memory_unmap(vms.heap.start, round-up-to-whole-pages(current-heap-size))
  call-c clib/stz_memory_unmap(vms.heap.bitset, round-up-to-whole-pages(current-bitset-size))
  ;Compute the size of the marking size (note that it grows downwards).
  val marking-stack-size = vms.heap.stack-bottom - vms.heap.stack-start
  call-c clib/stz_memory_unmap(vms.heap.stack-start, marking-stack-size)
  ;No meaningful return value.
  return false

;Ensure that the given heap is at least the given size.
;Assumes that the given size is less than the maximum size that heap can be expanded to.
lostanza defn expand-heap (size:long, vms:ptr<VMState>) -> ref<False> :
  ;Precondition: Ensure that size is less than maximum allowed size.
  #if-not-defined(OPTIMIZE) :
    if vms.heap.size < size :
      fatal("Cannot expand heap past its maximum size.")

  ;Exit immediately if heap is already the desired size (or bigger).
  val current-heap-size = round-up-to-whole-pages(vms.heap.limit - vms.heap.start)
  val desired-heap-size = round-up-to-whole-pages(size)
  if current-heap-size >= desired-heap-size : return false

  ;Resize the heap.
  vms.heap.limit = stz-memory-resize(vms.heap.start, current-heap-size, desired-heap-size)

  ;Resize the bitset.
  val current-bitset-size = round-up-to-whole-pages(bitset-size(current-heap-size))
  val desired-bitset-size = round-up-to-whole-pages(bitset-size(desired-heap-size))
  ;If necessary, clear the newly-allocated bytes in the bitset.
  if current-bitset-size < desired-bitset-size :
    call-c clib/stz_memory_resize(vms.heap.bitset, current-bitset-size, desired-bitset-size)
    clear(vms.heap.bitset + current-bitset-size, desired-bitset-size - current-bitset-size)

  ;No meaningful return value.
  return false

;Sanity check: Ensure that the given pointer points to within the heap of given VMState.
;Calls fatal if it is not.
lostanza defn ensure-pointer-in-heap! (p:ptr<?>, vms:ptr<VMState>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
    if p < vms.heap.start or  p >= vms.heap.top :
      fatal("Pointer is outside of heap.")
  return false

;Sanity check: Ensure that the given address range: start (inclusive) to limit (exclusive)
;is contained within the heap of given VMState.
;Calls fatal if it is not.
lostanza defn ensure-address-range-in-heap! (start:ptr<?>, limit:ptr<?>, vms:ptr<VMState>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
    if start < vms.heap.start or start > limit or limit > vms.heap.top :
      fatal("Address range is outside of heap.")
  return false

;Return the index in the state's heap bitset that acts as the mark for the state's heap pointer.
lostanza defn bit-index (p:ptr<?>, vms:ptr<VMState>) -> long :
  ensure-pointer-in-heap!(p, vms)
  return (p - vms.heap.start) >> LOG-BYTES-IN-LONG

;Returns the pointer in the state's heap's bitset containing the given mark bit.
lostanza defn bit-address (bit-index:long, vms:ptr<VMState>) -> ptr<long> :
  return vms.heap.bitset + (bit-index >> LOG-BITS-IN-LONG) << LOG-BYTES-IN-LONG

;Returns bit-index % BITS-IN-LONG.
lostanza defn bit-shift (bit-index:long) -> long :
  return bit-index & (BITS-IN-LONG - 1)

;Assumes the bit-index designates a bit within some 64-bit long.
;Returns a mask containing a 1 in the same position as that bit within the long.
lostanza defn bit-mask (bit-index:long) -> long :
  return 1L << bit-shift(bit-index)

;Returns 1 if the given heap pointer has been marked
;in the state's heap bitset, and 0 otherwise.
lostanza defn test-mark (p:ptr<?>, vms:ptr<VMState>) -> long :
  val index = bit-index(p, vms)
  return ([bit-address(index, vms)] >> bit-shift(index)) & 1

;Marks the given heap pointer in the state's heap bitset.
lostanza defn set-mark (p:ptr<?>, vms:ptr<VMState>) -> ref<False> :
  val index = bit-index(p, vms)
  val address = bit-address(index, vms)
  [address] = [address] | bit-mask(index)
  ;No meaningful return value.
  return false

;Clears the mark for the given heap pointer in the state's heap's bitset.
lostanza defn clear-mark (p:ptr<?>, vms:ptr<VMState>) -> ref<False> :
  val index = bit-index(p, vms)
  val address = bit-address(index, vms)
  [address] = [address] & (~ bit-mask(index))
  ;No meaningful return value.
  return false

;Fused operation. Marks the given heap pointer in the state's heap bitset.
;Returns non-zero value if the pointer was previously marked, otherwise 0L.
lostanza defn test-and-set-mark (p:ptr<?>, vms:ptr<VMState>) -> long :
  val index = bit-index(p, vms)
  val address = bit-address(index, vms)
  val mask = bit-mask(index)

  val old-value = [address]
  [address] = old-value | mask
  return old-value & mask

;Fused operation. Clears the mark for the given heap pointer in the state's heap's bitset.
;Returns non-zero value if the pointer was previously marked, otherwise 0L.
lostanza defn test-and-clear-mark (p:ptr<?>, vms:ptr<VMState>) -> long :
  val index = bit-index(p, vms)
  val address = bit-address(index, vms)
  val mask = bit-mask(index)

  val old-value = [address]
  [address] = old-value & (~ mask)
  return old-value & mask

;Clears the mark for the given heap address range.
lostanza defn clear-mark (start:ptr<?>, limit:ptr<?>, vms:ptr<VMState>) -> ref<False> :
  ensure-address-range-in-heap!(start, limit, vms)

  ;Compute start and ending masks.
  ;Supposing that start-bit-index is 9, then
  ;start-bit-mask is 0000 0000 1111 1111, which is used to zero-out all bits
  ;after the start-bit-index (inclusive).
  ;Supposing that end-bit-index is 9, then
  ;end-bit-mask is 1111 1110 0000 0000, which is used to zero-out all its
  ;before the end-bit-index (inclusive).
  val start-bit-index = bit-index(start, vms)
  val end-bit-index = bit-index(limit - 1, vms)
  val start-bit-address = bit-address(start-bit-index, vms)
  val end-bit-address = bit-address(end-bit-index, vms)
  val start-bit-mask = bit-mask(start-bit-index) - 1
  val end-bit-mask = (- (bit-mask(end-bit-index) << 1))

  ;Special case: the first bit word is the last bit word
  if start-bit-address == end-bit-address :
    ;Zero-out all bits where both masks are zero.
    [start-bit-address] = [start-bit-address] & (start-bit-mask | end-bit-mask)
  else :
    ;Zero-out the bits in the start and end words.
    [start-bit-address] = [start-bit-address] & start-bit-mask
    [end-bit-address] = [end-bit-address] & end-bit-mask
    ;Clear the intervening words completely.
    clear(start-bit-address + BYTES-IN-LONG, end-bit-address - start-bit-address - BYTES-IN-LONG)
  ;No meaningful return value.
  return false

;Given the 64-long address range starting at 'start' in the heap,
;and the 64-bit mask given in 'bit-word',
;call 'f' on every pointer corresponding to a 1 in 'bit-word'.
lostanza defn iterate-bit-word (start:ptr<?>, bit-word:long,
                                f:ptr<((ptr<?>, ptr<VMState>) -> ref<False>)>,
                                vms:ptr<VMState>) -> ref<False> :
  ;Ones are rare, expect zeroes
  var p:ptr<?> = start
  var bits:long = bit-word
  while bits != 0 :
    ;TODO: introduce BSF instruction and use it here
    ;If the next 32 bits in 'bits' is zero, then
    ;advance bits and pointer p by 32.
    if (bits & 0xFFFFFFFFL) == 0 :
      bits = bits >> 32
      p = p + (32 * BYTES-IN-LONG)
    ;If the next 16 bits in 'bits' is zero, then
    ;advance bits and pointer p by 16.
    if (bits & 0xFFFFL) == 0 :
      bits = bits >> 16
      p = p + (16 * BYTES-IN-LONG)
    ;If the next 8 bits in 'bits' is zero, then
    ;advance bits and pointer p by 8.
    if (bits & 0xFFL) == 0 :
      bits = bits >> 8
      p = p + (8 * BYTES-IN-LONG)
    ;If the next 4 bits in 'bits' is zero, then
    ;advance bits and pointer p by 4.
    if (bits & 0xFL) == 0 :
      bits = bits >> 4
      p = p + (4 * BYTES-IN-LONG)
    ;If the next 2 bits in 'bits' is zero, then
    ;advance bits and pointer p by 2.
    if (bits & 0x3) == 0 :
      bits = bits >> 2
      p = p + (2 * BYTES-IN-LONG)
    ;If the next bit is set, then call f on the
    ;current pointer.
    if (bits & 1) != 0 :
      [f](p, vms)
    ;Advance bits and p by 1.
    bits = bits >> 1
    p = p + (1 * BYTES-IN-LONG)
  ;No meaningful return value.
  return false

;Iterate through the heap address range given by start and limit,
;and call f on all pointers in that range that are marked in the state's heap bitset.
lostanza defn iterate-marked (start:ptr<?>, limit:ptr<?>,
                              f:ptr<((ptr<?>, ptr<VMState>) -> ref<False>)>,
                              vms:ptr<VMState>) -> ref<False> :
  ensure-address-range-in-heap!(start, limit, vms)

  ;Compute starting shift and ending mask.
  ;Supposing that end-bit-index is 9, then end-bit-mask contains 0000 0001 1111 1111.
  val start-bit-index = bit-index(start, vms)
  val end-bit-index = bit-index(limit - 1, vms)
  val start-bit-address = bit-address(start-bit-index, vms)
  val end-bit-address = bit-address(end-bit-index, vms)
  val start-bit-shift = bit-shift(start-bit-index)
  val end-bit-mask = (bit-mask(end-bit-index) << 1) - 1

  ;Special case: the first bit word is the last bit word
  if start-bit-address == end-bit-address :
    ;The '[start-bit-address] & end-bit-mask' expression contains the bitset word
    ;with mark bits for pointers beyond the ending pointer masked off.
    ;That word is then shifted to the right by 'start-bit-shift' to align with the start pointer.
    iterate-bit-word(start, ([start-bit-address] & end-bit-mask) >> start-bit-shift, f, vms)

  else :
    ;Process the first bit word.
    ;[start-bit-address] is the 64-bit long in the bitset containing the mark for the start pointer.
    ;It is shifted to the right by 'start-bit-shift' to align with the start pointer.
    iterate-bit-word(start, [start-bit-address] >> start-bit-shift, f, vms)

    ;Initialize p to the pointer right after the 64-pointer chunk containing the start pointer.
    var p:ptr<?> = start + ((BITS-IN-LONG - start-bit-shift) * BYTES-IN-LONG)
    var bit-address:ptr<long> = start-bit-address + BYTES-IN-LONG
    ;Process every intervening chunk, not including the last chunk containing the end pointer.
    while bit-address < end-bit-address :
      ;Iterate through every marked pointer in this chunk.
      if [bit-address] != 0 :     ;Rarely taken
        iterate-bit-word(p, [bit-address], f, vms)
      ;Advance to the next chunk
      bit-address = bit-address + BYTES-IN-LONG
      p = p + (BITS-IN-LONG * BYTES-IN-LONG)

    ;Process the last bit word.
    ;Mask off the bits in the bitset that are beyond the last pointer.
    iterate-bit-word(p, [end-bit-address] & end-bit-mask, f, vms)

  ;No meaningful return value
  return false

;Reset the incomplete range to the null interval.
;We deliberately set min to greater than any pointer in the heap,
;and set max to lower than any pointer in the heap,
;to prepare the incomplete range to be extended using extend-incomplete-range.
lostanza defn reset-incomplete-range (vms:ptr<VMState>) -> ref<False> :
  vms.heap.min-incomplete = vms.heap.limit
  vms.heap.max-incomplete = vms.heap.start
  ;No meaningful return value
  return false

;Extend the incomplete range by ensuring the given heap pointer p
;is within the incomplete range.
lostanza defn extend-incomplete-range (p:ptr<?>, vms:ptr<VMState>) -> ref<False> :
  if p < vms.heap.min-incomplete : vms.heap.min-incomplete = p
  if p > vms.heap.max-incomplete : vms.heap.max-incomplete = p
  ;No meaningful return value
  return false

;Push a new pointer onto the marking stack.
;Note that the marking stack grows downwards.
lostanza defn push-to-marking-stack (p:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
    if marking-stack-full(vms) : fatal("Marking stack overflow.")
  vms.heap.stack-top = vms.heap.stack-top - BYTES-IN-LONG
  [vms.heap.stack-top] = p as long
  return false

;Pop a pointer from the marking stack.
;Note that the marking stack grows downwards.
lostanza defn pop-marking-stack (vms:ptr<VMState>) -> ptr<long> :
  #if-not-defined(OPTIMIZE) :
    if marking-stack-empty(vms) : fatal("Marking stack underflow.")
  val value = [vms.heap.stack-top]
  vms.heap.stack-top = vms.heap.stack-top + BYTES-IN-LONG
  return value as ptr<long>

;Returns 1L if the marking stack is not empty.
;The marking stack grows downwards, so it is not empty
;if the top is less than the bottom.
lostanza defn marking-stack-not-empty (vms:ptr<VMState>) -> long :
  return vms.heap.stack-top < vms.heap.stack-bottom

;Returns 1L if the marking stack is empty.
lostanza defn marking-stack-empty (vms:ptr<VMState>) -> long :
  return vms.heap.stack-top == vms.heap.stack-bottom

;Return 1L if the marking stack is full.
lostanza defn marking-stack-full (vms:ptr<VMState>) -> long :
  return vms.heap.stack-top == vms.heap.stack-start

;Mark the object at the given heap pointer.
;On marking stack overflow the depth-first object traversal is pruned, and
;the marked objects with possibly unmarked children are added to the range
;of incompletely marked objects.
lostanza defn mark-and-push (ref:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  ;Retrieve the value at the given heap pointer.
  val v = [ref]
  ;Is this a reference to a Stanza heap object?
  val tagbits = v & 7L
  if tagbits == 1L :
    ;Remove the tagbits to retrieve the object pointer.
    val p = (v - 1) as ptr<long>
    ;Mark the object, and test whether it has already previously been marked.
    if test-and-set-mark(p, vms) == 0 :
      ;If there is still space in the marking stack add the object to the
      ;marking stack, otherwise add it to the incomplete range.
      if marking-stack-full(vms) : extend-incomplete-range(p, vms)
      else : push-to-marking-stack(p, vms)

  ;No meaningful return value
  return false

;Given 'ref', a pointer to a root variable (e.g. global, const, etc.),
;mark it and iteratively traverse through its referenced objects.
lostanza defn mark-from-root (ref:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  ;Retrieve the value at the given heap pointer.
  val v = [ref]
  ;Is this a reference to a Stanza heap object?
  val tagbits = v & 7L
  if tagbits == 1L :
    ;Remove the tag bits to retrieve the object pointer.
    val p = (v - 1) as ptr<long>
    ;Mark the object, and continue marking the object graph if it
    ;has not previously been marked.
    if test-and-set-mark(p, vms) == 0 :
      continue-marking(p, vms)
  ;No meaningful return value
  return false

;Given the pointer p to an already-marked object,
;mark all the objects that it references and traverse the object graph.
;Marks as many objects as possible given the size of the marking stack.
lostanza defn continue-marking (p:ptr<?>, vms:ptr<VMState>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
    if test-mark(p, vms) == 0 : fatal("Marked object expected.")
  ;Initialize the marking stack with p.
  push-to-marking-stack(p, vms)
  ;Iteratively traverse and mark the object graph.
  while marking-stack-not-empty(vms) :
    iterate-references(pop-marking-stack(vms), addr(mark-and-push), vms)
  ;No meaningful return value
  return false

;Recover from possible marking stack overflow by using marked objects from
;the range of incompletely marked objects as additional roots
lostanza defn complete-marking (vms:ptr<VMState>) -> ref<False> :
  ;If the incomplete range is not empty,
  while vms.heap.min-incomplete <= vms.heap.max-incomplete :
    ;We add BYTES-IN-LONG to max-incomplete because max-incomplete is inclusive
    ;and 'iterate-marked' needs exclusive bounds.
    val incomplete-start = vms.heap.min-incomplete
    val incomplete-limit = vms.heap.max-incomplete + BYTES-IN-LONG

    ;Call continue-marking on all marked pointers in the incomplete range.
    ;We reset the incomplete range before we do this so that if the marking
    ;stack overflows, the remaining pointers are stored in the incomplete range.
    reset-incomplete-range(vms)
    iterate-marked(incomplete-start, incomplete-limit, addr(continue-marking), vms)

  ;No meaningful return value
  return false

;Call f on all root pointers.
lostanza defn iterate-roots (f:ptr<((ptr<long>, ptr<VMState>) -> ref<False>)>,
                             vms:ptr<VMState>) -> ref<False> :
  ;Scan globals
  val globals = vms.global-mem as ptr<long>
  val roots = vms.global-root-table
  val nroots = roots.length
  for (var i:int = 0, i < nroots, i = i + 1) :
    val r = roots.roots[i]
    [f](addr(globals[r]), vms)

  ;Scan const roots
  val consts = vms.const-table
  val nconsts = [vms.const-mem as ptr<int>]
  for (var i:int = 0, i < nconsts, i = i + 1) :
    [f](addr(consts[i]), vms)

  ;Scan stack roots
  ;call-c clib/printf("scan stacks\n")
  [f](addr(vms.current-stack), vms)
  [f](addr(vms.system-stack), vms)
  ;No meaningful return value
  return false

;Call f on all references stored in the object pointed to by p.
lostanza defn iterate-references (p:ptr<long>,
                                  f:ptr<((ptr<long>, ptr<VMState>) -> ref<False>)>,
                                  vms:ptr<VMState>) -> ref<False> :
  val tag = [p]
  val class-rec = vms.class-table[tag]
  if class-rec.item-size == 0 :
    val roots = addr(class-rec.roots)
    val num-roots = class-rec.num-roots
    val obj = p as ptr<ObjectLayout>
    for (var i:int = 0, i < num-roots, i = i + 1) :
      val r = roots[i]
      [f](addr(obj.slots[r]), vms)
  ;Array class
  else :
    val array-rec = class-rec as ptr<ArrayRecord>
    val array = p as ptr<ObjectLayout>

    val num-base-roots = array-rec.num-base-roots
    val base-roots = addr(array-rec.roots)
    for (var i:int = 0, i < num-base-roots, i = i + 1) :
      val r = base-roots[i]
      [f](addr(array.slots[r]), vms)

    val num-item-roots = array-rec.num-item-roots
    if num-item-roots > 0 :
      var items:ptr<?> = addr(array.slots) + array-rec.base-size
      val item-size = array-rec.item-size
      val item-roots = addr(array-rec.roots[num-base-roots])
      val len = array.slots[0]
      for (var n:long = 0, n < len, n = n + 1) :
        for (var i:int = 0, i < num-item-roots, i = i + 1) :
          [f](items + item-roots[i], vms)
        items = items + item-size
  ;No meaningful return value
  return false

lostanza defn object-size-on-heap (sz:long) -> long :
  return (8L + sz + 7L) & -8L

;Given p, a heap pointer pointing to the start of an object (i.e. at
;the header word), return the total size of the object. This
;function takes care of handling variable-sized arrays.
lostanza defn allocation-size (p:ptr<long>, vms:ptr<VMState>) -> long :
  ;Use the header word to retrieve the object's class record.
  val tag = [p]
  val class-rec = vms.class-table[tag]
  ;Fixed-length objects have an item-size of 0.
  if class-rec.item-size == 0 :
    ;Use 'object-size-on-heap' to handle details of accounting
    ;for the size of the header word and space for the forwarding pointer.
    return object-size-on-heap(class-rec.size)
  ;Otherwise, it's a variable-length array object.
  else :
    val array-rec = class-rec as ptr<ArrayRecord>
    val base-size = array-rec.base-size
    val item-size = array-rec.item-size
    val array = p as ptr<ObjectLayout>
    val len = array.slots[0]
    ;Use 'object-size-on-heap' to handle details of accounting
    ;for the size of the header word and space for the forwarding pointer.
    return object-size-on-heap(base-size + item-size * len)

;Mark all reachable objects.
lostanza defn mark-reachable-objects (vms:ptr<VMState>) -> ref<False> :
  ;Reset the incomplete range and call mark-from-root
  ;on all roots.
  reset-incomplete-range(vms)
  iterate-roots(addr(mark-from-root), vms)
  ;Iteratively call continue-marking on all pointers in the
  ;incomplete range until we're finished.
  complete-marking(vms)
  scan-stacks(vms)
  ;No meaningful return value
  return false

;Scans the heap from given start to heap top until first unmarked object found.
;Clear the scanned objects marks. Returns address of the first unmarked object,
;or the heap top if it is not found.
lostanza defn skip-and-clear-marked (start:ptr<long>, vms:ptr<VMState>) -> ptr<long> :
  ;Precondition: Ensure that given start is below heap-top.
  val heap-top = vms.heap.top
  #if-not-defined(OPTIMIZE) :
    if start > heap-top : fatal("Invalid range.")

  ;Start scan pointer from the given start, proceeding until
  ;we hit heap top.
  var p:ptr<long> = start
  while p < heap-top :
    ;If the pointer points to an unmarked object
    ;then return that pointer immediately. Clears the
    ;mark at the same time.
    if test-and-clear-mark(p, vms) == 0 : return p
    ;Advance the pointer by the object size, so that p
    ;points to the next object in the heap.
    p = p + allocation-size(p, vms)

  ;Sanity check: If all the objects in the heap are
  ;marked, then we should be at heap-top exactly by the
  ;end of the scan.
  #if-not-defined(OPTIMIZE) :
    if p != heap-top : fatal("Invalid heap-top.")

  ;Return the heap-top to indicate no unmarked object found.
  return heap-top

;Scans the heap from given start to heap top until first marked object found.
;Returns address of the first unmarked object or the heap top if it is not found.
lostanza defn skip-unmarked (start:ptr<long>, vms:ptr<VMState>) -> ptr<long> :
  ;Precondition: Ensure that given start is below or equal to heap top.
  val heap-top = vms.heap.top
  #if-not-defined(OPTIMIZE) :
    if start > heap-top : fatal("Invalid range.")

  ;Start scan pointer from the given start, proceeding until
  ;we hit heap top.
  var p:ptr<long> = start
  while p < heap-top :
    ;If the pointer points to a marked object
    ;then return that pointer immediately.
    if test-mark(p, vms) : return p
    ;Advance the pointer by the object size, so that p
    ;points to the next object in the heap.
    p = p + allocation-size(p, vms)

  ;Sanity check: If none of the objects in the heap are
  ;marked, then we should be at heap-top exactly by the
  ;end of the scan.
  #if-not-defined(OPTIMIZE) :
    if p != heap-top : fatal("Invalid heap-top.")

  ;Return heap-top to indicate no marked object found.
  return heap-top

;Write the live range r into the heap address at the given break location.
;
;Live ranges are stored directly in the heap memory, in the space
;currently occupied by dead objects: the breaks.
;
;The encoding varies depending upon the size of the break.
;The minimum size of a break is 8 bytes long, but the live range struct is
;in general 16 bytes long.
;
;Encoding:
;Case break >= 16 bytes: then just directly store the live range.
;Case break == 8 bytes: only store the 'dead' field, tagged with 1.
;
;Since heap addresses are always 8-byte aligned, the tagged 1 will tell us
;which encoding we are using.
lostanza defn write-live-range (location:ptr<long>, r:LiveRange) -> ref<False> :
  ;Case: break == 8 bytes.
  if addr(location[1]) == r.live :
    ;Store the tagged 'dead' field.
    location[0] = (r.dead as long) | 1
  ;Case: break >= 16 bytes.
  else :
    ;Store the live range directly.
    location[0] = r.live as long
    location[1] = r.dead as long
  ;No meaningful return value
  return false

;Represents a live range: a region of live objects.
;- live: the address of the first live object in the range.
;- dead: the address just past the last live object in the range.
lostanza deftype LiveRange :
  live:ptr<long>
  dead:ptr<long>

;Read the live range at the given break location.
lostanza defn read-live-range (location:ptr<long>) -> LiveRange :
  ;Read the first word at the location.
  val location0 = location[0]
  ;Test the tag bit to determine which encoding we are using.
  if location0 & 1L :
    ;Case break == 8 bytes.
    val live = addr(location[1])             ;Computed from size of break.
    val dead = (location0 - 1) as ptr<long>  ;Remove tag bit.
    return LiveRange{live, dead}
  else :
    ;Case break >= 16 bytes.
    val live = location0 as ptr<long>
    val dead = location[1] as ptr<long>
    return LiveRange{live, dead}

;The break table considers the heap broken up into equal-sized buckets.
;Each bucket stores its information in a BreakTableEntry.
;- first-break-location: the address right after the first live range in this break.
;- accumulated-offset: the total number of bytes occupied by unmarked objects
;  before the first live range in this break.
lostanza deftype BreakTableEntry :
  var first-break-location:ptr<long>
  var accumulated-offset:long

;Computes log2 of the bucket size. Bucket size must be power-of-2 and satisfy:
;  bucket-size * break-table-length >= total-compaction-area
;Returns bucket-size = ceil(log2( total-compaction-area / break-table-length ))
lostanza defn log2-bucket-size (break-table-length:long, vms:ptr<VMState>) -> long :
  ;Goal: Compute minimum n such that:
  ;      2^n * break-table-length >= total-compaction-area
  ;Equivalent to: ceil(total-compaction-area / 2^n)  <=  break-table-length
  ;Equivalent to: floor((total-compaction-area - 1) / 2^n) + 1  <=  break-table-length
  ;Equivalent to: floor((total-compaction-area - 1) / 2^n)  <  break-table-length
  var count:long = 0L
  var compaction-area-size:long = vms.heap.top - vms.heap.compaction-start - 1L
  while compaction-area-size >= break-table-length :
    count = count + 1L
    compaction-area-size = compaction-area-size >> 1
  return count

;Given that p is a heap pointer, return the index of the break table bucket
;that contains p.
lostanza defn break-table-index (p:ptr<?>, vms:ptr<VMState>) -> long :
  return (p - vms.heap.compaction-start) >> vms.heap.log2-bucket-size

;Create the break table in the memory originally used for the marking stack, at vms.heap.stack-start.
;- compaction-start is the address of the lowest unmarked object if one exists, or
;  heap-top if it doesn't.
;After this function finishes:
;1) The break table entries will be created properly.
;2) The heap top will be updated.
;3) The information about live ranges will be annotated directly in the breaks.
;4) The compaction start address will be recorded.
lostanza defn create-break-table (compaction-start:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  ;Record the compaction-start address.
  vms.heap.compaction-start = compaction-start

  ;Marking stack is used only during marking phase. Now we reuse its memory
  ;for the root of break table. Compute the number of entries (and
  ;hence buckets) in the break table. We plan to use the entire space
  ;originally reserved for the marking stack for break table entries.
  val marking-stack-size = vms.heap.stack-bottom - vms.heap.stack-start
  val break-table-length = marking-stack-size / sizeof(BreakTableEntry)

  ;Based upon the number of entries in the break table, compute and
  ;store the size of the buckets.
  vms.heap.log2-bucket-size = log2-bucket-size(break-table-length, vms)

  ;Construct break table using the memory of the marking stack.
  val break-table = vms.heap.stack-start as ptr<BreakTableEntry>

  ;Fill the break table and annotate the breaks with the live ranges.
  ;- index: the index of the last bucket whose entry has been filled.
  ;- limit: the top of the heap
  ;- offset: the accumulated offset that all objects in the current bucket
  ;  should be shifted by. Guaranteed to be strictly negative because
  ;  objects can only move downwards during compaction phase.
  ;- current-unmarked: points to the next break in the heap.
  var index:long = -1
  val limit = vms.heap.top
  var offset:long = 0
  var current-unmarked:ptr<long> = compaction-start
  while current-unmarked < limit :
    ;Compute the details of the next live range.
    ;The live range starts at 'next-marked' and ends at 'next-unmarked'.
    ;If there are no more marked objects, then record current-unmarked
    ;as the top of the heap, and return immediately.
    val next-marked = skip-unmarked(current-unmarked, vms)
    if next-marked == limit :
      vms.heap.top = current-unmarked
      return false
    val next-unmarked = skip-and-clear-marked(next-marked, vms)
    ;Store the live range information in the heap in the
    ;current break.
    write-live-range(current-unmarked, LiveRange{next-marked, next-unmarked})

    ;Compute the length of the current break, and update the
    ;accumulated offset.
    offset = offset - (next-marked - current-unmarked)

    ;Fill break table root entries.
    ;The upcoming live range can potentially span multiple buckets.
    ;Compute 'start-index' and 'end-index' the indices of the first
    ;(inclusive) and last (inclusive) buckets that the live range
    ;spans.
    val start-index = break-table-index(next-marked, vms)
    val end-index = break-table-index(next-unmarked - 1, vms)

    ;Advance the index to be at least the starting index of the
    ;live range.
    if index < start-index : index = start-index

    ;For all buckets that the live range spans (that haven't already
    ;been filled with a BreakTableEntry), fill in the same
    ;BreakTableEntry.
    while index <= end-index :
      ;Sanity check: the index should never exceed the break table length.
      #if-not-defined(OPTIMIZE) :
        if index >= break-table-length : fatal("Index out of range.")
      ;Store the break table entry, and advance to the next bucket.
      break-table[index] = BreakTableEntry{next-unmarked, offset}
      index = index + 1

    ;Advance past the live range to the next potential break.
    current-unmarked = next-unmarked
  ;No meaningful return value
  return false

;Returns the offset that needs to be added to an object to
;compute its new address after compaction.
;- p: The pointer to the object. Can point at the object's header, inside the object,
;  or right above the object.
lostanza defn relocation-offset (p:ptr<?>, vms:ptr<VMState>) -> long :
  ;Retrieve the break table from the memory originally used for the
  ;marking stack.
  val break-table = vms.heap.stack-start as ptr<BreakTableEntry>
  ;Compute the index of the bucket that this object falls in, and
  ;retrieve the corresponding break table entry for that object.
  val break-table-entry = break-table[break-table-index(p, vms)]
  ;If the object is located within the first live range in the
  ;bucket, then the accumulated offset is equal to the final offset
  ;to return.
  var offset:long = break-table-entry.accumulated-offset
  ;dead starts off holding the address just after the first live range
  ;in the bucket. So if dead < p, then the object is *not* in the
  ;first live range in the bucket, and we need to add the other
  ;breaks to the final offset.
  var dead:ptr<long> = break-table-entry.first-break-location
  while dead < p :
    ;Read the next live range in the bucket.
    val next = read-live-range(dead)
    ;Compute the length of the next break and subtract it
    ;from the final offset. The next break proceeds from
    ;the end of the previous break (dead) to the beginning
    ;of the next break (next.live).
    offset = offset - (next.live - dead)
    ;Update dead to be the end of the next break.
    dead = next.dead
  ;Return the final offset.
  return offset

;Given a pointer to an object reference, write its new value after compaction in-place.
lostanza defn relocate-reference (ref:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  ;Retrieve the value at the given heap pointer.
  val v = [ref]
  ;Is this a reference to a Stanza heap object?
  val tagbits = v & 7L
  if tagbits == 1L :
    ;Remove the tag bits to retrieve the object pointer.
    val p = (v - 1) as ptr<long>  ;This decrement is not really necessary
    ;Only pointers to objects in the compaction area are relocated.
    if p > vms.heap.compaction-start :
      [ref] = v + relocation-offset(p, vms)
  ;No meaningful return value
  return false

;Relocate references in every object in given range
lostanza defn relocate-references (start:ptr<long>, limit:ptr<long>,
                                   vms:ptr<VMState>) -> ptr<long> :
  var p:ptr<long> = start
  while p < limit :
    iterate-references(p, addr(relocate-reference), vms)
    p = p + allocation-size(p, vms)
  return p

;Relocate all object references as part of compaction.
lostanza defn relocate-references (vms:ptr<VMState>) -> ref<False> :
  ;Relocate all GC roots.
  iterate-roots(addr(relocate-reference), vms)
  ;Relocate liveness trackers separately because their
  ;references are not typed as references.
  relocate-liveness-trackers(vms)
  ;Relocate stacks separately because of their list and off-heap frames.
  relocate-stacks(vms)
  ;Relocate references in solid prefix
  var dead:ptr<long> = relocate-references(vms.heap.start, vms.heap.compaction-start, vms)
  ;Scan the live ranges
  while dead < vms.heap.top :
    ;Read the annotated LiveRange record for the current
    ;break.
    val next = read-live-range(dead)
    ;Relocate references in every object in the live range
    dead = relocate-references(next.live, next.dead, vms)
  ;No meaningful return value
  return false

;Move objects in heap to lower memory as part of compaction.
lostanza defn compact (vms:ptr<VMState>) -> ref<False> :
  ;offset holds the amount that objects need to be
  ;shifted by to reach their new location.
  var offset:long = 0
  val top = vms.heap.top
  var dead:ptr<long> = vms.heap.compaction-start
  while dead < top :
    ;Read the live range annotated in the current break.
    val next = read-live-range(dead)
    ;The span of dead objects spans from dead (the end of the previous
    ;live range) to next.live (the start of the next live range).
    offset = offset - (next.live - dead)
    ;Shift the entire live range down by 'offset'.
    call-c clib/memcpy(next.live + offset, next.live, next.dead - next.live)
    ;Advance to the next break.
    dead = next.dead
  ;Record the new heap top.
  vms.heap.top = top + offset
  ;No meaningful return value
  return false

;Used as callback to iterate-marked. GC is incorrect if ever called.
lostanza defn fatal-object-marked! (p:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  fatal("Unexpected marked object.")
  ;No meaningful return value
  return false

;Calls fatal if any object in the heap is marked.
lostanza defn ensure-no-marks-in-collection-area! (vms:ptr<VMState>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
    iterate-marked(vms.heap.start, vms.heap.top, addr(fatal-object-marked!), vms)
  ;No meaningful return value
  return false

lostanza defn collect-garbage (vms:ptr<VMState>) -> ref<False> :
  ;Precondition: No objects should be marked.
  ensure-no-marks-in-collection-area!(vms)

  ;Four phases:
  ;1) Mark
  ;2) Construct break table
  ;3) Relocate references
  ;4) Compact

  ;Phase 1. Mark
  mark-reachable-objects(vms)
  scan-liveness-trackers(vms)

  ;Find the first unmarked object. If there is one, then this is where
  ;compaction begins.
  val compaction-start = skip-and-clear-marked(vms.heap.start, vms)
  if compaction-start < vms.heap.top :
    ;Phase 2. Construct break table
    create-break-table(compaction-start, vms)
    ;Phase 3. Relocate references
    relocate-references(vms)
    ;Phase 4. Compact
    compact(vms)

  ;Post condition: All marks should be cleared.
  ensure-no-marks-in-collection-area!(vms)

  ;No meaningful return value
  return false

;============================================================
;==================== LivenessTracker =======================
;============================================================

public deftype Unique <: Equalable

defmethod equal? (a:Unique, b:Unique) :
  ($prim identical? a b)

;LivenessTracker for determining whether objects are still live.
;- value: meant to hold either a reference to a Unique object
;  or false. It is stored as a long to prevent GC from automatically
;  traversing this field during the marking phase.
;- tail: holds the linked list of liveness trackers.
public lostanza deftype LivenessTracker :
  var value: long
  var tail: ptr<LivenessTracker>

;Global list of live LivenessTrackers.
;New liveness trackers are added to this list when they are created.
lostanza var LIVENESS-TRACKERS:ptr<LivenessTracker> = null

;Create a new LivenessTracker, wrapped around the given Unique object,
;and add it to the global LIVENESS-TRACKERS list.
public lostanza defn LivenessTracker (value:ref<Unique>) -> ref<LivenessTracker> :
  val tracker = new LivenessTracker{value as long, LIVENESS-TRACKERS}
  LIVENESS-TRACKERS = addr!([tracker])
  return tracker

;Retrieve the wrapped Unique object within a liveness tracker.
;Returns false if the object is no longer live.
public lostanza defn value (t:ref<LivenessTracker>) -> ref<False|Unique> :
  return t.value as ref<False|Unique>

lostanza val false-marker:long = tagof(False) << 3L + 2

;Scan through the global list LIVENESS-TRACKERS and update them.
;After this function finishes:
;1) All LIVENESS-TRACKERS will have their 'value' field appropriately updated.
;   The 'value' field will be set to false, if the object they are referencing is
;   no longer live.
;2) The LIVENESS-TRACKERS list will contain only LivenessTrackers that are still live,
;   that hold references to Unique objects that are still live.
lostanza defn scan-liveness-trackers (vms:ptr<VMState>) -> ref<False> :
  ;p is a pointer to the list being scanned.
  var p:ptr<ptr<LivenessTracker>> = addr(LIVENESS-TRACKERS)
  ;Scan until we reach the end of the list (represented using null pointer).
  ;TODO: In generational GC scan the list while [p] >= collection-area-start
  while [p] != null :
    ;Retrieve the next ptr<LivenessTracker> in the list.
    val tracker = [p]

    ;Compute the pointer to the start of the object by decrementing
    ;the size of the header word. This pointer is what is marked
    ;in the bitset.
    val tracker-obj = (tracker as ptr<?>) - sizeof(long)

    ;Test whether the tracker is marked (and therefore still live).
    if test-mark(tracker-obj, vms) == 0 :
      ;The tracker is no longer live, so unlink the tracker
      ;from the list.
      [p] = tracker.tail
    else :
      ;Set the value field on the tracker to false if it
      ;no longer refers to a live Unique object. We can assume that
      ;value currently holds a pointer into the heap otherwise it
      ;wouldn't be in the LIVENESS-TRACKERS list.
      val value-ptr = (tracker.value - 1) as ptr<?>
      if test-mark(value-ptr, vms) == 0 :
        ;The Unique is no longer live so replace the value with
        ;false-marker.
        tracker.value = false-marker
        ;Unlink current tracker from the list
        [p] = tracker.tail
      else :
        ;The unique is still live, so keep this tracker on the list.
        ;Go to the next element in the list.
        p = addr(tracker.tail)

  ;No meaningful return value
  return false

;Relocate the referenced objects in the global list of liveness trackers
;as part of compaction.
lostanza defn relocate-liveness-trackers (vms:ptr<VMState>) -> ref<False> :
  val compaction-start = vms.heap.compaction-start
  ;p is a pointer to the list being scanned.
  var p:ptr<ptr<LivenessTracker>> = addr(LIVENESS-TRACKERS)
  ;GC preserves the allocation order, so:
  ;  1) Tracker value is always below the tracker.
  ;  2) Later trackers in the list are below earlier trackers.
  while [p] > compaction-start :
    ;Retrieve the next ptr<LivenessTracker> in the list.
    val tracker = [p]
    ;Relocate the pointer to the tracker
    [p] = tracker + relocation-offset(tracker, vms)
    ;Relocate the tracker value
    relocate-reference(addr(tracker.value), vms)
    ;Go to the next element in the list.
    p = addr(tracker.tail)
  ;No meaningful return value
  return false

public lostanza defn max (x:long, y:long) -> long :
  if x < y : return y
  else : return x

public lostanza defn min (x:long, y:long) -> long :
  if x < y : return x
  else : return y

;============================================================
;===================== Debugging ============================
;============================================================

lostanza deftype ObjectLayout :
  tag: long
  var slots: long ...

lostanza defn tag (x:ptr<?>) -> long :
  return (x + 1) as long

lostanza defn untag (x:long) -> ptr<?> :
  val tagbits = x & 7L
  if tagbits != 1 : fatal("Not a heap-allocated object!")
  return (x - 1 + 8) as ptr<?>

lostanza defn dump-heap (vms:ptr<VMState>) -> int :
  return dump-heap(vms.heap.start, vms.heap.top, vms)

lostanza defn dump-heap (pstart:ptr<long>, pend:ptr<long>, vms:ptr<VMState>) -> int :
  val stackrefs = LSLongVector()
  call-c clib/printf("Heap:\n")
  var p:ptr<long> = pstart
  while p < pend :
    val tag = [p] as int
    if tag == tagof(Stack) :
      add(stackrefs, /tag(p))
    val class = vms.class-table[tag]
    if class.item-size == 0 :
      val obj = p as ptr<ObjectLayout>
      val size = class.size
      call-c clib/printf("  %p: [Object %d, size = %d]", /tag(p), tag, size)
      for (var i:long = 0, i < size, i = i + 8) :
        call-c clib/printf("  %lx", [p + 8 + i])
      call-c clib/printf("\n")
      ;Advance to next object
      p = p + object-size-on-heap(size)
    else :
      val class = class as ptr<ArrayRecord>
      val array = p as ptr<ObjectLayout>
      val len = array.slots[0]
      val base-size = class.base-size
      val item-size = class.item-size
      val size = base-size + item-size * len
      call-c clib/printf("  %p: [Array %d, length = %ld, base-size = %d, item-size = %d]",
                         /tag(p), tag, len, base-size, item-size)
      for (var i:long = 0, i < size, i = i + 8) :
        call-c clib/printf("  %lx", [p + 8 + i])
      call-c clib/printf("\n")
      ;Advance to next object
      p = p + object-size-on-heap(size)
  ;Dump stacks
  for (var i:int = 0, i < stackrefs.length, i = i + 1) :
    val s = stackrefs.items[i]
    dump-stack(s, vms)
  return 0

lostanza defn dump-stack (stackref:long, vms:ptr<VMState>) -> int :
  val stk:ptr<Stack> = untag(stackref)
  val f-end = stk.stack-pointer
  call-c clib/printf("Stack %p (last frame %p):\n", stackref, f-end)
  if stk.frames != null :
    labels :
      begin :
        goto loop(stk.frames)
      loop (f:ptr<StackFrame>) :
        if f <= f-end :
          ;Get frame properties
          val map-index = f.liveness-map
          val map = vms.stackmap-table[map-index]
          val live-slots = addr(map.roots)
          val num-slots = (map.size - 16) / 8
          ;Print properties
          val num-live = map.num-roots
          var slot-i:int = 0
          call-c clib/printf("  %p: [StackFrame %ld, num-slots = %d]\n", f, f.liveness-map, num-slots)
          for (var i:int = 0, i < num-slots, i = i + 1) :
            if slot-i < num-live and live-slots[slot-i] == i :
              call-c clib/printf("    %d: [%lx]\n", i, f.slots[i])
              slot-i = slot-i + 1
            else :
              call-c clib/printf("    %d: %lx\n", i, f.slots[i])

          if f != f-end :
            val f* = f + map.size
            if f* > f-end :
              call-c clib/printf("New stack %p is past end\n", f*)
              call-c clib/exit(-1)
            goto loop(f*)
  return 0


;============================================================
;====================== CONSTANTS ===========================
;============================================================

val COROUTINE-ACTIVE = 0
val COROUTINE-CLOSED = 1
val COROUTINE-SUSPENDED = 2
val COROUTINE-OPEN = 3

lostanza val INT-TAG-BITS:long = 0L
lostanza val REF-TAG-BITS:long = 1L
lostanza val MARKER-TAG-BITS:long = 2L
lostanza val BYTE-TAG-BITS:long = 3L
lostanza val CHAR-TAG-BITS:long = 4L
lostanza val FLOAT-TAG-BITS:long = 5L

lostanza val FALSE-TYPE:int = 0
lostanza val TRUE-TYPE:int = 1
lostanza val BYTE-TYPE:int = 2
lostanza val CHAR-TYPE:int = 3
lostanza val INT-TYPE:int = 4
lostanza val FLOAT-TYPE:int = 5

public lostanza val null:ptr<?> = 0L as ptr<?>

;============================================================
;======================= Bytes ==============================
;============================================================

public lostanza defn shift-left (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value << b.value}

public lostanza defn shift-right (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value >> b.value}

public lostanza defn bit-or (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value | b.value}

public lostanza defn bit-xor (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value & b.value}

public lostanza defn bit-not (a:ref<Byte>) -> ref<Byte> :
  return new Byte{(~ a.value)}

public lostanza defn plus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value + b.value}

public lostanza defn minus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value - b.value}

public lostanza defn times (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value * b.value}

public lostanza defn divide (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  ensure-divide-non-zero(b)
  return new Byte{a.value / b.value}

public lostanza defn modulo (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  ensure-divide-non-zero(b)
  return new Byte{a.value % b.value}

;============================================================
;====================== Integers ============================
;============================================================

public defn shift-left (a:Int, b:Int) -> Int :
  ($prim shl a b)

public defn shift-right (a:Int, b:Int) -> Int :
  ($prim shr a b)

public defn arithmetic-shift-right (a:Int, b:Int) -> Int :
  ($prim ashr a b)

public defn bit-or (a:Int, b:Int) -> Int :
  ($prim or a b)

public defn bit-and (a:Int, b:Int) -> Int :
  ($prim and a b)

public defn bit-xor (a:Int, b:Int) -> Int :
  ($prim xor a b)

public defn bit-not (a:Int) -> Int :
  ($prim not a)

public defn negate (a:Int) -> Int :
  ($prim neg a)

public defn abs (a:Int) -> Int :
  (- a) when a < 0 else a

public defn plus (a:Int, b:Int) -> Int :
  ($prim add a b)

public defn minus (a:Int, b:Int) -> Int :
  ($prim sub a b)

public defn times (a:Int, b:Int) -> Int :
  ($prim mul a b)

public defn divide (a:Int, b:Int) -> Int :
  ensure-divide-non-zero(b)
  ($prim div a b)

public defn modulo (a:Int, b:Int) -> Int :
  ensure-divide-non-zero(b)
  ($prim mod a b)

public lostanza defn bitcount (x0:long) -> int :
  var x:long = x0
  var count:int = 0
  while x :
    count = count + 1
    x = x & (x - 1)
  return count

public lostanza defn bitcount (x:ref<Int>) -> ref<Int> :
  return new Int{bitcount(x.value)}

public lostanza defn bitcount (x:ref<Long>) -> ref<Int> :
  return new Int{bitcount(x.value)}

;============================================================
;======================== Longs =============================
;============================================================

public lostanza defn shift-left (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value << b.value}

public lostanza defn shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value >> b.value}

public lostanza defn arithmetic-shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value >>> b.value}

public lostanza defn bit-or (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value | b.value}

public lostanza defn bit-xor (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value & b.value}

public lostanza defn bit-not (a:ref<Long>) -> ref<Long> :
  return new Long{(~ a.value)}

public lostanza defn negate (a:ref<Long>) -> ref<Long> :
  return new Long{(- a.value)}

public defn abs (a:Long) -> Long :
  (- a) when a < 0L else a

public lostanza defn plus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value + b.value}

public lostanza defn minus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value - b.value}

public lostanza defn times (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value * b.value}

public lostanza defn divide (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  ensure-divide-non-zero(b)
  return new Long{a.value / b.value}

public lostanza defn modulo (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  ensure-divide-non-zero(b)
  return new Long{a.value % b.value}

;============================================================
;======================= Floats =============================
;============================================================

public lostanza defn negate (a:ref<Float>) -> ref<Float> :
  return new Float{(- a.value)}

public defn abs (a:Float) -> Float :
  (- a) when a < 0.0f else a

public lostanza defn plus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value + b.value}

public lostanza defn minus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value - b.value}

public lostanza defn times (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value * b.value}

public lostanza defn divide (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value / b.value}

public lostanza defn nan? (x:ref<Float>) -> ref<True|False> :
  val v = x.value
  if v != v : return true
  else : return false

;============================================================
;======================= Doubles ============================
;============================================================

public lostanza defn negate (a:ref<Double>) -> ref<Double> :
  return new Double{(- a.value)}

public defn abs (a:Double) -> Double :
  (- a) when a < 0.0 else a

public lostanza defn plus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value + b.value}

public lostanza defn minus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value - b.value}

public lostanza defn times (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value * b.value}

public lostanza defn divide (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value / b.value}

public lostanza defn nan? (x:ref<Double>) -> ref<True|False> :
  val v = x.value
  if v != v : return true
  else : return false

;============================================================
;======================== Strings ===========================
;============================================================

public lostanza defn String (len:long) -> ref<String> :
  return new String{len + 1, 0}

public lostanza defn String (len:long, chars:ptr<byte>) -> ref<String> :
  return initialize(String(len), chars)

public lostanza defn String (len:long, chars:ref<ByteArray>) -> ref<String> :
  return initialize(String(len), addr!(chars.data))

public lostanza defn String (len:ref<Long>, buf:ref<ByteArray>) -> ref<String> :
  return String(len.value, buf)

public lostanza defn String (len:ref<Int>, buf:ref<ByteArray>) -> ref<String> :
  return String(len.value, buf)

public lostanza defn initialize (s:ref<String>, chars:ptr<byte>) -> ref<String> :
  val l = s.length - 1
  call-c clib/memcpy(addr!(s.chars), chars, l)
  s.chars[l] = 0Y
  return s

;============================================================
;======================= Lists ==============================
;============================================================

public lostanza defn List () -> ref<List> :
  return new NilList{}

public lostanza defn cons<?T> (x:ref<?T>, t:ref<List<?T>>) -> ref<List<T>> :
  return new FullList<T>{x, t}

public defmulti head<?T> (x:List<?T>) -> T
public defmulti tail<?T> (x:List<?T>) -> List<T>
public defmulti empty? (x:List) -> True|False

defmethod head (x:NilList) : fatal("Cannot retrieve head of empty list.")
defmethod tail (x:NilList) : fatal("Cannot retrieve tail of empty list.")
defmethod empty? (x:NilList) : true
lostanza defmethod head (x:ref<FullList>) -> ref<?> : return x.head
lostanza defmethod tail (x:ref<FullList>) -> ref<?> : return x.tail
defmethod empty? (x:FullList) : false

;============================================================
;======================= Booleans ===========================
;============================================================

public defn complement (a:True|False) -> True|False :
  if a : false
  else : true

;============================================================
;==================== Identity Function =====================
;============================================================

public defn identity<?T> (x:?T) -> T : x

;============================================================
;====================== Comparable ==========================
;============================================================

public deftype Comparable<T> :
  Char <: Comparable<Char>
  Byte <: Comparable<Byte>
  Int <: Comparable<Int>
  Long <: Comparable<Long>
  Float <: Comparable<Float>
  Double <: Comparable<Double>
  Tuple<T> <: Comparable<Tuple<T>>
  String <: Comparable<String>
  Symbol <: Comparable<Symbol>
  List<T> <: Comparable<List<T>>

public defmulti compare<?T> (a:Comparable<?T>, b:T) -> Int
public defmulti less?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti greater?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti less-eq?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti greater-eq?<?T> (a:Comparable<?T>, b:T) -> True|False

defmethod less?<?T> (a:Comparable<?T>, b:T) : compare(a, b) < 0
defmethod greater?<?T> (a:Comparable<?T>, b:T) : compare(a, b) > 0
defmethod less-eq?<?T> (a:Comparable<?T>, b:T) : compare(a, b) <= 0
defmethod greater-eq?<?T> (a:Comparable<?T>, b:T) : compare(a, b) >= 0

lostanza defmethod compare (a:ref<Char>, b:ref<Char>) -> ref<Int> :
  return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Byte>, b:ref<Byte>) -> ref<Int> :
  return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

defmethod compare (a:Int, b:Int) -> Int :
  if a < b : -1
  else if a > b : 1
  else : 0

defmethod less? (a:Int, b:Int) -> True|False :
  ($prim lt a b)

defmethod less-eq? (a:Int, b:Int) -> True|False :
  ($prim le a b)

defmethod greater? (a:Int, b:Int) -> True|False :
  ($prim gt a b)

defmethod greater-eq? (a:Int, b:Int) -> True|False :
  ($prim ge a b)

lostanza defmethod compare (a:ref<Long>, b:ref<Long>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Float>, b:ref<Float>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Double>, b:ref<Double>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Tuple<Comparable>>, b:ref<Tuple<Comparable>>) -> ref<Int> :
  val la = a.length
  val lb = b.length
  labels :
    begin :
      goto loop(0)
    loop (i:long) :
      if i < la and i < lb :
        val c = compare(a.items[i], b.items[i])
        if c.value : return c
        else : goto loop(i + 1)
      else :
        return compare(new Int{la as int}, new Int{lb as int})

lostanza defmethod compare (a:ref<String>, b:ref<String>) -> ref<Int> :
  val na = strlen(a)
  val nb = strlen(b)
  labels :
    begin :
      goto loop(0)
    loop (i:long) :
      if (i == na) and (i == nb) :
        return new Int{0}
      else if i == na :
        return new Int{-1}
      else if i == nb :
        return new Int{1}
      else :
        val ac = a.chars[i]
        val bc = b.chars[i]
        if ac < bc : return new Int{-1}
        else if ac > bc : return new Int{1}
        else : goto loop(i + 1)

defmethod compare (xs:List<Comparable>, ys:List<Comparable>) -> Int :
  defn* loop (xs:List<Comparable>, ys:List<Comparable>) :
    match(empty?(xs), empty?(ys)) :
      (ex:True, ey:True) : 0
      (ex:True, ey:False) : -1
      (ex:False, ey:True) : 1
      (ex:False, ey:False) :
        val c = compare(head(xs), head(ys))
        if c == 0 : loop(tail(xs), tail(ys))
        else : c
  loop(xs, ys)

defmethod compare (a:Symbol, b:Symbol) :
  defn rank (s:Symbol) :
    match(s) :
      (s:StringSymbol) : 0
      (s:GenSymbol) : 1
  match(a, b) :
    (a:StringSymbol, b:StringSymbol) :
      compare(name(a), name(b))
    (a:GenSymbol, b:GenSymbol) :
      val c = compare(name(a), name(b))
      if c == 0 : compare(id(a), id(b))
      else : c
    (a, b) :
      compare(rank(a), rank(b))

;============================================================
;======================== Equalable =========================
;============================================================

public deftype Equalable :
  Char <: Equalable
  Byte <: Equalable
  Int <: Equalable
  Long <: Equalable
  Float <: Equalable
  Double <: Equalable
  Tuple<T> <: Equalable
  String <: Equalable
  Symbol <: Equalable
  List<T> <: Equalable
  True <: Equalable
  False <: Equalable

public defmulti equal? (a:Equalable, b:Equalable) -> True|False
defmethod equal? (a:Equalable, b:Equalable) : false

public defn not-equal? (a:Equalable, b:Equalable) -> True|False :
  not equal?(a, b)

defmethod equal? (a:Char, b:Char) -> True|False :
  ($prim identical? a b)

defmethod equal? (a:Byte, b:Byte) -> True|False :
  ($prim identical? a b)

defmethod equal? (a:Int, b:Int) -> True|False :
  ($prim eq a b)

lostanza defmethod equal? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

lostanza defmethod equal? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

lostanza defmethod equal? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

defmethod equal? (a:True|False, b:True|False) -> True|False :
  ($prim identical? a b)

lostanza defmethod equal? (x:ref<Tuple>, y:ref<Tuple>) -> ref<True|False> :
  val n = x.length
  if n != y.length : return false
  for (var i:long = 0, i < n, i = i + 1) :
    if equal?(x.items[i], y.items[i]) == false :
      return false
  return true

lostanza defmethod equal? (a:ref<String>, b:ref<String>) -> ref<True|False> :
  val n = strlen(a)
  if n == strlen(b) :
    for (var i:long = 0, i < n, i = i + 1) :
      if a.chars[i] != b.chars[i] :
        return false
    return true
  else :
    return false

defmethod equal? (a:List, b:List) -> True|False :
  defn* loop (a:List, b:List) :
    match(empty?(a), empty?(b)) :
      (ea:True, eb:True) : true
      (ea:False, eb:False) :
        if head(a) == head(b) :
          loop(tail(a), tail(b))
      (ea, eb) : false
  loop(a, b)

defmethod equal? (a:Symbol, b:Symbol) -> True|False :
  ($prim identical? a b)

;============================================================
;==================== Compare Contents ======================
;============================================================

public deftype HasContents :
  Equalable <: HasContents
  KeyValue<K,V> <: HasContents
  Tuple<T> <: HasContents
  IndexedCollection<T> <: HasContents

public defmulti same-contents? (a:HasContents, b:HasContents) -> True|False

;By default, two objects do not have the same contents.
defmethod same-contents? (a, b) : false

;Two objects have the same contents if they are equal.
defmethod same-contents? (a:Equalable, b:Equalable) : a == b

;Two keyvalue pairs have the same contents if their keys are equal
;and their values contain the same contents.
defmethod same-contents? (a:KeyValue, b:KeyValue) :
  key(a) == key(b) and
  same-contents?(value(a), value(b))

;Two Tuples contain the same contents if they have the same length
;and their items respectively contain the same contents.
defmethod same-contents? (a:Tuple, b:Tuple) :
  length(a) == length(b) and all?(same-contents?, a, b)

;Two Lists contain the same contents if they have the same length
;and their items respectively contain the same contents.
defmethod same-contents? (a:List, b:List) :
  let loop (a:List = a, b:List = b) :
    match(empty?(a), empty?(b)) :
      (ae:True, be:True) : true
      (ae:True, be:False) : false
      (ae:False, be:True) : false
      (ae:False, be:False) : same-contents?(head(a), head(b)) and
                             loop(tail(a), tail(b))

;Two IndexedCollections contain the same contents if they have the same length
;and their items respectively contain the same contents.
defmethod same-contents? (a:IndexedCollection, b:IndexedCollection) :
  length(a) == length(b) and
  for i in 0 to length(a) all? :
    same-contents?(a[i], b[i])

;Two wrapped Maybe objects contain the same contents if their
;wrapped value contains the same contents.
defmethod same-contents? (a:One, b:One) :
  same-contents?(value!(a), value!(b))

;============================================================
;====================== Lengthable ==========================
;============================================================

public deftype Lengthable :
  String <: Lengthable
  Tuple<T> <: Lengthable
  List<T> <: Lengthable

public defmulti length (l:Lengthable) -> Int

lostanza defmethod length (x:ref<Tuple>) -> ref<Int> :
  return new Int{x.length as int}

lostanza defmethod length (s:ref<String>) -> ref<Int> :
  return new Int{s.length as int - 1}

defmethod length (x:List) :
  defn* loop (x:List, n:Int) :
    if empty?(x) : n
    else : loop(tail(x), n + 1)
  loop(x, 0)

;============================================================
;=================== Winders ================================
;============================================================
defstruct Winder :
  in: False|(() -> ?)
  out: False|(() -> ?)
  final: False|(() -> ?)

var WINDER-STACK:List<Winder>
var NUM-WINDERS:Int

defn initialize-winders () :
  WINDER-STACK = List()
  NUM-WINDERS = 0

defn pop-winder () :
  val w = head(WINDER-STACK)
  WINDER-STACK = tail(WINDER-STACK)
  NUM-WINDERS = NUM-WINDERS - 1
  w

defn push-winder (w:Winder) :
  WINDER-STACK = cons(w, WINDER-STACK)
  NUM-WINDERS = NUM-WINDERS + 1

defn pop-winders (n:Int) :
  defn pop (n:Int) :
    if n > 0 : cons(pop-winder(), pop(n - 1))
    else : List()
  pop(NUM-WINDERS - n)

defn push-winders (ws:List<Winder>) :
  if not empty?(ws) :
    push-winders(tail(ws))
    push-winder(head(ws))

defn total-winders (c:False|RawCoroutine) -> Int :
  match(c) :
    (c:False) : 0
    (c:RawCoroutine) : total-winders(parent(c)) + num-winders(c)

defn wind-in (ws:List<Winder>) :
  if not empty?(ws) :
    wind-in(tail(ws))
    call?(in(head(ws)))

defn wind-out (ws:List<Winder>, call-out:True|False, call-final:True|False) :
  if not empty?(ws) :
    call?(out(head(ws))) when call-out
    call?(final(head(ws))) when call-final
    wind-out(tail(ws), call-out, call-final)

defn* call? (f: False|(() -> ?)) :
  match(f) :
    (f:() -> ?) : f()
    (f:False) : false

lostanza defn inc-winders (c:ref<RawCoroutine>, n:ref<Int>) -> ref<False> :
  c.num-winders = c.num-winders + n.value
  return false

lostanza defn num-winders (c:ref<RawCoroutine>) -> ref<Int> :
  return new Int{c.num-winders}

public defn dynamic-wind<?T> (in:False|(() -> ?),
                              body:() -> ?T,
                              out:False|(() -> ?)) -> T :
  call?(in)
  push-winder(Winder(in, out, false))
  inc-winders(current-coroutine, 1)
  val result = body()
  pop-winder()
  inc-winders(current-coroutine, -1)
  call?(out)
  result

;============================================================
;====================== Coroutines ==========================
;============================================================

public defmulti active? (c:Coroutine) -> True|False
public defmulti open? (c:Coroutine) -> True|False
public defmulti resume<?I,?O> (c:Coroutine<?I,?O>, x:I) -> O
public defmulti suspend<?I,?O> (c:Coroutine<?I,?O>, x:O) -> I
public defmulti break<?O> (c:Coroutine<?,?O>, x:O) -> Void
public defmulti close (c:Coroutine) -> False

;                  Wrapped Coroutines
;                  ==================

#if-defined(OPTIMIZE) :

  public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
    RawCoroutine(enter)

#else :

  deftype WrappedCoroutine<I,O> <: Coroutine<I,O>
  defmulti raw (c:WrappedCoroutine) -> RawCoroutine

  public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
    var rc
    val c = new WrappedCoroutine<I,O> :
      defmethod active? (this) : active?(rc)
      defmethod open? (this) : open?(rc)
      defmethod resume (this, x:I) : resume(rc, x)
      defmethod suspend (this, x:O) : suspend(rc, x)
      defmethod break (this, x:O) : break(rc, x)
      defmethod close (this) : close(rc)
      defmethod raw (this) : rc
    rc = RawCoroutine $ fn (rc, x0) :
      enter(c, x0)
    c

  defmethod print (o:OutputStream, c:WrappedCoroutine) :
    print(o, raw(c))

protected lostanza deftype RawCoroutine <: Coroutine & Unique :
  id: long
  var stack: ref<Stack>
  var parent: ref<False|RawCoroutine>
  var status: ref<Int>
  var num-winders: int
  var crsp: long
  saved-winders: ref<SavedWinders>

lostanza deftype SavedWinders :
  var winders: ref<List<Winder>>

lostanza deftype WinderFinalizer <: Finalizer :
  saved-winders: ref<SavedWinders>

lostanza deftype CoroutineParams :
  parent-stack: ref<Stack>
  coroutine: ref<RawCoroutine>
  enter: ref<((RawCoroutine, ?) -> ?)>

protected lostanza var current-coroutine:ref<RawCoroutine>
lostanza var COROUTINE-COUNTER:long

lostanza defn initialize-coroutines () -> ref<False> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val current-stack = vms.current-stack as ref<Stack>
  val crsp = call-prim crsp() as long
  current-coroutine = new RawCoroutine{0L, current-stack, false, COROUTINE-ACTIVE, 0, crsp, new SavedWinders{List()}}
  COROUTINE-COUNTER = 1L
  return false

public lostanza defn RawCoroutine (enter:ref<((RawCoroutine, ?) -> ?)>) -> ref<RawCoroutine> :
  val stk = allocate-stack()
  stk.pc = addr(setup-coroutine) as long
  val vms:ptr<VMState> = call-prim flush-vm()
  val current-stack = vms.current-stack as ref<Stack>
  return call-prim enter-stack(stk, current-stack, enter)

lostanza defn parent (c:ref<RawCoroutine>) -> ref<False|RawCoroutine> :
  return c.parent
lostanza defn status (c:ref<RawCoroutine>) -> ref<Int> :
  return c.status
lostanza defn id (c:ref<RawCoroutine>) -> ref<Int> :
  return new Int{c.id as int}

lostanza defmethod active? (c:ref<RawCoroutine>) -> ref<True|False> :
  if c.status == COROUTINE-ACTIVE : return true
  else : return false

lostanza defmethod open? (c:ref<RawCoroutine>) -> ref<True|False> :
  if c.status == COROUTINE-OPEN : return true
  else : return false

lostanza defmethod run (f:ref<WinderFinalizer>) -> ref<False> :
  val winders = f.saved-winders.winders
  if empty?(winders) == false :
    f.saved-winders.winders = List()
    wind-out(winders, false, true)
  return false

lostanza defn* setup-coroutine (stack:ref<Stack>, parent-stack:ref<Stack>, enter:ref<((RawCoroutine, ?) -> ?)>) -> ref<?> :
  val crsp = call-prim crsp() as long
  val co = new RawCoroutine{COROUTINE-COUNTER, stack, false, COROUTINE-OPEN, 0, crsp, new SavedWinders{List()}}
  add-finalizer(new WinderFinalizer{co.saved-winders}, co)
  ;call-c clib/printf("Created coroutine %ld #%d (stack frames = %p)\n", co, co.id, co.stack.frames)
  COROUTINE-COUNTER = COROUTINE-COUNTER + 1L
  val x0 = call-prim yield(parent-stack, co)
  return break(co, [enter](co, x0))

lostanza defmethod resume (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
  ;call-c clib/printf("[from coroutine %d] resuming coroutine %d (stackframes = %ld)\n", current-coroutine.id, c.id, c.stack.frames)
  ;Ensure coroutine is re-entrant
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot resume coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-ACTIVE :
    return fatal("Cannot resume coroutine. Coroutine is already active.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot resume coroutine. Coroutine's parent is suspended.")

  ;Adjust state
  attach-coroutine(c)

  ;Begin execution
  val result = call-prim yield(current-coroutine.stack, x)

  ;If the coroutine is closed (e.g. through a 'break' command) then free it immediately.
  if c.status == COROUTINE-CLOSED :
    free-coroutine(c)

  ;Return the result yielded by the coroutine.
  return result

lostanza defmethod* suspend (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
  ;call-c clib/printf("[from coroutine %d] suspending coroutine %d (%ld)\n", current-coroutine.id, c.id, c)

  ;Ensure coroutine is active
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot suspend coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-OPEN :
    return fatal("Cannot suspend coroutine. Coroutine is already suspended.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot suspend coroutine. Coroutine is already suspended.")

  ;Ensure coroutine was launched within same c context
  ensure-target-in-same-c-ctxt!(c)

  ;Set target winder environment and wind out
  c.saved-winders.winders = pop-winders(total-winders(c.parent))
  wind-out(c.saved-winders.winders, true, false)

  ;Detach coroutine
  detach-coroutine(c, COROUTINE-OPEN)

  ;Return to resume
  val result = call-prim yield(current-coroutine.stack, x)

  ;Wind in and restore original winder environment
  val winders = c.saved-winders.winders
  c.saved-winders.winders = List()
  wind-in(winders)
  push-winders(winders)

  ;Return execution
  return result

lostanza defmethod close (c:ref<RawCoroutine>) -> ref<False> :
  ;call-c clib/printf("[from coroutine %d] closing coroutine %d\n", current-coroutine.id, c.id)
  ;Ensure coroutine is re-entrant
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot close coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-ACTIVE :
    return fatal("Cannot close coroutine. Coroutine is active.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot close coroutine. Coroutine's parent is suspended.")

  ;Execute any final winders if necessary
  val winders = c.saved-winders.winders
  if empty?(winders) == false :
    c.saved-winders.winders = List()
    wind-out(winders, false, true)

  free-coroutine(c)
  return false

lostanza defmethod break (c:ref<RawCoroutine>, x:ref<?>) -> ref<Void> :
  ;call-c clib/printf("[from coroutine %d] breaking coroutine %d\n", current-coroutine.id, c.id)

  ;Ensure coroutine is active
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot break from coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-OPEN :
    return fatal("Cannot break from coroutine. Coroutine is already suspended.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot break from coroutine. Coroutine is already suspended.")

  ;Ensure coroutine was launched within same c context
  ensure-target-in-same-c-ctxt!(c)

  ;Set target winder environment and wind out
  val winders = pop-winders(total-winders(c.parent))
  wind-out(winders, true, true)

  ;Adjust state
  detach-coroutine(c, COROUTINE-CLOSED)

  ;Begin execution
  return call-prim yield(current-coroutine.stack, x)

lostanza defn ensure-target-in-same-c-ctxt! (c:ref<RawCoroutine>) -> int :
  val crsp = call-prim crsp() as long
  if c.crsp != crsp :
    fatal!("Cannot suspend coroutine. Coroutine was launched from a different C context. All 'extern defn' callbacks must return properly.")
  return 0

lostanza defn free-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(c)
    loop (c:ref<RawCoroutine>) :
      val parent = c.parent
      c.parent = false
      c.status = COROUTINE-CLOSED
      free(c.stack)
      match(parent) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : return 0

lostanza defn attach-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(c)
    loop (c:ref<RawCoroutine>) :
      val p = c.parent
      c.parent = current-coroutine
      c.status = COROUTINE-ACTIVE
      c.crsp = call-prim crsp() as long
      current-coroutine = c
      match(p) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : return 0

;Implements the semantics of suspending with 'c' as the argument coroutine.
;This function follows the parent pointer of the current coroutine until it reaches
;parent of 'c'. The current coroutine will be set to c.parent after this function finishes.
;The status of c will be set to "detached-status" at the end. It should be either
;COROUTINE-OPEN or COROUTINE-CLOSED, depending upon whether we intend to resume the
;coroutine.
lostanza defn detach-coroutine (c:ref<RawCoroutine>, detached-status:ref<Int>) -> int :
  labels :
    begin :
      goto loop(false)
    loop (tail:ref<RawCoroutine|False>) :
      val cc = current-coroutine
      val ccp = current-coroutine.parent as ref<RawCoroutine>
      cc.parent = tail
      current-coroutine = ccp
      if cc == c :
        cc.status = detached-status
        return 0
      else :
        cc.status = COROUTINE-SUSPENDED
        goto loop(cc)

;============================================================
;======================= Finalizers =========================
;============================================================

;LivenessHandler/run returns true if the LivenessHandler ran,
;and thus should be removed from the LivenessHandler list.
deftype LivenessHandler
defmulti run (f:LivenessHandler) -> True|False

;Global lists
var LIVENESS-HANDLERS:Vector<LivenessHandler>
var QUEUED-LIVENESS-HANDLERS:Vector<LivenessHandler>

;Initialize lists of handlers
defn initialize-liveness-handlers () :
  LIVENESS-HANDLERS = Vector<LivenessHandler>()
  QUEUED-LIVENESS-HANDLERS = Vector<LivenessHandler>()
  add-gc-notifier $ fn () :
    add-all(LIVENESS-HANDLERS, QUEUED-LIVENESS-HANDLERS)
    clear(QUEUED-LIVENESS-HANDLERS)
    remove-when(run, LIVENESS-HANDLERS)

public deftype Finalizer
public defmulti run (f:Finalizer) -> ?

public defn add-finalizer (f:Finalizer, v:Unique) :
  val tracker = LivenessTracker(v)
  val liveness-handler = new LivenessHandler :
    defmethod run (this) :
      if value(tracker) is False :
        run(f)
        true
  add(QUEUED-LIVENESS-HANDLERS, liveness-handler)

public defn add-finalizer (f:() -> ?, v:Unique) :
  val tracker = LivenessTracker(v)
  val liveness-handler = new LivenessHandler :
    defmethod run (this) :
      if value(tracker) is False :
        f()
        true
  add(QUEUED-LIVENESS-HANDLERS, liveness-handler)

;============================================================
;================== Runtime Configuration ===================
;============================================================

public lostanza defn current-heap-size () -> ref<Long> :
  val vms:ptr<VMState> = call-prim flush-vm()
  return new Long{vms.heap.limit - vms.heap.top}

public lostanza defn current-max-heap-size () -> ref<Long> :
  return new Long{MAXIMUM-HEAP-SIZE}

defn ensure-valid-max-heap-size (sz:Long) :
  val cur-sz = current-heap-size()
  if sz < cur-sz :
    fatal("Cannot set heap size to %_ bytes which is smaller than the current heap size (%_ bytes)." % [
      sz, cur-sz])

public lostanza defn set-max-heap-size (sz:ref<Long>) -> ref<False> :
  ensure-valid-max-heap-size(sz)
  MAXIMUM-HEAP-SIZE = round-up-to-whole-pages(sz.value)
  return false

;============================================================
;=================== Generic Printing =======================
;============================================================

lostanza defn object-type-id (x:ref<?>) -> int :
  val ref = x as long
  val tagbits = ref & 0x7L
  if tagbits == INT-TAG-BITS : return INT-TYPE
  else if tagbits == BYTE-TAG-BITS : return BYTE-TYPE
  else if tagbits == CHAR-TAG-BITS : return CHAR-TYPE
  else if tagbits == FLOAT-TAG-BITS : return FLOAT-TYPE
  else if tagbits == MARKER-TAG-BITS :
    return (ref >> 3L) as int
  else if tagbits == REF-TAG-BITS :
    val p = (ref - REF-TAG-BITS) as ptr<long>
    return [p] as int
  else :
    fatal("Illegal tag bits\n")
    return 0

public lostanza defn object-type (x:ref<?>) -> ref<String> :
  val chars = call-prim class-name(object-type-id(x))
  return String(chars)

;============================================================
;=================== Initialize Constants ===================
;============================================================
initialize-constants()

;============================================================
;=================== Compound Constants =====================
;============================================================

lostanza deftype Sentinel
lostanza val sentinel:ref<Sentinel> = new Sentinel{}

protected deftype Uninitialized
protected val uninitialized = new Uninitialized

#if-defined(PLATFORM-WINDOWS) :
  lostanza val LS-NL:ptr<?> = "\r\n"
  val NL = "\r\n"
#else :
  lostanza val LS-NL:ptr<?> = "\n"
  val NL = "\n"

;============================================================
;=================== Initialize Remaining ===================
;============================================================

initialize-error-handler()
initialize-command-launcher()
initialize-winders()
initialize-coroutines()
initialize-gc-notifiers()
initialize-liveness-handlers()
initialize-symbol-table()

;================================================================================
;========================== End of Boot Sequence ================================
;================================================================================

;============================================================
;============= ExternTable and Callback Index Table =========
;============================================================

public lostanza defn extern-address (index:int) -> long :
  val vms:ptr<VMState> = call-prim flush-vm()
  val table = vms.extern-table
  val entry = table.entries[index]
  return entry.address

public lostanza defn extern-address (index:ref<Int>) -> ref<Long> :
  return new Long{extern-address(index.value)}

public lostanza defn extern-id-table () -> ref<HashTable<Symbol,Int>> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val table = vms.extern-table
  val n = table.length
  val return-table = HashTable<Symbol,Int>()
  for (var i:long = 0, i < n, i = i + 1) :
    val entry = table.entries[i]
    val name = to-symbol(String(entry.name))
    set(return-table, name, new Int{i as int})
  return return-table

public lostanza defn callback-index-table () -> ref<HashTable<Symbol,Int>> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val table = vms.callback-index-table
  val n = table.length
  val return-table = HashTable<Symbol,Int>()
  for (var i:long = 0, i < n, i = i + 1) :
    val entry = table.entries[i]
    val name = to-symbol(String(entry.name))
    set(return-table, name, new Int{entry.index as int})
  return return-table

;============================================================
;===================== Utilities ============================
;============================================================

protected lostanza defn linux-error-msg () -> ref<String> :
  val s = call-c clib/strerror(call-c clib/get_errno())
  return String(s)

#if-defined(PLATFORM-WINDOWS):
  extern get_windows_api_error: () -> ptr<byte>

  protected lostanza defn windows-error-msg () -> ref<String> :
    return String(call-c get_windows_api_error())

protected lostanza defn platform-error-msg () -> ref<String> :
  #if-defined(PLATFORM-WINDOWS):
    return windows-error-msg()
  #else:
    return linux-error-msg()

;============================================================
;====================== ToString ============================
;============================================================

public defmulti to-string (x) -> String

;                Default Implementation
;                ======================

defmethod to-string (x) -> String :
   val s = StringBuffer()
   print(s, x)
   to-string(s)

defmethod to-string (x:String) : x
defmethod to-string (x:True) : "true"
defmethod to-string (x:False) : "false"

;============================================================
;====================== Error Preconditions =================
;============================================================

defn ensure-divide-non-zero (i:Byte) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0Y)
defn ensure-divide-non-zero (i:Int) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0)
defn ensure-divide-non-zero (i:Long) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0L)

protected defn ensure-index-in-bounds (xs:Lengthable, i:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if i < 0 or i >= length(xs) :
      fatal("Index (%_) out of bounds." % [i])

protected defn ensure-length-in-bounds (xs:Lengthable, i:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if i < 0 or i > length(xs) :
      fatal("Index (%_) out of bounds." % [i])

defn ensure-start-before-end (s:Int, e:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if e < s :
      fatal("Given end index (%_) is smaller than start index (%_)." % [e, s])

protected defn ensure-non-negative (quantity:String, n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if n < 0 :
      fatal("Given %_ (%_) is negative." % [quantity, n])

protected defn ensure-positive (quantity:String, n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if n <= 0 :
      fatal("Given %_ (%_) is not positive." % [quantity, n])

protected defn ensure-non-negative-length (n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    ensure-non-negative("length", n)

protected defn ensure-index-range (xs:Lengthable, r:Range) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if step(r) != 1 :
      fatal("Given index range (%_) does not have a step of 1." % [r])
    val s = start(r)
    match(end(r), inclusive?(r)) :
      (e:Int, inc?:True) :
        ensure-index-in-bounds(xs, s)
        ensure-index-in-bounds(xs, e)
        ensure-start-before-end(s, e)
      (e:Int, inc?:False) :
        ensure-length-in-bounds(xs, s)
        ensure-length-in-bounds(xs, e)
        ensure-start-before-end(s, e)
      (e:False, inc?) :
        ensure-length-in-bounds(xs, s)

protected defn range-bound (s:Lengthable, r:Range) -> [Int, Int] :
  match(end(r), inclusive?(r)) :
    (e:Int, i:True) : [start(r), e + 1]
    (e:Int, i:False) : [start(r), e]
    (e:False, i) : [start(r), length(s)]

;============================================================
;===================== Hashable =============================
;============================================================

public deftype Hashable :
  Char <: Hashable
  Byte <: Hashable
  Int <: Hashable
  Long <: Hashable
  Float <: Hashable
  Double <: Hashable
  Tuple<T> <: Hashable
  List<T> <: Hashable
  String <: Hashable
  Symbol <: Hashable
  True <: Hashable
  False <: Hashable

public defmulti hash (h:Hashable) -> Int

lostanza defmethod hash (a:ref<Char>) -> ref<Int> :
  return new Int{a.value}

lostanza defmethod hash (a:ref<Byte>) -> ref<Int> :
  return new Int{a.value}

defmethod hash (a:Int) -> Int :
  a

lostanza defmethod hash (a:ref<Long>) -> ref<Int> :
  val v = a.value
  return new Int{(v ^ (v >> 32)) as int}

defmethod hash (a:Float) -> Int :
  bits(a)

lostanza defmethod hash (a:ref<Double>) -> ref<Int> :
  val v = a.value
  val bits = ($ls-prim bits v)
  return new Int{(bits ^ (bits >> 32)) as int}

defmethod hash (xs:Tuple<Hashable>) :
  var code:Int = 0x9e3779b9
  for x in xs do :
    code = code ^ (code << 11 + code >> 2 + 0x9e3779b9 + hash(x))
  code

defmethod hash (xs:List<Hashable>) -> Int :
  var code:Int = 0x9e3779b9
  for x in xs do :
    code = code ^ (code << 11 + code >> 2 + 0x9e3779b9 + hash(x))
  code

defmethod hash (a:True) : 1
defmethod hash (a:False) : 0

public lostanza defmethod hash (s:ref<String>) -> ref<Int> :
  if s.hash == 0 :
    val n = strlen(s)
    var h:int = 0
    for (var i:long = 0, i < n, i = i + 1) :
      h = (31 * h) + s.chars[i]
    if h == 0 : s.hash = 1
    else : s.hash = h
  return new Int{s.hash}

lostanza defmethod hash (s:ref<StringSymbol>) -> ref<Int> :
  return hash(s.name)

lostanza defmethod hash (s:ref<GenSymbol>) -> ref<Int> :
  return id(s)

;============================================================
;======================= Symbols ============================
;============================================================

public defmulti name (a:Symbol) -> String
public defmulti qualified? (a:Symbol) -> True|False
public defmulti qualifier (a:Symbol) -> [False|Symbol, Symbol]

;                   StringSymbol Functions
;                   ======================
lostanza defn StringSymbol (name:ref<String>) -> ref<StringSymbol> :
  return new StringSymbol{name}

lostanza defmethod name (s:ref<StringSymbol>) -> ref<String> :
  return s.name

defmethod qualified? (s:StringSymbol) :
   contains?(name(s), '/')

defmethod qualifier (s:StringSymbol) :
   match(last-index-of-char(name(s), '/')) :
      (i:Int) :
         val part1 = intern-symbol(name(s)[0 to i])
         val part2 = intern-symbol(name(s)[(i + 1) to false])
         [part1, part2]
      (i:False) :
         [false, s]

defmethod to-string (s:StringSymbol) :
   name(s)

;                  GenSymbol Functions
;                  ===================
public defmulti id (s:GenSymbol) -> Int

defn GenSymbol (name:String) :
   defn make-sym (name:String) :
      val id = genid()
      new GenSymbol :
         defmethod id (this) : id
         defmethod name (this) : name
         defmethod qualified? (this) : false
         defmethod qualifier (this) : [false, this]

   match(last-index-of-char(name, '/')) :
      (i:Int) :
         val id = genid()
         val qualifier = intern-symbol(name[0 to i])
         val unqualified-sym = make-sym(name[(i + 1) to false])
         new GenSymbol :
            defmethod id (this) : id
            defmethod name (this) : name
            defmethod qualified? (this) : true
            defmethod qualifier (this) : [qualifier, unqualified-sym]
      (i:False) :
         make-sym(name)

val ID-COUNTER = to-seq(0 to false)

public defn gensym (x) :
   match(x) :
      (x:Symbol) : gensym(name(x))
      (s:String) : GenSymbol(s)
      (x) : gensym(to-string(x))

public defn gensym () :
   gensym("$gen")

public defn genid () :
   next(ID-COUNTER)

;                    General Functions
;                    =================

public defn prefix? (a:Symbol, p:String) -> True|False :
   prefix?(name(a), p)

;                    Symbol Interning
;                    ================

var INTERNED-SYMBOLS : HashTable<String,Symbol>

lostanza defn initialize-symbol-table () -> ref<False> :
  ;Read number of consts
  val vms:ptr<VMState> = call-prim flush-vm()
  val cdata = vms.const-mem as ptr<int>
  val n-consts = [cdata]

  ;Get pointer to constant table
  val consts = vms.const-table as ptr<ref<?>>

  ;Initialize symbol table
  INTERNED-SYMBOLS = HashTable-init<String,Symbol>(fn(StringSymbol))
  for (var i:int = 0, i < n-consts, i = i + 1) :
    match(consts[i]) :
      (s:ref<Symbol>) : set(INTERNED-SYMBOLS, name(s), s)
      (s) : ()

  ;Done initialization
  initialized-symbol-table? = 1L
  return false

defn intern-symbol (name:String) :
   INTERNED-SYMBOLS[name]

public defn to-symbol (x) :
   match(x) :
      (x:Symbol) : x
      (x:String) : intern-symbol(x)
      (x) : to-symbol(to-string(x))

;============================================================
;===================== OutputStream =========================
;============================================================

;                   General Interface
;                   =================
public deftype OutputStream
public defmulti print (o:OutputStream, x) -> False
public defmulti print-all (o:OutputStream, xs:Seqable) -> False
public defmulti put (o:OutputStream, x) -> False

;                Default Implementations
;                =======================

lostanza val CONVERSION-BUFFER: ptr<byte> = call-c clib/malloc(64)

lostanza defn print-conversion-buffer-float (o:ref<OutputStream>, n:int) -> ref<False> :
  labels :
    begin :
      goto loop(0)
    loop (i:int) :
      if i < n :
        val c = CONVERSION-BUFFER[i]
        if c == '.' : goto rest(i)
        else if c == 'e' : goto add-dot(i)
        else :
          print(o, new Char{c})
          goto loop(i + 1)
      else : goto add-dot(i)
    add-dot (i:int) :
      print(o, new Char{'.'})
      print(o, new Char{'0'})
      goto rest(i)
    rest (i:int) :
      if i < n :
        print(o, new Char{CONVERSION-BUFFER[i]})
        goto rest(i + 1)
  return false

lostanza defn print-conversion-buffer-float (o:ptr<?>, n:int) -> ref<False> :
  labels :
    begin :
      goto loop(0)
    loop (i:int) :
      if i < n :
        val c = CONVERSION-BUFFER[i]
        if c == '.' : goto rest(i)
        else if c == 'e' : goto add-dot(i)
        else :
          call-c clib/fputc(c, o)
          goto loop(i + 1)
      else : goto add-dot(i)
    add-dot (i:int) :
      call-c clib/fputc('.', o)
      call-c clib/fputc('0', o)
      goto rest(i)
    rest (i:int) :
      if i < n :
        call-c clib/fputc(CONVERSION-BUFFER[i], o)
        goto rest(i + 1)
  return false

lostanza defn print-conversion-buffer (o:ref<OutputStream>, n:int) -> ref<False> :
   for (var i:int = 0, i < n, i = i + 1) :
      print(o, new Char{CONVERSION-BUFFER[i]})
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Byte>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value as int)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Int>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Long>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%lld", x.value)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Float>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.6g", x.value as double)
   print-conversion-buffer-float(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Double>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.15g", x.value)
   print-conversion-buffer-float(o, n)
   return false

defmethod print (o:OutputStream, x:True) :
   print(o, "true")

defmethod print (o:OutputStream, x:False) :
   print(o, "false")

defmethod print (o:OutputStream, x:String) :
   print-all(o, x)

lostanza defn stackframes (c:ref<RawCoroutine>) -> ref<Long> :
  return new Long{c.stack.frames as long}

defmethod print (o:OutputStream, c:RawCoroutine) :
  val s = switch {status(c) == _} :
    COROUTINE-ACTIVE : "ACTIVE"
    COROUTINE-CLOSED : "CLOSED"
    COROUTINE-SUSPENDED : "SUSPENDED"
    COROUTINE-OPEN : "OPEN"
  print(o, "<Coroutine #%_ : %_>" % [id(c), s])

defmethod print (o:OutputStream, t:Tuple) -> False :
   print(o, "[%@]" % [t])

defmethod print (o:OutputStream, xs:List) -> False :
   print(o, "(%@)" % [xs])

defmethod print (o:OutputStream, s:StringSymbol) :
   print(o, name(s))

defmethod print (o:OutputStream, s:GenSymbol) :
   print(o, name(s))
   print(o, id(s))

defmethod print (o:OutputStream, x) :
  print(o, "[%_ object]" % [object-type(x)])

defmethod print-all (o:OutputStream, xs:Seqable) :
   do(print{o, _}, xs)

;                 Convenience Functions
;                 =====================

public defn println (o:OutputStream, x) :
  print(o, x)
  print(o, NL)

public defn lnprint (o:OutputStream, x) :
  print(o, NL)
  print(o, x)

public defn println-all (o:OutputStream, xs:Seqable) :
   print-all(o, xs)
   print(o, NL)

;============================================================
;==================== Printing of Types =====================
;============================================================

defmethod print (o:OutputStream, t:Type) :
  defn loop (t:String|Type) :
    match(t) :
      (t:String) : print(o, t)
      (t:Type) : do(loop, parts(t))
  do(loop, parts(t))

lostanza defn parts (t:ref<Type>) -> ref<Tuple<String|Type>> :
  val code = t.code as ptr<(ref<Type> -> ref<Tuple>)>
  return [code](t)

;============================================================
;=================== FileOutputStream =======================
;============================================================

public lostanza deftype FileOutputStream <: OutputStream :
  file: ptr<?>
  closable?: long

public lostanza defn FileOutputStream (filename:ref<String>, append?:ref<True|False>) -> ref<FileOutputStream> :
   var file : ptr<?>
   if append? == true : file = call-c clib/fopen(addr!(filename.chars), "ab")
   else : file = call-c clib/fopen(addr!(filename.chars), "wb")
   if file == null : throw(FileOpenException(filename, linux-error-msg()))
   return new FileOutputStream{file, 1}

public defn FileOutputStream (filename:String) :
   FileOutputStream(filename, false)

public lostanza defn close (o:ref<FileOutputStream>) -> ref<False> :
   if o.closable? :
      val err = call-c clib/fclose(o.file)
      if err != 0 : throw(FileCloseException(linux-error-msg()))
   else : fatal("System OutputStream is not closable.")
   return false

public lostanza defn flush (o:ref<FileOutputStream>) -> ref<False> :
  val err = call-c clib/fflush(o.file)
  if err != 0 : throw(FileFlushException(linux-error-msg()))
  return false

lostanza defmethod put (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod put (o:ref<FileOutputStream>, x:ref<Char>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

defmethod put (o:OutputStream, c:Char) -> False :
   put(o, to-byte(c))

defmethod put (o:OutputStream, i:Int) -> False :
   put(o, to-byte(i))
   put(o, to-byte(i >> 8))
   put(o, to-byte(i >> 16))
   put(o, to-byte(i >> 24))

defmethod put (o:OutputStream, i:Long) -> False :
   put(o, to-byte(i))
   put(o, to-byte(i >> 8L))
   put(o, to-byte(i >> 16L))
   put(o, to-byte(i >> 24L))
   put(o, to-byte(i >> 32L))
   put(o, to-byte(i >> 40L))
   put(o, to-byte(i >> 48L))
   put(o, to-byte(i >> 56L))

defmethod put (o:OutputStream, i:Float) -> False :
   put(o, bits(i))

defmethod put (o:OutputStream, i:Double) -> False :
   put(o, bits(i))

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<String>) -> ref<False> :
   val r = call-c clib/fputs(addr!(x.chars), o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value as int)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Char>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Int>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Long>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%lld", x.value)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Float>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.6g", x.value as double)
   print-conversion-buffer-float(o.file, n)
   if call-c clib/ferror(o.file) != 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Double>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.15g", x.value)
   print-conversion-buffer-float(o.file, n)
   if call-c clib/ferror(o.file) != 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<True>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "true")
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<False>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "false")
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

public defn with-output-file<?T> (file:FileOutputStream, f: () -> ?T) -> T :
   try : with-output-stream(file, f)
   finally : close(file)

public defn spit (filename:String, x) -> False :
  spit(filename, x, false)

public defn spit (filename:String, x, append?:True|False) -> False :
   val o = FileOutputStream(filename, append?)
   try : print(o, x)
   finally : close(o)

;============================================================
;================ System Output Streams =====================
;============================================================

;                 System Output Streams
;                 =====================

public lostanza val STANDARD-OUTPUT-STREAM : ref<OutputStream> =
   new FileOutputStream{stdout, 0}

public lostanza val STANDARD-ERROR-STREAM : ref<OutputStream> =
   new FileOutputStream{stderr, 0}

public lostanza val STANDARD-INPUT-STREAM : ref<InputStream> =
   new FileInputStream{stdin, 0}

;                 Current Output Stream
;                 =====================

var CURRENT-OUTPUT-STREAM : OutputStream = STANDARD-OUTPUT-STREAM

public defn with-output-stream<?T> (o:OutputStream, f: () -> ?T) -> T :
  let-var CURRENT-OUTPUT-STREAM = o :
    f()

public defn current-output-stream () :
  CURRENT-OUTPUT-STREAM

public defn set-current-output-stream (o:OutputStream) :
  CURRENT-OUTPUT-STREAM = o

;                 Current Error Stream
;                 ====================

var CURRENT-ERROR-STREAM : OutputStream = STANDARD-ERROR-STREAM

public defn with-error-stream<?T> (o:OutputStream, body: () -> ?T) -> T :
  val oldv = CURRENT-ERROR-STREAM
  dynamic-wind(
    fn () : set-current-error-stream(o)
    body
    fn () : set-current-error-stream(oldv))

public defn current-error-stream () :
  CURRENT-ERROR-STREAM

public defn set-current-error-stream (o:OutputStream) :
  CURRENT-ERROR-STREAM = o
  match(o:FileOutputStream) :
    set-current-err(o)

lostanza defn set-current-err (o:ref<FileOutputStream>) -> ref<False> :
  current-err = o.file
  return false

;              Print to Current Output Stream
;              ==============================

public defn print (x) :
   print(CURRENT-OUTPUT-STREAM, x)

public defn println (x) :
   println(CURRENT-OUTPUT-STREAM, x)

public defn print-all (xs:Seqable) :
   do(print, xs)

public defn println-all (xs:Seqable) :
   println-all(CURRENT-OUTPUT-STREAM, xs)


;============================================================
;=================== Input Streams ==========================
;============================================================

;                      Interface
;                      =========

public deftype InputStream
public defmulti get-char (i:InputStream) -> Char|False
public defmulti get-byte (i:InputStream) -> Byte|False
public defmulti fill (xs:CharArray, r:Range, i:InputStream) -> Int

;                Abstract Implementations
;                ========================

defmethod fill (xs:CharArray, r:Range, s:InputStream) -> Int :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   defn* loop (i:Int) :
      if i < e :
         match(get-char(s)) :
            (c:Char) :
               xs[i] = c
               loop(i + 1)
            (c:False) : i - b
      else : i - b
   loop(b)

;============================================================
;=============== Buffered Input Streams =====================
;============================================================

public deftype BufferedInputStream <: InputStream

;                      Interface
;                      =========

public defmulti peek? (i:BufferedInputStream, n:Int) -> Char|False
public defmulti peek-fill (xs:CharArray, r:Range, i:BufferedInputStream) -> Int

;                Abstract Implementations
;                ========================

public defn peek? (i:BufferedInputStream) -> Char|False :
   peek?(i, 0)

;                     Creation
;                     ========

deftype CharQueue <: Lengthable
defmulti peek (c:CharQueue, i:Int) -> Char
defmulti pop (c:CharQueue) -> Char
defmulti peek-fill (xs:CharArray, b:Int, e:Int, c:CharQueue) -> Int
defmulti pop-fill (xs:CharArray, b:Int, e:Int, c:CharQueue) -> Int
defmulti fill (xs:CharQueue, stream:InputStream) -> False

defn CharQueue (cap:Int) :
   val array = CharArray(cap)
   var start:Int = 0
   var len:Int = 0

   defn wrap (i:Int) :
      val idx = start + i
      idx when idx < cap else idx - cap

   defn copy (xs:CharArray, b:Int, e:Int) :
      val n = e - b
      val n1 = cap - start
      val n2 = n - n1
      if n <= n1 :
         block-copy(n, xs, b, array, start)
      else :
         block-copy(n1, xs, b, array, start)
         block-copy(n2, xs, b + n1, array, 0)

   new CharQueue :
      defmethod length (this) :
         len
      defmethod peek (this, i:Int) :
         array[wrap(i)]
      defmethod pop (this) :
         val c = array[start]
         start = wrap(1)
         len = len - 1
         c
      defmethod peek-fill (xs:CharArray, b:Int, e:Int, this) -> Int :
         val n = min(e - b, len)
         copy(xs, b, b + n)
         n
      defmethod pop-fill (xs:CharArray, b:Int, e:Int, this) -> Int :
         val n = peek-fill(xs, b, e, this)
         start = wrap(n)
         len = len - n
         n
      defmethod fill (this, stream:InputStream) -> False :
         val pos = wrap(len)
         val total-read =
            if len == 0 :
               start = 0
               fill(array, 0 to cap, stream)
            else if start < pos :
               val n1 = cap - pos
               val n1* = fill(array, pos to cap, stream)
               if n1* < n1 : n1*
               else : n1* + fill(array, 0 to start, stream)
            else :
               fill(array, pos to start, stream)
         len = len + total-read

public defn BufferedInputStream (i:InputStream) -> BufferedInputStream :
   BufferedInputStream(i, 1024)

public defn BufferedInputStream (stream:InputStream, size:Int) -> BufferedInputStream :
   ensure-positive("buffer size", size)

   val buffer = CharQueue(size)

   new BufferedInputStream :
      defmethod peek? (this, i:Int) -> False|Char :
         #if-not-defined(OPTIMIZE) :
            if i < 0 :
               fatal("Cannot peek? into a BufferedInputStream at a negative index.")
            if i >= size :
               fatal("Cannot peek? %_ chars ahead into BufferedInputStream with buffer size %_." % [i, size])
         if length(buffer) > i :
            peek(buffer, i)
         else :
            fill(buffer, stream)
            peek(buffer, i) when length(buffer) > i

      defmethod peek-fill (xs:CharArray, r:Range, this) -> Int :
         val [b, e] = range-bound(xs, r)
         val n = e - b
         #if-not-defined(OPTIMIZE) :
            if n > size :
               fatal("Cannot peek more characters (%_) than capacity of buffer (%_)." % [n, size])
         fill(buffer, stream) when length(buffer) < n
         peek-fill(xs, b, e, buffer)

      defmethod fill (xs:CharArray, r:Range, this) -> Int :
         val [b, e] = range-bound(xs, r)
         val n = e - b
         if n < size :
            fill(buffer, stream) when length(buffer) < n
            pop-fill(xs, b, e, buffer)
         else :
            val n1 = pop-fill(xs, b, e, buffer)
            if n1 < n : n1 + fill(xs, (b + n1) to e, stream)
            else : n1

      defmethod get-char (this) -> False|Char :
         fill(buffer, stream) when length(buffer) == 0
         pop(buffer) when length(buffer) > 0

      defmethod get-byte (this) :
         match(get-char(this)) :
            (c:Char) : to-byte(c)
            (c:False) : false

;============================================================
;================= File Input Streams =======================
;============================================================

public lostanza deftype FileInputStream <: InputStream :
  file: ptr<?>
  closable?: long

public lostanza defn FileInputStream (filename:ref<String>) -> ref<FileInputStream> :
   val file = call-c clib/fopen(addr!(filename.chars), "rb")
   if file == null : throw(FileOpenException(filename, linux-error-msg()))
   return new FileInputStream{file, 1}

public lostanza defn close (i:ref<FileInputStream>) -> ref<False> :
   if i.closable? :
      val err = call-c clib/fclose(i.file)
      if err != 0 : throw(FileCloseException(linux-error-msg()))
   else : fatal("System Input Stream is not closable.")
   return false

lostanza defmethod get-char (i:ref<FileInputStream>) -> ref<Char|False> :
   val c = call-c clib/fgetc(i.file)
   if c == EOF :
      val err = call-c clib/ferror(i.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Char{c as byte}

lostanza defmethod get-byte (i:ref<FileInputStream>) -> ref<Byte|False> :
   val c = call-c clib/fgetc(i.file)
   if c == EOF :
      val err = call-c clib/ferror(i.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Byte{c as byte}

public defn get-int (i:InputStream) -> False|Int :
   defn get-byte! (i:InputStream) :
      match(get-byte(i)) :
         (b:Byte) : b
         (b:False) : fail()
   attempt :
      val b0 = to-int(get-byte!(i))
      val b1 = to-int(get-byte!(i))
      val b2 = to-int(get-byte!(i))
      val b3 = to-int(get-byte!(i))
      (b0) |
      (b1 << 8) |
      (b2 << 16) |
      (b3 << 24)

public defn get-long (i:InputStream) -> False|Long :
   defn get-int! (i:InputStream) :
      match(get-int(i)) :
         (x:Int) : x
         (x:False) : fail()
   attempt :
      val w0 = to-long(get-int!(i))
      val w1 = to-long(get-int!(i))
      (w0 & 0xFFFFFFFFL) |
      (w1 << 32L)

public defn get-float (i:InputStream) -> False|Float :
   match(get-int(i)) :
      (x:Int) : bits-as-float(x)
      (x:False) : false

public defn get-double (i:InputStream) -> False|Double :
   match(get-long(i)) :
      (x:Long) : bits-as-double(x)
      (x:False) : false

public defn slurp (filename:String) :
   val s = FileInputStream(filename)
   try :
      val buffer = StringBuffer()
      defn* loop () :
         match(get-char(s)) :
            (c:Char) :
               add(buffer, c)
               loop()
            (c:False) : false
      loop()
      to-string(buffer)
   finally : close(s)

;============================================================
;================== RandomAccessFiles =======================
;============================================================

public lostanza deftype RandomAccessFile :
  file: ptr<?>
  writable: ref<True|False>

public lostanza defn RandomAccessFile (filename:ref<String>, writable:ref<True|False>) -> ref<RandomAccessFile> :
  if writable == true :
    var file:ptr<?> = call-c clib/fopen(addr!(filename.chars), "r+b")
    if file == null :
      file = call-c clib/fopen(addr!(filename.chars), "w+b")
      if file == null : throw(FileOpenException(filename, linux-error-msg()))
      return new RandomAccessFile{file, writable}
    else :
      return new RandomAccessFile{file, writable}
  else :
    val file = call-c clib/fopen(addr!(filename.chars), "rb")
    if file == null : throw(FileOpenException(filename, linux-error-msg()))
    return new RandomAccessFile{file, writable}

public lostanza defn output-stream (file:ref<RandomAccessFile>) -> ref<FileOutputStream> :
  if file.writable == false :
    throw(FileNotWritableException())
  return new FileOutputStream{file.file, 0}

public lostanza defn input-stream (file:ref<RandomAccessFile>) -> ref<FileInputStream> :
  return new FileInputStream{file.file, 0}

public lostanza defn close (f:ref<RandomAccessFile>) -> ref<False> :
  val err = call-c clib/fclose(f.file)
  if err != 0 : throw(FileCloseException(linux-error-msg()))
  return false

public lostanza defn flush (f:ref<RandomAccessFile>) -> ref<False> :
  val err = call-c clib/fflush(f.file)
  if err != 0 : throw(FileFlushException(linux-error-msg()))
  return false

public lostanza defn writable? (f:ref<RandomAccessFile>) -> ref<True|False> :
  return f.writable

public lostanza defn length (f:ref<RandomAccessFile>) -> ref<Long> :
  return new Long{call-c clib/get_file_size(f.file)}

public lostanza defn position (f:ref<RandomAccessFile>) -> ref<Long> :
  return new Long{call-c clib/ftell(f.file)}

public lostanza defn time-modified (filename:ref<String>) -> ref<Long> :
  val t = call-c clib/file_time_modified(addr!(filename.chars))
  if t == 0 : throw(FileStatException(filename, linux-error-msg()))
  return new Long{t}

public lostanza defn set-length (f:ref<RandomAccessFile>, len:ref<Long>) -> ref<False> :
  val err = call-c clib/file_set_length(f.file, len.value)
  if err != 0 : throw(FileSetLengthException(linux-error-msg()))
  return false

public lostanza defn seek (f:ref<RandomAccessFile>, pos:ref<Long>) -> ref<False> :
  val err = call-c clib/file_seek(f.file, pos.value)
  if err != 0 : throw(FileSeekException(linux-error-msg()))
  return false

public lostanza defn skip (f:ref<RandomAccessFile>, pos:ref<Long>) -> ref<False> :
  val err = call-c clib/file_skip(f.file, pos.value)
  if err != 0 : throw(FileSeekException(linux-error-msg()))
  return false

public lostanza defn get-byte (f:ref<RandomAccessFile>) -> ref<Byte|False> :
  val c = call-c clib/fgetc(f.file)
  if c == EOF :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
    return false
  else :
    return new Byte{c as byte}

public defn get-char (f:RandomAccessFile) -> Char|False :
  match(get-byte(f)) :
    (b:Byte) : to-char(b)
    (b:False) : b

public lostanza defn get-int (f:ref<RandomAccessFile>) -> ref<Int|False> :
  val b0 = call-c clib/fgetc(f.file)
  val b1 = call-c clib/fgetc(f.file)
  val b2 = call-c clib/fgetc(f.file)
  val b3 = call-c clib/fgetc(f.file)
  if b3 == EOF :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
    return false
  else :
    return new Int{
      (b0) |
      (b1 << 8) |
      (b2 << 16) |
      (b3 << 24)}

public lostanza defn get-long (f:ref<RandomAccessFile>) -> ref<Long|False> :
  val b0 = call-c clib/fgetc(f.file)
  val b1 = call-c clib/fgetc(f.file)
  val b2 = call-c clib/fgetc(f.file)
  val b3 = call-c clib/fgetc(f.file)
  val b4 = call-c clib/fgetc(f.file)
  val b5 = call-c clib/fgetc(f.file)
  val b6 = call-c clib/fgetc(f.file)
  val b7 = call-c clib/fgetc(f.file)
  if b7 == EOF :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
    return false
  else :
    return new Long{
      (b0) |
      (b1 << 8L) |
      (b2 << 16L) |
      (b3 << 24L) |
      (b4 << 32L) |
      (b5 << 40L) |
      (b6 << 48L) |
      (b7 << 56L)}

public defn get-float (f:RandomAccessFile) -> Float|False :
  match(get-int(f)) :
    (i:Int) : bits-as-float(i)
    (i:False) : false

public defn get-double (f:RandomAccessFile) -> Double|False :
  match(get-long(f)) :
    (i:Long) : bits-as-double(i)
    (i:False) : false

public lostanza defn fill (a:ref<ByteArray>, r:ref<Range>, f:ref<RandomAccessFile>) -> ref<Long> :
  ;Get range bounds
  ensure-index-range(a, r)
  val rb = range-bound(a, r)
  val b = get(rb, new Int{0}).value
  val e = get(rb, new Int{1}).value
  val len = e - b
  ;Read block
  val ptr = addr!(a.data) + b
  val n = call-c clib/file_read_block(f.file, ptr, len)
  ;Check errors
  if n < len :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
  ;Return bytes read
  return new Long{n}

public defn fill (a:ByteArray, f:RandomAccessFile) -> Long :
  fill(a, 0 to false, f)

defn ensure-writable (f:RandomAccessFile) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if not writable?(f) :
      fatal("RandomAccessFile is not writable.")

public lostanza defn put (f:ref<RandomAccessFile>, xs:ref<ByteArray>, r:ref<Range>) -> ref<False> :
  ensure-writable(f)
  ;Get range bounds
  ensure-index-range(xs, r)
  val rb = range-bound(xs, r)
  val b = get(rb, new Int{0}).value
  val e = get(rb, new Int{1}).value
  val len = e - b
  ;Write block
  val ptr = addr!(xs.data) + b
  val n = call-c clib/file_write_block(f.file, ptr, len)
  ;Check errors
  if n < len :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileWriteException(linux-error-msg()))
  ;Done
  return false

public defn put (f:RandomAccessFile, xs:ByteArray) -> False :
  put(f, xs, 0 to false)

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Byte>) -> ref<False> :
  ensure-writable(f)
  val r = call-c clib/fputc(x.value, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Char>) -> ref<False> :
  ensure-writable(f)
  val r = call-c clib/fputc(x.value, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Int>) -> ref<False> :
  ensure-writable(f)
  val fp = f.file
  val xv = x.value
  call-c clib/fputc(xv as byte, f.file)
  call-c clib/fputc((xv >> 8) as byte, f.file)
  call-c clib/fputc((xv >> 16) as byte, f.file)
  val r = call-c clib/fputc((xv >> 24) as byte, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Long>) -> ref<False> :
  ensure-writable(f)
  val fp = f.file
  val xv = x.value
  call-c clib/fputc(xv as byte, f.file)
  call-c clib/fputc((xv >> 8L) as byte, f.file)
  call-c clib/fputc((xv >> 16L) as byte, f.file)
  call-c clib/fputc((xv >> 24L) as byte, f.file)
  call-c clib/fputc((xv >> 32L) as byte, f.file)
  call-c clib/fputc((xv >> 40L) as byte, f.file)
  call-c clib/fputc((xv >> 48L) as byte, f.file)
  val r = call-c clib/fputc((xv >> 56L) as byte, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public defn put (f:RandomAccessFile, x:Float) -> False :
  put(f, bits(x))

public defn put (f:RandomAccessFile, x:Double) -> False :
  put(f, bits(x))

;============================================================
;===================== ByteBuffer ===========================
;============================================================

public deftype ByteBuffer <: IndexedCollection<Byte> & OutputStream
public defmulti clear (b:ByteBuffer) -> False
public defmulti set-write-position (b:ByteBuffer, h:Int) -> False
public defmulti write-position (b:ByteBuffer) -> Int

public defn ByteBuffer (n:Int) -> ByteBuffer :
  ensure-non-negative("length", n)
  var buffer = ByteArray(n)
  var len:Int = 0
  var head:Int = 0

  defn ensure-capacity (c:Int) :
    defn set-capacity (c:Int) :
      val buffer* = ByteArray(c)
      block-copy(len, buffer*, 0, buffer, 0)
      buffer = buffer*
    val cur-c = length(buffer)
    set-capacity(max(c, 2 * cur-c)) when c > cur-c

  new ByteBuffer :
    defmethod backing-array (this) :
      buffer

    defmethod put (this, c:Byte) :
      ensure-capacity(head + 1)
      buffer[head] = c
      head = head + 1
      len = max(len, head)

    defmethod clear (this) :
      len = 0
      head = 0

    defmethod get (this, i:Int) :
      ensure-index-in-bounds(this, i)
      buffer[i]

    defmethod get (this, r:Range) :
      ensure-index-range(this, r)
      val [b, e] = range-bound(this, r)
      buffer[b to e]

    defmethod set (this, i:Int, b:Byte) :
      if i == head :
        put(this, b)
      else :
        ensure-index-in-bounds(this, i)
        buffer[i] = b

    defmethod length (this) :
      len

    defmethod set-write-position (this, h:Int) :
      ensure-length-in-bounds(this, h)
      head = h

    defmethod write-position (this) :
      head

defmulti backing-array (b:ByteBuffer) -> ByteArray
public lostanza defn data (b:ref<ByteBuffer>) -> ptr<byte> :
  return addr!(backing-array(b).data)

public defn ByteBuffer () :
  ByteBuffer(32)

defmethod print (b:ByteBuffer, c:Char) :
  put(b, to-byte(c))

defmethod print (o:OutputStream, b:ByteBuffer) :
  print(o, "[ByteBuffer: %_ bytes]" % [length(b)])

public defn OutputStream (b:ByteBuffer, i:Int) :
  var pos = i
  defn inc-pos () :
    val cur-pos = pos
    pos = pos + 1
    cur-pos
  new OutputStream :
    defmethod put (this, x:Byte) : b[inc-pos()] = x
    defmethod print (this, x:Char) : b[inc-pos()] = to-byte(x)

public defn InputStream (b:ByteBuffer, i:Int) :
  var pos = i
  defn inc-pos () :
    val cur-pos = pos
    pos = pos + 1
    cur-pos
  new InputStream :
    defmethod get-char (this) : to-char(b[inc-pos()]) when pos < length(b)
    defmethod get-byte (this) : b[inc-pos()] when pos < length(b)

public defn OutputStream (b:ByteBuffer) : OutputStream(b, 0)
public defn InputStream (b:ByteBuffer) : InputStream(b, 0)

;============================================================
;=================== StringBuffer ===========================
;============================================================

public deftype StringBuffer <: IndexedCollection<Char> & OutputStream

;                     Interface
;                     =========

public defmulti add (s:StringBuffer, c:Char) -> False
public defmulti add-all (s:StringBuffer, c:Seqable<Char>) -> False
public defmulti clear (s:StringBuffer) -> False

;               Abstract Implementation
;               =======================

defmethod add-all (s:StringBuffer, xs:Seqable<Char>) :
   do(add{s, _}, xs)

defmethod print (s:StringBuffer, c:Char) : add(s, c)
defmethod print (s:StringBuffer, cs:String) : add-all(s, cs)
defmethod print (s:StringBuffer, cs:StringBuffer) : add-all(s, cs)
defmethod print (s:StringBuffer, cs:CharArray) : add-all(s, cs)

defmethod print-all (s:StringBuffer, cs:String) : add-all(s, cs)
defmethod print-all (s:StringBuffer, cs:StringBuffer) : add-all(s, cs)
defmethod print-all (s:StringBuffer, cs:CharArray) : add-all(s, cs)

defmethod write (o:OutputStream, s:StringBuffer) :
   print(o, '"')
   for c in s do :
      escape-for-string(o, c)
   print(o, '"')

;                   Implementation
;                   ==============

public defn StringBuffer (n:Int) -> StringBuffer :
   ensure-non-negative("length", n)
   var buffer = CharArray(n)
   var len = 0

   defn ensure-capacity (c:Int) :
      defn set-capacity (c:Int) :
         val buffer* = CharArray(c)
         block-copy(len, buffer*, 0, buffer, 0)
         buffer = buffer*
      val cur-c = length(buffer)
      set-capacity(max(c, 2 * cur-c)) when c > cur-c

   new StringBuffer :
      defmethod add (this, c:Char) :
         ensure-capacity(len + 1)
         buffer[len] = c
         len = len + 1

      defmethod add-all (this, xs:Seqable<Char> & Lengthable) :
         val n = length(xs)
         ensure-capacity(len + n)
         for (x in xs, i in 0 to n) do :
            buffer[len + i] = x
         len = len + n

      defmethod clear (this) :
         len = 0

      defmethod get (this, i:Int) :
         ensure-index-in-bounds(this, i)
         buffer[i]

      defmethod get (this, r:Range) :
         ensure-index-range(this, r)
         val [b, e] = range-bound(this, r)
         buffer[b to e]

      defmethod set (this, i:Int, c:Char) :
         if i == len :
            add(this, c)
         else :
            ensure-index-in-bounds(this, i)
            buffer[i] = c

      defmethod length (this) :
         len

      defmethod to-string (this) :
         buffer[0 to len] as String

public defn StringBuffer () :
   StringBuffer(32)

;============================================================
;==================== Remove File ===========================
;============================================================
#if-defined(PLATFORM-WINDOWS) :
  lostanza defn delete-folder (path:ref<String>) -> ref<False> :
    val r = call-c clib/rmdir(addr!(path.chars))
    if r == -1 : throw(FileDeletionError(path, linux-error-msg()))
    return false
  lostanza defn delete-plain-file (path:ref<String>) -> ref<False> :
    val r = call-c clib/remove(addr!(path.chars))
    if r == -1 : throw(FileDeletionError(path, linux-error-msg()))
    return false
  public defn delete-file (path:String) :
    if file-exists?(path) and file-type(path) is DirectoryType :
      delete-folder(path)
    else :
      delete-plain-file(path)
#else :
  public lostanza defn delete-file (path:ref<String>) -> ref<False> :
    val r = call-c clib/remove(addr!(path.chars))
    if r == -1 : throw(FileDeletionError(path, linux-error-msg()))
    return false

public deftype FileDeletionError <: Exception
public defn FileDeletionError (path:String, msg:String) :
   new FileDeletionError :
      defmethod print (o:OutputStream, this) :
         print{o, _} $
         "Error when attempting to delete %_. %_." % [path, msg]

;============================================================
;====================== Rename a File =======================
;============================================================

public lostanza defn rename-file (path:ref<String>, new-path:ref<String>) -> ref<False> :
  val r = call-c clib/rename(addr!(path.chars), addr!(new-path.chars))
  if r == -1 : throw(FileRenameError(path, linux-error-msg()))
  return false

public deftype FileRenameError <: Exception
public defn FileRenameError (path:String, msg:String) :
   new FileRenameError :
      defmethod print (o:OutputStream, this) :
         print{o, _} $
         "Error when attempting to rename %_. %_." % [path, msg]

;============================================================
;================= Create a Symbolic Link ===================
;============================================================

public lostanza defn symlink (target:ref<String>, linkpath:ref<String>) -> ref<False> :
  val r = call-c clib/symlink(addr!(target.chars), addr!(linkpath.chars))
  if r == -1 : throw(SymLinkError(target, linkpath, linux-error-msg()))
  return false

public deftype SymLinkError <: Exception
public defn SymLinkError (target:String, linkpath:String, msg:String) :
  new SymLinkError :
    defmethod print (o:OutputStream, this) :
      print(o, "Error creating symbolic link %~ -> %~. %_." % [
        linkpath, target, msg])

;============================================================
;===================== Copying a File =======================
;============================================================

public defn copy-file (old-path:String, new-path:String) :
  val old-file = RandomAccessFile(old-path, false)
  val new-file = RandomAccessFile(new-path, true)
  try :
    val buffer = ByteArray(1042 * 1024)
    val end = length(old-file)
    while position(old-file) < end :
      val nbytes = to-int(fill(buffer, old-file))
      put(new-file, buffer, 0 to nbytes)
  finally :
    close(old-file)
    close(new-file)

;============================================================
;===================== FilePaths ============================
;============================================================

;Convert a (possibly null) character pointer to a String.
lostanza defn ptr-to-string? (p:ptr<byte>) -> ref<String|False> :
  if p != null :
    val s = String(p)
    call-c clib/free(p)
    return s
  else :
    return false

#if-defined(PLATFORM-WINDOWS) :
  ;----------------------------------------------------------
  ;-------------------- HiStanza Bindings -------------------
  ;----------------------------------------------------------
  lostanza defn windows-logical-drives-bitmask () -> ref<Int> :
    return new Int{call-c clib/windows_logical_drives_bitmask()}

  lostanza defn windows-final-path-name (path:ref<String>) -> ref<String|False> :
    val p = call-c clib/windows_final_path_name(addr!(path.chars))
    return ptr-to-string?(p)

  lostanza defn windows-full-path-name (path:ref<String>) -> ref<String|False> :
    val p = call-c clib/windows_full_path_name(addr!(path.chars))
    return ptr-to-string?(p)

  ;----------------------------------------------------------
  ;---------------------- Utilities -------------------------
  ;----------------------------------------------------------
  ;The windows GetFinalPath function sometimes prepends the result
  ;with \\?\ to indicate that it is using Unicode syntax
  ;to represent the result. We do not currently handle Unicode
  ;so we will strip away this prefix and assume the result
  ;can be interpreted as ascii.
  defn resolve-final-path (path:String) -> String|False :
    val final-path = windows-final-path-name(path)
    match(final-path:String) :
      if prefix?(final-path, "\\\\?\\") : final-path[4 to false]
      else : final-path

  ;----------------------------------------------------------
  ;----------------- Windows UNC Drive Names ----------------
  ;----------------------------------------------------------
  ;Represents all mapped drives that have a corresponding
  ;UNC path on Windows.
  deftype WindowsUNCDrivePaths

  ;Returns a tuple of X => path, where X is the drive letter
  ;and path is the UNC path. The path ends with a terminating \.
  defmulti drives (p:WindowsUNCDrivePaths) -> Tuple<KeyValue<Char,String>>

  ;Singleton definition
  val WINDOWS-UNC-DRIVE-PATHS = WindowsUNCDrivePaths()

  ;Return the vector of active drive letters.
  defn windows-drive-letters () -> Vector<Char> :
    val drives = Vector<Char>()
    var mask:Int = windows-logical-drives-bitmask()
    for i in 0 to 26 do :
      val valid? = mask & 1 != 0
      if valid? :
        val c = to-char(to-int('A') + i)
        add(drives, c)
      mask = mask >> 1
    drives

  ;Returns true if the given path is a UNC path.
  defn unc-path? (path:String) -> True|False :
    prefix?(path, "UNC\\")

  ;Scan for the Windows UNC Drive Paths.
  defn WindowsUNCDrivePaths () :
    var drive-paths:Tuple<KeyValue<Char,String>>|False = false
    defn scan-drive-paths () :
      if drive-paths is False :
        val paths = Vector<KeyValue<Char,String>>()
        for c in windows-drive-letters() do :
          val path = resolve-final-path(to-string("%_:\\" % [c]))
          match(path:String) :
            add(paths, c => path) when unc-path?(path)
        drive-paths = to-tuple(paths)
    new WindowsUNCDrivePaths :
      defmethod drives (this) :
        scan-drive-paths()
        drive-paths as Tuple<KeyValue<Char,String>>

  ;If the given path is a mapped network drive with a UNC path, then attempt to subtitute the
  ;drive letter for the UNC path. If a preferred drive is provided, then try to
  ;use the subtitution corresponding to that drive letter. (This occurs if the same path
  ;can be substituted in multiple ways.)
  defn sub-drive-letter (w:WindowsUNCDrivePaths, path:String, preferred:Char|False) -> String|False :
    ;Try to find all new paths.
    val new-paths = to-tuple $ for entry in drives(w) seq? :
      val letter = key(entry)
      if prefix?(path, value(entry)) :
        val len = length(value(entry))
        val new-path = to-string("%_:\\%_" % [letter, path[len to false]])
        One(letter => new-path)
      else : None()
    ;Choose the preferred one.
    switch(length(new-paths)) :
      0 :
        false
      1 :
        value(new-paths[0])
      else :
        val pref = find({key(_) == preferred}, new-paths)
        match(pref:KeyValue<Char,String>) : value(pref)
        else : value(new-paths[0])

  ;Windows algorithm for path resolution:
  ;Try the following techniques in this order:
  ;1) Use GetFinalPath.
  ;2) If it is a UNC path then try subtituting the drive letter.
  ;3) If that doesn't work, then try using GetFullPath.
  ;4) Ensure the final resolved path exists before returning.
  public defn resolve-path (path:String) -> String|False :
    ;Step 1.
    defn resolve-using-final-path () :
      val final-path = resolve-final-path(path)
      match(final-path:String) :
        if unc-path?(final-path) : resolve-by-substituting-drive-letter(final-path)
        else : return-path-if-exists?(final-path)

    ;Utility: If path has form X:\mydir, then return X.
    defn drive-letter? (path:String) -> Char|False :
      if length(path) >= 3 :
        val chars = path[1 to 3]
        if chars == ":\\" or chars == ":/" :
          path[0]

    ;Step 2.
    defn resolve-by-substituting-drive-letter (unc-path:String) :
      val preferred = drive-letter?(path)
      val new-path = sub-drive-letter(WINDOWS-UNC-DRIVE-PATHS, unc-path, preferred)
      match(new-path:String) : return-path-if-exists?(new-path)
      else : resolve-using-full-path()

    ;Step 3.
    defn resolve-using-full-path () :
      val full-path = windows-full-path-name(path)
      match(full-path:String) : return-path-if-exists?(full-path)

    ;Step 4.
    defn return-path-if-exists? (p:String) :
      p when file-exists?(p)

    ;Launch!
    resolve-using-final-path()

#else :
  public lostanza defn resolve-path (path:ref<String>) -> ref<String|False> :
     val p = call-c clib/resolve_path(addr!(path.chars))
     return ptr-to-string?(p)

public defn resolve-path! (path:String) -> String :
  match(resolve-path(path)) :
    (p:String) : p
    (f:False) : throw(PathResolutionError(path))

public defn norm-path (path) -> String :
   #if-defined(PLATFORM-WINDOWS) :
      replace(to-string(path), '/', '\\')
   #else :
      to-string(path)

public defn file-exists? (filename:String) -> True|False :
  try :
    file-type(filename, false)
    true
  catch (e:FileTypeException) :
    false

;============================================================
;================= Get the File Type ========================
;============================================================

public deftype FileType
public defstruct RegularFileType <: FileType
public defstruct DirectoryType <: FileType
public defstruct SymbolicLinkType <: FileType
public defstruct OtherType <: FileType

defmethod print (o:OutputStream, t:FileType) :
  print{o, _} $ match(t) :
    (t:RegularFileType) : "Regular File"
    (t:DirectoryType) : "Directory"
    (t:SymbolicLinkType) : "Symbolic Link"
    (t:OtherType) : "Other"

;Convert result of driver file_type return value into FileType object.
lostanza defn to-file-type (filename:ref<String>, r:int) -> ref<FileType> :
  if r == -1 : return throw(FileTypeException(filename, platform-error-msg()))
  else if r == 0 : return RegularFileType()
  else if r == 1 : return DirectoryType()
  else if r == 2 : return SymbolicLinkType()
  else if r == 3 : return OtherType()
  else : return fatal("Unreachable case")

#if-defined(PLATFORM-WINDOWS) :
  public lostanza defn file-type (filename:ref<String>, follow-symlinks?:ref<True|False>) -> ref<FileType> :
    if follow-symlinks? == true :
      return file-type(resolve-path!(filename), false)
    else :
      val result = call-c clib/get_file_type(addr!(filename.chars))
      return to-file-type(filename, result)
#else :
  public lostanza defn file-type (filename:ref<String>, follow-symlinks?:ref<True|False>) -> ref<FileType> :
    var follow-slinks:int = 0
    if follow-symlinks? == true : follow-slinks = 1
    val result = call-c clib/get_file_type(addr!(filename.chars), follow-slinks)
    return to-file-type(filename, result)

public defn file-type (filename:String) -> FileType :
  file-type(filename, true)

public defstruct FileTypeException <: IOException :
  filename: String
  cause: String|False with: (default => false)

defmethod print (o:OutputStream, e:FileTypeException) :
  val cause-str = match(cause(e)) :
    (c:String) : ": %_" % [c]
    (c:False) : ""
  print(o, "Error occurred when determining type of file %_%_." % [filename(e), cause-str])

;============================================================
;================ List Contents of Directory ================
;============================================================

extern free_stringlist : ptr<StringList> -> int
lostanza deftype StringList :
  n: int
  capacity: int
  strings: ptr<ptr<byte>>

extern list_dir: ptr<byte> -> ptr<StringList>
public lostanza defn dir-files (dirname:ref<String>, include-parents?:ref<True|False>) -> ref<Tuple<String>> :
  ;Call list dir
  val list = call-c list_dir(addr!(dirname.chars))
  val null = 0L as ptr<?>
  if list == null: throw(DirException(dirname, linux-error-msg()))
  ;Convert to vector
  val strings = Vector<String>()
  for (var i:int = 0, i < list.n, i = i + 1) :
    add(strings, String(list.strings[i]))
  ;Free stringlist
  call-c free_stringlist(list)
  ;Apply filter
  if include-parents? == true : return to-tuple(strings)
  else : return to-tuple(filter(fn(without-parents), strings))

defn without-parents (name:String) : name != "." and name != ".."

public defn dir-files (dirname:String) : dir-files(dirname, false)

public defstruct DirException <: IOException :
  filename: String
  cause: String
defmethod print (o:OutputStream, e:DirException) :
  print(o, "Error occurred when listing contents of directory %_: %_." %
    [filename(e), cause(e)])

;============================================================
;================== Split a Filepath ========================
;============================================================

public defn split-filepath (path:String) -> [String, String] :
  val n = length(path)
  match(last-index-of-char(path, '/')) :
    (i:Int) :
      throw(PathEndsWithSlash(path)) when i == n - 1
      [path[0 through i], path[(i + 1) to false]]
    (i:False) :
      throw(EmptyPath()) when n == 0
      ["./", path]

public deftype PathException <: Exception

public defstruct PathEndsWithSlash <: PathException :
  path: String
defmethod print (o:OutputStream, e:PathEndsWithSlash) :
  print(o, PEWS-MSG % [path(e)])
val PEWS-MSG = "Could not determine project name. Path %~ ends with a slash."

public defstruct EmptyPath <: PathException
defmethod print (o:OutputStream, e:EmptyPath) :
  print(o, EP-MSG)
val EP-MSG = "Could not determine project name. The given path is empty."

;============================================================
;================== Recursively Delete ======================
;============================================================

public defn delete-recursive (path:String, follow-symlinks?:True|False) :
  val dir = core/parsed-path/parse-path(path)
  if file-type(path, follow-symlinks?) is DirectoryType :
    for file in dir-files(path) do :
      val path = to-string(core/parsed-path/relative-to-dir(dir, file))
      delete-recursive(path, follow-symlinks?)
  delete-file(path)

public defn delete-recursive (path:String) :
  delete-recursive(path, true)

;============================================================
;================ Create a New Directory ====================
;============================================================

#if-defined(PLATFORM-WINDOWS) :
  extern _mkdir: (ptr<byte>) -> int
  public lostanza defn create-dir (dirname:ref<String>,
                                  permissions:ref<Int>) -> ref<False> :
    val result = call-c _mkdir(addr!(dirname.chars))
    if result == -1 : throw(CreateDirException(dirname, linux-error-msg()))
    return false
#else :
  extern mkdir: (ptr<byte>, long) -> int
  public lostanza defn create-dir (dirname:ref<String>,
                                  permissions:ref<Int>) -> ref<False> :
    val result = call-c mkdir(addr!(dirname.chars), permissions.value)
    if result == -1 : throw(CreateDirException(dirname, linux-error-msg()))
    return false

public defn create-dir (dirname:String) :
  create-dir(dirname, 0o777)

public defstruct CreateDirException <: IOException :
  filename: String
  cause: String
defmethod print (o:OutputStream, e:CreateDirException) :
  print(o, "Error occurred when attempting to create directory %_: %_." %
    [filename(e), cause(e)])

;============================================================
;================ Environment Variables =====================
;============================================================

public lostanza defn get-env (name:ref<String>) -> ref<String|False> :
  val value = call-c clib/getenv(addr!(name.chars))
  if value == null : return false
  else : return String(value)

public defn get-env! (name:String) -> String :
  val v = get-env(name)
  match(v:String) : v
  else : throw(NoEnvVarError(name))

public lostanza defn set-env (name:ref<String>, value:ref<String>, overwrite:ref<True|False>) -> ref<False> :
  var ov:int = 0
  if overwrite == true : ov = 1
  val r = call-c clib/setenv(addr!(name.chars), addr!(value.chars), ov)
  if r != 0 : throw(SetEnvException(name, value, linux-error-msg()))
  return false

public defn set-env (name:String, value:String) :
  set-env(name, value, true)

public lostanza defn unset-env (name:ref<String>) -> ref<False> :
  val r = call-c clib/unsetenv(addr!(name.chars))
  if r != 0 : throw(UnsetEnvException(name, linux-error-msg()))
  return false

public defstruct NoEnvVarError <: Exception :
  name: String

public defstruct SetEnvException <: Exception :
  name: String
  value: String
  cause: String

defmethod print (o:OutputStream, e:SetEnvException) :
   print(o, "Could not set environment variable %_ to %~. %_." % [name(e), value(e), cause(e)])

public defstruct UnsetEnvException <: Exception :
  name: String
  cause: String
defmethod print (o:OutputStream, e:UnsetEnvException) :
  print(o, "Could not unset environment variable %_. %_." % [name(e), cause(e)])

;============================================================
;================== Exit System =============================
;============================================================

public lostanza defn exit (code:ref<Int>) -> ref<Void> :
   call-c clib/exit(code.value)
   return null as ref<Void>

;============================================================
;===================== Exceptions ===========================
;============================================================

;Represents all exceptions.
public deftype Exception <: Unique

;Simple constructor for a generic exception.
public defn Exception (msg) -> Exception :
  new Exception :
    defmethod print (o:OutputStream, this) :
      print(o, msg)

;Holds the currently-equipped exception handler.
var CURRENT-EXCEPTION-HANDLER : Exception -> Void =
  fn (e:Exception) :
    fatal(e)

;Throw the given exception to the currently-set handler.
public defn throw (e:Exception) :
  CURRENT-EXCEPTION-HANDLER(e)

;Run the given body with the equipped exception interceptor.
public defn with-exception-interceptor<?T> (body: () -> ?T,
                                            intercept: Exception -> Void) -> T :
  val handler = CURRENT-EXCEPTION-HANDLER
  defn interceptor (e:Exception) :
    CURRENT-EXCEPTION-HANDLER = handler
    intercept(e)
  let-var CURRENT-EXCEPTION-HANDLER = interceptor :
    body()

;Run the given body with the equipped catchers.
public defn with-exception-handler<?T> (body: () -> ?T,
                                        catch?: Exception -> True|False,
                                        catcher: Exception -> ?T) -> T :
  ;Execute the body within a label so that stack can be unwound.
  val r = label<ExceptionResult|NormalResult> break :
    ;Get the current handler. This needs to be called if the
    ;equipped catcher doesn't handle this.
    val current-handler = CURRENT-EXCEPTION-HANDLER

    ;Implementation of throw within the body.
    defn throw-within-body (e:Exception) :
      ;First check whether the catcher is supposed to handle this
      ;exception.
      if catch?(e) :
        ;If it is, then unwind the stack and handle it.
        break(ExceptionResult(e))
      else :
        ;Otherwise, pass the exception to the next handler
        ;to handle it.
        current-handler(e)

    ;Execute the body with the new throw equipped.
    let-var CURRENT-EXCEPTION-HANDLER = throw-within-body :
      NormalResult(body())

  ;Depending on whether the body executed successfully, either
  ;run the catcher or not.
  match(r) :
    (r:ExceptionResult) : catcher(exception(r))
    (r:NormalResult) : result(r)

;Represents the return value from a body when equipped
;with catchers.
defstruct ExceptionResult : (exception: Exception)
defstruct NormalResult : (result)

;Run the given body with the equipped finally block.
public defn with-finally<?T> (body: () -> ?T, finally: () -> ?) -> T :
  push-winder(Winder(false, false, finally))
  inc-winders(current-coroutine, 1)
  val result = body()
  pop-winder()
  inc-winders(current-coroutine, -1)
  finally()
  result

;============================================================
;============== Input/Output Exceptions =====================
;============================================================

public deftype IOException <: Exception

public defstruct FileStatException <: IOException :
  filename: String
  cause: String

defmethod print (o:OutputStream, e:FileStatException) :
  print(o, "Error occurred when attempting to read statistics of file %_. %_." % [
    filename(e), cause(e)])

public defstruct FileOpenException <: IOException :
   filename: String
   cause: String

defmethod print (o:OutputStream, e:FileOpenException) :
   print(o, "Error occurred when attempting to open file %_. %_." % [filename(e), cause(e)])

public defstruct FileCloseException <: IOException :
   cause: String

public defstruct FileNotWritableException <: IOException
defmethod print (o:OutputStream, e:FileNotWritableException) :
  print(o, "The given random access file is not allowed to be written to.")

defmethod print (o:OutputStream, e:FileCloseException) :
   print(o, "Error occurred when attempting to close file. %_." % [cause(e)])

public defstruct FileFlushException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileFlushException) :
   print(o, "Error occurred when attempting to flush file. %_." % [cause(e)])

public defstruct FileReadException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileReadException) :
   print(o, "Error occurred when attempting to read from file. %_." % [cause(e)])

public defstruct FileWriteException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileWriteException) :
   print(o, "Error occurred when attempting to write to file. %_." % [cause(e)])

public defstruct FileSeekException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileSeekException) :
   print(o, "Error occurred when attempting to seek in file. %_." % [cause(e)])

public defstruct FileSetLengthException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileSetLengthException) :
   print(o, "Error occurred when attempting to seek in file. %_." % [cause(e)])

public defstruct PathResolutionError <: Exception :
   filename: String
defmethod print (o:OutputStream, e:PathResolutionError) :
  print(o, "Could not resolve path %~." % [filename(e)])

;============================================================
;================ String Input Streams ======================
;============================================================

public deftype StringInputStream <: InputStream & Lengthable

;                       Interface
;                       =========

public defmulti peek? (s:StringInputStream, i:Int) -> False|Char
public defmulti info (s:StringInputStream) -> FileInfo
public defmulti get-chars (s:StringInputStream, n:Int) -> String


;                Abstract Implementations
;                ========================

public defn peek? (s:StringInputStream) :
   peek?(s, 0)

public defn peek (s:StringInputStream, i:Int) :
   match(peek?(s, i)) :
      (c:Char) : c
      (c:False) : fatal("No more characters in stream.")

public defn peek (s:StringInputStream) :
   peek(s, 0)

;                   Implementation
;                   ==============

public defn StringInputStream (string:String, filename:String) :
  StringInputStream(string, FileInfo(filename, 1, 0))

public defn StringInputStream (string:String, fileinfo:FileInfo) :
   var start = 0
   var line = line(fileinfo)
   var column = column(fileinfo)
   val n = length(string)

   new StringInputStream :
      defmethod get-char (this) :
         if start < n :
            val c = string[start]
            start = start + 1
            if c == '\n' :
               line = line + 1
               column = 0
            else :
               column = column + 1
            c

      defmethod get-chars (this, n:Int) :
         #if-not-defined(OPTIMIZE) :
            if length(this) < n :
               fatal("Cannot eat %_ chars from StringInputStream with %_ chars remaining." % [n, length(this)])
         val ret = string[start to start + n]
         do(get-char{this}, 0 to n)
         ret

      defmethod get-byte (this) :
         match(get-char(this)) :
            (c:Char) : to-byte(c)
            (c:False) : false

      defmethod info (this) :
         FileInfo(filename(fileinfo), line, column)

      defmethod peek? (this, i:Int) :
         string[start + i] when start + i < n

      defmethod length (this) :
         n - start

public defn StringInputStream (string:String) :
   StringInputStream(string, "UnnamedStream")

;============================================================
;======================= Chars ==============================
;============================================================

public lostanza defn digit? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= '0' and b <= '9' : return true
   else : return false

public lostanza defn letter? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'a' and b <= 'z' : return true
   else if b >= 'A' and b <= 'Z' : return true
   else : return false

public lostanza defn upper-case? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'A' and b <= 'Z' : return true
   else : return false

public lostanza defn lower-case? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'a' and b <= 'z' : return true
   else : return false

public lostanza defn lower-case (c:ref<Char>) -> ref<Char> :
   val cv = c.value
   if cv >= 'A' and cv <= 'Z' : return new Char{cv - 'A' + 'a'}
   else : return c

public lostanza defn upper-case (c:ref<Char>) -> ref<Char> :
   val cv = c.value
   if cv >= 'a' and cv <= 'z' : return new Char{cv - 'a' + 'A'}
   else : return c

;============================================================
;===================== Tuples ===============================
;============================================================

protected lostanza defn void-tuple (n:long) -> ref<Tuple> :
  val x = new Tuple{n}
  for (var i:long = 0, i < n, i = i + 1) :
    x.items[i] = sentinel
  return x

public lostanza defn Tuple<?T> (n:ref<Int>, x:ref<?T>) -> ref<Tuple<T>> :
   ensure-non-negative-length(n)
   val len = n.value
   val t = new Tuple<T>{len}
   for (var i:long = 0, i < len, i = i + 1) :
      t.items[i] = x
   return t

lostanza defn set<?T> (x:ref<Tuple<?T>>, i:ref<Int>, v:ref<T>) -> ref<False> :
   ensure-index-in-bounds(x, i)
   x.items[i.value] = v
   return false

public lostanza defn get<?T> (x:ref<Tuple<?T>>, i:ref<Int>) -> ref<T> :
   ensure-index-in-bounds(x, i)
   return x.items[i.value]

public defn get<?T> (xs:Tuple<?T>, r:Range) -> Tuple<T> :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])

public defn empty? (t:Tuple) :
   length(t) == 0

public defn map<?T,?R> (f:T -> ?R, xs:Tuple<?T>) -> Tuple<R> :
   to-tuple(seq(f, xs))

;============================================================
;===================== Strings ==============================
;============================================================

public lostanza defn String (chars:ptr<byte>) -> ref<String> :
  val len = call-c clib/strlen(chars)
  return String(len, chars)

public lostanza defn String (len:long, c:byte) -> ref<String> :
  val s = String(len)
  for (var i:long = 0, i < len, i = i + 1) :
    s.chars[i] = c
  s.chars[len] = 0 as byte
  return s

public lostanza defn String (len:ref<Int>, c:ref<Char>) -> ref<String> :
  ensure-non-negative-length(len)
  return String(len.value, c.value)

public lostanza defn get (s:ref<String>, i:ref<Int>) -> ref<Char> :
  ensure-index-in-bounds(s, i)
  return new Char{s.chars[i.value]}

lostanza defn set (s:ref<String>, i:ref<Int>, c:ref<Char>) -> ref<False> :
  ensure-index-in-bounds(s, i)
  s.chars[i.value] = c.value
  return false

lostanza defn copy-string (s:ref<String>) -> ref<String> :
  return String(s.length, addr!(s.chars))

;============================================================
;======================= String Library =====================
;============================================================

lostanza defn strlen (s:ref<String>) -> long :
  return s.length - 1

lostanza defn copy (dst:ref<String>, src:ref<String>, dst-i:long) -> ref<False> :
   val src-len = strlen(src)
   call-c clib/memcpy(addr!(dst.chars[dst-i]), addr!(src.chars), src-len)
   return false

public defn matches? (a:String, start:Int, b:String) :
   ensure-length-in-bounds(a, start)
   val an = length(a)
   val bn = length(b)
   if (start + bn) <= an :
      for i in 0 to bn all? :
         a[start + i] == b[i]

public defn prefix? (s:String, prefix:String) :
   matches?(s, 0, prefix)

public defn suffix? (s:String, suffix:String) :
   val start = max(0, length(s) - length(suffix))
   matches?(s, start, suffix)

public defn empty? (s:String) :
   length(s) == 0

lostanza defn substring! (str:ref<String>, b:ref<Int>, e:ref<Int>) -> ref<String> :
   val s = b.value
   val n = e.value - s
   val ret = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      ret.chars[i] = str.chars[i + s]
   ret.chars[n] = 0 as byte
   return ret

public defn get (s:String, r:Range) -> String :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   substring!(s, b, e)

public lostanza defn append (a:ref<String>, b:ref<String>) -> ref<String> :
   val al = strlen(a)
   val bl = strlen(b)
   val n = al + bl
   val s = String(n)
   copy(s, a, 0)
   copy(s, b, al)
   s.chars[n] = 0 as byte
   return s

public lostanza defn append-all (xs:ref<Seqable<String>>) -> ref<String> :
   match(xs) :
      (xs:ref<Collection<String>>) :
         val len = sum(seq(fn(length), xs))
         val ret = String(len.value)
         val xs-seq = to-seq(xs)
         var accum : long = 0
         while empty?(xs-seq) == false :
            val s = next(xs-seq)
            copy(ret, s, accum)
            accum = accum + strlen(s)
         ret.chars[len.value] = 0 as byte
         return ret
      (xs:ref<Seqable<String>>) :
         return append-all(to-vector<String>(xs))

public defn string-join (xs:Seqable) -> String :
   val s = StringBuffer()
   print-all(s, xs)
   to-string(s)

public defn string-join (xs:Seqable, j) -> String :
   string-join(join(xs, j))

public defn index-of-char (s:String, r:Range, c:Char) -> False|Int :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   for i in b to e find :
      s[i] == c

public defn index-of-char (s:String, c:Char) -> False|Int :
   index-of-char(s, 0 to false, c)

public defn index-of-chars (a:String, r:Range, b:String) -> False|Int :
   ensure-index-range(a, r)
   val [s, e] = range-bound(a, r)
   val an = e - s
   val bn = length(b)
   if bn <= an :
      for i in s through (e - bn) find :
         matches?(a, i, b)

;Returns the index at which b occurs within a.
public defn index-of-chars (a:String, b:String) -> False|Int :
   index-of-chars(a, 0 to false, b)

;Returns true if b is a substring of a.
public defn substring? (a:String, b:String) -> True|False :
  index-of-chars(a, b) is Int

;Returns true if b is a substring of the given range within a.
public defn substring? (a:String, r:Range, b:String) -> True|False :
  index-of-chars(a, r, b) is Int

public defn last-index-of-char (s:String, r:Range, c:Char) -> False|Int :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   for i in (e - 1) through b by -1 find :
      s[i] == c

public defn last-index-of-char (s:String, c:Char) -> False|Int :
   last-index-of-char(s, 0 to false, c)

public defn last-index-of-chars (a:String, r:Range, b:String) -> False|Int :
   ensure-index-range(a, r)
   val [s, e] = range-bound(a, r)
   val an = e - s
   val bn = length(b)
   if bn <= an :
      for i in (e - bn) through s by -1 find :
         matches?(a, i, b)

public defn last-index-of-chars (a:String, b:String) -> False|Int :
   last-index-of-chars(a, 0 to false, b)

public defn replace (s:String, i:Int, c:Char) -> String :
  val s2 = copy-string(s)
  s2[i] = c
  s2

public lostanza defn replace (s:ref<String>, c1:ref<Char>, c2:ref<Char>) -> ref<String> :
   val b1 = c1.value
   val b2 = c2.value
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc == b1 : r.chars[i] = b2
      else : r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public defn replace (str:String, s1:String, s2:String) -> String :
   fatal("String to be replaced cannot be empty.") when empty?(s1)
   val buf = StringBuffer(length(str))
   val n = length(str)
   val s1n = length(s1)
   defn* loop (i:Int) :
      if i < n :
         if matches?(str, i, s1) :
            print(buf, s2)
            loop(i + s1n)
         else :
            print(buf, str[i])
            loop(i + 1)
   loop(0)
   to-string(buf)

public defn split (str:String, s:String) -> Seq<String> :
  generate<String> :
    val sl = length(s)
    defn loop (b:Int) :
      match(index-of-chars(str, b to false, s)) :
        (i:Int) :
          yield(str[b to i])
          loop(i + sl)
        (i:False) :
          yield(str[b to false])
    loop(0)

public defn split (str:String, s:String, n:Int) -> Seq<String> :
  if n <= 0 :
    fatal("Maximum number of splits (%_) is not positive." % [n])
  generate<String> :
    val sl = length(s)
    defn* loop (b:Int, n:Int) :
      if n > 1 :
        match(index-of-chars(str, b to false, s)) :
          (i:Int) :
            yield(str[b to i])
            loop(i + sl, n - 1)
          (i:False) :
            yield(str[b to false])
      else :
        yield(str[b to false])
    loop(0, n)

public lostanza defn lower-case (s:ref<String>) -> ref<String> :
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc >= 'A' and sc <= 'Z' :
         r.chars[i] = sc - 'A' + 'a'
      else :
         r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public lostanza defn upper-case (s:ref<String>) -> ref<String> :
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc >= 'a' and sc <= 'z' :
         r.chars[i] = sc - 'a' + 'A'
      else :
         r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public defn trim (pred: Char -> True|False, s:String) :
   defn not-pred (c:Char) : not pred(c)
   match(index-when(not-pred, s)) :
      (i:Int) :
         val n = length(s)
         val j = for i in (n - 1) through 0 by -1 find! :
            not-pred(s[i])
         s[i through j]
      (i:False) : ""

public defn trim (s:String) -> String :
   defn whitespace? (c:Char) :
      (c == ' ') or
      (c == '\n') or
      (c == '\t') or
      (c == '\b') or
      (c == '\r')
   trim(whitespace?, s)

;============================================================
;======================= Lists ==============================
;============================================================

public defn cons<?T> (x:?T, y:?T, t:List<?T>) -> List<T> :
   cons(x, cons(y, t))

public defn cons<?T> (x:?T, y:?T, z:?T, t:List<?T>) -> List<T> :
   cons(x, cons(y, cons(z, t)))

public defn List<?T> (x:?T) -> List<T> :
   cons(x, List())

public defn List<?T> (x:?T, y:?T) -> List<T> :
   cons(x, cons(y, List()))

public defn List<?T> (x:?T, y:?T, z:?T) -> List<T> :
   cons(x, cons(y, cons(z, List())))

public defn List<?T> (w:?T, x:?T, y:?T, z:?T) -> List<T> :
   cons(w, cons(x, cons(y, cons(z, List()))))

;============================================================
;====================== List Library ========================
;============================================================

public defn* get<?T> (xs:List<?T>, i:Int) -> T :
   if i == 0 : head(xs)
   else : get(tail(xs), i - 1)

public defn headn<?T> (l:List<?T>, n:Int) -> List<T> :
   if n == 0 : List()
   else : cons(head(l), headn(tail(l), n - 1))

public defn* tailn<?T> (l:List<?T>, n:Int) -> List<T> :
   if n == 0 : l
   else : tailn(tail(l), n - 1)

public defn append<?T> (xs:Seqable<?T>, ys:List<?T>) -> List<T> :
   if empty?(ys) :
      to-list(xs)
   else :
      val items = to-vector<T>(xs)
      defn* loop (i:Int, tail:List<T>) :
         if i >= 0 : loop(i - 1, cons(items[i], tail))
         else : tail
      loop(length(items) - 1, ys)

public defn append-all<?T> (xs:Seqable<List<?T>>) -> List<T> :
   val xs-seq = to-seq(xs)
   defn loop () :
      if empty?(xs-seq) : List()
      else : append(next(xs-seq), loop())
   loop()

public defn seq-append<?T,?R> (f: T -> List<?R>, xs:Seqable<?T>) -> List<R> :
   append-all(seq(f, xs))

public defn seq-append<?T,?S,?R> (f: (T,S) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> List<R> :
   append-all(seq(f, xs, ys))

public defn seq-append<?T,?S,?U,?R> (f: (T,S,U) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R> :
   append-all(seq(f, xs, ys, zs))

public defn map<?T,?R> (f: T -> ?R, xs:List<?T>) -> List<R> :
  let loop (xs:List<T> = xs, i:Int = 0) :
    if i < 16 :
      if empty?(xs) : List()
      else : cons(f(head(xs)), loop(tail(xs), i + 1))
    else : to-list(seq(f, xs))

public defn map<?T,?S,?R> (f: (T,S) -> ?R, xs:List<?T>, ys:Seqable<?S>) -> List<R> :
   to-list(seq(f, xs, ys))

public defn map<?T,?S,?U,?R> (f: (T,S,U) -> ?R, xs:List<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R> :
   to-list(seq(f, xs, ys, zs))

public defn transpose<?T> (xs:List<List<?T>>) -> List<List<T>> :
   if empty?(xs) :
      List()
   else if any?(empty?, xs) :
      List()
   else :
      val hs = map(head, xs)
      val ts = map(tail, xs)
      cons(hs, transpose(ts))

public defn last<?T> (xs:List<?T>) -> T :
   fatal("Empty List") when empty?(xs)
   defn* loop (xs:List<T>) :
      if empty?(tail(xs)) : head(xs)
      else : loop(tail(xs))
   loop(xs)

public defn but-last<?T> (xs:List<?T>) -> List<T> :
   fatal("Empty List") when empty?(xs)
   defn* loop (xs:List<T>) :
      if empty?(tail(xs)) : List()
      else : cons(head(xs), but-last(tail(xs)))
   loop(xs)

public defn reverse<?T> (xs:List<?T>) -> List<T> :
   if empty?(xs) :
      xs
   else :
      var accum = List()
      for x in xs do :
         accum = cons(x, accum)
      accum

;============================================================
;====================== Formatting ==========================
;============================================================

public deftype Printable

public defn modulo (format:String, args:Seqable) -> Printable :
  new Printable :
    defmethod* print (o:OutputStream, this) :
      val seq = to-seq(args)
      defn next-arg () :
        #if-not-defined(OPTIMIZE) :
          fatal("Format string %~ is expecting more arguments." % [format]) when empty?(seq)
        next(seq)
      defn next-seq () :
        val x = next-arg()
        #if-not-defined(OPTIMIZE) :
          if x is-not Seqable :
            fatal("Format string %~ is expecting a sequence, but received: %~." % [format, x])
        x

      val n = length(format)
      defn* loop (i:Int) :
        if i < n :
          val c = format[i]
          if c == '%' :
            if i + 1 < n :
              val modifier = format[i + 1]
              switch {modifier == _} :
                '_' : print(o, next-arg())
                '*' : print-all(o, next-seq())
                ',' : print-all(o, join(next-seq(), ", "))
                's' : print-all(o, join(next-seq(), " "))
                'n' : print-all(o, join(next-seq(), "\n"))
                '~' : write(o, next-arg())
                '@' : write-all(o, next-seq())
                '%' : print(o, c)
                else : fatal("Invalid argument specifier %~ in format string %~." % [modifier, format])
              loop(i + 2)
            else :
              fatal("Incomplete argument specifier %% at end of format string %~." % [format])
          else :
            print(o, c)
            loop(i + 1)
        else :
          if not empty?(seq) :
            fatal("Unexpected end of format string %~. More arguments remaining." % [format])
      loop(0)

;============================================================
;=================== Indented Streams =======================
;============================================================

public deftype IndentedStream <: OutputStream
public defmulti stream (s:IndentedStream) -> OutputStream
public defmulti indent (s:IndentedStream) -> Int

public defn IndentedStream (o:OutputStream) :
  IndentedStream(o, 2)

public defn IndentedStream (o:OutputStream, n:Int) :
  match(o) :
    (o:IndentedStream) :
      IndentedStream(stream(o), n + indent(o))
    (o) :
      var start-of-line? = true
      val spaces = String(n, ' ')
      defn put (c:Char) :
        if c == '\n' :
          print(o, c)
          start-of-line? = true
        else :
          print(o, spaces) when start-of-line?
          print(o, c)
          start-of-line? = false
      new IndentedStream :
        defmethod stream (this) : o
        defmethod indent (this) : n
        defmethod print (this, c:Char) : put(c)

public deftype Indented
public defmulti item (x:Indented) -> ?
public defmulti indent (x:Indented) -> Int

public defn Indented (item, indent:Int) -> Indented :
  fatal("Indent (%_) is not positive." % [indent]) when indent <= 0
  match(item:Indented) :
    Indented(/item(item), /indent(item) + indent)
  else :
    new Indented :
      defmethod item (this) : item
      defmethod indent (this) : indent

public defn Indented (item) :
  Indented(item, 2)

defmethod print (o:OutputStream, x:Indented) :
  print(IndentedStream(o, indent(x)), item(x))

public defn do-indented<?T> (f: IndentedStream -> ?T, o:OutputStream) :
   f(IndentedStream(o))

public defn indented<?T> (f: () -> ?T) -> T :
  val stream = current-output-stream()
  var result:T
  val obj = new Printable :
    defmethod print (o:OutputStream, this) :
      result = with-output-stream(o, f)
      false
  print(stream, Indented(obj))
  result

;============================================================
;===================== Generators ===========================
;============================================================

public defn Generator<T> (thunk : (T -> False, (T -> Void) & (() -> Void)) -> ?) -> Seq<T> :
   ;State
   var item = sentinel

   ;Generator Coroutine
   val co = Coroutine<False, T|Sentinel> $ fn (co, x0) :
      defn co-yield (x:T) :
         suspend(co, x)
      val co-break = multifn :
         (x:T) : break(co, x)
         () : break(co, sentinel)
      thunk(co-yield, co-break)
      sentinel

   ;Fill state: Returns whether empty
   defn fill () :
      if (item is Sentinel) and open?(co) :
         item = resume(co, false)
      item is Sentinel

   ;Peek
   defn peek () :
      if item is Sentinel :
         fatal("Empty Sequence")
      item as T

   ;Empty bucket
   defn empty () :
      val x = peek()
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         peek()
      defmethod empty? (this) :
         fill()
      defmethod free (this) :
         close(co) when open?(co)

;============================================================
;====================== Labels ==============================
;============================================================

public defn* LabeledScope<T> (thunk: (T -> Void) -> T) -> T :
   val c = Coroutine<False,T> $ fn* (c, x0) :
      thunk(break{c, _})
   resume(c, false)

public defn* LabeledScope* (thunk: (() -> Void) -> ?) -> False :
   val c = Coroutine<False,False> $ fn* (c, x0) :
      thunk(fn () : break(c, false))
      false
   resume(c, false)

;============================================================
;================== Failure Handler =========================
;============================================================

var CURRENT-FAILURE-HANDLER : () -> Void =
   fn () :
      fatal("Uncaught failure")

public defn fail () :
   CURRENT-FAILURE-HANDLER()

public defn with-attempt<?T> (conseq: () -> ?T, alt: () -> ?T) :
   val result = label<Maybe<T>> return :
      let-var CURRENT-FAILURE-HANDLER = fn* () : return(None()) :
         One(conseq())
   match(result) :
      (r:One<T>) : value(r)
      (r:None) : alt()

;============================================================
;=================== IndexedCollections =====================
;============================================================

public deftype IndexedCollection<T> <: Lengthable

;                       Interface
;                       =========

public defmulti get<?T> (a:IndexedCollection<?T>, i:Int) -> T
public defmulti set<?T> (a:IndexedCollection<?T>, i:Int, v:T) -> False
public defmulti get<?T> (a:IndexedCollection<?T>, r:Range) -> Collection<T>
public defmulti set<?T> (a:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False
public defmulti set-all<?T> (a:IndexedCollection<?T>, r:Range, v:T) -> False
public defmulti map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False

;                 Abstract Implementations
;                 ========================

public defn empty? (v:IndexedCollection) :
   length(v) == 0

defmethod print (o:OutputStream, a:IndexedCollection) -> False :
   print(o, "[%@]" % [a])

defmethod map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False :
   for i in 0 to length(xs) do :
      xs[i] = f(xs[i])

defmethod get<?T> (xs:IndexedCollection<?T>, r:Range) -> Tuple<T> :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])

defmethod set<?T> (xs:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   val vs-seq = to-seq(vs)
   for i in b to e do : xs[i] = next(vs-seq)

defmethod set-all<?T> (xs:IndexedCollection<?T>, r:Range, v:T) -> False :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   for i in b to e do : xs[i] = v

public defn reverse!<?T> (xs:IndexedCollection<?T>) -> False :
   val n = length(xs)
   for i in 0 to n / 2 do :
      val j = n - 1 - i
      val xi = xs[i]
      val xj = xs[j]
      xs[i] = xj
      xs[j] = xi

;                       Sorting
;                       =======

public defn qsort!<?T> (xs:IndexedCollection<?T>, is-less?:(T,T) -> True|False) -> False :
   ;Random
   val rand = Random(0L)

   ;Swap element i with element j
   defn swap (i:Int, j:Int) :
      if i != j :
         val xi = xs[i]
         val xj = xs[j]
         xs[i] = xj
         xs[j] = xi

   ;Rearrange elements from b to e, such that the first elements is less than pivot.
   ;Returns a s.t. all elements from b to a are less than pivot.
   defn partition (b:Int, e:Int, pivot:T) :
      defn* loop (a:Int, b:Int) -> Int :
         if b < e :
            val xb = xs[b]
            if is-less?(xb, pivot) :
               swap(a, b)
               loop(a + 1, b + 1)
            else : loop(a, b + 1)
         else : a
      loop(b, b)

   ;Driver
   defn* sort (b:Int, e:Int) :
      val n = e - b
      if n > 2 :
         swap(next-int(rand,b to e), e - 1) when n > 10
         val e1 = partition(b, e - 1, xs[e - 1])
         swap(e1, e - 1)
         sort(b, e1)
         sort(e1 + 1, e)
      else if n == 2 :
         swap(b, b + 1) when is-less?(xs[b + 1], xs[b])

   sort(0, length(xs))

public defn qsort!<?T> (xs:IndexedCollection<?T>, cmp:(T,T) -> Int) -> False :
   ;Random
   val rand = Random(0L)

   ;Swap element i with element j
   defn swap (i:Int, j:Int) :
      if i != j :
         val xi = xs[i]
         val xj = xs[j]
         xs[i] = xj
         xs[j] = xi

   ;Rearrange elements from b to e, such that:
   ;   b to lt is less than v
   ;   lt to gt is equal to v
   ;   gt to e is greater than v
   ;Returns [lt, gt]
   defn partition (b:Int, e:Int, pivot:T) -> [Int, Int] :
      defn* loop (lt:Int, gt:Int, i:Int) :
         if i < gt :
            val c = cmp(xs[i], pivot)
            if c < 0 :
               swap(i, lt)
               loop(lt + 1, gt, i + 1)
            else if c > 0 :
               swap(i, gt - 1)
               loop(lt, gt - 1, i)
            else :
               loop(lt, gt, i + 1)
         else :
            [lt, gt]
      loop(b, e, b)

   ;Driver
   defn* sort (b:Int, e:Int) :
      val n = e - b
      if n > 2 :
         val [lt, gt] = partition(b, e, xs[next-int(rand, b to e)])
         sort(b, lt)
         sort(gt, e)
      else if n == 2 :
         swap(b, b + 1) when cmp(xs[b + 1], xs[b]) < 0

   sort(0, length(xs))

public defn qsort!<?T> (xs:IndexedCollection<?T&Comparable<T>>) -> False :
   qsort!(xs, compare)

public defn qsort!<?T,?S> (key:T -> ?S&Comparable<S>, xs:IndexedCollection<?T>) -> False :
   qsort!(xs, compare{key(_), key(_)})

;                        Non-Destructive Sorting
;                        =======================

public defn qsort<?T> (coll:Seqable<?T>, is-less?:(T,T) -> True|False) -> Tuple<T> :
  val buffer = to-vector<T>(coll)
  qsort!(buffer, is-less?)
  to-tuple(buffer)

public defn qsort<?T> (coll:Seqable<?T>, cmp:(T,T) -> Int) -> Tuple<T> :
  val buffer = to-vector<T>(coll)
  qsort!(buffer, cmp)
  to-tuple(buffer)

public defn qsort<?T> (coll:Seqable<?T&Comparable<T>>) -> Tuple<T> :
  val buffer = to-vector<Comparable>(coll)
  qsort!(buffer)
  to-tuple(buffer) as Tuple<T&Comparable>

public defn qsort<?T,?S> (key:T -> ?S&Comparable<S>, coll:Seqable<?T>) -> Tuple<T> :
  val buffer = to-vector<T>(coll)
  qsort!({key(_) as Comparable}, buffer)
  to-tuple(buffer)

;                       Lazy Sorting
;                       ============

public defn lazy-qsort<?T> (coll:Seqable<?T>, is-less?:(T,T) -> True|False) -> Collection<T> & Lengthable :
   ;Random
   val rand = Random(0L)

   ;Convert to a vector
   val xs = to-vector<T>(coll)

   ;Sort Progress
   defn sort-progress () :
      generate<Int> :
         ;Swap element i with element j
         defn swap (i:Int, j:Int) :
            if i != j :
               val xi = xs[i]
               val xj = xs[j]
               xs[i] = xj
               xs[j] = xi

         ;Rearrange elements from b to e, such that the first elements is less than pivot.
         ;Returns a s.t. all elements from b to a are less than pivot.
         defn partition (b:Int, e:Int, pivot:T) :
            defn* loop (a:Int, b:Int) -> Int :
               if b < e :
                  val xb = xs[b]
                  if is-less?(xb, pivot) :
                     swap(a, b)
                     loop(a + 1, b + 1)
                  else : loop(a, b + 1)
               else : a
            loop(b, b)

         ;Driver
         defn* sort (b:Int, e:Int) :
            val n = e - b
            if n > 2 :
               swap(next-int(rand, b to e), e - 1) when n > 10
               val e1 = partition(b, e - 1, xs[e - 1])
               swap(e1, e - 1)
               sort(b, e1)
               yield(e1 + 1)
               sort(e1 + 1, e)
            else if n == 2 :
               swap(b, b + 1) when is-less?(xs[b + 1], xs[b])

         sort(0, length(xs))
         break(length(xs))

   ;Ensuring Progress
   var sorted = 0
   val sorter = sort-progress()
   defn* ensure-sorted (n:Int) :
      if sorted < n :
         sorted = next(sorter)
         ensure-sorted(n)

   ;Return object
   new Collection<T> & Lengthable :
      defmethod length (this) :
         length(xs)
      defmethod to-seq (this) :
         for i in 0 to length(xs) seq :
            ensure-sorted(i + 1)
            xs[i]


public defn lazy-qsort<?T> (coll:Seqable<?T>, cmp:(T,T) -> Int) -> Collection<T> & Lengthable :
   ;Random
   val rand = Random(0L)

   ;Convert to a vector
   val xs = to-vector<T>(coll)

   ;Sort Progress
   defn sort-progress () :
      generate<Int> :
         ;Swap element i with element j
         defn swap (i:Int, j:Int) :
            if i != j :
               val xi = xs[i]
               val xj = xs[j]
               xs[i] = xj
               xs[j] = xi

         ;Rearrange elements from b to e, such that:
         ;   b to lt is less than v
         ;   lt to gt is equal to v
         ;   gt to e is greater than v
         ;Returns [lt, gt]
         defn partition (b:Int, e:Int, pivot:T) -> [Int, Int] :
            defn* loop (lt:Int, gt:Int, i:Int) :
               if i < gt :
                  val c = cmp(xs[i], pivot)
                  if c < 0 :
                     swap(i, lt)
                     loop(lt + 1, gt, i + 1)
                  else if c > 0 :
                     swap(i, gt - 1)
                     loop(lt, gt - 1, i)
                  else :
                     loop(lt, gt, i + 1)
               else :
                  [lt, gt]
            loop(b, e, b)

         ;Driver
         defn* sort (b:Int, e:Int) :
            val n = e - b
            if n > 2 :
               val [lt, gt] = partition(b, e, xs[next-int(rand,b to e)])
               sort(b, lt)
               yield(gt)
               sort(gt, e)
            else if n == 2 :
               swap(b, b + 1) when cmp(xs[b + 1], xs[b]) < 0

         sort(0, length(xs))
         break(length(xs))

   ;Ensuring Progress
   var sorted = 0
   val sorter = sort-progress()
   defn* ensure-sorted (n:Int) :
      if sorted < n :
         sorted = next(sorter)
         ensure-sorted(n)

   ;Return object
   new Collection<T> & Lengthable :
      defmethod length (this) :
         length(xs)
      defmethod to-seq (this) :
         for i in 0 to length(xs) seq :
            ensure-sorted(i + 1)
            xs[i]

public defn lazy-qsort<?T> (coll:Seqable<?T&Comparable<T>>) :
   lazy-qsort(coll, compare)

public defn lazy-qsort<?T,?S> (key:T -> ?S&Comparable<S>, coll:Seqable<?T>) :
   lazy-qsort(coll, compare{key(_), key(_)})

;============================================================
;======================= Arrays =============================
;============================================================

public deftype Array<T> <: IndexedCollection<T> & Unique

;                     Implementation
;                     ==============

lostanza deftype RawArray<T> <: Array<T> :
   length: long
   var items: ref<?> ...

lostanza defn RawArray<T> (n:ref<Int>, x:ref<?>) -> ref<RawArray<T>> :
   val l = n.value
   val a = new RawArray<T>{l}
   for (var i:long = 0, i < l, i = i + 1) :
      a.items[i] = x
   return a

lostanza defmethod get<?T> (a:ref<RawArray<?T>>, i:ref<Int>) -> ref<T> :
  return a.items[i.value]

lostanza defmethod set<?T> (a:ref<RawArray<?T>>, i:ref<Int>, v:ref<?T>) -> ref<False> :
  a.items[i.value] = v
  return false

lostanza defmethod set-all<?T> (xs:ref<RawArray<?T>>, r:ref<Range>, v:ref<?T>) -> ref<False> :
   val range = range-bound(xs, r) as ref<Tuple<Int>>
   val b = range.items[0].value
   val e = range.items[1].value
   for (var i:long = b, i < e, i = i + 1) :
      xs.items[i] = v
   return false

lostanza defmethod length (a:ref<RawArray>) -> ref<Int> :
   return new Int{a.length as int}

defmethod print (o:OutputStream, a:RawArray) -> False :
   print(o, "[%@]" % [a])

;                     Wrapping
;                     ========

#if-defined(OPTIMIZE) :

   public defn Array<T> (n:Int) -> RawArray<T> :
      RawArray<T>(n, sentinel)

   public defn Array<T> (n:Int, x:T) -> RawArray<T> :
      RawArray<T>(n, x)

#else :

   deftype WrappedArray<T> <: Array<T>

   public defn Array<T> (n:Int) -> Array<T> :
      ensure-non-negative("length", n)
      Array<T>(RawArray<T>(n, sentinel))

   public defn Array<T> (n:Int, x:T) -> Array<T> :
      ensure-non-negative("length", n)
      Array<T>(RawArray<T>(n, x))

   defn Array<T> (a:RawArray) -> Array<T> :
      new WrappedArray<T> :
         defmethod get (this, i:Int) :
            ensure-index-in-bounds(a, i)
            match(a[i]) :
               (v:Sentinel) : fatal("Index (%_) is uninitialized." % [i])
               (v) : v
         defmethod set (this, i:Int, v:T) :
            ensure-index-in-bounds(a, i)
            a[i] = v
         defmethod set-all (this, r:Range, v:T) :
            ensure-index-range(a, r)
            set-all(a, r, v)
         defmethod length (this) :
            length(a)
         defmethod print (o:OutputStream, this) :
            print(o, a)

public defn map<R,?T> (f: T -> R, xs:Array<?T>) -> Array<R> :
   val ret = Array<R>(length(xs))
   for (x in xs, i in 0 to false) do :
      ret[i] = f(x)
   ret

;============================================================
;==================== Primitive Arrays ======================
;============================================================

#for (Prim in [Byte Int Long Float Double]
      prim in [byte int long float double]
      PrimArray in [ByteArray IntArray LongArray FloatArray DoubleArray]
      x0 in [0Y 0 0L 0.0F 0.0]) :

  ;                     Declaration
  ;                     ===========
  public lostanza deftype PrimArray <: Array<Prim> :
    length: long
    var data: prim ...

  ;                     Implementation
  ;                     ==============
  public lostanza defn PrimArray (n:ref<Int>, x:ref<Prim>) -> ref<PrimArray> :
    ensure-non-negative-length(n)
    val l = n.value
    val a = new PrimArray{l}
    val xv = x.value
    for (var i:long = 0, i < l, i = i + 1) :
      a.data[i] = xv
    return a

  public defn PrimArray (n:Int) -> PrimArray :
    PrimArray(n, x0)

  lostanza defmethod get (a:ref<PrimArray>, i:ref<Int>) -> ref<Prim> :
    ensure-index-in-bounds(a, i)
    return new Prim{a.data[i.value]}

  lostanza defmethod set (a:ref<PrimArray>, i:ref<Int>, x:ref<Prim>) -> ref<False> :
    ensure-index-in-bounds(a, i)
    a.data[i.value] = x.value
    return false

  lostanza defmethod length (a:ref<PrimArray>) -> ref<Int> :
    return new Int{a.length as int}

  lostanza defmethod get (a:ref<PrimArray>, r:ref<Range>) -> ref<PrimArray> :
    ensure-index-range(a, r)
    val rb = range-bound(a, r)
    val b = get(rb, new Int{0}).value
    val e = get(rb, new Int{1}).value
    val len = e - b
    val ret = new PrimArray{len}
    for (var i:long = 0, i < len, i = i + 1) :
      ret.data[i] = a.data[i + b]
    return ret

  lostanza defmethod set (a:ref<PrimArray>, r:ref<Range>, xs:ref<PrimArray>) -> ref<False> :
    ensure-index-range(a, r)
    val rb = range-bound(a, r)
    val b = get(rb, new Int{0}).value
    val e = get(rb, new Int{1}).value
    val len = e - b
    #if-not-defined(OPTIMIZE) :
      ensure-len-le-xs(new Int{len}, xs)
    for (var i:long = 0, i < len, i = i + 1) :
      a.data[i + b] = xs.data[i]
    return false
  defn ensure-len-le-xs (len:Int, xs:PrimArray) :
    if len > length(xs) :
      fatal("Length of range (%_) is greater than length of values array (%_)." % [
        len, length(xs)])

;============================================================
;==================== CharArrays ============================
;============================================================

public lostanza deftype CharArray <: Array<Char> :
  length: long
  var chars: byte ...

;                     Implementation
;                     ==============

public lostanza defn CharArray (n:ref<Int>, x:ref<Char>) -> ref<CharArray> :
   ensure-non-negative-length(n)
   val l = n.value
   val a = new CharArray{l}
   val c = x.value
   for (var i:long = 0, i < l, i = i + 1) :
      a.chars[i] = c
   return a

public defn CharArray (n:Int) -> CharArray :
   CharArray(n, ' ')

lostanza defmethod get (a:ref<CharArray>, i:ref<Int>) -> ref<Char> :
  ensure-index-in-bounds(a, i)
  return new Char{a.chars[i.value]}

lostanza defmethod set (a:ref<CharArray>, i:ref<Int>, v:ref<Char>) -> ref<False> :
  ensure-index-in-bounds(a, i)
  a.chars[i.value] = v.value
  return false

lostanza defmethod length (a:ref<CharArray>) -> ref<Int> :
   return new Int{a.length as int}

lostanza defn substring! (a:ref<CharArray>, b:ref<Int>, e:ref<Int>) -> ref<String> :
   val len = e.value - b.value
   val start = b.value
   val s = String(len)
   for (var i:long = 0, i < len, i = i + 1) :
      s.chars[i] = a.chars[i + start]
   s.chars[len] = 0 as byte
   return s

defmethod get (a:CharArray, r:Range) -> String :
   ensure-index-range(a, r)
   val [b, e] = range-bound(a, r)
   substring!(a, b, e)

;                     Looping
;                     =======

defmethod do (f: Char -> ?, xs:CharArray) :
   val n = length(xs)
   let loop (i:Int = 0) :
      if i < n :
         f(xs[i])
         loop(i + 1)

;============================================================
;==================== Block Copying =========================
;============================================================

public defmulti block-copy<?T> (n:Int, dst:IndexedCollection<?T>, di:Int, src:IndexedCollection<T>, si:Int) -> False

defmethod block-copy<?T> (n:Int, dst:IndexedCollection<?T>, di:Int, src:IndexedCollection<T>, si:Int) :
  ensure-block-copy-preconditions(n, dst, di, src, si)
   for i in 0 to n do :
      dst[di + i] = src[si + i]

lostanza defmethod block-copy (ref-n:ref<Int>, dst:ref<RawArray>, ref-di:ref<Int>, src:ref<RawArray>, ref-si:ref<Int>) -> ref<False> :
  ensure-block-copy-preconditions(ref-n, dst, ref-di, src, ref-si)
  val dst-ptr = addr!(dst.items)
  val src-ptr = addr!(src.items)
  val di = ref-di.value
  val si = ref-si.value
  val n = ref-n.value
  call-c clib/memcpy(addr!(dst-ptr[di]), addr!(src-ptr[si]), n * sizeof(ref<?>))
  return false

defmethod block-copy (n:Int, dst:ByteBuffer, di:Int, src:ByteBuffer, si:Int) :
  ensure-block-copy-preconditions(n, dst, di, src, si)
  block-copy(n, backing-array(dst), di, backing-array(src), si)

#for (PrimArray in [ByteArray IntArray LongArray FloatArray DoubleArray]
      prim in [byte int long float double]) :
  lostanza defmethod block-copy (ref-n:ref<Int>, dst:ref<PrimArray>, ref-di:ref<Int>, src:ref<PrimArray>, ref-si:ref<Int>) -> ref<False> :
    ensure-block-copy-preconditions(ref-n, dst, ref-di, src, ref-si)
    val dst-ptr = addr!(dst.data)
    val src-ptr = addr!(src.data)
    val di = ref-di.value
    val si = ref-si.value
    val n = ref-n.value
    call-c clib/memcpy(addr!(dst-ptr[di]), addr!(src-ptr[si]), n * sizeof(prim))
    return false

defn ensure-block-copy-preconditions (n:Int, dst:IndexedCollection, di:Int, src:IndexedCollection, si:Int) :
  #if-not-defined(OPTIMIZE) :
    ensure-non-negative("number of elements", n)
    ensure-non-negative("destination index", di)
    ensure-non-negative("source index", si)
    if length(dst) < di + n : fatal("Attempt to write past bounds of destination collection.")
    if length(src) < si + n : fatal("Attempt to read past bounds of source collection.")
  false

;============================================================
;==================== Conversions ===========================
;============================================================

;                 Numeric Conversions
;                 ===================

public lostanza defn to-byte (b:ref<Byte>) -> ref<Byte> : return b
public lostanza defn to-byte (c:ref<Char>) -> ref<Byte> : return new Byte{c.value}
public lostanza defn to-byte (i:ref<Int>) -> ref<Byte> : return new Byte{i.value as byte}
public lostanza defn to-byte (l:ref<Long>) -> ref<Byte> : return new Byte{l.value as byte}
public lostanza defn to-byte (f:ref<Float>) -> ref<Byte> : return new Byte{f.value as byte}
public lostanza defn to-byte (d:ref<Double>) -> ref<Byte> : return new Byte{d.value as byte}
public lostanza defn to-char (b:ref<Byte>) -> ref<Char> : return new Char{b.value}
public lostanza defn to-char (c:ref<Char>) -> ref<Char> : return c
public lostanza defn to-char (i:ref<Int>) -> ref<Char> : return new Char{i.value as byte}
public lostanza defn to-int (b:ref<Byte>) -> ref<Int> : return new Int{b.value}
public lostanza defn to-int (c:ref<Char>) -> ref<Int> : return new Int{c.value}
public lostanza defn to-int (i:ref<Int>) -> ref<Int> : return i
public lostanza defn to-int (l:ref<Long>) -> ref<Int> : return new Int{l.value as int}
public lostanza defn to-int (f:ref<Float>) -> ref<Int> : return new Int{f.value as int}
public lostanza defn to-int (d:ref<Double>) -> ref<Int> : return new Int{d.value as int}
public lostanza defn to-long (b:ref<Byte>) -> ref<Long> : return new Long{b.value}
public lostanza defn to-long (i:ref<Int>) -> ref<Long> : return new Long{i.value}
public lostanza defn to-long (l:ref<Long>) -> ref<Long> : return l
public lostanza defn to-long (f:ref<Float>) -> ref<Long> : return new Long{f.value as long}
public lostanza defn to-long (d:ref<Double>) -> ref<Long> : return new Long{d.value as long}
public lostanza defn to-float (b:ref<Byte>) -> ref<Float> : return new Float{b.value as float}
public lostanza defn to-float (i:ref<Int>) -> ref<Float> : return new Float{i.value as float}
public lostanza defn to-float (l:ref<Long>) -> ref<Float> : return new Float{l.value as float}
public lostanza defn to-float (f:ref<Float>) -> ref<Float> : return f
public lostanza defn to-float (d:ref<Double>) -> ref<Float> : return new Float{d.value as float}
public lostanza defn to-double (b:ref<Byte>) -> ref<Double> : return new Double{b.value as double}
public lostanza defn to-double (i:ref<Int>) -> ref<Double> : return new Double{i.value as double}
public lostanza defn to-double (l:ref<Long>) -> ref<Double> : return new Double{l.value as double}
public lostanza defn to-double (f:ref<Float>) -> ref<Double> : return new Double{f.value}
public lostanza defn to-double (d:ref<Double>) -> ref<Double> : return d

;                Numeric Reinterpretations
;                =========================

public lostanza defn bits (f:ref<Float>) -> ref<Int> :
  val v = f.value
  return new Int{($ls-prim bits v)}

public lostanza defn bits (d:ref<Double>) -> ref<Long> :
  val v = d.value
  return new Long{($ls-prim bits v)}

public lostanza defn bits-as-float (i:ref<Int>) -> ref<Float> :
  val v = i.value
  return new Float{($ls-prim fnum v)}

public lostanza defn bits-as-double (i:ref<Long>) -> ref<Double> :
  val v = i.value
  return new Double{($ls-prim fnum v)}

;============================================================
;==================== Number Parsing ========================
;============================================================

;                     Error Checking
;                     ==============

#for (to-value! in [to-byte! to-int! to-long! to-float! to-double!]
      to-value in [to-byte to-int to-long to-float to-double]
      Value in [Byte Int Long Float Double]
      name in ["byte" "int" "long" "float" "double"]) :
  public defn to-value! (s:String) -> Value :
    #if-defined(OPTIMIZE) :
      to-value(s) as Value
    #else :
      match(to-value(s)) :
        (v:Value) : v
        (v:False) : fatal("String %~ cannot be converted to a %_." % [s, name])

;                        Drivers
;                        =======

public defn to-byte (s:String) -> False|Byte :
  match(to-int(s)) :
    (i:Int) : to-byte(i) when i >= 0 and i <= 255
    (i:False) : false

public lostanza defn to-int (s:ref<String>) -> ref<False|Int> :
  if prefix?(s, "-") :
    return neg-to-int(s, 1, 10)
  else if prefix?(s, "0x") :
    return bits-to-int(s, 2, 16, 4)
  else if prefix?(s, "0o") :
    return bits-to-int(s, 2, 8, 3)
  else if prefix?(s, "0b") :
    return bits-to-int(s, 2, 2, 1)
  else :
    return pos-to-int(s, 0, 10)

public lostanza defn to-long (s:ref<String>) -> ref<False|Long> :
  if prefix?(s, "-") :
    return neg-to-long(s, 1, 10)
  else if prefix?(s, "0x") :
    return bits-to-long(s, 2, 16, 4)
  else if prefix?(s, "0o") :
    return bits-to-long(s, 2, 8, 3)
  else if prefix?(s, "0b") :
    return bits-to-long(s, 2, 2, 1)
  else :
    return pos-to-long(s, 0, 10)

;TODO: This is necessary because addresses of local variables don't work yet.
lostanza var DOUBLE-BUFFER : double
lostanza var CHAR-BUFFER : byte
public lostanza defn to-double (s:ref<String>) -> ref<False|Double> :
  val n = call-c clib/sscanf(addr!(s.chars), "%lf%c", addr(DOUBLE-BUFFER), addr(CHAR-BUFFER))
  if n != 1 : return false
  else : return new Double{DOUBLE-BUFFER}

lostanza var FLOAT-BUFFER : float
public lostanza defn to-float (s:ref<String>) -> ref<False|Float> :
  val n = call-c clib/sscanf(addr!(s.chars), "%f%c", addr(FLOAT-BUFFER), addr(CHAR-BUFFER))
  if n != 1 : return false
  else : return new Float{FLOAT-BUFFER}

;                        Utilities
;                        =========

lostanza defn prefix? (str:ref<String>, prefix:ptr<byte>) -> int :
  for (var i:long = 0, 1, i = i + 1) :
    if prefix[i] == 0 : return 1
    else if str.chars[i] == 0 : return 0
    else if prefix[i] != str.chars[i] : return 0
  return 0

lostanza defn digit (c:byte, radix:int) -> int :
  var d:int
  if c >= '0' and c <= '9' : d = c - '0'
  else if c >= 'a' and c <= 'f' : d = c - 'a' + 10
  else if c >= 'A' and c <= 'F' : d = c - 'A' + 10
  else : return -1
  if d < radix : return d
  else : return -1

;                        Parsing Integers
;                        ================

lostanza defn pos-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
  if empty?(s) == true :
    return false
  var n:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix + d
        if n < 0 : return false
  fatal("Unreachable")
  return false

lostanza defn neg-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
  if empty?(s) == true :
    return false
  var n:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix - d
        if n > 0 : return false
  fatal("Unreachable")
  return false

lostanza defn bits-to-int (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Int> :
  if empty?(s) == true :
    return false
  var n:int = 0
  var nbits:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = (n << bits) | d
        nbits = nbits + bits
        if nbits >= 32 + bits : return false
  fatal("Unreachable")
  return false

;                        Parsing Longs
;                        =============

lostanza defn pos-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
  if empty?(s) == true :
    return false
  var n:long = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix + d
        if n < 0 : return false
  fatal("Unreachable")
  return false

lostanza defn neg-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
  if empty?(s) == true :
    return false
  var n:long = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix - d
        if n > 0 : return false
  fatal("Unreachable")
  return false

lostanza defn bits-to-long (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Long> :
  if empty?(s) == true :
    return false
  var n:long = 0
  var nbits:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = (n << bits) | d
        nbits = nbits + bits
        if nbits >= 64 + bits : return false
  fatal("Unreachable")
  return false

;============================================================
;=================== Limits =================================
;============================================================

public val BYTE-MAX = 255Y
public val BYTE-MIN = 0Y
public lostanza val INT-MAX:ref<Int> = new Int{(1 << 31) - 1}
public lostanza val INT-MIN:ref<Int> = new Int{1 << 31}
public lostanza val LONG-MAX:ref<Long> = new Long{(1L << 63L) - 1L}
public lostanza val LONG-MIN:ref<Long> = new Long{1L << 63L}

public val FLOAT-MAX = bits-as-float(0x7F7FFFFF)
public val FLOAT-MIN-NORMAL = bits-as-float(0x00800000)
public val FLOAT-MIN = bits-as-float(0x1)
public val FLOAT-NAN = bits-as-float(0x7FC00000)
public val FLOAT-POSITIVE-INFINITY = bits-as-float(0x7F800000)
public val FLOAT-NEGATIVE-INFINITY = bits-as-float(0xFF800000)

public val DOUBLE-MAX = bits-as-double(0x7fefffffffffffffL)
public val DOUBLE-MIN-NORMAL = bits-as-double(0x0010000000000000L)
public val DOUBLE-MIN = bits-as-double(0x1L)
public val DOUBLE-NAN = bits-as-double(0x7ff8000000000000L)
public val DOUBLE-POSITIVE-INFINITY = bits-as-double(0x7ff0000000000000L)
public val DOUBLE-NEGATIVE-INFINITY = bits-as-double(0xfff0000000000000L)

;============================================================
;==================== Arithmetic ============================
;============================================================

public defn max<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T :
  b when a < b else a

public defn min<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T :
  a when a < b else b

public defn minimum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, xs} $ fn (x, y) :
    if x < y : x
    else : y

public defn minimum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, x0, xs} $ fn (x, y) :
    if x < y : x
    else : y

public defn maximum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, xs} $ fn (x, y) :
    if x < y : y
    else : x

public defn maximum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, x0, xs} $ fn (x, y) :
    if x < y : y
    else : x

public defn minimum<?T> (xs:Seqable<?T&Comparable>) -> T : minimum(xs, less?)
public defn maximum<?T> (xs:Seqable<?T&Comparable>) -> T : maximum(xs, less?)

public defn minimum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : minimum(x0, xs, less?)
public defn maximum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : maximum(x0, xs, less?)

public defn minimum<?T> (key: T -> Comparable, input-xs:Seqable<?T>) -> T :
  val xs = to-seq(input-xs)
  var min-x:T = next(xs)
  var min-key:Comparable = key(min-x)
  for x in xs do :
    val k = key(x)
    if k < min-key :
      min-x = x
      min-key = k
  min-x

public defn maximum<?T> (key: T -> Comparable, input-xs:Seqable<?T>) -> T :
  val xs = to-seq(input-xs)
  var max-x:T = next(xs)
  var max-key:Comparable = key(max-x)
  for x in xs do :
    val k = key(x)
    if k > max-key :
      max-x = x
      max-key = k
  max-x

public defn ceil-log2 (i:Int) -> Int :
  defn* loop (n:Int, l:Int) :
    if i > n :
      if l == 30 : l + 1
      else : loop(n << 1, l + 1)
    else : l
  fatal("Log of non-positive number!") when i <= 0
  loop(1, 0)

public defn floor-log2 (i:Int) -> Int :
  defn* loop (n:Int, l:Int) :
    if i == n : l
    else if i < n : l - 1
    else if l == 30 : l
    else : loop(n << 1, l + 1)
  fatal("Log of non-positive number!") when i <= 0
  loop(1, 0)

public defn ceil-log2 (i:Long) -> Int :
  defn* loop (n:Long, l:Int) :
    if i > n :
      if l == 62 : l + 1
      else : loop(n << to-long(1), l + 1)
    else : l
  fatal("Log of non-positive number!") when i <= to-long(0)
  loop(to-long(1), 0)

public defn floor-log2 (i:Long) -> Int :
  defn* loop (n:Long, l:Int) :
    if n == i : l
    else if i < n : l - 1
    else if l == 62 : l
    else : loop(n << to-long(1), l + 1)
  fatal("Log of non-positive number!") when i <= to-long(0)
  loop(to-long(1), 0)

public defn next-pow2 (i:Int) -> Int :
  ensure-non-negative("value", i)
  if i == 0 :
    i
  else :
    val n = ceil-log2(i)
    if n <= 30 : 1 << n
    else : fatal("Overflow")

public defn prev-pow2 (i:Int) -> Int :
  ensure-non-negative("value", i)
  if i == 0 :
    i
  else :
    1 << floor-log2(i)

public defn next-pow2 (i:Long) -> Long :
  val n = ceil-log2(i)
  if n <= 62 : to-long(1) << to-long(n)
  else : fatal("Overflow")

public defn prev-pow2 (i:Long) -> Long :
  to-long(1) << to-long(floor-log2(i))

public defn sum (xs: Seqable<Int>) -> Int : reduce(plus, 0, xs)
public defn sum (xs: Seqable<Long>) -> Long : reduce(plus, 0L, xs)
public defn sum (xs: Seqable<Float>) -> Float : reduce(plus, 0.0f, xs)
public defn sum (xs: Seqable<Double>) -> Double : reduce(plus, 0.0, xs)

public defn product (xs: Seqable<Int>) -> Int : reduce(times, 1, xs)
public defn product (xs: Seqable<Long>) -> Long : reduce(times, 1L, xs)
public defn product (xs: Seqable<Float>) -> Float : reduce(times, 1.0f, xs)
public defn product (xs: Seqable<Double>) -> Double : reduce(times, 1.0, xs)

;============================================================
;====================== Maybe ===============================
;============================================================

public deftype Maybe<T> <: Equalable & Comparable<Maybe<T>> & Hashable
public deftype None <: Maybe<Void>
public deftype One<T> <: Maybe<T>

;                      Interface
;                      =========

public defmulti value<?T> (x:One<?T>) -> T

;                     Constructors
;                     ============

public defn None () :
   new None

public defn One<?T> (x:?T) :
   new One<T> :
      defmethod value (this) : x

;                     Printers
;                     ========

defmethod print (o:OutputStream, x:None) :
   print(o, "None")
defmethod print (o:OutputStream, x:One) :
   print(o, "One(%~)" % [value(x)])

;                   Implementation
;                   ==============

public defn value!<?T> (x:Maybe<?T>) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : fatal("Object of type None has no value.")

public defn value?<?T> (x:Maybe<?T>, default:?T) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : default

public defn value?<?T> (x:Maybe<?T>) -> T|False :
   value?(x, false)

public defn empty? (x:Maybe) :
   x is None

defmethod equal? (a:None, b:None) :
   true

defmethod equal? (a:One, b:One) :
   value(a) == value(b)

defmethod hash (a:None) :
  1817

defmethod hash (a:One) :
  hash(value(a)) * 17

;                   Comparisons
;                   ===========

defmethod* compare<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : 0
      (x:None, y:One<T>) : -1
      (x:One<T>, y:None) : 1
      (x:One<T&Comparable<T>>, y:One<T>) : compare(value(x), value(y))

defmethod less?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) < value(y)

defmethod less-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) <= value(y)

defmethod greater?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) > value(y)

defmethod greater-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) >= value(y)

;============================================================
;====================== Ranges ==============================
;============================================================

public deftype Range <: Equalable

;                      Interface
;                      =========

public defmulti start (r:Range) -> Int
public defmulti end (r:Range) -> Int|False
public defmulti step (r:Range) -> Int
public defmulti inclusive? (r:Range) -> True|False

;                     Constructor
;                     ===========

public defn Range (start:Int, end:Int|False, step:Int, inclusive?:True|False) :
   ;Compute the length of the range
   val length = match(end, inclusive?) :
      (end:Int, inc:False) :
         if step == 0 :
            if start == end : 0
            else : false
         else if step == 1 :
            safe-minus(end, start)
         else if step == -1 :
            safe-minus(start, end)
         else if step > 0 :
            div?(safe-add(safe-minus(end, start), step - 1), step)
         else :
            div?(safe-add(safe-minus(end, start), step + 1), step)
      (end:Int, inc:True) :
         if step == 0 :
            false
         else if step == 1 :
            safe-add(safe-minus(end, start), 1)
         else if step == -1 :
            safe-add(safe-minus(start, end), 1)
         else :
            div?(safe-add(safe-minus(end, start), step), step)
      (end:False, inc) :
         false

   match(length) :
      (length:Int) :
         new Range & Lengthable :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?
            defmethod length (this) : max(length, 0)
      (length:False) :
         new Range :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?

defn safe-add (x:Int, y:Int) :
  val z = x + y
  val sign-x = x >> 31
  val sign-y = y >> 31
  val sign-z = z >> 31
  val c = (sign-x ^ sign-y) | (1 ^ sign-x ^ sign-z)
  z when c == 1

defn safe-minus (x:Int, y:Int) :
  val z = x - y
  val sign-x = x >> 31
  val sign-y = y >> 31
  val sign-z = z >> 31
  val c = (1 ^ sign-x ^ sign-y) | (1 ^ sign-x ^ sign-z)
  z when c == 1

defn safe-add (x:False, y:Int) : false
defn safe-minus (x:False, y:Int) : false
defn div? (x:Int, y:Int) : x / y
defn div? (x:False, y:Int) : false

;                Conversion to Sequence
;                ======================



;             Reverse
;             =======
public defn reverse (r:Range) :
  ;Fields
  val start = start(r)
  val end = end(r)
  val step = step(r)
  val inc = inclusive?(r)

  ;Cases
  defn* empty-range () :
    Range(end as Int, start, (- step), inc)
  defn* reverse-range (last:Int) :
    last through start by (- step)
  defn* infinite-range () :
    start through start by 0
  defn* no-last-element () :
    fatal("Range %_ cannot be reversed." % [r])

  if step == 0 :
    match(start == end, inc) :
      (eq:False, inc) : infinite-range()
      (eq:True, inc:True) : infinite-range()
      (eq:True, inc:False) : empty-range()
  else if end is False :
    no-last-element()
  else :
    val end = end as Int
    match(step > 0, end > start) :
      (r1:True, r2:False) :
        empty-range()
      (r1:False, r2:True) :
        empty-range()
      (r1, r2) :
        val sgn-step = 1 when r1 else -1
        val n = if inc : (end - start + step) / step
                else : (end - start + step - sgn-step) / step
        reverse-range(start + (n - 1) * step)



;             Looping
;             =======

defmethod do (f: Int -> ?, r:Range&Lengthable) :
   val s = step(r)
   let loop (i:Int = start(r), n:Int = length(r)) :
      if n > 0 :
         f(i)
         loop(i + s, n - 1)

defmethod do (f: Int -> ?, r:Range) :
   val s = step(r)
   let loop (i:Int = start(r)) :
      f(i)
      loop(i + s)

;                  Inclusion
;                  =========

defmethod contains? (r:Range, x:Int) :
  val start = start(r)
  val step = step(r)
  match(end(r), inclusive?(r)) :
    (end:Int, inc:False) :
      if step == 0 :
        if start == end : false
        else : start == x
      else if step == 1 :
        x >= start and x < end
      else if step == -1 :
        x <= start and x > end
      else if step > 0 :
        x >= start and x < end and ((x - start) % step == 0)
      else :
        x <= start and x > end and ((x - start) % step == 0)
    (end:Int, inc:True) :
      if step == 0 :
        start == x
      else if step == 1 :
        x >= start and x <= end
      else if step == -1 :
        x <= start and x >= end
      else if step > 0 :
        x >= start and x <= end and ((x - start) % step == 0)
      else :
        x <= start and x >= end and ((x - start) % step == 0)
    (end:False, inc) :
      if step == 0 :
        start == x
      else if step == 1 :
        x >= start
      else if step == -1 :
        x <= start
      else if step > 0 :
        x >= start and ((x - start) % step == 0)
      else :
        x <= start and ((x - start) % step == 0)

;                 Comparison
;                 ==========

defmethod equal? (a:Range, b:Range) :
   start(a) == start(b) and
   end(a) == end(b) and
   step(a) == step(b) and
   inclusive?(a) == inclusive?(b)

;                  Printing
;                  ========

defmethod print (o:OutputStream, x:Range) :
   val op = "through" when inclusive?(x) else "to"
   if step(x) == 1 : print(o, "%_ %_ %_" % [start(x), op, end(x)])
   else : print(o, "%_ %_ %_ by %_" % [start(x), op, end(x), step(x)])

;                  Mapping
;                  =======

public defn map<?R> (f: Int -> ?R, r:Range) -> List<R> :
   fatal("Infinite Range") when r is-not Range&Lengthable
   to-list(seq(f, r))

;============================================================
;==================== KeyValue Pairs ========================
;============================================================

public deftype KeyValue<K,V> <: Equalable & Hashable

;                       Interface
;                       =========

public defmulti key<?K> (kv:KeyValue<?K,?>) -> K
public defmulti value<?V> (kv:KeyValue<?,?V>) -> V

;                      Constructor
;                      ===========

public defn KeyValue<?K,?V> (k:?K, v:?V) -> KeyValue<K,V> :
   new KeyValue<K,V> :
      defmethod key (this) : k
      defmethod value (this) : v

defmethod print (o:OutputStream, v:KeyValue) :
   write(o, key(v))
   print(o, " => ")
   write(o, value(v))

defmethod equal? (a:KeyValue, b:KeyValue) :
   key(a) == key(b) and
   value(a) == value(b)

defmethod hash (x:KeyValue<Hashable,Hashable>) :
   hash(key(x)) + 7 * hash(value(x))

;============================================================
;====================== Tokens ==============================
;============================================================

public deftype Token <: Equalable

;                      Interface
;                      =========

public defmulti item (t:Token) -> ?
public defmulti info (t:Token) -> FileInfo

;                     Constructor
;                     ===========

public defn Token (item, info:FileInfo) :
   new Token :
      defmethod item (this) : item
      defmethod info (this) : info

public defn unwrap-token (t) :
   match(t) :
      (t:Token) : unwrap-token(item(t))
      (t) : t

public defn sub-token-item? (t, x) -> ? :
  match(t, x) :
    (t, x:Token) : x
    (t:Token, x) : Token(x, info(t))
    (t, x) : x

public defn unwrap-all (t) -> ? :
   match(t) :
      (t:Token) : unwrap-all(item(t))
      (t:List) : map(unwrap-all, t)
      (t) : t

defmethod print (o:OutputStream, t:Token) :
   write(o, item(t))

defmethod equal? (a:Token, b:Token) :
   (item(a) == item(b)) and
   (info(a) == info(b))

;============================================================
;===================== FileInfo =============================
;============================================================

public deftype FileInfo <: Equalable & Hashable & Comparable<FileInfo>

;                     Interface
;                     =========

public defmulti filename (i:FileInfo) -> String
public defmulti line (i:FileInfo) -> Int
public defmulti column (i:FileInfo) -> Int

;                  Implementation
;                  ==============

public defn FileInfo (f:String, l:Int, c:Int) :
   new FileInfo :
      defmethod filename (this) : f
      defmethod line (this) : l
      defmethod column (this) : c

defmethod equal? (a:FileInfo, b:FileInfo) :
   filename(a) == filename(b) and
   line(a) == line(b) and
   column(a) == column(b)

defmethod hash (i:FileInfo) :
   hash(filename(i)) +
   7 * hash(line(i)) +
   49 * hash(column(i))

defmethod compare (a:FileInfo, b:FileInfo) :
   val c = compare(filename(a), filename(b))
   if c == 0 :
      val c = compare(line(a), line(b))
      if c == 0 :
         compare(column(a), column(b))
      else : c
   else : c

defmethod print (o:OutputStream, i:FileInfo) :
   print(o, filename(i))
   print(o, ":")
   print(o, line(i))
   print(o, ".")
   print(o, column(i))

;============================================================
;======================= Sequences ==========================
;============================================================

public deftype Seqable<T> :
  Collection<T> <: Seqable<T>

public deftype Seq<T> <: Seqable<T>

public deftype Collection<T> :
  Range <: Collection<Int>
  String <: Collection<Char>
  List<T> <: Collection<T>
  Tuple<T> <: Collection<T>
  IndexedCollection<T> <: Collection<T>

public defmulti to-seq<?T> (s:Seqable<?T>) -> Seq<T>
defmethod to-seq<?T> (s:Seq<?T>) : s

public defmulti next<?T> (s:Seq<?T>) -> T
public defmulti peek<?T> (s:Seq<?T>) -> T
public defmulti empty? (s:Seq) -> True|False
public defmulti free (s:Seq) -> False
defmethod free (s:Seq) : false

defn* do-seq<?T,?R> (f: Seq<T> -> ?R, s:Seqable<?T>) -> R :
  match(s) :
   (s:Seq<T>) :
     f(s)
   (s) :
     val s-seq = to-seq(s)
     with-finally(
       fn* () : f(s-seq)
       fn* () : free(s-seq))

;===== Conversion to Sequence =====

defmethod to-seq<?T> (x:Tuple<?T>) :
   seq({x[_]}, 0 to length(x))

defmethod to-seq (s:String) :
   seq({s[_]}, 0 to length(s))

defmethod to-seq<?T> (x:List<?T>) :
   var l = x
   new Seq<T> :
      defmethod empty? (this) :
         empty?(l)
      defmethod next (this) :
         val x = peek(this)
         l = tail(l)
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         head(l)

defmethod to-seq<?T> (xs:IndexedCollection<?T>) -> Seq<T> :
   seq({xs[_]}, 0 to length(xs))

defmethod to-seq (r:Range) :
  match(r) :
    (r:Range & Lengthable) :
      var i = start(r)
      var n = length(r)
      new Seq<Int> & Lengthable :
        defmethod next (this) :
          val i* = peek(this)
          i = i + step(r)
          n = n - 1
          i*
        defmethod peek (this) :
          fatal("Empty Sequence") when empty?(this)
          i
        defmethod empty? (this) :
          n == 0
        defmethod length (this) :
          n
    (r:Range) :
      var i = start(r)
      new Seq<Int> :
        defmethod next (this) :
          val i* = i
          i = i + step(r)
          i*
        defmethod peek (this) :
          i
        defmethod empty? (this) :
          false

;===== Conversion from Sequence =====

public defn to-tuple<?T> (xs:Seqable<?T>) -> Tuple<T> :
   match(xs) :
      (xs:Tuple<T>) :
         xs
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val t = Tuple(n, false as ?)
         for (x in xs, i in 0 to n) do :
            t[i] = x
         t
      (xs) :
         to-tuple(to-vector<T>(xs))

public defn String (cs:Seqable<Char>) -> String :
   match(cs) :
      (cs:Seqable<Char> & Lengthable) :
         val n = length(cs)
         val s = String(n, ' ')
         for (c in cs, i in 0 to false) do :
            s[i] = c
         s
      (c) :
         String(to-vector<Char>(cs))

public defn to-list<?T> (xs:Seqable<?T>) -> List<T> :
   match(xs) :
      (xs:List<T>) :
         xs
      (xs) :
         val vec = to-vector<T>(xs)
         defn* loop (i:Int, accum:List<T>) :
            if i >= 0 : loop(i - 1, cons(vec[i], accum))
            else : accum
         loop(length(vec) - 1, List())

public defn to-array<T> (xs:Seqable<T>) -> Array<T> :
   match(xs) :
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val a = Array<T>(n)
         for (x in xs, i in 0 to n) do :
            a[i] = x
         a
      (xs) :
         to-array<T>(to-list(xs))

public defn symbol-join (xs:Seqable) -> Symbol :
   to-symbol(string-join(xs))

;============================================================
;================== Sequence Library ========================
;============================================================

public defmulti do<?T> (f:T -> ?, xs:Seqable<?T>) -> False
public defmulti do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False
public defmulti do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False

defmethod do<?T> (f:T -> ?, xs:Seqable<?T>) -> False :
   for xs-seq in xs do-seq :
      while not empty?(xs-seq) :
         f(next(xs-seq))

defmethod do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         while (not empty?(xs-seq)) and (not empty?(ys-seq)) :
            f(next(xs-seq), next(ys-seq))

defmethod do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            while (not empty?(xs-seq)) and (not empty?(ys-seq)) and (not empty?(zs-seq)) :
               f(next(xs-seq), next(ys-seq), next(zs-seq))

;Specialization
defmethod do<?T> (f: T -> ?, xs:Array<?T>) :
   val n = length(xs)
   let loop (i:Int = 0) :
      if i < n :
         f(xs[i])
         loop(i + 1)

defmethod do<?T> (f: T -> ?, xs:Tuple<?T>) :
   val n = length(xs)
   let loop (i:Int = 0) :
      if i < n :
         f(xs[i])
         loop(i + 1)

#for (Prim in [Byte Int Long Float Double]
      PrimArray in [ByteArray IntArray LongArray FloatArray DoubleArray]) :
   defmethod do (f: Prim -> ?, xs:PrimArray) :
      val n = length(xs)
      let loop (i:Int = 0) :
         if i < n :
            f(xs[i])
            loop(i + 1)

defmethod do (f: Char -> ?, xs:String) :
   val n = length(xs)
   let loop (i:Int = 0) :
      if i < n :
         f(xs[i])
         loop(i + 1)

defmethod do<?T> (f:T -> ?, xs:List<?T>) -> False :
   let loop (xs:List<T> = xs) :
      if not empty?(xs) :
         f(head(xs))
         loop(tail(xs))

defn wrap-length<?T> (xs:Seq<?T>, length:() -> Int) :
  new Seq<T> & Lengthable :
    defmethod next (this) : next(xs)
    defmethod peek (this) : peek(xs)
    defmethod empty? (this) : empty?(xs)
    defmethod length (this) : length()

public defn to-collection<?T> (f:() -> Seq<?T>) -> Collection<T> :
  new Collection<T> :
    defmethod to-seq (this) : f()

public defn seq<?T,?S> (f:T -> ?S, xs:Seqable<?T>) -> Seq<S> :
  val xs-seq = to-seq(xs)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) : None()
    else : One(f(next(xs-seq)))
  match(xs-seq) :
    (xs:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + length(xs)})
    (xs) : rs

public defn seq<?T,?S,?R> (f:(T,S) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
  val xs-seq = to-seq(xs)
  val ys-seq = to-seq(ys)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) or empty?(ys-seq) : None()
    else : One(f(next(xs-seq), next(ys-seq)))
  match(xs-seq, ys-seq) :
    (xs:Seq&Lengthable, ys:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + min(length(xs), length(ys))})
    (xs, ys) : rs

public defn seq<?T,?S,?U,?R> (f:(T,S,U) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
  val xs-seq = to-seq(xs)
  val ys-seq = to-seq(ys)
  val zs-seq = to-seq(zs)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) or empty?(ys-seq) or empty?(zs-seq) : None()
    else : One(f(next(xs-seq), next(ys-seq), next(zs-seq)))
  match(xs-seq, ys-seq, zs-seq) :
    (xs:Seq&Lengthable, ys:Seq&Lengthable, zs:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + min(length(xs), min(length(ys), length(zs)))})
    (xs, ys, zs) : rs

public defmulti in-reverse<?T> (xs:Seqable<?T>) -> Seq<T>
defmethod in-reverse<?T> (xs:Seqable<?T>) :
  in-reverse(to-vector<T>(xs))

defmethod in-reverse<?T> (xs:IndexedCollection<?T>) :
  val n = length(xs)
  for i in (n - 1) through 0 by -1 seq :
    xs[i]

defmethod in-reverse (r:Range) :
  to-seq(reverse(r))

defmethod in-reverse<?T> (xs:List<?T>) -> Seq<T> :
  generate<T> :
    defn loop (xs:List<T>) :
      if not empty?(xs) :
        loop(tail(xs))
        yield(head(xs))
    loop(xs)

public defmulti contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False
defmethod contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False :
   label<False|True> return :
      for x in xs do :
         return(true) when x == y

public defn find<?T> (f: T -> True|False, xs:Seqable<?T>) -> T|False :
   label<False|T> return :
      for x in xs do :
         return(x) when f(x)

public defn find<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> T|False :
   label<False|T> return :
      for (x in xs, y in ys) do :
         return(x) when f(x, y)

public defn find!<?T> (f: T -> True|False, xs:Seqable<?T>) : find(f, xs) as T
public defn find!<?T, ?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : find(f, xs, ys) as T

public defn first<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Maybe<R> :
   label<Maybe<R>> return :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()

public defn first<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Maybe<R> :
   label<Maybe<R>> return :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()

public defn first!<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) : value!(first(f, xs))
public defn first!<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) : value!(first(f, xs, ys))

public defn seq?<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Seq<R> :
   generate<R> :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?U,?R> (f: (T,S,U) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys, z in zs) do :
         match(f(x, y, z)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn filter<?T> (f: T -> True|False, xs:Seqable<?T>) -> Seq<T> :
   generate<T> :
      for x in xs do :
         yield(x) when f(x)

public defn filter<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<T> :
   generate<T> :
      for (x in xs, y in ys) do :
         yield(x) when f(x, y)

public defn filter<?T> (xs:Seqable<?T>, sel:Seqable<True|False>) -> Seq<T> :
   for (x in xs, s in sel) filter : s

public defn index-of (xs:Seqable<Equalable>, y:Equalable) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when x == y

public defn index-of! (xs:Seqable<Equalable>, y:Equalable) : index-of(xs, y) as Int

public defn index-when<?T> (f: T -> True|False, xs:Seqable<?T>) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when f(x)

public defn index-when<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Int|False :
   label<Int|False> return :
      for (x in xs, y in ys, i in 0 to false) do :
         return(i) when f(x, y)

public defn index-when!<?T> (f: T -> True|False, xs:Seqable<?T>) : index-when(f, xs) as Int
public defn index-when!<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : index-when(f, xs, ys) as Int

public defn split!<?T> (f: T -> True|False, xs: Seqable<?T>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for x in xs do :
      add{_, x} $
         if f(x) : true-xs
         else : false-xs
   [true-xs, false-xs]

public defn split!<?T,?S> (f: (T, S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
  val true-xs = Vector<T>()
  val false-xs = Vector<T>()
  for (x in xs, y in ys) do :
    add{_, x} $
      if f(x, y) : true-xs
      else : false-xs
  [true-xs, false-xs]

public defn split!<?T> (xs:Seqable<?T>, ss:Seqable<True|False>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for (x in xs, s in ss) do :
      add{_, x} $
         if s : true-xs
         else : false-xs
   [true-xs, false-xs]

public defn split<?T> (f:T -> True|False, xs-items:Seqable<?T>) -> [Seq<T>, Seq<T>] :
  val xs = to-seq(xs-items)
  val a-items = Queue<T>()
  val b-items = Queue<T>()

  ;Pull next item onto queues
  defn pull () :
    val x = next(xs)
    if f(x) : add(a-items, x)
    else : add(b-items, x)

  ;Try to fill a queue, returns true if filled
  defn* fill (items:Queue<T>) -> True|False :
    if empty?(items) :
      if not empty?(xs) :
        pull()
        fill(items)
    else :
      true

  ;Create seq from queue
  defn queue-seq (items:Queue<T>) :
    new Seq<T> :
      defmethod next (this) :
        if fill(items) : pop(items)
        else : fatal("No more items")
      defmethod peek (this) :
        if fill(items) : peek(items)
        else : fatal("No more items")
      defmethod empty? (this) :
        not fill(items)

  [queue-seq(a-items), queue-seq(b-items)]

public defn fork<?T> (xs-items:Seqable<?T>) -> [Seq<T>, Seq<T>] :
  val xs = to-seq(xs-items)
  val a-items = Queue<T>()
  val b-items = Queue<T>()

  defn queue-seq (items:Queue<T>, other:Queue<T>) :
    new Seq<T> :
      defmethod next (this) :
        if empty?(items) :
          val x = next(xs)
          add(other, x)
          x
        else :
          pop(items)
      defmethod peek (this) :
        if empty?(items) : peek(xs)
        else : peek(items)
      defmethod empty? (this) :
        empty?(items) and empty?(xs)

  [queue-seq(a-items, b-items),
   queue-seq(b-items, a-items)]

public defn fork<?T> (xs-items:Seqable<?T>, n:Int) -> Tuple<Seq<T>> :
  val xs = to-seq(xs-items)
  val items = to-tuple(repeatedly(Queue<T>{}, n))

  ;Pull next item all queues except queue n
  defn pull (n:Int) :
    val x = next(xs)
    for (q in items, i in 0 to false) do :
      add(q, x) when i != n
    x

  to-tuple $ for i in 0 to n seq :
    val items = items[i]
    new Seq<T> :
      defmethod next (this) :
        if empty?(items) : pull(i)
        else : pop(items)
      defmethod peek (this) :
        if empty?(items) : peek(xs)
        else : peek(items)
      defmethod empty? (this) :
        empty?(items) and empty?(xs)

public defn take-while<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = peek(xs-seq)
               if f(x) :
                  next(xs-seq)
                  yield(x)
                  loop()
         loop()

public defn take-until<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = next(xs-seq)
               yield(x)
               loop() when not f(x)
         loop()

public defn take-n<?T> (n:Int, xs:Seqable<?T>) :
   ensure-non-negative("length", n)
   var len = n
   val xs-seq = to-seq(xs)
   new Seq<T> & Lengthable :
      defmethod next (this) :
         val v = peek(this)
         next(xs-seq)
         len = len - 1
         v
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         peek(xs-seq)
      defmethod empty? (this) :
         len == 0
      defmethod length (this) :
         len
      defmethod free (this) :
         free(xs-seq)

public defn take-up-to-n<?T> (n:Int, xs:Seqable<?T>) :
   ensure-non-negative("length", n)
   var len = n
   val xs-seq = to-seq(xs)
   new Seq<T> :
      defmethod next (this) :
         val v = peek(this)
         next(xs-seq)
         len = len - 1
         v
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         peek(xs-seq)
      defmethod empty? (this) :
         (len == 0) or empty?(xs-seq)
      defmethod free (this) :
         free(xs-seq)

public defn cat<?T> (a:Seqable<?T>, b:Seqable<?T>) -> Seq<T> :
   cat-all([a, b])

public defn cat-all<?T> (input-xss:Seqable<Seqable<?T>>) -> Seq<T> :
  val xss = to-seq(input-xss)
  var xs:Seq<T>|False|Sentinel = sentinel
  defn* load-next-seq () :
    if empty?(xss) :
      xs = false
    else :
      xs = to-seq(next(xss))
      fill()
  defn* fill () -> Seq<T>|False :
    match(xs) :
      (xs:False) : false
      (xs:Seq<T>) : load-next-seq() when empty?(xs) else xs
      (xs:Sentinel) : load-next-seq()
  defn fill! () :
    match(fill()) :
      (xs:Seq<T>) : xs
      (xs:False) : fatal("Empty Sequence")
  new Seq :
    defmethod next (this) :
      next(fill!())
    defmethod peek (this) :
      peek(fill!())
    defmethod empty? (this) :
      fill() is False
    defmethod free (this) :
      match(xs:Seq<T>) : free(xs)
      free(xss)
      xs = false

public defn seq-cat<?T,?R> (f:T -> Seqable<?R>, xs:Seqable<?T>) -> Seq<R> :
   cat-all(seq(f, xs))

public defn seq-cat<?T,?S,?R> (f:(T,S) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   cat-all(seq(f, xs, ys))

public defn seq-cat<?T,?S,?U,?R> (f:(T,S,U) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   cat-all(seq(f, xs, ys, zs))

public defn all?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   for xs-seq in xs do-seq :
      defn* loop () :
         if empty?(xs-seq) : true
         else : pred?(next(xs-seq)) and loop()
      loop()

public defn all?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         defn* loop () :
            if empty?(xs-seq) or empty?(ys-seq) : true
            else : pred?(next(xs-seq), next(ys-seq)) and loop()
         loop()

public defn all?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            defn* loop () :
               if empty?(xs-seq) or empty?(ys-seq) or empty?(zs-seq) : true
               else : pred?(next(xs-seq), next(ys-seq), next(zs-seq)) and loop()
            loop()

public defn none?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   defn notp (x) : not pred?(x)
   all?(notp, xs)

public defn none?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   defn notp (x1, x2) : not pred?(x1, x2)
   all?(notp, xs, ys)

public defn none?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   defn notp (x1, x2, x3) : not pred?(x1, x2, x3)
   all?(notp, xs, ys, zs)

public defn any?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   not none?(pred?, xs)

public defn any?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   not none?(pred?, xs, ys)

public defn any?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   not none?(pred?, xs, ys, zs)

public defn count (xs:Seqable) -> Int :
  match(xs) :
    (xs:Seqable & Lengthable) :
      length(xs)
    (xs) :
      var accum:Int = 0
      for x in xs do :
        accum = accum + 1
      accum

public defn count<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> Int :
   var accum:Int = 0
   for x in xs do :
      if pred?(x) : accum = accum + 1
   accum

public defn join<?T,?S> (xs0:Seqable<?T>, y:?S) -> Seq<T|S> :
  val xs = to-seq(xs0)
  var join? = false
  val rs = new Seq<T|S> :
    defmethod next (this) :
      fatal("Empty Sequence") when empty?(xs)
      val result = y when join? else next(xs)
      join? = not join?
      result
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(xs)
      y when join? else peek(xs)
    defmethod empty? (this) :
      empty?(xs)
  match(xs) :
    (xs:Seq<T> & Lengthable) :
      defn rs-length () :
        if join? : length(xs) * 2
        else : length(xs) * 2 - 1
      wrap-length(rs, rs-length)
    (xs) : rs

public defn interleave<?T,?S> (xs0:Seqable<?T>, ys0:Seqable<?S>) -> Seq<T|S> :
  val xs = to-seq(xs0)
  val ys = to-seq(ys0)
  var yield-x? = true
  val rs = new Seq<T|S> :
    defmethod next (this) :
      fatal("Empty Sequence") when empty?(this)
      val result = next(xs) when yield-x? else next(ys)
      yield-x? = not yield-x?
      result
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(this)
      peek(xs) when yield-x? else peek(ys)
    defmethod empty? (this) :
      empty?(xs) when yield-x? else empty?(ys)
  match(xs, ys) :
    (xs:Seq<T> & Lengthable, ys:Seq<S> & Lengthable) :
      defn rs-length () :
        if yield-x? : 2 * min(length(xs), length(ys))
        else : 1 + 2 * min(length(xs), length(ys) - 1)
      wrap-length(rs, rs-length)
    (xs, ys) : rs

public defn reduce<?T,?S> (f: (T, S) -> ?T, x0: ?T, xs:Seqable<?S>) -> T :
   var accum = x0
   for x in xs do :
      accum = f(accum, x)
   accum

public defn reduce<?T,?S> (f: (T|S, T) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      reduce(f, next(xs-seq), xs-seq)

public defn reduce-right<?T,?S> (f: (S, T) -> ?T, xs:Seqable<?S>, xn:?T) -> T :
   for xs-seq in xs do-seq :
      defn loop () :
         if empty?(xs-seq) : xn
         else : f(next(xs-seq), loop())
      loop()

public defn reduce-right<?T,?S> (f: (T, T|S) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      defn loop (x:T) :
         if empty?(xs-seq) : x
         else : f(x, loop(next(xs-seq)))
      loop(next(xs-seq))

public defn repeat<?T> (x:?T) -> Seq<T> :
   new Seq<T> :
      defmethod next (this) : x
      defmethod peek (this) : x
      defmethod empty? (this) : false

public defn repeat<?T> (x:?T, n:Int) :
   ensure-non-negative("length", n)
   var len = n
   new Seq<T> & Lengthable :
      defmethod next (this) :
         fatal("Empty Sequence") when len == 0
         len = len - 1
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         x
      defmethod empty? (this) :
         len == 0
      defmethod length (this) :
         len

deftype RepeatWhileSeq<T> <: Seq<T>
defmulti cached (s:RepeatWhileSeq) -> Int

public defn repeat-while<?T> (f: () -> Maybe<?T>) -> RepeatWhileSeq<T> :
  var item = sentinel
  defn fill () : (item = f()) when item is Sentinel

  new RepeatWhileSeq<T> :
    defmethod next (this) :
      val x = peek(this)
      item = sentinel
      x
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(this)
      value(item as One<T>)
    defmethod empty? (this) :
      fill()
      item is None
    defmethod cached (this) :
      1 when item is One else 0

public defn repeatedly<?T> (f:() -> ?T) -> Seq<T> :
   var item = sentinel
   defn fill () : (item = f()) when item is Sentinel

   defn empty () :
      val x = item as T
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         item as T
      defmethod empty? (this) :
         false

public defn repeatedly<?T> (f:() -> ?T, n:Int) :
   take-n(n, repeatedly(f))

public defn zip<?T,?S> (xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<[T,S]> :
   for (x in xs, y in ys) seq : [x, y]

public defn zip<?T,?S,?U> (xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<[T,S,U]> :
   for (x in xs, y in ys, z in zs) seq : [x, y, z]

public defn zip-all<?T> (xs:Seqable<Seqable<?T>>) :
   val seqs = to-tuple(seq(to-seq, xs))
   fatal("No Sequences Given") when empty?(seqs)
   val ret-seq = new Seq<Tuple<T>> :
      defmethod next (this) :
         map(next, seqs)
      defmethod peek (this) :
         map(peek, seqs)
      defmethod empty? (this) :
         any?(empty?, seqs)
   if all?({_ is Lengthable&Seq}, seqs) :
      val len = minimum{seq(length{_ as Lengthable&Seq}, seqs)}
      wrap-length(ret-seq, len)
   else :
      ret-seq

public defn unique<?T> (xs:Seqable<?T&Equalable>) -> List<T> :
   ;Manage Visited Set
   val table = HashTable<Hashable,True|False>()
   val accum = Vector<Equalable>()

   defn add-to-unique-set (x:T&Equalable) :
      match(x) :
         (x:T&Equalable&Hashable) : table[x] = true
         (x:T&Equalable) : add(accum, x)
   defn visited? (x:T&Equalable) :
      match(x) :
         (x:T&Equalable&Hashable) : key?(table, x)
         (x:T&Equalable) : contains?(accum, x)

   ;Filter
   to-list $ for x in xs filter :
      if not visited?(x) :
         add-to-unique-set(x)
         true

public defn lookup?<?K,?V,?D> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable, default:?D) -> D|V :
   label<V|D> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      default

public defn lookup?<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> False|V :
   lookup?(xs, k, false)

public defn lookup<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> V :
   label<V> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      fatal("Key %~ not found in entries." % [k])

public defn fork-on-seq<?T,?X,?Y> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y) -> [X,Y] :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val fco = make-co(f)
   val gco = make-co(g)

   ;Store function results
   var fresult = resume(fco, None())
   var gresult = resume(gco, None())

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         if fresult is None :
            fresult = resume(fco, v)
         if gresult is None :
            gresult = resume(gco, v)
         (fresult is None) or
         (gresult is None)
      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   [value!(fresult),
    value!(gresult)]

public defn fork-on-seq<?T,?X,?Y,?Z> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y, h:Seq<T> -> ?Z) -> [X,Y,Z] :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val fco = make-co(f)
   val gco = make-co(g)
   val hco = make-co(h)

   ;Store function results
   var fresult = resume(fco, None())
   var gresult = resume(gco, None())
   var hresult = resume(hco, None())

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         if fresult is None :
            fresult = resume(fco, v)
         if gresult is None :
            gresult = resume(gco, v)
         if hresult is None :
            hresult = resume(hco, v)
         (fresult is None) or
         (gresult is None) or
         (hresult is None)
      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   [value!(fresult),
    value!(gresult),
    value!(hresult)]

public defn fork-on-seq<?T,?S> (xs:Seqable<?T>, fs:Seqable<(Seq<T> -> ?S)>) -> Tuple<S> :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val cos = to-tuple(seq(make-co, fs))

   ;Store function results
   val results = to-array<Maybe<S>>(seq(resume{_, None()}, cos))

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         var more? = false
         for (co in cos, i in 0 to false) do :
            if results[i] is None :
               val r = resume(co, v)
               results[i] = r
               more? = more? or (r is None)
         more?

      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   to-tuple(seq(value!, results))

;============================================================
;=============== Commandline Arguments ======================
;============================================================

public lostanza defn command-line-arguments () -> ref<Array<String>> :
  val r = Array<String>(new Int{clib/input_argc})
  for (var i:int = 0, i < clib/input_argc, i = i + 1) :
    val str = clib/input_argv[i]
    set(r, new Int{i}, String(str))
  return r

public lostanza defn set-command-line-arguments (args:ref<Tuple<String>>) -> ref<False> :
  ;Free old arguments if necessary
  if clib/input_argv_needs_free :
    val n = clib/input_argc
    val ss = clib/input_argv
    for (var i:int = 0, i < n, i = i + 1) :
      call-c clib/free(ss[i])
    call-c clib/free(ss)

  ;Malloc array for new arguments
  val n = length(args).value
  val argvs:ptr<ptr<byte>> = call-c clib/malloc((n + 1) * sizeof(ptr<?>))

  ;Copy strings to new array
  for (var i:int = 0, i < n, i = i + 1) :
    argvs[i] = copy-chars(args.items[i])
  argvs[n] = null

  ;Set to global variables
  clib/input_argc = n
  clib/input_argv = argvs

  ;Set flag to indicate that the newly allocated arguments need to be freed.
  clib/input_argv_needs_free = 1

  ;Return from function
  return false

lostanza defn copy-chars (s:ref<String>) -> ptr<byte> :
  val n = length(s).value + 1
  val p:ptr<byte> = call-c clib/malloc(n)
  call-c clib/memcpy(p, addr!(s.chars), n)
  return p

;============================================================
;===================== Random Numbers =======================
;============================================================

public lostanza deftype Random :
  var state: long
lostanza defn next-state (s0:long) -> long :
  return (s0 * 0x5deece66dL + 0xbL) & 0xFFFFFFFFFFFFL
lostanza defn extract-bits (s:long, n:int) -> int :
  return (s >>> (48 - n)) as int
lostanza defn next-bits (r:ref<Random>, n:int) -> int :
  val s = next-state(r.state)
  r.state = s
  return extract-bits(s, n)

public lostanza defn Random (state:ref<Long>) -> ref<Random> :
  return new Random{next-state(state.value)}

public lostanza defn state (r:ref<Random>) -> ref<Long> :
  return new Long{r.state}

public lostanza defn set-state (r:ref<Random>, state:ref<Long>) -> ref<False> :
  r.state = state.value
  return false

public defn Random () :
  Random(current-time-us())

public lostanza defn next-int (r:ref<Random>) -> ref<Int> :
  return new Int{next-bits(r, 31)}

public lostanza defn next-signed-int (r:ref<Random>) -> ref<Int> :
  return new Int{next-bits(r, 32)}

val LIMIT-STR = String("limit")
public lostanza defn next-int (r:ref<Random>, n0:ref<Int>) -> ref<Int> :
  ensure-positive(LIMIT-STR, n0)

  ;Extract lostanza values
  val n = n0.value

  ;Power of 2
  if n & (- n) == n :
    val bits = next-bits(r, 31) as long
    return new Int{((n * bits) >> 31) as int}

  ;Otherwise
  labels :
    loop :
      val bits = next-bits(r, 31)
      val v = bits % n
      if bits - v + (n - 1) < 0 : goto loop
      else : return new Int{v}

public lostanza defn next-bytes (r:ref<Random>, bs:ref<ByteArray>) -> ref<False> :
  val n = bs.length
  labels :
    begin: goto loop(r.state, 0)
    loop (s:long, i:long) :
      if i + 4 < n :
        val s* = next-state(s)
        [addr!(bs.data[i]) as ptr<int>] = extract-bits(s*, 32)
        goto loop(s*, i + 4)
      else : goto end(s, i)
    end (s:long, i:long) :
      if i < n :
        val s* = next-state(s)
        bs.data[i] = extract-bits(s*, 8) as byte
        goto end(s*, i + 1)
      else :
        r.state = s
        return false

public defn next-int (rand:Random, r:Range) :
  ;Returns an integer between lo and hi inclusive
  defn from-interval (lo:Int, hi:Int) :
    val spread = hi - lo + 1
    if spread < 0 :
      let loop () :
        val r = next-int(rand)
        if r >= lo and r <= hi : r
        else : loop()
    else :
      lo + next-int(rand, spread)

  ;Check
  #if-not-defined(OPTIMIZE) :
    if step(r) != 1 :
      fatal("Ranges with step sizes other than 1 not supported.")
  val s = start(r)
  match(end(r), inclusive?(r)) :
    (e:Int, inc:True) :
      ensure-start-before-end(s, e)
      from-interval(s, e)
    (e:Int, inc:False) :
      #if-not-defined(OPTIMIZE) :
        if e == s : fatal("Empty range.")
        else : ensure-start-before-end(s, e)
      from-interval(s, e - 1)
    (e:False, inc) :
      from-interval(s, INT-MAX)

public lostanza defn next-long (rand:ref<Random>) -> ref<Long> :
  val x0 = next-bits(rand, 31) as long
  val x1 = next-bits(rand, 32) as long & 0xFFFFFFFFL
  val r0 = (x0 << 32L)
  return new Long{x0 << 32L | x1}

public lostanza defn next-signed-long (rand:ref<Random>) -> ref<Long> :
  val x0 = next-bits(rand, 32) as long
  val x1 = next-bits(rand, 32) as long & 0xFFFFFFFFL
  return new Long{x0 << 32L | x1}

public lostanza defn next-float (rand:ref<Random>) -> ref<Float> :
  return new Float{next-bits(rand,24) as float / (1 << 24) as float}

public lostanza defn next-double (rand:ref<Random>) -> ref<Double> :
  val num = ((next-bits(rand, 26) as long) << 27) + next-bits(rand, 27)
  val den = (1L << 53L) as double
  return new Double{num as double / den}

val RANDOM = Random(current-time-us())
public defn current-random () : RANDOM
public defn srand (n:Long) : set-state(RANDOM, n)
public defn rand () : next-int(RANDOM)
public defn rand-long () : next-long(RANDOM)
public defn rand-float () : next-float(RANDOM)
public defn rand-double () : next-double(RANDOM)
public defn rand (n:Int) : next-int(RANDOM, n)
public defn rand (r:Range) : next-int(RANDOM, r)

;============================================================
;======================== Sleep =============================
;============================================================

extern sleep_us : long -> int
public lostanza defn sleep-us (us:ref<Long>) -> ref<False> :
  val res = call-c sleep_us(us.value)
  if res < 0 : throw(SystemCallException(linux-error-msg()))
  return false

;============================================================
;======================= Platform ===========================
;============================================================

public defenum Platform :
  Windows
  Linux
  OS-X

public val CURRENT-PLATFORM:Platform =
  #if-defined(PLATFORM-WINDOWS) :
    Windows
  #else :
    #if-defined(PLATFORM-OS-X) :
      OS-X
    #else :
      #if-defined(PLATFORM-LINUX) :
        Linux
      #else :
        fatal("Unreachable")

;============================================================
;=================== Process Library ========================
;============================================================

;                   Process Structure
;                   =================

val PIPE-ID-GENERATOR = Random()

public lostanza deftype Process :
  var pid: long
  var pipeid: int
  var input: ptr<?>
  var output: ptr<?>
  var error: ptr<?>
  var input-stream: ref<False|FileOutputStream>
  var output-stream: ref<False|FileInputStream>
  var error-stream: ref<False|FileInputStream>

;                 Process State Structure
;                 =======================

public deftype ProcessState
public defstruct ProcessRunning <: ProcessState
public defstruct ProcessDone <: ProcessState : (value:Int)
public defstruct ProcessTerminated <: ProcessState : (signal:Int)
public defstruct ProcessStopped <: ProcessState : (signal:Int)

defmethod print (o:OutputStream, s:ProcessState) :
  print{o, _} $ match(s) :
    (s:ProcessRunning) : "Running"
    (s:ProcessDone) : "Done(exit value = %_)" % [value(s)]
    (s:ProcessTerminated) : "Terminated(signal = %_)" % [signal(s)]
    (s:ProcessStopped) : "Stopped(signal = %_)" % [signal(s)]

;                   Stream Specifier
;                   ================

public defstruct StreamSpecifier <: Equalable : (value:Int)
public val STANDARD-IN = StreamSpecifier(0)
public val STANDARD-OUT = StreamSpecifier(1)
public val PROCESS-IN = StreamSpecifier(2)
public val PROCESS-OUT = StreamSpecifier(3)
public val STANDARD-ERR = StreamSpecifier(4)
public val PROCESS-ERR = StreamSpecifier(5)

defmethod equal? (a:StreamSpecifier, b:StreamSpecifier) :
  value(a) == value(b)

defmethod print (o:OutputStream, s:StreamSpecifier) :
  print{o, _} $ switch(value(s)) :
    0 : "STANDARD-IN"
    1 : "STANDARD-OUT"
    2 : "PROCESS-IN"
    3 : "PROCESS-OUT"
    4 : "STANDARD-ERR"
    5 : "PROCESS-ERR"

;                      Process Errors
;                      ==============
public defstruct ProcessAbortedError <: Exception :
  state: ProcessState
defmethod print (o:OutputStream, e:ProcessAbortedError) :
  match(state(e)) :
    (s:ProcessTerminated) : print(o, "Process prematurely terminated with signal %_." % [signal(s)])
    (s:ProcessStopped) : print(o, "Process prematurely stopped with signal %_." % [signal(s)])

public deftype SystemCallException <: Exception
defn SystemCallException (msg:String) :
  new SystemCallException :
    defmethod print (o:OutputStream, this) :
      print(o, msg)

;                           Constructor
;                           ===========
#if-defined(PLATFORM-WINDOWS):
  public lostanza defn Process (filename:ref<String>,
                                args0:ref<Seqable<String>>,
                                input:ref<StreamSpecifier>,
                                output:ref<StreamSpecifier>,
                                error:ref<StreamSpecifier>,
                                working-dir:ref<String|False>) -> ref<Process> :
    ensure-valid-stream-specifiers(input, output, error)
    val proc = new Process{0, -1, null, null, null, false, false, false}

    ; Create a command line from the given filename and args (discarding the first argument).
    ; This is necessary because Windows' process API expects a command line (not a list of arguments).
    ; We discard the first argument because, on Windows, the first argument is used to look-up
    ; the executable (e.g. in the current directiory, in the PATH, etc.) whereas on POSIX
    ; it is typically only exists as a convention.
    val args = cons(filename, tail(to-list(args0)))
    val command-line = escape-shell-command(args)
    val input_v = value(input).value
    val output_v = value(output).value
    val error_v = value(error).value

    ;Retrieve the characters of the working directory (or null if false).
    var working-dir-chars:ptr<byte>
    match(working-dir) :
      (working-dir:ref<String>) : working-dir-chars = addr!(working-dir.chars)
      (working-dir:ref<False>) : working-dir-chars = null

    ;Launch the process
    val launch_success = call-c clib/launch_process(
      addr!(command-line.chars), input_v, output_v, error_v, working-dir-chars, addr!([proc]))
    ;Throw an exception if launch failed.
    if launch_success != 0 :
      throw(SystemCallException(windows-error-msg()))
    ;Return the newly created process.
    return proc
#else:
  public lostanza defn Process (filename:ref<String>,
                                args0:ref<Seqable<String>>,
                                input:ref<StreamSpecifier>,
                                output:ref<StreamSpecifier>,
                                error:ref<StreamSpecifier>,
                                working-dir:ref<String|False>) -> ref<Process> :
    ensure-valid-stream-specifiers(input, output, error)
    val args = to-tuple(args0)
    val pipe-id = next-int(PIPE-ID-GENERATOR).value
    val proc = new Process{0, pipe-id, null, null, null, false, false, false}
    val input_v = value(input).value
    val output_v = value(output).value
    val error_v = value(error).value
    val nargs = args.length
    val argvs:ptr<ptr<byte>> = call-c clib/malloc((nargs + 1) * sizeof(ptr<?>))
    argvs[nargs] = null
    for (var i:long = 0, i < nargs, i = i + 1) :
      argvs[i] = addr!(args.items[i].chars)

    ;Retrieve the characters of the working directory (or null if false).
    var working-dir-chars:ptr<byte>
    match(working-dir) :
      (working-dir:ref<String>) : working-dir-chars = addr!(working-dir.chars)
      (working-dir:ref<False>) : working-dir-chars = null
    ;Launch the process
    val launch_succ = call-c clib/launch_process(addr!(filename.chars), argvs,
      input_v, output_v, error_v, proc.pipeid, working-dir-chars, addr!([proc]))
    ;Throw an exception if launch failed.
    if launch_succ != 0 :
      throw(SystemCallException(linux-error-msg()))
    ;Return the newly created process.
    return proc

public defn Process (filename:String, args:Seqable<String>,
                     input:StreamSpecifier, output:StreamSpecifier, error:StreamSpecifier) -> Process :
  Process(filename, args, input, output, error, false)

public defn Process (filename:String, args:Seqable<String>) :
  Process(filename, args, STANDARD-IN, STANDARD-OUT, STANDARD-ERR, false)

defn ensure-valid-stream-specifiers (input:StreamSpecifier, output:StreamSpecifier, error:StreamSpecifier) :
  if not contains?([STANDARD-IN, PROCESS-IN], input) :
    fatal("%_ is not a valid input stream specifier." % [input])
  if not contains?([STANDARD-OUT, PROCESS-OUT, PROCESS-ERR], output) :
    fatal("%_ is not a valid output stream specifier." % [output])
  if not contains?([STANDARD-ERR, PROCESS-OUT, PROCESS-ERR], error) :
    fatal("%_ is not a valid error stream specifier." % [error])

;                            Stream API
;                            ==========
public lostanza defn input-stream (p:ref<Process>) -> ref<FileOutputStream> :
  if p.input-stream == false :
    if p.input == null : fatal(String("Process has no input stream."))
    p.input-stream = new FileOutputStream{p.input, 0}
  return p.input-stream as ref<FileOutputStream>
public lostanza defn output-stream (p:ref<Process>) -> ref<InputStream> :
  if p.output-stream == false :
    if p.output == null : fatal(String("Process has no output stream."))
    p.output-stream = new FileInputStream{p.output, 0}
  return p.output-stream as ref<FileInputStream>
public lostanza defn error-stream (p:ref<Process>) -> ref<InputStream> :
  if p.error-stream == false :
    if p.error == null : fatal(String("Process has no error stream."))
    p.error-stream = new FileInputStream{p.error, 0}
  return p.error-stream as ref<FileInputStream>

;                          Initialization
;                          ==============
public lostanza defn initialize-process-launcher () -> ref<False> :
  #if-not-defined(PLATFORM-WINDOWS):
    call-c clib/initialize_launcher_process()
  return false

;                            State API
;                            =========
lostanza deftype StateStruct :
  var state: int
  var code: int
lostanza defn retrieve-state (p:ref<Process>, wait-for-termination?:ref<True|False>) -> ref<ProcessState> :
  val s = new StateStruct{0, 0}
  call-c clib/retrieve_process_state(p.pid, addr!([s]), (wait-for-termination? == true) as int)

  ;State Codes
  val RUNNING = 0
  val DONE = 1
  val TERMINATED = 2
  val STOPPED = 3

  #if-not-defined(PLATFORM-WINDOWS):
    if s.state != RUNNING and p.pipeid != -1 :
      val res = call-c clib/delete_process_pipes(p.input, p.output, p.error, p.pipeid)
      if res < 0 :
        throw(SystemCallException(linux-error-msg()))
      p.pipeid = -1

  ;Translation
  if s.state == RUNNING :
    return ProcessRunning()
  else if s.state == DONE :
    return ProcessDone(new Int{s.code})
  else if s.state == TERMINATED :
    return ProcessTerminated(new Int{s.code})
  else if s.state == STOPPED :
    return ProcessStopped(new Int{s.code})
  else :
    return fatal(String("Unreachable"))

public defn state (p:Process) :
  retrieve-state(p, false)

public defn* wait (p:Process) :
  val s = retrieve-state(p, true)
  match(s:ProcessRunning) : wait(p)
  else : s

;                         System Call API
;                         ===============
public defn call-system (file:String, args:Seqable<String>) -> Int :
  match(wait(Process(file, args))) :
    (s:ProcessDone) : value(s)
    (s) : throw(ProcessAbortedError(s))

;============================================================
;=========== Call System and Retrieve Output ================
;============================================================

public defn call-system-and-get-output (file:String, args:Seqable<String>) -> String :
  val buffer = StringBuffer()
  val proc = Process(file, args, STANDARD-IN, PROCESS-OUT, PROCESS-OUT)
  val proc-out = output-stream(proc)
  let loop () :
    val c = get-char(proc-out)
    match(c:Char) :
      add(buffer,c)
      loop()
  wait(proc)
  to-string(buffer)

;============================================================
;=============== Replace Current Process ====================
;============================================================

public defn replace-current-process (path:String, args:Tuple<String>) :
  replace-current-process(path, args, true)

public lostanza defn replace-current-process (path:ref<String>,
                                              args:ref<Tuple<String>>,
                                              resolve-path?:ref<True|False>) -> ref<Void> :
  ;Create null-terminated C-array of arguments
  val len = length(args).value
  val argvs:ptr<ptr<byte>> = call-c clib/malloc((len + 1) * sizeof(ptr<byte>))
  for (var i:long = 0L, i < len, i = i + 1) :
    argvs[i] = addr!(args.items[i].chars)
  argvs[len] = null
  ;Call either execvp or execv
  var result:int
  if resolve-path? == true :
    result = call-c clib/execvp(addr!(path.chars), argvs)
  else :
    result = call-c clib/execv(addr!(path.chars), argvs)
  ;Issue error
  return throw(SystemCallException(linux-error-msg()))

;============================================================
;================== Shell Escaping ==========================
;============================================================

;Tokenize shell command:
;The C programming language models incoming command-line arguments as
;an array of strings, however when interacting with the terminal,
;the user actually types in a shell command as a single long string.
;This function takes as input the shell command typed by the user
;and tokenizes it into the array of strings that would be
;passed to the C main function.

public defn tokenize-shell-command (s:String) -> Collection<String> :
  defn whitespace? (c:Char) :
    (c == ' ') or
    (c == '\n') or
    (c == '\t') or
    (c == '\b') or
    (c == '\r')

  ;Buffer management
  val buffer = StringBuffer()
  val args = Vector<String>()
  defn add-char (c:Char) :
    add(buffer, c)
  defn make-arg () :
    add(args, to-string(buffer))
    clear(buffer)

  ;View characters as stream
  val stream = StringInputStream(s)

  ;Determine whether backslashes are an escape
  ;character
  val backslash-escape? = CURRENT-PLATFORM is OS-X|Linux

  ;General read dispatch
  defn* read () :
    val c = peek?(stream)
    match(c:Char) :
      if whitespace?(c) :
        get-char(stream)
        read()
      else :
        read-arg()

  defn* read-arg () :
    val c = peek?(stream)
    match(c:Char) :
      if whitespace?(c) :
        make-arg()
        read()
      else if c == '"' or c == '\'' :
        get-char(stream)
        read-until(c)
        read-arg()
      else if backslash-escape? and c == '\\' :
        get-char(stream)
        val c2 = get-char(stream)
        match(c2:Char) :
          add-char(c2)
          read-arg()
        else :
          make-arg()
      else :
        get-char(stream)
        add-char(c)
        read-arg()
    else :
      make-arg()


  defn* read-until (end:Char) :
    val c = get-char(stream)
    match(c:Char) :
      if c == '\\' :
        val c2 = peek?(stream)
        match(c2:Char) :
          if c2 == end :
            get-char(stream)
            add-char(c2)
            read-until(end)
          else :
            add-char(c)
            read-until(end)
        else :
          add-char(c)
      else if c != end :
        add-char(c)
        read-until(end)

  ;End
  read()
  args

;Escape shell command:
;The C programming language models incoming command-line arguments as
;an array of strings, however when interacting with the terminal,
;the user actually types in a shell command as a single long string.
;This function takes an array of command-line arguments (as given to C)
;and returns the shell command that the user would have typed.
;Windows is handled specially in that the first argument
;must be escaped differently than the remaining arguments.

public defn escape-shell-command (args:Seqable<String>) -> String :
  #if-defined(PLATFORM-WINDOWS) :
    defn escape (s:String, i:Int) :
      val s* =
        replace{_, "\"", "\\\""} $
        replace{_, "\\", "\\\\"} $
        s
      if i == 0 : s*
      else : "\"%_\"" % [s*]
    val escaped = seq(escape, args, 0 to false)
    to-string("%s" % [escaped])
  #else :
    defn escape (s:String) :
      {"\"%_\"" % [_]} $
      replace{_, "\"", "\\\""} $
      replace{_, "\\", "\\\\"} $
      s
    to-string("%s" % [seq(escape, args)])

;============================================================
;===================== Id Pool ==============================
;============================================================

val ID-SEQ = to-seq(0 to false)
val FREE-IDS = Vector<Int>()
val OBJ-MAP = Vector<?>()

public lostanza defn box-object (x:ref<?>) -> int :
   var id:ref<Int>
   if empty?(FREE-IDS) == true : id = next(ID-SEQ)
   else : id = pop(FREE-IDS)
   set(OBJ-MAP, id, x)
   return id.value

public lostanza defn free-box (id:int) -> ref<?> :
   add(FREE-IDS, new Int{id})
   val obj = get(OBJ-MAP, new Int{id})
   set(OBJ-MAP, new Int{id}, false)
   return obj

public lostanza defn boxed-object (id:int) -> ref<?> :
   return get(OBJ-MAP, new Int{id})

;============================================================
;==================== Resources =============================
;============================================================

public deftype Resource
public defmulti free (r:Resource) -> False

protected defn with-resource<?T,?S> (f:T -> ?S, x:?T&Resource) -> S :
   try : f(x)
   finally : free(x)

;============================================================
;==================== Autofree ==============================
;============================================================
;
;lostanza deftype FreeCallback :
;   c-convention:int
;   free:ptr<(ptr<?> -> int)>
;   value:ptr<?>
;
;lostanza defn free (c:ref<FreeCallback>) -> ref<False> :
;   if c.c-convention :
;      call-c [c.free](c.value)
;   else :
;      [c.free](c.value)
;   return false
;
;public lostanza defn c-autofree-marker (free:ptr<(ptr<?> -> int)>, value:ptr<?>) -> ref<LivenessMarker> :
;   val t = LivenessTracker(new FreeCallback{1, free, value})
;   add(FREE-CALLBACKS, t)
;   return marker!(t)
;
;public lostanza defn autofree-marker (free:ptr<(ptr<?> -> int)>, value:ptr<?>) -> ref<LivenessMarker> :
;   val t = LivenessTracker(new FreeCallback{0, free, value})
;   add(FREE-CALLBACKS, t)
;   return marker!(t)
;
;val FREE-CALLBACKS = Vector<LivenessTracker<FreeCallback>>()
;add-gc-notifier $ fn () :
;   for t in FREE-CALLBACKS remove-when :
;      if marker(t) is False :
;         free(value(t))
;         true
;
;============================================================
;=================== Pretty Printer =========================
;============================================================

;                  General Interface
;                  =================

public defmulti write (o:OutputStream, x) -> False

;                Default Implementation
;                ======================

defmethod write (o:OutputStream, x) :
   print(o, x)

public defn write-all (o:OutputStream, xs:Seqable) -> False :
   val xs-seq = to-seq(xs)
   if not empty?(xs-seq) :
      write(o, next(xs-seq))
   while not empty?(xs-seq) :
      print(o, " ")
      write(o, next(xs-seq))

;                 Convenience Functions
;                 =====================


public defn writeln (o:OutputStream, x) :
  write(o, x)
  print(o, NL)

public defn lnwrite (o:OutputStream, x) :
  print(o, NL)
  write(o, x)

public defn writeln-all (o:OutputStream, xs:Seqable) :
  write-all(o, xs)
  print(o, NL)

public defn written (x) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      write(o, x)

;              Write to Current Output Stream
;              ==============================

public defn write (x) :
  write(CURRENT-OUTPUT-STREAM, x)

public defn write-all (xs:Seqable) :
  write-all(CURRENT-OUTPUT-STREAM, xs)

public defn writeln (x) :
  writeln(CURRENT-OUTPUT-STREAM, x)

public defn lnwrite (x) :
  lnwrite(CURRENT-OUTPUT-STREAM, x)

public defn writeln-all (xs:Seqable) :
  writeln-all(CURRENT-OUTPUT-STREAM, xs)


;                    Escape Sequences
;                    ================

defn general-escape (o:OutputStream, c:Char) :
   defn escape (c:Char) :
      print(o, '\\')
      print(o, c)
   switch {c == _} :
      '\t' : escape('t')
      '\b' : escape('b')
      '\r' : escape('r')
      '\n' : escape('n')
      '\\' : escape('\\')
      else : print(o, c)

defn escape-for-string (o:OutputStream, c:Char) :
   if c == '\"' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

defn escape-for-symbol (o:OutputStream, c:Char) :
   if c == '|' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

defn escape-for-char (o:OutputStream, c:Char) :
   if c == '\'' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

;              Determination Whether Symbol Requires Escape
;              ============================================

lostanza var NECESSARY-IDENTIFIER-CHARS:ref<String>
lostanza var IDENTIFIER-CHARS:ref<String>
lostanza var OPERATOR-CHARS:ref<String>

lostanza defn tag-char (table:ref<String>, c:byte) -> int :
   table.chars[c] = 1 as byte
   return 0

lostanza defn tag-chars (table:ref<String>, cs:ptr<byte>) -> int :
   for (var i:long = 0, 1, i = i + 1) :
      val c = cs[i]
      if c == 0 : return 0
      tag-char(table, c)
   fatal("Unreachable")
   return 0

lostanza let :
  NECESSARY-IDENTIFIER-CHARS = String(256, 0 as byte)
  IDENTIFIER-CHARS = String(256, 0 as byte)
  OPERATOR-CHARS = String(256, 0 as byte)

  val L = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
  val U = "_?"
  val D = "0123456789"
  val P = "~!@#$%^*+-=/"
  val S = ".:<>&|"

  tag-chars(NECESSARY-IDENTIFIER-CHARS, L)
  tag-chars(NECESSARY-IDENTIFIER-CHARS, U)

  tag-chars(IDENTIFIER-CHARS, L)
  tag-chars(IDENTIFIER-CHARS, U)
  tag-chars(IDENTIFIER-CHARS, D)
  tag-chars(IDENTIFIER-CHARS, P)

  tag-chars(OPERATOR-CHARS, P)
  tag-chars(OPERATOR-CHARS, S)

public deftype SymbolParseClass
public defstruct NumberClass <: SymbolParseClass
public defstruct IdentifierClass <: SymbolParseClass
public defstruct OperatorClass <: SymbolParseClass

defmethod print (o:OutputStream, c:SymbolParseClass) :
  print{o, _} $ match(c) :
    (c:NumberClass) : "Number"
    (c:IdentifierClass) : "Identifier"
    (c:OperatorClass) : "Operator"

lostanza defn digit-char? (b:byte) -> long :
  if b >= '0' and b <= '9' : return 1
  else : return 0

lostanza defn gensymbol? (s:ref<Symbol>) -> long :
  match(s) :
    (s:ref<GenSymbol>) : return 1
    (s) : return 0

public lostanza defn parse-as? (c:ref<Symbol>) -> ref<SymbolParseClass|False> :
  ;Does it parse as a number?
  val name = name(c)
  val l = length(name).value
  if (l == 0 and gensymbol?(c)) or
     digit-char?(name.chars[0]) or
     (name.chars[0] == '-' and l == 1 and gensymbol?(c)) or
     (name.chars[0] == '-' and l > 1 and digit-char?(name.chars[1])) :
    return NumberClass()

  ;Collect statistics
  var all-id:long = 1
  var all-op:long = 1
  var has-nid:long = 0
  for (var i:long = 0, i < l, i = i + 1) :
    val c = name.chars[i]
    if NECESSARY-IDENTIFIER-CHARS.chars[c] == 1 : has-nid = 1
    if IDENTIFIER-CHARS.chars[c] == 0 : all-id = 0
    if OPERATOR-CHARS.chars[c] == 0 : all-op = 0
  if gensymbol?(c) : all-op = 0

  ;Classify
  if l == 0 : return false
  else if all-id and has-nid : return IdentifierClass()
  else if all-op : return OperatorClass()
  else : return false

public defn escape? (s:Symbol) :
  parse-as?(s) is NumberClass|False

;                  Escaped Primitive Values
;                  ========================

defmethod write (o:OutputStream, c:Char) :
   print(o, '\'')
   escape-for-char(o, c)
   print(o, '\'')

defmethod write (o:OutputStream, s:String) :
   print(o, '"')
   for c in s do :
      escape-for-string(o, c)
   print(o, '"')

defmethod write (o:OutputStream, x:Byte) :
   print(o, x)
   print(o, 'Y')

defmethod write (o:OutputStream, x:Long) :
   print(o, x)
   print(o, 'L')

defmethod write (o:OutputStream, b:Float) :
   print(o, b)
   print(o, 'f')

defmethod write (o:OutputStream, s:StringSymbol) :
   if escape?(s) :
      print(o, "\\|")
      for c in name(s) do :
         escape-for-symbol(o, c)
      print(o, '|')
   else :
      print(o, name(s))

defmethod write (o:OutputStream, s:GenSymbol) :
   if escape?(s) :
      print(o, "\\|")
      for c in name(s) do :
         escape-for-symbol(o, c)
      print(o, id(s))
      print(o, '|')
   else :
      print(o, name(s))
      print(o, id(s))

;============================================================
;===================== Timers ===============================
;============================================================

public lostanza defn current-time-ms () -> ref<Long> :
   val ms = call-c clib/current_time_ms()
   return new Long{ms}

public lostanza defn current-time-us () -> ref<Long> :
   val us = call-c clib/current_time_us()
   return new Long{us}

public deftype Timer
public defmulti start (t:Timer) -> False
public defmulti stop (t:Timer) -> False
public defmulti time (t:Timer) -> Long
public defmulti running? (t:Timer) -> True|False

defn Timer (name:String, get-time: () -> Long) :
   var total-time:Long = 0L
   var last-time:Long = 0L
   var running = false
   new Timer :
      defmethod start (this) :
         fatal("Timer already running.") when running
         last-time = get-time()
         running = true
      defmethod stop (this) :
         fatal("Timer is not running.") when not running
         val time = get-time()
         total-time = total-time + time - last-time
         last-time = time
         running = false
      defmethod time (this) :
         if running : total-time + get-time() - last-time
         else : total-time
      defmethod running? (this) :
         running
      defmethod print (o:OutputStream, this) :
         print(o, "[%_ Timer : %_]" % [name, time(this)])

public defn MillisecondTimer (name:String) :
   Timer(name, current-time-ms)

public defn MicrosecondTimer (name:String) :
   Timer(name, current-time-us)

public defn PiggybackTimer (name:String, t:Timer) :
   Timer(name, time{t})

;============================================================
;==================== Reified Types =========================
;============================================================

public deftype TypeObject<T>
public defmulti typeof?<?T> (x, t:TypeObject<?T>) -> True|False
public defmulti name (t:TypeObject) -> String

;############################################################
;################## Math Package ############################
;############################################################

defpackage math :
   import core

public lostanza val PI:ref<Double> = new Double{3.141592653589793}
public lostanza val PI-F:ref<Float> = new Float{3.1415927f}

public lostanza defn exp (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/exp(x.value)}
public lostanza defn exp (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/exp(x.value) as float}

public lostanza defn log (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/log(x.value)}
public lostanza defn log (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/log(x.value) as float}

public lostanza defn log10 (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/log10(x.value)}
public lostanza defn log10 (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/log10(x.value) as float}

public lostanza defn sqrt (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sqrt(x.value)}
public lostanza defn sqrt (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sqrt(x.value) as float}

public lostanza defn pow (x:ref<Double>, y:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/pow(x.value, y.value)}
public lostanza defn pow (x:ref<Float>, y:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/pow(x.value, y.value) as float}

public lostanza defn sin (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sin(x.value)}
public lostanza defn sin (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sin(x.value) as float}

public lostanza defn cos (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/cos(x.value)}
public lostanza defn cos (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/cos(x.value) as float}

public lostanza defn tan (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/tan(x.value)}
public lostanza defn tan (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/tan(x.value) as float}

public lostanza defn asin (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/asin(x.value)}
public lostanza defn asin (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/asin(x.value) as float}

public lostanza defn acos (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/acos(x.value)}
public lostanza defn acos (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/acos(x.value) as float}

public lostanza defn atan (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/atan(x.value)}
public lostanza defn atan (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/atan(x.value) as float}

public lostanza defn atan2 (y:ref<Double>, x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/atan2(y.value, x.value)}
public lostanza defn atan2 (y:ref<Float>, x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/atan2(y.value, x.value) as float}

public lostanza defn sinh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sinh(x.value)}
public lostanza defn sinh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sinh(x.value) as float}

public lostanza defn cosh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/cosh(x.value)}
public lostanza defn cosh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/cosh(x.value) as float}

public lostanza defn tanh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/tanh(x.value)}
public lostanza defn tanh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/tanh(x.value) as float}

public lostanza defn ceil (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/ceil(x.value)}
public lostanza defn ceil (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/ceil(x.value) as float}

public lostanza defn floor (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/floor(x.value)}
public lostanza defn floor (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/floor(x.value) as float}

public lostanza defn round (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/round(x.value)}
public lostanza defn round (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/round(x.value) as float}

public lostanza defn to-radians (degrees:ref<Double>) -> ref<Double> :
   val pi = 3.141592653589793
   return new Double{degrees.value * pi / 180.0}

public lostanza defn to-degrees (radians:ref<Double>) -> ref<Double> :
   val pi = 3.141592653589793
   return new Double{radians.value * 180.0 / pi}
