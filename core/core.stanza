;See License.txt for details about licensing.

;############################################################
;################## C Externs ###############################
;############################################################

defpackage clib

protected extern remove: (ptr<byte>) -> int
protected extern fclose: (ptr<?>) -> int
protected extern fopen: (ptr<byte>, ptr<byte>) -> ptr<?>
protected extern fputs: (ptr<byte>, ptr<?>) -> int
protected extern fputc: (byte, ptr<?>) -> int
protected extern fgetc: (ptr<?>) -> int
protected extern ferror: (ptr<?>) -> int
protected extern fprintf: (ptr<?>, ptr<byte>, ? ...) -> int
protected extern sprintf: (ptr<byte>, ptr<byte>, ? ...) -> int
protected extern sscanf: (ptr<byte>, ptr<byte>, ptr<?> ...) -> int
protected extern printf: (ptr<byte>, ? ...) -> int
protected extern malloc: long -> ptr<?>
protected extern free: ptr<?> -> int
protected extern exit: int -> int
protected extern get_stdout: () -> ptr<?>
protected extern get_stderr: () -> ptr<?>
protected extern get_stdin: () -> ptr<?>
protected extern get_eof: () -> int
protected extern rand: () -> int
protected extern input_argc: int
protected extern input_argv: ptr<ptr<byte>>
protected extern strlen: ptr<byte> -> int
protected extern current_time_us: () -> long
protected extern current_time_ms: () -> long
protected extern getenv: (ptr<byte>) -> ptr<byte>
protected extern setenv: (ptr<byte>, ptr<byte>, int) -> int
protected extern system: (ptr<byte>) -> int
protected extern strerror: (int) -> ptr<byte>
protected extern get_errno: () -> int
protected extern resolve_path: (ptr<byte>) -> ptr<byte>
protected extern get_file_size: ptr<?> -> long
protected extern file_set_length: (ptr<?>, long) -> int
protected extern file_seek: (ptr<?>, long) -> int
protected extern file_skip: (ptr<?>, long) -> int
protected extern file_read_block: (ptr<?>, ptr<byte>, long) -> long
protected extern file_write_block: (ptr<?>, ptr<byte>, long) -> long

;Math libraries
protected extern exp: double -> double
protected extern log: double -> double
protected extern log10: double -> double
protected extern sqrt: double -> double
protected extern pow: (double, double) -> double
protected extern sin: double -> double
protected extern cos: double -> double
protected extern tan: double -> double
protected extern asin: double -> double
protected extern acos: double -> double
protected extern atan: double -> double
protected extern atan2: (double, double) -> double
protected extern sinh: double -> double
protected extern cosh: double -> double
protected extern tanh: double -> double
protected extern ceil: double -> double
protected extern floor: double -> double
protected extern round: double -> double

;############################################################
;################## Core Package ############################
;############################################################

defpackage core :
   import collections

;============================================================
;================== Core Types ==============================
;============================================================

public :
   deftype Seqable<T>
   deftype Seq<T> <: Seqable<T>
   deftype Collection<T> <: Seqable<T>

   deftype Lengthable

   deftype Equalable

   deftype Hashable

   deftype Comparable<T>

   deftype OutputStream

   lostanza deftype FileOutputStream <: OutputStream :
      file: ptr<?>
      closable?: long

   deftype InputStream
   lostanza deftype FileInputStream <: InputStream :
      file: ptr<?>
      closable?: long
   deftype StringInputStream <: InputStream & Lengthable

   deftype BufferedInputStream <: InputStream

   lostanza deftype RandomAccessFile :
      file: ptr<?>
      writable: ref<True|False>

   deftype Maybe<T> <: Equalable & Comparable<Maybe<T>>
   deftype None <: Maybe<Void>
   deftype One<T> <: Maybe<T>

   deftype Coroutine<I,O> <: Equalable

   deftype Range <: Collection<Int> & Equalable

   lostanza deftype Byte <: Equalable & Hashable & Comparable<Byte> :
      value: byte

   lostanza deftype Char <: Equalable & Hashable & Comparable<Char> :
      value: byte

   lostanza deftype Int <: Equalable & Hashable & Comparable<Int> :
      value: int

   lostanza deftype Long <: Equalable & Hashable & Comparable<Long> :
      value: long

   lostanza deftype Float <: Equalable & Hashable & Comparable<Float> :
      value: float

   lostanza deftype Double <: Equalable & Hashable & Comparable<Double> :
      value: double

   lostanza deftype String <: Lengthable & Collection<Char> & Equalable & Hashable & Comparable<String> :
      length: long
      hash: int
      chars: byte ...

   deftype Symbol <: Equalable & Hashable

   deftype List<T> <: Lengthable & Collection<T> & Equalable & Hashable & Comparable<List<T>>

   lostanza deftype True <: Equalable
   lostanza deftype False <: Equalable

   lostanza deftype Tuple<T> <: Lengthable & Collection<T> & Equalable & Hashable & Comparable<Tuple<T>> :
      length: long
      items: ref<T> ...

   deftype IndexedCollection<T> <: Lengthable & Collection<T>

   deftype Array<T> <: IndexedCollection<T> & Equalable

   lostanza deftype CharArray <: Array<Char> :
      length: long
      chars: byte ...

   lostanza deftype ByteArray <: Array<Byte> :
      length: long
      data: byte ...

   lostanza deftype LivenessMarker :
      id: long

   lostanza deftype LivenessTracker<T> :
      marker: ref<False|Sentinel|LivenessMarker>
      value: ref<T>
      next: ref<False|LivenessTracker>

   deftype StringBuffer <: IndexedCollection<Char> & OutputStream

   deftype FileInfo <: Equalable & Hashable & Comparable<FileInfo>

   deftype Token <: Equalable

   deftype KeyValue<K,V> <: Equalable & Hashable

   deftype Exception

   ;System File/Dir Handling
   ;Command Prompt Execution
   ;Slices

;============================================================
;================ Internal Types ============================
;============================================================

lostanza deftype Fn :
   length: long
   code: ptr<?>
   free: ref<?> ...
lostanza deftype Box :
   item: ref<?>
lostanza deftype Type :
   length: long
   code: ptr<?>
   free: ref<?> ...
lostanza deftype Stack :
   position: int
   mark: int
   parent: ref<False|Stack>
   sp: ptr<?>
   frames: StackFrame ...
lostanza deftype StackFrame :
   ret: ptr<?>
   map: ptr<RefMap>
   items: long ...
lostanza deftype RefMap :
   length: long
   bits: long ...
lostanza deftype FileInfoTable :
   length: long
   entries: FileInfoEntry ...
lostanza deftype FileInfoEntry :
   lbl: ptr<?>
   file: ptr<byte>
   line: int
   column: int

;============================================================
;============== Standard Streams ============================
;============================================================

lostanza val stdout:ptr<?> = call-c clib/get_stdout()
lostanza val stderr:ptr<?> = call-c clib/get_stderr()
lostanza val stdin:ptr<?> = call-c clib/get_stdin()
lostanza val EOF:int = call-c clib/get_eof()

;============================================================
;=============== Initialization Phase 0 =====================
;============================================================

;                  Stack Initialization
;                  ====================

extern stanza_stack_size: long
lostanza var num-stacks:long = 1024

lostanza defn parent (s:ref<Stack>) -> ref<Stack> :
   return s.parent as ref<Stack>

lostanza defn initialize-stacks () -> int :
   ;Create stack pool
   val pool:ptr<ref<Stack>> = call-c clib/malloc(sizeof(ref<?>) * num-stacks)
   for (var i:int = 1, i < num-stacks, i = i + 1) :
      val p:ptr<long> = call-c clib/malloc(stanza_stack_size)
      [p] = tagof(Stack) << 3
      val s = (p + 1) as ref<Stack>
      s.position = i << 3
      s.mark = 0
      pool[i] = s

   ;Initialize current stack
   val s = call-prim stack()
   val p = (addr!([s]) - 8) as ptr<long>
   [p] = tagof(Stack) << 3
   s.position = 0
   s.mark = 0
   s.parent = false
   pool[0] = s

   ;Tell Stanza about stack pool
   call-prim set-num-free-stacks(num-stacks - 1)
   call-prim set-free-stacks(addr(pool[1]))
   call-prim set-stack-pool(pool)

   return 0

;                 Heap Initialization
;                 ===================

lostanza var mem-size:long
lostanza var max-mem-size:long
lostanza var heap-mem:ptr<long>
lostanza var free-mem:ptr<long>
lostanza var free-ptr:ptr<long>

lostanza defn initialize-heaps () -> int :
   mem-size = 4L * 1024 * 1024
   max-mem-size = 4L * 1024 * 1024 * 1024
   heap-mem = call-c clib/malloc(mem-size)
   free-mem = call-c clib/malloc(mem-size)
   call-prim set-heap(heap-mem)
   call-prim set-heap-limit(heap-mem + mem-size)
   return 0

;                    Driver
;                    ======

lostanza defn initialize-phase0 () -> int :
   initialize-stacks()
   initialize-heaps()
   return 0

lostanza: initialize-phase0()

;============================================================
;============== Generated Entry Points ======================
;============================================================

lostanza defn cast-error () -> ref<Void> :
   return fatal("Cannot cast value to type.", call-prim sp())

lostanza defn arity-error () -> ref<Void> :
   return fatal("Wrong number of arguments.", call-prim sp())

lostanza defn no-branch-error () -> ref<Void> :
   return fatal("No matching branch.", call-prim sp())

lostanza defn amb-branch-error () -> ref<Void> :
   return fatal("Ambiguous branch.", call-prim sp())

lostanza defn variable-uninitialized-error () -> ref<Void> :
   return fatal("Variable is uninitialized.", call-prim sp())

lostanza defn tuple-length-error () -> ref<Void> :
   return fatal("Tuple has wrong arity for detupling.", call-prim sp())

;============================================================
;================== Stack Traces ============================
;============================================================
lostanza val null:ptr<?> = 0L as ptr<?>

lostanza defn print-stack-trace (end:ptr<?>) -> ref<False> :
   ;Allocate space for storing trace
   ;No trace can be larger than the size of a stack
   val trace-buffer:ptr<ptr<FileInfoEntry>> = call-c clib/malloc(stanza_stack_size)

   ;Print trace starting from current stack
   labels :
      begin :
         goto loop(call-prim stack(), end)
      loop (s:ref<Stack>, end:ptr<?>) :
         labels :
            ;Start with frame past intercepted return frame
            begin :
               val f0 = addr!(s.frames)
               goto store(f0 + frame-size(f0), 0)

            ;Store trace into buffer
            store (s:ptr<StackFrame>, i:int) :
               ;Store the return address into trace buffer
               trace-buffer[i] = info-entry(s.ret)
               ;Continue tracing next frame unless end is reached.
               if s == end : goto print(i)
               else : goto store(s + frame-size(s), i + 1)

            ;Print trace backwards
            print (i:int) :
               if i >= 0 :
                  val e = trace-buffer[i]
                  if e == null :
                     call-c clib/fprintf(stderr, "   at [Unknown Source Location]\n")
                  else :
                     call-c clib/fprintf(stderr, "   at %s:%d.%d\n", e.file, e.line, e.column)
                  goto print(i - 1)

         ;Print parent stack trace
         match(s.parent) :
            (p:ref<Stack>) : goto loop(p, p.sp)
            (p:ref<False>) : ()

   ;Free trace buffer and return
   call-c clib/free(trace-buffer)
   return false

lostanza defn frame-size (s:ptr<StackFrame>) -> long :
   val map = s.map
   return sizeof(StackFrame) + s.map.length * sizeof(long)

lostanza defn info-entry (p:ptr<?>) -> ptr<FileInfoEntry> :
   val table = call-prim info-table() as ptr<FileInfoTable>
   for (var i:long = 0, i < table.length, i = i + 1) :
      val e = table.entries[i]
      if e.lbl == p :
         return addr(table.entries[i])
   return null

;============================================================
;=============== Garbage Collector ==========================
;============================================================

;              Generated Entry Points
;              ======================

;Called when attempting to allocate beyond the heap limit.
lostanza defn extend-heap (sz:long) -> int :
   if gc-running :
      fatal!("Heap access within garbage collector")
   else :
      new-stack<int>{run-garbage-collector()}
      val new-size = enlarged-size(sz)
      if new-size < 0 : fatal!("Out of Memory", call-prim sp())
      else if new-size != mem-size : enlarge-heap(new-size)
      run-gc-notifiers()
   return 0

lostanza defn enlarged-size (sz:long) -> long :
   ;Case 1: Out of memory
   val min-mem-size = call-prim heap() + sz - heap-mem
   if min-mem-size > max-mem-size :
      return -1

   ;Case 2: Safe mem size
   val safe-mem-size = mem-size >>> 1
   if min-mem-size <= safe-mem-size :
      return mem-size

   ;Case 3: Enlarged size
   var new-size:long = mem-size * 2
   while new-size < min-mem-size :
      new-size = new-size * 2
   return min(new-size, max-mem-size)

lostanza defn min (a:long, b:long) -> long :
   if a < b : return a
   else : return b

lostanza defn enlarge-heap (size:long) -> int :
   ;Set new size
   mem-size = size

   ;Enlarge freespace
   call-c clib/free(free-mem)
   free-mem = call-c clib/malloc(mem-size)

   ;Copy to enlarged freespace
   new-stack<int>{run-garbage-collector()}

   ;Enlarge the new freespace to match the new heapspace
   call-c clib/free(free-mem)
   free-mem = call-c clib/malloc(mem-size)
   return 0

;Called when the number of free stacks is 2 or less.
;Running extend-stack uses two stacks (1 for GC, 1 for handling extend-stack during GC).
lostanza var extending-stack:long = 0
lostanza defn extend-stack () -> int :
   if gc-running :
      fatal!("Stack overflow in garbage collector")
   else if extending-stack == 0 :
      extending-stack = 1
      new-stack<int>{run-garbage-collector()}
      if call-prim num-free-stacks() <= 2 :
         fatal!("Stack overflow", call-prim sp())
      extending-stack = 0
      run-gc-notifiers()

   ;Return
   return 0

;                   Main Function
;                   =============

;Main function for garbage collector
lostanza var gc-running:long = 0
lostanza var tracker-chain:ref<False|LivenessTracker>
lostanza defn run-garbage-collector () -> int :   
   ;Mark GC as running to detect stack extension within GC
   gc-running = 1

   ;Initialize free pointer to point to beginning of free memory before copying starts.
   free-ptr = free-mem

   ;Initialize tracker chain
   tracker-chain = false

   ;Current stack is the collection stack, the stack that the GC runs in.
   ;Set its mark bit to indicate that it should not be scanned.
   val current-stack = call-prim stack()
   current-stack.mark = 1

   ;Scan roots
   scan-globals()
   scan-stack(parent(current-stack))

   ;Scan internal pointers of all heap objects
   scan-heap()

   ;Scan liveness trackers
   tracker-chain = scan-trackers(tracker-chain)

   ;Swap free memory with heap
   val swap = heap-mem
   heap-mem = free-mem
   free-mem = swap
   call-prim set-heap(free-ptr)
   call-prim set-heap-limit(heap-mem + mem-size)

   ;All active stacks have their mark bits set.
   free-unmarked-stacks()

   ;Finish
   gc-running = 0
   return 0


;                    Notifiers
;                    =========

var GC-NOTIFIERS : Maybe<Vector<(() -> ?)>> = None()

defn initialize-gc-notifiers () :
   GC-NOTIFIERS = One(Vector<(() -> ?)>())

defn run-gc-notifiers () :
   if not empty?(GC-NOTIFIERS) :
      for f in value!(GC-NOTIFIERS) do :
         f()

public defn add-gc-notifier (f: () -> ?) :
   add(value!(GC-NOTIFIERS), f)


;                Liveness Trackers
;                =================

lostanza defn scan-liveness-tracker (p:ptr<long>) -> ptr<long> :
   p[2] = post-gc-object(p[2])
   p[3] = tracker-chain as long
   tracker-chain = (p + 1) as ref<LivenessTracker>
   return p + 8 + sizeof(LivenessTracker)

lostanza defn post-gc-marker (marker:ref<False|Sentinel|LivenessMarker>) -> ref<False|Sentinel|LivenessMarker> :
   if (marker == false) or (marker == sentinel) :
      return marker
   else :
      val p = (marker as ptr<long>) - 1
      if p[0] == -1 : return p[1] as ref<LivenessMarker>
      else : return false

lostanza defn scan-trackers (tracker:ref<False|LivenessTracker>) -> ref<False> :
   labels :
      begin :
         goto loop(tracker)
      loop (t:ref<False|LivenessTracker>) :
         match(t) :
            (t:ref<LivenessTracker>) :
               t.marker = post-gc-marker(t.marker)
               goto loop(t.next)
            (t:ref<False>) :
               return false

;                 Scanning Functions
;                 ==================

;Copy all global references to the free memory.
lostanza defn scan-globals () -> int :
   ;Get tables
   val globals = call-prim globals() as ptr<long>
   val map = call-prim global-map() as ptr<RefMap>
   ;Scan globals
   scan-map-words(addr(map.bits), map.length, globals)
   return 0

;Copy all stack references in this and parent stacks to free memory.
lostanza defn scan-stack (s:ref<Stack>) -> int :
   labels :
      begin :
         goto loop(s)
      loop (s:ref<Stack>) :
         if s.mark == 0 :
            s.mark = 1

            ;Scan all stack frames
            val sp = s.sp
            labels :
               begin :
                  goto scan(addr!(s.frames))
               scan (fs:ptr<StackFrame>) :
                  if fs < sp :
                     val map = fs.map
                     scan-map-words(addr(map.bits), map.length, addr(fs.items))
                     val next-fs = addr(fs.items[map.length])
                     goto scan(next-fs as ptr<StackFrame>)

            ;Scan stack parent if there is one
            match(s.parent) :
               (p:ref<Stack>) : goto loop(p)
               (p:ref<False>) : ()
   return 0

;Copy all internal references in heap to free memory.
lostanza defn scan-heap () -> int :
   labels :
      begin :
         goto loop(free-mem)
      loop (p:ptr<long>) :
         if p < free-ptr :
            val tagword = p[0]
            val tagbits = tagword & 7
            if tagbits == 0 :
               val tag = tagword >>> 3
               if tag == tagof(LivenessTracker) :
                  goto loop(scan-liveness-tracker(p))
               else :
                  goto loop(scan-object(p))
            else if tagbits == 1 :
               goto loop(scan-array(p))
            else :
               call-c clib/fprintf(stderr, "Invalid tag bits in heap: %llx\n", tagbits)
               call-c clib/exit(-1)
   return 0

;Copy all internal references in object to free memory.
lostanza defn scan-object (p:ptr<long>) -> ptr<long> :
   ;p is [tag-word, cells ...]
   val tag = p[0] >>> 3
   val map = object-map(tag)
   scan-map-words(base-bits(map), base-nbits(map), p + 8)
   ;Occupied space is tag-word + base + padding
   val occupied = (8 + map.base-size + 7) & -8
   return p + occupied

;Copy all internal references in array to free memory.
lostanza defn scan-array (p:ptr<long>) -> ptr<long> :
   ;p is [len-word, tag-word, cells ...]
   val len = p[0] >>> 3
   val tag = p[1] >>> 3

   ;Calculate the total size of object, rounding up to nearest 8 bytes
   val map = object-map(tag)
   val bytes = ((map.base-size + map.tail-size * len) + 7) & -8

   ;Scan base of array
   scan-map-words(base-bits(map), base-nbits(map), p + 16)

   ;Scan tail of array if it contains references.
   if tail-refs?(map) :
      var tail:ptr<long> = p + 16 + map.base-size
      val tbits = tail-bits(map)
      val tnbits = tail-nbits(map)
      for (var i:long = 0, i < len, i = i + 1) :
         scan-map-words(tbits, tnbits, tail)
         tail = tail + map.tail-size

   ;Return end of array
   return p + 16 + bytes

;Scan n references (marked with a 1 bit) from the given pointer
lostanza defn scan-map-words (map:ptr<long>, n:long, refs:ptr<long>) -> int :
   labels :
      begin :
         goto loop(map, n, refs)
      loop (map:ptr<long>, n:long, refs:ptr<long>) :
         if n > 64 :
            scan-map-word([map], 64, refs)
            goto loop(map + sizeof(long), n - 64, addr(refs[64]))
         else if n > 0 :
            scan-map-word([map], n, refs)
   return 0

lostanza defn scan-map-word (map:long, n:long, refs:ptr<long>) -> int :
   var ref-ptr:ptr<long> = refs
   for (var i:long = 0, i < n, i = i + 1) :
      val b = (map >> i) & 1
      if b : [ref-ptr] = post-gc-object([ref-ptr])
      ref-ptr = ref-ptr + sizeof(long)
   return 0

;                Copying Functions
;                =================

lostanza defn post-gc-object (obj:long) -> long :
   val tagbits = obj & 7
   if tagbits == 1 :
      val obj-ptr = (obj - tagbits) as ptr<long>
      val tag = obj-ptr[0] >>> 3

      ;If broken heart, then return forwarding pointer
      if tag == -1 :
         return obj-ptr[1]
      ;Otherwise, copy object
      else :
         val map = object-map(tag)
         if tag == tagof(Stack) :
            scan-stack(obj as ref<Stack>)
            return obj
         else if finite?(map) :
            val obj* = copy-object-to-free(obj-ptr, map.base-size) + tagbits
            set-broken-heart(obj-ptr, obj*)
            return obj*
         else :
            val obj* = copy-array-to-free(obj-ptr, map.base-size, map.tail-size) + tagbits
            set-broken-heart(obj-ptr, obj*)
            return obj*
   else :
      return obj

lostanza defn set-broken-heart (old:ptr<long>, new-obj:long) -> int :
   old[0] = -1
   old[1] = new-obj
   return 0

lostanza defn copy-object-to-free (obj:ptr<long>, size:long) -> long :
   val ret = free-ptr
   ;Round up to nearest word size and add header
   val occupied = 8 + (size + 7) & -8
   copy-bytes-to-free(obj, occupied)
   return ret as long

lostanza defn copy-array-to-free (obj:ptr<long>, size:long, tail:long) -> long :
   ;obj: [len, tag, items ...]
   ;Returned pointer points to the tag word
   val ret = free-ptr + 8
   val length = obj[-1] >>> 3

   ;Calculate the total size of object, rounding up to nearest 8 bytes
   val bytes = ((size + tail * length) + 7) & -8

   ;Copy the bytes to free including header
   copy-bytes-to-free(obj - 8, bytes + 16)

   return ret as long

lostanza defn copy-bytes-to-free (p:ptr<long>, n:long) -> int :
   val nwords = n >>> 3
   for (var i:long = 0, i < nwords, i = i + 1) :
      free-ptr[i] = p[i]
   free-ptr = free-ptr + n
   return 0

;               Utilities for ObjectMap
;               =======================

lostanza deftype ObjectMap :
   base-size: int
   tail-size: int
   bits: long ...

lostanza defn object-map (tag:long) -> ptr<ObjectMap> :
   val table = call-prim object-table() as ptr<ptr<ObjectMap>>
   return table[tag]

lostanza defn finite? (m:ptr<ObjectMap>) -> long :
   return m.tail-size == 0

lostanza defn base-bits (m:ptr<ObjectMap>) -> ptr<long> :
   return addr(m.bits)

lostanza defn base-nbits (m:ptr<ObjectMap>) -> long :
   return m.base-size >>> 3

lostanza defn tail-bits (m:ptr<ObjectMap>) -> ptr<long> :
   val bnbits = m.base-size >>> 3
   val bnwords = (bnbits + 63) >>> 6
   return addr(m.bits[bnwords])

lostanza defn tail-nbits (m:ptr<ObjectMap>) -> long :
   return m.tail-size >>> 3

lostanza defn tail-refs? (m:ptr<ObjectMap>) -> long :
   val tnbits = m.tail-size >>> 3
   val tnwords = (tnbits + 63) >>> 6
   val bits = tail-bits(m)
   for (var i:long = 0, i < tnwords, i = i + 1) :
      if bits[i] != 0 :
         return 1
   return 0

;                  Releasing Stacks
;                  ================

;Free an active stack, and add back to the free stack list.
lostanza defn free-stack (s:ref<Stack>) -> long :
   ;Ensure s is the last active stack
   val stk-pool = call-prim stack-pool()
   val last-stk = (call-prim free-stacks())[-1]
   if s != last-stk :
      ;Swap locations of last-stk with s
      [stk-pool + s.position] = last-stk
      [stk-pool + last-stk.position] = s
      ;Swap positions of last-stk with s
      val s-position = s.position
      s.position = last-stk.position
      last-stk.position = s-position
   ;Free last active stack
   call-prim set-num-free-stacks(call-prim num-free-stacks() + 1)
   call-prim set-free-stacks(call-prim free-stacks() - 8)
   return 0

;Free all unmarked stacks.
lostanza defn free-unmarked-stacks () -> int :
   var stk-ptr:ptr<ref<Stack>> = call-prim stack-pool()
   while stk-ptr < call-prim free-stacks() :
      val s = [stk-ptr]
      if s.mark == 0 :
         free-stack(s)
      else :
         stk-ptr = stk-ptr + 8
      s.mark = 0
   return 0

;============================================================
;=================== Winders ================================
;============================================================
defstruct Winder :
   in: False|(() -> ?)
   out: False|(? -> ?)
   
var WINDER-STACK:List<Winder> = List()
var NUM-WINDERS = 0

defn pop-winder () :
   val w = head(WINDER-STACK)
   WINDER-STACK = tail(WINDER-STACK)
   NUM-WINDERS = NUM-WINDERS - 1
   w

defn push-winder (w:Winder) :
   WINDER-STACK = cons(w, WINDER-STACK)
   NUM-WINDERS = NUM-WINDERS + 1

defn pop-winders (n:Int) :
   defn pop (n:Int) :
      if n > 0 : cons(pop-winder(), pop(n - 1))
      else : List()
   pop(NUM-WINDERS - n)   

defn push-winders (ws:List<Winder>) :
   if not empty?(ws) :
      push-winders(tail(ws))
      push-winder(head(ws))

defn total-winders (c:False|RawCoroutine) -> Int :
   match(c) :
      (c:False) : 0
      (c:RawCoroutine) : total-winders(parent(c)) + num-winders(c)

defn wind-in (ws:List<Winder>) :
   if not empty?(ws) :
      wind-in(tail(ws))
      call?(in(head(ws)))

defn wind-out (ws:List<Winder>, f:True|False) :
   if not empty?(ws) :
      call?(out(head(ws)), f)
      wind-out(tail(ws), f)

defn* call? (f: False|(() -> ?)) :
   match(f) :
      (f:() -> ?) : f()
      (f:False) : false

defn* call? (f: False|(? -> ?), x: ?) :
   match(f) :
      (f:? -> ?) : f(x)
      (f:False) : false
      
public defn dynamic-wind<?T> (in:False|(() -> ?),
                              body:() -> ?T,
                              out:False|(True|False -> ?)) -> T :
   call?(in)
   push-winder(Winder(in, out))
   inc-winders(current-coroutine, 1)
   val result = body()
   pop-winder()
   inc-winders(current-coroutine, -1)
   call?(out, true)
   result

;============================================================
;===================== Coroutines ===========================
;============================================================

;                     Interface
;                     =========

public defmulti active? (c:Coroutine) -> True|False
public defmulti open? (c:Coroutine) -> True|False
public defmulti resume<?I,?O> (c:Coroutine<?I,?O>, x:I) -> O
public defmulti suspend<?I,?O> (c:Coroutine<?I,?O>, x:O) -> I
public defmulti break<?O> (c:Coroutine<?,?O>, x:O) -> Void
public defmulti close (c:Coroutine) -> False

;                   Raw Coroutines
;                   ==============

lostanza deftype RawCoroutine <: Coroutine :
   id: long
   c-rsp: ptr<?>
   parent: ref<False|RawCoroutine>
   top: ref<Stack|False>
   bottom: ref<Stack|False>
   num-winders: int
   status: ref<Int>

;                  Wrapped Coroutines
;                  ==================

#if-defined(OPTIMIZE) :

   public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
      RawCoroutine(enter)

#else :

   deftype WrappedCoroutine<I,O> <: Coroutine<I,O>
   defmulti raw (c:WrappedCoroutine) -> RawCoroutine

   public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
      var rc
      val c = new WrappedCoroutine<I,O> :
         defmethod active? (this) : active?(rc)
         defmethod open? (this) : open?(rc)
         defmethod resume (this, x:I) : resume(rc, x)
         defmethod suspend (this, x:O) : suspend(rc, x)
         defmethod break (this, x:O) : break(rc, x)
         defmethod close (this) : close(rc)
         defmethod equal? (this, b:WrappedCoroutine) : rc == raw(b)
         defmethod raw (this) : rc
         defmethod print (o:OutputStream, this) : print(o, rc)
      rc = RawCoroutine $ fn (rc, x0) :
         enter(c, x0)
      c

;                    Implementation
;                    ==============

lostanza deftype CoResult :
   value: ref<?>
   windout: ref<False|(? -> ?)>
   final?: ref<True|False>

val COROUTINE-ACTIVE = 0
val COROUTINE-CLOSED = 1
val COROUTINE-SUSPENDED = 2
val COROUTINE-OPEN = 3

lostanza var COROUTINE-COUNTER:long = 0
lostanza defn next-coroutine-id () -> long :
   val id = COROUTINE-COUNTER
   COROUTINE-COUNTER = COROUTINE-COUNTER + 1
   return id

lostanza var current-coroutine:ref<RawCoroutine> =
   new RawCoroutine{
      next-coroutine-id()
      call-prim c-rsp()
      false
      false
      call-prim stack()
      0
      COROUTINE-ACTIVE}

lostanza defn RawCoroutine (enter: ref<((RawCoroutine, ?) -> ?)>) -> ref<RawCoroutine> :
   return new-stack<ref<RawCoroutine>>{setup-coroutine(enter)}

lostanza defmethod equal? (a:ref<RawCoroutine>, b:ref<RawCoroutine>) -> ref<True|False> :
   if a.id == b.id : return true
   else : return false

lostanza defmethod active? (c:ref<RawCoroutine>) -> ref<True|False> :
   if c.status == COROUTINE-ACTIVE : return true
   else : return false

lostanza defmethod open? (c:ref<RawCoroutine>) -> ref<True|False> :
   if c.status == COROUTINE-OPEN : return true
   else : return false

lostanza defn take-top (c:ref<RawCoroutine>) -> ref<Stack> :
   val s = c.top as ref<Stack>
   c.top = false
   return s

lostanza defn top (c:ref<RawCoroutine>) -> ref<Stack> :
   return c.top as ref<Stack>

lostanza defn bottom (c:ref<RawCoroutine>) -> ref<Stack> :
   return c.bottom as ref<Stack>

lostanza defn num-winders (c:ref<RawCoroutine>) -> ref<Int> :
   return new Int{c.num-winders}

lostanza defn inc-winders (c:ref<RawCoroutine>, n:ref<Int>) -> ref<False> :
   c.num-winders = c.num-winders + n.value
   return false

lostanza defn* setup-coroutine (enter: ref<((RawCoroutine,?) -> ?)>) -> ref<?> :
   val s = call-prim stack()
   val p = parent(s)
   s.parent = false
   val c = new RawCoroutine{next-coroutine-id(), call-prim c-rsp(), false, s, s, 0, COROUTINE-OPEN}
   val x0 = switch-stack<ref<?>>{p, c}
   return break(c, [enter](c, x0))

lostanza defn parent (c:ref<RawCoroutine>) -> ref<False|RawCoroutine> :
   return c.parent

lostanza defmethod resume (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
   ;Ensure coroutine is re-entrant
   if c.status == COROUTINE-CLOSED :
      return fatal("Cannot resume coroutine. Coroutine is already closed.")
   else if c.status == COROUTINE-ACTIVE :
      return fatal("Cannot resume coroutine. Coroutine is already active.")
   else if c.status == COROUTINE-SUSPENDED :
      return fatal("Cannot resume coroutine. Coroutine's parent is suspended.")

   ;Connect stacks, and attach coroutine
   current-coroutine.top = call-prim stack()
   current-coroutine.c-rsp = call-prim c-rsp()
   bottom(c).parent = current-coroutine.top
   attach(c)
   
   ;Switch stacks
   call-prim set-c-rsp(current-coroutine.c-rsp)
   return switch-stack<ref<?>>{take-top(current-coroutine), x}

lostanza defmethod* suspend (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
   ;Ensure coroutine is active
   if c.status == COROUTINE-CLOSED :
      return fatal("Cannot suspend coroutine. Coroutine is already closed.")
   else if c.status == COROUTINE-OPEN :
      return fatal("Cannot suspend coroutine. Coroutine is already suspended.")
   else if c.status == COROUTINE-SUSPENDED :
      return fatal("Cannot suspend coroutine. Coroutine is already suspended.")

   ;Set target winder environment and wind out
   val winders = pop-winders(total-winders(c.parent))
   wind-out(winders, false)

   ;Disconnect stacks, and Detach coroutine
   current-coroutine.top = call-prim stack()
   current-coroutine.c-rsp = call-prim c-rsp()
   bottom(c).parent = false
   detach(c)

   ;Return to resume
   call-prim set-c-rsp(current-coroutine.c-rsp)
   val result = switch-stack<ref<?>>{take-top(current-coroutine), x}

   ;Wind in and restore original winder environment
   wind-in(winders)
   push-winders(winders)

   ;Return execution
   return result

lostanza defmethod* break (c:ref<RawCoroutine>, x:ref<?>) -> ref<Void> :
   ;Ensure coroutine is active
   if c.status == COROUTINE-CLOSED :
      return fatal("Cannot break from coroutine. Coroutine is already closed.")
   else if c.status == COROUTINE-OPEN :
      return fatal("Cannot break from coroutine. Coroutine is already suspended.")
   else if c.status == COROUTINE-SUSPENDED :
      return fatal("Cannot break from coroutine. Coroutine is already suspended.")

   ;Set target winder environment and wind out
   val winders = pop-winders(total-winders(c.parent))
   wind-out(winders, true)

   ;Detach coroutine
   current-coroutine.top = call-prim stack()
   current-coroutine.c-rsp = call-prim c-rsp()
   detach(c)
   free(c)

   ;Switch stacks
   call-prim set-c-rsp(current-coroutine.c-rsp)
   return switch-stack<ref<Void>>{take-top(current-coroutine), x}

lostanza defmethod close (c:ref<RawCoroutine>) -> ref<False> :
   ;Ensure coroutine is re-entrant
   if c.status == COROUTINE-CLOSED :
      return fatal("Cannot close coroutine. Coroutine is already closed.")
   else if c.status == COROUTINE-ACTIVE :
      return fatal("Cannot close coroutine. Coroutine is active.")
   else if c.status == COROUTINE-SUSPENDED :
      return fatal("Cannot close coroutine. Coroutine's parent is suspended.")
   free(c)
   return false

lostanza defn attach (c:ref<RawCoroutine>) -> int :
   labels :
      begin :
         goto loop(c)
      loop (c:ref<RawCoroutine>) :
         val p = c.parent
         c.parent = current-coroutine
         c.status = COROUTINE-ACTIVE
         current-coroutine = c
         match(p) :
            (p:ref<RawCoroutine>) : goto loop(p)
            (p:ref<False>) : return 0

lostanza defn detach (c:ref<RawCoroutine>) -> int :
   labels :
      begin :
         goto loop(false)
      loop (tail:ref<RawCoroutine|False>) :
         val cc = current-coroutine
         val ccp = current-coroutine.parent as ref<RawCoroutine>
         cc.parent = tail
         current-coroutine = ccp
         if cc == c :
            cc.status = COROUTINE-OPEN
            return 0
         else :
            cc.status = COROUTINE-SUSPENDED
            goto loop(cc)

lostanza defn free (c:ref<RawCoroutine>) -> int :
   labels :
      begin :
         goto loop(c)
      loop (c:ref<RawCoroutine>) :
         val parent = c.parent
         c.status = COROUTINE-CLOSED
         free-stacks(top(c), bottom(c))
         c.top = false
         c.bottom = false
         c.parent = false
         match(parent) :
            (p:ref<RawCoroutine>) : goto loop(p)
            (p:ref<False>) : return 0

lostanza defn free-stacks (top:ref<Stack>, bottom:ref<Stack>) -> int :
   labels :
      begin :
         goto free(top)
      free (top:ref<Stack>) :
         if top == bottom :
            free-stack(top)
            return 0
         else :
            val p = parent(top)
            free-stack(top)
            goto free(p)

defmethod print (o:OutputStream, c:RawCoroutine) :
   val s = switch {status(c) == _} :
      COROUTINE-ACTIVE : "ACTIVE"
      COROUTINE-CLOSED : "CLOSED"
      COROUTINE-SUSPENDED : "SUSPENDED"
      COROUTINE-OPEN : "OPEN"
   print(o, "<Coroutine #%_ : %_>" % [id(c), s])

lostanza defn id (c:ref<RawCoroutine>) -> ref<Int> : return new Int{c.id as int}
lostanza defn status (c:ref<RawCoroutine>) -> ref<Int> : return c.status

;============================================================
;================= Liveness Trackers ========================
;============================================================
public lostanza defn LivenessTracker<?T> (value:ref<?T>) -> ref<LivenessTracker<T>> :
   return new LivenessTracker{sentinel, value, false}

lostanza var tracker-counter:long = 0
public lostanza defn marker (tracker:ref<LivenessTracker>) -> ref<False|LivenessMarker> :
   if tracker.marker == sentinel :
      tracker.marker = new LivenessMarker{tracker-counter}
      tracker-counter = tracker-counter + 1
   return tracker.marker as ref<False|LivenessMarker>

public defn marker! (tracker:LivenessTracker) :
   marker(tracker) as LivenessMarker

public lostanza defn value<?T> (tracker:ref<LivenessTracker<?T>>) -> ref<T> :
   return tracker.value

lostanza defn id (marker:ref<LivenessMarker>) -> ref<Long> :
   return new Long{marker.id}

defmethod print (o:OutputStream, m:LivenessMarker) :
   print(o, "<LivenessMarker %_>" % [id(m)])

defmethod print (o:OutputStream, t:LivenessTracker) :
   print(o, "<LivenessTracker %_ %~>" % [marker(t), value(t)])

;============================================================
;======================= Utilities ==========================
;============================================================

;                       Sentinels
;                       =========

lostanza deftype Sentinel
lostanza val sentinel:ref<Sentinel> = new Sentinel{}

defmethod print (o:OutputStream, s:Sentinel) :
   print(o, '_')

;                       Errors
;                       ======

protected defn ensure-index-in-bounds (xs:Lengthable, i:Int) :
   if i < 0 or i >= length(xs) :
      fatal("Index (%_) out of bounds." % [i])

defn ensure-start-before-end (s:Int, e:Int) :
   if e < s :
      fatal("Given end index (%_) is smaller than start index (%_)." % [e, s])

protected defn ensure-non-negative (quantity:String, n:Int) :
   if n < 0 :
      fatal("Given %_ (%_) is negative." % [quantity, n])

protected defn ensure-positive (quantity:String, n:Int) :
   if n <= 0 :
      fatal("Given %_ (%_) is not positive." % [quantity, n])

protected defn ensure-non-negative-length (n:Int) :
   ensure-non-negative("length", n)

protected defn ensure-index-range (xs:Lengthable, r:Range) :
   defn ensure-end-index-in-bounds (xs:Lengthable, i:Int) :
      if i < 0 or i > length(xs) :
         fatal("Index (%_) out of bounds." % [i])

   if step(r) != 1 :
      fatal("Given index range (%_) does not have a step of 1." % [r])
   val s = start(r)
   match(end(r), inclusive?(r)) :
      (e:Int, inc?:True) :
         ensure-index-in-bounds(xs, s)
         ensure-index-in-bounds(xs, e)
         ensure-start-before-end(s, e)
      (e:Int, inc?:False) :
         ensure-end-index-in-bounds(xs, s)
         ensure-end-index-in-bounds(xs, e)
         ensure-start-before-end(s, e)
      (e:False, inc?) :
         ensure-end-index-in-bounds(xs, s)

protected defn range-bound (s:Lengthable, r:Range) -> [Int, Int] :
   match(end(r), inclusive?(r)) :
      (e:Int, i:True) : [start(r), e + 1]
      (e:Int, i:False) : [start(r), e]
      (e:False, i) : [start(r), length(s)]

;============================================================
;================ Initialization Phase 1 ====================
;============================================================

;                  Constant Initialization
;                  =======================

lostanza var const-ptr:ptr<?>
lostanza val BYTE-CONST-TAG : int = 0
lostanza val CHAR-CONST-TAG : int = 1
lostanza val INT-CONST-TAG : int = 2
lostanza val LONG-CONST-TAG : int = 3
lostanza val FLOAT-CONST-TAG : int = 4
lostanza val DOUBLE-CONST-TAG : int = 5
lostanza val TRUE-CONST-TAG : int = 6
lostanza val FALSE-CONST-TAG : int = 7
lostanza val LIST-CONST-TAG : int = 8
lostanza val STRING-CONST-TAG : int = 9
lostanza val SYMBOL-CONST-TAG : int = 10
lostanza val TYPE-CONST-TAG : int = 11
lostanza val FN-CONST-TAG : int = 12

lostanza defn initialize-constants () -> ref<False> :
   ;Initialize read pointer to beginning of the constant table
   ;[num, constants ...]
   const-ptr = call-prim constant-table()
   val n-consts = read-const-int()

   ;Initialize pre symbol table
   initialize-pre-symbol-table()

   ;First n-consts entries in the global table are for constants
   var gs:ptr<ref<?>> = call-prim globals()
   for (var i:int = 0, i < n-consts, i = i + 1) :
      gs[i] = read-const()

   ;Initialize Symbol Table
   collections/initialize-collections()
   initialize-symbol-table()

   return false

lostanza defn read-const () -> ref<?> :
   val tag = read-const-int()
   if tag == BYTE-CONST-TAG :
      return new Byte{read-const-byte()}
   else if tag == CHAR-CONST-TAG :
      return new Char{read-const-byte()}
   else if tag == INT-CONST-TAG :
      return new Int{read-const-int()}
   else if tag == LONG-CONST-TAG :
      return new Long{read-const-long()}
   else if tag == FLOAT-CONST-TAG :
      return new Float{read-const-float()}
   else if tag == DOUBLE-CONST-TAG :
      return new Double{read-const-double()}
   else if tag == TRUE-CONST-TAG :
      return true
   else if tag == FALSE-CONST-TAG :
      return false
   else if tag == LIST-CONST-TAG :
      val len = read-const-int()
      return read-const-list(len)
   else if tag == STRING-CONST-TAG :
      val len = read-const-long()
      val chars = read-const-chars(len)
      return String(len, chars)
   else if tag == SYMBOL-CONST-TAG :
      val len = read-const-long()
      val chars = read-const-chars(len)
      return init-symbol(String(len, chars))
   else if tag == TYPE-CONST-TAG :
      val code = read-const-long() as ptr<?>
      return new Type{0, code}
   else if tag == FN-CONST-TAG :
      val code = read-const-long() as ptr<?>
      return new Fn{0, code}
   else :
      call-c clib/fprintf(stderr, "Unknown constant tag: %lld\n", tag)
      return fatal!("Unknown constant tag")

lostanza defn read-const-list (n:int) -> ref<List> :
   if n == 0 : return new NilList{}
   else : return new FullList{read-const(), read-const-list(n - 1)}

lostanza defn read-const-byte () -> byte :
   val value = [const-ptr as ptr<byte>]
   const-ptr = const-ptr + sizeof(byte)
   return value

lostanza defn read-const-int () -> int :
   val value = [const-ptr as ptr<int>]
   const-ptr = const-ptr + sizeof(int)
   return value

lostanza defn read-const-long () -> long :
   val value = [const-ptr as ptr<long>]
   const-ptr = const-ptr + sizeof(long)
   return value

lostanza defn read-const-float () -> float :
   val value = [const-ptr as ptr<float>]
   const-ptr = const-ptr + sizeof(float)
   return value

lostanza defn read-const-double () -> double :
   val value = [const-ptr as ptr<double>]
   const-ptr = const-ptr + sizeof(double)
   return value

lostanza defn read-const-chars (len:long) -> ptr<byte> :
   val value = const-ptr as ptr<byte>
   ;length chars + 0 character + pad to nearest 4 bytes
   val n = (len + 4) & -4
   const-ptr = (const-ptr + n) as ptr<?>
   return value

;                     Driver
;                     ======

initialize-constants()
initialize-gc-notifiers()

;============================================================
;============== Uncatchable Fatal Errors ====================
;============================================================

;Uncatchable fatal error with LoStanza message
lostanza defn fatal! (msg:ptr<byte>, sp:ptr<?>) -> ref<Void> :
   call-c clib/fprintf(stderr, "FATAL ERROR: %s\n", msg)
   print-stack-trace(sp)
   call-c clib/exit(-1)
   return null as ref<Void>   
lostanza defn fatal! (msg:ptr<byte>) -> ref<Void> :
   return fatal!(msg, call-prim sp())

;Uncatchable fatal error with HiStanza message
lostanza defn fatal! (msg:ref<?>, sp:ptr<?>) -> ref<Void> :
   call-c clib/fprintf(stderr, "FATAL ERROR: ")
   println(STANDARD-ERROR-STREAM, msg)
   print-stack-trace(sp)
   call-c clib/exit(-1)
   return null as ref<Void>   
lostanza defn fatal! (msg:ref<?>) -> ref<Void> :
   return fatal!(msg, call-prim sp())

;============================================================
;=================== Error Handler ==========================
;============================================================

#if-not-defined(OPTIMIZE) :
   ;Fatal error contains message and stack pointer of originator
   lostanza deftype FatalError :
      msg: ref<?>
      sp: ptr<?>

   ;Retrieve message inside fatal error
   lostanza defn msg (e:ref<FatalError>) -> ref<?> :
      return e.msg

   ;Default error handler just calls fatal!
   lostanza defn default-error-handler (e:ref<FatalError>) -> ref<Void> :
      return fatal!(e.msg, e.sp)

   ;Stores the currently installed error handler
   var CURRENT-ERROR-HANDLER : FatalError -> Void = default-error-handler

;Runs body with installed error handler
public defn with-error-handler<?T> (body: () -> ?T, handler: ? -> ?T) -> T :
   #if-defined(OPTIMIZE) :
      body()
   #else :
      val r = label break :
         let-var CURRENT-ERROR-HANDLER = break :
            body()
      match(r) :
         (r:FatalError) : handler(msg(r))
         (r) : r

;============================================================
;=================== Fatal Errors ===========================
;============================================================
#if-defined(OPTIMIZE) :
   ;Fatal error with LoStanza message
   lostanza defn* fatal (msg:ptr<byte>, sp:ptr<?>) -> ref<Void> :
      return fatal!(msg, sp)
   lostanza defn* fatal (msg:ptr<byte>) -> ref<Void> :
      return fatal!(msg)

   ;Fatal error with HiStanza message
   public lostanza defn* fatal (msg:ref<?>) -> ref<Void> :
      return fatal!(msg)
#else :
   ;Fatal error with LoStanza message
   lostanza defn* fatal (msg:ptr<byte>, sp:ptr<?>) -> ref<Void> :
      return [CURRENT-ERROR-HANDLER](new FatalError{String(msg), sp})
   lostanza defn* fatal (msg:ptr<byte>) -> ref<Void> :
      return [CURRENT-ERROR-HANDLER](new FatalError{String(msg), call-prim sp()})

   ;Fatal error with HiStanza message
   public lostanza defn* fatal (msg:ref<?>) -> ref<Void> :
      return [CURRENT-ERROR-HANDLER](new FatalError{msg, call-prim sp()})   

;============================================================
;====================== Lengthable ==========================
;============================================================

public defmulti length (l:Lengthable) -> Int

;============================================================
;======================= Equalable ==========================
;============================================================

public defmulti equal? (a:Equalable, b:Equalable) -> True|False
defmethod equal? (a:Equalable, b:Equalable) : false

public defn not-equal? (a:Equalable, b:Equalable) -> True|False :
   complement(equal?(a, b))

;============================================================
;================== Seqable/Sequences =======================
;============================================================

public defmulti to-seq<?T> (s:Seqable<?T>) -> Seq<T>
defmethod to-seq<?T> (s:Seq<?T>) : s

public defmulti next<?T> (s:Seq<?T>) -> T
public defmulti peek<?T> (s:Seq<?T>) -> T
public defmulti empty? (s:Seq) -> True|False
public defmulti free (s:Seq) -> False

defmethod free (s:Seq) : false

defn* do-seq<?T,?R> (f: Seq<T> -> ?R, s:Seqable<?T>) -> R :
   match(s) :
      (s:Seq<T>) :
         f(s)
      (s) :
         val s-seq = to-seq(s)
         dynamic-wind(
            false,
            fn* () : f(s-seq)
            fn* (final?) : free(s-seq) when final?)

;============================================================
;===================== Hashes ===============================
;============================================================

public defmulti hash (h:Hashable) -> Int

;============================================================
;=================== Comparable =============================
;============================================================

public defmulti compare<?T> (a:Comparable<?T>, b:T) -> Int

public defmulti less?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti greater?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti less-eq?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti greater-eq?<?T> (a:Comparable<?T>, b:T) -> True|False

defmethod less?<?T> (a:Comparable<?T>, b:T) : compare(a, b) < 0
defmethod greater?<?T> (a:Comparable<?T>, b:T) : compare(a, b) > 0
defmethod less-eq?<?T> (a:Comparable<?T>, b:T) : compare(a, b) <= 0
defmethod greater-eq?<?T> (a:Comparable<?T>, b:T) : compare(a, b) >= 0

;============================================================
;====================== ToString ============================
;============================================================

public defmulti to-string (x) -> String

;                Default Implementation
;                ======================

defmethod to-string (x) -> String :
   val s = StringBuffer()
   print(s, x)
   to-string(s)

defmethod to-string (x:String) : x
defmethod to-string (x:True) : "true"
defmethod to-string (x:False) : "false"

;============================================================
;===================== OutputStream =========================
;============================================================

;                   General Interface
;                   =================

public defmulti print (o:OutputStream, x) -> False
public defmulti print-all (o:OutputStream, xs:Seqable) -> False

;                Default Implementations
;                =======================

lostanza val CONVERSION-BUFFER: ptr<byte> = call-c clib/malloc(64)

lostanza defn print-conversion-buffer (o:ref<OutputStream>, n:int) -> ref<False> :
   for (var i:int = 0, i < n, i = i + 1) :
      print(o, new Char{CONVERSION-BUFFER[i]})
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Byte>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value as int)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Int>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Long>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%lld", x.value)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Float>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%f", x.value as double)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Double>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.15lf", x.value)
   print-conversion-buffer(o, n)
   return false

defmethod print (o:OutputStream, x:True) :
   print(o, "true")

defmethod print (o:OutputStream, x:False) :
   print(o, "false")

defmethod print (o:OutputStream, x:String) :
   print-all(o, x)

defmethod print (o:OutputStream, x) :
   print(o, "[Unprintable Object]")

defmethod print-all (o:OutputStream, xs:Seqable) :
   do(print{o, _}, xs)

;                 Convenience Functions
;                 =====================

public defn println (o:OutputStream, x) :
   print(o, x)
   print(o, "\n")

public defn println-all (o:OutputStream, xs:Seqable) :
   print-all(o, xs)
   print(o, "\n")

;============================================================
;=================== FileOutputStream =======================
;============================================================

;TODO: Files and Directories.
;FileOutputStream streams are obtained from files.

public lostanza defn FileOutputStream (filename:ref<String>, append?:ref<True|False>) -> ref<FileOutputStream> :
   var file : ptr<?>
   if append? == true : file = call-c clib/fopen(addr!(filename.chars), "ab")
   else : file = call-c clib/fopen(addr!(filename.chars), "wb")
   if file == null : throw(FileOpenException(filename, linux-error-msg()))
   return new FileOutputStream{file, 1}

public defn FileOutputStream (filename:String) :
   FileOutputStream(filename, false)

public lostanza defn close (o:ref<FileOutputStream>) -> ref<False> :
   if o.closable? :
      val err = call-c clib/fclose(o.file)
      if err != 0 : throw(FileCloseException(linux-error-msg()))
   else : fatal("System OutputStream is not closable.")
   return false

public lostanza defn put (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

public defn put (o:FileOutputStream, i:Int) -> False :
   put(o, to-byte(i))
   put(o, to-byte(i >> 8))
   put(o, to-byte(i >> 16))
   put(o, to-byte(i >> 24))

public defn put (o:FileOutputStream, i:Long) -> False :
   put(o, to-byte(i))
   put(o, to-byte(i >> 8L))
   put(o, to-byte(i >> 16L))
   put(o, to-byte(i >> 24L))
   put(o, to-byte(i >> 32L))
   put(o, to-byte(i >> 40L))
   put(o, to-byte(i >> 48L))
   put(o, to-byte(i >> 56L))

public defn put (o:FileOutputStream, i:Float) -> False :
   put(o, bits(i))

public defn put (o:FileOutputStream, i:Double) -> False :
   put(o, bits(i))

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<String>) -> ref<False> :
   val r = call-c clib/fputs(addr!(x.chars), o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value as int)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Char>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Int>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Long>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%lld", x.value)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Float>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%f", x.value as double)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Double>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%.15f", x.value)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<True>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "true")
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<False>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "false")
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

public defn with-output-file<?T> (file:FileOutputStream, f: () -> ?T) -> T :
   try : with-output-stream(file, f)
   finally : close(file)

public defn spit (filename:String, x) -> False :
   val o = FileOutputStream(filename, false)
   try : print(o, x)
   finally : close(o)

;============================================================
;================ System Output Streams =====================
;============================================================

;                 System Output Streams
;                 =====================

public lostanza val STANDARD-OUTPUT-STREAM : ref<OutputStream> =
   new FileOutputStream{stdout, 0}

public lostanza val STANDARD-ERROR-STREAM : ref<OutputStream> =
   new FileOutputStream{stderr, 0}

public lostanza val STANDARD-INPUT-STREAM : ref<InputStream> =
   new FileInputStream{stdin, 0}

;                 Current Output Stream
;                 =====================

var CURRENT-OUTPUT-STREAM : OutputStream = STANDARD-OUTPUT-STREAM

public defn with-output-stream<?T> (o:OutputStream, f: () -> ?T) -> T :
   let-var CURRENT-OUTPUT-STREAM = o :
      f()

public defn current-output-stream () :
   CURRENT-OUTPUT-STREAM

public defn print (x) :
   print(CURRENT-OUTPUT-STREAM, x)

public defn println (x) :
   print(x)
   print("\n")

public defn print-all (xs:Seqable) :
   do(print, xs)

public defn println-all (xs:Seqable) :
   print-all(xs)
   print("\n")

;============================================================
;=================== Input Streams ==========================
;============================================================

;                      Interface
;                      =========

public defmulti get-char (i:InputStream) -> Char|False
public defmulti get-byte (i:InputStream) -> Byte|False
public defmulti fill (xs:CharArray, r:Range, i:InputStream) -> Int

;                Abstract Implementations
;                ========================

defmethod fill (xs:CharArray, r:Range, s:InputStream) -> Int :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   defn* loop (i:Int) :
      if i < e :
         match(get-char(s)) :
            (c:Char) :
               xs[i] = c
               loop(i + 1)
            (c:False) : i - b
      else : i - b
   loop(b)

;============================================================
;=============== Buffered Input Streams =====================
;============================================================

;                      Interface
;                      =========

public defmulti peek? (i:BufferedInputStream, n:Int) -> Char|False
public defmulti peek-fill (xs:CharArray, r:Range, i:BufferedInputStream) -> Int

;                Abstract Implementations
;                ========================

public defn peek? (i:BufferedInputStream) -> Char|False :
   peek?(i, 0)

val DEFAULT-BUFFER-SIZE = 1024

public defn BufferedInputStream (i:InputStream) -> BufferedInputStream :
   BufferedInputStream(i, DEFAULT-BUFFER-SIZE)

public defn BufferedInputStream (i:InputStream, size:Int) -> BufferedInputStream :
   if size <= 0:
      fatal("BufferedInputStream buffer size must be greater than or equal to 0.")
   val buffer = CharArray(size)
   var count = 0
   var index = 0

   defn internal-fill-preserve () -> Int :
      val preserve = count - index
      buffer[0 to preserve] = buffer[index to count]
      count = preserve + fill(buffer, preserve to size, i)
      index = 0
      count

   defn internal-fill () -> Int :
      count = fill(buffer, 0 to size, i)
      index = 0
      count

   new BufferedInputStream:
      defmethod get-char (this) :
         if index >= count and internal-fill() == 0 :
            false
         else :
            index = index + 1
            buffer[index - 1]

      defmethod get-byte (this) :
         match(get-char(this)) :
            (c:Char) : to-byte(c)
            (c:False) : c

      defmethod fill (xs:CharArray, r:Range, this) -> Int :
         #if-not-defined(OPTIMIZE) :
            ensure-index-range(xs, r)
         val [b, e] = range-bound(xs, r)
         val needed = e - b
         defn fill-helper (xs:CharArray, start:Int) -> Int :
            val still-needed = e - start
            label<Int> return :
               if index >= count :
                  if still-needed > size :
                     return(fill(xs, r, i))
                  else if internal-fill() == 0 :
                     return(0)
               val available = count - index
               val to-fill = available when available < still-needed else still-needed
               xs[start to start + to-fill] = buffer[index to index + to-fill]
               index = index + to-fill
               return(to-fill)
         defn* loop (total:Int) -> Int :
            val n = fill-helper(xs, b + total)
            val new-total = total + n
            if n == 0 :
               new-total
            if new-total == needed :
               needed
            else :
               loop(new-total)
         loop(0)

      defmethod peek-fill (xs:CharArray, r:Range, this) -> Int :
         #if-not-defined(OPTIMIZE) :
            ensure-index-range(xs, r)
         val [b, e] = range-bound(xs, r)
         val needed = e - b
         if needed > size :
            fatal("Cannot peek-fill %_ chars from BufferedInputStream with buffer size %_." % [needed, size])
         if needed > count - index :
            internal-fill-preserve()
         if needed > count :
            xs[b to b + count] = buffer[0 to count]
            count
         else :
            xs[r] = buffer[0 to needed]
            needed

      defmethod peek? (this, n:Int) -> Char|False :
         if n < 0 :
            fatal("Cannot peek? into a BufferedInputStream at a negative index.")
         if n >= size :
            fatal("Cannot peek? %_ chars ahead into BufferedInputStream with buffer size %_." % [n, size])
         if index + n >= count :
            internal-fill-preserve()
         false when index + n >= count else buffer[index + n]

;============================================================
;================= File Input Streams =======================
;============================================================

public lostanza defn FileInputStream (filename:ref<String>) -> ref<FileInputStream> :
   val file = call-c clib/fopen(addr!(filename.chars), "rb")
   if file == null : throw(FileOpenException(filename, linux-error-msg()))
   return new FileInputStream{file, 1}

public lostanza defn close (i:ref<FileInputStream>) -> ref<False> :
   if i.closable? :
      val err = call-c clib/fclose(i.file)
      if err != 0 : throw(FileCloseException(linux-error-msg()))
   else : fatal("System Input Stream is not closable.")
   return false

lostanza defmethod get-char (i:ref<FileInputStream>) -> ref<Char|False> :
   val c = call-c clib/fgetc(i.file)
   if c == EOF :
      val err = call-c clib/ferror(i.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Char{c as byte}

lostanza defmethod get-byte (i:ref<FileInputStream>) -> ref<Byte|False> :
   val c = call-c clib/fgetc(i.file)
   if c == EOF :
      val err = call-c clib/ferror(i.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Byte{c as byte}

public defn get-int (i:FileInputStream) -> False|Int :
   defn get-byte! (i:FileInputStream) :
      match(get-byte(i)) :
         (b:Byte) : b
         (b:False) : fail()
   attempt :
      val b0 = to-int(get-byte!(i))
      val b1 = to-int(get-byte!(i))
      val b2 = to-int(get-byte!(i))
      val b3 = to-int(get-byte!(i))
      (b0) |
      (b1 << 8) |
      (b2 << 16) |
      (b3 << 24)

public defn get-long (i:FileInputStream) -> False|Long :
   defn get-int! (i:FileInputStream) :
      match(get-int(i)) :
         (x:Int) : x
         (x:False) : fail()
   attempt :
      val w0 = to-long(get-int!(i))
      val w1 = to-long(get-int!(i))
      (w0 & 0xFFFFFFFFL) |
      (w1 << 32L)

public defn get-float (i:FileInputStream) -> False|Float :
   match(get-int(i)) :
      (x:Int) : bits-as-float(x)
      (x:False) : false

public defn get-double (i:FileInputStream) -> False|Double :
   match(get-long(i)) :
      (x:Long) : bits-as-double(x)
      (x:False) : false

public defn slurp (filename:String) :
   val s = FileInputStream(filename)
   try :
      val buffer = StringBuffer()
      defn* loop () :
         match(get-char(s)) :
            (c:Char) :
               add(buffer, c)
               loop()
            (c:False) : false
      loop()
      to-string(buffer)
   finally : close(s)

public defn file-exists? (filename:String) :
   try :
      close(FileInputStream(filename))
      true
   catch (e:Exception) :
      false

;============================================================
;================== RandomAccessFiles =======================
;============================================================

public lostanza defn RandomAccessFile (filename:ref<String>, writable:ref<True|False>) -> ref<RandomAccessFile> :
   if writable == true :
      var file:ptr<?> = call-c clib/fopen(addr!(filename.chars), "r+b")
      if file == null :
         file = call-c clib/fopen(addr!(filename.chars), "w+b")
         if file == null : throw(FileOpenException(filename, linux-error-msg()))
         return new RandomAccessFile{file, writable}
      else :
         return new RandomAccessFile{file, writable}
   else :
      val file = call-c clib/fopen(addr!(filename.chars), "rb")
      if file == null : throw(FileOpenException(filename, linux-error-msg()))
      return new RandomAccessFile{file, writable}

public lostanza defn close (f:ref<RandomAccessFile>) -> ref<False> :
   val err = call-c clib/fclose(f.file)
   if err != 0 : throw(FileCloseException(linux-error-msg()))
   return false

public lostanza defn writable? (f:ref<RandomAccessFile>) -> ref<True|False> :
   return f.writable

public lostanza defn length (f:ref<RandomAccessFile>) -> ref<Long> :
   return new Long{call-c clib/get_file_size(f.file)}

public lostanza defn set-length (f:ref<RandomAccessFile>, len:ref<Long>) -> ref<False> :
   val err = call-c clib/file_set_length(f.file, len.value)
   if err != 0 : throw(FileSetLengthException(linux-error-msg()))
   return false

public lostanza defn seek (f:ref<RandomAccessFile>, pos:ref<Long>) -> ref<False> :
   val err = call-c clib/file_seek(f.file, pos.value)
   if err != 0 : throw(FileSeekException(linux-error-msg()))
   return false

public lostanza defn skip (f:ref<RandomAccessFile>, pos:ref<Long>) -> ref<False> :
   val err = call-c clib/file_skip(f.file, pos.value)
   if err != 0 : throw(FileSeekException(linux-error-msg()))
   return false

public lostanza defn get-byte (f:ref<RandomAccessFile>) -> ref<Byte|False> :
   val c = call-c clib/fgetc(f.file)
   if c == EOF :
      val err = call-c clib/ferror(f.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Byte{c as byte}   

public defn get-char (f:RandomAccessFile) -> Char|False :
   match(get-byte(f)) :
      (b:Byte) : to-char(b)
      (b:False) : b
      
public lostanza defn get-int (f:ref<RandomAccessFile>) -> ref<Int|False> :
   val b0 = call-c clib/fgetc(f.file)
   val b1 = call-c clib/fgetc(f.file)
   val b2 = call-c clib/fgetc(f.file)
   val b3 = call-c clib/fgetc(f.file)
   if b3 == EOF :
      val err = call-c clib/ferror(f.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Int{
         (b0) |
         (b1 << 8) |
         (b2 << 16) |
         (b3 << 24)}

public lostanza defn get-long (f:ref<RandomAccessFile>) -> ref<Long|False> :
   val b0 = call-c clib/fgetc(f.file)
   val b1 = call-c clib/fgetc(f.file)
   val b2 = call-c clib/fgetc(f.file)
   val b3 = call-c clib/fgetc(f.file)
   val b4 = call-c clib/fgetc(f.file)
   val b5 = call-c clib/fgetc(f.file)
   val b6 = call-c clib/fgetc(f.file)
   val b7 = call-c clib/fgetc(f.file)
   if b7 == EOF :
      val err = call-c clib/ferror(f.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Long{
         (b0) |
         (b1 << 8L) |
         (b2 << 16L) |
         (b3 << 24L) |
         (b4 << 32L) |
         (b5 << 40L) |
         (b6 << 48L) |
         (b7 << 56L)}

public defn get-float (f:RandomAccessFile) -> Float|False :
   match(get-int(f)) :
      (i:Int) : bits-as-float(i)
      (i:False) : false

public defn get-double (f:RandomAccessFile) -> Double|False :
   match(get-long(f)) :
      (i:Long) : bits-as-double(i)
      (i:False) : false

public lostanza defn fill (a:ref<ByteArray>, r:ref<Range>, f:ref<RandomAccessFile>) -> ref<Long> :
   ;Get range bounds
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(a, r)
   val rb = range-bound(a, r)
   val b = get(rb, new Int{0}).value
   val e = get(rb, new Int{1}).value
   val len = e - b
   ;Read block
   val ptr = addr!(a.data) + b
   val n = call-c clib/file_read_block(f.file, ptr, len)   
   ;Check errors
   if n < len :
      val err = call-c clib/ferror(f.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
   ;Return bytes read
   return new Long{n}

public defn fill (a:ByteArray, f:RandomAccessFile) -> Long :
   fill(a, 0 to false, f)

defn ensure-writable (f:RandomAccessFile) :
   if not writable?(f) :
      fatal("RandomAccessFile is not writable.")

public lostanza defn put (f:ref<RandomAccessFile>, xs:ref<ByteArray>, r:ref<Range>) -> ref<False> :
   #if-not-defined(OPTIMIZE) :
      ensure-writable(f)
   ;Get range bounds
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(xs, r)
   val rb = range-bound(xs, r)
   val b = get(rb, new Int{0}).value
   val e = get(rb, new Int{1}).value
   val len = e - b
   ;Write block
   val ptr = addr!(xs.data) + b
   val n = call-c clib/file_write_block(f.file, ptr, len)
   ;Check errors
   if n < len :
      val err = call-c clib/ferror(f.file)
      if err != 0 : throw(FileWriteException(linux-error-msg()))
   ;Done   
   return false

public defn put (f:RandomAccessFile, xs:ByteArray) -> False :
   put(f, xs, 0 to false)

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Byte>) -> ref<False> :
   #if-not-defined(OPTIMIZE) :
      ensure-writable(f)
   val r = call-c clib/fputc(x.value, f.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Char>) -> ref<False> :
   #if-not-defined(OPTIMIZE) :
      ensure-writable(f)
   val r = call-c clib/fputc(x.value, f.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Int>) -> ref<False> :
   #if-not-defined(OPTIMIZE) :
      ensure-writable(f)
   val fp = f.file   
   val xv = x.value
   call-c clib/fputc(xv as byte, f.file)
   call-c clib/fputc((xv >> 8) as byte, f.file)
   call-c clib/fputc((xv >> 16) as byte, f.file)
   val r = call-c clib/fputc((xv >> 24) as byte, f.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Long>) -> ref<False> :
   #if-not-defined(OPTIMIZE) :
      ensure-writable(f)
   val fp = f.file   
   val xv = x.value
   call-c clib/fputc(xv as byte, f.file)
   call-c clib/fputc((xv >> 8L) as byte, f.file)
   call-c clib/fputc((xv >> 16L) as byte, f.file)
   call-c clib/fputc((xv >> 24L) as byte, f.file)
   call-c clib/fputc((xv >> 32L) as byte, f.file)
   call-c clib/fputc((xv >> 40L) as byte, f.file)
   call-c clib/fputc((xv >> 48L) as byte, f.file)
   val r = call-c clib/fputc((xv >> 56L) as byte, f.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

public defn put (f:RandomAccessFile, x:Float) -> False :
   put(f, bits(x))

public defn put (f:RandomAccessFile, x:Double) -> False :
   put(f, bits(x))

;============================================================
;================= Linux Errors =============================
;============================================================

lostanza defn linux-error-msg () -> ref<String> :
   val s = call-c clib/strerror(call-c clib/get_errno())
   return String(s)

;============================================================
;==================== Remove File ===========================
;============================================================

public lostanza defn delete-file (path:ref<String>) -> ref<False> :
   val r = call-c clib/remove(addr!(path.chars))
   if r == -1 : throw(FileDeletionError(path, linux-error-msg()))
   return false

public deftype FileDeletionError <: Exception
public defn FileDeletionError (path:String, msg:String) :
   new FileDeletionError :
      defmethod print (o:OutputStream, this) :
         print{o, _} $
         "Error when attempting to delete %_. %_." % [path, msg]

;============================================================
;===================== FilePaths ============================
;============================================================

public lostanza defn resolve-path (path:ref<String>) -> ref<String|False> :
   val rpath = call-c clib/resolve_path(addr!(path.chars))
   if rpath == null :
      return false
   else :
      val s = String(rpath)
      call-c clib/free(rpath)
      return s

public defn norm-path (path) -> String :
   #if-defined(PLATFORM-WINDOWS) :
      replace(to-string(path), '/', '\\')
   #else :
      to-string(path)

;============================================================
;================ Environment Variables =====================
;============================================================

public lostanza defn get-env (name:ref<String>) -> ref<String|False> :
   val value = call-c clib/getenv(addr!(name.chars))
   if value == null : return false
   else : return String(value)

public lostanza defn set-env (name:ref<String>, value:ref<String>, overwrite:ref<True|False>) -> ref<False> :
   var ov:int = 0
   if overwrite == true : ov = 1
   val r = call-c clib/setenv(addr!(name.chars), addr!(value.chars), ov)
   if r != 0 : throw(SetEnvException(name, value, linux-error-msg()))
   return false

public defn set-env (name:String, value:String) :
   set-env(name, value, true)

public defstruct SetEnvException <: Exception :
   name: String
   value: String
   cause: String

defmethod print (o:OutputStream, e:SetEnvException) :
   print(o, "Could not set environment variable %_ to %~. %_." % [name(e), value(e), cause(e)])

;============================================================
;================== Exit System =============================
;============================================================

public lostanza defn exit (code:ref<Int>) -> ref<Void> :
   call-c clib/exit(code.value)
   return null as ref<Void>

;============================================================
;===================== System Calls =========================
;============================================================

public lostanza defn call-system (cmd:ref<String>) -> ref<Int> :
   val r = call-c clib/system(addr!(cmd.chars))
   if r == -1 : throw(SystemCallException(linux-error-msg()))
   return new Int{r}

public deftype SystemCallException <: Exception
defn SystemCallException (msg:String) :
   new SystemCallException :
      defmethod print (o:OutputStream, this) :
         print(o, msg)

;============================================================
;============== Input/Output Exceptions =====================
;============================================================

public deftype IOException <: Exception

public defstruct FileOpenException <: IOException :
   filename: String
   cause: String

defmethod print (o:OutputStream, e:FileOpenException) :
   print(o, "Error occurred when attempting to open file %_. %_." % [filename(e), cause(e)])

public defstruct FileCloseException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileCloseException) :
   print(o, "Error occurred when attempting to close file. %_." % [cause(e)])

public defstruct FileReadException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileReadException) :
   print(o, "Error occurred when attempting to read from file. %_." % [cause(e)])

public defstruct FileWriteException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileWriteException) :
   print(o, "Error occurred when attempting to write to file. %_." % [cause(e)])

public defstruct FileSeekException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileSeekException) :
   print(o, "Error occurred when attempting to seek in file. %_." % [cause(e)])

public defstruct FileSetLengthException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileSetLengthException) :
   print(o, "Error occurred when attempting to seek in file. %_." % [cause(e)])

;============================================================
;================ String Input Streams ======================
;============================================================

;                       Interface
;                       =========

public defmulti peek? (s:StringInputStream, i:Int) -> False|Char
public defmulti info (s:StringInputStream) -> FileInfo
public defmulti get-chars (s:StringInputStream, n:Int) -> String


;                Abstract Implementations
;                ========================

public defn peek? (s:StringInputStream) :
   peek?(s, 0)

public defn peek (s:StringInputStream, i:Int) :
   match(peek?(s, i)) :
      (c:Char) : c
      (c:False) : fatal("No more characters in stream.")

public defn peek (s:StringInputStream) :
   peek(s, 0)

;                   Implementation
;                   ==============

public defn StringInputStream (string:String, filename:String) :
   var start = 0
   var line = 1
   var column = 0
   val n = length(string)

   new StringInputStream :
      defmethod get-char (this) :
         if start < n :
            val c = string[start]
            start = start + 1
            if c == '\n' :
               line = line + 1
               column = 0
            else :
               column = column + 1
            c

      defmethod get-chars (this, n:Int) :
         #if-not-defined(OPTIMIZE) :
            if length(this) < n :
               fatal("Cannot eat %_ chars from StringInputStream with %_ chars remaining." % [n, length(this)])
         val ret = string[start to start + n]
         do(get-char{this}, 0 to n)
         ret

      defmethod get-byte (this) :
         match(get-char(this)) :
            (c:Char) : to-byte(c)
            (c:False) : false

      defmethod info (this) :
         FileInfo(filename, line, column)

      defmethod peek? (this, i:Int) :
         string[start + i] when start + i < n

      defmethod length (this) :
         n - start

public defn StringInputStream (string:String) :
   StringInputStream(string, "UnnamedStream")

;============================================================
;===================== Formatting ===========================
;============================================================

deftype Printable

public defn modulo (format:String, args:Seqable) -> Printable :
   new Printable :
      defmethod* print (o:OutputStream, this) :
         val seq = to-seq(args)
         val n = length(format)
         defn* loop (i:Int) :
            if i < n :
               val c = format[i]
               if c == '%' :
                  if i + 1 < n :
                     val modifier = format[i + 1]
                     switch {modifier == _} :
                        '_' : print(o, next(seq))
                        '*' : print-all(o, next(seq))
                        ',' : print-all(o, join(next(seq), ", "))
                        '~' : write(o, next(seq))
                        '@' : write-all(o, next(seq))
                        '%' : print(o, c)
                        else : fatal("Invalid argument specifier %~ in format string %~." % [modifier, format])
                     loop(i + 2)
                  else :
                     fatal("Incomplete argument specifier %% at end of format string %~." % [format])
               else :
                  print(o, c)
                  loop(i + 1)
            else :
               if not empty?(seq) :
                  fatal("Unexpected end of format string %~. More arguments remaining." % [format])
         loop(0)


;============================================================
;=================== Indented Streams =======================
;============================================================

public deftype IndentedStream <: OutputStream
defmulti stream (s:IndentedStream) -> OutputStream
defmulti indent (s:IndentedStream) -> Int

public defn IndentedStream (o:OutputStream, n:Int) :
   match(o) :
      (o:IndentedStream) :
         IndentedStream(stream(o), n + indent(o))
      (o) :
         var start-of-line? = true
         val spaces = String(n, ' ')
         defn put (c:Char) :
            if start-of-line? :
               print(o, spaces)
               start-of-line? = false
            print(o, c)
            if c == '\n' :
               start-of-line? = true

         new IndentedStream :
            defmethod stream (this) : o
            defmethod indent (this) : n
            defmethod print (this, c:Char) : put(c)

public defn do-indented<?T> (f: IndentedStream -> ?T, o:OutputStream) :
   f(IndentedStream(o, 3))

public defn indented<?T> (f: () -> ?T) :
   let-var CURRENT-OUTPUT-STREAM = IndentedStream(CURRENT-OUTPUT-STREAM, 3) :
      f()

;============================================================
;===================== Generators ===========================
;============================================================

public defn Generator<T> (thunk : (T -> False, (T -> Void) & (() -> Void)) -> ?) -> Seq<T> :
   ;State
   var item = sentinel

   ;Generator Coroutine
   val co = Coroutine<False, T|Sentinel> $ fn (co, x0) :
      defn co-yield (x:T) :
         suspend(co, x)
      val co-break = multifn :
         (x:T) : break(co, x)
         () : break(co, sentinel)
      thunk(co-yield, co-break)
      sentinel

   ;Fill state: Returns whether empty
   defn fill () :
      if (item is Sentinel) and open?(co) :
         item = resume(co, false)
      item is Sentinel

   ;Peek
   defn peek () :
      if item is Sentinel :
         fatal("Empty Sequence")
      item as T

   ;Empty bucket
   defn empty () :
      val x = peek()
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         peek()
      defmethod empty? (this) :
         fill()
      defmethod free (this) :
         close(co) when open?(co)

;============================================================
;====================== Labels ==============================
;============================================================

public defn* LabeledScope<T> (thunk: (T -> Void) -> T) -> T :
   val c = Coroutine<False,T> $ fn* (c, x0) :
      thunk(break{c, _})
   resume(c, false)

;============================================================
;====================== Maybe ===============================
;============================================================

;                      Interface
;                      =========

public defmulti value<?T> (x:One<?T>) -> T

;                     Constructors
;                     ============

public defn None () :
   new None

public defn One<?T> (x:?T) :
   new One<T> :
      defmethod value (this) : x

;                     Printers
;                     ========

defmethod print (o:OutputStream, x:None) :
   print(o, "None")
defmethod print (o:OutputStream, x:One) :
   print(o, "One(%~)" % [value(x)])

;                   Implementation
;                   ==============

public defn value!<?T> (x:Maybe<?T>) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : fatal("Object of type None has no value.")

public defn value?<?T> (x:Maybe<?T>, default:?T) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : default

public defn value?<?T> (x:Maybe<?T>) -> T|False :
   value?(x, false)

public defn empty? (x:Maybe) :
   x is None

defmethod equal? (a:None, b:None) :
   true

defmethod equal? (a:One, b:One) :
   value(a) == value(b)

;                   Comparisons
;                   ===========

defmethod* compare<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : 0
      (x:None, y:One<T>) : -1
      (x:One<T>, y:None) : 1
      (x:One<T&Comparable<T>>, y:One<T>) : compare(value(x), value(y))

defmethod less?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) < value(y)

defmethod less-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) <= value(y)

defmethod greater?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) > value(y)

defmethod greater-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) >= value(y)

;============================================================
;====================== Ranges ==============================
;============================================================

;                      Interface
;                      =========

public defmulti start (r:Range) -> Int
public defmulti end (r:Range) -> Int|False
public defmulti step (r:Range) -> Int
public defmulti inclusive? (r:Range) -> True|False

;                     Constructor
;                     ===========

public defn Range (start:Int, end:Int|False, step:Int, inclusive?:True|False) :
   ;Compute the length of the range
   val length = match(end, inclusive?) :
      (end:Int, inc:False) :
         if step == 0 :
            if step == end : 0
            else : false
         else if step == 1 :
            end - start
         else if step == -1 :
            start - end
         else if step > 0 :
            (end - start + step - 1) / step
         else :
            (end - start + step + 1) / step
      (end:Int, inc:True) :
         if step == 0 :
            false
         else if step == 1 :
            end - start + 1
         else if step == -1 :
            start - end + 1
         else :
            (end - start + step) / step
      (end:False, inc) :
         false

   match(length) :
      (length:Int) :
         new Range & Lengthable :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?
            defmethod length (this) : max(length, 0)
      (length:False) :
         new Range :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?

;                Conversion to Sequence
;                ======================

defmethod to-seq (r:Range) :
   match(r) :
      (r:Range & Lengthable) :
         var i = start(r)
         var n = length(r)
         new Seq<Int> & Lengthable :
            defmethod next (this) :
               val i* = peek(this)
               i = i + step(r)
               n = n - 1
               i*
            defmethod peek (this) :
               fatal("Empty Sequence") when empty?(this)
               i
            defmethod empty? (this) :
               n == 0
            defmethod length (this) :
               n
      (r:Range) :
         var i = start(r)
         new Seq<Int> :
            defmethod next (this) :
               val i* = i
               i = i + step(r)
               i*
            defmethod peek (this) :
               i
            defmethod empty? (this) :
               false

;             Looping
;             =======

defmethod do (f: Int -> ?, r:Range&Lengthable) :
   val s = step(r)
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(i)
         loop(i + s, n - 1)
   loop(start(r), length(r))

defmethod do (f: Int -> ?, r:Range) :
   val s = step(r)
   defn* loop (i:Int) :
      f(i)
      loop(i + s)
   loop(start(r))

;                 Comparison
;                 ==========

defmethod equal? (a:Range, b:Range) :
   start(a) == start(b) and
   end(a) == end(b) and
   step(a) == step(b) and
   inclusive?(a) == inclusive?(b)

;                  Printing
;                  ========

defmethod print (o:OutputStream, x:Range) :
   val op = "through" when inclusive?(x) else "to"
   if step(x) == 1 : print(o, "%_ %_ %_" % [start(x), op, end(x)])
   else : print(o, "%_ %_ %_ by %_" % [start(x), op, end(x), step(x)])

;                  Mapping
;                  =======

public defn map<?R> (f: Int -> ?R, r:Range) -> List<R> :
   fatal("Infinite Range") when r is-not Range&Lengthable
   to-list(seq(f, r))

;============================================================
;===================== Tuples ===============================
;============================================================

public lostanza defn Tuple<?T> (n:ref<Int>, x:ref<?T>) -> ref<Tuple<T>> :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative-length(n)
   val len = n.value
   val t = new Tuple<T>{len}
   for (var i:long = 0, i < len, i = i + 1) :
      t.items[i] = x
   return t

lostanza defn set<?T> (x:ref<Tuple<?T>>, i:ref<Int>, v:ref<T>) -> ref<False> :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(x, i)
   x.items[i.value] = v
   return false

lostanza defmethod length (x:ref<Tuple>) -> ref<Int> :
   return new Int{x.length as int}

public lostanza defn get<?T> (x:ref<Tuple<?T>>, i:ref<Int>) -> ref<T> :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(x, i)
   return x.items[i.value]

public defn get<?T> (xs:Tuple<?T>, r:Range) -> Tuple<T> :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])

defmethod to-seq<?T> (x:Tuple<?T>) :
   seq({x[_]}, 0 to length(x))

lostanza defmethod equal? (x:ref<Tuple>, y:ref<Tuple>) -> ref<True|False> :
   val n = x.length
   if n != y.length : return false
   for (var i:long = 0, i < n, i = i + 1) :
      if equal?(x.items[i], y.items[i]) == false :
         return false
   return true

defmethod hash (xs:Tuple) :
   var i = length(xs)
   for x in xs do :
      i = (7 * i) + hash(x)
   i

defmethod compare (a:Tuple<Comparable>, b:Tuple<Comparable>) -> Int :
   defn* loop (i:Int, j:Int) :
      if i < length(a) and j < length(b) :
         val c = compare(a[i], b[i])
         if c == 0 : loop(i + 1, j + 1)
         else : c
      else if i < length(a) : 1
      else if j < length(b) : -1
      else : 0
   loop(0, 0)

defmethod print (o:OutputStream, t:Tuple) -> False :
   print(o, "[%@]" % [t])

public defn to-tuple<?T> (xs:Seqable<?T>) -> Tuple<T> :
   match(xs) :
      (xs:Tuple<T>) :
         xs
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val t = Tuple(n, false as ?)
         for (x in xs, i in 0 to n) do :
            t[i] = x
         t
      (xs) :
         to-tuple(to-vector<T>(xs))

public defn map<?T,?R> (f:T -> ?R, xs:Tuple<?T>) -> Tuple<R> :
   to-tuple(seq(f, xs))

public defn empty? (t:Tuple) :
   length(t) == 0

;============================================================
;======================= Bytes ==============================
;============================================================

public lostanza defn shift-left (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value << b.value}

public lostanza defn shift-right (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value >> b.value}

public lostanza defn bit-or (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value | b.value}

public lostanza defn bit-xor (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value & b.value}

public lostanza defn bit-not (a:ref<Byte>) -> ref<Byte> :
   return new Byte{(~ a.value)}

public lostanza defn plus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value + b.value}

public lostanza defn minus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value - b.value}

public lostanza defn times (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value * b.value}

public lostanza defn divide (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value / b.value}

public lostanza defn modulo (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value % b.value}

lostanza defmethod compare (a:ref<Byte>, b:ref<Byte>) -> ref<Int> :
   return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false

defmethod equal? (a:Byte, b:Byte) -> True|False :
   ($prim identical? a b)

lostanza defmethod hash (a:ref<Byte>) -> ref<Int> :
   return new Int{a.value}

;============================================================
;======================= Chars ==============================
;============================================================

lostanza defmethod compare (a:ref<Char>, b:ref<Char>) -> ref<Int> :
   return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false

defmethod equal? (a:Char, b:Char) -> True|False :
   ($prim identical? a b)

lostanza defmethod hash (a:ref<Char>) -> ref<Int> :
   return new Int{a.value}

public lostanza defn digit? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= '0' and b <= '9' : return true
   else : return false

public lostanza defn letter? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'a' and b <= 'z' : return true
   else if b >= 'A' and b <= 'Z' : return true
   else : return false

public lostanza defn upper-case? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'A' and b <= 'Z' : return true
   else : return false

public lostanza defn lower-case? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'a' and b <= 'z' : return true
   else : return false

public lostanza defn lower-case (c:ref<Char>) -> ref<Char> :
   val cv = c.value
   if cv >= 'A' and cv <= 'Z' : return new Char{cv - 'A' + 'a'}
   else : return c

public lostanza defn upper-case (c:ref<Char>) -> ref<Char> :
   val cv = c.value
   if cv >= 'a' and cv <= 'z' : return new Char{cv - 'a' + 'A'}
   else : return c

;============================================================
;======================= Ints ===============================
;============================================================

public defn shift-left (a:Int, b:Int) -> Int :
   ($prim shl a b)

public defn shift-right (a:Int, b:Int) -> Int :
   ($prim shr a b)

public defn arithmetic-shift-right (a:Int, b:Int) -> Int :
   ($prim ashr a b)

public defn bit-or (a:Int, b:Int) -> Int :
   ($prim or a b)

public defn bit-and (a:Int, b:Int) -> Int :
   ($prim and a b)

public defn bit-xor (a:Int, b:Int) -> Int :
   ($prim xor a b)

public defn bit-not (a:Int) -> Int :
   ($prim not a)

public defn negate (a:Int) -> Int :
   ($prim neg a)

public defn abs (a:Int) -> Int :
   (- a) when a < 0 else a

public defn plus (a:Int, b:Int) -> Int :
   ($prim add a b)

public defn minus (a:Int, b:Int) -> Int :
   ($prim sub a b)

public defn times (a:Int, b:Int) -> Int :
   ($prim mul a b)

public defn divide (a:Int, b:Int) -> Int :
   ($prim div a b)

public defn modulo (a:Int, b:Int) -> Int :
   ($prim mod a b)

defmethod compare (a:Int, b:Int) -> Int :
   if a < b : -1
   else if a > b : 1
   else : 0

defmethod less? (a:Int, b:Int) -> True|False :
   ($prim lt a b)

defmethod less-eq? (a:Int, b:Int) -> True|False :
   ($prim le a b)

defmethod greater? (a:Int, b:Int) -> True|False :
   ($prim gt a b)

defmethod greater-eq? (a:Int, b:Int) -> True|False :
   ($prim ge a b)

defmethod equal? (a:Int, b:Int) -> True|False :
   ($prim eq a b)

defmethod hash (a:Int) -> Int :
   a

;============================================================
;======================= Longs ==============================
;============================================================

public lostanza defn shift-left (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value << b.value}

public lostanza defn shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value >> b.value}

public lostanza defn arithmetic-shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value >>> b.value}

public lostanza defn bit-or (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value | b.value}

public lostanza defn bit-xor (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value & b.value}

public lostanza defn bit-not (a:ref<Long>) -> ref<Long> :
   return new Long{(~ a.value)}

public lostanza defn negate (a:ref<Long>) -> ref<Long> :
   return new Long{(- a.value)}

public defn abs (a:Long) -> Long :
   (- a) when a < 0L else a

public lostanza defn plus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value + b.value}

public lostanza defn minus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value - b.value}

public lostanza defn times (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value * b.value}

public lostanza defn divide (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value / b.value}

public lostanza defn modulo (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value % b.value}

lostanza defmethod compare (a:ref<Long>, b:ref<Long>) -> ref<Int> :
   if a.value < b.value : return new Int{-1}
   else if a.value > b.value : return new Int{1}
   else : return new Int{0}

lostanza defmethod less? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false

lostanza defmethod equal? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value == b.value : return true
   else : return false

lostanza defmethod hash (a:ref<Long>) -> ref<Int> :
   val v = a.value
   return new Int{(v ^ (v >> 32)) as int}

;============================================================
;======================= Floats =============================
;============================================================

public lostanza defn negate (a:ref<Float>) -> ref<Float> :
   return new Float{(- a.value)}

public defn abs (a:Float) -> Float :
   (- a) when a < 0.0f else a

public lostanza defn plus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
   return new Float{a.value + b.value}

public lostanza defn minus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
   return new Float{a.value - b.value}

public lostanza defn times (a:ref<Float>, b:ref<Float>) -> ref<Float> :
   return new Float{a.value * b.value}

public lostanza defn divide (a:ref<Float>, b:ref<Float>) -> ref<Float> :
   return new Float{a.value / b.value}

lostanza defmethod compare (a:ref<Float>, b:ref<Float>) -> ref<Int> :
   if a.value < b.value : return new Int{-1}
   else if a.value > b.value : return new Int{1}
   else : return new Int{0}

lostanza defmethod less? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false

lostanza defmethod equal? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value == b.value : return true
   else : return false

defmethod hash (a:Float) -> Int :
   bits(a)

;============================================================
;======================= Doubles ============================
;============================================================

public lostanza defn negate (a:ref<Double>) -> ref<Double> :
   return new Double{(- a.value)}

public defn abs (a:Double) -> Double :
   (- a) when a < 0.0 else a

public lostanza defn plus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
   return new Double{a.value + b.value}

public lostanza defn minus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
   return new Double{a.value - b.value}

public lostanza defn times (a:ref<Double>, b:ref<Double>) -> ref<Double> :
   return new Double{a.value * b.value}

public lostanza defn divide (a:ref<Double>, b:ref<Double>) -> ref<Double> :
   return new Double{a.value / b.value}

lostanza defmethod compare (a:ref<Double>, b:ref<Double>) -> ref<Int> :
   if a.value < b.value : return new Int{-1}
   else if a.value > b.value : return new Int{1}
   else : return new Int{0}

lostanza defmethod less? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false

lostanza defmethod equal? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value == b.value : return true
   else : return false

lostanza defmethod hash (a:ref<Double>) -> ref<Int> :
   val v = a.value
   val bits = ($ls-prim bits v)
   return new Int{(bits ^ (bits >> 32)) as int}

;============================================================
;=================== Limits =================================
;============================================================

public val BYTE-MAX = 255Y
public val BYTE-MIN = 0Y
public lostanza val INT-MAX:ref<Int> = new Int{(1 << 31) - 1}
public lostanza val INT-MIN:ref<Int> = new Int{1 << 31}
public lostanza val LONG-MAX:ref<Long> = new Long{(1L << 63L) - 1L}
public lostanza val LONG-MIN:ref<Long> = new Long{1L << 63L}

;============================================================
;=============== Commandline Arguments ======================
;============================================================

public lostanza defn command-line-arguments () -> ref<Array<String>> :
   val r = Array<String>(new Int{clib/input_argc})
   for (var i:int = 0, i < clib/input_argc, i = i + 1) :
      val str = clib/input_argv[i]
      set(r, new Int{i}, String(str))
   return r

;============================================================
;====================== Strings =============================
;============================================================

public lostanza defn String (chars:ptr<byte>) -> ref<String> :
   val len = call-c clib/strlen(chars)
   return String(len, chars)

public lostanza defn String (len:long, chars:ptr<byte>) -> ref<String> :
   val s = String(len)
   for (var i:long = 0, i < len, i = i + 1) :
      s.chars[i] = chars[i]
   s.chars[len] = 0 as byte
   return s

public lostanza defn String (len:long, c:byte) -> ref<String> :
   val s = String(len)
   for (var i:long = 0, i < len, i = i + 1) :
      s.chars[i] = c
   s.chars[len] = 0 as byte
   return s

public lostanza defn String (len:long) -> ref<String> :
   return new String{len + 1, 0}

public lostanza defn String (len:ref<Int>, c:ref<Char>) -> ref<String> :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative-length(len)
   return String(len.value, c.value)

lostanza defn strlen (s:ref<String>) -> long :
   return s.length - 1

lostanza defn set (s:ref<String>, i:ref<Int>, c:ref<Char>) -> ref<False> :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(s, i)
   s.chars[i.value] = c.value
   return false

lostanza defn copy (dst:ref<String>, src:ref<String>, dst-i:long) -> ref<False> :
   val src-len = strlen(src)
   for (var i:long = 0, i < src-len, i = i + 1) :
      dst.chars[i + dst-i] = src.chars[i]
   return false

public defn String (cs:Seqable<Char>) -> String :
   match(cs) :
      (cs:Seqable<Char> & Lengthable) :
         val n = length(cs)
         val s = String(n, ' ')
         for (c in cs, i in 0 to false) do :
            s[i] = c
         s
      (c) :
         String(to-vector<Char>(cs))

public lostanza defmethod hash (s:ref<String>) -> ref<Int> :
   if s.hash == 0 :
      val n = strlen(s)
      var h:int = 0
      for (var i:long = 0, i < n, i = i + 1) :
         h = (31 * h) + s.chars[i]
      if h == 0 : s.hash = 1
      else : s.hash = h
   return new Int{s.hash}

defmethod length (s:String) -> Int :
   ;TODO: This is dirty. Do it in the code generator instead.
   ($prim string-len s) - 1

public defn get (s:String, i:Int) -> Char :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(s, i)
   ($prim string-get s i)

defmethod to-seq (s:String) :
   seq({s[_]}, 0 to length(s))

lostanza defmethod equal? (a:ref<String>, b:ref<String>) -> ref<True|False> :
   val n = strlen(a)
   if n == strlen(b) :
      for (var i:long = 0, i < n, i = i + 1) :
         if a.chars[i] != b.chars[i] :
            return false
      return true
   else :
      return false

lostanza defmethod compare (a:ref<String>, b:ref<String>) -> ref<Int> :
   val na = strlen(a)
   val nb = strlen(b)
   labels :
      begin :
         goto loop(0)
      loop (i:long) :
         if (i == na) and (i == nb) :
            return new Int{0}
         else if i == na :
            return new Int{-1}
         else if i == nb :
            return new Int{1}
         else :
            val ac = a.chars[i]
            val bc = b.chars[i]
            if ac < bc : return new Int{-1}
            else if ac > bc : return new Int{1}
            else : goto loop(i + 1)

defmethod do (f: Char -> ?, xs:String) :
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(xs[i])
         loop(i + 1, n - 1)
   loop(0, length(xs))

;============================================================
;======================= Lists ==============================
;============================================================

;                      Interface
;                      =========

public defmulti head<?T> (x:List<?T>) -> T
public defmulti tail<?T> (x:List<?T>) -> List<T>
public defmulti empty? (x:List) -> True|False

;                Concrete Implementations
;                ========================

lostanza deftype FullList<T> <: List<T> :
   head: ref<T>
   tail: ref<List<T>>
lostanza deftype NilList <: List<Void>

;                    Constructors
;                    ============

public lostanza defn List () -> ref<List> :
   return new NilList{}

public lostanza defn cons<?T> (x:ref<?T>, t:ref<List<?T>>) -> ref<List<T>> :
   return new FullList<T>{x, t}

public defn cons<?T> (x:?T, y:?T, t:List<?T>) -> List<T> :
   cons(x, cons(y, t))

public defn cons<?T> (x:?T, y:?T, z:?T, t:List<?T>) -> List<T> :
   cons(x, cons(y, cons(z, t)))

public defn List<?T> (x:?T) -> List<T> :
   cons(x, List())

public defn List<?T> (x:?T, y:?T) -> List<T> :
   cons(x, cons(y, List()))

public defn List<?T> (x:?T, y:?T, z:?T) -> List<T> :
   cons(x, cons(y, cons(z, List())))

public defn List<?T> (w:?T, x:?T, y:?T, z:?T) -> List<T> :
   cons(w, cons(x, cons(y, cons(z, List()))))

;                     Implementation
;                     ==============

lostanza defmethod head<?T> (x:ref<FullList<?T>>) -> ref<T> : return x.head
lostanza defmethod tail<?T> (x:ref<FullList<?T>>) -> ref<List<T>> : return x.tail
lostanza defmethod empty? (x:ref<FullList>) -> ref<False> : return false

defmethod head (x:NilList) : fatal("Cannot retrieve head of empty list.")
defmethod tail (x:NilList) : fatal("Cannot retrieve tail of empty list.")
lostanza defmethod empty? (x:ref<NilList>) -> ref<True> : return true

defmethod length (x:List) :
   defn* loop (x:List, n:Int) :
      if empty?(x) : n
      else : loop(tail(x), n + 1)
   loop(x, 0)

defmethod to-seq<?T> (x:List<?T>) :
   var l = x
   new Seq<T> :
      defmethod empty? (this) :
         empty?(l)
      defmethod next (this) :
         val x = peek(this)
         l = tail(l)
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         head(l)

defmethod equal? (a:List, b:List) -> True|False :
   defn* loop (a:List, b:List) :
      match(empty?(a), empty?(b)) :
         (ea:True, eb:True) : true
         (ea:False, eb:False) :
            if head(a) == head(b) :
               loop(tail(a), tail(b))
         (ea, eb) : false
   loop(a, b)

defmethod hash (xs:List<Hashable>) -> Int :
   var i = 0
   for x in xs do :
      i = (7 * i) + hash(x)
   i

defmethod compare (xs:List<Comparable>, ys:List<Comparable>) -> Int :
   defn* loop (xs:List<Comparable>, ys:List<Comparable>) :
      match(empty?(xs), empty?(ys)) :
         (ex:True, ey:True) : 0
         (ex:True, ey:False) : -1
         (ex:False, ey:True) : 1
         (ex:False, ey:False) :
            val c = compare(head(xs), head(ys))
            if c == 0 : loop(tail(xs), tail(ys))
            else : c
   loop(xs, ys)

defmethod print (o:OutputStream, xs:List) -> False :
   print(o, "(%@)" % [xs])

public defn to-list<?T> (xs:Seqable<?T>) -> List<T> :
   match(xs) :
      (xs:List<T>) :
         xs
      (xs) :
         val vec = to-vector<T>(xs)
         defn* loop (i:Int, accum:List<T>) :
            if i >= 0 : loop(i - 1, cons(vec[i], accum))
            else : accum
         loop(length(vec) - 1, List())

public defn in-reverse<?T> (xs:List<?T>) -> Seq<T> :
   generate<T> :
      defn loop (xs:List<T>) :
         if not empty?(xs) :
            loop(tail(xs))
            yield(head(xs))
      loop(xs)

defmethod do<?T> (f:T -> ?, xs:List<?T>) -> False :
   defn* loop (xs:List<T>) :
      if not empty?(xs) :
         f(head(xs))
         loop(tail(xs))
   loop(xs)

;============================================================
;===================== True/False ===========================
;============================================================

public defn complement (a:True|False) -> True|False :
   if a : false
   else : true

defmethod equal? (a:True|False, b:True|False) -> True|False :
   ($prim identical? a b)

;============================================================
;=================== IndexedCollections =====================
;============================================================

;                       Interface
;                       =========

public defmulti get<?T> (a:IndexedCollection<?T>, i:Int) -> T
public defmulti set<?T> (a:IndexedCollection<?T>, i:Int, v:T) -> False
public defmulti get<?T> (a:IndexedCollection<?T>, r:Range) -> Collection<T>
public defmulti set<?T> (a:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False
public defmulti set-all<?T> (a:IndexedCollection<?T>, r:Range, v:T) -> False
public defmulti map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False

;                 Abstract Implementations
;                 ========================

public defn empty? (v:IndexedCollection) :
   length(v) == 0

defmethod print (o:OutputStream, a:IndexedCollection) -> False :
   print(o, "[%@]" % [a])

defmethod map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False :
   for i in 0 to length(xs) do :
      xs[i] = f(xs[i])

defmethod get<?T> (xs:IndexedCollection<?T>, r:Range) -> Tuple<T> :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])

defmethod set<?T> (xs:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   val vs-seq = to-seq(vs)
   for i in b to e do : xs[i] = next(vs-seq)

defmethod set-all<?T> (xs:IndexedCollection<?T>, r:Range, v:T) -> False :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   for i in b to e do : xs[i] = v

defmethod to-seq<?T> (xs:IndexedCollection<?T>) -> Seq<T> :
   seq({xs[_]}, 0 to length(xs))

public defn reverse!<?T> (xs:IndexedCollection<?T>) -> False :
   val n = length(xs)
   for i in 0 to n / 2 do :
      val j = n - 1 - i
      val xi = xs[i]
      val xj = xs[j]
      xs[i] = xj
      xs[j] = xi

public defn in-reverse<?T> (xs:IndexedCollection<?T>) -> Seq<T> :
   val n = length(xs)
   for i in (n - 1) through 0 by -1 seq :
      xs[i]

;                       Sorting
;                       =======

public defn qsort!<?T> (xs:IndexedCollection<?T>, is-less?:(T,T) -> True|False) -> False :
   ;Swap element i with element j
   defn swap (i:Int, j:Int) :
      if i != j :
         val xi = xs[i]
         val xj = xs[j]
         xs[i] = xj
         xs[j] = xi

   ;Rearrange elements from b to e, such that the first elements is less than pivot.
   ;Returns a s.t. all elements from b to a are less than pivot.
   defn partition (b:Int, e:Int, pivot:T) :
      defn* loop (a:Int, b:Int) -> Int :
         if b < e :
            val xb = xs[b]
            if is-less?(xb, pivot) :
               swap(a, b)
               loop(a + 1, b + 1)
            else : loop(a, b + 1)
         else : a
      loop(b, b)

   ;Driver
   defn* sort (b:Int, e:Int) :
      val n = e - b
      if n > 2 :
         swap(rand(b to e), e - 1) when n > 10
         val e1 = partition(b, e - 1, xs[e - 1])
         swap(e1, e - 1)
         sort(b, e1)
         sort(e1 + 1, e)
      else if n == 2 :
         swap(b, b + 1) when is-less?(xs[b + 1], xs[b])

   sort(0, length(xs))

public defn qsort!<?T> (xs:IndexedCollection<?T&Comparable<T>>) -> False :
   qsort!(xs, less?)

public defn qsort!<?T,?S> (key:T -> ?S&Comparable<S>, xs:IndexedCollection<?T>) -> False :
   qsort!{xs, _} $ fn (x, y) :
      key(x) < key(y)

;                       Lazy Sorting
;                       ============

public defn lazy-qsort<?T> (coll:Seqable<?T>, is-less?:(T,T) -> True|False) -> Collection<T> & Lengthable :
   ;Convert to a vector
   val xs = to-vector<T>(coll)

   ;Sort Progress
   defn sort-progress () :
      generate<Int> :
         ;Swap element i with element j
         defn swap (i:Int, j:Int) :
            if i != j :
               val xi = xs[i]
               val xj = xs[j]
               xs[i] = xj
               xs[j] = xi

         ;Rearrange elements from b to e, such that the first elements is less than pivot.
         ;Returns a s.t. all elements from b to a are less than pivot.
         defn partition (b:Int, e:Int, pivot:T) :
            defn* loop (a:Int, b:Int) -> Int :
               if b < e :
                  val xb = xs[b]
                  if is-less?(xb, pivot) :
                     swap(a, b)
                     loop(a + 1, b + 1)
                  else : loop(a, b + 1)
               else : a
            loop(b, b)

         ;Driver
         defn* sort (b:Int, e:Int) :
            val n = e - b
            if n > 2 :
               swap(rand(b to e), e - 1) when n > 10
               val e1 = partition(b, e - 1, xs[e - 1])
               swap(e1, e - 1)
               sort(b, e1)
               yield(e1 + 1)
               sort(e1 + 1, e)
            else if n == 2 :
               swap(b, b + 1) when is-less?(xs[b + 1], xs[b])

         sort(0, length(xs))
         break(length(xs))

   ;Ensuring Progress
   var sorted = 0
   val sorter = sort-progress()
   defn* ensure-sorted (n:Int) :
      if sorted < n :
         sorted = next(sorter)
         ensure-sorted(n)

   ;Return object
   new Collection<T> & Lengthable :
      defmethod length (this) :
         length(xs)
      defmethod to-seq (this) :
         for i in 0 to length(xs) seq :
            ensure-sorted(i + 1)
            xs[i]

public defn lazy-qsort<?T> (coll:Seqable<?T&Comparable<T>>) :
   lazy-qsort(coll, less?)

public defn lazy-qsort<?T,?S> (key:T -> ?S&Comparable<S>, coll:Seqable<?T>) :
   lazy-qsort{coll, _} $ fn (x, y) :
      key(x) < key(y)

;============================================================
;======================= Arrays =============================
;============================================================

;                 Abstract Implementations
;                 ========================

public defn to-array<T> (xs:Seqable<T>) -> Array<T> :
   match(xs) :
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val a = Array<T>(n)
         for (x in xs, i in 0 to n) do :
            a[i] = x
         a
      (xs) :
         to-array<T>(to-list(xs))

public defn map<R,?T> (f: T -> R, xs:Array<?T>) -> Array<R> :
   val ret = Array<R>(length(xs))
   for (x in xs, i in 0 to false) do :
      ret[i] = f(x)
   ret

;                     Implementation
;                     ==============

lostanza deftype RawArray <: Array :
   length: long
   items: ref<?> ...

lostanza defn RawArray (n:ref<Int>, x:ref<?>) -> ref<RawArray> :
   val l = n.value
   val a = new RawArray{l}
   for (var i:long = 0, i < l, i = i + 1) :
      a.items[i] = x
   return a

defmethod get (a:RawArray, i:Int) -> ? :
   ($prim aget a i)

defmethod set (a:RawArray, i:Int, v) -> False :
   ($prim aset a i v)

lostanza defmethod set-all (xs:ref<RawArray>, r:ref<Range>, v:ref<?>) -> ref<False> :
   val range = range-bound(xs, r) as ref<Tuple<Int>>
   val b = range.items[0].value
   val e = range.items[1].value
   for (var i:long = b, i < e, i = i + 1) :
      xs.items[i] = v
   return false

defmethod length (a:RawArray) -> Int :
   ($prim alen a)

defmethod print (o:OutputStream, a:RawArray) -> False :
   print(o, "[%@]" % [a])

defmethod equal? (a:RawArray, b:RawArray) :
   ($prim identical? a b)

;                     Wrapping
;                     ========

#if-defined(OPTIMIZE) :

   public defn Array<T> (n:Int) -> Array<T> :
      RawArray(n, sentinel)

   public defn Array<T> (n:Int, x:T) -> Array<T> :
      RawArray(n, x)

#else :

   deftype WrappedArray<T> <: Array<T>
   defmulti raw (a:WrappedArray) -> RawArray

   public defn Array<T> (n:Int) -> Array<T> :
      #if-not-defined(OPTIMIZE) :
         ensure-non-negative("length", n)
      Array<T>(RawArray(n, sentinel))

   public defn Array<T> (n:Int, x:T) -> Array<T> :
      #if-not-defined(OPTIMIZE) :
         ensure-non-negative("length", n)
      Array<T>(RawArray(n, x))

   defn Array<T> (a:RawArray) -> Array<T> :
      new WrappedArray<T> :
         defmethod raw (this) : a
         defmethod get (this, i:Int) :
            #if-not-defined(OPTIMIZE) :
               ensure-index-in-bounds(a, i)
            match(a[i]) :
               (v:Sentinel) : fatal("Index (%_) is uninitialized." % [i])
               (v) : v
         defmethod set (this, i:Int, v:T) :
            #if-not-defined(OPTIMIZE) :
               ensure-index-in-bounds(a, i)
            a[i] = v
         defmethod set-all (this, r:Range, v:T) :
            #if-not-defined(OPTIMIZE) :
               ensure-index-range(a, r)
            set-all(a, r, v)
         defmethod length (this) :
            length(a)
         defmethod print (o:OutputStream, this) :
            print(o, a)
         defmethod equal? (this, x:WrappedArray) :
            a == raw(x)

;                     Looping
;                     =======

defmethod do<?T> (f: T -> ?, xs:Array<?T>) :
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(xs[i])
         loop(i + 1, n - 1)
   loop(0, length(xs))

;============================================================
;==================== CharArrays ============================
;============================================================

;                     Implementation
;                     ==============

public lostanza defn CharArray (n:ref<Int>, x:ref<Char>) -> ref<CharArray> :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative-length(n)
   val l = n.value
   val a = new CharArray{l}
   val c = x.value
   for (var i:long = 0, i < l, i = i + 1) :
      a.chars[i] = c
   return a

public defn CharArray (n:Int) -> CharArray :
   CharArray(n, ' ')

defmethod get (a:CharArray, i:Int) -> Char :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(a, i)
   ($prim char-aget a i)

defmethod set (a:CharArray, i:Int, c:Char) -> False :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(a, i)
   ($prim char-aset a i c)

defmethod length (a:CharArray) -> Int :
   ($prim alen a)

lostanza defn substring! (a:ref<CharArray>, b:ref<Int>, e:ref<Int>) -> ref<String> :
   val len = e.value - b.value
   val start = b.value
   val s = String(len)
   for (var i:long = 0, i < len, i = i + 1) :
      s.chars[i] = a.chars[i + start]
   s.chars[len] = 0 as byte
   return s

defmethod get (a:CharArray, r:Range) -> String :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(a, r)
   val [b, e] = range-bound(a, r)
   substring!(a, b, e)

;                     Looping
;                     =======

defmethod do (f: Char -> ?, xs:CharArray) :
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(xs[i])
         loop(i + 1, n - 1)
   loop(0, length(xs))

;============================================================
;==================== Byte Arrays ===========================
;============================================================

;                     Implementation
;                     ==============

public lostanza defn ByteArray (n:ref<Int>, x:ref<Byte>) -> ref<ByteArray> :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative-length(n)
   val l = n.value
   val a = new ByteArray{l}
   val xv = x.value
   for (var i:long = 0, i < l, i = i + 1) :
      a.data[i] = xv
   return a

public defn ByteArray (n:Int) -> ByteArray :
   ByteArray(n, 0Y)

lostanza defmethod get (a:ref<ByteArray>, i:ref<Int>) -> ref<Byte> :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(a, i)
   return new Byte{a.data[i.value]}

lostanza defmethod set (a:ref<ByteArray>, i:ref<Int>, x:ref<Byte>) -> ref<False> :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(a, i)
   a.data[i.value] = x.value   
   return false   

lostanza defmethod length (a:ref<ByteArray>) -> ref<Int> :
   return new Int{a.length as int}

lostanza defmethod get (a:ref<ByteArray>, r:ref<Range>) -> ref<ByteArray> :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(a, r)
   val rb = range-bound(a, r)
   val b = get(rb, new Int{0}).value
   val e = get(rb, new Int{1}).value
   val len = e - b
   val ret = new ByteArray{len}
   for (var i:long = 0, i < len, i = i + 1) :
      ret.data[i] = a.data[i + b]
   return ret   

lostanza defmethod set (a:ref<ByteArray>, r:ref<Range>, xs:ref<ByteArray>) -> ref<False> :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(a, r)
   val rb = range-bound(a, r)
   val b = get(rb, new Int{0}).value
   val e = get(rb, new Int{1}).value
   val len = e - b
   #if-not-defined(OPTIMIZE) :
      ensure-len-le-xs(new Int{len}, xs)
   for (var i:long = 0, i < len, i = i + 1) :
      a.data[i + b] = xs.data[i]
   return false
defn ensure-len-le-xs (len:Int, xs:ByteArray) :
   if len > length(xs) :
      fatal("Length of range (%_) is greater than length of values array (%_)." % [
         len, length(xs)])


;                     Looping
;                     =======

defmethod do (f: Byte -> ?, xs:ByteArray) :
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(xs[i])
         loop(i + 1, n - 1)
   loop(0, length(xs))


;============================================================
;=================== StringBuffer ===========================
;============================================================

;                     Interface
;                     =========

public defmulti add (s:StringBuffer, c:Char) -> False
public defmulti add-all (s:StringBuffer, c:Seqable<Char>) -> False
public defmulti clear (s:StringBuffer) -> False

;               Abstract Implementation
;               =======================

defmethod add-all (s:StringBuffer, xs:Seqable<Char>) :
   do(add{s, _}, xs)

defmethod print (s:StringBuffer, c:Char) : add(s, c)
defmethod print (s:StringBuffer, cs:String) : add-all(s, cs)
defmethod print (s:StringBuffer, cs:StringBuffer) : add-all(s, cs)
defmethod print (s:StringBuffer, cs:CharArray) : add-all(s, cs)

defmethod print-all (s:StringBuffer, cs:String) : add-all(s, cs)
defmethod print-all (s:StringBuffer, cs:StringBuffer) : add-all(s, cs)
defmethod print-all (s:StringBuffer, cs:CharArray) : add-all(s, cs)

defmethod write (o:OutputStream, s:StringBuffer) :
   print(o, '"')
   for c in s do :
      escape-for-string(o, c)
   print(o, '"')

;                   Implementation
;                   ==============

public defn StringBuffer (n:Int) -> StringBuffer :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative("length", n)
   var buffer = CharArray(n)
   var len = 0

   defn ensure-capacity (c:Int) :
      defn set-capacity (c:Int) :
         val buffer* = CharArray(c)
         for i in 0 to len do :
            buffer*[i] = buffer[i]
         buffer = buffer*
      val cur-c = length(buffer)
      set-capacity(max(c, 2 * cur-c)) when c > cur-c

   new StringBuffer :
      defmethod add (this, c:Char) :
         ensure-capacity(len + 1)
         buffer[len] = c
         len = len + 1

      defmethod add-all (this, xs:Seqable<Char> & Lengthable) :
         val n = length(xs)
         ensure-capacity(len + n)
         for (x in xs, i in 0 to n) do :
            buffer[len + i] = x
         len = len + n

      defmethod clear (this) :
         len = 0

      defmethod get (this, i:Int) :
         #if-not-defined(OPTIMIZE) :
            ensure-index-in-bounds(this, i)
         buffer[i]

      defmethod set (this, i:Int, c:Char) :
         if i == len :
            add(this, c)
         else :
            #if-not-defined(OPTIMIZE) :
               ensure-index-in-bounds(this, i)
            buffer[i] = c

      defmethod length (this) :
         len

      defmethod to-string (this) :
         buffer[0 to len] as String

public defn StringBuffer () :
   StringBuffer(32)

;============================================================
;===================== FileInfo =============================
;============================================================

;                     Interface
;                     =========

public defmulti filename (i:FileInfo) -> String
public defmulti line (i:FileInfo) -> Int
public defmulti column (i:FileInfo) -> Int

;                  Implementation
;                  ==============

public defn FileInfo (f:String, l:Int, c:Int) :
   new FileInfo :
      defmethod filename (this) : f
      defmethod line (this) : l
      defmethod column (this) : c

defmethod equal? (a:FileInfo, b:FileInfo) :
   filename(a) == filename(b) and
   line(a) == line(b) and
   column(a) == column(b)

defmethod hash (i:FileInfo) :
   hash(filename(i)) +
   7 * hash(line(i)) +
   49 * hash(column(i))

defmethod compare (a:FileInfo, b:FileInfo) :
   val c = compare(filename(a), filename(b))
   if c == 0 :
      val c = compare(line(a), line(b))
      if c == 0 :
         compare(column(a), column(b))
      else : c
   else : c

defmethod print (o:OutputStream, i:FileInfo) :
   print(o, filename(i))
   print(o, ":")
   print(o, line(i))
   print(o, ".")
   print(o, column(i))

;============================================================
;====================== Tokens ==============================
;============================================================

;                      Interface
;                      =========

public defmulti item (t:Token) -> ?
public defmulti info (t:Token) -> FileInfo

;                     Constructor
;                     ===========

public defn Token (item, info:FileInfo) :
   new Token :
      defmethod item (this) : item
      defmethod info (this) : info

public defn unwrap-token (t) :
   match(t) :
      (t:Token) : unwrap-token(item(t))
      (t) : t

public defn unwrap-all (t) -> ? :
   match(t) :
      (t:Token) : unwrap-all(item(t))
      (t:List) : map(unwrap-all, t)
      (t) : t

defmethod print (o:OutputStream, t:Token) :
   write(o, item(t))

defmethod equal? (a:Token, b:Token) :
   (item(a) == item(b)) and
   (info(a) == info(b))

;============================================================
;==================== KeyValue Pairs ========================
;============================================================

;                       Interface
;                       =========

public defmulti key<?K> (kv:KeyValue<?K,?>) -> K
public defmulti value<?V> (kv:KeyValue<?,?V>) -> V

;                      Constructor
;                      ===========

public defn KeyValue<?K,?V> (k:?K, v:?V) -> KeyValue<K,V> :
   new KeyValue<K,V> :
      defmethod key (this) : k
      defmethod value (this) : v

defmethod print (o:OutputStream, v:KeyValue) :
   write(o, key(v))
   print(o, " => ")
   write(o, value(v))

defmethod equal? (a:KeyValue, b:KeyValue) :
   key(a) == key(b) and
   value(a) == value(b)

defmethod hash (x:KeyValue<Hashable,Hashable>) :
   hash(key(x)) + 7 * hash(value(x))

;============================================================
;===================== Exceptions ===========================
;============================================================

public defn Exception (msg) :
   new Exception :
      defmethod print (o:OutputStream, this) :
         print(o, msg)

var CURRENT-EXCEPTION-HANDLER : Exception -> Void =
   fn (e:Exception) :
      fatal(e)

defmethod print (o:OutputStream, e:Exception) :
   print(o, "Exception")

public defn throw (e:Exception) :
   CURRENT-EXCEPTION-HANDLER(e)

defstruct ExceptionResult : (exception: Exception)
defstruct NormalResult : (result)

public defn with-exception-handler<?T> (body: () -> ?T,
                                        handler: Exception -> ?T) -> T :
   val r = label<ExceptionResult|NormalResult> break :
      let-var CURRENT-EXCEPTION-HANDLER = break{ExceptionResult(_)} :
         NormalResult(body())
   match(r) :
      (r:ExceptionResult) : handler(exception(r))
      (r:NormalResult) : result(r)

public defn with-finally<?T> (body: () -> ?T, finally: (True|False) -> ?) -> T :
   var entered? = false
   dynamic-wind(
      fn () :
         fatal("Cannot re-enter body with finally clause.") when entered?
         entered? = true
      body
      finally)


;============================================================
;================== Failure Handler =========================
;============================================================

var CURRENT-FAILURE-HANDLER : () -> Void =
   fn () :
      fatal("Uncaught failure")

public defn fail () :
   CURRENT-FAILURE-HANDLER()

public defn with-attempt<?T> (conseq: () -> ?T, alt: () -> ?T) :
   val result = label<Maybe<T>> return :
      let-var CURRENT-FAILURE-HANDLER = fn* () : return(None()) :
         One(conseq())
   match(result) :
      (r:One<T>) : value(r)
      (r:None) : alt()

;============================================================
;==================== Conversions ===========================
;============================================================

;                 Numeric Conversions
;                 ===================

public lostanza defn to-byte (b:ref<Byte>) -> ref<Byte> : return b
public lostanza defn to-byte (c:ref<Char>) -> ref<Byte> : return new Byte{c.value}
public lostanza defn to-byte (i:ref<Int>) -> ref<Byte> : return new Byte{i.value as byte}
public lostanza defn to-byte (l:ref<Long>) -> ref<Byte> : return new Byte{l.value as byte}
public lostanza defn to-byte (f:ref<Float>) -> ref<Byte> : return new Byte{f.value as byte}
public lostanza defn to-byte (d:ref<Double>) -> ref<Byte> : return new Byte{d.value as byte}
public lostanza defn to-char (b:ref<Byte>) -> ref<Char> : return new Char{b.value}
public lostanza defn to-char (c:ref<Char>) -> ref<Char> : return c
public lostanza defn to-char (i:ref<Int>) -> ref<Char> : return new Char{i.value as byte}
public lostanza defn to-int (b:ref<Byte>) -> ref<Int> : return new Int{b.value}
public lostanza defn to-int (c:ref<Char>) -> ref<Int> : return new Int{c.value}
public lostanza defn to-int (i:ref<Int>) -> ref<Int> : return i
public lostanza defn to-int (l:ref<Long>) -> ref<Int> : return new Int{l.value as int}
public lostanza defn to-int (f:ref<Float>) -> ref<Int> : return new Int{f.value as int}
public lostanza defn to-int (d:ref<Double>) -> ref<Int> : return new Int{d.value as int}
public lostanza defn to-long (b:ref<Byte>) -> ref<Long> : return new Long{b.value}
public lostanza defn to-long (i:ref<Int>) -> ref<Long> : return new Long{i.value}
public lostanza defn to-long (l:ref<Long>) -> ref<Long> : return l
public lostanza defn to-long (f:ref<Float>) -> ref<Long> : return new Long{f.value as long}
public lostanza defn to-long (d:ref<Double>) -> ref<Long> : return new Long{d.value as long}
public lostanza defn to-float (b:ref<Byte>) -> ref<Float> : return new Float{b.value as float}
public lostanza defn to-float (i:ref<Int>) -> ref<Float> : return new Float{i.value as float}
public lostanza defn to-float (l:ref<Long>) -> ref<Float> : return new Float{l.value as float}
public lostanza defn to-float (f:ref<Float>) -> ref<Float> : return f
public lostanza defn to-float (d:ref<Double>) -> ref<Float> : return new Float{d.value as float}
public lostanza defn to-double (b:ref<Byte>) -> ref<Double> : return new Double{b.value as double}
public lostanza defn to-double (i:ref<Int>) -> ref<Double> : return new Double{i.value as double}
public lostanza defn to-double (l:ref<Long>) -> ref<Double> : return new Double{l.value as double}
public lostanza defn to-double (f:ref<Float>) -> ref<Double> : return new Double{f.value}
public lostanza defn to-double (d:ref<Double>) -> ref<Double> : return d

;                Numeric Reinterpretations
;                =========================

public lostanza defn bits (f:ref<Float>) -> ref<Int> :
   val v = f.value
   return new Int{($ls-prim bits v)}

public lostanza defn bits (d:ref<Double>) -> ref<Long> :
   val v = d.value
   return new Long{($ls-prim bits v)}

public lostanza defn bits-as-float (i:ref<Int>) -> ref<Float> :
   val v = i.value
   return new Float{($ls-prim fnum v)}

public lostanza defn bits-as-double (i:ref<Long>) -> ref<Double> :
   val v = i.value
   return new Double{($ls-prim fnum v)}

;============================================================
;==================== Number Parsing ========================
;============================================================

;                        Drivers
;                        =======

public defn to-byte (s:String) -> False|Byte :
   match(to-int(s)) :
      (i:Int) : to-byte(i) when i >= 0 and i <= 255
      (i:False) : false

public lostanza defn to-int (s:ref<String>) -> ref<False|Int> :
   if prefix?(s, "-") :
      return neg-to-int(s, 1, 10)
   else if prefix?(s, "0x") :
      return bits-to-int(s, 2, 16, 4)
   else if prefix?(s, "0o") :
      return bits-to-int(s, 2, 8, 3)
   else if prefix?(s, "0b") :
      return bits-to-int(s, 2, 2, 1)
   else :
      return pos-to-int(s, 0, 10)

public lostanza defn to-long (s:ref<String>) -> ref<False|Long> :
   if prefix?(s, "-") :
      return neg-to-long(s, 1, 10)
   else if prefix?(s, "0x") :
      return bits-to-long(s, 2, 16, 4)
   else if prefix?(s, "0o") :
      return bits-to-long(s, 2, 8, 3)
   else if prefix?(s, "0b") :
      return bits-to-long(s, 2, 2, 1)
   else :
      return pos-to-long(s, 0, 10)

;TODO: This is necessary because addresses of local variables don't work yet.
lostanza var DOUBLE-BUFFER : double
lostanza var CHAR-BUFFER : byte
public lostanza defn to-double (s:ref<String>) -> ref<False|Double> :
   val n = call-c clib/sscanf(addr!(s.chars), "%lf%c", addr(DOUBLE-BUFFER), addr(CHAR-BUFFER))
   if n != 1 : return false
   else : return new Double{DOUBLE-BUFFER}

lostanza var FLOAT-BUFFER : float
public lostanza defn to-float (s:ref<String>) -> ref<False|Float> :
   val n = call-c clib/sscanf(addr!(s.chars), "%f%c", addr(FLOAT-BUFFER), addr(CHAR-BUFFER))
   if n != 1 : return false
   else : return new Float{FLOAT-BUFFER}

;                        Utilities
;                        =========

lostanza defn prefix? (str:ref<String>, prefix:ptr<byte>) -> int :
   for (var i:long = 0, 1, i = i + 1) :
      if prefix[i] == 0 : return 1
      else if str.chars[i] == 0 : return 0
      else if prefix[i] != str.chars[i] : return 0
   return 0

lostanza defn digit (c:byte, radix:int) -> int :
   var d:int
   if c >= '0' and c <= '9' : d = c - '0'
   else if c >= 'a' and c <= 'f' : d = c - 'a' + 10
   else if c >= 'A' and c <= 'F' : d = c - 'A' + 10
   else : return -1
   if d < radix : return d
   else : return -1

;                        Parsing Integers
;                        ================

lostanza defn pos-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
   var n:int = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Int{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = n * radix + d
            if n < 0 : return false
   fatal("Unreachable")
   return false

lostanza defn neg-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
   var n:int = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Int{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = n * radix - d
            if n > 0 : return false
   fatal("Unreachable")
   return false

lostanza defn bits-to-int (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Int> :
   var n:int = 0
   var nbits:int = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Int{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = (n << bits) | d
            nbits = nbits + bits
            if nbits >= 32 + bits : return false
   fatal("Unreachable")
   return false

;                        Parsing Longs
;                        =============

lostanza defn pos-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
   var n:long = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Long{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = n * radix + d
            if n < 0 : return false
   fatal("Unreachable")
   return false

lostanza defn neg-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
   var n:long = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Long{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = n * radix - d
            if n > 0 : return false
   fatal("Unreachable")
   return false

lostanza defn bits-to-long (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Long> :
   var n:long = 0
   var nbits:int = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Long{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = (n << bits) | d
            nbits = nbits + bits
            if nbits >= 64 + bits : return false
   fatal("Unreachable")
   return false

;============================================================
;==================== Arithmetic ============================
;============================================================

public defn max<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T :
   b when a < b else a

public defn min<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T :
   a when a < b else b

public defn minimum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
   reduce{_, xs} $ fn (x, y) :
      if x < y : x
      else : y

public defn minimum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
   reduce{_, x0, xs} $ fn (x, y) :
      if x < y : x
      else : y

public defn maximum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
   reduce{_, xs} $ fn (x, y) :
      if x < y : y
      else : x

public defn maximum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
   reduce{_, x0, xs} $ fn (x, y) :
      if x < y : y
      else : x

public defn minimum<?T> (xs:Seqable<?T&Comparable>) -> T : minimum(xs, less?)
public defn maximum<?T> (xs:Seqable<?T&Comparable>) -> T : maximum(xs, less?)

public defn minimum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : minimum(x0, xs, less?)
public defn maximum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : maximum(x0, xs, less?)

public defn minimum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T : minimum(xs, {key(_) < key(_)})
public defn maximum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T : maximum(xs, {key(_) < key(_)})

public lostanza defn rand () -> ref<Int> :
   val i = call-c clib/rand()
   return new Int{i}

public defn rand (n:Int) :
   #if-not-defined(OPTIMIZE) :
      ensure-positive("limit", n)
   rand() % n

;TODO: Ensure r has step size 1.
;TODO: Fix problems with overflow.
public defn rand (r:Range) :
   val s = start(r)
   match(end(r), inclusive?(r)) :
      (e:Int, inc:True) :
         #if-not-defined(OPTIMIZE) :
            ensure-start-before-end(s, e)
         rand(e + 1 - s) + s
      (e:Int, inc:False) :
         #if-not-defined(OPTIMIZE) :
            if e == s : fatal("Empty range.")
            else : ensure-start-before-end(s, e)
         rand(e - s) + s
      (e:False, inc) :
         fatal("Unbounded range.")

public defn ceil-log2 (i:Int) -> Int :
   defn* loop (n:Int, l:Int) :
      if i > n :
         if l == 30 : l + 1
         else : loop(n << 1, l + 1)
      else : l
   fatal("Log of non-positive number!") when i <= 0
   loop(1, 0)

public defn floor-log2 (i:Int) -> Int :
   defn* loop (n:Int, l:Int) :
      if i == n : l
      else if i < n : l - 1
      else if l == 30 : l
      else : loop(n << 1, l + 1)
   fatal("Log of non-positive number!") when i <= 0
   loop(1, 0)

public defn ceil-log2 (i:Long) -> Int :
   defn* loop (n:Long, l:Int) :
      if i > n :
         if l == 62 : l + 1
         else : loop(n << to-long(1), l + 1)
      else : l
   fatal("Log of non-positive number!") when i <= to-long(0)
   loop(to-long(1), 0)

public defn floor-log2 (i:Long) -> Int :
   defn* loop (n:Long, l:Int) :
      if n == i : l
      else if i < n : l - 1
      else if l == 62 : l
      else : loop(n << to-long(1), l + 1)
   fatal("Log of non-positive number!") when i <= to-long(0)
   loop(to-long(1), 0)

public defn next-pow2 (i:Int) -> Int :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative("value", i)
   if i == 0 :
      i
   else :
      val n = ceil-log2(i)
      if n <= 30 : 1 << n
      else : fatal("Overflow")

public defn prev-pow2 (i:Int) -> Int :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative("value", i)
   if i == 0 :
      i
   else :
      1 << floor-log2(i)

public defn next-pow2 (i:Long) -> Long :
   val n = ceil-log2(i)
   if n <= 62 : to-long(1) << to-long(n)
   else : fatal("Overflow")

public defn prev-pow2 (i:Long) -> Long :
   to-long(1) << to-long(floor-log2(i))

public defn sum (xs: Seqable<Int>) -> Int : reduce(plus, 0, xs)
public defn sum (xs: Seqable<Long>) -> Long : reduce(plus, 0L, xs)
public defn sum (xs: Seqable<Float>) -> Float : reduce(plus, 0.0f, xs)
public defn sum (xs: Seqable<Double>) -> Double : reduce(plus, 0.0, xs)

public defn product (xs: Seqable<Int>) -> Int : reduce(times, 1, xs)
public defn product (xs: Seqable<Long>) -> Long : reduce(times, 0L, xs)
public defn product (xs: Seqable<Float>) -> Float : reduce(times, 1.0f, xs)
public defn product (xs: Seqable<Double>) -> Double : reduce(times, 1.0, xs)


;============================================================
;================== Sequence Library ========================
;============================================================

public defmulti do<?T> (f:T -> ?, xs:Seqable<?T>) -> False
public defmulti do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False
public defmulti do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False

defmethod do<?T> (f:T -> ?, xs:Seqable<?T>) -> False :
   for xs-seq in xs do-seq :
      while not empty?(xs-seq) :
         f(next(xs-seq))

defmethod do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         while (not empty?(xs-seq)) and (not empty?(ys-seq)) :
            f(next(xs-seq), next(ys-seq))

defmethod do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            while (not empty?(xs-seq)) and (not empty?(ys-seq)) and (not empty?(zs-seq)) :
               f(next(xs-seq), next(ys-seq), next(zs-seq))

public defn seq<?T,?S> (f:T -> ?S, xs:Seqable<?T>) -> Seq<S> :
   match(xs) :
      (xs:Seq<T> & Lengthable) :
         new Seq<S> & Lengthable :
            defmethod empty? (this) : empty?(xs)
            defmethod next (this) : f(next(xs))
            defmethod peek (this) : f(peek(xs))
            defmethod length (this) : length(xs)
            defmethod free (this) : free(xs)
      (xs:Seq<T>) :
         new Seq<S> :
            defmethod empty? (this) : empty?(xs)
            defmethod next (this) : f(next(xs))
            defmethod peek (this) : f(peek(xs))
            defmethod free (this) : free(xs)
      (xs) :
         seq(f, to-seq(xs))

public defn seq<?T,?S,?R> (f:(T,S) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   match(xs, ys) :
      (xs:Seq<T> & Lengthable, ys:Seq<S> & Lengthable) :
         var len = min(length(xs), length(ys))
         new Seq<R> & Lengthable :
            defmethod empty? (this) :
               empty?(xs) or empty?(ys)
            defmethod next (this) :
               len = len - 1
               f(next(xs), next(ys))
            defmethod peek (this) :
               f(peek(xs), peek(ys))
            defmethod length (this) :
               len
            defmethod free (this) :
               free(xs)
               free(ys)
      (xs:Seq<T>, ys:Seq<S>) :
         new Seq<R> :
            defmethod empty? (this) : empty?(xs) or empty?(ys)
            defmethod next (this) : f(next(xs), next(ys))
            defmethod peek (this) : f(peek(xs), peek(ys))
            defmethod free (this) : (free(xs), free(ys))
      (xs, ys) :
         seq(f, to-seq(xs), to-seq(ys))


public defn seq<?T,?S,?U,?R> (f:(T,S,U) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   match(xs, ys, zs) :
      (xs:Seq<T> & Lengthable, ys:Seq<S> & Lengthable, zs:Seq<U> & Lengthable) :
         var len = min(min(length(xs), length(ys)), length(zs))
         new Seq<R> & Lengthable :
            defmethod empty? (this) :
               empty?(xs) or empty?(ys) or empty?(zs)
            defmethod next (this) :
               len = len - 1
               f(next(xs), next(ys), next(zs))
            defmethod peek (this) :
               f(peek(xs), peek(ys), peek(zs))
            defmethod length (this) :
               len
            defmethod free (this) :
               free(xs)
               free(ys)
               free(zs)
      (xs:Seq<T>, ys:Seq<S>, zs:Seq<U>) :
         new Seq<R> :
            defmethod empty? (this) : empty?(xs) or empty?(ys) or empty?(zs)
            defmethod next (this) : f(next(xs), next(ys), next(zs))
            defmethod peek (this) : f(peek(xs), peek(ys), peek(zs))
            defmethod free (this) : (free(xs), free(ys), free(zs))
      (xs, ys, zs) :
         seq(f, to-seq(xs), to-seq(ys), to-seq(zs))

public defn contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False :
   label<False|True> return :
      for x in xs do :
         return(true) when x == y

public defn find<?T> (f: T -> True|False, xs:Seqable<?T>) -> T|False :
   label<False|T> return :
      for x in xs do :
         return(x) when f(x)

public defn find<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> T|False :
   label<False|T> return :
      for (x in xs, y in ys) do :
         return(x) when f(x, y)

public defn find!<?T> (f: T -> True|False, xs:Seqable<?T>) : find(f, xs) as T
public defn find!<?T, ?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : find(f, xs, ys) as T

public defn first<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Maybe<R> :
   label<Maybe<R>> return :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()

public defn first<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Maybe<R> :
   label<Maybe<R>> return :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()

public defn first!<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) : value!(first(f, xs))
public defn first!<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) : value!(first(f, xs, ys))

public defn seq?<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Seq<R> :
   generate<R> :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?U,?R> (f: (T,S,U) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys, z in zs) do :
         match(f(x, y, z)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn filter<?T> (f: T -> True|False, xs:Seqable<?T>) -> Seq<T> :
   generate<T> :
      for x in xs do :
         yield(x) when f(x)

public defn filter<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<T> :
   generate<T> :
      for (x in xs, y in ys) do :
         yield(x) when f(x, y)

public defn filter<?T> (xs:Seqable<?T>, sel:Seqable<True|False>) -> Seq<T> :
   for (x in xs, s in sel) filter : s

public defn index-of (xs:Seqable<Equalable>, y:Equalable) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when x == y

public defn index-of! (xs:Seqable<Equalable>, y:Equalable) : index-of(xs, y) as Int

public defn index-when<?T> (f: T -> True|False, xs:Seqable<?T>) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when f(x)

public defn index-when<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Int|False :
   label<Int|False> return :
      for (x in xs, y in ys, i in 0 to false) do :
         return(i) when f(x, y)

public defn index-when!<?T> (f: T -> True|False, xs:Seqable<?T>) : index-when(f, xs) as Int
public defn index-when!<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : index-when(f, xs, ys) as Int

public defn split<?T> (f: T -> True|False, xs: Seqable<?T>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for x in xs do :
      add{_, x} $
         if f(x) : true-xs
         else : false-xs
   [true-xs, false-xs]

public defn split<?T> (xs:Seqable<?T>, ss:Seqable<True|False>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for (x in xs, s in ss) do :
      add{_, x} $
         if s : true-xs
         else : false-xs
   [true-xs, false-xs]

public defn take-while<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = peek(xs-seq)
               if f(x) :
                  next(xs-seq)
                  yield(x)
                  loop()
         loop()

public defn take-until<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = next(xs-seq)
               yield(x)
               loop() when not f(x)
         loop()

public defn take-n<?T> (n:Int, xs:Seqable<?T>) :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative("length", n)
   var len = n
   val xs-seq = to-seq(xs)
   new Seq<T> & Lengthable :
      defmethod next (this) :
         val v = peek(this)
         next(xs-seq)
         len = len - 1
         v
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         peek(xs-seq)
      defmethod empty? (this) :
         len == 0
      defmethod length (this) :
         len
      defmethod free (this) :
         free(xs-seq)

public defn take-up-to-n<?T> (n:Int, xs:Seqable<?T>) :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative("length", n)
   var len = n
   val xs-seq = to-seq(xs)
   new Seq<T> :
      defmethod next (this) :
         val v = peek(this)
         next(xs-seq)
         len = len - 1
         v
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         peek(xs-seq)
      defmethod empty? (this) :
         (len == 0) or empty?(xs-seq)
      defmethod free (this) :
         free(xs-seq)

public defn cat<?T> (a:Seqable<?T>, b:Seqable<?T>) -> Seq<T> :
   cat-all([a, b])

public defn cat-all<?T> (xss: Seqable<Seqable<?T>>) -> Seq<T> :
   val ret-seq = generate<T> :
      for xs in xss do :
         do(yield, xs)
   val length? =
      if xss is Collection :
         if all?({_ is Lengthable&Seqable}, xss) :
            sum(seq(length{_ as Lengthable&Seqable}, xss))
   match(length?) :
      (l:Int) : take-n(l, ret-seq)
      (l:False) : ret-seq

public defn seq-cat<?T,?R> (f:T -> Seqable<?R>, xs:Seqable<?T>) -> Seq<R> :
   cat-all(seq(f, xs))

public defn seq-cat<?T,?S,?R> (f:(T,S) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   cat-all(seq(f, xs, ys))

public defn seq-cat<?T,?S,?U,?R> (f:(T,S,U) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   cat-all(seq(f, xs, ys, zs))

public defn all?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   for xs-seq in xs do-seq :
      defn* loop () :
         if empty?(xs-seq) : true
         else : pred?(next(xs-seq)) and loop()
      loop()

public defn all?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         defn* loop () :
            if empty?(xs-seq) or empty?(ys-seq) : true
            else : pred?(next(xs-seq), next(ys-seq)) and loop()
         loop()

public defn all?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            defn* loop () :
               if empty?(xs-seq) or empty?(ys-seq) or empty?(zs-seq) : true
               else : pred?(next(xs-seq), next(ys-seq), next(zs-seq)) and loop()
            loop()

public defn none?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   defn notp (x) : not pred?(x)
   all?(notp, xs)

public defn none?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   defn notp (x1, x2) : not pred?(x1, x2)
   all?(notp, xs, ys)

public defn none?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   defn notp (x1, x2, x3) : not pred?(x1, x2, x3)
   all?(notp, xs, ys, zs)

public defn any?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   not none?(pred?, xs)

public defn any?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   not none?(pred?, xs, ys)

public defn any?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   not none?(pred?, xs, ys, zs)

public defn count (xs:Seqable) -> Int :
   match(xs) :
      (xs:Seqable & Lengthable) :
         length(xs)
       (xs) :
         var accum:Int = 0
         for x in xs do :
            accum = accum + 1
         accum

public defn count<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> Int :
   var accum:Int = 0
   for x in xs do :
      if pred?(x) : accum = accum + 1
   accum

public defn join<?T,?S> (xs:Seqable<?T>, y:?S) -> Seq<T|S> :
   val ret-seq = generate<T|S> :
      val xs-seq = to-seq(xs)
      yield(next(xs-seq)) when not empty?(xs-seq)
      while not empty?(xs-seq) :
         yield(y)
         yield(next(xs-seq))
   match(xs) :
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val n* = n + max(0, n - 1)
         take-n(n*, ret-seq)
      (xs) : ret-seq

public defn reduce<?T,?S> (f: (T, S) -> ?T, x0: ?T, xs:Seqable<?S>) -> T :
   var accum = x0
   for x in xs do :
      accum = f(accum, x)
   accum

public defn reduce<?T,?S> (f: (T|S, T) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      reduce(f, next(xs-seq), xs-seq)

public defn reduce-right<?T,?S> (f: (S, T) -> ?T, xs:Seqable<?S>, xn:?T) -> T :
   for xs-seq in xs do-seq :
      defn loop () :
         if empty?(xs-seq) : xn
         else : f(next(xs-seq), loop())
      loop()

public defn reduce-right<?T,?S> (f: (T, T|S) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      defn loop (x:T) :
         if empty?(xs-seq) : x
         else : f(x, loop(next(xs-seq)))
      loop(next(xs-seq))

public defn repeat<?T> (x:?T) -> Seq<T> :
   new Seq<T> :
      defmethod next (this) : x
      defmethod peek (this) : x
      defmethod empty? (this) : false

public defn repeat<?T> (x:?T, n:Int) :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative("length", n)
   var len = n
   new Seq<T> & Lengthable :
      defmethod next (this) :
         fatal("Empty Sequence") when len == 0
         len = len - 1
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         x
      defmethod empty? (this) :
         len == 0
      defmethod length (this) :
         len

public defn repeat-while<?T> (f: () -> Maybe<?T>) -> Seq<T> :
   var item = sentinel
   defn fill () :
      if item is Sentinel :
         item = f()

   new Seq<T> :
      defmethod next (this) :
         val x = peek(this)
         item = sentinel
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         value(item as One<T>)
      defmethod empty? (this) :
         fill()
         item is None

public defn repeatedly<?T> (f:() -> ?T) -> Seq<T> :
   var item = sentinel
   defn fill () :
      if item is Sentinel :
         item = f()
   defn empty () :
      val x = item as T
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         item as T
      defmethod empty? (this) :
         false

public defn repeatedly<?T> (f:() -> ?T, n:Int) :
   take-n(n, repeatedly(f))

public defn zip<?T,?S> (xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<[T,S]> :
   for (x in xs, y in ys) seq : [x, y]

public defn zip<?T,?S,?U> (xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<[T,S,U]> :
   for (x in xs, y in ys, z in zs) seq : [x, y, z]

public defn zip-all<?T> (xs:Seqable<Seqable<?T>>) :
   val seqs = to-tuple(seq(to-seq, xs))
   fatal("No Sequences Given") when empty?(seqs)
   val ret-seq = new Seq<Tuple<T>> :
      defmethod next (this) :
         map(next, seqs)
      defmethod peek (this) :
         map(peek, seqs)
      defmethod empty? (this) :
         any?(empty?, seqs)
   if all?({_ is Lengthable&Seqable}, seqs) :
      val n = minimum(seq(length{_ as Lengthable&Seqable}, seqs))
      take-n(n, ret-seq)
   else :
      ret-seq

val UNIQUE-TABLE = HashTable<Hashable,True|False>()
val UNIQUE-LIST = Vector<Equalable>()
public defn unique<?T> (xs:Seqable<?T&Equalable>) -> List<T> :
   ;Manage Visited Set
   clear(UNIQUE-TABLE)
   clear(UNIQUE-LIST)
   defn add-to-unique-set (x:T&Equalable) :
      match(x) :
         (x:T&Equalable&Hashable) : UNIQUE-TABLE[x] = true
         (x:T&Equalable) : add(UNIQUE-LIST, x)
   defn visited? (x:T&Equalable) :
      match(x) :
         (x:T&Equalable&Hashable) : key?(UNIQUE-TABLE, x)
         (x:T&Equalable) : contains?(UNIQUE-LIST, x)

   ;Filter
   to-list $ for x in xs filter :
      if not visited?(x) :
         add-to-unique-set(x)
         true

public defn lookup?<?K,?V,?D> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable, default:?D) -> D|V :
   label<V|D> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      default

public defn lookup?<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> False|V :
   lookup?(xs, k, false)

public defn lookup<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> V :
   label<V> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      fatal("Key %~ not found in entries." % [k])

public defn parallel-seq<?T,?X,?Y> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y) -> [X,Y] :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val fco = make-co(f)
   val gco = make-co(g)

   ;Store function results
   var fresult = resume(fco, None())
   var gresult = resume(gco, None())

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         if fresult is None :
            fresult = resume(fco, v)
         if gresult is None :
            gresult = resume(gco, v)
         (fresult is None) or
         (gresult is None)
      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   [value!(fresult),
    value!(gresult)]

public defn parallel-seq<?T,?X,?Y,?Z> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y, h:Seq<T> -> ?Z) -> [X,Y,Z] :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val fco = make-co(f)
   val gco = make-co(g)
   val hco = make-co(h)

   ;Store function results
   var fresult = resume(fco, None())
   var gresult = resume(gco, None())
   var hresult = resume(hco, None())

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         if fresult is None :
            fresult = resume(fco, v)
         if gresult is None :
            gresult = resume(gco, v)
         if hresult is None :
            hresult = resume(hco, v)
         (fresult is None) or
         (gresult is None) or
         (hresult is None)
      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   [value!(fresult),
    value!(gresult),
    value!(hresult)]

public defn parallel-seq<?T,?S> (xs:Seqable<?T>, fs:Seqable<(Seq<T> -> ?S)>) -> Tuple<S> :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val cos = to-tuple(seq(make-co, fs))

   ;Store function results
   val results = to-array<Maybe<S>>(seq(resume{_, None()}, cos))

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         var more? = false
         for (co in cos, i in 0 to false) do :
            if results[i] is None :
               val r = resume(co, v)
               results[i] = r
               more? = more? or (r is None)
         more?

      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   to-tuple(seq(value!, results))

;============================================================
;==================== List Library ==========================
;============================================================

public defn* get<?T> (xs:List<?T>, i:Int) -> T :
   if i == 0 : head(xs)
   else : get(tail(xs), i - 1)

public defn headn<?T> (l:List<?T>, n:Int) -> List<T> :
   if n == 0 : List()
   else : cons(head(l), headn(tail(l), n - 1))

public defn* tailn<?T> (l:List<?T>, n:Int) -> List<T> :
   if n == 0 : l
   else : tailn(tail(l), n - 1)

public defn append<?T> (xs:Seqable<?T>, ys:List<?T>) -> List<T> :
   if empty?(ys) :
      to-list(xs)
   else :
      val items = to-vector<T>(xs)
      defn* loop (i:Int, tail:List<T>) :
         if i >= 0 : loop(i - 1, cons(items[i], tail))
         else : tail
      loop(length(items) - 1, ys)   

public defn append-all<?T> (xs:Seqable<List<?T>>) -> List<T> :
   val xs-seq = to-seq(xs)
   defn loop () :
      if empty?(xs-seq) : List()
      else : append(next(xs-seq), loop())
   loop()

public defn seq-append<?T,?R> (f: T -> List<?R>, xs:Seqable<?T>) -> List<R> :
   append-all(seq(f, xs))

public defn seq-append<?T,?S,?R> (f: (T,S) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> List<R> :
   append-all(seq(f, xs, ys))

public defn seq-append<?T,?S,?U,?R> (f: (T,S,U) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R> :
   append-all(seq(f, xs, ys, zs))

public defn map<?T,?R> (f: T -> ?R, xs:List<?T>) -> List<R> :
   if empty?(xs) : List()
   else : cons(f(head(xs)), map(f, tail(xs)))

public defn map<?T,?S,?R> (f: (T,S) -> ?R, xs:List<?T>, ys:Seqable<?S>) -> List<R> :
   to-list(seq(f, xs, ys))

public defn map<?T,?S,?U,?R> (f: (T,S,U) -> ?R, xs:List<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R> :
   to-list(seq(f, xs, ys, zs))

public defn transpose<?T> (xs:List<List<?T>>) -> List<List<T>> :
   if empty?(xs) :
      List()
   else if any?(empty?, xs) :
      List()
   else :
      val hs = map(head, xs)
      val ts = map(tail, xs)
      cons(hs, transpose(ts))

public defn last<?T> (xs:List<?T>) -> T :
   fatal("Empty List") when empty?(xs)
   defn* loop (xs:List<T>) :
      if empty?(tail(xs)) : head(xs)
      else : loop(tail(xs))
   loop(xs)

public defn but-last<?T> (xs:List<?T>) -> List<T> :
   fatal("Empty List") when empty?(xs)
   defn* loop (xs:List<T>) :
      if empty?(tail(xs)) : List()
      else : cons(head(xs), but-last(tail(xs)))
   loop(xs)

public defn reverse<?T> (xs:List<?T>) -> List<T> :
   if empty?(xs) :
      xs
   else :
      var accum = List()
      for x in xs do :
         accum = cons(x, accum)
      accum


;============================================================
;=================== String Library =========================
;============================================================

public defn matches? (a:String, start:Int, b:String) :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(a, start)
   val an = length(a)
   val bn = length(b)
   if (start + bn) <= an :
      for i in 0 to bn all? :
         a[start + i] == b[i]

public defn prefix? (s:String, prefix:String) :
   matches?(s, 0, prefix)

public defn suffix? (s:String, suffix:String) :
   val start = max(0, length(s) - length(suffix))
   matches?(s, start, suffix)

public defn empty? (s:String) :
   length(s) == 0

lostanza defn substring! (str:ref<String>, b:ref<Int>, e:ref<Int>) -> ref<String> :
   val s = b.value
   val n = e.value - s
   val ret = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      ret.chars[i] = str.chars[i + s]
   ret.chars[n] = 0 as byte
   return ret

public defn get (s:String, r:Range) -> String :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   substring!(s, b, e)

public lostanza defn append (a:ref<String>, b:ref<String>) -> ref<String> :
   val al = strlen(a)
   val bl = strlen(b)
   val n = al + bl
   val s = String(n)
   copy(s, a, 0)
   copy(s, b, al)
   s.chars[n] = 0 as byte
   return s

public lostanza defn append-all (xs:ref<Seqable<String>>) -> ref<String> :
   match(xs) :
      (xs:ref<Collection<String>>) :
         val len = sum(seq(fn(length), xs))
         val ret = String(len.value)
         val xs-seq = to-seq(xs)
         var accum : long = 0
         while empty?(xs-seq) == false :
            val s = next(xs-seq)
            copy(ret, s, accum)
            accum = accum + strlen(s)
         ret.chars[len.value] = 0 as byte
         return ret
      (xs:ref<Seqable<String>>) :
         return append-all(to-vector<String>(xs))

public defn string-join (xs:Seqable) -> String :
   val s = StringBuffer()
   print-all(s, xs)
   to-string(s)

public defn string-join (xs:Seqable, j) -> String :
   string-join(join(xs, j))

public defn index-of-char (s:String, r:Range, c:Char) -> False|Int :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   for i in b to e find :
      s[i] == c

public defn index-of-char (s:String, c:Char) -> False|Int :
   index-of-char(s, 0 to false, c)

public defn index-of-chars (a:String, r:Range, b:String) -> False|Int :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(a, r)
   val [s, e] = range-bound(a, r)
   val an = e - s
   val bn = length(b)
   if bn <= an :
      for i in s through (e - bn) find :
         matches?(a, i, b)

public defn index-of-chars (a:String, b:String) -> False|Int :
   index-of-chars(a, 0 to false, b)

public defn last-index-of-char (s:String, r:Range, c:Char) -> False|Int :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   for i in (e - 1) through b by -1 find :
      s[i] == c

public defn last-index-of-char (s:String, c:Char) -> False|Int :
   last-index-of-char(s, 0 to false, c)

public defn last-index-of-chars (a:String, r:Range, b:String) -> False|Int :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(a, r)
   val [s, e] = range-bound(a, r)
   val an = e - s
   val bn = length(b)
   if bn <= an :
      for i in (e - bn) through s by -1 find :
         matches?(a, i, b)

public defn last-index-of-chars (a:String, b:String) -> False|Int :
   last-index-of-chars(a, 0 to false, b)

public lostanza defn replace (s:ref<String>, c1:ref<Char>, c2:ref<Char>) -> ref<String> :
   val b1 = c1.value
   val b2 = c2.value
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc == b1 : r.chars[i] = b2
      else : r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public defn replace (str:String, s1:String, s2:String) -> String :
   fatal("String to be replaced cannot be empty.") when empty?(s1)
   val buf = StringBuffer(length(str))
   val n = length(str)
   val s1n = length(s1)
   defn* loop (i:Int) :
      if i < n :
         if matches?(str, i, s1) :
            print(buf, s2)
            loop(i + s1n)
         else :
            print(buf, str[i])
            loop(i + 1)
   loop(0)
   to-string(buf)

public defn split (str:String, s:String) -> Seq<String> :
   generate<String> :
      val strl = length(str)
      val sl = length(s)
      defn loop (b:Int) :
         if b < strl :
            match(index-of-chars(str, b to false, s)) :
               (i:Int) :
                  yield(str[b to i])
                  loop(i + sl)
               (i:False) :
                  yield(str[b to false])
      loop(0)

public defn split (str:String, s:String, n:Int) -> Seq<String> :
   if n <= 0 :
      fatal("Maximum number of splits (%_) is not positive." % [n])
   generate<String> :
      val strl = length(str)
      val sl = length(s)
      defn* loop (b:Int, n:Int) :
         if b < strl :
            if n > 1 :
               match(index-of-chars(str, b to false, s)) :
                  (i:Int) :
                     yield(str[b to i])
                     loop(i + sl, n - 1)
                  (i:False) :
                     yield(str[b to false])
            else :
               yield(str[b to false])
      loop(0, n)

public lostanza defn lower-case (s:ref<String>) -> ref<String> :
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc >= 'A' and sc <= 'Z' :
         r.chars[i] = sc - 'A' + 'a'
      else :
         r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public lostanza defn upper-case (s:ref<String>) -> ref<String> :
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc >= 'a' and sc <= 'z' :
         r.chars[i] = sc - 'a' + 'A'
      else :
         r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public defn trim (pred: Char -> True|False, s:String) :
   defn not-pred (c:Char) : not pred(c)
   match(index-when(not-pred, s)) :
      (i:Int) :
         val n = length(s)
         val j = for i in (n - 1) through 0 by -1 find! :
            not-pred(s[i])
         s[i through j]
      (i:False) : ""

public defn trim (s:String) -> String :
   defn whitespace? (c:Char) :
      (c == ' ') or
      (c == '\n') or
      (c == '\t') or
      (c == '\b') or
      (c == '\r')
   trim(whitespace?, s)

;============================================================
;================= String Backed Symbol =====================
;============================================================

;                       Interface
;                       =========
public defmulti name (a:Symbol) -> String
public defmulti qualified? (a:Symbol) -> True|False
public defmulti qualifier (a:Symbol) -> [False|Symbol, Symbol]

public deftype StringSymbol <: Symbol

public deftype GenSymbol <: Symbol
defmulti id (s:GenSymbol) -> Int

defmethod equal? (a:Symbol, b:Symbol) -> True|False :
   ($prim identical? a b)

;                    General Functions
;                    =================

public defn prefix? (a:Symbol, p:String) -> True|False :
   prefix?(name(a), p)

;                     Initialization
;                     ==============

var INITIALIZATION-SYMBOLS: List<Symbol>

defn initialize-pre-symbol-table () :
   INITIALIZATION-SYMBOLS = List()

defn init-symbol (str:String) :
   val sym = for s in INITIALIZATION-SYMBOLS find :
      name(s) == str
   match(sym) :
      (sym:Symbol) :
         sym
      (sym:False) :
         val sym* = StringSymbol(str)
         INITIALIZATION-SYMBOLS = cons(sym*, INITIALIZATION-SYMBOLS)
         sym*


;                    Symbol Interning
;                    ================

var INTERNED-SYMBOLS : HashTable<String,Symbol>

defn initialize-symbol-table () :
   INTERNED-SYMBOLS = HashTable<String,Symbol>()
   for s in INITIALIZATION-SYMBOLS do :
      INTERNED-SYMBOLS[name(s)] = s
   INITIALIZATION-SYMBOLS = List()

defn intern-symbol (name:String) :
   match(get?(INTERNED-SYMBOLS, name)) :
      (s:Symbol) :
         s
      (s:False) :
         val sym = StringSymbol(name)
         INTERNED-SYMBOLS[name] = sym
         sym

public defn to-symbol (x) :
   match(x) :
      (x:Symbol) : x
      (x:String) : intern-symbol(x)
      (x) : to-symbol(to-string(x))

public defn symbol-join (xs:Seqable) -> Symbol :
   to-symbol(string-join(xs))

;                    String Backed Symbol
;                    ====================

defn StringSymbol (name:String) :
   new StringSymbol :
      defmethod name (this) : name

defmethod qualified? (s:StringSymbol) :
   contains?(name(s), '/')

defmethod qualifier (s:StringSymbol) :
   match(last-index-of-char(name(s), '/')) :
      (i:Int) :
         val part1 = intern-symbol(name(s)[0 to i])
         val part2 = intern-symbol(name(s)[(i + 1) to false])
         [part1, part2]
      (i:False) :
         [false, s]

defmethod hash (s:StringSymbol) :
   hash(name(s))

defmethod print (o:OutputStream, s:StringSymbol) :
   print(o, name(s))

defmethod to-string (s:StringSymbol) :
   name(s)

defmethod write (o:OutputStream, s:StringSymbol) :
   if symbol-needs-escape?(name(s)) :
      print(o, "\\|")
      for c in name(s) do :
         escape-for-symbol(o, c)
      print(o, '|')
   else :
      print(o, name(s))

;                       Generated Symbol
;                       ================

defn GenSymbol (name:String) :
   defn make-sym (name:String) :
      val id = genid()
      new GenSymbol :
         defmethod id (this) : id
         defmethod name (this) : name
         defmethod qualified? (this) : false
         defmethod qualifier (this) : [false, this]

   match(last-index-of-char(name, '/')) :
      (i:Int) :
         val id = genid()
         val qualifier = intern-symbol(name[0 to i])
         val unqualified-sym = make-sym(name[(i + 1) to false])
         new GenSymbol :
            defmethod id (this) : id
            defmethod name (this) : name
            defmethod qualified? (this) : true
            defmethod qualifier (this) : [qualifier, unqualified-sym]
      (i:False) :
         make-sym(name)

val ID-COUNTER = to-seq(0 to false)

public defn gensym (x) :
   match(x) :
      (x:Symbol) : gensym(name(x))
      (s:String) : GenSymbol(s)
      (x) : gensym(to-string(x))

public defn gensym () :
   gensym("$gen")

public defn genid () :
   next(ID-COUNTER)

defmethod hash (s:GenSymbol) :
   id(s)

defmethod print (o:OutputStream, s:GenSymbol) :
   print(o, name(s))
   print(o, id(s))

defmethod write (o:OutputStream, s:GenSymbol) :
   if symbol-needs-escape?(name(s)) :
      print(o, "\\|")
      for c in name(s) do :
         escape-for-symbol(o, c)
      print(o, id(s))
      print(o, '|')
   else :
      print(o, name(s))
      print(o, id(s))

;============================================================
;===================== Id Pool ==============================
;============================================================

val ID-SEQ = to-seq(0 to false)
val FREE-IDS = Vector<Int>()
val OBJ-MAP = Vector<?>()

public lostanza defn box-object (x:ref<?>) -> int :
   var id:ref<Int>
   if empty?(FREE-IDS) == true : id = next(ID-SEQ)
   else : id = pop(FREE-IDS)
   set(OBJ-MAP, id, x)
   return id.value

public lostanza defn free-box (id:int) -> ref<False> :
   add(FREE-IDS, new Int{id})
   set(OBJ-MAP, new Int{id}, false)
   return false

public lostanza defn boxed-object (id:int) -> ref<?> :
   return get(OBJ-MAP, new Int{id})

;============================================================
;==================== Resources =============================
;============================================================

public deftype Resource
public defmulti free (r:Resource) -> False

protected defn with-resource<?T,?S> (f:T -> ?S, x:?T&Resource) -> S :
   try : f(x)
   finally : free(x)

;============================================================
;==================== Autofree ==============================
;============================================================

lostanza deftype FreeCallback :
   c-convention:int
   free:ptr<(ptr<?> -> int)>
   value:ptr<?>

lostanza defn free (c:ref<FreeCallback>) -> ref<False> :
   if c.c-convention :
      call-c [c.free](c.value)
   else :
      [c.free](c.value)
   return false

public lostanza defn c-autofree-marker (free:ptr<(ptr<?> -> int)>, value:ptr<?>) -> ref<LivenessMarker> :
   val t = LivenessTracker(new FreeCallback{1, free, value})
   add(FREE-CALLBACKS, t)
   return marker!(t)

public lostanza defn autofree-marker (free:ptr<(ptr<?> -> int)>, value:ptr<?>) -> ref<LivenessMarker> :
   val t = LivenessTracker(new FreeCallback{0, free, value})
   add(FREE-CALLBACKS, t)
   return marker!(t)

val FREE-CALLBACKS = Vector<LivenessTracker<FreeCallback>>()
add-gc-notifier $ fn () :
   for t in FREE-CALLBACKS remove-when :
      if marker(t) is False :
         free(value(t))
         true

;============================================================
;=================== Pretty Printer =========================
;============================================================

;                  General Interface
;                  =================

public defmulti write (o:OutputStream, x) -> False

;                Default Implementation
;                ======================

defmethod write (o:OutputStream, x) :
   print(o, x)

public defn write-all (o:OutputStream, xs:Seqable) -> False :
   val xs-seq = to-seq(xs)
   if not empty?(xs-seq) :
      write(o, next(xs-seq))
   while not empty?(xs-seq) :
      print(o, " ")
      write(o, next(xs-seq))

;                    Escape Sequences
;                    ================

defn general-escape (o:OutputStream, c:Char) :
   defn escape (c:Char) :
      print(o, '\\')
      print(o, c)
   switch {c == _} :
      '\t' : escape('t')
      '\b' : escape('b')
      '\r' : escape('r')
      '\n' : escape('n')
      '\\' : escape('\\')
      else : print(o, c)

defn escape-for-string (o:OutputStream, c:Char) :
   if c == '\"' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

defn escape-for-symbol (o:OutputStream, c:Char) :
   if c == '|' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

defn escape-for-char (o:OutputStream, c:Char) :
   if c == '\'' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

;              Determination Whether Symbol Requires Escape
;              ============================================

lostanza var SYMBOL-CHARS:ref<String>
lostanza var OPERATOR-CHARS:ref<String>

lostanza defn tag-char (table:ref<String>, c:byte) -> int :
   table.chars[c] = 1 as byte
   return 0

lostanza defn tag-chars (table:ref<String>, cs:ptr<byte>) -> int :
   for (var i:long = 0, 1, i = i + 1) :
      val c = cs[i]
      if c == 0 : return 0
      tag-char(table, c)
   fatal("Unreachable")
   return 0

lostanza :
   SYMBOL-CHARS = String(256, 0 as byte)
   OPERATOR-CHARS = String(256, 0 as byte)

   tag-chars(SYMBOL-CHARS, "0123456789")
   tag-chars(SYMBOL-CHARS, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
   tag-chars(SYMBOL-CHARS, "_?")
   tag-chars(SYMBOL-CHARS, "~!@#$%^*+-=/")

   tag-chars(OPERATOR-CHARS, "~!@#$%^*+-=/")
   tag-chars(OPERATOR-CHARS, ".:<>&|")

lostanza defn symbol-char? (c:ref<Char>) -> ref<True|False> :
   if SYMBOL-CHARS.chars[c.value] == 0 : return false
   else : return true

lostanza defn operator-char? (c:ref<Char>) -> ref<True|False> :
   if OPERATOR-CHARS.chars[c.value] == 0 : return false
   else : return true

defn symbol-needs-escape? (str:String) :
   if empty?(str) : true
   else if digit?(str[0]) : true
   else if length(str) >= 2 and str[0] == '-' and digit?(str[1]) : true
   else if all?(symbol-char?, str) : false
   else if all?(operator-char?, str) : false
   else : true

;                  Escaped Primitive Values
;                  ========================

defmethod write (o:OutputStream, c:Char) :
   print(o, '\'')
   escape-for-char(o, c)
   print(o, '\'')

defmethod write (o:OutputStream, s:String) :
   print(o, '"')
   for c in s do :
      escape-for-string(o, c)
   print(o, '"')

defmethod write (o:OutputStream, x:Byte) :
   print(o, x)
   print(o, 'Y')

defmethod write (o:OutputStream, x:Long) :
   print(o, x)
   print(o, 'L')

defmethod write (o:OutputStream, b:Float) :
   print(o, b)
   print(o, 'F')

;============================================================
;===================== Timers ===============================
;============================================================

public lostanza defn current-time-ms () -> ref<Long> :
   val ms = call-c clib/current_time_ms()
   return new Long{ms}

public lostanza defn current-time-us () -> ref<Long> :
   val us = call-c clib/current_time_us()
   return new Long{us}

public deftype Timer
public defmulti start (t:Timer) -> False
public defmulti stop (t:Timer) -> False
public defmulti time (t:Timer) -> Long

defn Timer (name:String, get-time: () -> Long) :
   var total-time:Long = 0L
   var last-time:Long = 0L
   var running = false
   new Timer :
      defmethod start (this) :
         fatal("Timer already running.") when running
         last-time = get-time()
         running = true
      defmethod stop (this) :
         fatal("Timer is not running.") when not running
         val time = get-time()
         total-time = total-time + time - last-time
         last-time = time
         running = false
      defmethod time (this) :
         if running : total-time + get-time() - last-time
         else : total-time
      defmethod print (o:OutputStream, this) :
         print(o, "[%_ Timer : %_]" % [name, time(this)])

public defn MillisecondTimer (name:String) :
   Timer(name, current-time-ms)

public defn MicrosecondTimer (name:String) :
   Timer(name, current-time-us)

public defn PiggybackTimer (name:String, t:Timer) :
   Timer(name, time{t})


;############################################################
;################## Math Package ############################
;############################################################

defpackage math :
   import core

public lostanza val PI:ref<Double> = new Double{3.141592653589793}
public lostanza val PI-F:ref<Float> = new Float{3.1415927f}

public lostanza defn exp (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/exp(x.value)}
public lostanza defn exp (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/exp(x.value) as float}

public lostanza defn log (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/log(x.value)}
public lostanza defn log (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/log(x.value) as float}

public lostanza defn log10 (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/log10(x.value)}
public lostanza defn log10 (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/log10(x.value) as float}

public lostanza defn sqrt (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sqrt(x.value)}
public lostanza defn sqrt (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sqrt(x.value) as float}

public lostanza defn pow (x:ref<Double>, y:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/pow(x.value, y.value)}
public lostanza defn pow (x:ref<Float>, y:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/pow(x.value, y.value) as float}

public lostanza defn sin (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sin(x.value)}
public lostanza defn sin (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sin(x.value) as float}

public lostanza defn cos (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/cos(x.value)}
public lostanza defn cos (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/cos(x.value) as float}

public lostanza defn tan (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/tan(x.value)}
public lostanza defn tan (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/tan(x.value) as float}

public lostanza defn asin (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/asin(x.value)}
public lostanza defn asin (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/asin(x.value) as float}

public lostanza defn acos (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/acos(x.value)}
public lostanza defn acos (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/acos(x.value) as float}

public lostanza defn atan (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/atan(x.value)}
public lostanza defn atan (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/atan(x.value) as float}

public lostanza defn atan2 (y:ref<Double>, x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/atan2(y.value, x.value)}
public lostanza defn atan2 (y:ref<Float>, x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/atan2(y.value, x.value) as float}

public lostanza defn sinh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sinh(x.value)}
public lostanza defn sinh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sinh(x.value) as float}

public lostanza defn cosh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/cosh(x.value)}
public lostanza defn cosh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/cosh(x.value) as float}

public lostanza defn tanh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/tanh(x.value)}
public lostanza defn tanh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/tanh(x.value) as float}

public lostanza defn ceil (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/ceil(x.value)}
public lostanza defn ceil (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/ceil(x.value) as float}

public lostanza defn floor (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/floor(x.value)}
public lostanza defn floor (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/floor(x.value) as float}

public lostanza defn round (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/round(x.value)}
public lostanza defn round (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/round(x.value) as float}

public lostanza defn to-radians (degrees:ref<Double>) -> ref<Double> :
   val pi = 3.141592653589793
   return new Double{degrees.value * pi / 180.0}

public lostanza defn to-degrees (radians:ref<Double>) -> ref<Double> :
   val pi = 3.141592653589793
   return new Double{radians.value * 180.0 / pi}