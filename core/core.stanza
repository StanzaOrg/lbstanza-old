defpackage clib

protected extern remove: (ptr<byte>) -> int
protected extern fclose: (ptr<?>) -> int
protected extern fopen: (ptr<byte>, ptr<byte>) -> ptr<?>
protected extern fputs: (ptr<byte>, ptr<?>) -> int
protected extern fputc: (byte, ptr<?>) -> int
protected extern fgetc: (ptr<?>) -> int
protected extern ferror: (ptr<?>) -> int
protected extern fprintf: (ptr<?>, ptr<byte>, ? ...) -> int
protected extern sprintf: (ptr<byte>, ptr<byte>, ? ...) -> int
protected extern sscanf: (ptr<byte>, ptr<byte>, ptr<?> ...) -> int
protected extern printf: (ptr<byte>, ? ...) -> int
protected extern malloc: long -> ptr<?>
protected extern free: ptr<?> -> int
protected extern exit: int -> int
protected extern get_stdout: () -> ptr<?>
protected extern get_stderr: () -> ptr<?>
protected extern get_eof: () -> int
protected extern rand: () -> int
protected extern input_argc: int
protected extern input_argv: ptr<ptr<byte>>
protected extern strlen: ptr<byte> -> int
protected extern current_time_us: () -> long
protected extern current_time_ms: () -> long
protected extern get_PATH_MAX: () -> int
protected extern realpath: (ptr<byte>, ptr<byte>) -> ptr<byte>
protected extern getenv: (ptr<byte>) -> ptr<byte>
protected extern setenv: (ptr<byte>, ptr<byte>, int) -> int
protected extern system: (ptr<byte>) -> int
protected extern strerror: (int) -> ptr<byte>
protected extern get_errno: () -> int

defpackage core :
   import collections

;============================================================
;================== Core Types ==============================
;============================================================

public :
   deftype Seqable<T>                   
   deftype Seq<T> <: Seqable<T>         
   deftype Collection<T> <: Seqable<T>        

   deftype Lengthable                   

   deftype Equalable                       

   deftype Hashable                     

   deftype Comparable<T>                

   deftype OutputStream                 

   lostanza deftype FileOutputStream <: OutputStream :   
      file: ptr<?>
      closable?: long

   deftype InputStream <: Seq<Char>
   deftype FileInputStream <: InputStream
   deftype StringInputStream <: InputStream & Lengthable

   deftype Maybe<T> <: Equalable & Comparable<Maybe<T>>           
   deftype None <: Maybe<Void>
   deftype One<T> <: Maybe<T>

   deftype Coroutine<I,O> <: Equalable     

   deftype Range <: Collection<Int> & Equalable  

   lostanza deftype Byte <: Equalable & Hashable & Comparable<Byte> :   
      value: byte

   lostanza deftype Char <: Equalable & Hashable & Comparable<Char> :   
      value: byte

   lostanza deftype Int <: Equalable & Hashable & Comparable<Int> :      
      value: int

   lostanza deftype Long <: Equalable & Hashable & Comparable<Long> :    
      value: long

   lostanza deftype Float <: Equalable & Hashable & Comparable<Float> :   
      value: float

   lostanza deftype Double <: Equalable & Hashable & Comparable<Double> :  
      value: double

   lostanza deftype String <: Lengthable & Collection<Char> & Equalable & Hashable & Comparable<String> : 
      length: long
      hash: int
      chars: byte ...

   deftype Symbol <: Equalable & Hashable

   deftype List<T> <: Lengthable & Collection<T> & Equalable & Hashable & Comparable<List<T>>   
   lostanza deftype FullList<T> <: List<T> :
      head: ref<T>
      tail: ref<List<T>>
   lostanza deftype NilList <: List<Void>

   lostanza deftype True <: Equalable      
   lostanza deftype False <: Equalable

   lostanza deftype Tuple<T> <: Lengthable & Collection<T> & Equalable & Hashable & Comparable<Tuple<T>> : 
      length: long
      items: ref<T> ...

   deftype IndexedCollection<T> <: Lengthable & Collection<T>
   
   deftype Array<T> <: IndexedCollection<T> & Equalable  

   lostanza deftype CharArray <: Array<Char> :    
      length: long
      chars: byte ...

   lostanza deftype LivenessMarker :
      id: long

   lostanza deftype LivenessTracker<T> :
      marker: ref<False|Sentinel|LivenessMarker>
      value: ref<T>
      next: ref<False|LivenessTracker>

   deftype StringBuffer <: IndexedCollection<Char> & OutputStream     

   deftype FileInfo <: Equalable & Hashable & Comparable<FileInfo>  

   deftype Token <: Equalable 

   deftype KeyValue<K,V> 

   deftype Exception  

   ;System File/Dir Handling
   ;Command Prompt Execution
   ;Slices

;============================================================
;================ Internal Types ============================
;============================================================

lostanza deftype Fn :
   code: ptr<?>
   free: ref<?> ...
lostanza deftype Box :
   item: ref<?>
lostanza deftype Type :
   code: ptr<?>
   free: ref<?> ...
lostanza deftype Stack :
   position: int
   mark: int
   parent: ref<False|Stack>
   sp: ptr<?>
   frames: StackFrame ...
lostanza deftype StackFrame :
   ret: ptr<?>
   map: ptr<RefMap>
   items: long ...
lostanza deftype RefMap :
   length: long
   bits: long ...
lostanza deftype FileInfoTable :
   length: long
   entries: FileInfoEntry ...
lostanza deftype FileInfoEntry :
   lbl: ptr<?>
   file: ptr<byte>
   line: int
   column: int

;============================================================
;============== Standard Streams ============================
;============================================================

lostanza val stdout:ptr<?> = call-c clib/get_stdout()
lostanza val stderr:ptr<?> = call-c clib/get_stderr()
lostanza val EOF:int = call-c clib/get_eof()

;============================================================
;=============== Initialization Phase 0 =====================
;============================================================

;                  Stack Initialization
;                  ====================

extern stanza_stack_size: long
lostanza var num-stacks:long = 1024

lostanza defn parent (s:ref<Stack>) -> ref<Stack> :
   return s.parent as ref<Stack>

lostanza defn initialize-stacks () -> int :
   ;Create stack pool
   val pool:ptr<ref<Stack>> = call-c clib/malloc(sizeof(ref<?>) * num-stacks)
   for (var i:int = 1, i < num-stacks, i = i + 1) :
      val p:ptr<long> = call-c clib/malloc(stanza_stack_size)
      [p] = tagof(Stack) << 3
      val s = (p + 1) as ref<Stack>
      s.position = i << 3
      s.mark = 0
      pool[i] = s

   ;Initialize current stack
   val s = call-prim stack()
   val p = (addr!([s]) - 8) as ptr<long>
   [p] = tagof(Stack) << 3
   s.position = 0
   s.mark = 0
   s.parent = false
   pool[0] = s

   ;Tell Stanza about stack pool
   call-prim set-num-free-stacks(num-stacks - 1)
   call-prim set-free-stacks(addr(pool[1]))
   call-prim set-stack-pool(pool)

   return 0

;                 Heap Initialization
;                 ===================

lostanza var mem-size:long
lostanza var max-mem-size:long
lostanza var heap-mem:ptr<long>
lostanza var free-mem:ptr<long>
lostanza var free-ptr:ptr<long>

lostanza defn initialize-heaps () -> int :
   mem-size = 1024 * 1024
   max-mem-size = (4 as long) * 1024 * 1024 * 1024
   heap-mem = call-c clib/malloc(mem-size)
   free-mem = call-c clib/malloc(mem-size)
   call-prim set-heap(heap-mem)
   call-prim set-heap-limit(heap-mem + mem-size)
   return 0

;                    Driver
;                    ======

lostanza defn initialize-phase0 () -> int :
   initialize-stacks()
   initialize-heaps()
   return 0

lostanza: initialize-phase0()

;============================================================
;============== Generated Entry Points ======================
;============================================================

lostanza defn cast-error () -> ref<Void> :
   return fatal("Cannot cast value to type.", call-prim sp())

lostanza defn arity-error () -> ref<Void> :
   return fatal("Wrong number of arguments.", call-prim sp())

lostanza defn no-branch-error () -> ref<Void> :
   return fatal("No matching branch.", call-prim sp())

lostanza defn amb-branch-error () -> ref<Void> :
   return fatal("Ambiguous branch.", call-prim sp())

lostanza defn variable-uninitialized-error () -> ref<Void> :
   return fatal("Variable is uninitialized.", call-prim sp())

lostanza defn tuple-length-error () -> ref<Void> :
   return fatal("Tuple has wrong arity for detupling.", call-prim sp())

;============================================================
;================== Stack Traces ============================
;============================================================

lostanza var trace-buffer:ptr<ptr<FileInfoEntry>>
lostanza var trace-size:int
lostanza val null:ptr<?> = 0 as long as ptr<?>

lostanza defn print-stack-trace (end:ptr<?>) -> ref<False> :
   ;Allocate space for storing trace
   ;No trace can be larger than the size of a stack
   trace-buffer = call-c clib/malloc(stanza_stack_size)

   ;Print trace starting from current stack
   print-stack-trace(call-prim stack(), end)

   ;Free trace buffer and return
   call-c clib/free(trace-buffer)
   return false

lostanza defn* print-stack-trace (s:ref<Stack>, end:ptr<?>) -> int :
   ;Store trace into buffer
   trace-size = 0
   val f0 = addr!(s.frames) + frame-size(addr!(s.frames)) ;Skip intercepted return frame
   store-stack-trace(f0, end)

   ;Print out trace
   for (var i:int = trace-size - 1, i >= 0, i = i - 1) :
      val e = trace-buffer[i]
      if e == null :
         call-c clib/fprintf(stderr, "   at [Unknown Source Location]\n")
      else :
         call-c clib/fprintf(stderr, "   at %s:%d.%d\n", e.file, e.line, e.column)

   ;Print parent stack trace
   match(s.parent) :
      (p:ref<Stack>) : return print-stack-trace(p, p.sp)
      (p:ref<False>) : return 0

lostanza defn* store-stack-trace (stacks:ptr<StackFrame>, end:ptr<?>) -> int :
   ;Store the return address into trace buffer
   trace-buffer[trace-size] = info-entry(stacks.ret)
   trace-size = trace-size + 1

   ;Continue tracing next frame unless end is reached.
   if stacks == end :
      return 0
   else :
      val sz = frame-size(stacks)
      return store-stack-trace(stacks + sz, end)

lostanza defn frame-size (s:ptr<StackFrame>) -> long :
   val map = s.map
   return sizeof(StackFrame) + s.map.length * sizeof(long)

lostanza defn info-entry (p:ptr<?>) -> ptr<FileInfoEntry> :
   val table = call-prim info-table() as ptr<FileInfoTable>
   for (var i:long = 0, i < table.length, i = i + 1) :
      val e = table.entries[i]
      if e.lbl == p :
         return addr(table.entries[i])
   return null

;============================================================
;===================== Errors ===============================
;============================================================

public lostanza defn* fatal (msg: ptr<byte>) -> ref<Void> :
   return fatal(msg, call-prim sp())

lostanza defn fatal (msg: ptr<byte>, sp:ptr<?>) -> ref<Void> :
   call-c clib/fprintf(stderr, "FATAL ERROR: %s\n", msg)
   print-stack-trace(sp)
   call-c clib/exit(-1)
   return null as ref<Void>

;============================================================
;=============== Garbage Collector ==========================
;============================================================

;              Generated Entry Points
;              ======================

;Called when attempting to allocate beyond the heap limit.
lostanza defn extend-heap (sz:long) -> int :
   if gc-running :
      fatal("Heap access within garbage collector")
   else :   
      new-stack<int>{run-garbage-collector()}
      val new-size = enlarged-size(sz)
      if new-size < 0 : fatal("Out of Memory", call-prim sp())
      else if new-size != mem-size : enlarge-heap(new-size)      
   return 0

lostanza defn enlarged-size (sz:long) -> long :
   ;Case 1: Out of memory
   val min-mem-size = call-prim heap() + sz - heap-mem
   if min-mem-size > max-mem-size :
      return -1

   ;Case 2: Safe mem size
   val safe-mem-size = mem-size >>> 1
   if min-mem-size <= safe-mem-size :
      return mem-size

   ;Case 3: Enlarged size
   var new-size:long = mem-size * 2
   while new-size < min-mem-size :
      new-size = new-size * 2
   return min(new-size, max-mem-size)

lostanza defn min (a:long, b:long) -> long :
   if a < b : return a
   else : return b      

lostanza defn enlarge-heap (size:long) -> int :
   ;Set new size
   mem-size = size
      
   ;Enlarge freespace   
   call-c clib/free(free-mem)
   free-mem = call-c clib/malloc(mem-size)

   ;Copy to enlarged freespace
   new-stack<int>{run-garbage-collector()}

   ;Enlarge the new freespace to match the new heapspace
   call-c clib/free(free-mem)
   free-mem = call-c clib/malloc(mem-size)
   return 0

;Called when the number of free stacks is 2 or less.
;Running extend-stack uses two stacks (1 for GC, 1 for handling extend-stack during GC).
lostanza var extending-stack:long = 0
lostanza defn extend-stack () -> int :
   if gc-running :
      fatal("Stack overflow in garbage collector")
   else if extending-stack == 0 :
      extending-stack = 1
      new-stack<int>{run-garbage-collector()}
      if call-prim num-free-stacks() <= 2 :
         fatal("Stack overflow", call-prim sp())
      extending-stack = 0
      
   ;Return   
   return 0

;                   Main Function
;                   =============

;Main function for garbage collector
lostanza var gc-running:long = 0
lostanza var tracker-chain:ref<False|LivenessTracker>
lostanza defn run-garbage-collector () -> int :   
   ;Mark GC as running to detect stack extension within GC
   gc-running = 1

   ;Initialize free pointer to point to beginning of free memory before copying starts.
   free-ptr = free-mem

   ;Initialize tracker chain
   tracker-chain = false

   ;Current stack is the collection stack, the stack that the GC runs in.
   ;Set its mark bit to indicate that it should not be scanned.
   ;Make sure the top stack of the current-coroutine is up-to-date
   val current-stack = call-prim stack()
   current-coroutine.top = current-stack
   current-stack.mark = 1

   ;Scan roots
   scan-globals()
   scan-stack(parent(current-stack))

   ;Scan internal pointers of all heap objects
   scan-heap()

   ;Scan liveness trackers
   tracker-chain = scan-trackers(tracker-chain)

   ;Swap free memory with heap
   val swap = heap-mem
   heap-mem = free-mem
   free-mem = swap
   call-prim set-heap(free-ptr)
   call-prim set-heap-limit(heap-mem + mem-size)

   ;All active stacks have their mark bits set.
   free-unmarked-stacks()

   ;Finish
   gc-running = 0
   return 0

;                Liveness Trackers
;                =================

lostanza defn scan-liveness-tracker (p:ptr<long>) -> ptr<long> :
   p[2] = post-gc-object(p[2])
   p[3] = tracker-chain as long
   tracker-chain = (p + 1) as ref<LivenessTracker>
   return p + 8 + sizeof(LivenessTracker)

lostanza defn post-gc-marker (marker:ref<False|Sentinel|LivenessMarker>) -> ref<False|Sentinel|LivenessMarker> :
   if (marker == false) or (marker == sentinel) :
      return marker
   else :
      val p = (marker as ptr<long>) - 1
      if p[0] == -1 : return p[1] as ref<LivenessMarker>
      else : return false

lostanza defn* scan-trackers (tracker:ref<False|LivenessTracker>) -> ref<False> :
   match(tracker) :
      (tracker:ref<LivenessTracker>) :
         tracker.marker = post-gc-marker(tracker.marker)
         return scan-trackers(tracker.next)
      (tracker:ref<False>) :
         return false

;                 Scanning Functions
;                 ==================

;Copy all global references to the free memory.
lostanza defn scan-globals () -> int :
   ;Get tables
   val globals = call-prim globals() as ptr<long>
   val map = call-prim global-map() as ptr<RefMap>
   ;Scan globals
   scan-map-words(addr(map.bits), map.length, globals)
   return 0

;Copy all stack references in this and parent stacks to free memory.
lostanza defn* scan-stack (s:ref<Stack>) -> int :
   if s.mark == 0 :
      s.mark = 1
      scan-stack-frames(addr!(s.frames), s.sp)
      match(s.parent) :
         (p:ref<Stack>) : return scan-stack(p)
         (p:ref<False>) : return 0
   else :
      return 0

;Copy all internal references in heap to free memory.
lostanza defn scan-heap () -> int :
   var p: ptr<long> = free-mem
   while p < free-ptr :
      val tagword = p[0]
      val tagbits = tagword & 7
      if tagbits == 0 :
         val tag = tagword >>> 3
         if tag == tagof(LivenessTracker) :
            p = scan-liveness-tracker(p)            
         else :
            p = scan-object(p)
      else if tagbits == 1 :
         p = scan-array(p)
      else :
         call-c clib/fprintf(stderr, "Invalid tag bits in heap: %lx\n", tagbits)
         call-c clib/exit(-1)
         return 0
   return 0

;Copy all internal references in object to free memory.
lostanza defn scan-object (p:ptr<long>) -> ptr<long> :
   ;p is [tag-word, cells ...]
   val tag = p[0] >>> 3
   val map = object-map(tag)
   scan-map-words(base-bits(map), base-nwords(map), p + 8)
   return p + 8 + map.base-size

;Copy all internal references in array to free memory.
lostanza defn scan-array (p:ptr<long>) -> ptr<long> :
   ;p is [len-word, tag-word, cells ...]
   val len = p[0] >>> 3
   val tag = p[1] >>> 3

   ;Calculate the total size of object, rounding up to nearest 8 bytes
   val map = object-map(tag)
   val bytes = ((map.base-size + map.tail-size * len) + 7) & -8

   ;Scan base of array
   scan-map-words(base-bits(map), base-nwords(map), p + 16)

   ;Scan tail of array if it contains references.
   if tail-refs?(map) :
      var tail:ptr<long> = p + 16 + map.base-size
      val tbits = tail-bits(map)
      val tnwords = tail-nwords(map)
      for (var i:long = 0, i < len, i = i + 1) :
         scan-map-words(tbits, tnwords, tail)
         tail = tail + map.tail-size

   ;Return end of array
   return p + 16 + bytes

;Copy all internal references in stack frames, fs, until end pointer
lostanza defn* scan-stack-frames (fs:ptr<StackFrame>, end:ptr<?>) -> int :
   if fs < end :
      val map = fs.map
      scan-map-words(addr(map.bits), map.length, addr(fs.items))
      val next-fs = addr(fs.items[map.length]) as ptr<StackFrame>
      return scan-stack-frames(next-fs, end)
   else :
      return 0

;Scan n references (marked with a 1 bit) from the given pointer
lostanza defn* scan-map-words (map:ptr<long>, n:long, refs:ptr<long>) -> int :
   if n > 64 :
      scan-map-word([map], 64, refs)
      return scan-map-words(addr(map[1]), n - 64, addr(refs[64]))
   else if n > 0 :
      scan-map-word([map], n, refs)
      return 0
   else :
      return 0

lostanza defn scan-map-word (map:long, n:long, refs:ptr<long>) -> int :
   var ref-ptr:ptr<long> = refs
   for (var i:long = 0, i < n, i = i + 1) :
      val b = (map >> i) & 1
      if b : [ref-ptr] = post-gc-object([ref-ptr])
      ref-ptr = ref-ptr + sizeof(long)
   return 0

;                Copying Functions
;                =================

lostanza defn post-gc-object (obj:long) -> long :
   val tagbits = obj & 7
   if tagbits == 1 :
      val obj-ptr = (obj - tagbits) as ptr<long>
      val tag = obj-ptr[0] >>> 3

      ;If broken heart, then return forwarding pointer
      if tag == -1 :
         return obj-ptr[1]
      ;Otherwise, copy object
      else :
         val map = object-map(tag)
         if tag == tagof(Stack) :
            scan-stack(obj as ref<Stack>)
            return obj
         else if finite?(map) :
            val obj* = copy-object-to-free(obj-ptr, map.base-size) + tagbits
            set-broken-heart(obj-ptr, obj*)
            return obj*
         else :
            val obj* = copy-array-to-free(obj-ptr, map.base-size, map.tail-size) + tagbits
            set-broken-heart(obj-ptr, obj*)
            return obj*
   else :
      return obj

lostanza defn set-broken-heart (old:ptr<long>, new-obj:long) -> int :
   old[0] = -1
   old[1] = new-obj
   return 0

lostanza defn copy-object-to-free (obj:ptr<long>, size:long) -> long :
   val ret = free-ptr
   copy-bytes-to-free(obj, size + 8)
   return ret as long

lostanza defn copy-array-to-free (obj:ptr<long>, size:long, tail:long) -> long :
   ;obj: [len, tag, items ...]
   ;Returned pointer points to the tag word
   val ret = free-ptr + 8
   val length = obj[-1] >>> 3

   ;Calculate the total size of object, rounding up to nearest 8 bytes
   val bytes = ((size + tail * length) + 7) & -8

   ;Copy the bytes to free including header
   copy-bytes-to-free(obj - 8, bytes + 16)

   return ret as long

lostanza defn copy-bytes-to-free (p:ptr<long>, n:long) -> int :
   val nwords = n >>> 3
   for (var i:long = 0, i < nwords, i = i + 1) :
      free-ptr[i] = p[i]
   free-ptr = free-ptr + n
   return 0

;               Utilities for ObjectMap
;               =======================

lostanza deftype ObjectMap :
   base-size: int
   tail-size: int
   bits: long ...

lostanza defn object-map (tag:long) -> ptr<ObjectMap> :
   val table = call-prim object-table() as ptr<ptr<ObjectMap>>
   return table[tag]

lostanza defn finite? (m:ptr<ObjectMap>) -> long :
   return m.tail-size == 0

lostanza defn base-bits (m:ptr<ObjectMap>) -> ptr<long> :
   return addr(m.bits)

lostanza defn base-nwords (m:ptr<ObjectMap>) -> long :
   return m.base-size >>> 3

lostanza defn tail-bits (m:ptr<ObjectMap>) -> ptr<long> :
   return addr(m.bits[base-nwords(m)])

lostanza defn tail-nwords (m:ptr<ObjectMap>) -> long :
   return m.tail-size >>> 3

lostanza defn tail-refs? (m:ptr<ObjectMap>) -> long :
   val n = tail-nwords(m)
   val bits = tail-bits(m)
   for (var i:long = 0, i < n, i = i + 1) :
      if bits[i] != 0 :
         return 1
   return 0

;                  Releasing Stacks
;                  ================

;Free an active stack, and add back to the free stack list.
lostanza defn free-stack (s:ref<Stack>) -> long :
   ;Ensure s is the last active stack
   val stk-pool = call-prim stack-pool()
   val last-stk = (call-prim free-stacks())[-1]
   if s != last-stk :
      ;Swap locations of last-stk with s
      [stk-pool + s.position] = last-stk
      [stk-pool + last-stk.position] = s
      ;Swap positions of last-stk with s
      val s-position = s.position
      s.position = last-stk.position
      last-stk.position = s-position
   ;Free last active stack
   call-prim set-num-free-stacks(call-prim num-free-stacks() + 1)
   call-prim set-free-stacks(call-prim free-stacks() - 8)
   return 0

;Free all unmarked stacks.
lostanza defn free-unmarked-stacks () -> int :
   var stk-ptr:ptr<ref<Stack>> = call-prim stack-pool()
   while stk-ptr < call-prim free-stacks() :
      val s = [stk-ptr]
      if s.mark == 0 :
         free-stack(s)
      else :
         stk-ptr = stk-ptr + 8
      s.mark = 0
   return 0

;============================================================
;===================== Winders ==============================
;============================================================

defn fn-cons-0 (a: False|(() -> ?), b: False|(() -> ?)) -> False|(() -> ?) :
   match(a, b) :
      (a:False, b) : b
      (a, b:False) : a
      (a:() -> ?, b:() -> ?) : fn* () : (a(), b())

defn fn-cons-1 (a: False|(? -> ?), b: False|(? -> ?)) -> False|(? -> ?) :
   match(a, b) :
      (a:False, b) : b
      (a, b:False) : a
      (a:? -> ?, b:? -> ?) : fn* (x) : (a(x), b(x))

defn* call-if-function (f: False|(() -> ?)) :
   match(f) :
      (f:() -> ?) : f()
      (f:False) : false

defn* call-if-function (f: False|(? -> ?), x: ?) :
   match(f) :
      (f:? -> ?) : f(x)
      (f:False) : false

public lostanza defn dynamic-wind<?T> (in:ref<False|(() -> ?)>,
                                       body:ref<(() -> ?T)>,
                                       out:ref<False|(? -> ?)>) -> ref<T> :
   call-if-function(in)
   val w-in = current-coroutine.windin
   val w-out = current-coroutine.windout
   current-coroutine.windin = fn-cons-0(w-in, in)
   current-coroutine.windout = fn-cons-1(out, w-out)
   val result = [body]()
   current-coroutine.windin = w-in
   current-coroutine.windout = w-out
   call-if-function(out, true)
   return result

lostanza defn windin (c:ref<RawCoroutine>) -> ref<False|(() -> ?)> :
   match(c.parent) :
      (p:ref<RawCoroutine>) : return fn-cons-0(c.windin, windin(p))
      (p:ref<False>) : return c.windin

lostanza defn windout (c:ref<RawCoroutine>) -> ref<False|(? -> ?)> :
   match(c.parent) :
      (p:ref<RawCoroutine>) : return fn-cons-1(windout(p), c.windout)
      (p:ref<False>) : return c.windout

;============================================================
;===================== Coroutines ===========================
;============================================================

;                     Interface
;                     =========

public defmulti active? (c:Coroutine) -> True|False
public defmulti open? (c:Coroutine) -> True|False
public defmulti resume<?I,?O> (c:Coroutine<?I,?O>, x:I) -> O
public defmulti suspend<?I,?O> (c:Coroutine<?I,?O>, x:O) -> I
public defmulti break<?O> (c:Coroutine<?,?O>, x:O) -> Void
public defmulti close (c:Coroutine) -> False

;                   Raw Coroutines
;                   ==============

lostanza deftype RawCoroutine <: Coroutine :
   id: long
   c-rsp: ptr<?>
   parent: ref<False|RawCoroutine>
   top: ref<Stack|False>
   bottom: ref<Stack|False>
   windin: ref<False|(() -> ?)>
   windout: ref<False|(? -> ?)>
   status: ref<Int>

;                  Wrapped Coroutines
;                  ==================

#if-defined(OPTIMIZE) :

   public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
      RawCoroutine(enter)

#else :

   deftype WrappedCoroutine<I,O> <: Coroutine<I,O>
   defmulti raw (c:WrappedCoroutine) -> RawCoroutine

   public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
      var rc
      val c = new WrappedCoroutine<I,O> :
         defmethod active? (this) : active?(rc)
         defmethod open? (this) : open?(rc)
         defmethod resume (this, x:I) : resume(rc, x)
         defmethod suspend (this, x:O) : suspend(rc, x)
         defmethod break (this, x:O) : break(rc, x)
         defmethod close (this) : close(rc)
         defmethod equal? (this, b:WrappedCoroutine) : rc == raw(b)
         defmethod raw (this) : rc
         defmethod print (o:OutputStream, this) : print(o, rc)
      rc = RawCoroutine $ fn (rc, x0) :
         enter(c, x0)
      c

;                    Implementation
;                    ==============

lostanza deftype CoResult :
   value: ref<?>
   windout: ref<False|(? -> ?)>
   final?: ref<True|False>

val COROUTINE-ACTIVE = 0
val COROUTINE-CLOSED = 1
val COROUTINE-SUSPENDED = 2
val COROUTINE-OPEN = 3

lostanza var COROUTINE-COUNTER:long = 0
lostanza defn next-coroutine-id () -> long :
   val id = COROUTINE-COUNTER
   COROUTINE-COUNTER = COROUTINE-COUNTER + 1
   return id

lostanza var current-coroutine:ref<RawCoroutine> =
   new RawCoroutine{
      next-coroutine-id()
      call-prim c-rsp()
      false
      call-prim stack()
      call-prim stack()
      false
      false
      COROUTINE-ACTIVE}

lostanza defn RawCoroutine (enter: ref<((RawCoroutine, ?) -> ?)>) -> ref<RawCoroutine> :
   return new-stack<ref<RawCoroutine>>{setup-coroutine(enter)}

lostanza defmethod equal? (a:ref<RawCoroutine>, b:ref<RawCoroutine>) -> ref<True|False> :
   if a.id == b.id : return true
   else : return false

lostanza defmethod active? (c:ref<RawCoroutine>) -> ref<True|False> :
   if c.status == COROUTINE-ACTIVE : return true
   else : return false

lostanza defmethod open? (c:ref<RawCoroutine>) -> ref<True|False> :
   if c.status == COROUTINE-OPEN : return true
   else : return false

lostanza defn top (c:ref<RawCoroutine>) -> ref<Stack> :
   return c.top as ref<Stack>

lostanza defn bottom (c:ref<RawCoroutine>) -> ref<Stack> :
   return c.bottom as ref<Stack>

lostanza defn* setup-coroutine (enter: ref<((RawCoroutine,?) -> ?)>) -> ref<?> :
   val s = call-prim stack()
   val p = parent(s)
   s.parent = false
   val c = new RawCoroutine{next-coroutine-id(), call-prim c-rsp(), false, s, s, false, false, COROUTINE-OPEN}
   val x0 = switch-stack<ref<?>>{p, c}
   return break(c, [enter](c, x0))

lostanza defmethod resume (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
   ;Ensure coroutine is re-entrant
   if c.status != COROUTINE-OPEN :
      return fatal("Unresumable Coroutine")

   ;Call its windin
   call-if-function(windin(c))

   ;Connect stacks, and attach coroutine
   current-coroutine.top = call-prim stack()
   current-coroutine.c-rsp = call-prim c-rsp()
   bottom(c).parent = current-coroutine.top
   attach(c)

   ;Switch stacks
   call-prim set-c-rsp(current-coroutine.c-rsp)
   val result = switch-stack<CoResult>{top(current-coroutine), x}

   ;Call its windout
   call-if-function(result.windout, result.final?)

   ;Switch stacks
   return result.value

lostanza defmethod* suspend (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
   ;Ensure coroutine is active
   if c.status != COROUTINE-ACTIVE :
      return fatal("Inactive Coroutine")

   ;Disconnect stacks, and Detach coroutine
   current-coroutine.top = call-prim stack()
   current-coroutine.c-rsp = call-prim c-rsp()
   bottom(c).parent = false
   detach(c, false)

   ;Return to resume
   val result = CoResult{x, windout(c), false}
   call-prim set-c-rsp(current-coroutine.c-rsp)
   return switch-stack<ref<?>>{top(current-coroutine), result}

lostanza defmethod* break (c:ref<RawCoroutine>, x:ref<?>) -> ref<Void> :
   ;Ensure coroutine is active
   if c.status != COROUTINE-ACTIVE :
      return fatal("Inactive Coroutine")

   ;Detach coroutine
   current-coroutine.top = call-prim stack()
   current-coroutine.c-rsp = call-prim c-rsp()
   detach(c, false)

   ;Result to return to resume
   val result = CoResult{x, windout(c), true}

   ;Free the coroutine
   free(c)

   ;Switch stacks
   call-prim set-c-rsp(current-coroutine.c-rsp)
   return switch-stack<ref<Void>>{top(current-coroutine), result}

lostanza defmethod close (c:ref<RawCoroutine>) -> ref<False> :
   if c.status == COROUTINE-CLOSED :
      return false
   else if c.status == COROUTINE-ACTIVE :
      return fatal("Cannot close active coroutine")
   else if c.status == COROUTINE-SUSPENDED :
      return fatal("Cannot close suspended coroutine")
   free(c)
   return false

lostanza defn* attach (c:ref<RawCoroutine>) -> int :
   val p = c.parent
   c.parent = current-coroutine
   c.status = COROUTINE-ACTIVE
   current-coroutine = c
   match(p) :
      (p:ref<RawCoroutine>) : return attach(p)
      (p:ref<False>) : return 0

lostanza defn* detach (c:ref<RawCoroutine>, tail:ref<RawCoroutine|False>) -> int :
   val cc = current-coroutine
   val ccp = current-coroutine.parent as ref<RawCoroutine>
   cc.parent = tail
   current-coroutine = ccp
   if c == cc :
      cc.status = COROUTINE-OPEN
      return 0
   else :
      cc.status = COROUTINE-SUSPENDED
      return detach(c, cc)

lostanza defn* free (c:ref<RawCoroutine>) -> int :
   val parent = c.parent
   c.status = COROUTINE-CLOSED
   free-stacks(top(c), bottom(c))
   c.top = false
   c.bottom = false
   c.parent = false
   c.windin = false
   c.windout = false
   match(parent) :
      (p:ref<RawCoroutine>) : return free(p)
      (p:ref<False>) : return 0

lostanza defn* free-stacks (top:ref<Stack>, bottom:ref<Stack>) -> int :
   if top == bottom :
      free-stack(top)
      return 0
   else :
      val p = parent(top)
      free-stack(top)
      return free-stacks(p, bottom)

defmethod print (o:OutputStream, c:RawCoroutine) :
   val s = switch {status(c) == _} :
      COROUTINE-ACTIVE : "ACTIVE"
      COROUTINE-CLOSED : "CLOSED"
      COROUTINE-SUSPENDED : "SUSPENDED"
      COROUTINE-OPEN : "OPEN"
   print(o, "<Coroutine #%_ : %_>" % [id(c), s])

lostanza defn id (c:ref<RawCoroutine>) -> ref<Int> : return new Int{c.id as int}
lostanza defn status (c:ref<RawCoroutine>) -> ref<Int> : return c.status

;============================================================
;================= Liveness Trackers ========================
;============================================================

public lostanza defn LivenessTracker<?T> (value:ref<?T>) -> ref<LivenessTracker<T>> :
   return new LivenessTracker{sentinel, value, false}

public lostanza defn id (marker:ref<LivenessMarker>) -> ref<Long> :
   return new Long{marker.id}

lostanza var tracker-counter:long = 0
public lostanza defn marker (tracker:ref<LivenessTracker>) -> ref<False|LivenessMarker> :
   if tracker.marker == sentinel :
      tracker.marker = new LivenessMarker{tracker-counter}
      tracker-counter = tracker-counter + 1
   return tracker.marker as ref<False|LivenessMarker>

public lostanza defn value<?T> (tracker:ref<LivenessTracker<?T>>) -> ref<T> :
   return tracker.value

defmethod print (o:OutputStream, m:LivenessMarker) :
   print(o, "<LivenessMarker %_>" % [id(m)])

defmethod print (o:OutputStream, t:LivenessTracker) :
   print(o, "<LivenessTracker %_ %~>" % [marker(t), value(t)])

;============================================================
;======================= Utilities ==========================
;============================================================

;                       Sentinels
;                       =========

lostanza deftype Sentinel
lostanza val sentinel:ref<Sentinel> = new Sentinel{}

defmethod print (o:OutputStream, s:Sentinel) :
   print(o, '_')

;                       Errors
;                       ======

protected defn ensure-index-in-bounds (xs:Lengthable, i:Int) :
   if i < 0 or i >= length(xs) :
      fatal("Index (%_) out of bounds." % [i])

defn ensure-start-before-end (s:Int, e:Int) :
   if e < s :
      fatal("Given end index (%_) is smaller than start index (%_)." % [e, s])

protected defn ensure-non-negative (quantity:String, n:Int) :
   if n < 0 :
      fatal("Given %_ (%_) is negative." % [quantity, n])

protected defn ensure-positive (quantity:String, n:Int) :
   if n <= 0 :
      fatal("Given %_ (%_) is not positive." % [quantity, n])

protected defn ensure-non-negative-length (n:Int) :
   ensure-non-negative("length", n)   

protected defn ensure-index-range (xs:Lengthable, r:Range) :
   defn ensure-end-index-in-bounds (xs:Lengthable, i:Int) :
      if i < 0 or i > length(xs) :
         fatal("Index (%_) out of bounds." % [i])
      
   if step(r) != 1 :
      fatal("Given index range (%_) does not have a step of 1." % [r])
   val s = start(r)   
   match(end(r), inclusive?(r)) :
      (e:Int, inc?:True) :
         ensure-index-in-bounds(xs, s)
         ensure-index-in-bounds(xs, e)
         ensure-start-before-end(s, e)
      (e:Int, inc?:False) :
         ensure-end-index-in-bounds(xs, s)
         ensure-end-index-in-bounds(xs, e)
         ensure-start-before-end(s, e)
      (e:False, inc?) :
         ensure-end-index-in-bounds(xs, s)

protected defn range-bound (s:Lengthable, r:Range) -> [Int, Int] :
   match(end(r), inclusive?(r)) :
      (e:Int, i:True) : [start(r), e + 1]
      (e:Int, i:False) : [start(r), e]
      (e:False, i) : [start(r), length(s)]

;============================================================
;================ Initialization Phase 1 ====================
;============================================================

;                  Constant Initialization
;                  =======================

lostanza var const-ptr:ptr<?>
lostanza val BYTE-CONST-TAG : int = 0
lostanza val CHAR-CONST-TAG : int = 1
lostanza val INT-CONST-TAG : int = 2
lostanza val LONG-CONST-TAG : int = 3
lostanza val FLOAT-CONST-TAG : int = 4
lostanza val DOUBLE-CONST-TAG : int = 5
lostanza val TRUE-CONST-TAG : int = 6
lostanza val FALSE-CONST-TAG : int = 7
lostanza val LIST-CONST-TAG : int = 8
lostanza val STRING-CONST-TAG : int = 9
lostanza val SYMBOL-CONST-TAG : int = 10
lostanza val TYPE-CONST-TAG : int = 11
lostanza val FN-CONST-TAG : int = 12

lostanza defn initialize-constants () -> int :
   ;Initialize read pointer to beginning of the constant table
   ;[num, constants ...]
   const-ptr = call-prim constant-table()
   val n-consts = read-const-int()

   ;Initialize pre symbol table
   initialize-pre-symbol-table()

   ;First n-consts entries in the global table are for constants
   var gs:ptr<ref<?>> = call-prim globals()
   for (var i:int = 0, i < n-consts, i = i + 1) :
      gs[i] = read-const()

   ;Initialize Symbol Table
   collections/initialize-collections()
   initialize-symbol-table()

   return 0

lostanza defn read-const () -> ref<?> :
   val tag = read-const-int()
   if tag == BYTE-CONST-TAG :
      return new Byte{read-const-byte()}
   else if tag == CHAR-CONST-TAG :
      return new Char{read-const-byte()}
   else if tag == INT-CONST-TAG :
      return new Int{read-const-int()}
   else if tag == LONG-CONST-TAG :
      return new Long{read-const-long()}
   else if tag == FLOAT-CONST-TAG :
      return new Float{read-const-float()}
   else if tag == DOUBLE-CONST-TAG :
      return new Double{read-const-double()}
   else if tag == TRUE-CONST-TAG :
      return true
   else if tag == FALSE-CONST-TAG :
      return false
   else if tag == LIST-CONST-TAG :
      val len = read-const-int()
      return read-const-list(len)
   else if tag == STRING-CONST-TAG :
      val len = read-const-long()
      val chars = read-const-chars(len)
      return String(len, chars)
   else if tag == SYMBOL-CONST-TAG :
      val len = read-const-long()
      val chars = read-const-chars(len)
      return init-symbol(String(len, chars))
   else if tag == TYPE-CONST-TAG :
      val code = read-const-long() as ptr<?>
      return new Type{code}[0]
   else if tag == FN-CONST-TAG :
      val code = read-const-long() as ptr<?>
      return new Fn{code}[0]
   else :
      call-c clib/fprintf(stderr, "Unknown constant tag: %ld\n", tag)
      return fatal("Unknown constant tag")

lostanza defn read-const-list (n:int) -> ref<List> :
   if n == 0 : return new NilList{}
   else : return new FullList{read-const(), read-const-list(n - 1)}

lostanza defn read-const-byte () -> byte :
   val value = [const-ptr as ptr<byte>]
   const-ptr = const-ptr + sizeof(byte)
   return value

lostanza defn read-const-int () -> int :
   val value = [const-ptr as ptr<int>]
   const-ptr = const-ptr + sizeof(int)
   return value

lostanza defn read-const-long () -> long :
   val value = [const-ptr as ptr<long>]
   const-ptr = const-ptr + sizeof(long)
   return value

lostanza defn read-const-float () -> float :
   val value = [const-ptr as ptr<float>]
   const-ptr = const-ptr + sizeof(float)
   return value

lostanza defn read-const-double () -> double :
   val value = [const-ptr as ptr<double>]
   const-ptr = const-ptr + sizeof(double)
   return value

lostanza defn read-const-chars (len:long) -> ptr<byte> :
   val value = const-ptr as ptr<byte>
   ;length chars + 0 character + pad to nearest 4 bytes
   val n = (len + 4) & -4
   const-ptr = (const-ptr + n) as ptr<?>
   return value

;                     Driver
;                     ======

lostanza: initialize-constants()

;============================================================
;============= Non-Printable Characters =====================
;============================================================

;TODO: Get rid of this once bootstrapped
val TAB-CHAR = to-char(9)
val BACKSPACE-CHAR = to-char(8)
val CARRIAGE-RETURN-CHAR = to-char(13)

;============================================================
;====================== Lengthable ==========================
;============================================================

public defmulti length (l:Lengthable) -> Int

;============================================================
;======================= Equalable ==========================
;============================================================

public defmulti equal? (a:Equalable, b:Equalable) -> True|False
defmethod equal? (a:Equalable, b:Equalable) : false

public defn not-equal? (a:Equalable, b:Equalable) -> True|False :
   complement(equal?(a, b))

;============================================================
;================== Seqable/Sequences =======================
;============================================================

public defmulti to-seq<?T> (s:Seqable<?T>) -> Seq<T>
defmethod to-seq<?T> (s:Seq<?T>) : s

public defmulti next<?T> (s:Seq<?T>) -> T
public defmulti peek<?T> (s:Seq<?T>) -> T
public defmulti empty? (s:Seq) -> True|False
public defmulti close (s:Seq) -> False

defn* do-seq<?T,?R> (f: Seq<T> -> ?R, s:Seqable<?T>) -> R :
   match(s) :
      (s:Seq<T>) :
         f(s)
      (s) :
         val s-seq = to-seq(s)
         dynamic-wind(
            false,
            fn* () : f(s-seq)
            fn* (final?) : close(s-seq) when final?)

;============================================================
;===================== Hashes ===============================
;============================================================

public defmulti hash (h:Hashable) -> Int

;============================================================
;=================== Comparable =============================
;============================================================

public defmulti compare<?T> (a:Comparable<?T>, b:T&Comparable) -> Int

public defmulti less?<?T> (a:Comparable<?T>, b:T&Comparable) -> True|False
public defmulti greater?<?T> (a:Comparable<?T>, b:T&Comparable) -> True|False
public defmulti less-eq?<?T> (a:Comparable<?T>, b:T&Comparable) -> True|False
public defmulti greater-eq?<?T> (a:Comparable<?T>, b:T&Comparable) -> True|False

defmethod less?<?T> (a:Comparable<?T>, b:T&Comparable) : compare(a, b) < 0
defmethod greater?<?T> (a:Comparable<?T>, b:T&Comparable) : compare(a, b) > 0
defmethod less-eq?<?T> (a:Comparable<?T>, b:T&Comparable) : compare(a, b) <= 0
defmethod greater-eq?<?T> (a:Comparable<?T>, b:T&Comparable) : compare(a, b) >= 0

;============================================================
;====================== ToString ============================
;============================================================

public defmulti to-string (x) -> String

;                Default Implementation
;                ======================

defmethod to-string (x) :
   val s = StringBuffer()
   print(s, x)
   to-string(s)

defmethod to-string (s:String) :
   s

;                  Primitive Values
;                  ================

lostanza val CONVERSION-BUFFER: ptr<byte> = call-c clib/malloc(32)

lostanza defmethod to-string (x:ref<Byte>) -> ref<String> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value as int)
   return String(n, CONVERSION-BUFFER)

defmethod to-string (x:Char) -> String :
   String(1, x)

lostanza defmethod to-string (x:ref<Int>) -> ref<String> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value)
   return String(n, CONVERSION-BUFFER)

lostanza defmethod to-string (x:ref<Long>) -> ref<String> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%ld", x.value)
   return String(n, CONVERSION-BUFFER)

lostanza defmethod to-string (x:ref<Float>) -> ref<String> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%f", x.value as double)
   return String(n, CONVERSION-BUFFER)

lostanza defmethod to-string (x:ref<Double>) -> ref<String> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%f", x.value)
   return String(n, CONVERSION-BUFFER)

defmethod to-string (x:True) :
   "true"

defmethod to-string (x:False) :
   "false"

;============================================================
;===================== OutputStream =========================
;============================================================

;                   General Interface
;                   =================

public defmulti print (o:OutputStream, x) -> False
public defmulti print-all (o:OutputStream, xs:Seqable) -> False

;                Default Implementations
;                =======================

defmethod print (o:OutputStream, x:Byte) : print(o, to-string(x))
defmethod print (o:OutputStream, x:Int) : print(o, to-string(x))
defmethod print (o:OutputStream, x:Long) : print(o, to-string(x))
defmethod print (o:OutputStream, x:Float) : print(o, to-string(x))
defmethod print (o:OutputStream, x:Double) : print(o, to-string(x))
defmethod print (o:OutputStream, x:True) : print(o, to-string(x))
defmethod print (o:OutputStream, x:False) : print(o, to-string(x))
defmethod print (o:OutputStream, x:String) : print-all(o, x)
defmethod print (o:OutputStream, x) : print(o, "[Unprintable Object]")

defmethod print-all (o:OutputStream, xs:Seqable) : do(print{o, _}, xs)

;                 Convenience Functions
;                 =====================

public defn println (o:OutputStream, x) :
   print(o, x)
   print(o, "\n")

public defn println-all (o:OutputStream, xs:Seqable) :
   print-all(o, xs)
   print(o, "\n")

;============================================================
;=================== FileOutputStream =======================
;============================================================

;TODO: Files and Directories.
;FileOutputStream streams are obtained from files.

public lostanza defn FileOutputStream (filename:ref<String>, append?:ref<True|False>) -> ref<FileOutputStream> :
   var file : ptr<?>
   if append? == true : file = call-c clib/fopen(addr!(filename.chars), "a")
   else : file = call-c clib/fopen(addr!(filename.chars), "w")
   if file == null : throw(FileOpenException(filename))
   return new FileOutputStream{file, 1}

public defn FileOutputStream (filename:String) :
   FileOutputStream(filename, false)

public lostanza defn close (o:ref<FileOutputStream>) -> ref<False> :
   if o.closable? :
      val err = call-c clib/fclose(o.file)
      if err != 0 : throw(FileCloseException())
   else : fatal("System OutputStream is not closable.")
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<String>) -> ref<False> :
   val r = call-c clib/fputs(addr!(x.chars), o.file)
   if r == EOF : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value as int)
   if r < 0 : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Char>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Int>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value)
   if r < 0 : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Long>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%ld", x.value)
   if r < 0 : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Float>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%f", x.value as double)
   if r < 0 : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Double>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%f", x.value as double)
   if r < 0 : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<True>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "true")
   if r < 0 : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<False>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "false")
   if r < 0 : throw(FileWriteException())
   return false

public defn with-output-file<?T> (file:FileOutputStream, f: () -> ?T) -> T :
   try : with-output-stream(file, f)
   finally : close(file)

public defn spit (filename:String, x) -> False :
   val o = FileOutputStream(filename, false)
   try : print(o, x)
   finally : close(o)

;============================================================
;================ System Output Streams =====================
;============================================================

;                 System Output Streams
;                 =====================

public lostanza val STANDARD-OUTPUT-STREAM : ref<OutputStream> =
   new FileOutputStream{stdout, 0}

public lostanza val STANDARD-ERROR-STREAM : ref<OutputStream> =
   new FileOutputStream{stderr, 0}

;                 Current Output Stream
;                 =====================

var CURRENT-OUTPUT-STREAM : OutputStream = STANDARD-OUTPUT-STREAM

public defn with-output-stream<?T> (o:OutputStream, f: () -> ?T) -> T :
   let-var CURRENT-OUTPUT-STREAM = o :
      f()

public defn print (x) :
   print(CURRENT-OUTPUT-STREAM, x)

public defn println (x) :
   print(x)
   print("\n")

public defn print-all (xs:Seqable) :
   do(print, xs)

public defn println-all (xs:Seqable) :
   print-all(xs)
   print("\n")

;============================================================
;=================== Input Streams ==========================
;============================================================

;                      Interface
;                      =========

public defmulti fill (xs:CharArray, r:Range, i:InputStream) -> Int
public defmulti info (i:InputStream) -> FileInfo

;                Abstract Implementations
;                ========================

defmethod fill (xs:CharArray, r:Range, s:InputStream) -> Int :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   defn* loop (i:Int) :
      if i < e :
         if empty?(s) :
            i - b
         else :
            xs[i] = next(s)
            loop(i + 1)
      else : i - b
   loop(b)   

;============================================================
;================= File Input Streams =======================
;============================================================

lostanza deftype InputFile :
   file: ptr<?>
   closable?: long

lostanza defn InputFile (filename:ref<String>) -> ref<InputFile> :
   val file = call-c clib/fopen(addr!(filename.chars), "r")
   if file == null : throw(FileOpenException(filename))
   return new InputFile{file, 1}
   
lostanza defn close (i:ref<InputFile>) -> ref<False> :
   if i.closable? :
      val err = call-c clib/fclose(i.file)
      if err != 0 : throw(FileCloseException())
   else : fatal("System Input Stream is not closable.")
   return false

lostanza defn char? (i:ref<InputFile>) -> ref<Maybe<Char>> :
   val c = call-c clib/fgetc(i.file)
   if c == EOF :
      val err = call-c clib/ferror(i.file)
      if err != 0 : throw(FileReadException())
      return None()
   else :
      return One(new Char{c as byte})

defn FileInputStream (file:InputFile, filename:String) :
   val chars = repeat-while(char?{file})
   var line = 1
   var column = 0
   new FileInputStream :
      defmethod next (this) :
         val c = next(chars)
         if c == '\n' :
            line = line + 1
            column = 0
         else :
            column = column + 1
         c
      defmethod peek (this) : peek(chars)
      defmethod close (this) : (close(chars), close(file))
      defmethod empty? (this) : empty?(chars)
      defmethod info (this) : FileInfo(filename, line, column)

public defn FileInputStream (filename:String) :
   FileInputStream(InputFile(filename), filename)

public defn slurp (filename:String) :
   val s = FileInputStream(filename)
   try : string-join(s)
   finally : close(s)

public defn file-exists? (filename:String) :
   try :
      InputFile(filename)
      true
   catch (e:Exception) :
      false      

;============================================================
;================= Linux Errors =============================
;============================================================

lostanza defn linux-error-msg () -> ref<String> :
   val s = call-c clib/strerror(call-c clib/get_errno())
   return String(s)

;============================================================
;==================== Remove File ===========================
;============================================================

public lostanza defn delete-file (path:ref<String>) -> ref<False> :
   val r = call-c clib/remove(addr!(path.chars))
   if r == -1 : throw(FileDeletionError(path, linux-error-msg()))
   return false

public deftype FileDeletionError <: Exception
public defn FileDeletionError (path:String, msg:String) :
   new FileDeletionError :
      defmethod print (o:OutputStream, this) :
         print{o, _} $
         "Error when attempting to delete %_. %_." % [path, msg]

;============================================================
;===================== FilePaths ============================
;============================================================

lostanza val PATH-BUFFER:ptr<byte> = call-c clib/malloc(call-c clib/get_PATH_MAX())
public lostanza defn resolve-path (path:ref<String>) -> ref<String|False> :
   val rpath = call-c clib/realpath(addr!(path.chars), PATH-BUFFER)
   if rpath == null : return false
   else : return String(rpath)      

;============================================================
;================ Environment Variables =====================
;============================================================

public lostanza defn get-env (name:ref<String>) -> ref<String|False> :
   val value = call-c clib/getenv(addr!(name.chars))
   if value == null : return false
   else : return String(value)

public lostanza defn set-env (name:ref<String>, value:ref<String>, overwrite:ref<True|False>) -> ref<False> :
   var ov:int = 0
   if overwrite == true : ov = 1
   val r = call-c clib/setenv(addr!(name.chars), addr!(value.chars), ov)
   if r != 0 : throw(SetEnvException(name, value))
   return false

public defn set-env (name:String, value:String) :
   set-env(name, value, true)

public defn set-env? (name:String, value:String) :
   set-env(name, value, false)

defn SetEnvException (name:String, value:String) :
   new Exception :
      defmethod print (o:OutputStream, this) :
         print(o, "Could not set environment variable %_ to %~." % [name, value])

;============================================================
;===================== System Calls =========================
;============================================================

public lostanza defn call-system (cmd:ref<String>) -> ref<False> :
   val r = call-c clib/system(addr!(cmd.chars))
   if r == -1 : throw(SystemCallException(linux-error-msg()))
   return false

public deftype SystemCallException <: Exception
defn SystemCallException (msg:String) :
   new SystemCallException :
      defmethod print (o:OutputStream, this) :
         print(o, msg)

;============================================================
;============== Input/Output Exceptions =====================
;============================================================

public deftype IOException <: Exception

public defstruct FileOpenException <: IOException :
   filename: String

defmethod print (o:OutputStream, e:FileOpenException) :
   print(o, "Error occurred when attempting to open file %~." % [filename(e)])

public defstruct FileCloseException <: IOException

defmethod print (o:OutputStream, e:FileCloseException) :
   print(o, "Error occurred when attempting to close file.")

public defstruct FileReadException <: IOException

defmethod print (o:OutputStream, e:FileReadException) :
   print(o, "Error occurred when attempting to read from file.")

public defstruct FileWriteException <: IOException

defmethod print (o:OutputStream, e:FileWriteException) :
   print(o, "Error occurred when attempting to write to file.")

;============================================================ 
;================ String Input Streams ======================
;============================================================

;                       Interface
;                       =========

public defmulti peek? (s:StringInputStream, i:Int) -> False|Char

;                Abstract Implementations
;                ========================

public defn peek? (s:StringInputStream) :
   peek?(s, 0)

public defn peek (s:StringInputStream, i:Int) :
   match(peek?(s, i)) :
      (c:Char) : c
      (c:False) : fatal("Could not peek at position %_ in stream." % [i])

;                   Implementation
;                   ==============

public defn StringInputStream (string:String, filename:String) :
   var start = 0
   var line = 1
   var column = 0
   val n = length(string)
   
   new StringInputStream :
      defmethod next (this) :
         val c = peek(this)
         start = start + 1
         if c == '\n' :
            line = line + 1
            column = 0
         else :
            column = column + 1
         c
      defmethod peek (this) :
         if start < n : string[start]
         else : fatal("Empty Stream")         
      defmethod info (this) :
         FileInfo(filename, line, column)
      defmethod peek? (this, i:Int) :
         string[start + i] when start + i < n
      defmethod empty? (this) :
         start >= n
      defmethod length (this) :
         start - n
      defmethod close (this) :
         start = n

public defn StringInputStream (string:String) :
   StringInputStream(string, "UnnamedStream")

;============================================================
;==================== Fatal Error ===========================
;============================================================

public lostanza defn fatal (msg:ref<?>) -> ref<Void> :
   call-c clib/fprintf(stderr, "FATAL ERROR: ")
   println(STANDARD-ERROR-STREAM, msg)
   print-stack-trace(call-prim sp())
   call-c clib/exit(-1)
   return null as ref<Void>

;============================================================
;===================== Formatting ===========================
;============================================================

deftype Printable

public defn modulo (format:String, args:Seqable) -> ? :
   new Printable :
      defmethod* print (o:OutputStream, this) :
         val seq = to-seq(args)
         val n = length(format)
         defn* loop (i:Int) :
            if i < n :
               val c = format[i]
               if c == '%' :
                  if i + 1 < n :
                     val modifier = format[i + 1]
                     switch {modifier == _} :
                        '_' : print(o, next(seq))
                        '*' : print-all(o, next(seq))
                        ',' : print-all(o, join(next(seq), ", "))
                        '~' : write(o, next(seq))
                        '@' : write-all(o, next(seq))
                        '%' : print(o, c)
                        else : fatal("Invalid argument specifier %~ in format string %~." % [modifier, format])
                     loop(i + 2)
                  else :
                     fatal("Incomplete argument specifier %% at end of format string %~." % [format])
               else :
                  print(o, c)
                  loop(i + 1)
            else :
               if not empty?(seq) :
                  fatal("Unexpected end of format string %~. More arguments remaining." % [format])
         loop(0)


;============================================================
;=================== Indented Streams =======================
;============================================================

public deftype IndentedStream <: OutputStream
defmulti stream (s:IndentedStream) -> OutputStream
defmulti indent (s:IndentedStream) -> Int

public defn IndentedStream (o:OutputStream, n:Int) :
   match(o) :
      (o:IndentedStream) :
         IndentedStream(stream(o), n + indent(o))
      (o) :
         var start-of-line? = true
         val spaces = String(n, ' ')
         defn put (c:Char) :
            if start-of-line? :
               print(o, spaces)
               start-of-line? = false
            print(o, c)
            if c == '\n' :
               start-of-line? = true
            
         new IndentedStream :
            defmethod stream (this) : o
            defmethod indent (this) : n
            defmethod print (this, c:Char) : put(c)

public defn do-indented (f: IndentedStream -> ?, o:OutputStream) :
   f(IndentedStream(o, 3))
   
public defn indented (f: () -> ?) :
   let-var CURRENT-OUTPUT-STREAM = IndentedStream(CURRENT-OUTPUT-STREAM, 3) :
      f()

;============================================================
;===================== Generators ===========================
;============================================================

public defn Generator<T> (thunk : (T -> False, (T -> Void) & (() -> Void)) -> ?) -> Seq<T> :
   ;State
   var item = sentinel

   ;Generator Coroutine
   val co = Coroutine<False, T|Sentinel> $ fn (co, x0) :
      defn co-yield (x:T) :
         suspend(co, x)
      val co-break = multifn :
         (x:T) : break(co, x)
         () : break(co, sentinel)
      thunk(co-yield, co-break)
      sentinel

   ;Fill state: Returns whether empty
   defn fill () :
      if (item is Sentinel) and open?(co) :
         item = resume(co, false)
      item is Sentinel

   ;Peek
   defn peek () :
      if item is Sentinel :
         fatal("Empty Sequence")
      item as T

   ;Empty bucket
   defn empty () :
      val x = peek()
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         peek()
      defmethod close (this) :
         item = sentinel
         close(co)
      defmethod empty? (this) :
         fill()

;============================================================
;====================== Labels ==============================
;============================================================

public defn* LabeledScope<T> (thunk: (T -> Void) -> T) -> T :
   val c = Coroutine<False,T> $ fn* (c, x0) :
      thunk(break{c, _})
   resume(c, false)

;============================================================
;====================== Maybe ===============================
;============================================================

;                      Interface
;                      =========

public defmulti value<?T> (x:One<?T>) -> T

;                     Constructors
;                     ============

public defn None () :
   new None

public defn One<?T> (x:?T) :
   new One<T> :
      defmethod value (this) : x

;                   Implementation
;                   ==============

public defn value!<?T> (x:Maybe<?T>) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : fatal("Object of type None has no value.")

public defn value?<?T> (x:Maybe<?T>) -> T|False :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : false

public defn empty? (x:Maybe) :
   x is None

defmethod equal? (a:None, b:None) :
   true

defmethod equal? (a:One, b:One) :
   value(a) == value(b)

;                   Comparisons
;                   ===========

defmethod* compare<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : 0
      (x:None, y:One<T>) : -1
      (x:One<T>, y:None) : 1
      (x:One<T&Comparable>, y:One<T&Comparable>) : compare(value(x), value(y))

defmethod less?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable>, y:One<T&Comparable>) : value(x) < value(y)

defmethod less-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable>, y:One<T&Comparable>) : value(x) <= value(y)

defmethod greater?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable>, y:One<T&Comparable>) : value(x) > value(y)

defmethod greater-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable>, y:One<T&Comparable>) : value(x) >= value(y)

;============================================================
;====================== Ranges ==============================
;============================================================

;                      Interface
;                      =========

public defmulti start (r:Range) -> Int
public defmulti end (r:Range) -> Int|False
public defmulti step (r:Range) -> Int
public defmulti inclusive? (r:Range) -> True|False

;                     Constructor
;                     ===========

public defn Range (start:Int, end:Int|False, step:Int, inclusive?:True|False) :
   ;Compute the length of the range
   val length = match(end, inclusive?) :
      (end:Int, inc:False) :
         if step == 0 :
            if step == end : 0
            else : false
         else if step == 1 :
            end - start
         else if step == -1 :
            start - end
         else if step > 0 :
            (end - start + step - 1) / step
         else :
            (end - start + step + 1) / step
      (end:Int, inc:True) :
         if step == 0 :
            false
         else if step == 1 :
            end - start + 1
         else if step == -1 :
            start - end + 1
         else :
            (end - start + step) / step
      (end:False, inc) :
         false

   match(length) :
      (length:Int) :
         new Range & Lengthable :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?
            defmethod length (this) : max(length, 0)
      (length:False) :
         new Range :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?

;                Conversion to Sequence
;                ======================

defmethod to-seq (r:Range) :
   match(r) :
      (r:Range & Lengthable) :
         var i = start(r)
         var n = length(r)
         new Seq<Int> & Lengthable :
            defmethod next (this) :
               val i* = peek(this)
               i = i + step(r)
               n = n - 1
               i*
            defmethod peek (this) :
               fatal("Empty Sequence") when n == 0
               i
            defmethod close (this) :
               n = 0
            defmethod empty? (this) :
               n == 0
            defmethod length (this) :
               n
      (r:Range) :
         var i = start(r)
         var closed? = false
         new Seq<Int> :
            defmethod next (this) :
               fatal("Empty Sequence") when closed?
               val i* = i
               i = i + step(r)
               i*
            defmethod peek (this) :
               fatal("Empty Sequence") when closed?
               i
            defmethod close (this) :
               closed? = true
            defmethod empty? (this) :
               closed?

;             Looping
;             =======

defmethod do (f: Int -> ?, r:Range&Lengthable) :
   val s = step(r)
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(i)
         loop(i + s, n - 1)
   loop(start(r), length(r))

defmethod do (f: Int -> ?, r:Range) :
   val s = step(r)
   defn* loop (i:Int) :
      f(i)
      loop(i + s)
   loop(start(r))

;                 Comparison
;                 ==========

defmethod equal? (a:Range, b:Range) :
   start(a) == start(b) and
   end(a) == end(b) and
   step(a) == step(b) and
   inclusive?(a) == inclusive?(b)

;                  Printing
;                  ========

defmethod print (o:OutputStream, x:Range) :
   val op = "through" when inclusive?(x) else "to"
   if step(x) == 1 : print(o, "%_ %_ %_" % [start(x), op, end(x)])
   else : print(o, "%_ %_ %_ by %_" % [start(x), op, end(x), step(x)])

;                  Mapping
;                  =======

public defn map<?R> (f: Int -> ?R, r:Range) -> List<R> :
   to-list(seq(f, r))

;============================================================
;===================== Tuples ===============================
;============================================================

public lostanza defn Tuple<?T> (n:ref<Int>, x:ref<?T>) -> ref<Tuple<T>> :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative-length(n)
   val len = n.value
   val t = new Tuple<T>{len}[len]
   for (var i:long = 0, i < len, i = i + 1) :
      t.items[i] = x
   return t

lostanza defn set<?T> (x:ref<Tuple<?T>>, i:ref<Int>, v:ref<T>) -> ref<False> :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(x, i)
   x.items[i.value] = v
   return false

lostanza defmethod length (x:ref<Tuple>) -> ref<Int> :
   return new Int{x.length as int}

public lostanza defn get<?T> (x:ref<Tuple<?T>>, i:ref<Int>) -> ref<T> :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(x, i)
   return x.items[i.value]

public defn get<?T> (xs:Tuple<?T>, r:Range) -> Tuple<T> :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])   

defmethod to-seq<?T> (x:Tuple<?T>) :
   seq({x[_]}, 0 to length(x))

lostanza defmethod equal? (x:ref<Tuple>, y:ref<Tuple>) -> ref<True|False> :
   val n = x.length
   if n != y.length : return false
   for (var i:long = 0, i < n, i = i + 1) :
      if equal?(x.items[i], y.items[i]) == false :
         return false
   return true

defmethod hash (xs:Tuple) :
   var i = length(xs)
   for x in xs do :
      i = (7 * i) + hash(x)
   i

defmethod compare (a:Tuple<Comparable>, b:Tuple<Comparable>) -> Int :
   defn* loop (i:Int, j:Int) :
      if i < length(a) and j < length(b) :
         val c = compare(a[i], b[i])
         if c == 0 : loop(i + 1, j + 1)
         else : c
      else if i < length(a) : 1
      else if j < length(b) : -1
      else : 0
   loop(0, 0)

defmethod print (o:OutputStream, t:Tuple) -> False :
   print(o, "[%@]" % [t])

public defn to-tuple<?T> (xs:Seqable<?T>) -> Tuple<T> :
   match(xs) :
      (xs:Tuple<T>) :
         xs
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val t = Tuple(n, false as ?)
         for (x in xs, i in 0 to n) do :
            t[i] = x
         t
      (xs) :
         to-tuple(to-list(xs))

public defn map<?T,?R> (f:T -> ?R, xs:Tuple<?T>) -> Tuple<R> :
   to-tuple(seq(f, xs))

public defn empty? (t:Tuple) :
   length(t) == 0

;============================================================
;======================= Bytes ==============================
;============================================================

public lostanza defn shift-left (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value << b.value}

public lostanza defn shift-right (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value >> b.value}

public lostanza defn arithmetic-shift-right (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value >>> b.value}

public lostanza defn bit-or (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value | b.value}

public lostanza defn bit-xor (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value & b.value}

public lostanza defn bit-not (a:ref<Byte>) -> ref<Byte> :
   return new Byte{(~ a.value)}

public lostanza defn plus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value + b.value}

public lostanza defn minus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value - b.value}

public lostanza defn times (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value * b.value}

public lostanza defn divide (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value / b.value}

public lostanza defn modulo (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value % b.value}

lostanza defmethod compare (a:ref<Byte>, b:ref<Byte>) -> ref<Int> :
   return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false

defmethod equal? (a:Byte, b:Byte) -> True|False :
   ($prim identical? a b)

lostanza defmethod hash (a:ref<Byte>) -> ref<Int> :
   return new Int{a.value}

;============================================================
;======================= Chars ==============================
;============================================================

lostanza defmethod compare (a:ref<Char>, b:ref<Char>) -> ref<Int> :
   return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false

defmethod equal? (a:Char, b:Char) -> True|False :
   ($prim identical? a b)

lostanza defmethod hash (a:ref<Char>) -> ref<Int> :
   return new Int{a.value}

public lostanza defn digit? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= '0' and b <= '9' : return true
   else : return false

public lostanza defn letter? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'a' and b <= 'z' : return true
   else if b >= 'A' and b <= 'Z' : return true
   else : return false

;============================================================
;======================= Ints ===============================
;============================================================

public lostanza val INT-MAX:ref<Int> = new Int{(1 << 31) - 1}
public lostanza val INT-MIN:ref<Int> = new Int{1 << 31}

public defn shift-left (a:Int, b:Int) -> Int :
   ($prim shl a b)

public defn shift-right (a:Int, b:Int) -> Int :
   ($prim shr a b)

public defn arithmetic-shift-right (a:Int, b:Int) -> Int :
   ($prim ashr a b)

public defn bit-or (a:Int, b:Int) -> Int :
   ($prim or a b)

public defn bit-and (a:Int, b:Int) -> Int :
   ($prim and a b)

public defn bit-xor (a:Int, b:Int) -> Int :
   ($prim xor a b)

public defn bit-not (a:Int) -> Int :
   ($prim not a)

public defn negate (a:Int) -> Int :
   ($prim neg a)

public defn plus (a:Int, b:Int) -> Int :
   ($prim add a b)

public defn minus (a:Int, b:Int) -> Int :
   ($prim sub a b)

public defn times (a:Int, b:Int) -> Int :
   ($prim mul a b)

public defn divide (a:Int, b:Int) -> Int :
   ($prim div a b)

public defn modulo (a:Int, b:Int) -> Int :
   ($prim mod a b)

defmethod compare (a:Int, b:Int) -> Int :
   if a < b : -1
   else if a > b : 1
   else : 0

defmethod less? (a:Int, b:Int) -> True|False :
   ($prim lt a b)

defmethod less-eq? (a:Int, b:Int) -> True|False :
   ($prim le a b)

defmethod greater? (a:Int, b:Int) -> True|False :
   ($prim gt a b)

defmethod greater-eq? (a:Int, b:Int) -> True|False :
   ($prim ge a b)

defmethod equal? (a:Int, b:Int) -> True|False :
   ($prim eq a b)

defmethod hash (a:Int) -> Int :
   a

;============================================================
;======================= Longs ==============================
;============================================================

public lostanza defn shift-left (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value << b.value}

public lostanza defn shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value >> b.value}

public lostanza defn arithmetic-shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value >>> b.value}

public lostanza defn bit-or (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value | b.value}

public lostanza defn bit-xor (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value & b.value}

public lostanza defn bit-not (a:ref<Long>) -> ref<Long> :
   return new Long{(~ a.value)}

public lostanza defn negate (a:ref<Long>) -> ref<Long> :
   return new Long{(- a.value)}

public lostanza defn plus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value + b.value}

public lostanza defn minus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value - b.value}

public lostanza defn times (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value * b.value}

public lostanza defn divide (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value / b.value}

public lostanza defn modulo (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value % b.value}

lostanza defmethod compare (a:ref<Long>, b:ref<Long>) -> ref<Int> :
   if a.value < b.value : return new Int{-1}
   else if a.value > b.value : return new Int{1}
   else : return new Int{0}

lostanza defmethod less? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false

lostanza defmethod equal? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value == b.value : return true
   else : return false

lostanza defmethod hash (a:ref<Long>) -> ref<Int> :
   val v = a.value
   return new Int{(v ^ (v >> 32)) as int}

;============================================================
;======================= Floats =============================
;============================================================

public lostanza defn negate (a:ref<Float>) -> ref<Float> :
   return new Float{(- a.value)}

public lostanza defn plus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
   return new Float{a.value + b.value}

public lostanza defn minus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
   return new Float{a.value - b.value}

public lostanza defn times (a:ref<Float>, b:ref<Float>) -> ref<Float> :
   return new Float{a.value * b.value}

public lostanza defn divide (a:ref<Float>, b:ref<Float>) -> ref<Float> :
   return new Float{a.value / b.value}

lostanza defmethod compare (a:ref<Float>, b:ref<Float>) -> ref<Int> :
   if a.value < b.value : return new Int{-1}
   else if a.value > b.value : return new Int{1}
   else : return new Int{0}

lostanza defmethod less? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false
   
lostanza defmethod equal? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value == b.value : return true
   else : return false

defmethod hash (a:Float) -> Int :
   bits(a)

;============================================================
;======================= Doubles ============================
;============================================================

public lostanza defn negate (a:ref<Double>) -> ref<Double> :
   return new Double{(- a.value)}

public lostanza defn plus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
   return new Double{a.value + b.value}

public lostanza defn minus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
   return new Double{a.value - b.value}

public lostanza defn times (a:ref<Double>, b:ref<Double>) -> ref<Double> :
   return new Double{a.value * b.value}

public lostanza defn divide (a:ref<Double>, b:ref<Double>) -> ref<Double> :
   return new Double{a.value / b.value}

lostanza defmethod compare (a:ref<Double>, b:ref<Double>) -> ref<Int> :
   if a.value < b.value : return new Int{-1}
   else if a.value > b.value : return new Int{1}
   else : return new Int{0}

lostanza defmethod less? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false

lostanza defmethod equal? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value == b.value : return true
   else : return false

lostanza defmethod hash (a:ref<Double>) -> ref<Int> :
   val v = a.value
   val bits = ($ls-prim bits v)
   return new Int{(bits ^ (bits >> 32)) as int}

;============================================================
;=============== Commandline Arguments ======================
;============================================================

public lostanza defn command-line-arguments () -> ref<Array<String>> :
   val r = Array<String>(new Int{clib/input_argc})
   for (var i:int = 0, i < clib/input_argc, i = i + 1) :
      val str = clib/input_argv[i]
      set(r, new Int{i}, String(str))
   return r

;============================================================
;====================== Strings =============================
;============================================================

public lostanza defn String (chars:ptr<byte>) -> ref<String> :
   val len = call-c clib/strlen(chars)
   return String(len, chars)

public lostanza defn String (len:long, chars:ptr<byte>) -> ref<String> :
   val s = String(len)
   for (var i:long = 0, i < len, i = i + 1) :
      s.chars[i] = chars[i]
   s.chars[len] = 0 as byte   
   return s

public lostanza defn String (len:long, c:byte) -> ref<String> :
   val s = String(len)
   for (var i:long = 0, i < len, i = i + 1) :
      s.chars[i] = c
   s.chars[len] = 0 as byte   
   return s

public lostanza defn String (len:long) -> ref<String> :
   return new String{len, 0}[len + 1]

public lostanza defn String (len:ref<Int>, c:ref<Char>) -> ref<String> :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative-length(len)
   return String(len.value, c.value)

lostanza defn set (s:ref<String>, i:ref<Int>, c:ref<Char>) -> ref<False> :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(s, i)
   s.chars[i.value] = c.value
   return false

public defn String (cs:Seqable<Char>) -> String :
   match(cs) :
      (cs:Seqable<Char> & Lengthable) :
         val n = length(cs)
         val s = String(n, ' ')
         for (c in cs, i in 0 to false) do :
            s[i] = c
         s
      (c) :
         String(to-vector<Char>(cs))

public lostanza defmethod hash (s:ref<String>) -> ref<Int> :
   if s.hash == 0 :
      val n = s.length
      var h:int = 0
      for (var i:long = 0, i < n, i = i + 1) :
         h = (31 * h) + s.chars[i]
      if h == 0 : s.hash = 1
      else : s.hash = h
   return new Int{s.hash}

defmethod length (s:String) -> Int :
   ($prim string-len s)

public defn get (s:String, i:Int) -> Char :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(s, i)
   ($prim string-get s i)

defmethod to-seq (s:String) :
   seq({s[_]}, 0 to length(s))

lostanza defmethod equal? (a:ref<String>, b:ref<String>) -> ref<True|False> :
   val n = a.length
   if n == b.length :
      for (var i:long = 0, i < n, i = i + 1) :
         if a.chars[i] != b.chars[i] :
            return false
      return true
   else :
      return false

lostanza defmethod compare (a:ref<String>, b:ref<String>) -> ref<Int> :
   val c = compare-strings(a, b, 0, a.length, b.length)
   return new Int{c}

lostanza defn* compare-strings (a:ref<String>, b:ref<String>, i:long, na:long, nb:long) -> int :
   if (i == na) and (i == nb) :
      return 0
   else if i == na :
      return -1
   else if i == nb :
      return 1
   else :
      val ac = a.chars[i]
      val bc = b.chars[i]
      if ac < bc : return -1
      else if ac > bc : return 1
      else : return compare-strings(a, b, i + 1, na, nb)

defmethod do (f: Char -> ?, xs:String) :
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(xs[i])
         loop(i + 1, n - 1)
   loop(0, length(xs))

;============================================================
;======================= Lists ==============================
;============================================================

;                      Interface
;                      =========

public defmulti head<?T> (x:List<?T>) -> T
public defmulti tail<?T> (x:List<?T>) -> List<T>

;                    Constructors
;                    ============

public lostanza defn List () -> ref<NilList> :
   return new NilList{}

public lostanza defn cons<?T> (x:ref<?T>, t:ref<List<?T>>) -> ref<FullList<T>> :
   return new FullList<T>{x, t}

public defn cons<?T> (x:?T, y:?T, t:List<?T>) -> FullList<T> :
   cons(x, cons(y, t))

public defn cons<?T> (x:?T, y:?T, z:?T, t:List<?T>) -> FullList<T> :
   cons(x, cons(y, cons(z, t)))

public defn List<?T> (x:?T) -> FullList<T> :
   cons(x, List())

public defn List<?T> (x:?T, y:?T) -> FullList<T> :
   cons(x, cons(y, List()))

public defn List<?T> (x:?T, y:?T, z:?T) -> FullList<T> :
   cons(x, cons(y, cons(z, List())))

public defn List<?T> (w:?T, x:?T, y:?T, z:?T) -> FullList<T> :
   cons(w, cons(x, cons(y, cons(z, List()))))

;                     Implementation
;                     ==============

public defn empty? (x:List) :
   x is NilList

lostanza defmethod head<?T> (x:ref<FullList<?T>>) -> ref<T> :
   return x.head

lostanza defmethod tail<?T> (x:ref<FullList<?T>>) -> ref<List<T>> :
   return x.tail

defmethod head (x:NilList) : fatal("Object of type NilList has no head.")
defmethod tail (x:NilList) : fatal("Object of type NilList has no tail.")

defmethod length (x:List) :
   defn* loop (x:List, n:Int) :
      match(x) :
         (x:FullList) : loop(tail(x), n + 1)
         (x:NilList) : n
   loop(x, 0)

defmethod to-seq<?T> (x:List<?T>) :
   var l = x
   new Seq<T> :
      defmethod empty? (this) :
         l is NilList
      defmethod next (this) :
         val x = peek(this)
         l = tail(l)
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         head(l)
      defmethod close (this) :
         l = List()

defmethod equal? (a:List, b:List) -> True|False :
   defn* loop (a:List, b:List) :
      match(a, b) :
         (a:NilList, b:NilList) : true
         (a:FullList<Equalable>, b:FullList<Equalable>) :
            if head(a) == head(b) :
               loop(tail(a), tail(b))
         (a, b) : false
   loop(a, b)

defmethod hash (xs:List<Hashable>) -> Int :
   var i = 0
   for x in xs do :
      i = (7 * i) + hash(x)
   i

defmethod compare (xs:List<Comparable>, ys:List<Comparable>) -> Int :
   defn* loop (xs:List<Comparable>, ys:List<Comparable>) :
      match(xs, ys) :
         (xs:NilList, ys:NilList) : 0
         (xs:NilList, ys:FullList) : -1
         (xs:FullList, ys:NilList) : 1
         (xs:FullList<Comparable>, ys:FullList<Comparable>) :
            val c = compare(head(xs), head(ys))
            if c == 0 : loop(tail(xs), tail(ys))
            else : c
   loop(xs, ys)

defmethod print (o:OutputStream, xs:List) -> False :
   print(o, "(%@)" % [xs])

public defn to-list<?T> (xs:Seqable<?T>) -> List<T> :
   match(xs) :
      (xs:List<T>) :
         xs
      (xs) :
         val xs-seq = to-seq(xs)
         defn loop () :
            if empty?(xs-seq) : List()
            else : cons(next(xs-seq), loop())
         loop()

public defn in-reverse<?T> (xs:List<?T>) -> Seq<T> :
   generate<T> :
      defn loop (xs:List<T>) :
         if not empty?(xs) :
            loop(tail(xs))
            yield(head(xs))
      loop(xs)      

defmethod do<?T> (f:T -> ?, xs:List<?T>) -> False :
   defn* loop (xs:List<T>) :
      if not empty?(xs) :
         f(head(xs))
         loop(tail(xs))
   loop(xs)      

;============================================================
;===================== True/False ===========================
;============================================================

public defn complement (a:True|False) -> True|False :
   if a : false
   else : true

defmethod equal? (a:True|False, b:True|False) -> True|False :
   ($prim identical? a b)

;============================================================
;=================== IndexedCollections =====================
;============================================================

;                       Interface
;                       =========

public defmulti get<?T> (a:IndexedCollection<?T>, i:Int) -> T
public defmulti set<?T> (a:IndexedCollection<?T>, i:Int, v:T) -> False
public defmulti get<?T> (a:IndexedCollection<?T>, r:Range) -> Collection<T>
public defmulti set<?T> (a:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False
public defmulti map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False

;                 Abstract Implementations
;                 ========================

public defn empty? (v:IndexedCollection) :
   length(v) == 0

defmethod print (o:OutputStream, a:IndexedCollection) -> False :
   print(o, "[%@]" % [a])

defmethod map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False :
   for i in 0 to length(xs) do :
      xs[i] = f(xs[i])

defmethod get<?T> (xs:IndexedCollection<?T>, r:Range) -> Tuple<T> :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])

defmethod set<?T> (xs:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   val vs-seq = to-seq(vs)
   for i in b to e do : xs[i] = next(vs-seq)

defmethod to-seq<?T> (xs:IndexedCollection<?T>) -> Seq<T> :
   seq({xs[_]}, 0 to length(xs))

public defn reverse!<?T> (xs:IndexedCollection<?T>) -> False :
   val n = length(xs)
   for i in 0 to n / 2 do :
      val j = n - 1 - i
      val xi = xs[i]
      val xj = xs[j]
      xs[i] = xj
      xs[j] = xi

public defn in-reverse<?T> (xs:IndexedCollection<?T>) -> Seq<T> :
   val n = length(xs)
   for i in (n - 1) through 0 by -1 seq :
      xs[i]   

;                       Sorting
;                       =======

public defn qsort!<?T> (xs:IndexedCollection<?T>, is-less?:(T,T) -> True|False) -> False :
   ;Swap element i with element j
   defn swap (i:Int, j:Int) :
      if i != j :
         val xi = xs[i]
         val xj = xs[j]
         xs[i] = xj
         xs[j] = xi
      
   ;Rearrange elements from b to e, such that the first elements is less than pivot.
   ;Returns a s.t. all elements from b to a are less than pivot.
   defn partition (b:Int, e:Int, pivot:T) :
      defn* loop (a:Int, b:Int) -> Int :
         if b < e :
            val xb = xs[b]
            if is-less?(xb, pivot) :
               swap(a, b)
               loop(a + 1, b + 1)
            else : loop(a, b + 1)
         else : a
      loop(b, b)

   ;Driver
   defn* sort (b:Int, e:Int) :
      val n = e - b
      if n > 2 :
         swap(rand(b to e), e - 1) when n > 10
         val e1 = partition(b, e - 1, xs[e - 1])
         swap(e1, e - 1)
         sort(b, e1)
         sort(e1 + 1, e)
      else if n == 2 :
         swap(b, b + 1) when is-less?(xs[b + 1], xs[b])
         
   sort(0, length(xs))

public defn qsort!<?T> (xs:IndexedCollection<?T&Comparable>) -> False :
   qsort!(xs, less?)   

public defn qsort!<?T> (key:T -> Comparable, xs:IndexedCollection<?T>) -> False :
   qsort!{xs, _} $ fn (x, y) :
      key(x) < key(y)
         
;                       Lazy Sorting
;                       ============

public defn lazy-qsort<?T> (coll:Seqable<?T>, is-less?:(T,T) -> True|False) -> Collection<T> & Lengthable :
   ;Convert to a vector
   val xs = to-vector<T>(coll)

   ;Sort Progress
   defn sort-progress () :
      generate<Int> :
         ;Swap element i with element j
         defn swap (i:Int, j:Int) :
            if i != j :
               val xi = xs[i]
               val xj = xs[j]
               xs[i] = xj
               xs[j] = xi
            
         ;Rearrange elements from b to e, such that the first elements is less than pivot.
         ;Returns a s.t. all elements from b to a are less than pivot.
         defn partition (b:Int, e:Int, pivot:T) :
            defn* loop (a:Int, b:Int) -> Int :
               if b < e :
                  val xb = xs[b]
                  if is-less?(xb, pivot) :
                     swap(a, b)
                     loop(a + 1, b + 1)
                  else : loop(a, b + 1)
               else : a
            loop(b, b)

         ;Driver
         defn* sort (b:Int, e:Int) :
            val n = e - b
            if n > 2 :
               swap(rand(b to e), e - 1) when n > 10
               val e1 = partition(b, e - 1, xs[e - 1])
               swap(e1, e - 1)
               sort(b, e1)
               yield(e1 + 1)
               sort(e1 + 1, e)
            else if n == 2 :
               swap(b, b + 1) when is-less?(xs[b + 1], xs[b])
         
         sort(0, length(xs))
         break(length(xs))

   ;Ensuring Progress
   var sorted = 0
   val sorter = sort-progress()
   defn* ensure-sorted (n:Int) :
      if sorted < n :
         sorted = next(sorter)
         ensure-sorted(n)

   ;Return object
   new Collection<T> & Lengthable :
      defmethod length (this) :
         length(xs)
      defmethod to-seq (this) :   
         for i in 0 to length(xs) seq :
            ensure-sorted(i + 1)
            xs[i]

public defn lazy-qsort<?T> (coll:Seqable<?T&Comparable>) :
   lazy-qsort(coll, less?)
      

;============================================================
;======================= Arrays =============================
;============================================================

;                 Abstract Implementations
;                 ========================

public defn to-array<T> (xs:Seqable<T>) -> Array<T> :
   match(xs) :
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val a = Array<T>(n)
         for (x in xs, i in 0 to n) do :
            a[i] = x
         a
      (xs) :
         to-array<T>(to-list(xs))

public defn map<R,?T> (f: T -> R, xs:Array<?T>) -> Array<R> :
   val ret = Array<R>(length(xs))
   for (x in xs, i in 0 to false) do :
      ret[i] = f(x)
   ret   

;                     Implementation
;                     ==============

lostanza deftype RawArray <: Array :
   length: long
   items: ref<?> ...

lostanza defn RawArray (n:ref<Int>, x:ref<?>) -> ref<RawArray> :
   val l = n.value
   val a = new RawArray{l}[l]
   for (var i:long = 0, i < l, i = i + 1) :
      a.items[i] = x
   return a

defmethod get (a:RawArray, i:Int) -> ? :
   ($prim aget a i)

defmethod set (a:RawArray, i:Int, v) -> False :
   ($prim aset a i v)

defmethod length (a:RawArray) -> Int :
   ($prim alen a)

defmethod print (o:OutputStream, a:RawArray) -> False :
   print(o, "[%@]" % [a])

defmethod equal? (a:RawArray, b:RawArray) :
   ($prim identical? a b)

;                     Wrapping
;                     ========

#if-defined(OPTIMIZE) :

   public defn Array<T> (n:Int) -> Array<T> :
      RawArray(n, sentinel)

   public defn Array<T> (n:Int, x:T) -> Array<T> :
      RawArray(n, x)
      
#else :

   deftype WrappedArray<T> <: Array<T>
   defmulti raw (a:WrappedArray) -> RawArray

   public defn Array<T> (n:Int) -> Array<T> :
      #if-not-defined(OPTIMIZE) :
         ensure-non-negative("length", n)
      Array<T>(RawArray(n, sentinel))

   public defn Array<T> (n:Int, x:T) -> Array<T> :
      #if-not-defined(OPTIMIZE) :
         ensure-non-negative("length", n)
      Array<T>(RawArray(n, x))

   defn Array<T> (a:RawArray) -> Array<T> :
      new WrappedArray<T> :
         defmethod raw (this) : a
         defmethod get (this, i:Int) :
            #if-not-defined(OPTIMIZE) :
               ensure-index-in-bounds(a, i)
            match(a[i]) :
               (v:Sentinel) : fatal("Index (%_) is uninitialized." % [i])
               (v) : v
         defmethod set (this, i:Int, v:T) :
            #if-not-defined(OPTIMIZE) :
               ensure-index-in-bounds(a, i)
            a[i] = v
         defmethod length (this) :
            length(a)
         defmethod print (o:OutputStream, this) :
            print(o, a)
         defmethod equal? (this, x:WrappedArray) :
            a == raw(x)

;                     Looping
;                     =======

defmethod do<?T> (f: T -> ?, xs:Array<?T>) :
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(xs[i])
         loop(i + 1, n - 1)
   loop(0, length(xs))

;============================================================
;==================== CharArrays ============================
;============================================================

;                     Implementation
;                     ==============

public lostanza defn CharArray (n:ref<Int>, x:ref<Char>) -> ref<CharArray> :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative-length(n)
   val l = n.value
   val a = new CharArray{l}[l]
   val c = x.value
   for (var i:long = 0, i < l, i = i + 1) :
      a.chars[i] = c
   return a

public defn CharArray (n:Int) -> CharArray :
   CharArray(n, ' ')

defmethod get (a:CharArray, i:Int) -> Char :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(a, i)
   ($prim char-aget a i)

defmethod set (a:CharArray, i:Int, c:Char) -> False :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(a, i)
   ($prim char-aset a i c)   

defmethod length (a:CharArray) -> Int :
   ($prim alen a)

;                     Looping
;                     =======

defmethod do (f: Char -> ?, xs:CharArray) :
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(xs[i])
         loop(i + 1, n - 1)
   loop(0, length(xs))

;============================================================
;=================== StringBuffer ===========================
;============================================================

;                     Interface
;                     =========

public defmulti add (s:StringBuffer, c:Char) -> False
public defmulti add-all (s:StringBuffer, c:Seqable<Char>) -> False
public defmulti clear (s:StringBuffer) -> False

;               Abstract Implementation
;               =======================

defmethod add-all (s:StringBuffer, xs:Seqable<Char>) :
   do(add{s, _}, xs)

defmethod print (s:StringBuffer, c:Char) :
   add(s, c)

defmethod print-all (s:StringBuffer, cs:String|StringBuffer|CharArray) :
   add-all(s, cs)

defmethod print (o:OutputStream, s:StringBuffer) :
   print-all(o, s)

defmethod write (o:OutputStream, s:StringBuffer) :
   print(o, '"')
   for c in s do :
      escape-for-string(o, c)
   print(o, '"')   

;                   Implementation
;                   ==============

public defn StringBuffer (n:Int) -> StringBuffer :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative("length", n)
   var buffer = CharArray(n)
   var len = 0

   defn ensure-capacity (c:Int) :
      defn set-capacity (c:Int) :
         val buffer* = CharArray(c)
         for i in 0 to len do :
            buffer*[i] = buffer[i]
         buffer = buffer*
      val cur-c = length(buffer)
      set-capacity(max(c, 2 * cur-c)) when c > cur-c

   new StringBuffer :
      defmethod add (this, c:Char) :
         ensure-capacity(len + 1)
         buffer[len] = c
         len = len + 1

      defmethod add-all (this, xs:Seqable<Char> & Lengthable) :
         val n = length(xs)
         ensure-capacity(len + n)
         for (x in xs, i in 0 to n) do :
            buffer[len + i] = x
         len = len + n

      defmethod clear (this) :
         len = 0

      defmethod get (this, i:Int) :
         #if-not-defined(OPTIMIZE) :
            ensure-index-in-bounds(this, i)
         buffer[i]

      defmethod set (this, i:Int, c:Char) :
         if i == len :
            add(this, c)
         else :
            #if-not-defined(OPTIMIZE) :
               ensure-index-in-bounds(this, i)
            buffer[i] = c

      defmethod length (this) :
         len

      defmethod to-string (this) :
         subchars(len, buffer)

public defn StringBuffer () :
   StringBuffer(32)

lostanza defn subchars (n:ref<Int>, b:ref<CharArray>) -> ref<String> :
   val len = n.value
   val s = String(len)
   for (var i:long = 0, i < len, i = i + 1) :
      s.chars[i] = b.chars[i]
   s.chars[len] = 0 as byte   
   return s

;============================================================
;===================== FileInfo =============================
;============================================================

;                     Interface
;                     =========

public defmulti filename (i:FileInfo) -> String
public defmulti line (i:FileInfo) -> Int
public defmulti column (i:FileInfo) -> Int

;                  Implementation
;                  ==============

public defn FileInfo (f:String, l:Int, c:Int) :
   new FileInfo :
      defmethod filename (this) : f
      defmethod line (this) : l
      defmethod column (this) : c

defmethod equal? (a:FileInfo, b:FileInfo) :
   filename(a) == filename(b) and
   line(a) == line(b) and
   column(a) == column(b)

defmethod hash (i:FileInfo) :
   hash(filename(i)) +
   7 * hash(line(i)) +
   49 * hash(column(i))

defmethod compare (a:FileInfo, b:FileInfo) :
   val c = compare(filename(a), filename(b))
   if c == 0 :
      val c = compare(line(a), line(b))
      if c == 0 :
         compare(column(a), column(b))
      else : c
   else : c

defmethod print (o:OutputStream, i:FileInfo) :   
   print(o, filename(i))
   print(o, ":")
   print(o, line(i))
   print(o, ".")
   print(o, column(i))

;============================================================
;====================== Tokens ==============================
;============================================================

;                      Interface
;                      =========

public defmulti item (t:Token) -> ?
public defmulti info (t:Token) -> FileInfo

;                     Constructor
;                     ===========

public defn Token (item, info:FileInfo) :
   new Token :
      defmethod item (this) : item
      defmethod info (this) : info

public defn unwrap-token (t) :
   match(t) :
      (t:Token) : unwrap-token(item(t))
      (t) : t

public defn unwrap-all (t) -> ? :
   match(t) :
      (t:Token) : unwrap-all(item(t))
      (t:List) : map(unwrap-all, t)
      (t) : t

defmethod print (o:OutputStream, t:Token) :
   write(o, item(t))

defmethod equal? (a:Token, b:Token) :
   equal?(item(a), item(b))


;============================================================
;==================== KeyValue Pairs ========================
;============================================================

;                       Interface
;                       =========

public defmulti key<?K> (kv:KeyValue<?K,?>) -> K
public defmulti value<?V> (kv:KeyValue<?,?V>) -> V

;                      Constructor
;                      ===========

public defn KeyValue<?K,?V> (k:?K, v:?V) -> KeyValue<K,V> :
   new KeyValue<K,V> :
      defmethod key (this) : k
      defmethod value (this) : v

defmethod print (o:OutputStream, v:KeyValue) :
   write(o, key(v))
   print(o, " => ")
   write(o, value(v))



;============================================================
;===================== Exceptions ===========================
;============================================================

public defn Exception (msg) :
   new Exception :
      defmethod print (o:OutputStream, this) :
         print(o, msg)

var CURRENT-EXCEPTION-HANDLER : Exception -> Void =
   fn (e:Exception) :
      fatal(e)

defmethod print (o:OutputStream, e:Exception) :
   print(o, "Exception")

public defn throw (e:Exception) :
   CURRENT-EXCEPTION-HANDLER(e)

defstruct ExceptionResult : (exception: Exception)
defstruct NormalResult : (result)

public defn with-exception-handler<?T> (body: () -> ?T,
                                        handler: Exception -> ?T) -> T :
   val r = label<ExceptionResult|NormalResult> break :
      let-var CURRENT-EXCEPTION-HANDLER = break{ExceptionResult(_)} :
         NormalResult(body())
   match(r) :
      (r:ExceptionResult) : handler(exception(r))
      (r:NormalResult) : result(r)

public defn with-finally<?T> (body: () -> ?T, finally: (True|False) -> ?) -> T :
   var entered? = false
   dynamic-wind(
      fn () :
         fatal("Cannot re-enter body with finally clause.") when entered?
         entered? = true
      body
      finally)


;============================================================
;================== Failure Handler =========================
;============================================================

var CURRENT-FAILURE-HANDLER : () -> Void =
   fn () :
      fatal("Uncaught failure")

public defn fail () :
   CURRENT-FAILURE-HANDLER()

public defn with-attempt<?T> (conseq: () -> ?T, alt: () -> ?T) :
   val result = label<Maybe<T>> return :
      let-var CURRENT-FAILURE-HANDLER = fn* () : return(None()) :
         One(conseq())
   match(result) :
      (r:One<T>) : value(r)
      (r:None) : alt()

;============================================================
;==================== Conversions ===========================
;============================================================

;                 Numeric Conversions
;                 ===================

public lostanza defn to-byte (b:ref<Byte>) -> ref<Byte> : return b
public lostanza defn to-byte (c:ref<Char>) -> ref<Byte> : return new Byte{c.value}
public lostanza defn to-byte (i:ref<Int>) -> ref<Byte> : return new Byte{i.value as byte}
public lostanza defn to-byte (l:ref<Long>) -> ref<Byte> : return new Byte{l.value as byte}
public lostanza defn to-byte (f:ref<Float>) -> ref<Byte> : return new Byte{f.value as byte}
public lostanza defn to-byte (d:ref<Double>) -> ref<Byte> : return new Byte{d.value as byte}
public lostanza defn to-char (b:ref<Byte>) -> ref<Char> : return new Char{b.value}
public lostanza defn to-char (c:ref<Char>) -> ref<Char> : return c
public lostanza defn to-char (i:ref<Int>) -> ref<Char> : return new Char{i.value as byte}
public lostanza defn to-int (b:ref<Byte>) -> ref<Int> : return new Int{b.value}
public lostanza defn to-int (c:ref<Char>) -> ref<Int> : return new Int{c.value}
public lostanza defn to-int (i:ref<Int>) -> ref<Int> : return i
public lostanza defn to-int (l:ref<Long>) -> ref<Int> : return new Int{l.value as int}
public lostanza defn to-int (f:ref<Float>) -> ref<Int> : return new Int{f.value as int}
public lostanza defn to-int (d:ref<Double>) -> ref<Int> : return new Int{d.value as int}
public lostanza defn to-long (b:ref<Byte>) -> ref<Long> : return new Long{b.value}
public lostanza defn to-long (i:ref<Int>) -> ref<Long> : return new Long{i.value}
public lostanza defn to-long (l:ref<Long>) -> ref<Long> : return l
public lostanza defn to-long (f:ref<Float>) -> ref<Long> : return new Long{f.value as long}
public lostanza defn to-long (d:ref<Double>) -> ref<Long> : return new Long{d.value as long}
public lostanza defn to-float (b:ref<Byte>) -> ref<Float> : return new Float{b.value as float}
public lostanza defn to-float (i:ref<Int>) -> ref<Float> : return new Float{i.value as float}
public lostanza defn to-float (l:ref<Long>) -> ref<Float> : return new Float{l.value as float}
public lostanza defn to-float (f:ref<Float>) -> ref<Float> : return f
public lostanza defn to-float (d:ref<Double>) -> ref<Float> : return new Float{d.value as float}
public lostanza defn to-double (b:ref<Byte>) -> ref<Double> : return new Double{b.value as double}
public lostanza defn to-double (i:ref<Int>) -> ref<Double> : return new Double{i.value as double}
public lostanza defn to-double (l:ref<Long>) -> ref<Double> : return new Double{l.value as double}
public lostanza defn to-double (f:ref<Float>) -> ref<Double> : return new Double{f.value}
public lostanza defn to-double (d:ref<Double>) -> ref<Double> : return d

;                Numeric Reinterpretations
;                =========================

public lostanza defn bits (f:ref<Float>) -> ref<Int> :
   val v = f.value
   return new Int{($ls-prim bits v)}

public lostanza defn bits (d:ref<Double>) -> ref<Long> :
   val v = d.value
   return new Long{($ls-prim bits v)}

public lostanza defn bits-as-float (i:ref<Int>) -> ref<Float> :
   val v = i.value
   return new Float{($ls-prim fnum v)}

public lostanza defn bits-as-double (i:ref<Long>) -> ref<Double> :
   val v = i.value
   return new Double{($ls-prim fnum v)}


;============================================================
;==================== Number Parsing ========================
;============================================================

;                        Drivers
;                        =======

public defn to-byte (s:String) -> False|Byte :
   match(to-int(s)) :
      (i:Int) : to-byte(i) when i >= 0 and i <= 255
      (i:False) : false

public lostanza defn to-int (s:ref<String>) -> ref<False|Int> :
   if prefix?(s, "-") :
      return neg-to-int(s, 1, 10)
   else if prefix?(s, "0x") :
      return bits-to-int(s, 2, 16, 4)
   else if prefix?(s, "0o") :
      return bits-to-int(s, 2, 8, 3)
   else if prefix?(s, "0b") :
      return bits-to-int(s, 2, 2, 1)
   else :
      return pos-to-int(s, 0, 10)

public lostanza defn to-long (s:ref<String>) -> ref<False|Long> :
   if prefix?(s, "-") :
      return neg-to-long(s, 1, 10)
   else if prefix?(s, "0x") :
      return bits-to-long(s, 2, 16, 4)
   else if prefix?(s, "0o") :
      return bits-to-long(s, 2, 8, 3)
   else if prefix?(s, "0b") :
      return bits-to-long(s, 2, 2, 1)
   else :
      return pos-to-long(s, 0, 10)

;TODO: This is necessary because addresses of local variables don't work yet.
lostanza var DOUBLE-BUFFER : double
lostanza var CHAR-BUFFER : byte
public lostanza defn to-double (s:ref<String>) -> ref<False|Double> :
   val n = call-c clib/sscanf(addr!(s.chars), "%lf%c", addr(DOUBLE-BUFFER), addr(CHAR-BUFFER))
   if n != 1 : return false
   else : return new Double{DOUBLE-BUFFER}

lostanza var FLOAT-BUFFER : float
public lostanza defn to-float (s:ref<String>) -> ref<False|Float> :
   val n = call-c clib/sscanf(addr!(s.chars), "%f%c", addr(FLOAT-BUFFER), addr(CHAR-BUFFER))
   if n != 1 : return false
   else : return new Float{FLOAT-BUFFER}

;                        Utilities
;                        =========

lostanza defn* prefix? (str:ref<String>, prefix:ptr<byte>) -> int :
   for (var i:long = 0, 1, i = i + 1) :
      if prefix[i] == 0 : return 1
      else if str.chars[i] == 0 : return 0
      else if prefix[i] != str.chars[i] : return 0
   return 0   

lostanza defn digit (c:byte, radix:int) -> int :
   var d:int
   if c >= '0' and c <= '9' : d = c - '0'
   else if c >= 'a' and c <= 'f' : d = c - 'a' + 10
   else if c >= 'A' and c <= 'F' : d = c - 'A' + 10
   else : return -1
   if d < radix : return d
   else : return -1

;                        Parsing Integers
;                        ================

lostanza defn pos-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
   var n:int = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Int{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = n * radix + d
            if n < 0 : return false
   fatal("Unreachable")
   return false

lostanza defn neg-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
   var n:int = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Int{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = n * radix - d
            if n > 0 : return false
   fatal("Unreachable")
   return false

lostanza defn bits-to-int (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Int> :
   var n:int = 0
   var nbits:int = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Int{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = (n << bits) | d
            nbits = nbits + bits
            if nbits >= 32 + bits : return false
   fatal("Unreachable")
   return false

;                        Parsing Longs
;                        =============

lostanza defn pos-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
   var n:long = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Long{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = n * radix + d
            if n < 0 : return false
   fatal("Unreachable")
   return false

lostanza defn neg-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
   var n:long = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Long{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = n * radix - d
            if n > 0 : return false
   fatal("Unreachable")
   return false

lostanza defn bits-to-long (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Long> :
   var n:long = 0
   var nbits:int = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Long{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = (n << bits) | d
            nbits = nbits + bits
            if nbits >= 64 + bits : return false
   fatal("Unreachable")
   return false

;============================================================
;==================== Arithmetic ============================
;============================================================

public defn max<?T> (a:?T&Comparable<?T>, b:T&Comparable) -> T :
   b when a < b else a

public defn min<?T> (a:?T&Comparable<?T>, b:T&Comparable) -> T :
   a when a < b else b

public defn minimum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
   reduce{_, xs} $ fn (x, y) :
      if x < y : x
      else : y

public defn minimum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
   reduce{_, x0, xs} $ fn (x, y) :
      if x < y : x
      else : y

public defn maximum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
   reduce{_, xs} $ fn (x, y) :
      if x < y : y
      else : x

public defn maximum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
   reduce{_, x0, xs} $ fn (x, y) :
      if x < y : y
      else : x

public defn minimum<?T> (xs:Seqable<?T&Comparable>) -> T : minimum(xs, less?)
public defn maximum<?T> (xs:Seqable<?T&Comparable>) -> T : maximum(xs, less?)

public defn minimum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : minimum(x0, xs, less?)
public defn maximum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : maximum(x0, xs, less?)

public defn minimum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T : minimum(xs, {key(_) < key(_)})
public defn maximum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T : maximum(xs, {key(_) < key(_)})


;TODO: Remove uses of to-long, to-float with literals
public defn abs (a:Int) -> Int : (- a) when a < 0 else a
public defn abs (a:Long) -> Long : (- a) when a < 0L else a
public defn abs (a:Float) -> Float : (- a) when a < 0.0f else a
public defn abs (a:Double) -> Double : (- a) when a < 0.0 else a

public lostanza defn rand () -> ref<Int> :
   val i = call-c clib/rand()
   return new Int{i}

public defn rand (n:Int) :
   #if-not-defined(OPTIMIZE) :
      ensure-positive("limit", n)
   rand() % n

public defn rand (r:Range) :
   val s = start(r)
   match(end(r), inclusive?(r)) :
      (e:Int, inc:True) :
         #if-not-defined(OPTIMIZE) :
            ensure-start-before-end(s, e)
         rand(e + 1 - s) + s
      (e:Int, inc:False) :
         #if-not-defined(OPTIMIZE) :
            if e == s : fatal("Empty range.")
            else : ensure-start-before-end(s, e)
         rand(e - s) + s
      (e:False, inc) :
         fatal("Unbounded range.")

public defn ceil-log2 (i:Int) -> Int :
   defn* loop (n:Int, l:Int) :
      if i > n :
         if l == 30 : l + 1
         else : loop(n << 1, l + 1)
      else : l
   fatal("Log of non-positive number!") when i <= 0
   loop(1, 0)

public defn floor-log2 (i:Int) -> Int :
   defn* loop (n:Int, l:Int) :
      if i == n : l
      else if i < n : l - 1
      else if l == 30 : l
      else : loop(n << 1, l + 1)
   fatal("Log of non-positive number!") when i <= 0
   loop(1, 0)

public defn ceil-log2 (i:Long) -> Int :
   defn* loop (n:Long, l:Int) :
      if i > n :
         if l == 62 : l + 1
         else : loop(n << to-long(1), l + 1)
      else : l
   fatal("Log of non-positive number!") when i <= to-long(0)
   loop(to-long(1), 0)

public defn floor-log2 (i:Long) -> Int :
   defn* loop (n:Long, l:Int) :
      if n == i : l
      else if i < n : l - 1
      else if l == 62 : l
      else : loop(n << to-long(1), l + 1)
   fatal("Log of non-positive number!") when i <= to-long(0)
   loop(to-long(1), 0)

public defn next-pow2 (i:Int) -> Int :
   val n = ceil-log2(i)
   if n <= 30 : 1 << n
   else : fatal("Overflow")

public defn prev-pow2 (i:Int) -> Int :
   1 << floor-log2(i)

public defn next-pow2 (i:Long) -> Long :
   val n = ceil-log2(i)
   if n <= 62 : to-long(1) << to-long(n)
   else : fatal("Overflow")

public defn prev-pow2 (i:Long) -> Long :
   to-long(1) << to-long(floor-log2(i))

public defn sum (xs: Seqable<Int>) -> Int : reduce(plus, 0, xs)
public defn sum (xs: Seqable<Long>) -> Long : reduce(plus, 0L, xs)
public defn sum (xs: Seqable<Float>) -> Float : reduce(plus, 0.0f, xs)
public defn sum (xs: Seqable<Double>) -> Double : reduce(plus, 0.0, xs)

public defn product (xs: Seqable<Int>) -> Int : reduce(times, 1, xs)
public defn product (xs: Seqable<Long>) -> Long : reduce(times, 0L, xs)
public defn product (xs: Seqable<Float>) -> Float : reduce(times, 1.0f, xs)
public defn product (xs: Seqable<Double>) -> Double : reduce(times, 1.0, xs)


;============================================================
;================== Sequence Library ========================
;============================================================

public defmulti do<?T> (f:T -> ?, xs:Seqable<?T>) -> False
public defmulti do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False
public defmulti do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False

defmethod do<?T> (f:T -> ?, xs:Seqable<?T>) -> False :
   for xs-seq in xs do-seq :
      while not empty?(xs-seq) :
         f(next(xs-seq))

defmethod do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         while (not empty?(xs-seq)) and (not empty?(ys-seq)) :
            f(next(xs-seq), next(ys-seq))

defmethod do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            while (not empty?(xs-seq)) and (not empty?(ys-seq)) and (not empty?(zs-seq)) :
               f(next(xs-seq), next(ys-seq), next(zs-seq))

public defn seq<?T,?S> (f:T -> ?S, xs:Seqable<?T>) -> Seq<S> :
   match(xs) :
      (xs:Seq<T> & Lengthable) :
         new Seq<S> & Lengthable :
            defmethod empty? (this) : empty?(xs)
            defmethod next (this) : f(next(xs))
            defmethod peek (this) : f(peek(xs))
            defmethod close (this) : close(xs)
            defmethod length (this) : length(xs)
      (xs:Seq<T>) :
         new Seq<S> :
            defmethod empty? (this) : empty?(xs)
            defmethod next (this) : f(next(xs))
            defmethod peek (this) : f(peek(xs))
            defmethod close (this) : close(xs)
      (xs) :
         seq(f, to-seq(xs))

public defn seq<?T,?S,?R> (f:(T,S) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   match(xs, ys) :
      (xs:Seq<T> & Lengthable, ys:Seq<S> & Lengthable) :
         var len = min(length(xs), length(ys))
         new Seq<R> & Lengthable :
            defmethod empty? (this) :
               empty?(xs) or empty?(ys)
            defmethod next (this) :
               len = len - 1
               f(next(xs), next(ys))
            defmethod peek (this) :
               f(peek(xs), peek(ys))
            defmethod close (this) :
               len = 0
               close(xs)
               close(ys)
            defmethod length (this) :
               len
      (xs:Seq<T>, ys:Seq<S>) :
         new Seq<R> :
            defmethod empty? (this) : empty?(xs) or empty?(ys)
            defmethod next (this) : f(next(xs), next(ys))
            defmethod peek (this) : f(peek(xs), peek(ys))
            defmethod close (this) : (close(xs), close(ys))
      (xs, ys) :
         seq(f, to-seq(xs), to-seq(ys))


public defn seq<?T,?S,?U,?R> (f:(T,S,U) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   match(xs, ys, zs) :
      (xs:Seq<T> & Lengthable, ys:Seq<S> & Lengthable, zs:Seq<U> & Lengthable) :
         var len = min(min(length(xs), length(ys)), length(zs))
         new Seq<R> & Lengthable :
            defmethod empty? (this) :
               empty?(xs) or empty?(ys) or empty?(zs)
            defmethod next (this) :
               len = len - 1
               f(next(xs), next(ys), next(zs))
            defmethod peek (this) :
               f(peek(xs), peek(ys), peek(zs))
            defmethod close (this) :
               len = 0
               close(xs)
               close(ys)
               close(zs)
            defmethod length (this) :
               len
      (xs:Seq<T>, ys:Seq<S>, zs:Seq<U>) :
         new Seq<R> :
            defmethod empty? (this) : empty?(xs) or empty?(ys) or empty?(zs)
            defmethod next (this) : f(next(xs), next(ys), next(zs))
            defmethod peek (this) : f(peek(xs), peek(ys), peek(zs))
            defmethod close (this) : (close(xs), close(ys), close(zs))
      (xs, ys, zs) :
         seq(f, to-seq(xs), to-seq(ys), to-seq(zs))

public defn contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False :
   label<False|True> return :
      for x in xs do :
         return(true) when x == y

public defn find<?T> (f: T -> True|False, xs:Seqable<?T>) -> T|False :
   label<False|T> return :
      for x in xs do :
         return(x) when f(x)

public defn find<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> T|False :
   label<False|T> return :
      for (x in xs, y in ys) do :
         return(x) when f(x, y)

public defn find!<?T> (f: T -> True|False, xs:Seqable<?T>) : find(f, xs) as T
public defn find!<?T, ?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : find(f, xs, ys) as T

public defn first<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Maybe<R> :
   label<Maybe<R>> return :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()      

public defn first<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Maybe<R> :
   label<Maybe<R>> return :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()      

public defn first!<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) : value!(first(f, xs))
public defn first!<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) : value!(first(f, xs, ys))

public defn seq?<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Seq<R> :
   generate<R> :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?U,?R> (f: (T,S,U) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys, z in zs) do :
         match(f(x, y, z)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn filter<?T> (f: T -> True|False, xs:Seqable<?T>) -> Seq<T> :
   generate<T> :
      for x in xs do :
         yield(x) when f(x)

public defn filter<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<T> :
   generate<T> :
      for (x in xs, y in ys) do :
         yield(x) when f(x, y)

public defn filter<?T> (xs:Seqable<?T>, sel:Seqable<True|False>) -> Seq<T> :
   for (x in xs, s in sel) filter : s

public defn index-of (xs:Seqable<Equalable>, y:Equalable) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when x == y

public defn index-of! (xs:Seqable<Equalable>, y:Equalable) : index-of(xs, y) as Int

public defn index-when<?T> (f: T -> True|False, xs:Seqable<?T>) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when f(x)

public defn index-when<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Int|False :
   label<Int|False> return :
      for (x in xs, y in ys, i in 0 to false) do :
         return(i) when f(x, y)

public defn index-when!<?T> (f: T -> True|False, xs:Seqable<?T>) : index-when(f, xs) as Int
public defn index-when!<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : index-when(f, xs, ys) as Int

public defn split<?T> (f: T -> True|False, xs: Seqable<?T>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for x in xs do :
      add{_, x} $
         if f(x) : true-xs
         else : false-xs
   [true-xs, false-xs]

public defn split<?T> (xs:Seqable<?T>, ss:Seqable<True|False>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for (x in xs, s in ss) do :
      add{_, x} $
         if s : true-xs
         else : false-xs
   [true-xs, false-xs]   

public defn take-while<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = peek(xs-seq)
               if f(x) :
                  next(xs-seq)
                  yield(x)
                  loop()
         loop()

public defn take-until<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = next(xs-seq)
               yield(x)
               loop() when not f(x)
         loop()

public defn take-n<?T> (n:Int, xs:Seqable<?T>) :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative("length", n)
   var len = n
   val xs-seq = to-seq(xs)
   new Seq<T> & Lengthable :
      defmethod next (this) :
         val v = peek(this)
         next(xs-seq)
         len = len - 1
         v
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         peek(xs-seq)
      defmethod close (this) :
         close(xs-seq)
         len = 0
      defmethod empty? (this) :
         len == 0
      defmethod length (this) :
         len

public defn cat<?T> (a:Seqable<?T>, b:Seqable<?T>) -> Seq<T> :
   cat-all([a, b])

public defn cat-all<?T> (xss: Seqable<Seqable<?T>>) -> Seq<T> :
   val ret-seq = generate<T> :
      for xs in xss do :
         do(yield, xs)
   val length? =
      if xss is Collection :
         if all?({_ is Lengthable&Seqable}, xss) :
            sum(seq(length{_ as Lengthable&Seqable}, xss))
   match(length?) :
      (l:Int) : take-n(l, ret-seq)
      (l:False) : ret-seq

public defn seq-cat<?T,?R> (f:T -> Seqable<?R>, xs:Seqable<?T>) -> Seq<R> :
   cat-all(seq(f, xs))

public defn seq-cat<?T,?S,?R> (f:(T,S) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   cat-all(seq(f, xs, ys))

public defn seq-cat<?T,?S,?U,?R> (f:(T,S,U) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   cat-all(seq(f, xs, ys, zs))

public defn all?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   for xs-seq in xs do-seq :
      defn* loop () :
         if empty?(xs-seq) : true
         else : pred?(next(xs-seq)) and loop()
      loop()

public defn all?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         defn* loop () :
            if empty?(xs-seq) or empty?(ys-seq) : true
            else : pred?(next(xs-seq), next(ys-seq)) and loop()
         loop()

public defn all?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            defn* loop () :
               if empty?(xs-seq) or empty?(ys-seq) or empty?(zs-seq) : true
               else : pred?(next(xs-seq), next(ys-seq), next(zs-seq)) and loop()
            loop()

public defn none?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   defn notp (x) : not pred?(x)
   all?(notp, xs)

public defn none?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   defn notp (x1, x2) : not pred?(x1, x2)
   all?(notp, xs, ys)

public defn none?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   defn notp (x1, x2, x3) : not pred?(x1, x2, x3)
   all?(notp, xs, ys, zs)

public defn any?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   not none?(pred?, xs)

public defn any?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   not none?(pred?, xs, ys)

public defn any?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   not none?(pred?, xs, ys, zs)

public defn count (xs:Seqable) -> Int :
   match(xs) :
      (xs:Seqable & Lengthable) :
         length(xs)
       (xs) :
         var accum:Int = 0
         for x in xs do :
            accum = accum + 1
         accum

public defn count<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> Int :
   var accum:Int = 0
   for x in xs do :
      if pred?(x) : accum = accum + 1
   accum

public defn join<?T,?S> (xs:Seqable<?T>, y:?S) -> Seq<T|S> :
   val ret-seq = generate<T|S> :
      val xs-seq = to-seq(xs)
      yield(next(xs-seq)) when not empty?(xs-seq)
      while not empty?(xs-seq) :
         yield(y)
         yield(next(xs-seq))
   match(xs) :
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val n* = n + max(0, n - 1)
         take-n(n*, ret-seq)
      (xs) : ret-seq

public defn reduce<?T,?S,?U> (f: (T|U, S) -> ?U, x0: ?T, xs:Seqable<?S>) -> T|U :
   var accum = x0
   for x in xs do :
      accum = f(accum, x)
   accum

public defn reduce<?T,?S> (f: (T|S, T) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      reduce(f, next(xs-seq), xs-seq)

public defn reduce-right<?T,?S,?U> (f: (S, T|U) -> ?U, xn:?T, xs:Seqable<?S>) -> T|U :
   for xs-seq in xs do-seq :
      defn loop () :
         if empty?(xs-seq) : xn
         else : f(next(xs-seq), loop())
      loop()   

public defn reduce-right<?T,?S> (f: (T, T|S) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      defn loop (x:T) :
         if empty?(xs-seq) : x
         else : f(x, loop(next(xs-seq)))
      loop(next(xs-seq))         

public defn repeat<?T> (x:?T) -> Seq<T> :
   var closed? = false
   new Seq<T> :
      defmethod next (this) :
         peek(this)
      defmethod peek (this) :
         fatal("Closed Sequence") when closed?
         x
      defmethod empty? (this) :
         closed?
      defmethod close (this) :
         closed? = true

public defn repeat<?T> (x:?T, n:Int) :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative("length", n)
   var len = n
   new Seq<T> & Lengthable :
      defmethod next (this) :
         fatal("Empty Sequence") when len == 0
         len = len - 1
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         x
      defmethod empty? (this) :
         len == 0
      defmethod close (this) :
         len = 0
      defmethod length (this) :
         len         

public defn repeat-while<?T> (f: () -> Maybe<?T>) -> Seq<T> :
   var item = sentinel
   defn fill () :
      if item is Sentinel :
         item = f()

   new Seq<T> :
      defmethod next (this) :
         val x = peek(this)
         item = sentinel
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         value(item as One<T>)
      defmethod empty? (this) :
         fill()
         item is None
      defmethod close (this) :
         item = None()

public defn repeatedly<?T> (f:() -> ?T) -> Seq<T> :
   var item = sentinel
   var closed? = false
   defn fill () :
      if item is Sentinel :
         item = f()
   defn empty () :
      val x = item as T
      item = sentinel
      x   

   new Seq<T> :
      defmethod next (this) :
         fatal("Closed Sequence") when closed?
         fill()
         empty()
      defmethod peek (this) :
         fatal("Closed Sequence") when closed?
         fill()
         item as T
      defmethod empty? (this) :
         closed?
      defmethod close (this) :
         closed? = true

public defn repeatedly<?T> (f:() -> ?T, n:Int) :
   take-n(n, repeatedly(f))

public defn zip<?T,?S> (xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<[T,S]> :
   for (x in xs, y in ys) seq : [x, y]

public defn zip<?T,?S,?U> (xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<[T,S,U]> :
   for (x in xs, y in ys, z in zs) seq : [x, y, z]

public defn zip-all<?T> (xs:Seqable<Seqable<?T>>) :
   val seqs = to-tuple(seq(to-seq, xs))
   fatal("No Sequences Given") when empty?(seqs)
   val ret-seq = new Seq<Tuple<T>> :
      defmethod next (this) :
         map(next, seqs)
      defmethod peek (this) :
         map(peek, seqs)
      defmethod empty? (this) :
         any?(empty?, seqs)
      defmethod close (this) :
         do(close, seqs)
   if all?({_ is Lengthable&Seqable}, seqs) :
      val n = minimum(seq(length{_ as Lengthable&Seqable}, seqs))
      take-n(n, ret-seq)
   else :
      ret-seq

;TODO: Use hash when possible
public defn unique<?T> (xs:Seqable<?T&Equalable>) -> List<T> :
   val ys = Vector<T&Equalable>()
   for x in xs do :
      add(ys, x) when not contains?(ys, x)
   to-list(ys)

public defn lookup?<?K,?V,?D> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable, default:?D) -> D|V :
   label<V|D> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      default   

public defn lookup?<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> False|V :
   lookup?(xs, k, false)

public defn lookup<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> V :
   label<V> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      fatal("Key %~ not found in entries." % [k])

public defn parallel-seq<?T,?X,?Y> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y) -> [X,Y] :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val fco = make-co(f)
   val gco = make-co(g)
   
   ;Store function results
   var fresult = resume(fco, None())
   var gresult = resume(gco, None())

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         if fresult is None :
            fresult = resume(fco, v)
         if gresult is None :
            gresult = resume(gco, v)
         (fresult is None) or
         (gresult is None)
      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   [value!(fresult),
    value!(gresult)]

public defn parallel-seq<?T,?X,?Y,?Z> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y, h:Seq<T> -> ?Z) -> [X,Y,Z] :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val fco = make-co(f)
   val gco = make-co(g)
   val hco = make-co(h)
   
   ;Store function results
   var fresult = resume(fco, None())
   var gresult = resume(gco, None())
   var hresult = resume(hco, None())

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         if fresult is None :
            fresult = resume(fco, v)
         if gresult is None :
            gresult = resume(gco, v)
         if hresult is None :
            hresult = resume(hco, v)
         (fresult is None) or
         (gresult is None) or
         (hresult is None)
      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   [value!(fresult),
    value!(gresult),
    value!(hresult)]

public defn parallel-seq<?T,?S> (xs:Seqable<?T>, fs:Collection<(Seq<T> -> ?S)>) -> Tuple<S> :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val cos = to-tuple(seq(make-co, fs))
   
   ;Store function results
   val results = to-array<Maybe<S>>(seq(resume{_, None()}, cos))

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         var more? = false
         for (co in cos, i in 0 to false) do :
            if results[i] is None :
               val r = resume(co, v)
               results[i] = r
               more? = more? or (r is None)
         more?         

      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   to-tuple(seq(value!, results))

;============================================================
;==================== List Library ==========================
;============================================================

public defn* get<?T> (xs:List<?T>, i:Int) -> T :
   if i == 0 : head(xs)
   else : get(tail(xs), i - 1)

public defn headn<?T> (l:List<?T>, n:Int) -> List<T> :
   if n == 0 : List()
   else : cons(head(l), headn(tail(l), n - 1))

public defn* tailn<?T> (l:List<?T>, n:Int) -> List<T> :
   if n == 0 : l
   else : tailn(tail(l), n - 1)

public defn append<?T> (xs:Seqable<?T>, ys:List<?T>) -> List<T> :
   match(xs) :
      (xs:List<T>) :
         defn loop (xs:List<T>) :
            if empty?(xs) : ys
            else : cons(head(xs), loop(tail(xs)))
         if empty?(ys) : xs
         else : loop(xs)
      (xs) :
         val xs-seq = to-seq(xs)
         defn loop () :
            if empty?(xs-seq) : ys
            else : cons(next(xs-seq), loop())
         loop()   

public defn append-all<?T> (xs:Seqable<List<?T>>) -> List<T> :
   val xs-seq = to-seq(xs)
   defn loop () :
      if empty?(xs-seq) : List()
      else : append(next(xs-seq), loop())
   loop()

public defn seq-append<?T,?R> (f: T -> List<?R>, xs:Seqable<?T>) -> List<R> :
   append-all(seq(f, xs))

public defn seq-append<?T,?S,?R> (f: (T,S) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> List<R> :
   append-all(seq(f, xs, ys))

public defn seq-append<?T,?S,?U,?R> (f: (T,S,U) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R> :
   append-all(seq(f, xs, ys, zs))

public defn map<?T,?R> (f: T -> ?R, xs:List<?T>) -> List<R> :
   if empty?(xs) : List()
   else : cons(f(head(xs)), map(f, tail(xs)))

public defn map<?T,?S,?R> (f: (T,S) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>) -> List<R> :
   to-list(seq(f, xs, ys))

public defn map<?T,?S,?U,?R> (f: (T,S,U) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R> :
   to-list(seq(f, xs, ys, zs))

public defn transpose<?T> (xs:List<List<?T>>) -> List<List<T>> :
   if empty?(xs) :
      List()
   else if any?(empty?, xs) :
      List()
   else :
      val hs = map(head, xs)
      val ts = map(tail, xs)
      cons(hs, transpose(ts))

public defn last<?T> (xs:List<?T>) -> T :
   fatal("Empty List") when empty?(xs)
   defn* loop (xs:List<T>) :
      if empty?(tail(xs)) : head(xs)
      else : loop(tail(xs))
   loop(xs)

public defn but-last<?T> (xs:List<?T>) -> List<T> :
   fatal("Empty List") when empty?(xs)
   defn* loop (xs:List<T>) :
      if empty?(tail(xs)) : List()
      else : cons(head(xs), but-last(tail(xs)))
   loop(xs)

public defn reverse<?T> (xs:List<?T>) -> List<T> :
   if empty?(xs) :
      xs
   else :
      var accum = List()
      for x in xs do :
         accum = cons(x, accum)
      accum


;============================================================
;=================== String Library =========================
;============================================================

public defn matches? (a:String, start:Int, b:String) :
   #if-not-defined(OPTIMIZE) :
      ensure-index-in-bounds(a, start)
   val an = length(a)
   val bn = length(b)
   if bn <= an :
      for i in 0 to bn all? :
         a[start + i] == b[i]

public defn prefix? (s:String, prefix:String) :
   matches?(s, 0, prefix)

public defn suffix? (s:String, suffix:String) :
   val start = max(0, length(s) - length(suffix))
   matches?(s, start, suffix)

public defn empty? (s:String) :
   length(s) == 0
      
lostanza defn substring! (str:ref<String>, b:ref<Int>, e:ref<Int>) -> ref<String> :
   val s = b.value
   val n = e.value - s
   val ret = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      ret.chars[i] = str.chars[i + s]
   ret.chars[n] = 0 as byte
   return ret

public defn get (s:String, r:Range) -> String :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   substring!(s, b, e)

public lostanza defn append (a:ref<String>, b:ref<String>) -> ref<String> :
   val al = a.length
   val bl = b.length
   val n = al + bl
   val s = String(n)
   for (var i:long = 0, i < al, i = i + 1) :
      s.chars[i] = a.chars[i]
   for (var i:long = 0, i < bl, i = i + 1) :
      s.chars[al + i] = b.chars[i]
   s.chars[n] = 0 as byte   
   return s   

public defn append-all (xs:Seqable<String>) -> String :
   val xs-seq = to-seq(xs)
   if empty?(xs-seq) : ""
   else : reduce(append, xs-seq)

public defn string-join (xs:Seqable) -> String :
   val s = StringBuffer()
   print-all(s, xs)
   to-string(s)

public defn string-join (xs:Seqable, j) -> String :
   string-join(join(xs, j))

public defn index-of-char (s:String, r:Range, c:Char) -> False|Int :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   for i in b to e find :
      s[i] == c

public defn index-of-char (s:String, c:Char) -> False|Int :
   index-of-char(s, 0 to false, c)

public defn index-of-chars (a:String, r:Range, b:String) -> False|Int :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(a, r)
   val [s, e] = range-bound(a, r)
   val an = e - s
   val bn = length(b)
   if bn <= an :
      for i in s to (e - bn) find :
         matches?(a, i, b)

public defn index-of-chars (a:String, b:String) -> False|Int :
   index-of-chars(a, 0 to false, b)

public defn last-index-of-char (s:String, r:Range, c:Char) -> False|Int :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   for i in (e - 1) through b by -1 find :
      s[i] == c

public defn last-index-of-char (s:String, c:Char) -> False|Int :
   last-index-of-char(s, 0 to false, c)

public defn last-index-of-chars (a:String, r:Range, b:String) -> False|Int :
   #if-not-defined(OPTIMIZE) :
      ensure-index-range(a, r)
   val [s, e] = range-bound(a, r)
   val an = e - s
   val bn = length(b)
   if bn <= an :
      for i in (e - bn - 1) through s by -1 find :
         matches?(a, i, b)

public defn last-index-of-chars (a:String, b:String) -> False|Int :
   last-index-of-chars(a, 0 to false, b)

public lostanza defn replace (s:ref<String>, c1:ref<Char>, c2:ref<Char>) -> ref<String> :
   val b1 = c1.value
   val b2 = c2.value
   val n = s.length
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc == b1 : r.chars[i] = b2
      else : r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public defn replace (str:String, s1:String, s2:String) -> String :
   fatal("String to be replaced cannot be empty.") when empty?(s1)      
   val buf = StringBuffer(length(str))
   val n = length(str)
   val s1n = length(s1)
   defn* loop (i:Int) :
      if i < n :
         if matches?(str, i, s1) :
            print(buf, s2)
            loop(i + s1n)
         else :
            print(buf, str[i])
            loop(i + 1)
   loop(0)
   to-string(buf)

public defn split (str:String, s:String) -> Seq<String> :
   generate<String> :
      val strl = length(str)
      val sl = length(s)
      defn loop (b:Int) :
         if b < strl :
            match(index-of-chars(str, b to false, s)) :
               (i:Int) :
                  yield(str[b to i]) when b > 0
                  loop(i + sl)
               (i:False) :
                  yield(str[b to false])
      loop(0)

public defn split (str:String, s:String, n:Int) -> Seq<String> :
   if n <= 0 :
      fatal("Maximum number of splits (%_) is not positive." % [n])
   generate<String> :
      val strl = length(str)
      val sl = length(s)
      defn loop (b:Int, n:Int) :
         if b < strl :
            if n > 1 :
               match(index-of-chars(str, b to false, s)) :
                  (i:Int) :
                     yield(str[b to i]) when b > 0
                     loop(i + sl, n - 1)
                  (i:False) :
                     yield(str[b to false])
            else :
               yield(str[b to false])
      loop(0, n)

public lostanza defn lower-case (s:ref<String>) -> ref<String> :
   val n = s.length
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc >= 'A' and sc <= 'Z' :
         r.chars[i] = sc - 'A' + 'a'
      else :
         r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public lostanza defn upper-case (s:ref<String>) -> ref<String> :
   val n = s.length
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc >= 'a' and sc <= 'z' :
         r.chars[i] = sc - 'a' + 'A'
      else :
         r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public defn trim (s:String) -> String :
   defn not-whitespace? (c:Char) :
      (c != ' ') and
      (c != '\n') and
      (c != TAB-CHAR) and
      (c != BACKSPACE-CHAR) and
      (c != CARRIAGE-RETURN-CHAR)
   match(index-when(not-whitespace?, s)) :
      (i:Int) :
         val n = length(s)
         val j = for i in (n - 1) through 0 by -1 find! :
            not-whitespace?(s[i])
         s[i through j]   
      (i:False) : ""

;============================================================
;================= String Backed Symbol =====================
;============================================================

;                       Interface
;                       =========

public defmulti prefix (a:Symbol) -> String
public defmulti qualified? (a:Symbol) -> True|False
public defmulti qualifier (a:Symbol) -> [False|Symbol, Symbol]

defmethod equal? (a:Symbol, b:Symbol) -> True|False :
   ($prim identical? a b)

;                    General Functions
;                    =================

public defn prefix? (a:Symbol, p:String) -> True|False :
   prefix?(prefix(a), p)

;                     Initialization
;                     ==============

var INITIALIZATION-SYMBOLS: List<Symbol>

defn initialize-pre-symbol-table () :
   INITIALIZATION-SYMBOLS = List()

defn init-symbol (str:String) :
   val sym = for s in INITIALIZATION-SYMBOLS find :
      prefix(s) == str
   match(sym) :
      (sym:Symbol) :
         sym
      (sym:False) :
         val sym* = StringSymbol(str)
         INITIALIZATION-SYMBOLS = cons(sym*, INITIALIZATION-SYMBOLS)
         sym*


;                    Symbol Interning
;                    ================

var INTERNED-SYMBOLS : HashTable<String,Symbol>

defn initialize-symbol-table () :
   INTERNED-SYMBOLS = HashTable<String,Symbol>()
   for s in INITIALIZATION-SYMBOLS do :
      INTERNED-SYMBOLS[prefix(s)] = s
   INITIALIZATION-SYMBOLS = List()   

public defn to-symbol (x) :
   match(x) :
      (x:Symbol) :
         x
      (x:String) :
         match(get?(INTERNED-SYMBOLS, x)) :
            (v:Symbol) :
               v
            (v:False) :
               val sym = StringSymbol(x)
               INTERNED-SYMBOLS[x] = sym
               sym
      (x) :
         to-symbol(to-string(x))

public defn symbol-join (xs:Seqable) -> Symbol :
   to-symbol(string-join(xs))

;                    String Backed Symbol
;                    ====================

defn StringSymbol (s:String) :
   new Symbol :
      defmethod qualified? (this) :
         contains?(s, '/')
      defmethod qualifier (this) :
         match(last-index-of-char(s, '/')) :
            (i:Int) :
               val part1 = to-symbol(s[0 to i])
               val part2 = to-symbol(s[(i + 1) to false])
               [part1, part2]
            (i:False) :
               [false, this]
      defmethod hash (this) :
         hash(s)
      defmethod print (o:OutputStream, this) :
         print(o, s)
      defmethod to-string (this) :
         s
      defmethod prefix (this) :
         s
      defmethod write (o:OutputStream, this) :
         if symbol-needs-escape?(s) :
            print(o, "\\|")
            for c in s do :
               escape-for-symbol(o, c)
            print(o, '|')
         else :
            print(o, s)

;                       Generated Symbol
;                       ================

val ID-COUNTER = to-seq(0 to false)

public defn gensym (x) :
   match(x) :
      (x:Symbol) :
         gensym(prefix(x))
      (s:String) :
         val id = genid()
         new Symbol :
            defmethod qualified? (this) : false
            defmethod qualifier (this) : [false, this]
            defmethod hash (this) : hash(s) + (7 * id)
            defmethod prefix (this) : s   
            defmethod print (o:OutputStream, this) :
               print(o, s)
               print(o, id)
            defmethod write (o:OutputStream, this) :
               if symbol-needs-escape?(s) :
                  print(o, "\\|")
                  for c in s do :
                     escape-for-symbol(o, c)
                  print(o, id)
                  print(o, '|')
               else :
                  print(o, s)
                  print(o, id)
      (x) :
         gensym(to-string(x))

public defn gensym () :
   gensym("$gen")

public defn genid () :
   next(ID-COUNTER)


;============================================================
;=================== Pretty Printer =========================
;============================================================

;                  General Interface
;                  =================

public defmulti write (o:OutputStream, x) -> False

;                Default Implementation
;                ======================

defmethod write (o:OutputStream, x) :
   print(o, x)

public defn write-all (o:OutputStream, xs:Seqable) -> False :
   val xs-seq = to-seq(xs)
   if not empty?(xs-seq) :
      write(o, next(xs-seq))
   while not empty?(xs-seq) :
      print(o, " ")
      write(o, next(xs-seq))

;                    Escape Sequences
;                    ================

defn general-escape (o:OutputStream, c:Char) :
   defn escape (c:Char) :
      print(o, '\\')
      print(o, c)
   switch {c == _} :
      TAB-CHAR : escape('t')
      BACKSPACE-CHAR : escape('b')
      CARRIAGE-RETURN-CHAR : escape('r')
      '\n' : escape('n')
      '\\' : escape('\\')
      else : print(o, c)

defn escape-for-string (o:OutputStream, c:Char) :
   if c == '"' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)   

defn escape-for-symbol (o:OutputStream, c:Char) :
   if c == '|' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)   

defn escape-for-char (o:OutputStream, c:Char) :
   if c == '\'' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)   

;              Determination Whether Symbol Requires Escape
;              ============================================

lostanza var SYMBOL-CHARS:ref<String>
lostanza var OPERATOR-CHARS:ref<String>

lostanza defn tag-char (table:ref<String>, c:byte) -> int :
   table.chars[c] = 1 as byte
   return 0
   
lostanza defn tag-chars (table:ref<String>, cs:ptr<byte>) -> int :
   for (var i:long = 0, 1, i = i + 1) :
      val c = cs[i]
      if c == 0 : return 0
      tag-char(table, c)
   fatal("Unreachable")   
   return 0
   
lostanza :
   SYMBOL-CHARS = String(256, 0 as byte)
   OPERATOR-CHARS = String(256, 0 as byte)

   tag-chars(SYMBOL-CHARS, "0123456789")
   tag-chars(SYMBOL-CHARS, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
   tag-chars(SYMBOL-CHARS, "_?")
   tag-chars(SYMBOL-CHARS, "~!@#$%^*+-=/")

   tag-chars(OPERATOR-CHARS, "~!@#$%^*+-=/")
   tag-chars(OPERATOR-CHARS, ".:<>&|")

lostanza defn symbol-char? (c:ref<Char>) -> ref<True|False> :
   if SYMBOL-CHARS.chars[c.value] == 0 : return false
   else : return true

lostanza defn operator-char? (c:ref<Char>) -> ref<True|False> :
   if OPERATOR-CHARS.chars[c.value] == 0 : return false
   else : return true

defn symbol-needs-escape? (str:String) :
   if empty?(str) : true
   else if digit?(str[0]) : true
   else if length(str) >= 2 and str[0] == '-' and digit?(str[1]) : true
   else if all?(symbol-char?, str) : false
   else if all?(operator-char?, str) : false
   else : true

;                  Escaped Primitive Values
;                  ========================

defmethod write (o:OutputStream, c:Char) :
   print(o, '\'')
   escape-for-char(o, c)
   print(o, '\'')      

defmethod write (o:OutputStream, s:String) :
   print(o, '"')
   for c in s do :
      escape-for-char(o, c)
   print(o, '"')      

defmethod write (o:OutputStream, x:Byte) :
   print(o, x)
   print(o, 'Y')

defmethod write (o:OutputStream, x:Long) :
   print(o, x)
   print(o, 'L')

defmethod write (o:OutputStream, b:Float) :
   print(o, b)
   print(o, 'F')

;============================================================
;===================== Timers ===============================
;============================================================

public lostanza defn current-time-ms () -> ref<Long> :
   val ms = call-c clib/current_time_ms()
   return new Long{ms}

public lostanza defn current-time-us () -> ref<Long> :
   val us = call-c clib/current_time_us()
   return new Long{us}

public deftype Timer
public defmulti start (t:Timer) -> False
public defmulti stop (t:Timer) -> False
public defmulti time (t:Timer) -> Long

defn Timer (name:String, get-time: () -> Long) :
   var total-time:Long = 0L
   var last-time:Long = 0L
   var running = false
   new Timer :
      defmethod start (this) :
         fatal("Timer already running.") when running
         last-time = get-time()
         running = true
      defmethod stop (this) :
         fatal("Timer is not running.") when not running
         val time = get-time()
         total-time = total-time + time - last-time
         last-time = time
         running = false
      defmethod time (this) :
         if running : total-time + get-time() - last-time
         else : total-time
      defmethod print (o:OutputStream, this) :
         print(o, "[%_ Timer : %_]" % [name, time(this)])

public defn MillisecondTimer (name:String) :
   Timer(name, current-time-ms)

public defn MicrosecondTimer (name:String) :
   Timer(name, current-time-us)

public defn PiggybackTimer (name:String, t:Timer) :
   Timer(name, time{t})