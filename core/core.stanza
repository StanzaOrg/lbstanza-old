;################################################################################
;############################## C Library #######################################
;################################################################################

;================================================================================
;================================ Boot Sequence =================================
;================================================================================

defpackage clib

protected extern malloc: long -> ptr<?>
protected extern free: ptr<?> -> int
protected extern realloc: (ptr<?>, long) -> ptr<?>
protected extern memcpy: (ptr<?>, ptr<?>, long) -> ptr<?>
protected extern memcmp: (ptr<byte>, ptr<byte>, long) -> int
protected extern memset: (ptr<?>, long, long) -> ptr<?>
protected extern rmdir: (ptr<byte>) -> int
protected extern remove: (ptr<byte>) -> int
protected extern rename: (ptr<byte>, ptr<byte>) -> int
protected extern symlink: (ptr<byte>, ptr<byte>) -> int
protected extern ftell: (ptr<?>) -> long
protected extern fclose: (ptr<?>) -> int
protected extern fflush: (ptr<?>) -> int
protected extern fopen: (ptr<byte>, ptr<byte>) -> ptr<?>
protected extern fputs: (ptr<byte>, ptr<?>) -> int
protected extern fputc: (byte, ptr<?>) -> int
protected extern fgetc: (ptr<?>) -> int
protected extern fread: (ptr<?>, long, long, ptr<?>) -> long
protected extern fwrite: (ptr<?>, long, long, ptr<?>) -> long
protected extern ferror: (ptr<?>) -> int
protected extern fprintf: (ptr<?>, ptr<byte>, ? ...) -> int
protected extern sprintf: (ptr<byte>, ptr<byte>, ? ...) -> int
protected extern sscanf: (ptr<byte>, ptr<byte>, ptr<?> ...) -> int
protected extern printf: (ptr<byte>, ? ...) -> int
protected extern exit: int -> int
protected extern get_stdout: () -> ptr<?>
protected extern get_stderr: () -> ptr<?>
protected extern get_stdin: () -> ptr<?>
protected extern get_eof: () -> int
protected extern input_argc: int
protected extern input_argv: ptr<ptr<byte>>
protected extern input_argv_needs_free: int
protected extern strlen: ptr<byte> -> int
protected extern current_time_us: () -> long
protected extern current_time_ms: () -> long
protected extern get_env_vars: () -> ptr<ptr<byte>>
protected extern getenv: (ptr<byte>) -> ptr<byte>
protected extern setenv: (ptr<byte>, ptr<byte>, int) -> int
protected extern unsetenv: (ptr<byte>) -> int
protected extern system: (ptr<byte>) -> int
protected extern strerror: (int) -> ptr<byte>
protected extern get_errno: () -> int
protected extern get_file_size: ptr<?> -> long
protected extern file_set_length: (ptr<?>, long) -> int
protected extern file_seek: (ptr<?>, long) -> int
protected extern file_skip: (ptr<?>, long) -> int
protected extern file_read_block: (ptr<?>, ptr<byte>, long) -> long
protected extern file_write_block: (ptr<?>, ptr<byte>, long) -> long
protected extern file_time_modified: ptr<byte> -> long
protected extern execvp: (ptr<byte>, ptr<ptr<byte>>) -> int
protected extern execv: (ptr<byte>, ptr<ptr<byte>>) -> int

;Path Resolution
#if-defined(PLATFORM-WINDOWS) :
  protected extern windows_final_path_name: ptr<byte> -> ptr<byte>
  protected extern windows_full_path_name: ptr<byte> -> ptr<byte>
  protected extern windows_logical_drives_bitmask: () -> int
#else :
  protected extern resolve_path: ptr<byte> -> ptr<byte>

;Retrieve File Type
#if-defined(PLATFORM-WINDOWS) :
  protected extern get_file_type: ptr<byte> -> int
#else :
  protected extern get_file_type: (ptr<byte>, int) -> int

;Memory mapping
protected extern stz_memory_map: (long, long) -> ptr<?>
protected extern stz_memory_unmap: (ptr<?>, long) -> int
protected extern stz_memory_resize: (ptr<?>, long, long) -> int

;Process libraries
#if-defined(PLATFORM-WINDOWS):
  protected extern launch_process: (ptr<byte>, int, int, int, ptr<byte>, ptr<byte>, ptr<?>) -> int
  protected extern close_process_handle: (ptr<byte>) -> int
#else:
  protected extern launch_process: (ptr<byte>, ptr<ptr<byte>>, int, int, int, int, ptr<byte>, ptr<ptr<byte>>, ptr<?>) -> int
  protected extern delete_process_pipes: (ptr<?>, ptr<?>, ptr<?>, int) -> int
  protected extern initialize_launcher_process: () -> int
protected extern retrieve_process_state: (ptr<?>, ptr<?>, int) -> int


;Math libraries
protected extern exp: double -> double
protected extern log: double -> double
protected extern log10: double -> double
protected extern sqrt: double -> double
protected extern pow: (double, double) -> double
protected extern sin: double -> double
protected extern cos: double -> double
protected extern tan: double -> double
protected extern asin: double -> double
protected extern acos: double -> double
protected extern atan: double -> double
protected extern atan2: (double, double) -> double
protected extern sinh: double -> double
protected extern cosh: double -> double
protected extern tanh: double -> double
protected extern ceil: double -> double
protected extern floor: double -> double
protected extern round: double -> double

;################################################################################
;############################## Core Library ####################################
;################################################################################

;================================================================================
;=============================== Boot Sequence ==================================
;================================================================================

defpackage core :
  import collections
  import core/stack-trace
  import core/parsed-path

;============================================================
;===================== Internal Types =======================
;============================================================

protected lostanza deftype Fn :
   length: long
   code: ptr<?>
   free: ref<?> ...
protected lostanza deftype Box :
   item: ref<?>
protected lostanza deftype Type :
   length: long
   code: ptr<?>
   free: ref<?> ...
public lostanza deftype StackFrame :
  var return: long
  var liveness-map: long
  var slots: long ...
public lostanza deftype Stack :
  var size: long
  var frames: ptr<StackFrame>
  var stack-pointer: ptr<StackFrame>
  var pc: long
  var tail: ptr<Stack> ; next stack in STACKS list

lostanza defn core-iterate-references-in-stack-frames (stack:ptr<Stack>,
                                                       f:ptr<((ptr<long>, ptr<VMState>) -> ref<False>)>,
                                                       vms:ptr<VMState>) -> ref<False> :
  ;The collector executes on current-stack
  if stack == untag(vms.heap.current-stack) : return false

  val stackmap-table = vms.stackmap-table
  ;Precondition: stack.frames != null
  var frame:ptr<StackFrame> = stack.frames
  val end-frame:ptr<StackFrame> = stack.stack-pointer
  while frame <= end-frame :
    val map = stackmap-table[frame.liveness-map]
    val num-live = map.num-roots
    for (var i:int = 0, i < num-live, i = i + 1) :
      val r = map.roots[i]
      [f](addr(frame.slots[r]), vms)
    frame = frame + map.size
  ;No meaningful return value
  return false

lostanza deftype GlobalRoots :
  length: int
  roots: int ...

lostanza deftype StackMap :
  size: int
  num-roots: int
  roots: int ...

lostanza deftype StackTraceTable :
  length: long
  entries: StackTraceTableEntry ...

lostanza deftype StackTraceTableEntry :
  lbl: ptr<?>
  record: StackTraceRecord

lostanza deftype ClassDescriptor :
  case:int
  num-base-bytes:int
  record:ptr<ClassRecord>

lostanza deftype ClassRecord :
  num-bytes:int
  size:int
  item-size:int
  num-roots:int
  roots:int ...

lostanza deftype ArrayRecord :
  num-bytes:int
  base-size:int
  item-size:int
  num-base-roots:int
  num-item-roots:int
  roots:int ...

;The first fields in VMState are used by the core library
;in both compiled and interpreted mode. The last fields
;are used only in compiled mode.
;Permanent state changes in-between each code load.
;Variable state changes in-between each boundary change.
protected lostanza deftype VMState :
  ;Compiled and Interpreted Mode
  global-offsets: ptr<long>   ;(Permanent State)
  global-mem: ptr<byte>       ;(Permanent State)
  const-table: ptr<long>      ;(Permanent State)
  const-mem: ptr<byte>        ;(Permanent State)
  data-offsets: ptr<int>      ;(Permanent State)
  data-mem: ptr<byte>         ;(Permanent State)
  code-offsets: ptr<int>      ;(Permanent State)
  registers: ptr<long>        ;(Permanent State)
  system-registers: ptr<long> ;(Permanent State)
  var heap: Heap              ;(Variable State)
  ;Compiled Mode Tables
  class-table: ptr<ClassDescriptor>
  global-root-table: ptr<GlobalRoots>
  stackmap-table: ptr<ptr<StackMap>>
  stack-trace-table: ptr<StackTraceTable>
  extern-table: ptr<ExternTable>
  extern-defn-table: ptr<ExternDefnTable>

lostanza deftype ExternTable :
  length: long
  entries: ExternEntry ...

lostanza deftype ExternEntry :
  name:ptr<byte>
  address:long

lostanza deftype ExternDefnTable :
  length: long
  entries: ExternDefnEntry ...

lostanza deftype ExternDefnEntry :
  name:ptr<byte>
  var address:ptr<?>

;============================================================
;================== Internal Callbacks ======================
;============================================================

protected lostanza defn arity-error (arity:long) -> ref<Void> :
  return fatal(arity-message(new Int{arity as int}))
defn arity-message (arity:Int) :
  "Function cannot be called with %_ arguments." % [arity]

protected defn no-method-error (multi:String, args:Tuple) :
  fatal("Multi %_ has no appropriate method for arguments of type (%,)." % [multi, seq(object-type,args)])

protected defn amb-method-error (multi:String, args:Tuple) :
  fatal("Multi %_ has multiple appropriate methods for arguments of type (%,)." % [multi, seq(object-type,args)])

protected defn no-branch-error (args:Tuple) :
  fatal("No appropriate branch for arguments of type (%,)." % [seq(object-type, args)])

protected defn amb-branch-error (args:Tuple) :
  fatal("Multiple appropriate branches for arguments of type (%,)." % [seq(object-type, args)])

protected lostanza defn tuple-length-error (actual-len:long, expected-len:long) -> ref<Void> :
  return fatal(tuple-length-message(new Int{actual-len as int}, new Int{expected-len as int}))
defn tuple-length-message (actual-len:Int, expected-len:Int) :
  "Cannot destructure tuple of length %_ into %_ items." % [actual-len, expected-len]

protected defn variable-uninitialized-error (name:String|False) -> Void :
  match(name) :
    (name:String) : fatal("Variable %_ has not been initialized." % [name])
    (name:False) : fatal("Variable has not been initialized.")

protected lostanza defn cast-error (type:ref<Type>, obj:ref<?>, ctxt:int) -> ref<Void> :
  return fatal(cast-message(type, obj, new Int{ctxt}))

protected lostanza defn invalid-return-error () -> ref<Void> :
  return fatal("Unexpected return from function declared with Void return type.")

defn cast-message (t:Type, x, ctxt:Int) :
  val objt = object-type(x)
  switch(ctxt) :
    0 : "Cannot cast value of type %_ to type %_." % [objt, t]
    1 : "Argument was expected to be of type %_, but was passed a value of type %_." % [
          t, objt]
    2 : "The expected return type of this function is %_, but a value of type %_ was returned." % [
          t, objt]
    3 : "Cannot initialize a variable of type %_ with a value of type %_." % [t, objt]
    4 : "Cannot assign a value of type %_ to a variable with declared type %_." % [objt, t]
    5 : "Cannot call a value of type %_ as if it were a function." % [objt]
    6 : "Cannot deconstruct a value of type %_ into a tuple." % [objt]
    7 : "The variable was expected to have type %_, but we retrieved a value of type %_ from it." % [
          t, objt]
    8 : "Branch argument was expected to be of type %_, but was passed a value of type %_." % [
          t, objt]

;============================================================
;=================== Stack Traces ===========================
;============================================================

;Function for printing out the stack trace right now.
;Does not call any GC constructs. Does not obey stack trace
;filters.
public lostanza defn print-stack-trace! () -> ref<False> :
  ;Special circumstance where the current stack is not equal
  ;to stored stack in the current coroutine. This occurs
  ;when we are in a system function (e.g. extend-stack, or
  ;collect-garbage), and the current stack is the system stack.
  val vms:ptr<VMState> = call-prim flush-vm()
  val current-stack = vms.heap.current-stack as ref<Stack>
  if current-coroutine.stack != current-stack :
    call-prim print-stack-trace(current-stack)

  ;Start from the current coroutine, and print
  ;out the stacks following the coroutine parent chain.
  labels :
    begin :
      goto loop(current-coroutine)
    loop (co:ref<RawCoroutine>) :
      call-prim print-stack-trace(co.stack)
      match(co.parent) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : ()
  return false

;Function for printing out the stack trace during
;normal operation. Respects the stack trace filter.
public defn print-stack-trace (o:OutputStream) -> False :
  val trace = collect-stack-trace()
  print-stack-trace(o, trace, STACK-TRACE-FILTER)

;Function for printing out the stack trace during
;normal operation. Respects the stack trace filter.
public defn print-stack-trace () -> False :
  print-stack-trace(CURRENT-ERROR-STREAM)

;Collect the stack trace into an object.
public lostanza defn collect-stack-trace () -> ref<StackTrace> :
  call-prim flush-vm()
  val traces = Vector<SingleStackTrace>()
  labels :
    begin: goto loop(current-coroutine)
    loop (co:ref<RawCoroutine>) :
      val trace = call-prim collect-stack-trace(co.stack)
      add(traces, StackTrace(trace))
      match(co.parent) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : ()
  return append-all(traces)

;============================================================
;====================== Fatal Errors ========================
;============================================================

var ERROR-HANDLER: String -> Void

;Initialize the ERROR-HANDLER with the default error handling
;callback.
defn initialize-error-handler () :
  ERROR-HANDLER = fn (error-msg) :
    print(CURRENT-ERROR-STREAM, "FATAL ERROR: ")
    println(CURRENT-ERROR-STREAM, error-msg)
    print-stack-trace()
    exit(-1)

;Hard unrecoverable system error. Used only when error is
;so serious that we cannot run the standard error-handling
;process. For example, out of memory, stack overflow, failed system
;invariance conditions.
lostanza defn fatal! (msg:ptr<byte>) -> ref<Void> :
  call-c clib/fflush(stdout)
  call-c clib/fprintf(current-err, "FATAL ERROR: %s\n", msg)
  call-c clib/fflush(current-err)
  print-stack-trace!()
  call-c clib/exit(-1)
  ;Unreachable
  return false as ref<?>

;Standard fatal error.
public defn fatal (msg) -> Void :
  flush(STANDARD-OUTPUT-STREAM as FileOutputStream)
  ERROR-HANDLER(to-string(msg))

;Fatal error from LoStanza context.
public lostanza defn fatal (msg:ptr<byte>) -> ref<Void> :
  return fatal(String(msg))

;Execute the given body after arming context with the given
;error handler.
;Error handler has this type:
;- handle-error (msg:String) -> ?T
;- msg is the error message passed to fatal.
;- The return value of handle-error is returned by execute-with-error-handler.
public defn execute-with-error-handler<?T> (body:() -> ?T,
                                            handle-error:String -> ?T) :
  label<T> break :
    let-var ERROR-HANDLER = break{handle-error(_)} :
      body()

;Convenience function. Just prints the stack trace and then calls halt-function.
;public defn execute-with-halt-interceptor<?T> (body:() -> ?T, halt-function:() -> Void) -> T :
;  defn handle-error (error-msg:String, break:T -> Void) -> Void :
;    print(CURRENT-ERROR-STREAM, "FATAL ERROR: ")
;    println(CURRENT-ERROR-STREAM, error-msg)
;    print-stack-trace()
;    halt-function()
;  execute-with-error-handler<T>(body, handle-error)

;============================================================
;================ Top Level Commands ========================
;============================================================

;The current command launcher
var COMMAND-LAUNCHER: (() -> False) -> True|False

;Returns false if fatal is called during execution.
defn initialize-command-launcher () :
  COMMAND-LAUNCHER = fn (body) :
    defn handle-error (error-msg:String) -> False :
      print(CURRENT-ERROR-STREAM, "FATAL ERROR: ")
      println(CURRENT-ERROR-STREAM, error-msg)
      print-stack-trace()
      false
    within execute-with-error-handler(handle-error) :
      body()
      true

;Set the current command launcher for the REPL.
public defn set-command-launcher (launcher:(() -> False) -> True|False) :
  COMMAND-LAUNCHER = launcher

;Execute the given top level command with the current
;command launcher
defn execute-toplevel-command (body:() -> False) -> True|False :
  COMMAND-LAUNCHER(body)

;Display the result of a REPL expression to the user.
protected defn display-repl-result (result) -> False :
  val stdout = STANDARD-OUTPUT-STREAM
  val reached-limit? = limited-println(stdout, 2000, result)
  println(stdout, " ...") when reached-limit?

;============================================================
;==================== Limited Output Stream =================
;============================================================

;Print the given object with a maximum length limit.
;Returns true if the length was reached.
defn limited-println (o:OutputStream, limit:Int, object) -> True|False :
  label<True|False> return :
    val counter = to-seq(0 to false)
    val stream = new OutputStream :
      defmethod print (this, c:Char) :
        val num-printed = next(counter)
        return(true) when num-printed == limit
        print(o, c)
    println(stream, object)
    false

;============================================================
;===================== Stack Trace ==========================
;============================================================

;------------------------------------------------------------
;-------------------- Stack Trace Filter --------------------
;------------------------------------------------------------

var STACK-TRACE-FILTER: ((Symbol, String|False) -> True|False)|False = false

public defn set-stack-trace-filter (f:((Symbol, String|False) -> True|False)|False) :
  STACK-TRACE-FILTER = f

public defn current-stack-trace-filter () -> ((Symbol, String|False) -> True|False)|False :
  STACK-TRACE-FILTER

;------------------------------------------------------------
;------------------------ Printing --------------------------
;------------------------------------------------------------

lostanza defn print-stack-trace (stack:ref<Stack>) -> ref<False> :
  val vms:ptr<VMState> = call-prim flush-vm()

  ;Discover return addresses
  val buffer = stack-trace-return-addresses(vms,stack)

  ;Print buffer
  for (var i:long = buffer.length - 1, i >= 0, i = i - 1) :
    val entry = stack-trace-record(buffer.items[i], vms.stack-trace-table)
    if entry != null :
      print-record(entry)

  ;Free the buffer
  free(buffer)
  return false

lostanza defn print-record (record:ptr<StackTraceRecord>) -> ref<False> :
  call-c clib/fprintf(current-err, "  in %s", record.package)
  if record.signature != null :
    call-c clib/fprintf(current-err, "/%s", record.signature)
  call-c clib/fprintf(current-err, "\n")
  if record.file != null :
    call-c clib/fprintf(current-err, "    at %s:%d.%d\n", record.file, record.line, record.column)
  return false

;------------------------------------------------------------
;------------------------ Collecting ------------------------
;------------------------------------------------------------

lostanza defn collect-stack-trace (stack:ref<Stack>) -> ptr<PackedStackTrace> :
  val vms:ptr<VMState> = call-prim flush-vm()

  ;Discover return addresses
  val buffer = stack-trace-return-addresses(vms,stack)

  ;Build stack trace
  val builder = StackTraceBuilder()
  for (var i:long = buffer.length - 1, i >= 0, i = i - 1) :
    val entry = stack-trace-record(buffer.items[i], vms.stack-trace-table)
    if entry != null :
      add-entry(builder, entry)

  ;Pack stack trace into stable memory
  val trace = pack(builder)

  ;Free the buffer
  free(buffer)

  ;Return the packed trace.
  return trace

;------------------------------------------------------------
;------------------------ Utilities -------------------------
;------------------------------------------------------------

lostanza defn stack-trace-return-addresses (vms:ptr<VMState>, stack:ref<Stack>) -> ptr<LSLongVector> :
  ;Discover return addresses
  val buffer = LSLongVector()

  val end-sp = stack.stack-pointer
  labels :
    begin : goto loop(stack.frames)
    loop (sp:ptr<StackFrame>) :
      ;Store in return buffer
      add(buffer, sp.return)

      ;Continue if we're not at the end of the stack
      if sp < end-sp :
        val map-index = sp.liveness-map
        val stackmap = vms.stackmap-table[map-index]
        goto loop(sp + stackmap.size)

  ;Return the buffer
  return buffer

lostanza defn stack-trace-record (ret:long, trace-table:ptr<StackTraceTable>) -> ptr<StackTraceRecord> :
  for (var i:int = 0, i < trace-table.length, i = i + 1) :
    val entry = addr(trace-table.entries[i])
    if ret == (entry.lbl as long) :
      return addr(entry.record)
  return null

;============================================================
;====================== LS Long Vector ======================
;============================================================

protected lostanza defn realloc (p:ptr<?>, size*:long) -> ptr<?> :
  val p* = call-c clib/realloc(p, size*)
  if p* == null : fatal!("Failed to realloc")
  return p*

lostanza deftype LSLongVector :
  var capacity: int
  var length: int
  var items: ptr<long>

lostanza defn LSLongVector (capacity:int) -> ptr<LSLongVector> :
  val v:ptr<LSLongVector> = call-c clib/malloc(sizeof(LSLongVector))
  v.capacity = capacity
  v.length = 0
  v.items = call-c clib/malloc(capacity * sizeof(long))
  return v

lostanza defn LSLongVector () -> ptr<LSLongVector> :
  return LSLongVector(8)

lostanza defn ensure-capacity (v:ptr<LSLongVector>, new-capacity:int) -> int :
  if v.capacity < new-capacity :
    var c:int = v.capacity
    while c < new-capacity : c = c << 1
    v.capacity = c
    v.items = realloc(v.items, c * sizeof(long))
  return 0

lostanza defn add (v:ptr<LSLongVector>, x:long) -> int :
  ensure-capacity(v, v.length + 1)
  v.items[v.length] = x
  v.length = v.length + 1
  return 0

lostanza defn free (v:ptr<LSLongVector>) -> int :
  call-c clib/free(v.items)
  call-c clib/free(v)
  return 0

;============================================================
;==================== Class Name ============================
;============================================================

public lostanza defn class-name (x:int) -> ptr<byte> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val record = vms.class-table[x].record
  return (record + record.num-bytes) as ptr<byte>

;============================================================
;======================= Core Types =========================
;============================================================

public lostanza deftype Byte :
  value: byte

public lostanza deftype Char :
  value: byte

public lostanza deftype Int :
  value: int

public lostanza deftype Long :
  value: long

public lostanza deftype Float :
  value: float

public lostanza deftype Double :
  value: double

public lostanza deftype String :
  length: long
  var hash: int
  var chars: byte ...

public deftype Symbol
public lostanza deftype StringSymbol <: Symbol :
  name: ref<String>
public deftype GenSymbol <: Symbol

public lostanza deftype True
public lostanza deftype False

public lostanza deftype Tuple<T> :
  length: long
  var items: ref<T> ...

public deftype List<T>
lostanza deftype FullList<T> <: List<T> :
  head: ref<T>
  tail: ref<List<T>>
lostanza deftype NilList <: List<Void>

public deftype Coroutine<I,O>

;============================================================
;============== Standard Streams ============================
;============================================================

lostanza val stdout:ptr<?> = call-c clib/get_stdout()
lostanza val stderr:ptr<?> = call-c clib/get_stderr()
lostanza val stdin:ptr<?> = call-c clib/get_stdin()
lostanza val EOF:int = call-c clib/get_eof()
lostanza var current-err:ptr<?> = stderr

;============================================================
;================ Constant Initialization ===================
;============================================================

lostanza var const-ptr:ptr<?>
lostanza val BYTE-CONST-TAG : int = 0
lostanza val CHAR-CONST-TAG : int = 1
lostanza val INT-CONST-TAG : int = 2
lostanza val LONG-CONST-TAG : int = 3
lostanza val FLOAT-CONST-TAG : int = 4
lostanza val DOUBLE-CONST-TAG : int = 5
lostanza val TRUE-CONST-TAG : int = 6
lostanza val FALSE-CONST-TAG : int = 7
lostanza val LIST-CONST-TAG : int = 8
lostanza val STRING-CONST-TAG : int = 9
lostanza val SYMBOL-CONST-TAG : int = 10
lostanza val TYPE-CONST-TAG : int = 11
lostanza val FN-CONST-TAG : int = 12
lostanza val INTERNED-CONST-TAG : int = 13
lostanza var initialized-symbol-table? : long = 0L
lostanza var consts-top : long = 4L
lostanza var num-loaded-consts : long = 0L

protected lostanza defn initialize-constants () -> ref<False> :
  ;Initialize read pointer to beginning of the constant table
  ;[num, constants ...]
  val vms:ptr<VMState> = call-prim flush-vm()
  val consts-data = vms.const-mem

  ;Read total number of constants
  const-ptr = consts-data
  val n-consts = read-const-int()

  ;Populate constants vector
  const-ptr = consts-data + consts-top
  var cs:ptr<ref<?>> = vms.const-table as ptr<ref<?>>
  while num-loaded-consts < n-consts :
    cs[num-loaded-consts] = read-const(vms)
    num-loaded-consts = num-loaded-consts + 1

  ;Set new top
  consts-top = const-ptr - consts-data
  return false

;Align the constant pool reader (consts-ptr) so that
;it is aligned against the given size.
lostanza defn align-const-reader (size:int) -> ref<False> :
  val ptr-value = const-ptr as long
  val aligned-value = (ptr-value + size - 1) & (- size)
  const-ptr = aligned-value as ptr<?>
  return false

lostanza defn read-const (vms:ptr<VMState>) -> ref<?> :
  val tag = read-const-int()
  if tag == BYTE-CONST-TAG :
    return new Byte{read-const-byte()}
  else if tag == CHAR-CONST-TAG :
    return new Char{read-const-byte()}
  else if tag == INT-CONST-TAG :
    return new Int{read-const-int()}
  else if tag == LONG-CONST-TAG :
    return new Long{read-const-long()}
  else if tag == FLOAT-CONST-TAG :
    return new Float{read-const-float()}
  else if tag == DOUBLE-CONST-TAG :
    return new Double{read-const-double()}
  else if tag == TRUE-CONST-TAG :
    return true
  else if tag == FALSE-CONST-TAG :
    return false
  else if tag == LIST-CONST-TAG :
    val len = read-const-int()
    return read-const-list(len, vms)
  else if tag == STRING-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)
    return String(len, chars)
  else if tag == SYMBOL-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)
    val str = String(len, chars)
    if initialized-symbol-table? : return to-symbol(str)
    else : return new StringSymbol{str}
  else if tag == TYPE-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Type{0, code}
  else if tag == FN-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Fn{0, code}
  else if tag == INTERNED-CONST-TAG :
    val i = read-const-int()
    val cs = vms.const-table as ptr<ref<?>>
    return cs[i]
  else :
    call-c clib/printf("Unknown constant tag: %d\n", tag)
    return fatal!("Unknown constant tag")

lostanza defn read-const-list (n:int, vms:ptr<VMState>) -> ref<List> :
  if n == 0 : return new NilList{}
  else : return new FullList{read-const(vms), read-const-list(n - 1, vms)}

lostanza defn read-const-byte () -> byte :
  val value = [const-ptr as ptr<byte>]
  const-ptr = const-ptr + sizeof(byte)
  return value

lostanza defn read-const-int () -> int :
  align-const-reader(4)
  val value = [const-ptr as ptr<int>]
  const-ptr = const-ptr + sizeof(int)
  return value

lostanza defn read-const-long () -> long :
  align-const-reader(8)
  val value = [const-ptr as ptr<long>]
  const-ptr = const-ptr + sizeof(long)
  return value

lostanza defn read-const-float () -> float :
  align-const-reader(4)
  val value = [const-ptr as ptr<float>]
  const-ptr = const-ptr + sizeof(float)
  return value

lostanza defn read-const-double () -> double :
  align-const-reader(8)
  val value = [const-ptr as ptr<double>]
  const-ptr = const-ptr + sizeof(double)
  return value

lostanza defn read-const-chars (len:long) -> ptr<byte> :
  val value = const-ptr as ptr<byte>
  const-ptr = const-ptr + len
  return value

;============================================================
;=================== Garbage Collection =====================
;============================================================

lostanza var initialized-gc-notifiers? : long = 0L
public lostanza var MAXIMUM-HEAP-SIZE : long = 8L * 1024L * 1024L * 1024L
lostanza val SYSTEM-PAGE-SIZE : long = 4096

public lostanza defn round-up-to-whole-pages (x:long) -> long :
  return (x + (SYSTEM-PAGE-SIZE - 1)) & (~ (SYSTEM-PAGE-SIZE - 1));

;Round the given number up to the nearest 8-byte boundary.
lostanza defn round-up-to-whole-longs (x:long) -> long :
  return (x + (sizeof(long) - 1)) & (~ (sizeof(long) - 1));

;Explicitly request a garbage collection cycle.
public lostanza defn run-garbage-collector () -> ref<False> :
  return extend-heap(0L)

;This hook is called automatically by the generated code (and the
;VM) when we need to allocate a new object and there isn't
;enough space on the heap for its allocation.
;- size: the number of bytes that we need to reserve.
;The return value is unused.
;The system tries to free at least 'size' number of bytes.
;If it cannot do that, then it fails with an unrecoverable
;"Out Of Memory" error.
lostanza defn extend-heap (size:long) -> ref<False> :
  val vms:ptr<VMState> = call-prim flush-vm()
  ;Collect garbage, and ensure we freed enough space
  call-prim collect-garbage(size)
  ;Now run the GC notifiers, if they have been initialized
  if initialized-gc-notifiers? :
    run-gc-notifiers()
  ;If GC notifiers allocated too much space, then collect the garbage again
  ;(Happens rarely.)
  val remaining-after-notifiers = vms.heap.limit - vms.heap.top
  if remaining-after-notifiers < size :
    if (call-prim collect-garbage(size)) < size : fatal!("Out of memory.")
  ;Unused return value
  return false

;This function is called by the "call-prim collect-garbage" primitive.
;It runs the garbage collector, and returns the new number of bytes
;remaining after the garbage collector runs.
;- size: the number of bytes that we desire from the heap. This is
;  used to compute whether or not to grow the heap.
lostanza defn collect-garbage (size:long) -> long :
  ;Retrieve state
  val vms:ptr<VMState> = call-prim flush-vm()
  return collect-garbage(size, vms)

;============================================================
;====================== Stack Pool ==========================
;============================================================

lostanza val INITIAL-STACK-SIZE:long = 4L * 1024L

lostanza defn allocate-stack-frames-for-freelist (heap:ptr<Heap>) -> ref<False> :
  ;Parameters
  val stacks-in-block = 64L
  val stack-block-size = INITIAL-STACK-SIZE * stacks-in-block

  ;Allocate all the memory for the block
  var block:ptr<long> = call-c clib/malloc(stack-block-size)
  if block == null : fatal!("Cannot allocate stack block")

  ;Put stack frames on freelist.
  val block-end:ptr<?> = block + stack-block-size
  while block < block-end :
    [block] = heap.free-stacks as long
    heap.free-stacks = block
    block = block + INITIAL-STACK-SIZE
  return false

lostanza defn allocate-stack-frames (size:long, heap:ptr<Heap>) -> ptr<StackFrame> :
  if size == INITIAL-STACK-SIZE :
    if heap.free-stacks == null :
      allocate-stack-frames-for-freelist(heap)
    val frames = heap.free-stacks
    heap.free-stacks = [frames] as ptr<long>
    return frames as ptr<StackFrame>
  else :
    val frames:ptr<StackFrame> = call-c clib/malloc(size)
    if frames == null : fatal!("Cannot allocate stack frames")
    return frames

lostanza defn free-stack-frames (frames:ptr<StackFrame>, size:long, heap:ptr<Heap>) -> ref<False> :
  if frames == null : return false
  if size == INITIAL-STACK-SIZE :
    [frames as ptr<long>] = heap.free-stacks as long
    heap.free-stacks = frames as ptr<long>
  else :
    call-c clib/free(frames)
  return false

lostanza defn extend-stack-frames (frames:ptr<StackFrame>, size:long, new-size:long, heap:ptr<Heap>) -> ptr<StackFrame> :
  if size == INITIAL-STACK-SIZE or new-size == INITIAL-STACK-SIZE :
    ;Allocate new frames and copy over old frames
    val new-frames = allocate-stack-frames(new-size, heap)
    call-c clib/memcpy(new-frames, frames, size)
    free-stack-frames(frames, size, heap)
    return new-frames
  else :
    return realloc(frames, new-size)

lostanza defn allocate-stack () -> ref<Stack> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val stack = new Stack{0, null, null, 0, null}
  initialize-stack(addr!([stack]), addr(vms.heap))
  return stack

lostanza defn initialize-stack (stack:ptr<Stack>, heap:ptr<Heap>) -> ref<False> :
  val size = INITIAL-STACK-SIZE
  val frames = allocate-stack-frames(size, heap)
  frames.return = -1L
  frames.liveness-map = 0L
  stack.frames = frames
  stack.size = size
  stack.stack-pointer = null
  stack.pc = 0
  stack.tail = heap.stacks
  heap.stacks = stack
  ;No meaningful return value
  return false

lostanza defn free-stack-list (list:ptr<Stack>, heap:ptr<Heap>) -> ref<False> :
  for (var stack:ptr<Stack> = list, stack != null, stack = stack.tail) :
    free-stack-frames(stack.frames, stack.size, heap)
  ;No meaningful return value
  return false

lostanza defn free (s:ref<Stack>) -> ref<False> :
  val vms:ptr<VMState> = call-prim flush-vm()
  free-stack-frames(s.frames, s.size, addr(vms.heap))
  s.frames = null
  s.stack-pointer = null
  return false

;<doc>=======================================================
;====================== Stack Extension =====================
;============================================================

Computing the new size of the stack:
  - The desired-size is:
      stack-pointer + size - frames
  - Double the current size until it is larger than the
    desired size, and then cap it at the maximum allowable size.
  - If the new size is still less than the desired size, then
    stack overflow.

;============================================================
;=======================================================<doc>

lostanza defn extend-stack (size:long, heap:ptr<Heap>) -> ref<False> :
  ;Retrieve stack
  val s:ptr<Stack> = untag(heap.system-stack)

  ;Compute new size of stack
  val maximum-size = 1024L * 1024L * 1024L
  val desired-size = s.stack-pointer + size - s.frames
  var new-size:long = s.size
  while new-size < desired-size : new-size = new-size << 1
  new-size = min(new-size, maximum-size)

  ;Check for stack overflow
  if new-size < desired-size : fatal!("Stack overflow")

  val old-frames = s.frames
  val new-frames = extend-stack-frames(old-frames, s.size, new-size, heap)
  ;Swap in new frames
  s.stack-pointer = s.stack-pointer + (new-frames - old-frames)
  s.size = new-size
  s.frames = new-frames

  ;No meaningful return value
  return false

;Define various constants for the relations between
;bits, bytes, and longs.
lostanza val LOG-BITS-IN-BYTE:long = 3
lostanza val LOG-BYTES-IN-LONG:long = 3
lostanza val LOG-BITS-IN-LONG:long = LOG-BYTES-IN-LONG + LOG-BITS-IN-BYTE
lostanza val BYTES-IN-LONG:long = 1 << LOG-BYTES-IN-LONG
lostanza val BITS-IN-LONG:long = 1 << LOG-BITS-IN-LONG

;Structure for representing a Heap space.
;- top is the top address of the heap.
;- limit is equal to start + number of currently available bytes in the heap.
;  GC is triggered when we attempt to allocate past this limit.
;- start is the starting address of the heap. It is aligned at page boundary.
;- old-objects-end is the end of old objects at the bottom of the heap.
;- bitset is the starting address of the marking bits for the heap.
;- bitset-base is a cached common subexpression for set-mark, clear-mark,
;    test-mark, test-and-set-mark, test-and-clear-mark intrinsics.
;  bitset-base = bit-address(bit-index(null))
;  bitset-base = bitset - (start >> LOG-BITS-IN-LONG)
;- size is the current allocated size of the heap.
;- size-limit is the limit on heap size imposed by set-max-heap-size.
;    It cannot exceed max-size.
;- max-size is the maximum size that the heap can be expanded to.
;- compaction-start is the lowest moving object in collection area.
protected lostanza deftype Heap :
  var current-stack: long
  var system-stack: long
  var top:ptr<long>
  var limit:ptr<long>
  var start:ptr<long>
  var old-objects-end:ptr<long>
  var bitset:ptr<long>
  var bitset-base:ptr<long>
  var size:long
  var size-limit:long
  var max-size:long

  ;List of live Stacks in this heap.
  ;New Stacks are added to this list when they are created.
  var stacks:ptr<Stack>

  ;Free list for stackframes.
  var free-stacks:ptr<long>

  ;List of live LivenessTrackers in this heap.
  ;New liveness trackers are added to this list when they are created.
  var liveness-trackers:ptr<LivenessTracker>

  ;Marking stack
  ;Note that the stack grows downwards so stack-bottom is equal to
  ;stack-start + stack-size, and stack-top decreases as we push new items.
  var stack-start:ptr<long>
  var stack-bottom:ptr<long>
  var stack-top:ptr<long>

  ;Start of compaction area. (Only used during GC.)
  var compaction-start:ptr<long>

  ;Heap segment with the objects incompletely marked due to stack overflow. (Only used during GC.)
  var min-incomplete:ptr<?>
  var max-incomplete:ptr<?>

  ;Reference to environment with object layout metadata.
  var iterate-roots:ptr<((ptr<((ptr<long>, ptr<VMState>) -> ref<False>)>, ptr<VMState>) -> ref<False>)>
  var iterate-references-in-stack-frames:ptr<((ptr<Stack>, ptr<((ptr<long>, ptr<VMState>) -> ref<False>)>, ptr<VMState>) -> ref<False>)>

lostanza defn compute-bitset-base (heap:ptr<Heap>) -> ptr<long> :
  #if-not-defined(OPTIMIZE) :
    ;For bitset_base computation to work: bitset must be aligned to (BITS-IN-LONG * BYTES-IN-LONG)-bytes boundary.
    if heap.bitset as long & (BITS-IN-LONG * BYTES-IN-LONG - 1): fatal!("Unaligned bitset.")
  return heap.bitset - (heap.start as long >> LOG-BITS-IN-LONG)

lostanza defn heap-end (heap:ptr<Heap>) -> ptr<long> :
  return heap.start + heap.size

;Returns the desired size of the nursery.
;Defined to be heap-size / nursery-fraction.
lostanza defn compute-nursery-size (allocation-size:long, heap:ptr<Heap>) -> long :
  val nursery-fraction:long = 8
  return (round-up-to-whole-longs(heap.size / nursery-fraction) + allocation-size) << 1L

lostanza defn compute-nursery-size (heap:ptr<Heap>) -> long :
  return compute-nursery-size(0L, heap)

;============================================================
;=============== Fast Layout Descriptors ====================
;============================================================

lostanza val FAST-LAYOUT-BASE-WITH-NO-REFS:int = 0
lostanza val FAST-LAYOUT-BASE-WITH-REFS:int = 1
lostanza val FAST-LAYOUT-ARRAY-1-BYTE-TAIL:int = 2
lostanza val FAST-LAYOUT-ARRAY-4-BYTE-TAIL:int = 3
lostanza val FAST-LAYOUT-ARRAY-8-BYTE-TAIL:int = 4
lostanza val FAST-LAYOUT-ARRAY-REF-TAIL:int = 5
lostanza val FAST-LAYOUT-GENERAL:int = 6

;============================================================
;=============== Initialization of Heap =====================
;============================================================
;This routine initializes a freshly allocated Heap structure,
;to prepare for running the Stanza virtual machine.
;This routine is duplicated exactly by the C driver for initializing
;the heap before starting compiled Stanza.

;Initialize the current heap structure.
;- min-size is the initial size of the heap.
;- max-size is the maximum size that heap can be expanded to.
public lostanza defn initialize-heap (heap:ptr<Heap>,
                                      min-size:long,
                                      max-size:long) -> ref<False> :
  ;Precondition: Assert 0 <= min-size && min-size <= max-size
  #if-not-defined(OPTIMIZE) :
    if min-size < 0L or max-size < min-size :
      fatal("Illegal arguments to initialize-heap.")
  ;Round up sizes to the nearest page size so that it behaves wrt. mmap.
  val min-heap-size = round-up-to-whole-pages(min-size)
  heap.size = min-heap-size
  val max-heap-size = round-up-to-whole-pages(max-size)
  heap.max-size = max-heap-size
  heap.size-limit = max-heap-size
  ;Initialize the memory for the main heap.
  val heap-start = call-c clib/stz_memory_map(min-heap-size, max-heap-size)
  heap.start  = heap-start
  heap.old-objects-end = heap-start
  set-limit(heap-start + compute-nursery-size(heap), heap)
  ;Initialize the memory for the heap's bitset.
  val min-bitset-size = round-up-to-whole-pages(bitset-size(min-heap-size))
  val max-bitset-size = round-up-to-whole-pages(bitset-size(max-heap-size))
  heap.bitset = call-c clib/stz_memory_map(min-bitset-size, max-bitset-size)
  heap.bitset-base = compute-bitset-base(heap)
  clear(heap.bitset, min-bitset-size)
  ;Allocate space for marking stack (1024L * sizeof(long))
  ;Initialize stack-top and stack-bottom to just past the allocated memory.
  ;TODO: If marking stack were reserved right above the heap end, the entire address
  ;range from heap-top to stack-bottom could be occupied by the stack.
  val stack-size = round-up-to-whole-pages(1024L << LOG-BYTES-IN-LONG)
  heap.stack-start = call-c clib/stz_memory_map(stack-size, stack-size)
  heap.stack-bottom = heap.stack-start + stack-size
  heap.stack-top = heap.stack-bottom
  ;Initialize stack list
  heap.stacks = null
  heap.free-stacks = null
  heap.current-stack = tag-as-ref(allocate-initial-stack(heap))
  heap.system-stack = tag-as-ref(allocate-initial-stack(heap))
  ;Initialize trackers
  heap.liveness-trackers = null
  ;No meaningful return value.
  return false

;Remove all associated memory reserved for the current heap structure.
public lostanza defn finalize-heap (heap:ptr<Heap>) -> ref<False> :
  ;Dispose stack frames
  free-stack-list(heap.stacks, heap)

  ;Compute the current size of the heap and it's bitset.
  val current-bitset-size = bitset-size(heap.size)
  ;Unmap the currently reserved pages.
  call-c clib/stz_memory_unmap(heap.start, round-up-to-whole-pages(heap.size))
  call-c clib/stz_memory_unmap(heap.bitset, round-up-to-whole-pages(current-bitset-size))
  ;Compute the size of the marking size (note that it grows downwards).
  val marking-stack-size = heap.stack-bottom - heap.stack-start
  call-c clib/stz_memory_unmap(heap.stack-start, marking-stack-size)
  ;No meaningful return value.
  return false

;Ensure that the given heap is at least the given size.
lostanza defn expand-heap (size:long, heap:ptr<Heap>) -> ref<False> :
  ;Precondition: Ensure that size is less than maximum allowed size.
  #if-not-defined(OPTIMIZE) :
    if heap.max-size < size :
      fatal("Cannot expand heap past its maximum size.")

  ;Compute the new heap size by doubling the current size
  ;until it is at least as large as the requested size.
  var new-size:long = heap.size
  while new-size < size :
    new-size = new-size * 2
  new-size = min(new-size, heap.max-size)

  ;Exit immediately if heap is already the desired size (or bigger).
  val desired-heap-size = round-up-to-whole-pages(new-size)
  if heap.size >= desired-heap-size : return false

  ;Resize the heap.
  call-c clib/stz_memory_resize(heap.start, heap.size, desired-heap-size)

  ;Resize the bitset.
  val current-bitset-size = round-up-to-whole-pages(bitset-size(heap.size))
  val desired-bitset-size = round-up-to-whole-pages(bitset-size(desired-heap-size))
  ;If necessary, clear the newly-allocated bytes in the bitset.
  if current-bitset-size < desired-bitset-size :
    call-c clib/stz_memory_resize(heap.bitset, current-bitset-size, desired-bitset-size)
    clear(heap.bitset + current-bitset-size, desired-bitset-size - current-bitset-size)

  ;Record the new heap size
  heap.size = desired-heap-size

  ;No meaningful return value.
  return false

;Shrink the heap to be the given desired size. Called when desired-size is less than the
;current heap size.
;- Unmaps the memory for the heap.
;- Unmaps the memory for the bitset.
;- Records the current size of the heap to the new desired size.
lostanza defn shrink-heap (desired-size:long, heap:ptr<Heap>) -> ref<False> :
  ;Resize the heap.
  call-c clib/stz_memory_resize(heap.start, heap.size, desired-size)

  ;Resize the bitset.
  val current-bitset-size = round-up-to-whole-pages(bitset-size(heap.size))
  val desired-bitset-size = round-up-to-whole-pages(bitset-size(desired-size))
  if current-bitset-size > desired-bitset-size :
    call-c clib/stz_memory_resize(heap.bitset, current-bitset-size, desired-bitset-size)
  ;Record the new heap size
  heap.size = desired-size
  ;No meaningful return value.
  return false

;Allocate an object n a newly created heap.
public lostanza defn allocate-initial (heap:ptr<Heap>, tag:long, size:long) -> ptr<?> :
  ;Make space on heap
  var top:ptr<long> = heap.top
  [top] = tag
  top = top + sizeof(long)
  heap.top = top + size
  #if-not-defined(OPTIMIZE) :
    if heap.top > heap.limit :
      fatal!("Cannot allocate an initial object.")
  return top

lostanza defn allocate-initial-stack (heap:ptr<Heap>) -> ptr<Stack> :
  val stack:ptr<Stack> = allocate-initial(heap, tagof(Stack), sizeof(Stack))
  initialize-stack(stack, heap)
  return stack

;Given the current number of bytes in the heap, return
;the number of bytes in the heap's bitset, rounded up
;to the nearest long.
lostanza defn bitset-size (heap-size:long) -> long :
  ;heap-size-in-longs = ceil( heap-size * (1 long / 8 bytes) )
  val heap-size-in-longs = ((heap-size + (BYTES-IN-LONG - 1)) >> LOG-BYTES-IN-LONG)
  ;bitset-size-in-longs = ceil( heap-size-in-longs * (1 bit-in-bitset / 1 long) * (1 long / 64 bits) )
  val bitset-size-in-longs = (heap-size-in-longs + (BITS-IN-LONG - 1)) >> LOG-BITS-IN-LONG
  ;return bitset-size-in-longs * bytes-in-long
  return bitset-size-in-longs << LOG-BYTES-IN-LONG

;Sanity check: Ensure that the given pointer points to within the heap.
;Calls fatal if it is not.
lostanza defn ensure-pointer-in-heap! (p:ptr<?>, heap:ptr<Heap>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
    if p < heap.start or p >= heap.top :
      call-c clib/printf("Pointer p = %p\n", p)
      fatal!("Pointer is outside of heap.")
  return false

;Sanity check: Ensure that the given address range: start (inclusive) to limit (exclusive)
;is contained within the heap.
;Calls fatal if it is not.
lostanza defn ensure-address-range-in-heap! (start:ptr<?>, limit:ptr<?>, heap:ptr<Heap>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
    if start < heap.start or start > limit or limit > heap.top :
      call-c clib/printf("Address range is %p to %p.\n", start, limit)
      fatal!("Address range is outside of heap.")
  return false

;Return the index in the heap's bitset that acts as the mark for the heap pointer.
lostanza defn bit-index (p:ptr<?>, heap:ptr<Heap>) -> long :
  ensure-pointer-in-heap!(p, heap)
  return (p - heap.start) >> LOG-BYTES-IN-LONG
lostanza defn bit-index (p:ptr<?>) -> long :
  return p as long >> LOG-BYTES-IN-LONG

;Returns the pointer in the heap's bitset containing the given mark bit.
lostanza defn bit-address (bit-index:long, heap:ptr<Heap>) -> ptr<long> :
  return heap.bitset + (bit-index >> LOG-BITS-IN-LONG) << LOG-BYTES-IN-LONG
lostanza defn bit-address (bit-index:long, bitset-base:ptr<long>) -> ptr<long> :
  ;return heap.bitset + (bit-index >> LOG-BITS-IN-LONG) << LOG-BYTES-IN-LONG
  return bitset-base + (bit-index >> LOG-BITS-IN-LONG) << LOG-BYTES-IN-LONG
lostanza defn bit-address (p:ptr<long>, bitset-base:ptr<long>) -> ptr<long> :
  ;return heap.bitset + (bit-index >> LOG-BITS-IN-LONG) << LOG-BYTES-IN-LONG
  return bitset-base + (p as long >> (LOG-BITS-IN-LONG + LOG-BYTES-IN-LONG)) << LOG-BYTES-IN-LONG

;Returns bit-index % BITS-IN-LONG.
lostanza defn bit-shift (bit-index:long) -> long :
  return bit-index & (BITS-IN-LONG - 1)
lostanza defn bit-shift (p:ptr<?>) -> long :
  return bit-shift(bit-index(p))

;Assumes the bit-index designates a bit within some 64-bit long.
;Returns a mask containing a 1 in the same position as that bit within the long.
lostanza defn bit-mask (bit-index:long) -> long :
  return 1L << bit-shift(bit-index)
lostanza defn bit-mask (p:ptr<?>) -> long :
  return 1L << bit-shift(p)

;Returns a non-zero if the given heap pointer has been marked
;in the heap's bitset, and 0 otherwise.
lostanza defn test-mark (p:ptr<?>, heap:ptr<Heap>) -> long :
  ensure-pointer-in-heap!(p, heap)
  return test-mark(p, heap.bitset-base)
lostanza defn test-mark (p:ptr<?>, bitset-base:ptr<long>) -> long :
  return test-mark(bit-index(p), bitset-base)
lostanza defn test-mark (bit-index:long, bitset-base:ptr<long>) -> long :
  return call-prim test-bit(bit-index, bitset-base)

;Marks the given heap pointer in the heap's bitset.
public lostanza defn set-mark (p:ptr<?>, heap:ptr<Heap>) -> ref<False> :
  ensure-pointer-in-heap!(p, heap)
  return set-mark(p, heap.bitset-base)
lostanza defn set-mark (p:ptr<?>, bitset-base:ptr<long>) -> ref<False> :
  return set-mark(bit-index(p), bitset-base)
lostanza defn set-mark (bit-index:long, bitset-base:ptr<long>) -> ref<False> :
  call-prim set-bit(bit-index, bitset-base)
  ;No meaningful return value.
  return false

;Clears the mark for the given heap pointer in the heap's bitset.
public lostanza defn clear-mark (p:ptr<?>, heap:ptr<Heap>) -> ref<False> :
  ensure-pointer-in-heap!(p, heap)
  return clear-mark(p, heap.bitset-base)
lostanza defn clear-mark (p:ptr<?>, bitset-base:ptr<long>) -> ref<False> :
  return clear-mark(bit-index(p), bitset-base)
lostanza defn clear-mark (bit-index:long, bitset-base:ptr<long>) -> ref<False> :
  call-prim clear-bit(bit-index, bitset-base)
  ;No meaningful return value.
  return false

;Fused operation. Marks the given heap pointer in the heap's bitset.
;Returns non-zero value if the pointer was previously marked, otherwise 0L.
lostanza defn test-and-set-mark (p:ptr<?>, heap:ptr<Heap>) -> long :
  ensure-pointer-in-heap!(p, heap)
  return test-and-set-mark(p, heap.bitset-base)
lostanza defn test-and-set-mark (p:ptr<?>, bitset-base:ptr<long>) -> long :
  return test-and-set-mark(bit-index(p), bitset-base)
lostanza defn test-and-set-mark (bit-index:long, bitset-base:ptr<long>) -> long :
  return call-prim test-and-set-bit(bit-index, bitset-base)

;Fused operation. Clears the mark for the given heap pointer in the heap's bitset.
;Returns non-zero value if the pointer was previously marked, otherwise 0L.
public lostanza defn test-and-clear-mark (p:ptr<?>, heap:ptr<Heap>) -> long :
  ensure-pointer-in-heap!(p, heap)
  return test-and-clear-mark(p, heap.bitset-base)
lostanza defn test-and-clear-mark (p:ptr<?>, bitset-base:ptr<long>) -> long :
  return test-and-clear-mark(bit-index(p), bitset-base)
lostanza defn test-and-clear-mark (bit-index:long, bitset-base:ptr<long>) -> long :
  return call-prim test-and-clear-bit(bit-index, bitset-base)

;Clears the mark for the given heap address range.
lostanza defn clear-mark (start:ptr<?>, limit:ptr<?>, heap:ptr<Heap>) -> ref<False> :
  ensure-address-range-in-heap!(start, limit, heap)
  if start < limit :
    ;Compute start and ending masks.
    ;Supposing that start-bit-index is 9, then
    ;start-bit-mask is 0000 0000 1111 1111, which is used to zero-out all bits
    ;after the start-bit-index (inclusive).
    ;Supposing that end-bit-index is 9, then
    ;end-bit-mask is 1111 1110 0000 0000, which is used to zero-out all its
    ;before the end-bit-index (inclusive).
    val bitset-base = heap.bitset-base
    val start-bit-index = bit-index(start)
    val end-bit-index = bit-index(limit - 1)
    var start-bit-address:ptr<long> = bit-address(start-bit-index, bitset-base)
    val end-bit-address = bit-address(end-bit-index, bitset-base)
    val start-bit-mask = bit-mask(start-bit-index) - 1
    val end-bit-mask = -1L << bit-shift(end-bit-index) << 1

    ;Special case: the first bit word is the last bit word
    if start-bit-address == end-bit-address :
      ;Zero-out all bits where both masks are zero.
      [start-bit-address] = [start-bit-address] & (start-bit-mask | end-bit-mask)
    else :
      ;Zero-out the bits in the start and end words.
      [start-bit-address] = [start-bit-address] & start-bit-mask
      [end-bit-address] = [end-bit-address] & end-bit-mask
      ;Clear the intervening words completely.
      start-bit-address = start-bit-address + sizeof(long)
      clear(start-bit-address, end-bit-address - start-bit-address)
  ;No meaningful return value.
  return false

;Sets the mark for the given heap address range.
lostanza defn set-mark (start:ptr<?>, limit:ptr<?>, heap:ptr<Heap>) -> ref<False> :
  ensure-address-range-in-heap!(start, limit, heap)
  if start < limit :
    ;Compute start and ending masks.
    ;Supposing that start-bit-index is 9, then
    ;start-bit-mask is 0000 0000 1111 1111, which is used to zero-out all bits
    ;after the start-bit-index (inclusive).
    ;Supposing that end-bit-index is 9, then
    ;end-bit-mask is 1111 1110 0000 0000, which is used to zero-out all its
    ;before the end-bit-index (inclusive).
    val bitset-base = heap.bitset-base
    val start-bit-index = bit-index(start)
    val end-bit-index = bit-index(limit - 1)
    var start-bit-address:ptr<long> = bit-address(start-bit-index, bitset-base)
    val end-bit-address = bit-address(end-bit-index, bitset-base)
    val start-bit-mask = bit-mask(start-bit-index) - 1
    val end-bit-mask = -1L << bit-shift(end-bit-index) << 1

    ;Special case: the first bit word is the last bit word
    if start-bit-address == end-bit-address :
      ;Set all bits where both masks are ones.
      [start-bit-address] = [start-bit-address] | (start-bit-mask & end-bit-mask)
    else :
      ;Set the bits in the start and end words.
      [start-bit-address] = [start-bit-address] | start-bit-mask
      [end-bit-address] = [end-bit-address] | end-bit-mask
      ;Set all bits in the intervening words.
      start-bit-address = start-bit-address + sizeof(long)
      call-c clib/memset(start-bit-address, -1L, end-bit-address - start-bit-address)
  ;No meaningful return value.
  return false

lostanza defn iterate-marked (start:ptr<?>, limit:ptr<?>,
                              f:ptr<((ptr<?>, ptr<VMState>) -> ref<False>)>,
                              vms:ptr<VMState>) -> ref<False> :
  val heap = addr(vms.heap)
  ensure-address-range-in-heap!(start, limit, heap)
  if start < limit :
    val bitset-base = heap.bitset-base
    ;Compute starting shift and ending mask.
    ;Supposing that end-bit-index is 9, then end-bit-mask contains 0000 0001 1111 1111.
    val start-bit-index = bit-index(start)
    val end-bit-index = bit-index(limit - 1)
    var bit-address:ptr<long> = /bit-address(start-bit-index, bitset-base)
    val end-bit-address = /bit-address(end-bit-index, bitset-base)
    val start-bit-mask = -1L << bit-shift(start-bit-index)
    val end-bit-mask = (bit-mask(end-bit-index) << 1) - 1

    var bits:long = [bit-address] & start-bit-mask
    labels:
      start: goto entry()
      loop:
        bit-address = bit-address + sizeof(long)
        bits = [bit-address]
        goto entry()
      entry:
        while bits == 0L and bit-address < end-bit-address :
          bit-address = bit-address + sizeof(long)
          bits = [bit-address]
        if bit-address == end-bit-address :
          bits = bits & end-bit-mask
        ;Compute heap address corresponding to the lowest bit of [bit-address]
        var p:ptr<?> = ((bit-address - bitset-base) << LOG-BITS-IN-LONG) as ptr<?>
        while bits != 0 :
          val lowest-one = lowest-one(bits)
          bits = bits >> lowest-one >> 1
          p = p + lowest-one << LOG-BYTES-IN-LONG
          [f](p, vms)
          p = p + sizeof(long)
        if bit-address < end-bit-address : goto loop()
  return false

;Reset the incomplete range to the null interval.
;We deliberately set min to greater than any pointer in the heap,
;and set max to lower than any pointer in the heap,
;to prepare the incomplete range to be extended using extend-incomplete-range.
lostanza defn reset-incomplete-range (heap:ptr<Heap>) -> ref<False> :
  heap.min-incomplete = heap.limit
  heap.max-incomplete = heap.start
  ;No meaningful return value
  return false

;Extend the incomplete range by ensuring the given heap pointer p
;is within the incomplete range.
lostanza defn extend-incomplete-range (p:ptr<?>, heap:ptr<Heap>) -> ref<False> :
  if p < heap.min-incomplete : heap.min-incomplete = p
  if p > heap.max-incomplete : heap.max-incomplete = p
  ;No meaningful return value
  return false

;Push a new pointer onto the marking stack.
;Note that the marking stack grows downwards.
lostanza defn push-to-marking-stack (p:ptr<long>, heap:ptr<Heap>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
    if marking-stack-full(heap) : fatal!("Marking stack overflow.")
  val stack-top = heap.stack-top - sizeof(long)
  heap.stack-top = stack-top
  [stack-top] = p as long
  return false

;Pop a pointer from the marking stack.
;Note that the marking stack grows downwards.
lostanza defn pop-marking-stack (heap:ptr<Heap>) -> ptr<long> :
  #if-not-defined(OPTIMIZE) :
    if marking-stack-empty(heap) : fatal!("Marking stack underflow.")
  val stack-top = heap.stack-top
  heap.stack-top = stack-top + sizeof(long)
  return [stack-top] as ptr<long>

;Returns 1L if the marking stack is not empty.
;The marking stack grows downwards, so it is not empty
;if the top is less than the bottom.
lostanza defn marking-stack-not-empty (heap:ptr<Heap>) -> long :
  return heap.stack-top < heap.stack-bottom

;Returns 1L if the marking stack is empty.
lostanza defn marking-stack-empty (heap:ptr<Heap>) -> long :
  return heap.stack-top == heap.stack-bottom

;Return 1L if the marking stack is full.
lostanza defn marking-stack-full (heap:ptr<Heap>) -> long :
  return heap.stack-top == heap.stack-start

;Mark the object at the given heap pointer.
;On marking stack overflow the depth-first object traversal is pruned, and
;the marked objects with possibly unmarked children are added to the range
;of incompletely marked objects.
lostanza defn mark-and-push (ref:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  val heap = addr(vms.heap)
  ;Retrieve the value at the given heap pointer.
  val v = [ref]
  ;Is this a reference to a Stanza heap object?
  val tagbits = v & 7L
  if tagbits == 1L :
    ;Remove the tagbits to retrieve the object pointer.
    val p = (v - 1) as ptr<long>
    ;Mark the object, and test whether it has already previously been marked.
    if test-and-set-mark(p, heap) == 0 :
      ;If there is still space in the marking stack add the object to the
      ;marking stack, otherwise add it to the incomplete range.
      if marking-stack-full(heap) : extend-incomplete-range(p, heap)
      else : push-to-marking-stack(p, heap)
  ;No meaningful return value
  return false

;Given 'ref', a pointer to a root variable (e.g. global, const, etc.),
;mark it and iteratively traverse through its referenced objects.
public lostanza defn mark-from-root (ref:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  ;Retrieve the value at the given heap pointer.
  val v = [ref]
  ;Is this a reference to a Stanza heap object?
  val tagbits = v & 7L
  if tagbits == 1L :
    ;Remove the tag bits to retrieve the object pointer.
    val p = (v - 1) as ptr<long>
    ;Mark the object, and continue marking the object graph if it
    ;has not previously been marked.
    if test-and-set-mark(p, addr(vms.heap)) == 0 :
      continue-marking(p, vms)
  ;No meaningful return value
  return false

;Given the pointer p to an already-marked object,
;mark all the objects that it references and traverse the object graph.
;Marks as many objects as possible given the size of the marking stack.
lostanza defn continue-marking (p:ptr<?>, vms:ptr<VMState>) -> ref<False> :
  val heap = addr(vms.heap)
  #if-not-defined(OPTIMIZE) :
    if test-mark(p, heap) == 0 : fatal!("Marked object expected.")
  ;Initialize the marking stack with p.
  push-to-marking-stack(p, heap)
  ;Iteratively traverse and mark the object graph.
  while marking-stack-not-empty(heap) :
    iterate-references(pop-marking-stack(heap), addr(mark-and-push), vms)
  ;No meaningful return value
  return false

;Recover from possible marking stack overflow by using marked objects from
;the range of incompletely marked objects as additional roots
public lostanza defn complete-marking (vms:ptr<VMState>) -> ref<False> :
  val heap = addr(vms.heap)
  ;If the incomplete range is not empty,
  while heap.min-incomplete <= heap.max-incomplete :
    ;We add BYTES-IN-LONG to max-incomplete because max-incomplete is inclusive
    ;and 'iterate-marked' needs exclusive bounds.
    val incomplete-start = heap.min-incomplete
    val incomplete-limit = heap.max-incomplete + BYTES-IN-LONG

    ;Call continue-marking on all marked pointers in the incomplete range.
    ;We reset the incomplete range before we do this so that if the marking
    ;stack overflows, the remaining pointers are stored in the incomplete range.
    reset-incomplete-range(heap)
    iterate-marked(incomplete-start, incomplete-limit, addr(continue-marking), vms)
  ;No meaningful return value
  return false

;Call f on all root pointers.
lostanza defn iterate-roots (f:ptr<((ptr<long>, ptr<VMState>) -> ref<False>)>,
                             vms:ptr<VMState>) -> ref<False> :
  ;Scan stack roots
  [f](addr(vms.heap.current-stack), vms)
  [f](addr(vms.heap.system-stack), vms)

  ;Scan roots defined by the environment
  return [vms.heap.iterate-roots](f, vms)

;Call f on all references stored in the object pointed to by p.
lostanza defn iterate-references (p:ptr<long>,
                                  f:ptr<((ptr<long>, ptr<VMState>) -> ref<False>)>,
                                  vms:ptr<VMState>) -> ref<False> :
  ;Retrieve the object's tag.
  val tag = get-tag(p)
  ;Fast path using fast descriptor table.
  val descriptor = addr(vms.class-table[tag])
  val case = descriptor.case
  if case == FAST-LAYOUT-BASE-WITH-REFS :
    ;Call f on every slot in the object.
    val obj = p as ptr<ObjectLayout>
    val num-slots = descriptor.num-base-bytes >> 3
    for (var i:int = 0, i < num-slots, i = i + 1) :
      [f](addr(obj.slots[i]), vms)
  else if case == FAST-LAYOUT-ARRAY-REF-TAIL :
    ;Call f on every slot in the fail.
    val obj = p as ptr<ObjectLayout>
    val len = obj.slots[0]
    val tail = addr(obj.slots) + descriptor.num-base-bytes
    for (var i:int = 0, i < len, i = i + 1) :
      [f](addr(tail[i]), vms)
  else if case == FAST-LAYOUT-GENERAL :
    ;General case: Use the full layout record
    val class-rec = descriptor.record
    if class-rec.item-size == 0 :
      val roots = addr(class-rec.roots)
      val num-roots = class-rec.num-roots
      val obj = p as ptr<ObjectLayout>
      for (var i:int = 0, i < num-roots, i = i + 1) :
        val r = roots[i]
        [f](addr(obj.slots[r]), vms)
    ;Array class
    else :
      val array-rec = class-rec as ptr<ArrayRecord>
      val array = p as ptr<ObjectLayout>

      val num-base-roots = array-rec.num-base-roots
      val base-roots = addr(array-rec.roots)
      for (var i:int = 0, i < num-base-roots, i = i + 1) :
        val r = base-roots[i]
        [f](addr(array.slots[r]), vms)

      val num-item-roots = array-rec.num-item-roots
      if num-item-roots > 0 :
        var items:ptr<?> = addr(array.slots) + array-rec.base-size
        val item-size = array-rec.item-size
        val item-roots = addr(array-rec.roots[num-base-roots])
        val len = array.slots[0]
        for (var n:long = 0, n < len, n = n + 1) :
          for (var i:int = 0, i < num-item-roots, i = i + 1) :
            [f](items + item-roots[i], vms)
          items = items + item-size

  ;No meaningful return value
  return false

public lostanza defn iterate-references-in-stack-frames (stack:ptr<Stack>,
                                                         f:ptr<((ptr<long>, ptr<VMState>) -> ref<False>)>,
                                                         vms:ptr<VMState>) -> ref<False> :
  if stack.frames != null :
    [vms.heap.iterate-references-in-stack-frames](stack, f, vms)
  ;No meaningful return value
  return false

;Given p, a heap pointer pointing to the start of an object (i.e. at
;the header word), return the total size of the object. This
;function takes care of handling variable-sized arrays.
public lostanza defn allocation-size (p:ptr<long>, vms:ptr<VMState>) -> long :
  ;Retrieve the object's tag.
  val tag = get-tag(p)
  ;Fast path using fast descriptor table.
  val descriptor = addr(vms.class-table[tag])
  val case = descriptor.case
  if case == FAST-LAYOUT-BASE-WITH-REFS :
    return object-size-on-heap(descriptor.num-base-bytes)
  else if case == FAST-LAYOUT-ARRAY-REF-TAIL :
    val len = (p as ptr<ObjectLayout>).slots[0]
    return object-size-on-heap(descriptor.num-base-bytes + len << 3)
  else if case == FAST-LAYOUT-BASE-WITH-NO-REFS :
    return object-size-on-heap(descriptor.num-base-bytes)
  else if case == FAST-LAYOUT-ARRAY-1-BYTE-TAIL :
    val len = (p as ptr<ObjectLayout>).slots[0]
    return object-size-on-heap(descriptor.num-base-bytes + len)
  else if case == FAST-LAYOUT-ARRAY-8-BYTE-TAIL :
    val len = (p as ptr<ObjectLayout>).slots[0]
    return object-size-on-heap(descriptor.num-base-bytes + len << 3)
  else if case == FAST-LAYOUT-ARRAY-4-BYTE-TAIL :
    val len = (p as ptr<ObjectLayout>).slots[0]
    return object-size-on-heap(descriptor.num-base-bytes + len << 2)
  else :
    ;General case
    ;Use the tag to retrieve the object's class record.
    val class-rec = descriptor.record
    ;Fixed-length objects have an item-size of 0.
    if class-rec.item-size == 0 :
      return object-size-on-heap(class-rec.size)
    ;Otherwise, it's a variable-length array object.
    else :
      val array-rec = class-rec as ptr<ArrayRecord>
      val base-size = array-rec.base-size
      val item-size = array-rec.item-size
      val array = p as ptr<ObjectLayout>
      val len = array.slots[0]
      return object-size-on-heap(base-size + item-size * len)

public lostanza defn object-size-on-heap (size:long) -> long :
  return (size + 15L) & -8L

;Scan through current heap stacks list and update them. After this function finishes
;current heap stacks list shall contain only Stacks that are still live.
lostanza defn scan-stacks (vms:ptr<VMState>) -> ref<False> :
  val bitset-base = vms.heap.bitset-base
  var live-stacks:ptr<Stack> = null
  ;Scan reachable stacks
  var previous-stacks:ptr<Stack> = vms.heap.stacks
  ;Some stacks were marked at previous iteration
  while live-stacks != previous-stacks :
    ;Remember current state of live-stacks list
    previous-stacks = live-stacks
    ;Complete previous marking before testing if the stacks are marked.
    complete-marking(vms)
    var p:ptr<ptr<Stack>> = addr(vms.heap.stacks)
    while [p] != null :
      val stack = [p]
      val stack-obj = stack as ptr<?> - sizeof(long)
      if test-mark(stack-obj, bitset-base) :
        ;Mark references in stack frames
        iterate-references-in-stack-frames(stack, addr(mark-from-root), vms)
        ;Remove stack from heap.stacks list
        [p] = stack.tail
        ;Insert stack to live-stacks list
        stack.tail = live-stacks
        live-stacks = stack
      else :
        ;Proceed to next stack in heap.stacks list
        p = addr(stack.tail)
  ;Now heap.stacks list contains unreachable stacks only. Dispose their frames.
  free-stack-list(vms.heap.stacks, addr(vms.heap))
  vms.heap.stacks = live-stacks
  ;No meaningful return value
  return false

lostanza defn relocate-stacks (vms:ptr<VMState>) -> ref<False> :
  val compaction-start = vms.heap.compaction-start
  ;p is a pointer to the list being scanned.
  var p:ptr<ptr<Stack>> = addr(vms.heap.stacks)
  while [p] != null :
    val stack = [p]
    if stack > compaction-start :
      val stack-obj = (stack as ptr<long>) - sizeof(long)
      [p] = stack + relocation-offset(stack-obj)
    iterate-references-in-stack-frames(stack, addr(relocate-reference), vms)
    ;Go to the next element in the list.
    p = addr(stack.tail)
  ;No meaningful return value
  return false

;Mark all reachable objects.
lostanza defn mark-reachable-objects (vms:ptr<VMState>) -> ref<False> :
  ;Reset the incomplete range and call mark-from-root on all roots.
  reset-incomplete-range(addr(vms.heap))
  iterate-roots(addr(mark-from-root), vms)
  scan-stacks(vms)
  ;No meaningful return value
  return false

;Scans the heap from given start to heap top until first unmarked object found.
;Clear the scanned objects marks. Returns address of the first unmarked object,
;or the heap top if it is not found.
lostanza defn skip-live (start:ptr<long>, vms:ptr<VMState>) -> ptr<long> :
  ;Precondition: Ensure that given start is below heap-top.
  val heap-top = vms.heap.top
  #if-not-defined(OPTIMIZE) :
    if start > heap-top : fatal!("Invalid start.")

  ;Start scan pointer from the given start, proceeding until we hit heap top.
  for (var p:ptr<long> = start, p < heap-top, p = p + allocation-size(p, vms)) :
    ;If the pointer points to an unmarked object
    ;then return that pointer immediately. Clears the
    ;mark at the same time.
    if test-and-clear-mark(p, addr(vms.heap)) == 0 : return p

  ;Return the heap-top to indicate no unmarked object found.
  return heap-top

;Scans the heap from given start to heap top until first unmarked object found.
;Clear the scanned objects marks. Returns address of the first unmarked object,
;or the heap top if it is not found.
lostanza defn update-and-skip-live (start:ptr<long>, offset:long, vms:ptr<VMState>) -> ptr<long> :
  ;Precondition: Ensure that given start is below heap-top.
  val heap-top = vms.heap.top
  #if-not-defined(OPTIMIZE) :
    if start > heap-top : fatal!("Invalid start.")

  ;Start scan pointer from the given start, proceeding until we hit heap top.
  for (var p:ptr<long> = start, p < heap-top, p = p + allocation-size(p, vms)) :
    ;If the pointer points to an unmarked object
    ;then return that pointer immediately. Clears the
    ;mark at the same time.
    if test-and-clear-mark(p, addr(vms.heap)) == 0 : return p
    update-references(p, offset, vms)

  ;Return the heap-top to indicate no unmarked object found.
  return heap-top

lostanza defn lowest-zero-bit-count (x:long) -> long :
  if x == 0 : return -1L

  ;Ones are rare, expect zeroes
  var index:long = 0
  var bits:long = x
  ;If the next 32 bits in 'bits' is zero, then
  ;advance bits and index by 32.
  if (bits & 0xFFFFFFFFL) == 0 :
    bits = bits >> 32
    index = index + 32
  ;If the next 16 bits in 'bits' is zero, then
  ;advance bits and index by 16.
  if (bits & 0xFFFFL) == 0 :
    bits = bits >> 16
    index = index + 16
  ;If the next 8 bits in 'bits' is zero, then
  ;advance bits and index by 8.
  if (bits & 0xFFL) == 0 :
    bits = bits >> 8
    index = index + 8
  ;If the next 4 bits in 'bits' is zero, then
  ;advance bits and index by 4.
  if (bits & 0xFL) == 0 :
    bits = bits >> 4
    index = index + 4
  ;If the next 2 bits in 'bits' is zero, then
  ;advance bits and index by 2.
  if (bits & 0x3L) == 0 :
    bits = bits >> 2
    index = index + 2
  ;If the next bit in 'bits' is zero, then
  ;advance index by 1.
  if (bits & 0x1L) == 0 :
    index = index + 1
  return index

public lostanza defn lowest-zero-bit-count (a:ref<Long>) -> ref<Long> :
  return new Long{lowest-zero-bit-count(a.value)}

lostanza defn lowest-one (bit-word:long) -> long :
  return call-prim lowest-zero-bit-count(bit-word)

;Scans the heap from given start to heap top until first marked object found.
;Returns address of the first unmarked object or the heap top if it is not found.
lostanza defn skip-dead (start:ptr<long>, heap:ptr<Heap>) -> ptr<long> :
  val heap-top = heap.top
  #if-not-defined(OPTIMIZE) :
    if start > heap-top : fatal!("Invalid start.")
  val bitset-base = heap.bitset-base
  ;Compute starting shift and ending mask.
  ;Supposing that end-bit-index is 9, then end-bit-mask contains 0000 0001 1111 1111.
  val start-bit-index = bit-index(start)
  val end-bit-index = bit-index(heap-top - 1)
  var p:ptr<long> = bit-address(start-bit-index, bitset-base)
  val end-bit-address = bit-address(end-bit-index, bitset-base)
  val start-bit-mask = -1L << bit-shift(start-bit-index)
  val end-bit-mask = (bit-mask(end-bit-index) << 1) - 1

  var bits:long = [p] & start-bit-mask
  while bits == 0L and p < end-bit-address :
    p = p + sizeof(long)
    bits = [p]
  if p == end-bit-address :
    bits = bits & end-bit-mask
    if bits == 0L : return heap-top
  ;Compute heap address corresponding to the lowest bit of bitset word [p]
  return ((p - bitset-base) << LOG-BITS-IN-LONG) as ptr<long> + lowest-one(bits) << LOG-BYTES-IN-LONG

;Represents a live range: a region of live objects.
;- live: the address of the first live object in the range.
;- dead: the address just past the last live object in the range.
lostanza deftype LiveRange :
  live:ptr<long>
  dead:ptr<long>

;Write the live range r into the heap address at the given break location.
;
;Live ranges are stored directly in the heap memory, in the space
;currently occupied by dead objects: the breaks.
;
;The encoding varies depending upon the size of the break.
;The minimum size of a break is 8 bytes long, but the live range struct is
;in general 16 bytes long.
;
;Encoding:
;Case break >= 16 bytes: then just directly store the live range.
;Case break == 8 bytes: only store the 'dead' field, tagged with 1.
;
;Since heap addresses are always 8-byte aligned, the tagged 1 will tell us
;which encoding we are using.
lostanza defn write-live-range (location:ptr<long>, r:LiveRange) -> ref<False> :
  ;Case: break == 8 bytes.
  if addr(location[1]) == r.live :
    ;Store the tagged 'dead' field.
    location[0] = (r.dead as long) | 1
  ;Case: break >= 16 bytes.
  else :
    ;Store the live range directly.
    location[0] = r.live as long
    location[1] = r.dead as long
  ;No meaningful return value
  return false

;Read the live range at the given break location.
lostanza defn read-live-range (location:ptr<long>) -> LiveRange :
  ;Read the first word at the location.
  val location0 = location[0]
  ;Test the tag bit to determine which encoding we are using.
  if location0 & 1L :
    ;Case break == 8 bytes.
    val live = addr(location[1])             ;Computed from size of break.
    val dead = (location0 - 1) as ptr<long>  ;Remove tag bit.
    return LiveRange{live, dead}
  else :
    ;Case break >= 16 bytes.
    val live = location0 as ptr<long>
    val dead = location[1] as ptr<long>
    return LiveRange{live, dead}

;Create a list of live ranges, compute new object locations and relocate references
; in compaction area.
;- compaction-start is the address of the lowest unmarked object if one exists, or
;  heap-top if it doesn't.
;After this function finishes:
;1) List of live ranges will be created in the gaps between live objects. The list starts
;   at compaction-start.
;2) Relocation offset of each object will be recorded in spare bits of its header.
;3) References in compaction area will be relocated to object locations after compaction.
;4) The compaction start address will be recorded in the heap.
;5) The heap top will be updated.
lostanza defn create-live-ranges (compaction-start:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  ;Record the compaction-start address.
  vms.heap.compaction-start = compaction-start

  ;- limit: the top of the heap
  ;- offset: the accumulated offset that all objects in the current live range
  ;  should be moved by. Guaranteed to be strictly negative because
  ;  objects can only move downwards during compaction phase.
  ;- current-dead: points to the next gap in the heap.
  val limit = vms.heap.top
  var offset:long = 0
  var current-dead:ptr<long> = compaction-start
  while current-dead < limit :
    ;Compute the details of the next live range.
    ;The live range starts at 'next-marked' and ends at 'next-unmarked'.
    ;If there are no more marked objects, then record current-unmarked
    ;as the top of the heap, and return immediately.
    val next-live = skip-dead(current-dead, addr(vms.heap))
    if next-live == limit :
      vms.heap.top = current-dead
      return false

    ;Compute the length of the current break, and update the
    ;accumulated offset.
    offset = offset - (next-live - current-dead)

    val next-dead = update-and-skip-live(next-live, offset, vms)
    ;Store the live range information in the heap in the
    ;current break.
    write-live-range(current-dead, LiveRange{next-live, next-dead})

    ;Advance past the live range to the next potential break.
    current-dead = next-dead
  ;No meaningful return value
  return false

lostanza val TAG-BITS-IN-HEADER:long = 16
lostanza val TAG-MASK-IN-HEADER:long = (1L << (TAG-BITS-IN-HEADER + 1)) - 1L

lostanza defn get-tag (p:ptr<long>) -> long :
  return [p] & TAG-MASK-IN-HEADER

;Returns the offset that needs to be added to an object to
;compute its new address after compaction.
;- p: The pointer to the object.
lostanza defn relocation-offset (p:ptr<long>) -> long :
  val offset = [p] >>> TAG-BITS-IN-HEADER ;Relocation offset is negative.
  #if-not-defined(OPTIMIZE) :
    if offset >= 0L :
      fatal!("Invalid relocation offset.")
  return offset

lostanza defn clear-relocation-offset (range:LiveRange, vms:ptr<VMState>) -> ref<False> :
  for (var p:ptr<long> = range.live, p < range.dead, p = p + allocation-size(p, vms)) :
    [p] = [p] & TAG-MASK-IN-HEADER
  ;No meaningful return value.
  return false

lostanza defn update-references (p:ptr<long>, offset:long, vms:ptr<VMState>) -> ref<False> :
  var ref:ptr<long> = [p] as ptr<long>
  val limit = TAG-MASK-IN-HEADER as ptr<long>
  val new-value = p as long + offset + 1L ;For a tag
  while ref > limit :
    val next = [ref] as ptr<long>
    [ref] = new-value
    ref = next
  [p] = ref as long | (offset << TAG-BITS-IN-HEADER)
  return iterate-references(p, addr(relocate-or-reverse-reference), vms)

;Given a pointer to an object reference, write its new value after compaction in-place.
lostanza defn relocate-reference (ref:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  ;Retrieve the value at the given heap pointer.
  val v = [ref]
  ;Is this a reference to a Stanza heap object?
  val tagbits = v & 7L
  if tagbits == 1L :
    ;Remove the tag bits to retrieve the object pointer.
    val p = (v - 1) as ptr<long>
    ;Only pointers to objects in the compaction area are relocated.
    if p > vms.heap.compaction-start :
      [ref] = v + relocation-offset(p)
  ;No meaningful return value
  return false

;Given a pointer to an object reference, write its new value after compaction in-place.
lostanza defn relocate-remembered-reference (ref:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  ;Retrieve the value at the given heap pointer.
  val v = [ref]
  ;Remove the tag bits to retrieve the object pointer.
  val p = (v - 1) as ptr<long>
  ;Only pointers to objects in the compaction area are relocated.
  if p > vms.heap.compaction-start :
    [ref] = v + relocation-offset(p)
  ;No meaningful return value
  return false

lostanza defn relocate-or-reverse-reference (ref:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  ;Retrieve the value at the given heap pointer.
  val v = [ref]
  ;Is this a reference to a Stanza heap object?
  val tagbits = v & 7L
  if tagbits == 1L :
    ;Remove the tag bits to retrieve the object pointer.
    val p = (v - 1) as ptr<long>
    ;Only pointers to objects in the compaction area are relocated.
    if p > vms.heap.compaction-start :
      ;The heap is scanned from the start to the top. Objects above the reference
      ;are not scanned yet, so their relocation offsets are not yet computed.
      if p > ref :
        ;Link the reference to the list of other references to the object.
        ;References in the list will be resolved when the object is scanned.
        [ref] = [p]
        [p] = ref as long
      else :
        ;Relocation offset is already known. Relocate the reference.
        [ref] = v + relocation-offset(p)
  ;No meaningful return value
  return false

lostanza defn relocate-solid-prefix-references (vms:ptr<VMState>) -> ref<False> :
  val limit = vms.heap.compaction-start
  for (var p:ptr<long> = vms.heap.start, p < limit, p = p + allocation-size(p, vms)) :
    iterate-references(p, addr(relocate-reference), vms)
  ;No meaningful return value
  return false

;Move objects in heap to lower memory as part of compaction.
lostanza defn compact (vms:ptr<VMState>) -> ref<False> :
  ;offset holds the amount that objects need to be
  ;shifted by to reach their new location.
  val heap = addr(vms.heap)
  var offset:long = 0
  val top = heap.top
  var dead:ptr<long> = heap.compaction-start
  while dead < top :
    ;Read the live range annotated in the current break.
    val next = read-live-range(dead)
    clear-relocation-offset(next, vms)
    ;The span of dead objects spans from dead (the end of the previous
    ;live range) to next.live (the start of the next live range).
    offset = offset - (next.live - dead)
    ;Shift the entire live range down by 'offset'.
    call-c clib/memcpy(next.live + offset, next.live, next.dead - next.live)
    ;Advance to the next break.
    dead = next.dead
  ;Record the new heap top.
  heap.top = top + offset
  ;No meaningful return value
  return false

;Used as callback to iterate-marked. GC is incorrect if ever called.
lostanza defn fatal-object-marked! (p:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  fatal!("Unexpected marked object.")
  ;No meaningful return value
  return false

;Calls fatal if any object in the heap is marked.
lostanza defn ensure-no-marks-in-collection-area! (vms:ptr<VMState>) -> ref<False> :
  #if-defined(STRESS-TEST) :
    ;Iterate through the collection area of the heap and
    ;call fatal on any marked bits.
    iterate-marked(vms.heap.start, vms.heap.top, addr(fatal-object-marked!), vms)
  ;No meaningful return value
  return false

;Print every pointer in the remembered set.
lostanza defn print-remembered-set (vms:ptr<VMState>) -> ref<False> :
  val heap = addr(vms.heap)
  val heap-top = heap.top
  labels:
    begin: goto loop(heap.start)
    loop (p:ptr<long>) :
      if p < heap-top :
        val size = allocation-size(p,vms)
        val ptag = get-tag(p)
        for (var offset:long = 8, offset < size, offset = offset + 8) :
          if test-mark(p + offset, heap) :
            call-c clib/printf("  Object %p (tag %d): Field %d marked in remembered set.\n",
                               p, ptag, offset / 8)
        goto loop(p + size)
  return false

;============================================================
;=================== Reference Copy =========================
;============================================================

public lostanza defn refcpy (dst:ptr<?>, src:ptr<?>, nrefs:long) -> ref<False> :
  val size = nrefs << 3L
  call-c clib/memcpy(dst, src, size)

  val vms:ptr<VMState> = call-prim flush-vm()
  if dst < vms.heap.old-objects-end :
    set-mark(dst, dst + size, addr(vms.heap))
  ;No meaningful return value
  return false

;============================================================
;=========== Ensure Write Barrier Invariants ================
;============================================================

;Ensures that the write barrier invariants are satisfied by the heap.
lostanza defn ensure-write-barrier-invariants! (vms:ptr<VMState>) -> ref<False> :
  ;Pull out heap from VMState
  val heap = addr(vms.heap)
  ;Scan through all objects in the old generation, and iterate through
  ;the references. Ensure that the following invariant holds:
  ;For each internal reference:
  ;  Case pointer to young-gen: Ensure that the remembered bit is set.
  val old-objects-end = heap.old-objects-end
  for (var p:ptr<long> = heap.start, p < old-objects-end, p = p + allocation-size(p, vms)) :
    iterate-references(p, addr(check-write-barrier-invariants!), vms)
  return false

;Callback to ensure that a single reference satisfies the write barrier invariants.
lostanza defn check-write-barrier-invariants! (p:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  val heap = addr(vms.heap)
  ;Perform these checks:
  ;Case pointer to young-gen: Ensure that the remembered bit is set.
  val objref = [p]
  val tagbits = objref & 7L
  if tagbits == 1L :
    val objptr = (objref - 1L) as ptr<long>
    ;Is the pointer pointing into the young gen?
    if objptr >= heap.old-objects-end :
      ;Error if the remembered bit is not set.
      if test-mark(p, heap) == 0 :
        call-c clib/printf("Pointer %p into young-gen (%p) is not marked in remembered set.\n", p, objptr)
        fatal!("Write barrier invariants not satisfied.")
  ;Meaningless return
  return false

;============================================================
;========== Full-Heap Mark-Compact Algorithm ==============
;============================================================

;This is the mark-compact garbage collection algorithm for old objects.
lostanza defn mark-compact (vms:ptr<VMState>) -> ref<False> :
  clear-mark(vms.heap.start, vms.heap.top, addr(vms.heap))

  ;Three major phases:
  ;1. Mark
  ;2. Relocate references
  ;2.1. Skip solid prefix.
  ;2.2. Create a list of live ranges in compaction area, compute relocation offset for each live object,
  ;     relocate the references from live objects in compation area.
  ;2.3. Relocate references to moving objects from other areas: solid prefix, liveness trackers,
  ;     stack frames and globals.
  ;3. Compact

  ;Phase 1. Mark
  mark-reachable-objects(vms)
  scan-liveness-trackers(vms)

  ;Phase 2. Relocate references
  ;Skip solid prefix
  ;Find the first unmarked object. If there is one, then this is where compaction begins.
  val compaction-start = skip-live(vms.heap.start, vms)
  if compaction-start < vms.heap.top :
    ;2.2. Construct live ranges, compute relocation offset for each live object,
    ;relocate references in relocation area
    create-live-ranges(compaction-start, vms)
    ;2.3. Relocate references from other areas
    ;Relocate solid prefix separately because it is not in compaction area.
    relocate-solid-prefix-references(vms)
    ;Relocate liveness trackers separately because their
    ;references are not typed as references.
    relocate-liveness-trackers(vms)
    ;Relocate stacks separately because their list is not typed as references
    ;and their frames are allocated off-heap.
    relocate-stacks(vms)
    ;Relocate all GC roots. The roots must be relocated after the stacks.
    iterate-roots(addr(relocate-reference), vms)

    ;Phase 3. Compact
    compact(vms)
  vms.heap.old-objects-end = vms.heap.top

  ;Post condition: All marks should be cleared.
  ensure-no-marks-in-collection-area!(vms)

  ;No meaningful return value
  return false

;============================================================
;====== Evacuation of live objects from the nursery =========
;============================================================

lostanza defn available-space (heap:ptr<Heap>) -> long :
  return heap-end(heap) - heap.old-objects-end

;Returns the address of the start of the nursery.
;Heap layout is: | OLD OBJECTS | RESERVED TO-SPACE | NURSERY | FREE SPACE
;- The total available space between the old objects and heap.limit is
;  heap.limit - heap.old-objects-end.
;- Nursery is sized to be half that available space rounded down to nearest long.
protected lostanza defn nursery-start (heap:ptr<Heap>) -> ptr<long> :
  val nursery-size = ((heap.limit - heap.old-objects-end) >> 1L) & -8L
  return heap.limit - nursery-size

;The header word of an object is typically used to store the type tag.
;In this configuration, the header word has structure:
;  [  Zeros (48 bits) | Type Tag (16 bits) ]
;During evacuation of the nursery, we store the forwarding pointer
;in this header word. So we assume that if the first 48 bits is non-zero then
;it is a forwarding pointer, otherwise it is the header word of a not-yet-copied object.
lostanza defn forwarding-pointer? (header-word:long) -> long :
  return header-word >> TAG-BITS-IN-HEADER

;Given 'ref', a pointer to a root variable (e.g. global, field, etc.),
;resolve or copy the referenced object.
lostanza defn copy-object (ref:ptr<long>, vms:ptr<VMState>) -> ref<False> :
  ;Retrieve the value at the given heap pointer and preemptively remove the tag bit.
  val v = [ref] - 1L
  ;Is this a reference to a Stanza heap object?
  if (v & 7L) == 0L :
    ;Cast the bits to an object pointer.
    val src = v as ptr<long>
    ;Is it in the nursery?
    if src >= vms.heap.top :
      if forwarding-pointer?([src]) == 0L :
        val size = allocation-size(src, vms)
        ;Allocate the copy
        val dst = vms.heap.top
        vms.heap.top = dst + size
        ;Copy the data and store tagged destination as a forwardng pointer
        [src] = call-c clib/memcpy(dst, src, size) as long + 1L
      ;Update the reference with the forwarding pointer
      [ref] = [src]
  ;No meaningful return value
  return false

lostanza defn complete-copying (vms:ptr<VMState>) -> ref<False> :
  var p:ptr<long> = vms.heap.old-objects-end
  while p < vms.heap.top :
    ;TODO: iterate-references and allocation-size can be fused into iterate-references-and-return-size
    iterate-references(p, addr(copy-object), vms)
    p = p + allocation-size(p, vms)
  vms.heap.old-objects-end = p
  #if-not-defined(OPTIMIZE) :
    if p != vms.heap.top :
      fatal!("Failure to complete copying.")
  ;No meaningful return value
  return false

lostanza defn copy-stacks (vms:ptr<VMState>) -> ref<False> :
  ;List of stacks is ordered. New stacks are inserted to the list head.
  ;First skip new stacks.
  val limit = vms.heap.top
  var p:ptr<ptr<Stack>> = addr(vms.heap.stacks)
  while [p] >= limit :
    val stack = [p]
    p = addr(stack.tail)
  ;The tail of the list consists of old stacks. They are considered live.
  var live-stacks:ptr<Stack> = [p]
  ;Remove old stacks from heap.stacks list.
  [p] = null
  ;Scan old stacks, copy references in their frames.
  for (var stack:ptr<Stack> = live-stacks, stack != null, stack = stack.tail) :
    iterate-references-in-stack-frames(stack, addr(copy-object), vms)
  ;Scan reachable new stacks
  var previous-stacks:ptr<Stack> = vms.heap.stacks
  ;Is there any progress?
  while live-stacks != previous-stacks :
    ;Remember current state of live-stacks list
    previous-stacks = live-stacks
    ;Complete previous copying before testing whether some stacks were copied.
    complete-copying(vms)
    var p:ptr<ptr<Stack>> = addr(vms.heap.stacks)
    while [p] != null :
      val stack = [p]
      val stack-obj = stack as ptr<long> - sizeof(long)
      val tag = [stack-obj]
      if forwarding-pointer?(tag) :
        ;Remove stack from heap.stacks list
        [p] = stack.tail
        val stack-copy:ptr<Stack> = untag(tag)
        ;Insert dst to live-stacks list
        stack-copy.tail = live-stacks
        live-stacks = stack-copy
        ;Copy references in stack frames
        iterate-references-in-stack-frames(stack-copy, addr(copy-object), vms)
      else :
        ;Proceed to next stack in heap.stacks list
        p = addr(stack.tail)
  ;Now heap.stacks list contains unreachable new stacks only. Dispose their frames.
  free-stack-list(vms.heap.stacks, addr(vms.heap))
  ;Update the list
  vms.heap.stacks = live-stacks
  ;No meaningful return value
  return false

lostanza defn update-liveness-trackers (vms:ptr<VMState>) -> ref<False> :
  ;List of liveness trackers is ordered. New trackers are inserted to the list head.
  val limit = vms.heap.top

  ;p is a pointer to the list being scanned.
  var p:ptr<ptr<LivenessTracker>> = addr(vms.heap.liveness-trackers)

  ;Scan while p points to a tracker within the collection-area.
  ;(The end of the list is represented using a null pointer.)
  ;TODO: Rewrite this loop with labels
  while [p] >= limit :
    ;Retrieve the next ptr<LivenessTracker> in the list.
    val tracker = [p]
    ;Compute the pointer to the start of the object by decrementing
    ;the size of the header word. This pointer is what is marked
    ;in the bitset.
    val tracker-obj = (tracker as ptr<long>) - sizeof(long)
    val tag = [tracker-obj]
    if forwarding-pointer?(tag) :
      val tracker-copy:ptr<LivenessTracker> = untag(tag)
      ;Set the value field on the tracker to false if it
      ;no longer refers to a live Unique object. We can assume that
      ;value currently holds a pointer into the heap otherwise it
      ;wouldn't be in the heap.liveness-trackers list.
      val value-obj = (tracker-copy.value - 1) as ptr<long>
      if value-obj >= limit :
        val tag = [value-obj]
        if forwarding-pointer?(tag) :
          ;Update the value
          tracker-copy.value = tag
          ;Replace the tracker with its copy in the list
          [p] = tracker-copy
          p = addr(tracker-copy.tail)
        else :
          ;The Unique is no longer live so replace the value with false-marker.
          tracker-copy.value = false-marker
          ;Unlink current tracker from the list
          [p] = tracker-copy.tail
      else :
        ;The value is old and so considered live. Replace the tracker with its copy in the list
        [p] = tracker-copy
        p = addr(tracker-copy.tail)
    else :
      ;The tracker is no longer live, so unlink it from the list.
      [p] = tracker.tail
  ;No meaningful return value
  return false

lostanza defn evacuate-nursery (vms:ptr<VMState>) -> ref<False> :
  #if-defined(STRESS-TEST) :
    ;Ensure that write barriers properly record all writes to old generation.
    ensure-write-barrier-invariants!(vms)

  val heap = addr(vms.heap)
  clear-mark(nursery-start(heap), heap.top, heap)

  ;Use heap.top as old objects allocation top
  vms.heap.top = vms.heap.old-objects-end
  ;Copy remembered references from old objects.
  ;TODO: impement and use iterate-marked-once here to avoid clearing remembered set after evacuation.
  iterate-marked(vms.heap.start, vms.heap.old-objects-end, addr(copy-object), vms)
  ;Copy roots
  iterate-roots(addr(copy-object), vms)
  copy-stacks(vms)
  update-liveness-trackers(vms)

  ;No meaningful return value
  return false

;The remembered set spans from heap.start to heap.old-objects-end.
;Set all bits in the bitset for that range to zero.
lostanza defn clear-remembered-set (heap:ptr<Heap>) -> ref<False> :
  return clear-mark(heap.start, heap.old-objects-end, heap)

;Force a collection of the entire heap.
public lostanza defn full-heap-collection (vms:ptr<VMState>) -> ref<False> :
  mark-compact(vms)
  val heap = addr(vms.heap)
  val nursery-size = compute-nursery-size(heap)
  return set-limit(min(heap.old-objects-end + nursery-size, heap-end(heap)), heap)

lostanza defn set-limit (limit:ptr<long>, heap:ptr<Heap>) -> ref<False> :
  heap.limit = limit
  heap.top = nursery-start(heap)
  ;No meaningful return value
  return false

;We need to allocate 'allocation-size' bytes from the heap, and we have detected
;that this is past our heap limit (heap.limit).
;Run the GC and try to create enough free space so that we can perform the allocation.
;After GC, returns the number of bytes that are now free to be allocated from the heap.
public lostanza defn collect-garbage (allocation-size:long, vms:ptr<VMState>) -> long :
  ;High Level Algorithm:
  ;1) Define our desired nursery to have size:
  ;    (nursery-frac * heap-size) + allocation-size
  ;2) First try a partial GC to recover space for the nursery.
  ;3) If not enough space recovered, proceed with a full GC.
  ;4) After full GC try expanding the heap to ensure the desired heap capacity.

  ;If we're attempting to allocate a larger object than can ever
  ;be held in the heap (even after expansion) then don't bother doing anything.
  val heap = addr(vms.heap)
  if allocation-size < heap.max-size :

    ;Step 1. Define the desired size of the nursery.
    val nursery-size = compute-nursery-size(allocation-size, heap)
    ;Fail if we cannot possibly free enough space with a partial GC.
    if nursery-size <= available-space(heap) :

      ;Step 2. Try the partial GC.
      evacuate-nursery(vms)

      ;Fail if the partial GC didn't recover enough space.
      if nursery-size <= available-space(heap) :
        ;Success! The partial GC recovered enough space for the nursery.
        clear-remembered-set(heap)
        set-limit(heap.old-objects-end + nursery-size, heap)
        ;Return the space remaining
        return heap.limit - heap.top
      heap.limit = heap.top

    ;Step 3. Try using a full GC to create space.
    mark-compact(vms)

    ;Step 4. Expand the heap.
    val used-heap = heap.top - heap.start + nursery-size
    val usage-ratio = used-heap as double / heap.size as double
    if usage-ratio > 0.5 :
      expand-heap(min(heap.size-limit, used-heap * 2), heap)

    ;We've done what we can.
    ;Promote all the old objects, and
    ;create the young-generation that will fit.
    set-limit(min(heap.old-objects-end + nursery-size, heap-end(heap)), heap)

  ;Return the space remaining
  return heap.limit - heap.top

public lostanza defn ensure-heap-space (size:long, vms:ptr<VMState>) -> ref<False> :
  if collect-garbage(size, vms) < size : fatal!("Out of memory.")
  ;No meaningful return value
  return false

;============================================================
;============================================================
;============================================================

lostanza defn tag (x:ptr<?>) -> long :
  return (x + 1) as long

public lostanza defn tag-as-ref (x:ptr<?>) -> long :
  return tag(x - 8)

lostanza defn untag (x:long) -> ptr<?> :
  #if-not-defined(OPTIMIZE) :
    val tagbits = x & 7L
    if tagbits != 1 : fatal("Not a heap-allocated object!")
  return (x - 1 + 8) as ptr<?>

;Return lower of two pointers.
lostanza defn min (x:ptr<?>, y:ptr<?>) -> ptr<?> :
  if x < y : return x
  else : return y

;============================================================
;================== GC Notifiers ============================
;============================================================

var GC-NOTIFIERS:Vector<(() -> ?)>

lostanza defn initialize-gc-notifiers () -> ref<False> :
  GC-NOTIFIERS = Vector<(() -> ?)>()
  initialized-gc-notifiers? = 1L
  return false

defn run-gc-notifiers () :
  for f in GC-NOTIFIERS do :
    f()

public defn add-gc-notifier (f: () -> ?) :
   add(GC-NOTIFIERS, f)

;Ensure that the heap's callback routines have been initialized.
lostanza defn initialize-heap-callback-routines () -> ref<False> :
  ;If the heap's callback routines have not already been initialized,
  ;then initialize them now.
  val vms:ptr<VMState> = call-prim flush-vm()
  val heap:ptr<Heap> = addr(vms.heap)
  if heap.iterate-roots == null :
    heap.iterate-roots = addr(core-iterate-roots)
    heap.iterate-references-in-stack-frames = addr(core-iterate-references-in-stack-frames)

  ;No meaningful return value.
  return false

lostanza defn extend-stack (size:long) -> ref<False> :
  val vms:ptr<VMState> = call-prim flush-vm()
  return extend-stack(size, addr(vms.heap))

;============================================================
;================== New Garbage Collector ===================
;============================================================

;Sets the first 'size' bytes in the address range starting from 'start' to 0.
;Returns 'start'.
public lostanza defn clear (start:ptr<?>, size:long) -> ptr<?> :
  return call-c clib/memset(start, 0, size)

;Call f on all root pointers.
lostanza defn core-iterate-roots (f:ptr<((ptr<long>, ptr<VMState>) -> ref<False>)>,
                                  vms:ptr<VMState>) -> ref<False> :
  ;Scan globals
  val globals = vms.global-mem as ptr<long>
  val roots = vms.global-root-table
  val nroots = roots.length
  for (var i:int = 0, i < nroots, i = i + 1) :
    val r = roots.roots[i]
    [f](addr(globals[r]), vms)

  ;Scan const roots
  val consts = vms.const-table
  val nconsts = [vms.const-mem as ptr<int>]
  for (var i:int = 0, i < nconsts, i = i + 1) :
    [f](addr(consts[i]), vms)
  ;No meaningful return value
  return false

;============================================================
;==================== LivenessTracker =======================
;============================================================

public deftype Unique <: Equalable

defmethod equal? (a:Unique, b:Unique) :
  ($prim identical? a b)

;LivenessTracker for determining whether objects are still live.
;- value: meant to hold either a reference to a Unique object
;  or false. It is stored as a long to prevent GC from automatically
;  traversing this field during the marking phase.
;- tail: holds the linked list of liveness trackers.
public lostanza deftype LivenessTracker :
  var value: long
  var tail: ptr<LivenessTracker>

;Create a new LivenessTracker, wrapped around the given Unique object,
;and add it to vms.heap.liveness-trackers list.
public lostanza defn LivenessTracker (value:ref<Unique>) -> ref<LivenessTracker> :
  val vms:ptr<VMState> = call-prim flush-vm()
  return LivenessTracker(value, addr(vms.heap))

;Retrieve the wrapped Unique object within a liveness tracker.
;Returns false if the object is no longer live.
public lostanza defn value (t:ref<LivenessTracker>) -> ref<False|Unique> :
  return t.value as ref<False|Unique>

;Create a new LivenessTracker, wrapped around the given Unique object,
;and add it to heap.liveness-trackers list.
lostanza defn LivenessTracker (value:ref<Unique>, heap:ptr<Heap>) -> ref<LivenessTracker> :
  ;heap.liveness-trackers cannot be passed as an argument to new LivenessTracker{...}.
  ;heap.liveness-trackers is a ptr<>. new LivenessTracker{...} can cause a GC.
  ;GC is aware of heap.liveness-trackers and so can update it.
  ;But local copy of heap.liveness-trackers passed as an argument keeps the old value.
  val tracker = new LivenessTracker{0L, null}
  tracker.value = value as long
  tracker.tail = heap.liveness-trackers
  heap.liveness-trackers = addr!([tracker])
  return tracker

lostanza val false-marker:long = tagof(False) << 3L + 2

;Scan through heap.liveness-trackers and update them.
;After this function finishes:
;1) All heap.liveness-trackers will have their 'value' field appropriately updated.
;   The 'value' field will be set to false, if the object they are referencing is
;   no longer live.
;2) The heap.liveness-trackers list will contain only LivenessTrackers that are still live,
;   that hold references to Unique objects that are still live.
lostanza defn scan-liveness-trackers (vms:ptr<VMState>) -> ref<False> :
  val heap = addr(vms.heap)
  val bitset-base = heap.bitset-base

  ;p is a pointer to the list being scanned.
  var p:ptr<ptr<LivenessTracker>> = addr(heap.liveness-trackers)

  ;Scan while p points to a tracker within the collection-area.
  ;(The end of the list is represented using a null pointer.)
  while [p] != null :
    ;Retrieve the next ptr<LivenessTracker> in the list.
    val tracker = [p]

    ;Compute the pointer to the start of the object by decrementing
    ;the size of the header word. This pointer is what is marked
    ;in the bitset.
    val tracker-obj = (tracker as ptr<?>) - sizeof(long)

    ;Test whether the tracker is marked (and therefore still live).
    if test-mark(tracker-obj, bitset-base) == 0 :
      ;The tracker is no longer live, so unlink the tracker
      ;from the list.
      [p] = tracker.tail
    else :
      ;Set the value field on the tracker to false if it
      ;no longer refers to a live Unique object. We can assume that
      ;value currently holds a pointer into the heap otherwise it
      ;wouldn't be in the heap.liveness-trackers list.
      val value-obj = (tracker.value - 1) as ptr<?>
      if test-mark(value-obj, bitset-base) == 0 :
        ;The Unique is no longer live so replace the value with
        ;false-marker.
        tracker.value = false-marker
        ;Unlink current tracker from the list
        [p] = tracker.tail
      else :
        ;The unique is still live, so keep this tracker on the list.
        ;Go to the next element in the list.
        p = addr(tracker.tail)

  ;No meaningful return value
  return false

;Relocate the referenced objects in heap.liveness-trackers list
;as part of compaction.
lostanza defn relocate-liveness-trackers (vms:ptr<VMState>) -> ref<False> :
  val heap = addr(vms.heap)
  val compaction-start = heap.compaction-start
  ;p is a pointer to the list being scanned.
  var p:ptr<ptr<LivenessTracker>> = addr(heap.liveness-trackers)
  while [p] != null :
    ;Retrieve the next ptr<LivenessTracker> in the list.
    val tracker = [p]
    if tracker > compaction-start :
      val tracker-obj = (tracker as ptr<long>) - sizeof(long)
      ;Relocate the pointer to the tracker
      [p] = tracker + relocation-offset(tracker-obj)
    ;Relocate the tracker value
    relocate-reference(addr(tracker.value), vms)
    ;Go to the next element in the list.
    p = addr(tracker.tail)
  ;No meaningful return value
  return false

public lostanza defn max (x:long, y:long) -> long :
  if x < y : return y
  else : return x

public lostanza defn min (x:long, y:long) -> long :
  if x < y : return x
  else : return y

;============================================================
;===================== Debugging ============================
;============================================================

public lostanza deftype ObjectLayout :
  tag: long
  var slots: long ...

lostanza defn dump-heap (vms:ptr<VMState>) -> int :
  call-c clib/printf("Heap[%p to %p]:\n", vms.heap.start, vms.heap.old-objects-end)
  dump-heap(vms.heap.start, vms.heap.old-objects-end, vms)
  val nursery = nursery-start(addr(vms.heap))
  call-c clib/printf("Nursery[%p to %p]:\n", nursery, vms.heap.top)
  return dump-heap(nursery, vms.heap.top, vms)

lostanza defn dump-heap (pstart:ptr<long>, pend:ptr<long>, vms:ptr<VMState>) -> int :
  val stackrefs = LSLongVector()
  call-c clib/printf("Heap[%p to %p]:\n", pstart, pend)
  var p:ptr<long> = pstart
  while p < pend :
    val tag = [p] as int
    if tag == tagof(Stack) :
      add(stackrefs, /tag(p))
    val class = vms.class-table[tag].record
    if class.item-size == 0 :
      val obj = p as ptr<ObjectLayout>
      val size = class.size
      call-c clib/printf("  %p: [Object %d, size = %d]", /tag(p), tag, size)
      for (var i:long = 0, i < size, i = i + 8) :
        call-c clib/printf("  %lx", [p + 8 + i])
      call-c clib/printf("\n")
      ;Advance to next object
      p = p + object-size-on-heap(size)
    else :
      val class = class as ptr<ArrayRecord>
      val array = p as ptr<ObjectLayout>
      val len = array.slots[0]
      val base-size = class.base-size
      val item-size = class.item-size
      val size = base-size + item-size * len
      call-c clib/printf("  %p: [Array %d, length = %ld, base-size = %d, item-size = %d]",
                         /tag(p), tag, len, base-size, item-size)
      for (var i:long = 0, i < size, i = i + 8) :
        call-c clib/printf("  %lx", [p + 8 + i])
      call-c clib/printf("\n")
      ;Advance to next object
      p = p + object-size-on-heap(size)
  ;Dump stacks
  for (var i:int = 0, i < stackrefs.length, i = i + 1) :
    val s = stackrefs.items[i]
    dump-stack(s, vms)
  return 0

lostanza defn dump-stack (stackref:long, vms:ptr<VMState>) -> int :
  val stk:ptr<Stack> = untag(stackref)
  val f-end = stk.stack-pointer
  call-c clib/printf("Stack %p (last frame %p):\n", stackref, f-end)
  if stk.frames != null :
    labels :
      begin :
        goto loop(stk.frames)
      loop (f:ptr<StackFrame>) :
        if f <= f-end :
          ;Get frame properties
          val map-index = f.liveness-map
          val map = vms.stackmap-table[map-index]
          val live-slots = addr(map.roots)
          val num-slots = (map.size - 16) / 8
          ;Print properties
          val num-live = map.num-roots
          var slot-i:int = 0
          call-c clib/printf("  %p: [StackFrame %ld, num-slots = %d]\n", f, f.liveness-map, num-slots)
          for (var i:int = 0, i < num-slots, i = i + 1) :
            if slot-i < num-live and live-slots[slot-i] == i :
              call-c clib/printf("    %d: [%lx]\n", i, f.slots[i])
              slot-i = slot-i + 1
            else :
              call-c clib/printf("    %d: %lx\n", i, f.slots[i])

          if f != f-end :
            val f* = f + map.size
            if f* > f-end :
              call-c clib/printf("New stack %p is past end\n", f*)
              call-c clib/exit(-1)
            goto loop(f*)
  return 0


;============================================================
;====================== CONSTANTS ===========================
;============================================================

val COROUTINE-ACTIVE = 0
val COROUTINE-CLOSED = 1
val COROUTINE-SUSPENDED = 2
val COROUTINE-OPEN = 3

lostanza val INT-TAG-BITS:long = 0L
lostanza val REF-TAG-BITS:long = 1L
lostanza val MARKER-TAG-BITS:long = 2L
lostanza val BYTE-TAG-BITS:long = 3L
lostanza val CHAR-TAG-BITS:long = 4L
lostanza val FLOAT-TAG-BITS:long = 5L

lostanza val FALSE-TYPE:int = 0
lostanza val TRUE-TYPE:int = 1
lostanza val BYTE-TYPE:int = 2
lostanza val CHAR-TYPE:int = 3
lostanza val INT-TYPE:int = 4
lostanza val FLOAT-TYPE:int = 5

public lostanza val null:ptr<?> = 0L as ptr<?>

;============================================================
;======================= Bytes ==============================
;============================================================

public lostanza defn shift-left (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value << b.value}

public lostanza defn shift-right (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value >> b.value}

public lostanza defn bit-or (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value | b.value}

public lostanza defn bit-xor (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value & b.value}

public lostanza defn bit-not (a:ref<Byte>) -> ref<Byte> :
  return new Byte{(~ a.value)}

public lostanza defn plus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value + b.value}

public lostanza defn minus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value - b.value}

public lostanza defn times (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value * b.value}

public lostanza defn divide (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  ensure-divide-non-zero(b)
  return new Byte{a.value / b.value}

public lostanza defn modulo (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  ensure-divide-non-zero(b)
  return new Byte{a.value % b.value}

;============================================================
;====================== Integers ============================
;============================================================

public defn shift-left (a:Int, b:Int) -> Int :
  ($prim shl a b)

public defn shift-right (a:Int, b:Int) -> Int :
  ($prim shr a b)

public defn arithmetic-shift-right (a:Int, b:Int) -> Int :
  ($prim ashr a b)

public defn bit-or (a:Int, b:Int) -> Int :
  ($prim or a b)

public defn bit-and (a:Int, b:Int) -> Int :
  ($prim and a b)

public defn bit-xor (a:Int, b:Int) -> Int :
  ($prim xor a b)

public defn bit-not (a:Int) -> Int :
  ($prim not a)

public defn negate (a:Int) -> Int :
  ($prim neg a)

public defn abs (a:Int) -> Int :
  (- a) when a < 0 else a

public defn plus (a:Int, b:Int) -> Int :
  ($prim add a b)

public defn minus (a:Int, b:Int) -> Int :
  ($prim sub a b)

public defn times (a:Int, b:Int) -> Int :
  ($prim mul a b)

public defn divide (a:Int, b:Int) -> Int :
  ensure-divide-non-zero(b)
  ($prim div a b)

public defn modulo (a:Int, b:Int) -> Int :
  ensure-divide-non-zero(b)
  ($prim mod a b)

public lostanza defn bitcount (x0:long) -> int :
  var count:int = 0
  for (var x:long = x0, x, x = x & (x - 1)) :
    count = count + 1
  return count

public lostanza defn bitcount (x:ref<Int>) -> ref<Int> :
  return new Int{bitcount(x.value << 32L)}

public lostanza defn bitcount (x:ref<Long>) -> ref<Int> :
  return new Int{bitcount(x.value)}

;============================================================
;======================== Longs =============================
;============================================================

public lostanza defn shift-left (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value << b.value}

public lostanza defn shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value >> b.value}

public lostanza defn arithmetic-shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value >>> b.value}

public lostanza defn bit-or (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value | b.value}

public lostanza defn bit-xor (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value & b.value}

public lostanza defn bit-not (a:ref<Long>) -> ref<Long> :
  return new Long{(~ a.value)}

public lostanza defn negate (a:ref<Long>) -> ref<Long> :
  return new Long{(- a.value)}

public defn abs (a:Long) -> Long :
  (- a) when a < 0L else a

public lostanza defn plus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value + b.value}

public lostanza defn minus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value - b.value}

public lostanza defn times (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value * b.value}

public lostanza defn divide (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  ensure-divide-non-zero(b)
  return new Long{a.value / b.value}

public lostanza defn modulo (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  ensure-divide-non-zero(b)
  return new Long{a.value % b.value}

;============================================================
;======================= Floats =============================
;============================================================

public lostanza defn negate (a:ref<Float>) -> ref<Float> :
  return new Float{(- a.value)}

public defn abs (a:Float) -> Float :
  (- a) when a < 0.0f else a

public lostanza defn plus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value + b.value}

public lostanza defn minus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value - b.value}

public lostanza defn times (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value * b.value}

public lostanza defn divide (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value / b.value}

public lostanza defn nan? (x:ref<Float>) -> ref<True|False> :
  val v = x.value
  if v != v : return true
  else : return false

;============================================================
;======================= Doubles ============================
;============================================================

public lostanza defn negate (a:ref<Double>) -> ref<Double> :
  return new Double{(- a.value)}

public defn abs (a:Double) -> Double :
  (- a) when a < 0.0 else a

public lostanza defn plus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value + b.value}

public lostanza defn minus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value - b.value}

public lostanza defn times (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value * b.value}

public lostanza defn divide (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value / b.value}

public lostanza defn nan? (x:ref<Double>) -> ref<True|False> :
  val v = x.value
  if v != v : return true
  else : return false

;============================================================
;======================== Strings ===========================
;============================================================

public lostanza defn String (len:long) -> ref<String> :
  return new String{len + 1, 0}

public lostanza defn String (len:long, chars:ptr<byte>) -> ref<String> :
  return initialize(String(len), chars)

public lostanza defn String (len:long, chars:ref<ByteArray>) -> ref<String> :
  return initialize(String(len), addr!(chars.data))

public lostanza defn String (len:ref<Long>, buf:ref<ByteArray>) -> ref<String> :
  return String(len.value, buf)

public lostanza defn String (len:ref<Int>, buf:ref<ByteArray>) -> ref<String> :
  return String(len.value, buf)

public lostanza defn initialize (s:ref<String>, chars:ptr<byte>) -> ref<String> :
  val l = s.length - 1
  call-c clib/memcpy(addr!(s.chars), chars, l)
  s.chars[l] = 0Y
  return s

;============================================================
;======================= Lists ==============================
;============================================================

public lostanza defn List () -> ref<List> :
  return new NilList{}

public lostanza defn cons<?T> (x:ref<?T>, t:ref<List<?T>>) -> ref<List<T>> :
  return new FullList<T>{x, t}

public defmulti head<?T> (x:List<?T>) -> T
public defmulti tail<?T> (x:List<?T>) -> List<T>
public defmulti empty? (x:List) -> True|False

defmethod head (x:NilList) : fatal("Cannot retrieve head of empty list.")
defmethod tail (x:NilList) : fatal("Cannot retrieve tail of empty list.")
defmethod empty? (x:NilList) : true
lostanza defmethod head (x:ref<FullList>) -> ref<?> : return x.head
lostanza defmethod tail (x:ref<FullList>) -> ref<?> : return x.tail
defmethod empty? (x:FullList) : false

;============================================================
;======================= Booleans ===========================
;============================================================

public defn complement (a:True|False) -> True|False :
  if a : false
  else : true

;============================================================
;==================== Identity Function =====================
;============================================================

public defn identity<?T> (x:?T) -> T : x

;============================================================
;====================== Comparable ==========================
;============================================================

public deftype Comparable<T> :
  Char <: Comparable<Char>
  Byte <: Comparable<Byte>
  Int <: Comparable<Int>
  Long <: Comparable<Long>
  Float <: Comparable<Float>
  Double <: Comparable<Double>
  Tuple<T> <: Comparable<Tuple<T>>
  String <: Comparable<String>
  Symbol <: Comparable<Symbol>
  List<T> <: Comparable<List<T>>

public defmulti compare<?T> (a:Comparable<?T>, b:T) -> Int
public defmulti less?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti greater?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti less-eq?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti greater-eq?<?T> (a:Comparable<?T>, b:T) -> True|False

defmethod less?<?T> (a:Comparable<?T>, b:T) : compare(a, b) < 0
defmethod greater?<?T> (a:Comparable<?T>, b:T) : compare(a, b) > 0
defmethod less-eq?<?T> (a:Comparable<?T>, b:T) : compare(a, b) <= 0
defmethod greater-eq?<?T> (a:Comparable<?T>, b:T) : compare(a, b) >= 0

lostanza defmethod compare (a:ref<Char>, b:ref<Char>) -> ref<Int> :
  return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Byte>, b:ref<Byte>) -> ref<Int> :
  return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

defmethod compare (a:Int, b:Int) -> Int :
  if a < b : -1
  else if a > b : 1
  else : 0

defmethod less? (a:Int, b:Int) -> True|False :
  ($prim lt a b)

defmethod less-eq? (a:Int, b:Int) -> True|False :
  ($prim le a b)

defmethod greater? (a:Int, b:Int) -> True|False :
  ($prim gt a b)

defmethod greater-eq? (a:Int, b:Int) -> True|False :
  ($prim ge a b)

lostanza defmethod compare (a:ref<Long>, b:ref<Long>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Float>, b:ref<Float>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Double>, b:ref<Double>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Tuple<Comparable>>, b:ref<Tuple<Comparable>>) -> ref<Int> :
  val la = a.length
  val lb = b.length
  labels :
    begin :
      goto loop(0)
    loop (i:long) :
      if i < la and i < lb :
        val c = compare(a.items[i], b.items[i])
        if c.value : return c
        else : goto loop(i + 1)
      else :
        return compare(new Int{la as int}, new Int{lb as int})

lostanza defmethod compare (a:ref<String>, b:ref<String>) -> ref<Int> :
  val na = strlen(a)
  val nb = strlen(b)
  labels :
    begin :
      goto loop(0)
    loop (i:long) :
      if (i == na) and (i == nb) :
        return new Int{0}
      else if i == na :
        return new Int{-1}
      else if i == nb :
        return new Int{1}
      else :
        val ac = a.chars[i]
        val bc = b.chars[i]
        if ac < bc : return new Int{-1}
        else if ac > bc : return new Int{1}
        else : goto loop(i + 1)

defmethod compare (xs:List<Comparable>, ys:List<Comparable>) -> Int :
  defn* loop (xs:List<Comparable>, ys:List<Comparable>) :
    match(empty?(xs), empty?(ys)) :
      (ex:True, ey:True) : 0
      (ex:True, ey:False) : -1
      (ex:False, ey:True) : 1
      (ex:False, ey:False) :
        val c = compare(head(xs), head(ys))
        if c == 0 : loop(tail(xs), tail(ys))
        else : c
  loop(xs, ys)

defmethod compare (a:Symbol, b:Symbol) :
  defn rank (s:Symbol) :
    match(s) :
      (s:StringSymbol) : 0
      (s:GenSymbol) : 1
  match(a, b) :
    (a:StringSymbol, b:StringSymbol) :
      compare(name(a), name(b))
    (a:GenSymbol, b:GenSymbol) :
      val c = compare(name(a), name(b))
      if c == 0 : compare(id(a), id(b))
      else : c
    (a, b) :
      compare(rank(a), rank(b))

;============================================================
;======================== Equalable =========================
;============================================================

public deftype Equalable :
  Char <: Equalable
  Byte <: Equalable
  Int <: Equalable
  Long <: Equalable
  Float <: Equalable
  Double <: Equalable
  Tuple<T> <: Equalable
  String <: Equalable
  Symbol <: Equalable
  List<T> <: Equalable
  True <: Equalable
  False <: Equalable

public defmulti equal? (a:Equalable, b:Equalable) -> True|False
defmethod equal? (a:Equalable, b:Equalable) : false

public defn not-equal? (a:Equalable, b:Equalable) -> True|False :
  not equal?(a, b)

defmethod equal? (a:Char, b:Char) -> True|False :
  ($prim identical? a b)

defmethod equal? (a:Byte, b:Byte) -> True|False :
  ($prim identical? a b)

defmethod equal? (a:Int, b:Int) -> True|False :
  ($prim eq a b)

lostanza defmethod equal? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

lostanza defmethod equal? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

lostanza defmethod equal? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

defmethod equal? (a:True|False, b:True|False) -> True|False :
  ($prim identical? a b)

lostanza defmethod equal? (x:ref<Tuple>, y:ref<Tuple>) -> ref<True|False> :
  val n = x.length
  if n != y.length : return false
  for (var i:long = 0, i < n, i = i + 1) :
    if equal?(x.items[i], y.items[i]) == false :
      return false
  return true

lostanza defmethod equal? (a:ref<String>, b:ref<String>) -> ref<True|False> :
  val n = strlen(a)
  if n == strlen(b) :
    for (var i:long = 0, i < n, i = i + 1) :
      if a.chars[i] != b.chars[i] :
        return false
    return true
  else :
    return false

defmethod equal? (a:List, b:List) -> True|False :
  defn* loop (a:List, b:List) :
    match(empty?(a), empty?(b)) :
      (ea:True, eb:True) : true
      (ea:False, eb:False) :
        if head(a) == head(b) :
          loop(tail(a), tail(b))
      (ea, eb) : false
  loop(a, b)

defmethod equal? (a:Symbol, b:Symbol) -> True|False :
  ($prim identical? a b)

;============================================================
;==================== Compare Contents ======================
;============================================================

public deftype HasContents :
  Equalable <: HasContents
  KeyValue<K,V> <: HasContents
  Tuple<T> <: HasContents
  IndexedCollection<T> <: HasContents

public defmulti same-contents? (a:HasContents, b:HasContents) -> True|False

;By default, two objects do not have the same contents.
defmethod same-contents? (a, b) : false

;Two objects have the same contents if they are equal.
defmethod same-contents? (a:Equalable, b:Equalable) : a == b

;Two keyvalue pairs have the same contents if their keys are equal
;and their values contain the same contents.
defmethod same-contents? (a:KeyValue, b:KeyValue) :
  key(a) == key(b) and
  same-contents?(value(a), value(b))

;Two Tuples contain the same contents if they have the same length
;and their items respectively contain the same contents.
defmethod same-contents? (a:Tuple, b:Tuple) :
  length(a) == length(b) and all?(same-contents?, a, b)

;Two ByteArrays contains the same contents if they have the same length,
;and their bytes are equal.
lostanza defmethod same-contents? (a:ref<ByteArray>, b:ref<ByteArray>) -> ref<True|False> :
  if a.length == b.length :
    val c = call-c clib/memcmp(addr!(a.data), addr!(b.data), a.length)
    if c == 0 : return true
    else : return false
  return false

;Two Lists contain the same contents if they have the same length
;and their items respectively contain the same contents.
defmethod same-contents? (a:List, b:List) :
  let loop (a:List = a, b:List = b) :
    match(empty?(a), empty?(b)) :
      (ae:True, be:True) : true
      (ae:True, be:False) : false
      (ae:False, be:True) : false
      (ae:False, be:False) : same-contents?(head(a), head(b)) and
                             loop(tail(a), tail(b))

;Two IndexedCollections contain the same contents if they have the same length
;and their items respectively contain the same contents.
;Helper function is necessary so that objects that are both Equalable and IndexedCollection
;can have IndexedCollection take priority.
defn same-collection-contents? (a:IndexedCollection, b:IndexedCollection) :
  length(a) == length(b) and
  for i in 0 to length(a) all? :
    same-contents?(a[i], b[i])

defmethod same-contents? (a:IndexedCollection, b:IndexedCollection) :
  same-collection-contents?(a,b)

defmethod same-contents? (a:Equalable&IndexedCollection, b:Equalable&IndexedCollection) :
  same-collection-contents?(a,b)

;Two wrapped Maybe objects contain the same contents if their
;wrapped value contains the same contents.
defmethod same-contents? (a:One, b:One) :
  same-contents?(value!(a), value!(b))

;============================================================
;====================== Lengthable ==========================
;============================================================

public deftype Lengthable :
  String <: Lengthable
  Tuple<T> <: Lengthable
  List<T> <: Lengthable

public defmulti length (l:Lengthable) -> Int

lostanza defmethod length (x:ref<Tuple>) -> ref<Int> :
  return new Int{x.length as int}

lostanza defmethod length (s:ref<String>) -> ref<Int> :
  return new Int{s.length as int - 1}

defmethod length (x:List) :
  defn* loop (x:List, n:Int) :
    if empty?(x) : n
    else : loop(tail(x), n + 1)
  loop(x, 0)

;============================================================
;=================== Dynamic Context ========================
;============================================================

;------------------------------------------------------------
;----------- Representation of one Dynamic Frame ------------
;------------------------------------------------------------
;A dynamic frame consists of an entry thunk and an exit thunk.
;A boolean flag indicates whether the exit thunk is a
;'finally' block or not. Finally blocks are treated specially.

defstruct DyCtxtFrame :
  finally?:True|False
  in: False|(() -> ?)
  out: False|(() -> ?)

;Create a new non-finally dynamic context frame.
defn DyCtxtFrame (in:False|(() -> ?),
                  out:False|(() -> ?)) -> DyCtxtFrame :
  DyCtxtFrame(false, in, out)                

;Create a new finally dynamic context frame.
defn DyCtxtFinallyFrame (out:False|(() -> ?)) -> DyCtxtFrame :
  DyCtxtFrame(true, false, out)

;------------------------------------------------------------
;------------- State of a Winding Algorithm -----------------
;------------------------------------------------------------
;A DyCtxtWinder captures the in-progress state of performing
;a wind-in, or wind-out operation.
;As frames are pushed/popped into a coroutine, they are saved
;onto the winder.

;- entries: Each entry, CO => F, means that the frame
;F was popped from the state of coroutine CO during wind-out.
defstruct DyCtxtWinder :
  entries:List<KeyValue<Int,DyCtxtFrame>> with:
    setter => set-entries
    init => List()

;Returns true if any of the entries in the winder is a
;finally block.
defn contains-finally? (w:DyCtxtWinder) -> True|False :
  for e in entries(w) any? :
    finally?(value(e))

;Returns the minimum number of entries to pop
;from winder until 'contains-finally?' returns false.
defn num-finally-blocks (w:DyCtxtWinder) -> Int :
  var last-index:Int = -1
  for (e in entries(w), i in 0 to false) do :
    if finally?(value(e)) :
      last-index = i
  last-index + 1

;Return true if the winder has no more entries.
defn empty? (w:DyCtxtWinder) -> True|False :
  empty?(entries(w))

;Push a new entry to the winder.
defn push (w:DyCtxtWinder, co-id:Int, frame:DyCtxtFrame) :
  set-entries(w, cons(co-id => frame, entries(w)))

;Pop an entry from the winder.
defn pop (w:DyCtxtWinder) -> KeyValue<Int,DyCtxtFrame> :
  val e = head(entries(w))
  set-entries(w, tail(entries(w)))
  e

;Take a look at the top entry in the winder.
defn peek (w:DyCtxtWinder) -> KeyValue<Int,DyCtxtFrame> :
  head(entries(w))

;------------------------------------------------------------
;---------------- State of Dynamic Context ------------------
;------------------------------------------------------------
;Each coroutine stores its own stack of dynamic frames.

;- frames: The frames that have finished winding-in.
;  Most recent wind-in is at front.
;- saved: If the coroutine is suspended and in OPEN status,
;  then this contains a DyCtxtWinder that contains finally
;  blocks that need to execute when the coroutine is closed.
;- registered?: The DyCtxtState doubles as a finalizer which
;  executes its saved finally blocks. To prevent it from
;  being registered repeatedly, this field holds true if it
;  has already been registered as a finalizer.
defstruct DyCtxtState <: Finalizer :
  frames:List<DyCtxtFrame> with:
    setter => set-frames
    init => List()
  saved:DyCtxtWinder|False with:
    setter => set-saved
    init => false
  registered?:True|False with:
    setter => set-registered?
    init => false

;Execute the saved finally blocks.
defmethod run (s:DyCtxtState) -> False :
  if saved(s) is-not False :
    val winder = saved(s) as DyCtxtWinder
    set-saved(s, false)
    wind-in-out(winder)

;The coroutine co has just been suspended. Save the finally
;blocks, and register the finalizer.
defn save-winders (co:RawCoroutine, w:DyCtxtWinder) -> False :
  if contains-finally?(w) :
    val s = dy-ctxt-state(co)
    set-saved(s, w)
    if not registered?(s) :
      set-registered?(s,true)
      add-finalizer(s, co)

;The coroutine co has just been resumed, so we don't need
;its saved winders anymore.
defn clear-winders (co:RawCoroutine) -> False :
  set-saved(dy-ctxt-state(co), false)

;Returns true if the state has no more frames.
defn empty? (s:DyCtxtState) -> True|False :
  empty?(frames(s))

;Execute and push a new frame onto the state.
;The frame is pushed *after* it executes. 
defn push-frame (s:DyCtxtState, f:DyCtxtFrame) -> False :
  match(in(f)) :
    (f:False) : false
    (f-in:() -> ?) : f-in()
  set-frames(s, cons(f, frames(s)))

;Pop a new frame from the state, and execute it.
;The frame is *first* popped and then executed.
;non-finally out-blocks are executed only if call-out? is true.
;finally out-blocks are executed only if call-finally? is true.
defn pop-frame (s:DyCtxtState,
                call-out?:True|False,
                call-finally?:True|False) -> DyCtxtFrame :
  val f = head(frames(s))
  set-frames(s, tail(frames(s)))
  match(out(f)) :
    (f:False) :
      false
    (f-out:() -> ?) :
      if finally?(f) :
        f-out() when call-finally?
      else :
        f-out() when call-out?
  f

;------------------------------------------------------------
;------------ Main Wind-in / Wind-out Algorithms ------------
;------------------------------------------------------------

;Execute all wind-out dynamic frames, pushing them into the winder (if
;given). Starts from c and traverses its parent chain until target-id
;(inclusive) is processed.
defn wind-out (c:RawCoroutine,
               winder:DyCtxtWinder|False,
               target-id:Int,
               call-out?:True|False,
               call-finally?:True|False) -> False :
  let loop (c:RawCoroutine = c) :
    val s = dy-ctxt-state(c)
    if empty?(s) :
      if id(c) != target-id :
        loop(parent(c) as RawCoroutine)
    else :
      val f = pop-frame(s, call-out?, call-finally?)
      match(winder:DyCtxtWinder) :
        push(winder, id(c), f)
      loop(c)

;Execute the stored wind-in frames in the winder, pushing them
;back onto the coroutine state.
defn wind-in (winder:DyCtxtWinder, c:RawCoroutine) -> False :
  if not empty?(winder) :
    defn* pop-next-frame (cos:List<RawCoroutine>) :
      if not empty?(winder) :
        val entry = pop(winder)
        exec-frame(cos, key(entry), value(entry))
    defn* exec-frame (cos:List<RawCoroutine>, co-id:Int, frame:DyCtxtFrame) :
      val co = head(cos)
      if id(co) == co-id :        
        push-frame(dy-ctxt-state(co), frame)
        pop-next-frame(cos)
      else :
        exec-frame(tail(cos), co-id, frame)
    val entry0 = peek(winder)
    pop-next-frame(reverse(collect-parents(c, key(entry0))))

;Collect parents up to the given parent-id.
defn collect-parents (c:RawCoroutine, parent-id:Int) -> List<RawCoroutine> :
  if id(c) == parent-id : List(c)
  else : cons(c, collect-parents(parent(c) as RawCoroutine, parent-id))

;------------------------------------------------------------
;--------------- Dynamic Wind Algorithm ---------------------
;------------------------------------------------------------

;Execute the given body with the given frame pushed into
;the dynamic context of the current coroutine.
defn dynamic-wind<?T> (body:() -> ?T,
                       frame:DyCtxtFrame) -> T :
  val s = dy-ctxt-state(current-coroutine)
  push-frame(s, frame)
  val result = body()
  pop-frame(s, true, true)
  result

;Execute the given body within the given dynamic context.
public defn dynamic-wind<?T> (in:False|(() -> ?),
                              body:() -> ?T,
                              out:False|(() -> ?)) -> T :
  dynamic-wind(body, DyCtxtFrame(in, out))

;Wind in and then wind out of all entries in the given winder.
;Used to force finally blocks to run.
defn wind-in-out (winder:DyCtxtWinder) -> False :
  val num = num-finally-blocks(winder)
  let loop (i:Int = 0) :
    if i < num :
      dynamic-wind(loop{i + 1}, value(pop(winder)))
    false

;============================================================
;====================== Coroutines ==========================
;============================================================

public defmulti active? (c:Coroutine) -> True|False
public defmulti open? (c:Coroutine) -> True|False
public defmulti resume<?I,?O> (c:Coroutine<?I,?O>, x:I) -> O
public defmulti suspend<?I,?O> (c:Coroutine<?I,?O>, x:O) -> I
public defmulti break<?O> (c:Coroutine<?,?O>, x:O) -> Void
public defmulti close (c:Coroutine) -> False

;A deliberate restriction imposed by Stanza is that when a C function
;calls into Stanza (through an extern defn), that extern defn function
;must return normally. So from the perspective of C, all Stanza
;functions must return normally, they cannot throw exceptions past the
;call boundary.
;This function returns true if the given coroutine was created/resumed in the present
;C context. If it returns true that means that it is safe to suspend this coroutine,
;otherwise it means that attempting to suspend the coroutine would cross a call boundary
;and cause a fatal error.
public defmulti suspension-crosses-ffi-call-boundary? (c:Coroutine) -> True|False

;                  Wrapped Coroutines
;                  ==================

#if-defined(OPTIMIZE) :

  public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
    RawCoroutine(enter)

#else :

  deftype WrappedCoroutine<I,O> <: Coroutine<I,O>
  defmulti raw (c:WrappedCoroutine) -> RawCoroutine

  public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
    var rc
    val c = new WrappedCoroutine<I,O> :
      defmethod active? (this) : active?(rc)
      defmethod open? (this) : open?(rc)
      defmethod resume (this, x:I) : resume(rc, x)
      defmethod suspend (this, x:O) : suspend(rc, x)
      defmethod break (this, x:O) : break(rc, x)
      defmethod close (this) : close(rc)
      defmethod raw (this) : rc
      defmethod suspension-crosses-ffi-call-boundary? (this) : suspension-crosses-ffi-call-boundary?(rc)
    rc = RawCoroutine $ fn (rc, x0) :
      enter(c, x0)
    c

  defmethod print (o:OutputStream, c:WrappedCoroutine) :
    print(o, raw(c))

protected lostanza deftype RawCoroutine <: Coroutine & Unique :
  id: long
  var stack: ref<Stack>
  var parent: ref<False|RawCoroutine>
  var status: ref<Int>
  var crsp: long
  dy-ctxt-state: ref<DyCtxtState>

lostanza deftype CoroutineParams :
  parent-stack: ref<Stack>
  coroutine: ref<RawCoroutine>
  enter: ref<((RawCoroutine, ?) -> ?)>

protected lostanza var current-coroutine:ref<RawCoroutine>
lostanza var COROUTINE-COUNTER:long

lostanza defn initialize-coroutines () -> ref<False> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val current-stack = vms.heap.current-stack as ref<Stack>
  val crsp = call-prim crsp() as long
  current-coroutine = new RawCoroutine{
                        0L,
                        current-stack,
                        false,
                        COROUTINE-ACTIVE,
                        crsp,
                        DyCtxtState()}
  COROUTINE-COUNTER = 1L
  return false

public lostanza defn RawCoroutine (enter:ref<((RawCoroutine, ?) -> ?)>) -> ref<RawCoroutine> :
  val stk = allocate-stack()
  stk.pc = addr(setup-coroutine) as long
  val vms:ptr<VMState> = call-prim flush-vm()
  val current-stack = vms.heap.current-stack as ref<Stack>
  return call-prim enter-stack(stk, current-stack, enter)

lostanza defn parent (c:ref<RawCoroutine>) -> ref<False|RawCoroutine> :
  return c.parent
lostanza defn status (c:ref<RawCoroutine>) -> ref<Int> :
  return c.status
lostanza defn id (c:ref<RawCoroutine>) -> ref<Int> :
  return new Int{c.id as int}
lostanza defn dy-ctxt-state (co:ref<RawCoroutine>) -> ref<DyCtxtState> :
  return co.dy-ctxt-state

lostanza defmethod active? (c:ref<RawCoroutine>) -> ref<True|False> :
  if c.status == COROUTINE-ACTIVE : return true
  else : return false

lostanza defmethod open? (c:ref<RawCoroutine>) -> ref<True|False> :
  if c.status == COROUTINE-OPEN : return true
  else : return false

lostanza defn* setup-coroutine (stack:ref<Stack>, parent-stack:ref<Stack>, enter:ref<((RawCoroutine, ?) -> ?)>) -> ref<?> :
  val crsp = call-prim crsp() as long
  val co = new RawCoroutine{
                 COROUTINE-COUNTER,
                 stack,
                 false,
                 COROUTINE-OPEN,
                 crsp,
                 DyCtxtState()}
  COROUTINE-COUNTER = COROUTINE-COUNTER + 1L
  val x0 = call-prim yield(parent-stack, co)
  return break(co, [enter](co, x0))

lostanza defmethod resume (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
  ;Ensure coroutine is re-entrant
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot resume coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-ACTIVE :
    return fatal("Cannot resume coroutine. Coroutine is already active.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot resume coroutine. Coroutine's parent is suspended.")

  ;Adjust state
  attach-coroutine(c)
  
  ;Begin execution
  val result = call-prim yield(current-coroutine.stack, x)

  ;If the coroutine is closed (e.g. through a 'break' command) then free it immediately.
  if c.status == COROUTINE-CLOSED :
    free-coroutine(c)

  ;Return the result yielded by the coroutine.
  return result

lostanza defmethod* suspend (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
  ;Ensure coroutine is active
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot suspend coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-OPEN :
    return fatal("Cannot suspend coroutine. Coroutine is already suspended.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot suspend coroutine. Coroutine is already suspended.")

  ;Ensure coroutine was launched within same c context
  ensure-no-cross-ffi-call-boundary!(c)

  ;Wind out from current-coroutine until we reach c.
  ;Save wind-out frames into the winder.
  val winder = DyCtxtWinder()
  wind-out(current-coroutine, winder, id(c), true, false)

  ;Save the winders in case we need to run its finally blocks later.
  save-winders(c, winder)

  ;Detach coroutine
  detach-coroutine(c, COROUTINE-OPEN)

  ;Return to resume
  val result = call-prim yield(current-coroutine.stack, x)

  ;Clear winders now that the coroutine is attached again.
  clear-winders(c)

  ;Wind in the dynamic context state.
  wind-in(winder, current-coroutine)

  ;Return execution
  return result

lostanza defmethod close (c:ref<RawCoroutine>) -> ref<False> :
  ;Ensure coroutine is re-entrant
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot close coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-ACTIVE :
    return fatal("Cannot close coroutine. Coroutine is active.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot close coroutine. Coroutine's parent is suspended.")

  ;Execute the finally blocks.
  run(c.dy-ctxt-state)

  free-coroutine(c)
  return false

lostanza defmethod break (c:ref<RawCoroutine>, x:ref<?>) -> ref<Void> :
  ;Ensure coroutine is active
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot break from coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-OPEN :
    return fatal("Cannot break from coroutine. Coroutine is already suspended.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot break from coroutine. Coroutine is already suspended.")

  ;Ensure coroutine was launched within same c context
  ensure-no-cross-ffi-call-boundary!(c)

  ;Wind out from the current coroutine. No need
  ;to store the frames since we won't wind-in again.
  wind-out(current-coroutine, false, id(c), true, true)

  ;Adjust state
  detach-coroutine(c, COROUTINE-CLOSED)

  ;Begin execution
  return call-prim yield(current-coroutine.stack, x)

;Return true if suspending from this coroutine will cross the FFI call boundary.
lostanza defmethod suspension-crosses-ffi-call-boundary? (c:ref<RawCoroutine>) -> ref<True|False> :
  val crsp = call-prim crsp() as long
  if crsp == c.crsp : return false
  else : return true

;Issue an error if suspending from this coroutine results in crossing the FFI call boundary.
lostanza defn ensure-no-cross-ffi-call-boundary! (c:ref<RawCoroutine>) -> int :
  if suspension-crosses-ffi-call-boundary?(c) == true :
    fatal!("Cannot suspend coroutine. Coroutine was launched from a different C context. \
            All 'extern defn' callbacks must return properly.")
  return 0

;The given coroutine is finished. Close it and
;free all it stacks.
lostanza defn free-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(c)
    loop (c:ref<RawCoroutine>) :
      val parent = c.parent
      c.parent = false
      c.status = COROUTINE-CLOSED
      free(c.stack)
      match(parent) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : return 0

;Fix up the .parent, .status, and .crsp links from
;attaching the given coroutine to 'current-coroutine'.
;The current coroutine will be set to the last parent in the chain.
lostanza defn attach-coroutine (c:ref<RawCoroutine>) -> int :  
  labels :
    begin :
      goto loop(c)
    loop (c:ref<RawCoroutine>) :
      val p = c.parent
      c.parent = current-coroutine
      c.status = COROUTINE-ACTIVE
      c.crsp = call-prim crsp() as long
      current-coroutine = c
      match(p) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : return 0

;Implements the semantics of suspending with 'c' as the argument coroutine.
;This function follows the parent pointer of the current coroutine until it reaches
;parent of 'c'. The current coroutine will be set to c.parent after this function finishes.
;The status of c will be set to "detached-status" at the end. It should be either
;COROUTINE-OPEN or COROUTINE-CLOSED, depending upon whether we intend to resume the
;coroutine.
lostanza defn detach-coroutine (c:ref<RawCoroutine>, detached-status:ref<Int>) -> int :
  labels :
    begin :
      goto loop(false)
    loop (tail:ref<RawCoroutine|False>) :
      val cc = current-coroutine
      val ccp = current-coroutine.parent as ref<RawCoroutine>
      cc.parent = tail
      current-coroutine = ccp
      if cc == c :
        cc.status = detached-status
        return 0
      else :
        cc.status = COROUTINE-SUSPENDED
        goto loop(cc)

;============================================================
;======================= Finalizers =========================
;============================================================

;LivenessHandler/run returns true if the LivenessHandler ran,
;and thus should be removed from the LivenessHandler list.
deftype LivenessHandler
defmulti run (f:LivenessHandler) -> True|False

;Global lists
var LIVENESS-HANDLERS:Vector<LivenessHandler>
var QUEUED-LIVENESS-HANDLERS:Vector<LivenessHandler>

;Initialize lists of handlers
defn initialize-liveness-handlers () :
  LIVENESS-HANDLERS = Vector<LivenessHandler>()
  QUEUED-LIVENESS-HANDLERS = Vector<LivenessHandler>()
  add-gc-notifier $ fn () :
    add-all(LIVENESS-HANDLERS, QUEUED-LIVENESS-HANDLERS)
    clear(QUEUED-LIVENESS-HANDLERS)
    remove-when(run, LIVENESS-HANDLERS)

public deftype Finalizer
public defmulti run (f:Finalizer) -> ?

public defn add-finalizer (f:Finalizer, v:Unique) :
  val tracker = LivenessTracker(v)
  val liveness-handler = new LivenessHandler :
    defmethod run (this) :
      if value(tracker) is False :
        run(f)
        true
  add(QUEUED-LIVENESS-HANDLERS, liveness-handler)

public defn add-finalizer (f:() -> ?, v:Unique) :
  val tracker = LivenessTracker(v)
  val liveness-handler = new LivenessHandler :
    defmethod run (this) :
      if value(tracker) is False :
        f()
        true
  add(QUEUED-LIVENESS-HANDLERS, liveness-handler)

;============================================================
;================== Runtime Configuration ===================
;============================================================

public lostanza defn current-heap-size () -> ref<Long> :
  val vms:ptr<VMState> = call-prim flush-vm()
  return new Long{vms.heap.size}

public lostanza defn current-max-heap-size () -> ref<Long> :
  val vms:ptr<VMState> = call-prim flush-vm()
  return new Long{vms.heap.size-limit}

public lostanza defn set-max-heap-size (sz:ref<Long>) -> ref<False> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val heap = addr(vms.heap)
  ;Ensure size is in range [0, max-heap-size] and round it up to whole pages.
  var desired-size:long = min(round-up-to-whole-pages(max(sz.value, 0L)), heap.max-size)
  val heap-size = heap.size
  if desired-size < heap-size :
    ;Try to shrink the heap
    mark-compact(vms)

    ;Compute the minimum size required to hold all of the currently live objects.
    ;(Rounded up to whole pages.)
    ;And ensure that the desired-size is at least that.
    val min-size = round-up-to-whole-pages(heap.old-objects-end - heap.start)
    desired-size = max(desired-size, min-size)

    ;Shrink the heap we desire a smaller heap than is currently set.
    if desired-size < heap-size :
      shrink-heap(desired-size, heap)

    ;Update the nursery based upon the new heap size.
    ;Note that if the desired heap size is less than the space required for the
    ;currently live objects, the computed nursery-size will be 0, so the program
    ;will fail with OutOfMemory if it allocates any more objects.
    val nursery-size = compute-nursery-size(heap)
    set-limit(min(heap.old-objects-end + nursery-size, heap-end(heap)), heap)

  ;Update the new limit on the maximum size of the heap.
  heap.size-limit = desired-size

  ;No meaningful return value
  return false

;============================================================
;=================== Generic Printing =======================
;============================================================

lostanza defn object-type-id (x:ref<?>) -> int :
  val ref = x as long
  val tagbits = ref & 0x7L
  if tagbits == INT-TAG-BITS : return INT-TYPE
  else if tagbits == BYTE-TAG-BITS : return BYTE-TYPE
  else if tagbits == CHAR-TAG-BITS : return CHAR-TYPE
  else if tagbits == FLOAT-TAG-BITS : return FLOAT-TYPE
  else if tagbits == MARKER-TAG-BITS :
    return (ref >> 3L) as int
  else if tagbits == REF-TAG-BITS :
    val p = (ref - REF-TAG-BITS) as ptr<long>
    return [p] as int
  else :
    fatal("Illegal tag bits\n")
    return 0

public lostanza defn object-type (x:ref<?>) -> ref<String> :
  val chars = class-name(object-type-id(x))
  return String(chars)

;============================================================
;================ Initialize Constants ======================
;============================================================

;Constants have to be initialized before LS-NL and NL. Strings
;do not behave properly until after initialize-constants().
initialize-heap-callback-routines()
initialize-constants()

;============================================================
;=================== Compound Constants =====================
;============================================================

lostanza deftype Sentinel
lostanza val sentinel:ref<Sentinel> = new Sentinel{}

protected deftype Uninitialized
protected val uninitialized = new Uninitialized

#if-defined(PLATFORM-WINDOWS) :
  lostanza val LS-NL:ptr<?> = "\r\n"
  val NL = "\r\n"
#else :
  lostanza val LS-NL:ptr<?> = "\n"
  val NL = "\n"

;============================================================
;=================== Initialize Remaining ===================
;============================================================

initialize-error-handler()
initialize-command-launcher()
initialize-coroutines()
initialize-gc-notifiers()
initialize-liveness-handlers()
initialize-symbol-table()

;================================================================================
;========================== End of Boot Sequence ================================
;================================================================================

;============================================================
;============= ExternTable and Callback Index Table =========
;============================================================

public lostanza defn extern-address (index:int) -> long :
  val vms:ptr<VMState> = call-prim flush-vm()
  val table = vms.extern-table
  val entry = table.entries[index]
  return entry.address

public lostanza defn extern-address (index:ref<Int>) -> ref<Long> :
  return new Long{extern-address(index.value)}

public lostanza defn extern-id-table () -> ref<HashTable<Symbol,Int>> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val table = vms.extern-table
  val n = table.length
  val return-table = HashTable<Symbol,Int>()
  for (var i:long = 0, i < n, i = i + 1) :
    val entry = table.entries[i]
    val name = to-symbol(String(entry.name))
    set(return-table, name, new Int{i as int})
  return return-table

;============================================================
;===================== Utilities ============================
;============================================================

protected lostanza defn linux-error-msg () -> ref<String> :
  val s = call-c clib/strerror(call-c clib/get_errno())
  return String(s)

#if-defined(PLATFORM-WINDOWS):
  extern get_windows_api_error: () -> ptr<byte>

  protected lostanza defn windows-error-msg () -> ref<String> :
    return String(call-c get_windows_api_error())

protected lostanza defn platform-error-msg () -> ref<String> :
  #if-defined(PLATFORM-WINDOWS):
    return windows-error-msg()
  #else:
    return linux-error-msg()

;============================================================
;====================== ToString ============================
;============================================================

public defmulti to-string (x) -> String

;                Default Implementation
;                ======================

defmethod to-string (x) -> String :
   val s = StringBuffer()
   print(s, x)
   to-string(s)

defmethod to-string (x:String) : x
defmethod to-string (x:True) : "true"
defmethod to-string (x:False) : "false"

;============================================================
;====================== Error Preconditions =================
;============================================================

defn ensure-divide-non-zero (i:Byte) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0Y)
defn ensure-divide-non-zero (i:Int) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0)
defn ensure-divide-non-zero (i:Long) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0L)

protected defn ensure-index-in-bounds (xs:Lengthable, i:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if i < 0 or i >= length(xs) :
      fatal("Index (%_) out of bounds." % [i])

protected defn ensure-length-in-bounds (xs:Lengthable, i:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if i < 0 or i > length(xs) :
      fatal("Index (%_) out of bounds." % [i])

defn ensure-start-before-end (s:Int, e:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if e < s :
      fatal("Given end index (%_) is smaller than start index (%_)." % [e, s])

protected defn ensure-non-negative (quantity:String, n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if n < 0 :
      fatal("Given %_ (%_) is negative." % [quantity, n])

protected defn ensure-positive (quantity:String, n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if n <= 0 :
      fatal("Given %_ (%_) is not positive." % [quantity, n])

protected defn ensure-non-negative-length (n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    ensure-non-negative("length", n)

protected defn ensure-index-range (xs:Lengthable, r:Range) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if step(r) != 1 :
      fatal("Given index range (%_) does not have a step of 1." % [r])
    val s = start(r)
    match(end(r), inclusive?(r)) :
      (e:Int, inc?:True) :
        ensure-index-in-bounds(xs, s)
        ensure-index-in-bounds(xs, e)
        ensure-start-before-end(s, e)
      (e:Int, inc?:False) :
        ensure-length-in-bounds(xs, s)
        ensure-length-in-bounds(xs, e)
        ensure-start-before-end(s, e)
      (e:False, inc?) :
        ensure-length-in-bounds(xs, s)

protected defn range-bound (s:Lengthable, r:Range) -> [Int, Int] :
  match(end(r), inclusive?(r)) :
    (e:Int, i:True) : [start(r), e + 1]
    (e:Int, i:False) : [start(r), e]
    (e:False, i) : [start(r), length(s)]

;============================================================
;===================== Hashable =============================
;============================================================

public deftype Hashable :
  Char <: Hashable
  Byte <: Hashable
  Int <: Hashable
  Long <: Hashable
  Float <: Hashable
  Double <: Hashable
  Tuple<T> <: Hashable
  List<T> <: Hashable
  String <: Hashable
  Symbol <: Hashable
  True <: Hashable
  False <: Hashable

public defmulti hash (h:Hashable) -> Int

lostanza defmethod hash (a:ref<Char>) -> ref<Int> :
  return new Int{a.value}

lostanza defmethod hash (a:ref<Byte>) -> ref<Int> :
  return new Int{a.value}

defmethod hash (a:Int) -> Int :
  a

lostanza defmethod hash (a:ref<Long>) -> ref<Int> :
  val v = a.value
  return new Int{(v ^ (v >> 32)) as int}

defmethod hash (a:Float) -> Int :
  bits(a)

lostanza defmethod hash (a:ref<Double>) -> ref<Int> :
  val v = a.value
  val bits = ($ls-prim bits v)
  return new Int{(bits ^ (bits >> 32)) as int}

defmethod hash (xs:Tuple<Hashable>) :
  var code:Int = 0x9e3779b9
  for x in xs do :
    code = code ^ (code << 11 + code >> 2 + 0x9e3779b9 + hash(x))
  code

defmethod hash (xs:List<Hashable>) -> Int :
  var code:Int = 0x9e3779b9
  for x in xs do :
    code = code ^ (code << 11 + code >> 2 + 0x9e3779b9 + hash(x))
  code

defmethod hash (a:True) : 1
defmethod hash (a:False) : 0

public lostanza defmethod hash (s:ref<String>) -> ref<Int> :
  if s.hash == 0 :
    val n = strlen(s)
    var h:int = 0
    for (var i:long = 0, i < n, i = i + 1) :
      h = (31 * h) + s.chars[i]
    if h == 0 : s.hash = 1
    else : s.hash = h
  return new Int{s.hash}

lostanza defmethod hash (s:ref<StringSymbol>) -> ref<Int> :
  return hash(s.name)

lostanza defmethod hash (s:ref<GenSymbol>) -> ref<Int> :
  return id(s)

;============================================================
;======================= Symbols ============================
;============================================================

public defmulti name (a:Symbol) -> String
public defmulti qualified? (a:Symbol) -> True|False
public defmulti qualifier (a:Symbol) -> [False|Symbol, Symbol]

;                   StringSymbol Functions
;                   ======================
lostanza defn StringSymbol (name:ref<String>) -> ref<StringSymbol> :
  return new StringSymbol{name}

lostanza defmethod name (s:ref<StringSymbol>) -> ref<String> :
  return s.name

defmethod qualified? (s:StringSymbol) :
  contains?(name(s), '/')

defmethod qualifier (s:StringSymbol) :
  match(last-index-of-char(name(s), '/')) :
    (i:Int) :
      val part1 = intern-symbol(name(s)[0 to i])
      val part2 = intern-symbol(name(s)[(i + 1) to false])
      [part1, part2]
    (i:False) :
      [false, s]

defmethod to-string (s:StringSymbol) :
   name(s)

;                  GenSymbol Functions
;                  ===================
public defmulti id (s:GenSymbol) -> Int

defn GenSymbol (name:String) :
  defn make-sym (name:String) :
    val id = genid()
    new GenSymbol :
      defmethod id (this) : id
      defmethod name (this) : name
      defmethod qualified? (this) : false
      defmethod qualifier (this) : [false, this]

  match(last-index-of-char(name, '/')) :
    (i:Int) :
      val id = genid()
      val qualifier = intern-symbol(name[0 to i])
      val unqualified-sym = make-sym(name[(i + 1) to false])
      new GenSymbol :
        defmethod id (this) : id
        defmethod name (this) : name
        defmethod qualified? (this) : true
        defmethod qualifier (this) : [qualifier, unqualified-sym]
    (i:False) :
        make-sym(name)

val ID-COUNTER = to-seq(0 to false)

public defn gensym (x) :
  match(x) :
    (x:Symbol) : gensym(name(x))
    (s:String) : GenSymbol(s)
    (x) : gensym(to-string(x))

public defn gensym () :
  gensym("$gen")

public defn genid () :
  next(ID-COUNTER)

;                    General Functions
;                    =================

public defn prefix? (a:Symbol, p:String) -> True|False :
  prefix?(name(a), p)

;                    Symbol Interning
;                    ================

var INTERNED-SYMBOLS : HashTable<String,Symbol>

lostanza defn initialize-symbol-table () -> ref<False> :
  ;Read number of consts
  val vms:ptr<VMState> = call-prim flush-vm()
  val cdata = vms.const-mem as ptr<int>
  val n-consts = [cdata]

  ;Get pointer to constant table
  val consts = vms.const-table as ptr<ref<?>>

  ;Initialize symbol table
  INTERNED-SYMBOLS = HashTable-init<String,Symbol>(fn(StringSymbol))
  for (var i:int = 0, i < n-consts, i = i + 1) :
    match(consts[i]) :
      (s:ref<Symbol>) : set(INTERNED-SYMBOLS, name(s), s)
      (s) : ()

  ;Done initialization
  initialized-symbol-table? = 1L
  return false

defn intern-symbol (name:String) :
   INTERNED-SYMBOLS[name]

public defn to-symbol (x) :
   match(x) :
      (x:Symbol) : x
      (x:String) : intern-symbol(x)
      (x) : to-symbol(to-string(x))

;============================================================
;===================== OutputStream =========================
;============================================================

;                   General Interface
;                   =================
public deftype OutputStream
public defmulti print (o:OutputStream, x) -> False
public defmulti print-all (o:OutputStream, xs:Seqable) -> False
public defmulti put (o:OutputStream, x) -> False

;                Default Implementations
;                =======================

lostanza val CONVERSION-BUFFER: ptr<byte> = call-c clib/malloc(64)

lostanza defn print-conversion-buffer-float (o:ref<OutputStream>, n:int) -> ref<False> :
  labels :
    begin :
      goto loop(0)
    loop (i:int) :
      if i < n :
        val c = CONVERSION-BUFFER[i]
        if c == '.' : goto rest(i)
        else if c == 'e' : goto add-dot(i)
        else :
          print(o, new Char{c})
          goto loop(i + 1)
      else : goto add-dot(i)
    add-dot (i:int) :
      print(o, new Char{'.'})
      print(o, new Char{'0'})
      goto rest(i)
    rest (i:int) :
      if i < n :
        print(o, new Char{CONVERSION-BUFFER[i]})
        goto rest(i + 1)
  return false

lostanza defn print-conversion-buffer-float (o:ptr<?>, n:int) -> ref<False> :
  labels :
    begin :
      goto loop(0)
    loop (i:int) :
      if i < n :
        val c = CONVERSION-BUFFER[i]
        if c == '.' : goto rest(i)
        else if c == 'e' : goto add-dot(i)
        else :
          call-c clib/fputc(c, o)
          goto loop(i + 1)
      else : goto add-dot(i)
    add-dot (i:int) :
      call-c clib/fputc('.', o)
      call-c clib/fputc('0', o)
      goto rest(i)
    rest (i:int) :
      if i < n :
        call-c clib/fputc(CONVERSION-BUFFER[i], o)
        goto rest(i + 1)
  return false

lostanza defn print-conversion-buffer (o:ref<OutputStream>, n:int) -> ref<False> :
   for (var i:int = 0, i < n, i = i + 1) :
      print(o, new Char{CONVERSION-BUFFER[i]})
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Byte>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value as int)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Int>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Long>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%lld", x.value)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Float>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.6g", x.value as double)
   print-conversion-buffer-float(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Double>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.15g", x.value)
   print-conversion-buffer-float(o, n)
   return false

defmethod print (o:OutputStream, x:True) :
   print(o, "true")

defmethod print (o:OutputStream, x:False) :
   print(o, "false")

defmethod print (o:OutputStream, x:String) :
   print-all(o, x)

lostanza defn stackframes (c:ref<RawCoroutine>) -> ref<Long> :
  return new Long{c.stack.frames as long}

defmethod print (o:OutputStream, c:RawCoroutine) :
  val s = switch {status(c) == _} :
    COROUTINE-ACTIVE : "ACTIVE"
    COROUTINE-CLOSED : "CLOSED"
    COROUTINE-SUSPENDED : "SUSPENDED"
    COROUTINE-OPEN : "OPEN"
  print(o, "<Coroutine #%_ : %_>" % [id(c), s])

defmethod print (o:OutputStream, t:Tuple) -> False :
   print(o, "[%@]" % [t])

defmethod print (o:OutputStream, xs:List) -> False :
   print(o, "(%@)" % [xs])

defmethod print (o:OutputStream, s:StringSymbol) :
   print(o, name(s))

defmethod print (o:OutputStream, s:GenSymbol) :
   print(o, name(s))
   print(o, id(s))

defmethod print (o:OutputStream, x) :
  print(o, "[%_ object]" % [object-type(x)])

defmethod print-all (o:OutputStream, xs:Seqable) :
   do(print{o, _}, xs)

;                 Convenience Functions
;                 =====================

public defn println (o:OutputStream, x) :
  print(o, x)
  print(o, NL)

public defn lnprint (o:OutputStream, x) :
  print(o, NL)
  print(o, x)

public defn println-all (o:OutputStream, xs:Seqable) :
   print-all(o, xs)
   print(o, NL)

;============================================================
;==================== Printing of Types =====================
;============================================================

defmethod print (o:OutputStream, t:Type) :
  defn loop (t:String|Type) :
    match(t) :
      (t:String) : print(o, t)
      (t:Type) : do(loop, parts(t))
  do(loop, parts(t))

lostanza defn parts (t:ref<Type>) -> ref<Tuple<String|Type>> :
  val code = t.code as ptr<(ref<Type> -> ref<Tuple>)>
  return [code](t)

;============================================================
;=================== FileOutputStream =======================
;============================================================

public lostanza deftype FileOutputStream <: OutputStream :
  file: ptr<?>
  closable?: long

public lostanza defn FileOutputStream (filename:ref<String>, append?:ref<True|False>) -> ref<FileOutputStream> :
   var file : ptr<?>
   if append? == true : file = call-c clib/fopen(addr!(filename.chars), "ab")
   else : file = call-c clib/fopen(addr!(filename.chars), "wb")
   if file == null : throw(FileOpenException(filename, linux-error-msg()))
   return new FileOutputStream{file, 1}

public defn FileOutputStream (filename:String) :
   FileOutputStream(filename, false)

public lostanza defn close (o:ref<FileOutputStream>) -> ref<False> :
   if o.closable? :
      val err = call-c clib/fclose(o.file)
      if err != 0 : throw(FileCloseException(linux-error-msg()))
   else : fatal("System OutputStream is not closable.")
   return false

public lostanza defn flush (o:ref<FileOutputStream>) -> ref<False> :
  val err = call-c clib/fflush(o.file)
  if err != 0 : throw(FileFlushException(linux-error-msg()))
  return false

;Optimized implementation of put for (FileOutputStream, Byte).
lostanza defmethod put (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

;Optimized implementation of put for (FileOutputStream, Char).
lostanza defmethod put (o:ref<FileOutputStream>, x:ref<Char>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

;Helper: Buffer to temporarily write values for output.
val WRITE-BUFFER = CharArray(8)

;Optimized implementation of put for (FileOutputStream, Int).
;Note the following code only works on little-endian machines.
lostanza defmethod put (o:ref<FileOutputStream>, x:ref<Int>) -> ref<False> :
  val data = addr!(WRITE-BUFFER.chars) as ptr<int>
  [data] = x.value
  val n = call-c clib/fwrite(data, 1, 4, o.file)
  if n < 4 : throw(FileWriteException(linux-error-msg()))
  return false

;Optimized implementation of put for (FileOutputStream, Long).
;Note the following code only works on little-endian machines.
lostanza defmethod put (o:ref<FileOutputStream>, x:ref<Long>) -> ref<False> :
  val data = addr!(WRITE-BUFFER.chars) as ptr<long>
  [data] = x.value
  val n = call-c clib/fwrite(data, 1, 8, o.file)
  if n < 8 : throw(FileWriteException(linux-error-msg()))
  return false

;Optimized implementation of put for (FileOutputStream, Int).
;Note the following code only works on little-endian machines.
lostanza defmethod put (o:ref<FileOutputStream>, x:ref<Float>) -> ref<False> :
  val data = addr!(WRITE-BUFFER.chars) as ptr<float>
  [data] = x.value
  val n = call-c clib/fwrite(data, 1, 4, o.file)
  if n < 4 : throw(FileWriteException(linux-error-msg()))
  return false

;Optimized implementation of put for (FileOutputStream, Double).
;Note the following code only works on little-endian machines.
lostanza defmethod put (o:ref<FileOutputStream>, x:ref<Double>) -> ref<False> :
  val data = addr!(WRITE-BUFFER.chars) as ptr<double>
  [data] = x.value
  val n = call-c clib/fwrite(data, 1, 8, o.file)
  if n < 8 : throw(FileWriteException(linux-error-msg()))
  return false

defmethod put (o:OutputStream, c:Char) -> False :
  put(o, to-byte(c))

defmethod put (o:OutputStream, i:Int) -> False :
  put(o, to-byte(i))
  put(o, to-byte(i >> 8))
  put(o, to-byte(i >> 16))
  put(o, to-byte(i >> 24))

defmethod put (o:OutputStream, i:Long) -> False :
   put(o, to-byte(i))
   put(o, to-byte(i >> 8L))
   put(o, to-byte(i >> 16L))
   put(o, to-byte(i >> 24L))
   put(o, to-byte(i >> 32L))
   put(o, to-byte(i >> 40L))
   put(o, to-byte(i >> 48L))
   put(o, to-byte(i >> 56L))

defmethod put (o:OutputStream, i:Float) -> False :
   put(o, bits(i))

defmethod put (o:OutputStream, i:Double) -> False :
   put(o, bits(i))

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<String>) -> ref<False> :
   val r = call-c clib/fputs(addr!(x.chars), o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value as int)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Char>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Int>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Long>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%lld", x.value)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Float>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.6g", x.value as double)
   print-conversion-buffer-float(o.file, n)
   if call-c clib/ferror(o.file) != 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Double>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.15g", x.value)
   print-conversion-buffer-float(o.file, n)
   if call-c clib/ferror(o.file) != 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<True>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "true")
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<False>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "false")
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

public defn with-output-file<?T> (file:FileOutputStream, f: () -> ?T) -> T :
   try : with-output-stream(file, f)
   finally : close(file)

public defn spit (filename:String, x) -> False :
  spit(filename, x, false)

public defn spit (filename:String, x, append?:True|False) -> False :
   val o = FileOutputStream(filename, append?)
   try : print(o, x)
   finally : close(o)

;============================================================
;================ System Output Streams =====================
;============================================================

;                 System Output Streams
;                 =====================

public lostanza val STANDARD-OUTPUT-STREAM : ref<OutputStream> =
   new FileOutputStream{stdout, 0}

public lostanza val STANDARD-ERROR-STREAM : ref<OutputStream> =
   new FileOutputStream{stderr, 0}

public lostanza val STANDARD-INPUT-STREAM : ref<InputStream> =
   new FileInputStream{stdin, 0}

;                 Current Output Stream
;                 =====================

var CURRENT-OUTPUT-STREAM : OutputStream = STANDARD-OUTPUT-STREAM

public defn with-output-stream<?T> (o:OutputStream, f: () -> ?T) -> T :
  let-var CURRENT-OUTPUT-STREAM = o :
    f()

public defn current-output-stream () :
  CURRENT-OUTPUT-STREAM

public defn set-current-output-stream (o:OutputStream) :
  CURRENT-OUTPUT-STREAM = o

;                 Current Error Stream
;                 ====================

var CURRENT-ERROR-STREAM : OutputStream = STANDARD-ERROR-STREAM

public defn with-error-stream<?T> (o:OutputStream, body: () -> ?T) -> T :
  val oldv = CURRENT-ERROR-STREAM
  dynamic-wind(
    fn () : set-current-error-stream(o)
    body
    fn () : set-current-error-stream(oldv))

public defn current-error-stream () :
  CURRENT-ERROR-STREAM

public defn set-current-error-stream (o:OutputStream) :
  CURRENT-ERROR-STREAM = o
  match(o:FileOutputStream) :
    set-current-err(o)

lostanza defn set-current-err (o:ref<FileOutputStream>) -> ref<False> :
  current-err = o.file
  return false

;              Print to Current Output Stream
;              ==============================

public defn print (x) :
   print(CURRENT-OUTPUT-STREAM, x)

public defn println (x) :
   println(CURRENT-OUTPUT-STREAM, x)

public defn print-all (xs:Seqable) :
   do(print, xs)

public defn println-all (xs:Seqable) :
   println-all(CURRENT-OUTPUT-STREAM, xs)


;============================================================
;=================== Input Streams ==========================
;============================================================

;                      Interface
;                      =========

public deftype InputStream
public defmulti get-char (i:InputStream) -> Char|False
public defmulti get-byte (i:InputStream) -> Byte|False

;Fill the given range within 'xs' with characters read
;from the input stream `i`. Returns the number of characters
;that was read in total.
public defmulti fill (xs:CharArray, r:Range, i:InputStream) -> Int

;                Abstract Implementations
;                ========================

;Repeatedly calls `get-char` to fill the CharArray.
defmethod fill (xs:CharArray, r:Range, s:InputStream) -> Int :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   defn* loop (i:Int) :
      if i < e :
         match(get-char(s)) :
            (c:Char) :
               xs[i] = c
               loop(i + 1)
            (c:False) : i - b
      else : i - b
   loop(b)

;============================================================
;=============== Buffered Input Streams =====================
;============================================================

public deftype BufferedInputStream <: InputStream

;                      Interface
;                      =========

public defmulti peek? (i:BufferedInputStream, n:Int) -> Char|False
public defmulti peek-fill (xs:CharArray, r:Range, i:BufferedInputStream) -> Int

;                Abstract Implementations
;                ========================

public defn peek? (i:BufferedInputStream) -> Char|False :
   peek?(i, 0)

;                     Creation
;                     ========

deftype CharQueue <: Lengthable
defmulti peek (c:CharQueue, i:Int) -> Char
defmulti pop (c:CharQueue) -> Char
defmulti peek-fill (xs:CharArray, b:Int, e:Int, c:CharQueue) -> Int
defmulti pop-fill (xs:CharArray, b:Int, e:Int, c:CharQueue) -> Int
defmulti fill (xs:CharQueue, stream:InputStream) -> False

defn CharQueue (cap:Int) :
   val array = CharArray(cap)
   var start:Int = 0
   var len:Int = 0

   defn wrap (i:Int) :
      val idx = start + i
      idx when idx < cap else idx - cap

   defn copy (xs:CharArray, b:Int, e:Int) :
      val n = e - b
      val n1 = cap - start
      val n2 = n - n1
      if n <= n1 :
         block-copy(n, xs, b, array, start)
      else :
         block-copy(n1, xs, b, array, start)
         block-copy(n2, xs, b + n1, array, 0)

   new CharQueue :
      defmethod length (this) :
         len
      defmethod peek (this, i:Int) :
         array[wrap(i)]
      defmethod pop (this) :
         val c = array[start]
         start = wrap(1)
         len = len - 1
         c
      defmethod peek-fill (xs:CharArray, b:Int, e:Int, this) -> Int :
         val n = min(e - b, len)
         copy(xs, b, b + n)
         n
      defmethod pop-fill (xs:CharArray, b:Int, e:Int, this) -> Int :
         val n = peek-fill(xs, b, e, this)
         start = wrap(n)
         len = len - n
         n
      defmethod fill (this, stream:InputStream) -> False :
         val pos = wrap(len)
         val total-read =
            if len == 0 :
               start = 0
               fill(array, 0 to cap, stream)
            else if start < pos :
               val n1 = cap - pos
               val n1* = fill(array, pos to cap, stream)
               if n1* < n1 : n1*
               else : n1* + fill(array, 0 to start, stream)
            else :
               fill(array, pos to start, stream)
         len = len + total-read

public defn BufferedInputStream (i:InputStream) -> BufferedInputStream :
   BufferedInputStream(i, 1024)

public defn BufferedInputStream (stream:InputStream, size:Int) -> BufferedInputStream :
   ensure-positive("buffer size", size)

   val buffer = CharQueue(size)

   new BufferedInputStream :
      defmethod peek? (this, i:Int) -> False|Char :
         #if-not-defined(OPTIMIZE) :
            if i < 0 :
               fatal("Cannot peek? into a BufferedInputStream at a negative index.")
            if i >= size :
               fatal("Cannot peek? %_ chars ahead into BufferedInputStream with buffer size %_." % [i, size])
         if length(buffer) > i :
            peek(buffer, i)
         else :
            fill(buffer, stream)
            peek(buffer, i) when length(buffer) > i

      defmethod peek-fill (xs:CharArray, r:Range, this) -> Int :
         val [b, e] = range-bound(xs, r)
         val n = e - b
         #if-not-defined(OPTIMIZE) :
            if n > size :
               fatal("Cannot peek more characters (%_) than capacity of buffer (%_)." % [n, size])
         fill(buffer, stream) when length(buffer) < n
         peek-fill(xs, b, e, buffer)

      defmethod fill (xs:CharArray, r:Range, this) -> Int :
         val [b, e] = range-bound(xs, r)
         val n = e - b
         if n < size :
            fill(buffer, stream) when length(buffer) < n
            pop-fill(xs, b, e, buffer)
         else :
            val n1 = pop-fill(xs, b, e, buffer)
            if n1 < n : n1 + fill(xs, (b + n1) to e, stream)
            else : n1

      defmethod get-char (this) -> False|Char :
         fill(buffer, stream) when length(buffer) == 0
         pop(buffer) when length(buffer) > 0

      defmethod get-byte (this) :
         match(get-char(this)) :
            (c:Char) : to-byte(c)
            (c:False) : false

;============================================================
;================= File Input Streams =======================
;============================================================

public lostanza deftype FileInputStream <: InputStream :
  file: ptr<?>
  closable?: long

public lostanza defn FileInputStream (filename:ref<String>) -> ref<FileInputStream> :
   val file = call-c clib/fopen(addr!(filename.chars), "rb")
   if file == null : throw(FileOpenException(filename, linux-error-msg()))
   return new FileInputStream{file, 1}

public lostanza defn close (i:ref<FileInputStream>) -> ref<False> :
   if i.closable? :
      val err = call-c clib/fclose(i.file)
      if err != 0 : throw(FileCloseException(linux-error-msg()))
   else : fatal("System Input Stream is not closable.")
   return false

lostanza defmethod get-char (i:ref<FileInputStream>) -> ref<Char|False> :
   val c = call-c clib/fgetc(i.file)
   if c == EOF :
      val err = call-c clib/ferror(i.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Char{c as byte}

lostanza defmethod get-byte (i:ref<FileInputStream>) -> ref<Byte|False> :
   val c = call-c clib/fgetc(i.file)
   if c == EOF :
      val err = call-c clib/ferror(i.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Byte{c as byte}

;Return the number of chars to read, and where to write it to.
lostanza deftype ReadChars :
  read-ptr: ptr<?>
  length: long

;Compute the number of chars to read and where to start reading.
lostanza defn compute-read-chars (xs:ref<CharArray>, r:ref<Range>) -> ReadChars :
  ensure-index-range(xs,r)
  val bounds = range-bound(xs,r) as ref<Tuple<Int>>
  val begin = bounds.items[0].value
  val end = bounds.items[1].value
  val len = end - begin
  val read-ptr = addr!(xs.chars[begin])
  return ReadChars{read-ptr, len}

;Repeatedly calls `get-char` to fill the CharArray.
lostanza defmethod fill (xs:ref<CharArray>, r:ref<Range>, s:ref<FileInputStream>) -> ref<Int> :
  ;Compute where to read to.
  val params = compute-read-chars(xs, r)

  ;Call fread to read the required number of bytes.
  val num-read = call-c clib/fread(params.read-ptr, 1, params.length, s.file)

  ;Check whether there was an IO error.
  ;There's an error if num-read is less than what was requested, and ferror is set.
  if num-read < params.length :
    val err = call-c clib/ferror(s.file)
    if err : throw(FileReadException(linux-error-msg()))

  ;Return the number of bytes read.
  return new Int{num-read as int}

;Attempt to read a little-endian integer/long/float/double from the given input stream.
public defmulti get-int (i:InputStream) -> False|Int
public defmulti get-long (i:InputStream) -> False|Long
public defmulti get-float (i:InputStream) -> False|Float
public defmulti get-double (i:InputStream) -> False|Double

;Generic implementation for any InputStream.
;Note that the following code only works on a little-endian machine.
val READ-BUFFER = CharArray(8)
val RANGE-4 = 0 to 4
val RANGE-8 = 0 to 8

lostanza defmethod get-int (i:ref<InputStream>) -> ref<False|Int> :
  val n = fill(READ-BUFFER, RANGE-4, i)
  if n.value == 4 :
    val int-ptr = addr!(READ-BUFFER.chars) as ptr<int>
    return new Int{[int-ptr]}
  return false

lostanza defmethod get-long (i:ref<InputStream>) -> ref<False|Long> :
  val n = fill(READ-BUFFER, RANGE-8, i)
  if n.value == 8 :
    val long-ptr = addr!(READ-BUFFER.chars) as ptr<long>
    return new Long{[long-ptr]}
  return false

;Helper function: Quickly read 'num' characters into the given CharArray
;from the given FileInputStream. Return the number of characters read.
lostanza defn fill (xs:ref<CharArray>, num:int, s:ref<FileInputStream>) -> int :
  val num-read = call-c clib/fread(addr!(xs.chars), 1, num, s.file)
  if num-read < num :
    val err = call-c clib/ferror(s.file)
    if err : throw(FileReadException(linux-error-msg()))
  return num-read as int

;Optimized implementation for FileInputStream.
lostanza defmethod get-int (i:ref<FileInputStream>) -> ref<False|Int> :
  val n = fill(READ-BUFFER, 4, i)
  if n == 4 :
    val int-ptr = addr!(READ-BUFFER.chars) as ptr<int>
    return new Int{[int-ptr]}
  return false    

;Optimized implementation for FileInputStream.
lostanza defmethod get-long (i:ref<FileInputStream>) -> ref<False|Long> :
  val n = fill(READ-BUFFER, 8, i)
  if n == 8 :
    val long-ptr = addr!(READ-BUFFER.chars) as ptr<long>
    return new Long{[long-ptr]}
  return false

;Generic implementation for all input streams.
defmethod get-float (i:InputStream) -> False|Float :
  match(get-int(i)) :
    (x:Int) : bits-as-float(x)
    (x:False) : false

;Optimized implementation for FileInputStream.
lostanza defmethod get-float (i:ref<FileInputStream>) -> ref<False|Float> :
  val n = fill(READ-BUFFER, 4, i)
  if n == 4 :
    val float-ptr = addr!(READ-BUFFER.chars) as ptr<float>
    return new Float{[float-ptr]}
  return false      

;Generic implementation for all input streams.
defmethod get-double (i:InputStream) -> False|Double :
  match(get-long(i)) :
    (x:Long) : bits-as-double(x)
    (x:False) : false

;Generic implementation for all input streams.
lostanza defmethod get-double (i:ref<FileInputStream>) -> ref<False|Double> :
  val n = fill(READ-BUFFER, 8, i)
  if n == 8 :
    val double-ptr = addr!(READ-BUFFER.chars) as ptr<double>
    return new Double{[double-ptr]}
  return false

;============================================================
;========================= Slurp ============================
;============================================================

;Read the contents of a file into a string.
public defn slurp (filename:String) -> String :
  val file = RandomAccessFile(filename, false)
  try :
    val len = to-int(length(file))
    val str = uninitialized-string(len)
    read-contents-into-string(str, file, len)
    str
  finally :
    close(file)

;Create a String without initializing its contents.
lostanza defn uninitialized-string (len:ref<Int>) -> ref<String> :
  val n = len.value
  val s = new String{n + 1, 0}
  s.chars[n] = 0Y
  return s

;Read 'len' bytes from the file into the memory occupied by
;the given string. Assumes that the string is allocated to
;have enough memory.
lostanza defn read-contents-into-string (s:ref<String>,
                                         file:ref<RandomAccessFile>,
                                         len:ref<Int>) -> ref<False> :
  val n = len.value
  val num-read = call-c clib/fread(addr!(s.chars), 1, n, file.file)
  if num-read < n :
    val err = call-c clib/ferror(file.file)
    if err : throw(FileReadException(core/platform-error-msg()))
  return false

;============================================================
;================== RandomAccessFiles =======================
;============================================================

public lostanza deftype RandomAccessFile :
  file: ptr<?>
  writable: ref<True|False>

public lostanza defn RandomAccessFile (filename:ref<String>, writable:ref<True|False>) -> ref<RandomAccessFile> :
  if writable == true :
    var file:ptr<?> = call-c clib/fopen(addr!(filename.chars), "r+b")
    if file == null :
      file = call-c clib/fopen(addr!(filename.chars), "w+b")
      if file == null : throw(FileOpenException(filename, linux-error-msg()))
      return new RandomAccessFile{file, writable}
    else :
      return new RandomAccessFile{file, writable}
  else :
    val file = call-c clib/fopen(addr!(filename.chars), "rb")
    if file == null : throw(FileOpenException(filename, linux-error-msg()))
    return new RandomAccessFile{file, writable}

public lostanza defn output-stream (file:ref<RandomAccessFile>) -> ref<FileOutputStream> :
  if file.writable == false :
    throw(FileNotWritableException())
  return new FileOutputStream{file.file, 0}

public lostanza defn input-stream (file:ref<RandomAccessFile>) -> ref<FileInputStream> :
  return new FileInputStream{file.file, 0}

public lostanza defn close (f:ref<RandomAccessFile>) -> ref<False> :
  val err = call-c clib/fclose(f.file)
  if err != 0 : throw(FileCloseException(linux-error-msg()))
  return false

public lostanza defn flush (f:ref<RandomAccessFile>) -> ref<False> :
  val err = call-c clib/fflush(f.file)
  if err != 0 : throw(FileFlushException(linux-error-msg()))
  return false

public lostanza defn writable? (f:ref<RandomAccessFile>) -> ref<True|False> :
  return f.writable

public lostanza defn length (f:ref<RandomAccessFile>) -> ref<Long> :
  return new Long{call-c clib/get_file_size(f.file)}

public lostanza defn position (f:ref<RandomAccessFile>) -> ref<Long> :
  return new Long{call-c clib/ftell(f.file)}

public lostanza defn time-modified (filename:ref<String>) -> ref<Long> :
  val t = call-c clib/file_time_modified(addr!(filename.chars))
  if t == 0 : throw(FileStatException(filename, linux-error-msg()))
  return new Long{t}

public lostanza defn set-length (f:ref<RandomAccessFile>, len:ref<Long>) -> ref<False> :
  val err = call-c clib/file_set_length(f.file, len.value)
  if err != 0 : throw(FileSetLengthException(linux-error-msg()))
  return false

public lostanza defn seek (f:ref<RandomAccessFile>, pos:ref<Long>) -> ref<False> :
  val err = call-c clib/file_seek(f.file, pos.value)
  if err != 0 : throw(FileSeekException(linux-error-msg()))
  return false

public lostanza defn skip (f:ref<RandomAccessFile>, pos:ref<Long>) -> ref<False> :
  val err = call-c clib/file_skip(f.file, pos.value)
  if err != 0 : throw(FileSeekException(linux-error-msg()))
  return false

public lostanza defn get-byte (f:ref<RandomAccessFile>) -> ref<Byte|False> :
  val c = call-c clib/fgetc(f.file)
  if c == EOF :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
    return false
  else :
    return new Byte{c as byte}

public defn get-char (f:RandomAccessFile) -> Char|False :
  match(get-byte(f)) :
    (b:Byte) : to-char(b)
    (b:False) : b

public lostanza defn get-int (f:ref<RandomAccessFile>) -> ref<Int|False> :
  val b0 = call-c clib/fgetc(f.file)
  val b1 = call-c clib/fgetc(f.file)
  val b2 = call-c clib/fgetc(f.file)
  val b3 = call-c clib/fgetc(f.file)
  if b3 == EOF :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
    return false
  else :
    return new Int{
      (b0) |
      (b1 << 8) |
      (b2 << 16) |
      (b3 << 24)}

public lostanza defn get-long (f:ref<RandomAccessFile>) -> ref<Long|False> :
  val b0 = call-c clib/fgetc(f.file)
  val b1 = call-c clib/fgetc(f.file)
  val b2 = call-c clib/fgetc(f.file)
  val b3 = call-c clib/fgetc(f.file)
  val b4 = call-c clib/fgetc(f.file)
  val b5 = call-c clib/fgetc(f.file)
  val b6 = call-c clib/fgetc(f.file)
  val b7 = call-c clib/fgetc(f.file)
  if b7 == EOF :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
    return false
  else :
    return new Long{
      (b0) |
      (b1 << 8L) |
      (b2 << 16L) |
      (b3 << 24L) |
      (b4 << 32L) |
      (b5 << 40L) |
      (b6 << 48L) |
      (b7 << 56L)}

public defn get-float (f:RandomAccessFile) -> Float|False :
  match(get-int(f)) :
    (i:Int) : bits-as-float(i)
    (i:False) : false

public defn get-double (f:RandomAccessFile) -> Double|False :
  match(get-long(f)) :
    (i:Long) : bits-as-double(i)
    (i:False) : false

public lostanza defn fill (a:ref<ByteArray>, r:ref<Range>, f:ref<RandomAccessFile>) -> ref<Long> :
  ;Get range bounds
  ensure-index-range(a, r)
  val rb = range-bound(a, r)
  val b = get(rb, new Int{0}).value
  val e = get(rb, new Int{1}).value
  val len = e - b
  ;Read block
  val ptr = addr!(a.data) + b
  val n = call-c clib/file_read_block(f.file, ptr, len)
  ;Check errors
  if n < len :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
  ;Return bytes read
  return new Long{n}

public defn fill (a:ByteArray, f:RandomAccessFile) -> Long :
  fill(a, 0 to false, f)

defn ensure-writable (f:RandomAccessFile) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if not writable?(f) :
      fatal("RandomAccessFile is not writable.")

public lostanza defn put (f:ref<RandomAccessFile>, xs:ref<ByteArray>, r:ref<Range>) -> ref<False> :
  ensure-writable(f)
  ;Get range bounds
  ensure-index-range(xs, r)
  val rb = range-bound(xs, r)
  val b = get(rb, new Int{0}).value
  val e = get(rb, new Int{1}).value
  val len = e - b
  ;Write block
  val ptr = addr!(xs.data) + b
  val n = call-c clib/file_write_block(f.file, ptr, len)
  ;Check errors
  if n < len :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileWriteException(linux-error-msg()))
  ;Done
  return false

public defn put (f:RandomAccessFile, xs:ByteArray) -> False :
  put(f, xs, 0 to false)

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Byte>) -> ref<False> :
  ensure-writable(f)
  val r = call-c clib/fputc(x.value, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Char>) -> ref<False> :
  ensure-writable(f)
  val r = call-c clib/fputc(x.value, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Int>) -> ref<False> :
  ensure-writable(f)
  val fp = f.file
  val xv = x.value
  call-c clib/fputc(xv as byte, f.file)
  call-c clib/fputc((xv >> 8) as byte, f.file)
  call-c clib/fputc((xv >> 16) as byte, f.file)
  val r = call-c clib/fputc((xv >> 24) as byte, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Long>) -> ref<False> :
  ensure-writable(f)
  val fp = f.file
  val xv = x.value
  call-c clib/fputc(xv as byte, f.file)
  call-c clib/fputc((xv >> 8L) as byte, f.file)
  call-c clib/fputc((xv >> 16L) as byte, f.file)
  call-c clib/fputc((xv >> 24L) as byte, f.file)
  call-c clib/fputc((xv >> 32L) as byte, f.file)
  call-c clib/fputc((xv >> 40L) as byte, f.file)
  call-c clib/fputc((xv >> 48L) as byte, f.file)
  val r = call-c clib/fputc((xv >> 56L) as byte, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public defn put (f:RandomAccessFile, x:Float) -> False :
  put(f, bits(x))

public defn put (f:RandomAccessFile, x:Double) -> False :
  put(f, bits(x))

;============================================================
;===================== ByteBuffer ===========================
;============================================================

public deftype ByteBuffer <: IndexedCollection<Byte> & OutputStream
public defmulti clear (b:ByteBuffer) -> False
public defmulti set-write-position (b:ByteBuffer, h:Int) -> False
public defmulti write-position (b:ByteBuffer) -> Int

public defn ByteBuffer (n:Int) -> ByteBuffer :
  ensure-non-negative("length", n)
  var buffer = ByteArray(n)
  var len:Int = 0
  var head:Int = 0

  defn ensure-capacity (c:Int) :
    defn set-capacity (c:Int) :
      val buffer* = ByteArray(c)
      block-copy(len, buffer*, 0, buffer, 0)
      buffer = buffer*
    val cur-c = length(buffer)
    set-capacity(max(c, 2 * cur-c)) when c > cur-c

  new ByteBuffer :
    defmethod backing-array (this) :
      buffer

    defmethod put (this, c:Byte) :
      ensure-capacity(head + 1)
      buffer[head] = c
      head = head + 1
      len = max(len, head)

    defmethod clear (this) :
      len = 0
      head = 0

    defmethod get (this, i:Int) :
      ensure-index-in-bounds(this, i)
      buffer[i]

    defmethod get (this, r:Range) :
      ensure-index-range(this, r)
      val [b, e] = range-bound(this, r)
      buffer[b to e]

    defmethod set (this, i:Int, b:Byte) :
      if i == head :
        put(this, b)
      else :
        ensure-index-in-bounds(this, i)
        buffer[i] = b

    defmethod length (this) :
      len

    defmethod set-write-position (this, h:Int) :
      ensure-length-in-bounds(this, h)
      head = h

    defmethod write-position (this) :
      head

defmulti backing-array (b:ByteBuffer) -> ByteArray
public lostanza defn data (b:ref<ByteBuffer>) -> ptr<byte> :
  return addr!(backing-array(b).data)

public defn ByteBuffer () :
  ByteBuffer(32)

defmethod print (b:ByteBuffer, c:Char) :
  put(b, to-byte(c))

defmethod print (o:OutputStream, b:ByteBuffer) :
  print(o, "[ByteBuffer: %_ bytes]" % [length(b)])

public defn OutputStream (b:ByteBuffer, i:Int) :
  var pos = i
  defn inc-pos () :
    val cur-pos = pos
    pos = pos + 1
    cur-pos
  new OutputStream :
    defmethod put (this, x:Byte) : b[inc-pos()] = x
    defmethod print (this, x:Char) : b[inc-pos()] = to-byte(x)

public defn InputStream (b:ByteBuffer, i:Int) :
  var pos = i
  defn inc-pos () :
    val cur-pos = pos
    pos = pos + 1
    cur-pos
  new InputStream :
    defmethod get-char (this) : to-char(b[inc-pos()]) when pos < length(b)
    defmethod get-byte (this) : b[inc-pos()] when pos < length(b)

public defn OutputStream (b:ByteBuffer) : OutputStream(b, 0)
public defn InputStream (b:ByteBuffer) : InputStream(b, 0)

;============================================================
;=================== StringBuffer ===========================
;============================================================

public deftype StringBuffer <: IndexedCollection<Char> & OutputStream

;                     Interface
;                     =========

public defmulti add (s:StringBuffer, c:Char) -> False
public defmulti add-all (s:StringBuffer, c:Seqable<Char>) -> False
public defmulti clear (s:StringBuffer) -> False

;               Abstract Implementation
;               =======================

defmethod add-all (s:StringBuffer, xs:Seqable<Char>) :
   do(add{s, _}, xs)

defmethod print (s:StringBuffer, c:Char) : add(s, c)
defmethod print (s:StringBuffer, cs:String) : add-all(s, cs)
defmethod print (s:StringBuffer, cs:StringBuffer) : add-all(s, cs)
defmethod print (s:StringBuffer, cs:CharArray) : add-all(s, cs)

defmethod print-all (s:StringBuffer, cs:String) : add-all(s, cs)
defmethod print-all (s:StringBuffer, cs:StringBuffer) : add-all(s, cs)
defmethod print-all (s:StringBuffer, cs:CharArray) : add-all(s, cs)

defmethod write (o:OutputStream, s:StringBuffer) :
   print(o, '"')
   for c in s do :
      escape-for-string(o, c)
   print(o, '"')

;                   Implementation
;                   ==============

public defn StringBuffer (n:Int) -> StringBuffer :
   ensure-non-negative("length", n)
   var buffer = CharArray(n)
   var len = 0

   defn ensure-capacity (c:Int) :
      defn set-capacity (c:Int) :
         val buffer* = CharArray(c)
         block-copy(len, buffer*, 0, buffer, 0)
         buffer = buffer*
      val cur-c = length(buffer)
      set-capacity(max(c, 2 * cur-c)) when c > cur-c

   new StringBuffer :
      defmethod add (this, c:Char) :
         ensure-capacity(len + 1)
         buffer[len] = c
         len = len + 1

      defmethod add-all (this, xs:Seqable<Char> & Lengthable) :
         val n = length(xs)
         ensure-capacity(len + n)
         for (x in xs, i in 0 to n) do :
            buffer[len + i] = x
         len = len + n

      defmethod clear (this) :
         len = 0

      defmethod get (this, i:Int) :
         ensure-index-in-bounds(this, i)
         buffer[i]

      defmethod get (this, r:Range) :
         ensure-index-range(this, r)
         val [b, e] = range-bound(this, r)
         buffer[b to e]

      defmethod set (this, i:Int, c:Char) :
         if i == len :
            add(this, c)
         else :
            ensure-index-in-bounds(this, i)
            buffer[i] = c

      defmethod length (this) :
         len

      defmethod to-string (this) :
         buffer[0 to len] as String

public defn StringBuffer () :
   StringBuffer(32)

;============================================================
;==================== Remove File ===========================
;============================================================
#if-defined(PLATFORM-WINDOWS) :
  lostanza defn delete-folder (path:ref<String>) -> ref<False> :
    val r = call-c clib/rmdir(addr!(path.chars))
    if r == -1 : throw(FileDeletionError(path, linux-error-msg()))
    return false
  lostanza defn delete-plain-file (path:ref<String>) -> ref<False> :
    val r = call-c clib/remove(addr!(path.chars))
    if r == -1 : throw(FileDeletionError(path, linux-error-msg()))
    return false
  public defn delete-file (path:String) :
    if file-exists?(path) and file-type(path) is DirectoryType :
      delete-folder(path)
    else :
      delete-plain-file(path)
#else :
  public lostanza defn delete-file (path:ref<String>) -> ref<False> :
    val r = call-c clib/remove(addr!(path.chars))
    if r == -1 : throw(FileDeletionError(path, linux-error-msg()))
    return false

public deftype FileDeletionError <: Exception
public defn FileDeletionError (path:String, msg:String) :
   new FileDeletionError :
      defmethod print (o:OutputStream, this) :
         print{o, _} $
         "Error when attempting to delete %_. %_." % [path, msg]

;============================================================
;====================== Rename a File =======================
;============================================================

public lostanza defn rename-file (path:ref<String>, new-path:ref<String>) -> ref<False> :
  val r = call-c clib/rename(addr!(path.chars), addr!(new-path.chars))
  if r == -1 : throw(FileRenameError(path, linux-error-msg()))
  return false

public deftype FileRenameError <: Exception
public defn FileRenameError (path:String, msg:String) :
   new FileRenameError :
      defmethod print (o:OutputStream, this) :
         print{o, _} $
         "Error when attempting to rename %_. %_." % [path, msg]

;============================================================
;================= Create a Symbolic Link ===================
;============================================================

public lostanza defn symlink (target:ref<String>, linkpath:ref<String>) -> ref<False> :
  val r = call-c clib/symlink(addr!(target.chars), addr!(linkpath.chars))
  if r == -1 : throw(SymLinkError(target, linkpath, linux-error-msg()))
  return false

public deftype SymLinkError <: Exception
public defn SymLinkError (target:String, linkpath:String, msg:String) :
  new SymLinkError :
    defmethod print (o:OutputStream, this) :
      print(o, "Error creating symbolic link %~ -> %~. %_." % [
        linkpath, target, msg])

;============================================================
;===================== Copying a File =======================
;============================================================

public defn copy-file (old-path:String, new-path:String) :
  val old-file = RandomAccessFile(old-path, false)
  val new-file = RandomAccessFile(new-path, true)
  try :
    val buffer = ByteArray(1042 * 1024)
    val end = length(old-file)
    while position(old-file) < end :
      val nbytes = to-int(fill(buffer, old-file))
      put(new-file, buffer, 0 to nbytes)
  finally :
    close(old-file)
    close(new-file)

;============================================================
;===================== FilePaths ============================
;============================================================

;Convert a (possibly null) character pointer to a String.
lostanza defn ptr-to-string? (p:ptr<byte>) -> ref<String|False> :
  if p != null :
    val s = String(p)
    call-c clib/free(p)
    return s
  else :
    return false

#if-defined(PLATFORM-WINDOWS) :
  ;----------------------------------------------------------
  ;-------------------- HiStanza Bindings -------------------
  ;----------------------------------------------------------
  lostanza defn windows-logical-drives-bitmask () -> ref<Int> :
    return new Int{call-c clib/windows_logical_drives_bitmask()}

  lostanza defn windows-final-path-name (path:ref<String>) -> ref<String|False> :
    val p = call-c clib/windows_final_path_name(addr!(path.chars))
    return ptr-to-string?(p)

  lostanza defn windows-full-path-name (path:ref<String>) -> ref<String|False> :
    val p = call-c clib/windows_full_path_name(addr!(path.chars))
    return ptr-to-string?(p)

  ;----------------------------------------------------------
  ;---------------------- Utilities -------------------------
  ;----------------------------------------------------------
  ;The windows GetFinalPath function sometimes prepends the result
  ;with \\?\ to indicate that it is using Unicode syntax
  ;to represent the result. We do not currently handle Unicode
  ;so we will strip away this prefix and assume the result
  ;can be interpreted as ascii.
  defn resolve-final-path (path:String) -> String|False :
    val final-path = windows-final-path-name(path)
    match(final-path:String) :
      if prefix?(final-path, "\\\\?\\") : final-path[4 to false]
      else : final-path

  ;----------------------------------------------------------
  ;----------------- Windows UNC Drive Names ----------------
  ;----------------------------------------------------------
  ;Represents all mapped drives that have a corresponding
  ;UNC path on Windows.
  deftype WindowsUNCDrivePaths

  ;Returns a tuple of X => path, where X is the drive letter
  ;and path is the UNC path. The path ends with a terminating \.
  defmulti drives (p:WindowsUNCDrivePaths) -> Tuple<KeyValue<Char,String>>

  ;Singleton definition
  val WINDOWS-UNC-DRIVE-PATHS = WindowsUNCDrivePaths()

  ;Return the vector of active drive letters.
  defn windows-drive-letters () -> Vector<Char> :
    val drives = Vector<Char>()
    var mask:Int = windows-logical-drives-bitmask()
    for i in 0 to 26 do :
      val valid? = mask & 1 != 0
      if valid? :
        val c = to-char(to-int('A') + i)
        add(drives, c)
      mask = mask >> 1
    drives

  ;Returns true if the given path is a UNC path.
  defn unc-path? (path:String) -> True|False :
    prefix?(path, "UNC\\")

  ;Scan for the Windows UNC Drive Paths.
  defn WindowsUNCDrivePaths () :
    var drive-paths:Tuple<KeyValue<Char,String>>|False = false
    defn scan-drive-paths () :
      if drive-paths is False :
        val paths = Vector<KeyValue<Char,String>>()
        for c in windows-drive-letters() do :
          val path = resolve-final-path(to-string("%_:\\" % [c]))
          match(path:String) :
            add(paths, c => path) when unc-path?(path)
        drive-paths = to-tuple(paths)
    new WindowsUNCDrivePaths :
      defmethod drives (this) :
        scan-drive-paths()
        drive-paths as Tuple<KeyValue<Char,String>>

  ;If the given path is a mapped network drive with a UNC path, then attempt to subtitute the
  ;drive letter for the UNC path. If a preferred drive is provided, then try to
  ;use the subtitution corresponding to that drive letter. (This occurs if the same path
  ;can be substituted in multiple ways.)
  defn sub-drive-letter (w:WindowsUNCDrivePaths, path:String, preferred:Char|False) -> String|False :
    ;Try to find all new paths.
    val new-paths = to-tuple $ for entry in drives(w) seq? :
      val letter = key(entry)
      if prefix?(path, value(entry)) :
        val len = length(value(entry))
        val new-path = to-string("%_:\\%_" % [letter, path[len to false]])
        One(letter => new-path)
      else : None()
    ;Choose the preferred one.
    switch(length(new-paths)) :
      0 :
        false
      1 :
        value(new-paths[0])
      else :
        val pref = find({key(_) == preferred}, new-paths)
        match(pref:KeyValue<Char,String>) : value(pref)
        else : value(new-paths[0])

  ;Windows algorithm for path resolution:
  ;Try the following techniques in this order:
  ;1) Use GetFinalPath.
  ;2) If it is a UNC path then try subtituting the drive letter.
  ;3) If that doesn't work, then try using GetFullPath.
  ;4) Ensure the final resolved path exists before returning.
  public defn resolve-path (path:String) -> String|False :
    ;Step 1.
    defn resolve-using-final-path () :
      val final-path = resolve-final-path(path)
      match(final-path:String) :
        if unc-path?(final-path) : resolve-by-substituting-drive-letter(final-path)
        else : return-path-if-exists?(final-path)

    ;Utility: If path has form X:\mydir, then return X.
    defn drive-letter? (path:String) -> Char|False :
      if length(path) >= 3 :
        val chars = path[1 to 3]
        if chars == ":\\" or chars == ":/" :
          path[0]

    ;Step 2.
    defn resolve-by-substituting-drive-letter (unc-path:String) :
      val preferred = drive-letter?(path)
      val new-path = sub-drive-letter(WINDOWS-UNC-DRIVE-PATHS, unc-path, preferred)
      match(new-path:String) : return-path-if-exists?(new-path)
      else : resolve-using-full-path()

    ;Step 3.
    defn resolve-using-full-path () :
      val full-path = windows-full-path-name(path)
      match(full-path:String) : return-path-if-exists?(full-path)

    ;Step 4.
    defn return-path-if-exists? (p:String) :
      p when file-exists?(p)

    ;Launch!
    resolve-using-final-path()

#else :
  public lostanza defn resolve-path (path:ref<String>) -> ref<String|False> :
     val p = call-c clib/resolve_path(addr!(path.chars))
     return ptr-to-string?(p)

public defn resolve-path! (path:String) -> String :
  match(resolve-path(path)) :
    (p:String) : p
    (f:False) : throw(PathResolutionError(path))

public defn norm-path (path) -> String :
   #if-defined(PLATFORM-WINDOWS) :
      replace(to-string(path), '/', '\\')
   #else :
      to-string(path)

public defn file-exists? (filename:String) -> True|False :
  try :
    file-type(filename, false)
    true
  catch (e:FileTypeException) :
    false

;============================================================
;================= Get the File Type ========================
;============================================================

public deftype FileType
public defstruct RegularFileType <: FileType
public defstruct DirectoryType <: FileType
public defstruct SymbolicLinkType <: FileType
public defstruct OtherType <: FileType

defmethod print (o:OutputStream, t:FileType) :
  print{o, _} $ match(t) :
    (t:RegularFileType) : "Regular File"
    (t:DirectoryType) : "Directory"
    (t:SymbolicLinkType) : "Symbolic Link"
    (t:OtherType) : "Other"

;Convert result of driver file_type return value into FileType object.
lostanza defn to-file-type (filename:ref<String>, r:int) -> ref<FileType> :
  if r == -1 : return throw(FileTypeException(filename, platform-error-msg()))
  else if r == 0 : return RegularFileType()
  else if r == 1 : return DirectoryType()
  else if r == 2 : return SymbolicLinkType()
  else if r == 3 : return OtherType()
  else : return fatal("Unreachable case")

#if-defined(PLATFORM-WINDOWS) :
  public lostanza defn file-type (filename:ref<String>, follow-symlinks?:ref<True|False>) -> ref<FileType> :
    if follow-symlinks? == true :
      return file-type(resolve-path!(filename), false)
    else :
      val result = call-c clib/get_file_type(addr!(filename.chars))
      return to-file-type(filename, result)
#else :
  public lostanza defn file-type (filename:ref<String>, follow-symlinks?:ref<True|False>) -> ref<FileType> :
    var follow-slinks:int = 0
    if follow-symlinks? == true : follow-slinks = 1
    val result = call-c clib/get_file_type(addr!(filename.chars), follow-slinks)
    return to-file-type(filename, result)

public defn file-type (filename:String) -> FileType :
  file-type(filename, true)

public defstruct FileTypeException <: IOException :
  filename: String
  cause: String|False with: (default => false)

defmethod print (o:OutputStream, e:FileTypeException) :
  val cause-str = match(cause(e)) :
    (c:String) : ": %_" % [c]
    (c:False) : ""
  print(o, "Error occurred when determining type of file %_%_." % [filename(e), cause-str])

;============================================================
;================ List Contents of Directory ================
;============================================================

extern free_stringlist : ptr<StringList> -> int
lostanza deftype StringList :
  n: int
  capacity: int
  strings: ptr<ptr<byte>>

extern list_dir: ptr<byte> -> ptr<StringList>
public lostanza defn dir-files (dirname:ref<String>, include-parents?:ref<True|False>) -> ref<Tuple<String>> :
  ;Call list dir
  val list = call-c list_dir(addr!(dirname.chars))
  val null = 0L as ptr<?>
  if list == null: throw(DirException(dirname, linux-error-msg()))
  ;Convert to vector
  val strings = Vector<String>()
  for (var i:int = 0, i < list.n, i = i + 1) :
    add(strings, String(list.strings[i]))
  ;Free stringlist
  call-c free_stringlist(list)
  ;Apply filter
  if include-parents? == true : return to-tuple(strings)
  else : return to-tuple(filter(fn(without-parents), strings))

defn without-parents (name:String) : name != "." and name != ".."

public defn dir-files (dirname:String) : dir-files(dirname, false)

public defstruct DirException <: IOException :
  filename: String
  cause: String
defmethod print (o:OutputStream, e:DirException) :
  print(o, "Error occurred when listing contents of directory %_: %_." %
    [filename(e), cause(e)])

;============================================================
;================== Split a Filepath ========================
;============================================================

public defn split-filepath (path:String) -> [String, String] :
  val n = length(path)
  match(last-index-of-char(path, '/')) :
    (i:Int) :
      throw(PathEndsWithSlash(path)) when i == n - 1
      [path[0 through i], path[(i + 1) to false]]
    (i:False) :
      throw(EmptyPath()) when n == 0
      ["./", path]

public deftype PathException <: Exception

public defstruct PathEndsWithSlash <: PathException :
  path: String
defmethod print (o:OutputStream, e:PathEndsWithSlash) :
  print(o, PEWS-MSG % [path(e)])
val PEWS-MSG = "Could not determine project name. Path %~ ends with a slash."

public defstruct EmptyPath <: PathException
defmethod print (o:OutputStream, e:EmptyPath) :
  print(o, EP-MSG)
val EP-MSG = "Could not determine project name. The given path is empty."

;============================================================
;================== Recursively Delete ======================
;============================================================

public defn delete-recursive (path:String, follow-symlinks?:True|False) :
  val dir = parse-path(path)
  if file-type(path, follow-symlinks?) is DirectoryType :
    for file in dir-files(path) do :
      val path = to-string(relative-to-dir(dir, file))
      delete-recursive(path, follow-symlinks?)
  delete-file(path)

public defn delete-recursive (path:String) :
  delete-recursive(path, true)

;============================================================
;================ Create a New Directory ====================
;============================================================

#if-defined(PLATFORM-WINDOWS) :
  extern _mkdir: (ptr<byte>) -> int
  public lostanza defn create-dir (dirname:ref<String>,
                                   permissions:ref<Int>) -> ref<False> :
    val result = call-c _mkdir(addr!(dirname.chars))
    if result == -1 : throw(CreateDirException(dirname, linux-error-msg()))
    return false
#else :
  extern mkdir: (ptr<byte>, long) -> int
  public lostanza defn create-dir (dirname:ref<String>,
                                   permissions:ref<Int>) -> ref<False> :
    val result = call-c mkdir(addr!(dirname.chars), permissions.value)
    if result == -1 : throw(CreateDirException(dirname, linux-error-msg()))
    return false

public defn create-dir (dirname:String) :
  create-dir(dirname, 0o777)

public defstruct CreateDirException <: IOException :
  filename: String
  cause: String
defmethod print (o:OutputStream, e:CreateDirException) :
  print(o, "Error occurred when attempting to create directory %_: %_." %
    [filename(e), cause(e)])

;============================================================
;================ Recursively Create ========================
;============================================================

;Recursively create all directories that lead up to filepath.
;Behaves like 'mkdir -p'.
;Throws an exception if the filepath (or a path leading up to filepath)
;is not a directory. 
public defn create-dir-recursive (filepath:String,
                                  permissions:Int) -> False :
  val path = parse-path(filepath)
  for n in 1 through length(entries(path)) do :
    val subpath = to-string(ParsedPath(entries(path)[0 to n]))
    if file-exists?(subpath) :
      ;Since the subpath already exists, check whether it is of
      ;the right type.
      match(file-type(subpath)) :
        ;Case: It's a directory. This is what we want.
        (t:DirectoryType) :
          false
        ;Case: It's not a directory. Throw an error.
        (t) :
          val msg = "The path %~ already exists and is not a directory."
          throw(CreateRecursiveDirException(filepath, to-string(msg % [subpath])))
    else :
      create-dir(subpath, permissions)

;Default permissions is 0o777.
public defn create-dir-recursive (filepath:String) -> False :
  create-dir-recursive(filepath, 0o777)

;Occurs when create-dir-recursive fails.
public defstruct CreateRecursiveDirException <: IOException :
  filepath:String
  msg:String

defmethod print (o:OutputStream, e:CreateRecursiveDirException) :
  print(o, "Error occurred when creating directory %~ recursively. %_" % [
    filepath(e), msg(e)])

;============================================================
;================ Environment Variables =====================
;============================================================

public lostanza defn get-env (name:ref<String>) -> ref<String|False> :
  val value = call-c clib/getenv(addr!(name.chars))
  if value == null : return false
  else : return String(value)

public defn get-env! (name:String) -> String :
  val v = get-env(name)
  match(v:String) : v
  else : throw(NoEnvVarError(name))

public lostanza defn set-env (name:ref<String>, value:ref<String>, overwrite:ref<True|False>) -> ref<False> :
  var ov:int = 0
  if overwrite == true : ov = 1
  val r = call-c clib/setenv(addr!(name.chars), addr!(value.chars), ov)
  if r != 0 : throw(SetEnvException(name, value, linux-error-msg()))
  return false

public defn set-env (name:String, value:String) :
  set-env(name, value, true)

public lostanza defn unset-env (name:ref<String>) -> ref<False> :
  val r = call-c clib/unsetenv(addr!(name.chars))
  if r != 0 : throw(UnsetEnvException(name, linux-error-msg()))
  return false

public defstruct NoEnvVarError <: Exception :
  name: String

public defstruct SetEnvException <: Exception :
  name: String
  value: String
  cause: String

defmethod print (o:OutputStream, e:SetEnvException) :
   print(o, "Could not set environment variable %_ to %~. %_." % [name(e), value(e), cause(e)])

public defstruct UnsetEnvException <: Exception :
  name: String
  cause: String
defmethod print (o:OutputStream, e:UnsetEnvException) :
  print(o, "Could not unset environment variable %_. %_." % [name(e), cause(e)])

;Retrieve every env var in the environment.
public lostanza defn get-env-vars () -> ref<Tuple<KeyValue<String,String>>> :
  val accum = Vector<KeyValue<String,String>>()
  var env:ptr<ptr<byte>> = call-c clib/get_env_vars()
  while [env] != null :
    add?(accum, parse-env-var-string(String([env])))
    env = addr!(env[1])
  return to-tuple(accum)

;Helper: Add x to vector v if x is not empty.
defn add?<?T> (v:Vector<?T>, x:Maybe<T>) -> False :
  add(v,value!(x)) when not empty?(x)  

;Helper: Parse an env-var string with foramt: "VAR=VALUE".
;Returns None() if it is not in that format.
defn parse-env-var-string (str:String) -> Maybe<KeyValue<String,String>> :
  match(index-of-char(str, '=')) :
    (i:Int) : One(str[0 to i] => str[(i + 1) to false])
    (f:False) : None()

;============================================================
;================== Exit System =============================
;============================================================

public lostanza defn exit (code:ref<Int>) -> ref<Void> :
   call-c clib/exit(code.value)
   return null as ref<Void>

;============================================================
;===================== Exceptions ===========================
;============================================================

;Represents all exceptions.
public deftype Exception <: Unique

;Simple constructor for a generic exception.
public defn Exception (msg) -> Exception :
  new Exception :
    defmethod print (o:OutputStream, this) :
      print(o, msg)

;Holds the currently-equipped exception handler.
var CURRENT-EXCEPTION-HANDLER : Exception -> Void =
  fn (e:Exception) :
    fatal(e)

public var CURRENT-HANDLER-NAME:String = "Default"

;Throw the given exception to the currently-set handler.
public defn throw (e:Exception) :
  CURRENT-EXCEPTION-HANDLER(e)

;Run the given body with the equipped exception interceptor.
public defn with-exception-interceptor<?T> (body: () -> ?T,
                                            intercept: Exception -> Void) -> T :
  val handler = CURRENT-EXCEPTION-HANDLER
  defn interceptor (e:Exception) :
    CURRENT-EXCEPTION-HANDLER = handler
    intercept(e)
  let-var CURRENT-EXCEPTION-HANDLER = interceptor :
    body()

;Run the given body with the equipped catchers.
public defn with-exception-handler<?T> (body: () -> ?T,
                                        catch?: Exception -> True|False,
                                        catcher: Exception -> ?T) -> T :
  ;Execute the body within a label so that stack can be unwound.
  val r = label<ExceptionResult|NormalResult> break :
    ;Holds the outer handler during the dynamic extent of this 'try' block.
    ;Will be set during wind-in.
    var outer-handler:Exception -> Void

    ;Implementation of throw within the body.
    defn throw-within-body (e:Exception) :
      ;First check whether the catcher is supposed to handle this
      ;exception.
      if catch?(e) :
        ;If it is, then unwind the stack and handle it.
        break(ExceptionResult(e))
      else :
        ;Otherwise, pass the exception to the next handler
        ;to handle it.
        outer-handler(e)

    ;Execute the body with the new throw equipped.
    dynamic-wind(
      fn () :
        outer-handler = CURRENT-EXCEPTION-HANDLER
        CURRENT-EXCEPTION-HANDLER = throw-within-body
      fn () :
        NormalResult(body())
      fn () :
        CURRENT-EXCEPTION-HANDLER = outer-handler)

  ;Depending on whether the body executed successfully, either
  ;run the catcher or not.
  match(r) :
    (r:ExceptionResult) : catcher(exception(r))
    (r:NormalResult) : result(r)

;Represents the return value from a body when equipped
;with catchers.
defstruct ExceptionResult : (exception: Exception)
defstruct NormalResult : (result)

;Run the given body with the equipped finally block.
public defn with-finally<?T> (body: () -> ?T, finally: () -> ?) -> T :
  val s = dy-ctxt-state(current-coroutine)
  val frame = DyCtxtFinallyFrame(finally)
  push-frame(s, frame)
  val result = body()
  pop-frame(s, true, true)
  result


;  push-winder(Winder(false, false, finally))
;  inc-winders(current-coroutine, 1)
;  val result = body()
;  pop-winder()
;  inc-winders(current-coroutine, -1)
;  finally()
;  result

;============================================================
;============== Input/Output Exceptions =====================
;============================================================

public deftype IOException <: Exception

public defstruct FileStatException <: IOException :
  filename: String
  cause: String

defmethod print (o:OutputStream, e:FileStatException) :
  print(o, "Error occurred when attempting to read statistics of file %_. %_." % [
    filename(e), cause(e)])

public defstruct FileOpenException <: IOException :
   filename: String
   cause: String

defmethod print (o:OutputStream, e:FileOpenException) :
   print(o, "Error occurred when attempting to open file %_. %_." % [filename(e), cause(e)])

public defstruct FileCloseException <: IOException :
   cause: String

public defstruct FileNotWritableException <: IOException
defmethod print (o:OutputStream, e:FileNotWritableException) :
  print(o, "The given random access file is not allowed to be written to.")

defmethod print (o:OutputStream, e:FileCloseException) :
   print(o, "Error occurred when attempting to close file. %_." % [cause(e)])

public defstruct FileFlushException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileFlushException) :
   print(o, "Error occurred when attempting to flush file. %_." % [cause(e)])

public defstruct FileReadException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileReadException) :
   print(o, "Error occurred when attempting to read from file. %_." % [cause(e)])

public defstruct FileWriteException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileWriteException) :
   print(o, "Error occurred when attempting to write to file. %_." % [cause(e)])

public defstruct FileSeekException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileSeekException) :
   print(o, "Error occurred when attempting to seek in file. %_." % [cause(e)])

public defstruct FileSetLengthException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileSetLengthException) :
   print(o, "Error occurred when attempting to seek in file. %_." % [cause(e)])

public defstruct PathResolutionError <: Exception :
   filename: String
defmethod print (o:OutputStream, e:PathResolutionError) :
  print(o, "Could not resolve path %~." % [filename(e)])

;============================================================
;================ String Input Streams ======================
;============================================================

public deftype StringInputStream <: InputStream & Lengthable

;                       Interface
;                       =========

public defmulti peek? (s:StringInputStream, i:Int) -> False|Char
public defmulti info (s:StringInputStream) -> FileInfo
public defmulti get-chars (s:StringInputStream, n:Int) -> String


;                Abstract Implementations
;                ========================

public defn peek? (s:StringInputStream) :
   peek?(s, 0)

public defn peek (s:StringInputStream, i:Int) :
   match(peek?(s, i)) :
      (c:Char) : c
      (c:False) : fatal("No more characters in stream.")

public defn peek (s:StringInputStream) :
   peek(s, 0)

;                   Implementation
;                   ==============

public defn StringInputStream (string:String, filename:String) :
  StringInputStream(string, FileInfo(filename, 1, 0))

public defn StringInputStream (string:String, fileinfo:FileInfo) :
   var start = 0
   var line = line(fileinfo)
   var column = column(fileinfo)
   val n = length(string)

   new StringInputStream :
      defmethod get-char (this) :
         if start < n :
            val c = string[start]
            start = start + 1
            if c == '\n' :
               line = line + 1
               column = 0
            else :
               column = column + 1
            c

      defmethod get-chars (this, n:Int) :
         #if-not-defined(OPTIMIZE) :
            if length(this) < n :
               fatal("Cannot eat %_ chars from StringInputStream with %_ chars remaining." % [n, length(this)])
         val ret = string[start to start + n]
         do(get-char{this}, 0 to n)
         ret

      defmethod get-byte (this) :
         match(get-char(this)) :
            (c:Char) : to-byte(c)
            (c:False) : false

      defmethod info (this) :
         FileInfo(filename(fileinfo), line, column)

      defmethod peek? (this, i:Int) :
         string[start + i] when start + i < n

      defmethod length (this) :
         n - start

public defn StringInputStream (string:String) :
   StringInputStream(string, "UnnamedStream")

;============================================================
;======================= Chars ==============================
;============================================================

public lostanza defn digit? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= '0' and b <= '9' : return true
   else : return false

public lostanza defn letter? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'a' and b <= 'z' : return true
   else if b >= 'A' and b <= 'Z' : return true
   else : return false

public lostanza defn upper-case? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'A' and b <= 'Z' : return true
   else : return false

public lostanza defn lower-case? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'a' and b <= 'z' : return true
   else : return false

public lostanza defn lower-case (c:ref<Char>) -> ref<Char> :
   val cv = c.value
   if cv >= 'A' and cv <= 'Z' : return new Char{cv - 'A' + 'a'}
   else : return c

public lostanza defn upper-case (c:ref<Char>) -> ref<Char> :
   val cv = c.value
   if cv >= 'a' and cv <= 'z' : return new Char{cv - 'a' + 'A'}
   else : return c

;============================================================
;===================== Tuples ===============================
;============================================================

protected lostanza defn void-tuple (n:long) -> ref<Tuple> :
  val x = new Tuple{n}
  for (var i:long = 0, i < n, i = i + 1) :
    x.items[i] = sentinel
  return x

public lostanza defn Tuple<?T> (n:ref<Int>, x:ref<?T>) -> ref<Tuple<T>> :
   ensure-non-negative-length(n)
   val len = n.value
   val t = new Tuple<T>{len}
   for (var i:long = 0, i < len, i = i + 1) :
      t.items[i] = x
   return t

lostanza defn set<?T> (x:ref<Tuple<?T>>, i:ref<Int>, v:ref<T>) -> ref<False> :
   ensure-index-in-bounds(x, i)
   x.items[i.value] = v
   return false

public lostanza defn get<?T> (x:ref<Tuple<?T>>, i:ref<Int>) -> ref<T> :
   ensure-index-in-bounds(x, i)
   return x.items[i.value]

public defn get<?T> (xs:Tuple<?T>, r:Range) -> Tuple<T> :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])

public defn empty? (t:Tuple) :
   length(t) == 0

public defn map<?T,?R> (f:T -> ?R, xs:Tuple<?T>) -> Tuple<R> :
   to-tuple(seq(f, xs))

;============================================================
;===================== Strings ==============================
;============================================================

public lostanza defn String (chars:ptr<byte>) -> ref<String> :
  val len = call-c clib/strlen(chars)
  return String(len, chars)

public lostanza defn String (len:long, c:byte) -> ref<String> :
  val s = String(len)
  for (var i:long = 0, i < len, i = i + 1) :
    s.chars[i] = c
  s.chars[len] = 0 as byte
  return s

public lostanza defn String (len:ref<Int>, c:ref<Char>) -> ref<String> :
  ensure-non-negative-length(len)
  return String(len.value, c.value)

public lostanza defn get (s:ref<String>, i:ref<Int>) -> ref<Char> :
  ensure-index-in-bounds(s, i)
  return new Char{s.chars[i.value]}

lostanza defn set (s:ref<String>, i:ref<Int>, c:ref<Char>) -> ref<False> :
  ensure-index-in-bounds(s, i)
  s.chars[i.value] = c.value
  return false

lostanza defn copy-string (s:ref<String>) -> ref<String> :
  return String(s.length, addr!(s.chars))

;============================================================
;======================= String Library =====================
;============================================================

lostanza defn strlen (s:ref<String>) -> long :
  return s.length - 1

lostanza defn copy (dst:ref<String>, src:ref<String>, dst-i:long) -> ref<False> :
   val src-len = strlen(src)
   call-c clib/memcpy(addr!(dst.chars[dst-i]), addr!(src.chars), src-len)
   return false

public defn matches? (a:String, start:Int, b:String) :
   ensure-length-in-bounds(a, start)
   val an = length(a)
   val bn = length(b)
   if (start + bn) <= an :
      for i in 0 to bn all? :
         a[start + i] == b[i]

public defn prefix? (s:String, prefix:String) :
   matches?(s, 0, prefix)

public defn suffix? (s:String, suffix:String) :
   val start = max(0, length(s) - length(suffix))
   matches?(s, start, suffix)

public defn empty? (s:String) :
   length(s) == 0

lostanza defn substring! (str:ref<String>, b:ref<Int>, e:ref<Int>) -> ref<String> :
   val s = b.value
   val n = e.value - s
   val ret = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      ret.chars[i] = str.chars[i + s]
   ret.chars[n] = 0 as byte
   return ret

public defn get (s:String, r:Range) -> String :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   substring!(s, b, e)

public lostanza defn append (a:ref<String>, b:ref<String>) -> ref<String> :
   val al = strlen(a)
   val bl = strlen(b)
   val n = al + bl
   val s = String(n)
   copy(s, a, 0)
   copy(s, b, al)
   s.chars[n] = 0 as byte
   return s

public lostanza defn append-all (xs:ref<Seqable<String>>) -> ref<String> :
   match(xs) :
      (xs:ref<Collection<String>>) :
         val len = sum(seq(fn(length), xs))
         val ret = String(len.value)
         val xs-seq = to-seq(xs)
         var accum : long = 0
         while empty?(xs-seq) == false :
            val s = next(xs-seq)
            copy(ret, s, accum)
            accum = accum + strlen(s)
         ret.chars[len.value] = 0 as byte
         return ret
      (xs:ref<Seqable<String>>) :
         return append-all(to-vector<String>(xs))

public defn string-join (xs:Seqable) -> String :
   val s = StringBuffer()
   print-all(s, xs)
   to-string(s)

public defn string-join (xs:Seqable, j) -> String :
   string-join(join(xs, j))

public defn index-of-char (s:String, r:Range, c:Char) -> False|Int :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   for i in b to e find :
      s[i] == c

public defn index-of-char (s:String, c:Char) -> False|Int :
   index-of-char(s, 0 to false, c)

public defn index-of-chars (a:String, r:Range, b:String) -> False|Int :
   ensure-index-range(a, r)
   val [s, e] = range-bound(a, r)
   val an = e - s
   val bn = length(b)
   if bn <= an :
      for i in s through (e - bn) find :
         matches?(a, i, b)

;Returns the index at which b occurs within a.
public defn index-of-chars (a:String, b:String) -> False|Int :
   index-of-chars(a, 0 to false, b)

;Returns true if b is a substring of a.
public defn substring? (a:String, b:String) -> True|False :
  index-of-chars(a, b) is Int

;Returns true if b is a substring of the given range within a.
public defn substring? (a:String, r:Range, b:String) -> True|False :
  index-of-chars(a, r, b) is Int

public defn last-index-of-char (s:String, r:Range, c:Char) -> False|Int :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   for i in (e - 1) through b by -1 find :
      s[i] == c

public defn last-index-of-char (s:String, c:Char) -> False|Int :
   last-index-of-char(s, 0 to false, c)

public defn last-index-of-chars (a:String, r:Range, b:String) -> False|Int :
   ensure-index-range(a, r)
   val [s, e] = range-bound(a, r)
   val an = e - s
   val bn = length(b)
   if bn <= an :
      for i in (e - bn) through s by -1 find :
         matches?(a, i, b)

public defn last-index-of-chars (a:String, b:String) -> False|Int :
   last-index-of-chars(a, 0 to false, b)

public defn replace (s:String, i:Int, c:Char) -> String :
  val s2 = copy-string(s)
  s2[i] = c
  s2

public lostanza defn replace (s:ref<String>, c1:ref<Char>, c2:ref<Char>) -> ref<String> :
   val b1 = c1.value
   val b2 = c2.value
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc == b1 : r.chars[i] = b2
      else : r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public defn replace (str:String, s1:String, s2:String) -> String :
   fatal("String to be replaced cannot be empty.") when empty?(s1)
   val buf = StringBuffer(length(str))
   val n = length(str)
   val s1n = length(s1)
   defn* loop (i:Int) :
      if i < n :
         if matches?(str, i, s1) :
            print(buf, s2)
            loop(i + s1n)
         else :
            print(buf, str[i])
            loop(i + 1)
   loop(0)
   to-string(buf)

public defn split (str:String, s:String) -> Seq<String> :
  generate<String> :
    val sl = length(s)
    defn loop (b:Int) :
      match(index-of-chars(str, b to false, s)) :
        (i:Int) :
          yield(str[b to i])
          loop(i + sl)
        (i:False) :
          yield(str[b to false])
    loop(0)

public defn split (str:String, s:String, n:Int) -> Seq<String> :
  if n <= 0 :
    fatal("Maximum number of splits (%_) is not positive." % [n])
  generate<String> :
    val sl = length(s)
    defn* loop (b:Int, n:Int) :
      if n > 1 :
        match(index-of-chars(str, b to false, s)) :
          (i:Int) :
            yield(str[b to i])
            loop(i + sl, n - 1)
          (i:False) :
            yield(str[b to false])
      else :
        yield(str[b to false])
    loop(0, n)

public lostanza defn lower-case (s:ref<String>) -> ref<String> :
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc >= 'A' and sc <= 'Z' :
         r.chars[i] = sc - 'A' + 'a'
      else :
         r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public lostanza defn upper-case (s:ref<String>) -> ref<String> :
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc >= 'a' and sc <= 'z' :
         r.chars[i] = sc - 'a' + 'A'
      else :
         r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public defn trim (pred: Char -> True|False, s:String) :
   defn not-pred (c:Char) : not pred(c)
   match(index-when(not-pred, s)) :
      (i:Int) :
         val n = length(s)
         val j = for i in (n - 1) through 0 by -1 find! :
            not-pred(s[i])
         s[i through j]
      (i:False) : ""

public defn trim (s:String) -> String :
   defn whitespace? (c:Char) :
      (c == ' ') or
      (c == '\n') or
      (c == '\t') or
      (c == '\b') or
      (c == '\r')
   trim(whitespace?, s)

;============================================================
;======================= Lists ==============================
;============================================================

public defn cons<?T> (x:?T, y:?T, t:List<?T>) -> List<T> :
   cons(x, cons(y, t))

public defn cons<?T> (x:?T, y:?T, z:?T, t:List<?T>) -> List<T> :
   cons(x, cons(y, cons(z, t)))

public defn List<?T> (x:?T) -> List<T> :
   cons(x, List())

public defn List<?T> (x:?T, y:?T) -> List<T> :
   cons(x, cons(y, List()))

public defn List<?T> (x:?T, y:?T, z:?T) -> List<T> :
   cons(x, cons(y, cons(z, List())))

public defn List<?T> (w:?T, x:?T, y:?T, z:?T) -> List<T> :
   cons(w, cons(x, cons(y, cons(z, List()))))

;============================================================
;====================== List Library ========================
;============================================================

public defn* get<?T> (xs:List<?T>, i:Int) -> T :
   if i == 0 : head(xs)
   else : get(tail(xs), i - 1)

public defn headn<?T> (l:List<?T>, n:Int) -> List<T> :
   if n == 0 : List()
   else : cons(head(l), headn(tail(l), n - 1))

public defn* tailn<?T> (l:List<?T>, n:Int) -> List<T> :
   if n == 0 : l
   else : tailn(tail(l), n - 1)

public defn append<?T> (xs:Seqable<?T>, ys:List<?T>) -> List<T> :
   if empty?(ys) :
      to-list(xs)
   else :
      val items = to-vector<T>(xs)
      defn* loop (i:Int, tail:List<T>) :
         if i >= 0 : loop(i - 1, cons(items[i], tail))
         else : tail
      loop(length(items) - 1, ys)

public defn append-all<?T> (xs:Seqable<List<?T>>) -> List<T> :
   val xs-seq = to-seq(xs)
   defn loop () :
      if empty?(xs-seq) : List()
      else : append(next(xs-seq), loop())
   loop()

public defn seq-append<?T,?R> (f: T -> List<?R>, xs:Seqable<?T>) -> List<R> :
   append-all(seq(f, xs))

public defn seq-append<?T,?S,?R> (f: (T,S) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> List<R> :
   append-all(seq(f, xs, ys))

public defn seq-append<?T,?S,?U,?R> (f: (T,S,U) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R> :
   append-all(seq(f, xs, ys, zs))

public defn map<?T,?R> (f: T -> ?R, xs:List<?T>) -> List<R> :
  let loop (xs:List<T> = xs, i:Int = 0) :
    if i < 16 :
      if empty?(xs) : List()
      else : cons(f(head(xs)), loop(tail(xs), i + 1))
    else : to-list(seq(f, xs))

public defn map<?T,?S,?R> (f: (T,S) -> ?R, xs:List<?T>, ys:Seqable<?S>) -> List<R> :
   to-list(seq(f, xs, ys))

public defn map<?T,?S,?U,?R> (f: (T,S,U) -> ?R, xs:List<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R> :
   to-list(seq(f, xs, ys, zs))

public defn transpose<?T> (xs:List<List<?T>>) -> List<List<T>> :
   if empty?(xs) :
      List()
   else if any?(empty?, xs) :
      List()
   else :
      val hs = map(head, xs)
      val ts = map(tail, xs)
      cons(hs, transpose(ts))

public defn last<?T> (xs:List<?T>) -> T :
   fatal("Empty List") when empty?(xs)
   defn* loop (xs:List<T>) :
      if empty?(tail(xs)) : head(xs)
      else : loop(tail(xs))
   loop(xs)

public defn but-last<?T> (xs:List<?T>) -> List<T> :
   fatal("Empty List") when empty?(xs)
   defn* loop (xs:List<T>) :
      if empty?(tail(xs)) : List()
      else : cons(head(xs), but-last(tail(xs)))
   loop(xs)

public defn reverse<?T> (xs:List<?T>) -> List<T> :
   if empty?(xs) :
      xs
   else :
      var accum = List()
      for x in xs do :
         accum = cons(x, accum)
      accum

;============================================================
;====================== Formatting ==========================
;============================================================

public deftype Printable

public defn modulo (format:String, args:Seqable) -> Printable :
  new Printable :
    defmethod* print (o:OutputStream, this) :
      val seq = to-seq(args)
      defn next-arg () :
        #if-not-defined(OPTIMIZE) :
          fatal("Format string %~ is expecting more arguments." % [format]) when empty?(seq)
        next(seq)
      defn next-seq () :
        val x = next-arg()
        #if-not-defined(OPTIMIZE) :
          if x is-not Seqable :
            fatal("Format string %~ is expecting a sequence, but received: %~." % [format, x])
        x

      val n = length(format)
      defn* loop (i:Int) :
        if i < n :
          val c = format[i]
          if c == '%' :
            if i + 1 < n :
              val modifier = format[i + 1]
              switch {modifier == _} :
                '_' : print(o, next-arg())
                '*' : print-all(o, next-seq())
                ',' : print-all(o, join(next-seq(), ", "))
                's' : print-all(o, join(next-seq(), " "))
                'n' : print-all(o, join(next-seq(), "\n"))
                '~' : write(o, next-arg())
                '@' : write-all(o, next-seq())
                '%' : print(o, c)
                else : fatal("Invalid argument specifier %~ in format string %~." % [modifier, format])
              loop(i + 2)
            else :
              fatal("Incomplete argument specifier %% at end of format string %~." % [format])
          else :
            print(o, c)
            loop(i + 1)
        else :
          if not empty?(seq) :
            fatal("Unexpected end of format string %~. More arguments remaining." % [format])
      loop(0)

;============================================================
;=================== Indented Streams =======================
;============================================================

public deftype IndentedStream <: OutputStream
public defmulti stream (s:IndentedStream) -> OutputStream
public defmulti indent (s:IndentedStream) -> Int

public defn IndentedStream (o:OutputStream) :
  IndentedStream(o, 2)

public defn IndentedStream (o:OutputStream, n:Int) :
  IndentedStream(o, 2, true)

public defn IndentedStream (o:OutputStream, n:Int, initial-start-of-line?:True|False) :
  var start-of-line? = initial-start-of-line?
  val spaces = String(n, ' ')
  defn put (c:Char) :
    if c == '\n' :
      print(o, c)
      start-of-line? = true
    else :
      print(o, spaces) when start-of-line?
      print(o, c)
      start-of-line? = false
  new IndentedStream :
    defmethod stream (this) : o
    defmethod indent (this) : n
    defmethod print (this, c:Char) : put(c)

public deftype Indented
public defmulti item (x:Indented) -> ?
public defmulti indent (x:Indented) -> Int

public defn Indented (item, indent:Int) -> Indented :
  fatal("Indent (%_) is not positive." % [indent]) when indent <= 0
  match(item:Indented) :
    Indented(/item(item), /indent(item) + indent)
  else :
    new Indented :
      defmethod item (this) : item
      defmethod indent (this) : indent

public defn Indented (item) :
  Indented(item, 2)

defmethod print (o:OutputStream, x:Indented) :
  print(IndentedStream(o, indent(x)), item(x))

public defn do-indented<?T> (f: IndentedStream -> ?T, o:OutputStream) :
   f(IndentedStream(o))

public defn indented<?T> (f: () -> ?T) -> T :
  val stream = current-output-stream()
  var result:T
  val obj = new Printable :
    defmethod print (o:OutputStream, this) :
      result = with-output-stream(o, f)
      false
  print(stream, Indented(obj))
  result

;============================================================
;===================== Generators ===========================
;============================================================

public defn Generator<T> (thunk : (T -> False, (T -> Void) & (() -> Void)) -> ?) -> Seq<T> :
   ;State
   var item = sentinel

   ;Generator Coroutine
   val co = Coroutine<False, T|Sentinel> $ fn (co, x0) :
      defn co-yield (x:T) :
         suspend(co, x)
      val co-break = multifn :
         (x:T) : break(co, x)
         () : break(co, sentinel)
      thunk(co-yield, co-break)
      sentinel

   ;Fill state: Returns whether empty
   defn fill () :
      if (item is Sentinel) and open?(co) :
         item = resume(co, false)
      item is Sentinel

   ;Peek
   defn peek () :
      if item is Sentinel :
         fatal("Empty Sequence")
      item as T

   ;Empty bucket
   defn empty () :
      val x = peek()
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         peek()
      defmethod empty? (this) :
         fill()
      defmethod free (this) :
         close(co) when open?(co)

;============================================================
;====================== Labels ==============================
;============================================================

public defn* LabeledScope<T> (thunk: (T -> Void) -> T) -> T :
   val c = Coroutine<False,T> $ fn* (c, x0) :
      thunk(break{c, _})
   resume(c, false)

public defn* LabeledScope* (thunk: (() -> Void) -> ?) -> False :
   val c = Coroutine<False,False> $ fn* (c, x0) :
      thunk(fn () : break(c, false))
      false
   resume(c, false)

;============================================================
;================== Failure Handler =========================
;============================================================

var CURRENT-FAILURE-HANDLER : () -> Void =
   fn () :
      fatal("Uncaught failure")

public defn fail () :
   CURRENT-FAILURE-HANDLER()

public defn with-attempt<?T> (conseq: () -> ?T, alt: () -> ?T) :
   val result = label<Maybe<T>> return :
      let-var CURRENT-FAILURE-HANDLER = fn* () : return(None()) :
         One(conseq())
   match(result) :
      (r:One<T>) : value(r)
      (r:None) : alt()

;============================================================
;=================== IndexedCollections =====================
;============================================================

public deftype IndexedCollection<T> <: Lengthable

;                       Interface
;                       =========

public defmulti get<?T> (a:IndexedCollection<?T>, i:Int) -> T
public defmulti set<?T> (a:IndexedCollection<?T>, i:Int, v:T) -> False
public defmulti get<?T> (a:IndexedCollection<?T>, r:Range) -> Collection<T>
public defmulti set<?T> (a:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False
public defmulti set-all<?T> (a:IndexedCollection<?T>, r:Range, v:T) -> False
public defmulti map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False

;                 Abstract Implementations
;                 ========================

public defn empty? (v:IndexedCollection) :
   length(v) == 0

defmethod print (o:OutputStream, a:IndexedCollection) -> False :
   print(o, "[%@]" % [a])

defmethod map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False :
   for i in 0 to length(xs) do :
      xs[i] = f(xs[i])

defmethod get<?T> (xs:IndexedCollection<?T>, r:Range) -> Tuple<T> :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])

defmethod set<?T> (xs:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   val vs-seq = to-seq(vs)
   for i in b to e do : xs[i] = next(vs-seq)

defmethod set-all<?T> (xs:IndexedCollection<?T>, r:Range, v:T) -> False :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   for i in b to e do : xs[i] = v

public defn reverse!<?T> (xs:IndexedCollection<?T>) -> False :
   val n = length(xs)
   for i in 0 to n / 2 do :
      val j = n - 1 - i
      val xi = xs[i]
      val xj = xs[j]
      xs[i] = xj
      xs[j] = xi

;                       Sorting
;                       =======

public defn qsort!<?T> (xs:IndexedCollection<?T>, is-less?:(T,T) -> True|False) -> False :
   ;Random
   val rand = Random(0L)

   ;Swap element i with element j
   defn swap (i:Int, j:Int) :
      if i != j :
         val xi = xs[i]
         val xj = xs[j]
         xs[i] = xj
         xs[j] = xi

   ;Rearrange elements from b to e, such that the first elements is less than pivot.
   ;Returns a s.t. all elements from b to a are less than pivot.
   defn partition (b:Int, e:Int, pivot:T) :
      defn* loop (a:Int, b:Int) -> Int :
         if b < e :
            val xb = xs[b]
            if is-less?(xb, pivot) :
               swap(a, b)
               loop(a + 1, b + 1)
            else : loop(a, b + 1)
         else : a
      loop(b, b)

   ;Driver
   defn* sort (b:Int, e:Int) :
      val n = e - b
      if n > 2 :
         swap(next-int(rand,b to e), e - 1) when n > 10
         val e1 = partition(b, e - 1, xs[e - 1])
         swap(e1, e - 1)
         sort(b, e1)
         sort(e1 + 1, e)
      else if n == 2 :
         swap(b, b + 1) when is-less?(xs[b + 1], xs[b])

   sort(0, length(xs))

public defn qsort!<?T> (xs:IndexedCollection<?T>, cmp:(T,T) -> Int) -> False :
   ;Random
   val rand = Random(0L)

   ;Swap element i with element j
   defn swap (i:Int, j:Int) :
      if i != j :
         val xi = xs[i]
         val xj = xs[j]
         xs[i] = xj
         xs[j] = xi

   ;Rearrange elements from b to e, such that:
   ;   b to lt is less than v
   ;   lt to gt is equal to v
   ;   gt to e is greater than v
   ;Returns [lt, gt]
   defn partition (b:Int, e:Int, pivot:T) -> [Int, Int] :
      defn* loop (lt:Int, gt:Int, i:Int) :
         if i < gt :
            val c = cmp(xs[i], pivot)
            if c < 0 :
               swap(i, lt)
               loop(lt + 1, gt, i + 1)
            else if c > 0 :
               swap(i, gt - 1)
               loop(lt, gt - 1, i)
            else :
               loop(lt, gt, i + 1)
         else :
            [lt, gt]
      loop(b, e, b)

   ;Driver
   defn* sort (b:Int, e:Int) :
      val n = e - b
      if n > 2 :
         val [lt, gt] = partition(b, e, xs[next-int(rand, b to e)])
         sort(b, lt)
         sort(gt, e)
      else if n == 2 :
         swap(b, b + 1) when cmp(xs[b + 1], xs[b]) < 0

   sort(0, length(xs))

public defn qsort!<?T> (xs:IndexedCollection<?T&Comparable<T>>) -> False :
   qsort!(xs, compare)

public defn qsort!<?T,?S> (key:T -> ?S&Comparable<S>, xs:IndexedCollection<?T>) -> False :
   qsort!(xs, compare{key(_), key(_)})

;                        Non-Destructive Sorting
;                        =======================

public defn qsort<?T> (coll:Seqable<?T>, is-less?:(T,T) -> True|False) -> Tuple<T> :
  val buffer = to-vector<T>(coll)
  qsort!(buffer, is-less?)
  to-tuple(buffer)

public defn qsort<?T> (coll:Seqable<?T>, cmp:(T,T) -> Int) -> Tuple<T> :
  val buffer = to-vector<T>(coll)
  qsort!(buffer, cmp)
  to-tuple(buffer)

public defn qsort<?T> (coll:Seqable<?T&Comparable<T>>) -> Tuple<T> :
  val buffer = to-vector<Comparable>(coll)
  qsort!(buffer)
  to-tuple(buffer) as Tuple<T&Comparable>

public defn qsort<?T,?S> (key:T -> ?S&Comparable<S>, coll:Seqable<?T>) -> Tuple<T> :
  val buffer = to-vector<T>(coll)
  qsort!({key(_) as Comparable}, buffer)
  to-tuple(buffer)

;                       Lazy Sorting
;                       ============

public defn lazy-qsort<?T> (coll:Seqable<?T>, is-less?:(T,T) -> True|False) -> Collection<T> & Lengthable :
   ;Random
   val rand = Random(0L)

   ;Convert to a vector
   val xs = to-vector<T>(coll)

   ;Sort Progress
   defn sort-progress () :
      generate<Int> :
         ;Swap element i with element j
         defn swap (i:Int, j:Int) :
            if i != j :
               val xi = xs[i]
               val xj = xs[j]
               xs[i] = xj
               xs[j] = xi

         ;Rearrange elements from b to e, such that the first elements is less than pivot.
         ;Returns a s.t. all elements from b to a are less than pivot.
         defn partition (b:Int, e:Int, pivot:T) :
            defn* loop (a:Int, b:Int) -> Int :
               if b < e :
                  val xb = xs[b]
                  if is-less?(xb, pivot) :
                     swap(a, b)
                     loop(a + 1, b + 1)
                  else : loop(a, b + 1)
               else : a
            loop(b, b)

         ;Driver
         defn* sort (b:Int, e:Int) :
            val n = e - b
            if n > 2 :
               swap(next-int(rand, b to e), e - 1) when n > 10
               val e1 = partition(b, e - 1, xs[e - 1])
               swap(e1, e - 1)
               sort(b, e1)
               yield(e1 + 1)
               sort(e1 + 1, e)
            else if n == 2 :
               swap(b, b + 1) when is-less?(xs[b + 1], xs[b])

         sort(0, length(xs))
         break(length(xs))

   ;Ensuring Progress
   var sorted = 0
   val sorter = sort-progress()
   defn* ensure-sorted (n:Int) :
      if sorted < n :
         sorted = next(sorter)
         ensure-sorted(n)

   ;Return object
   new Collection<T> & Lengthable :
      defmethod length (this) :
         length(xs)
      defmethod to-seq (this) :
         for i in 0 to length(xs) seq :
            ensure-sorted(i + 1)
            xs[i]


public defn lazy-qsort<?T> (coll:Seqable<?T>, cmp:(T,T) -> Int) -> Collection<T> & Lengthable :
   ;Random
   val rand = Random(0L)

   ;Convert to a vector
   val xs = to-vector<T>(coll)

   ;Sort Progress
   defn sort-progress () :
      generate<Int> :
         ;Swap element i with element j
         defn swap (i:Int, j:Int) :
            if i != j :
               val xi = xs[i]
               val xj = xs[j]
               xs[i] = xj
               xs[j] = xi

         ;Rearrange elements from b to e, such that:
         ;   b to lt is less than v
         ;   lt to gt is equal to v
         ;   gt to e is greater than v
         ;Returns [lt, gt]
         defn partition (b:Int, e:Int, pivot:T) -> [Int, Int] :
            defn* loop (lt:Int, gt:Int, i:Int) :
               if i < gt :
                  val c = cmp(xs[i], pivot)
                  if c < 0 :
                     swap(i, lt)
                     loop(lt + 1, gt, i + 1)
                  else if c > 0 :
                     swap(i, gt - 1)
                     loop(lt, gt - 1, i)
                  else :
                     loop(lt, gt, i + 1)
               else :
                  [lt, gt]
            loop(b, e, b)

         ;Driver
         defn* sort (b:Int, e:Int) :
            val n = e - b
            if n > 2 :
               val [lt, gt] = partition(b, e, xs[next-int(rand,b to e)])
               sort(b, lt)
               yield(gt)
               sort(gt, e)
            else if n == 2 :
               swap(b, b + 1) when cmp(xs[b + 1], xs[b]) < 0

         sort(0, length(xs))
         break(length(xs))

   ;Ensuring Progress
   var sorted = 0
   val sorter = sort-progress()
   defn* ensure-sorted (n:Int) :
      if sorted < n :
         sorted = next(sorter)
         ensure-sorted(n)

   ;Return object
   new Collection<T> & Lengthable :
      defmethod length (this) :
         length(xs)
      defmethod to-seq (this) :
         for i in 0 to length(xs) seq :
            ensure-sorted(i + 1)
            xs[i]

public defn lazy-qsort<?T> (coll:Seqable<?T&Comparable<T>>) :
   lazy-qsort(coll, compare)

public defn lazy-qsort<?T,?S> (key:T -> ?S&Comparable<S>, coll:Seqable<?T>) :
   lazy-qsort(coll, compare{key(_), key(_)})

;============================================================
;======================= Arrays =============================
;============================================================

public deftype Array<T> <: IndexedCollection<T> & Unique

;                     Implementation
;                     ==============

lostanza deftype RawArray<T> <: Array<T> :
   length: long
   var items: ref<?> ...

lostanza defn RawArray<T> (n:ref<Int>, x:ref<?>) -> ref<RawArray<T>> :
   val l = n.value
   val a = new RawArray<T>{l}
   for (var i:long = 0, i < l, i = i + 1) :
      a.items[i] = x
   return a

lostanza defmethod get<?T> (a:ref<RawArray<?T>>, i:ref<Int>) -> ref<T> :
  return a.items[i.value]

lostanza defmethod set<?T> (a:ref<RawArray<?T>>, i:ref<Int>, v:ref<?T>) -> ref<False> :
  a.items[i.value] = v
  return false

lostanza defmethod set-all<?T> (xs:ref<RawArray<?T>>, r:ref<Range>, v:ref<?T>) -> ref<False> :
   val range = range-bound(xs, r) as ref<Tuple<Int>>
   val b = range.items[0].value
   val e = range.items[1].value
   for (var i:long = b, i < e, i = i + 1) :
      xs.items[i] = v
   return false

lostanza defmethod length (a:ref<RawArray>) -> ref<Int> :
   return new Int{a.length as int}

defmethod print (o:OutputStream, a:RawArray) -> False :
   print(o, "[%@]" % [a])

;                     Wrapping
;                     ========

#if-defined(OPTIMIZE) :

   public defn Array<T> (n:Int) -> RawArray<T> :
      RawArray<T>(n, sentinel)

   public defn Array<T> (n:Int, x:T) -> RawArray<T> :
      RawArray<T>(n, x)

#else :

   deftype WrappedArray<T> <: Array<T>

   public defn Array<T> (n:Int) -> Array<T> :
      ensure-non-negative("length", n)
      Array<T>(RawArray<T>(n, sentinel))

   public defn Array<T> (n:Int, x:T) -> Array<T> :
      ensure-non-negative("length", n)
      Array<T>(RawArray<T>(n, x))

   defn Array<T> (a:RawArray) -> Array<T> :
      new WrappedArray<T> :
         defmethod get (this, i:Int) :
            ensure-index-in-bounds(a, i)
            match(a[i]) :
               (v:Sentinel) : fatal("Index (%_) is uninitialized." % [i])
               (v) : v
         defmethod set (this, i:Int, v:T) :
            ensure-index-in-bounds(a, i)
            a[i] = v
         defmethod set-all (this, r:Range, v:T) :
            ensure-index-range(a, r)
            set-all(a, r, v)
         defmethod length (this) :
            length(a)
         defmethod print (o:OutputStream, this) :
            print(o, a)

public defn map<R,?T> (f: T -> R, xs:Array<?T>) -> Array<R> :
   val ret = Array<R>(length(xs))
   for (x in xs, i in 0 to false) do :
      ret[i] = f(x)
   ret

;============================================================
;==================== Primitive Arrays ======================
;============================================================

#for (Prim in [Byte Int Long Float Double]
      prim in [byte int long float double]
      PrimArray in [ByteArray IntArray LongArray FloatArray DoubleArray]
      to-PrimArray in [to-bytearray, to-intarray, to-longarray, to-floatarray, to-doublearray]
      x0 in [0Y 0 0L 0.0F 0.0]) :

  ;                     Declaration
  ;                     ===========
  public lostanza deftype PrimArray <: Array<Prim> :
    length: long
    var data: prim ...

  ;                     Implementation
  ;                     ==============
  public lostanza defn PrimArray (n:ref<Int>, x:ref<Prim>) -> ref<PrimArray> :
    ensure-non-negative-length(n)
    val l = n.value
    val a = new PrimArray{l}
    val xv = x.value
    for (var i:long = 0, i < l, i = i + 1) :
      a.data[i] = xv
    return a

  public defn PrimArray (n:Int) -> PrimArray :
    PrimArray(n, x0)

  lostanza defmethod get (a:ref<PrimArray>, i:ref<Int>) -> ref<Prim> :
    ensure-index-in-bounds(a, i)
    return new Prim{a.data[i.value]}

  lostanza defmethod set (a:ref<PrimArray>, i:ref<Int>, x:ref<Prim>) -> ref<False> :
    ensure-index-in-bounds(a, i)
    a.data[i.value] = x.value
    return false

  lostanza defmethod length (a:ref<PrimArray>) -> ref<Int> :
    return new Int{a.length as int}

  lostanza defmethod get (a:ref<PrimArray>, r:ref<Range>) -> ref<PrimArray> :
    ensure-index-range(a, r)
    val rb = range-bound(a, r)
    val b = get(rb, new Int{0}).value
    val e = get(rb, new Int{1}).value
    val len = e - b
    val ret = new PrimArray{len}
    for (var i:long = 0, i < len, i = i + 1) :
      ret.data[i] = a.data[i + b]
    return ret

  lostanza defmethod set (a:ref<PrimArray>, r:ref<Range>, xs:ref<PrimArray>) -> ref<False> :
    ensure-index-range(a, r)
    val rb = range-bound(a, r)
    val b = get(rb, new Int{0}).value
    val e = get(rb, new Int{1}).value
    val len = e - b
    #if-not-defined(OPTIMIZE) :
      ensure-len-le-xs(new Int{len}, xs)
    for (var i:long = 0, i < len, i = i + 1) :
      a.data[i + b] = xs.data[i]
    return false
  defn ensure-len-le-xs (len:Int, xs:PrimArray) :
    if len > length(xs) :
      fatal("Length of range (%_) is greater than length of values array (%_)." % [
        len, length(xs)])

  public defn to-PrimArray (xs:Seqable<Prim>) -> PrimArray :
    match(xs) :
      (xs:Vector<Prim>|Tuple<Prim>|Array<Prim>) :
        val n = length(xs)
        val a = PrimArray(n)
        for i in 0 to n do :
          a[i] = xs[i]
        a
      (xs) :
        to-PrimArray(to-vector<Prim>(xs))

;============================================================
;==================== CharArrays ============================
;============================================================

public lostanza deftype CharArray <: Array<Char> :
  length: long
  var chars: byte ...

;                     Implementation
;                     ==============

public lostanza defn CharArray (n:ref<Int>, x:ref<Char>) -> ref<CharArray> :
   ensure-non-negative-length(n)
   val l = n.value
   val a = new CharArray{l}
   val c = x.value
   for (var i:long = 0, i < l, i = i + 1) :
      a.chars[i] = c
   return a

public defn CharArray (n:Int) -> CharArray :
   CharArray(n, ' ')

lostanza defmethod get (a:ref<CharArray>, i:ref<Int>) -> ref<Char> :
  ensure-index-in-bounds(a, i)
  return new Char{a.chars[i.value]}

lostanza defmethod set (a:ref<CharArray>, i:ref<Int>, v:ref<Char>) -> ref<False> :
  ensure-index-in-bounds(a, i)
  a.chars[i.value] = v.value
  return false

lostanza defmethod length (a:ref<CharArray>) -> ref<Int> :
   return new Int{a.length as int}

lostanza defn substring! (a:ref<CharArray>, b:ref<Int>, e:ref<Int>) -> ref<String> :
   val len = e.value - b.value
   val start = b.value
   val s = String(len)
   for (var i:long = 0, i < len, i = i + 1) :
      s.chars[i] = a.chars[i + start]
   s.chars[len] = 0 as byte
   return s

defmethod get (a:CharArray, r:Range) -> String :
   ensure-index-range(a, r)
   val [b, e] = range-bound(a, r)
   substring!(a, b, e)

;                     Looping
;                     =======

defmethod do (f: Char -> ?, xs:CharArray) :
   val n = length(xs)
   let loop (i:Int = 0) :
      if i < n :
         f(xs[i])
         loop(i + 1)

;============================================================
;==================== Block Copying =========================
;============================================================

public defmulti block-copy<?T> (n:Int, dst:IndexedCollection<?T>, di:Int, src:IndexedCollection<T>, si:Int) -> False

defmethod block-copy<?T> (n:Int, dst:IndexedCollection<?T>, di:Int, src:IndexedCollection<T>, si:Int) :
  ensure-block-copy-preconditions(n, dst, di, src, si)
   for i in 0 to n do :
      dst[di + i] = src[si + i]

lostanza defmethod block-copy (ref-n:ref<Int>, dst:ref<RawArray>, ref-di:ref<Int>, src:ref<RawArray>, ref-si:ref<Int>) -> ref<False> :
  ensure-block-copy-preconditions(ref-n, dst, ref-di, src, ref-si)
  val dst-ptr = addr!(dst.items)
  val src-ptr = addr!(src.items)
  val di = ref-di.value
  val si = ref-si.value
  val n = ref-n.value
  refcpy(addr!(dst-ptr[di]), addr!(src-ptr[si]), n)
  return false

defmethod block-copy (n:Int, dst:ByteBuffer, di:Int, src:ByteBuffer, si:Int) :
  ensure-block-copy-preconditions(n, dst, di, src, si)
  block-copy(n, backing-array(dst), di, backing-array(src), si)

#for (PrimArray in [ByteArray IntArray LongArray FloatArray DoubleArray]
      prim in [byte int long float double]) :
  lostanza defmethod block-copy (ref-n:ref<Int>, dst:ref<PrimArray>, ref-di:ref<Int>, src:ref<PrimArray>, ref-si:ref<Int>) -> ref<False> :
    ensure-block-copy-preconditions(ref-n, dst, ref-di, src, ref-si)
    val dst-ptr = addr!(dst.data)
    val src-ptr = addr!(src.data)
    val di = ref-di.value
    val si = ref-si.value
    val n = ref-n.value
    call-c clib/memcpy(addr!(dst-ptr[di]), addr!(src-ptr[si]), n * sizeof(prim))
    return false

defn ensure-block-copy-preconditions (n:Int, dst:IndexedCollection, di:Int, src:IndexedCollection, si:Int) :
  #if-not-defined(OPTIMIZE) :
    ensure-non-negative("number of elements", n)
    ensure-non-negative("destination index", di)
    ensure-non-negative("source index", si)
    if length(dst) < di + n : fatal("Attempt to write past bounds of destination collection.")
    if length(src) < si + n : fatal("Attempt to read past bounds of source collection.")
  false

;============================================================
;==================== Conversions ===========================
;============================================================

;                 Numeric Conversions
;                 ===================

public lostanza defn to-byte (b:ref<Byte>) -> ref<Byte> : return b
public lostanza defn to-byte (c:ref<Char>) -> ref<Byte> : return new Byte{c.value}
public lostanza defn to-byte (i:ref<Int>) -> ref<Byte> : return new Byte{i.value as byte}
public lostanza defn to-byte (l:ref<Long>) -> ref<Byte> : return new Byte{l.value as byte}
public lostanza defn to-byte (f:ref<Float>) -> ref<Byte> : return new Byte{f.value as byte}
public lostanza defn to-byte (d:ref<Double>) -> ref<Byte> : return new Byte{d.value as byte}
public lostanza defn to-char (b:ref<Byte>) -> ref<Char> : return new Char{b.value}
public lostanza defn to-char (c:ref<Char>) -> ref<Char> : return c
public lostanza defn to-char (i:ref<Int>) -> ref<Char> : return new Char{i.value as byte}
public lostanza defn to-int (b:ref<Byte>) -> ref<Int> : return new Int{b.value}
public lostanza defn to-int (c:ref<Char>) -> ref<Int> : return new Int{c.value}
public lostanza defn to-int (i:ref<Int>) -> ref<Int> : return i
public lostanza defn to-int (l:ref<Long>) -> ref<Int> : return new Int{l.value as int}
public lostanza defn to-int (f:ref<Float>) -> ref<Int> : return new Int{f.value as int}
public lostanza defn to-int (d:ref<Double>) -> ref<Int> : return new Int{d.value as int}
public lostanza defn to-long (b:ref<Byte>) -> ref<Long> : return new Long{b.value}
public lostanza defn to-long (i:ref<Int>) -> ref<Long> : return new Long{i.value}
public lostanza defn to-long (l:ref<Long>) -> ref<Long> : return l
public lostanza defn to-long (f:ref<Float>) -> ref<Long> : return new Long{f.value as long}
public lostanza defn to-long (d:ref<Double>) -> ref<Long> : return new Long{d.value as long}
public lostanza defn to-float (b:ref<Byte>) -> ref<Float> : return new Float{b.value as float}
public lostanza defn to-float (i:ref<Int>) -> ref<Float> : return new Float{i.value as float}
public lostanza defn to-float (l:ref<Long>) -> ref<Float> : return new Float{l.value as float}
public lostanza defn to-float (f:ref<Float>) -> ref<Float> : return f
public lostanza defn to-float (d:ref<Double>) -> ref<Float> : return new Float{d.value as float}
public lostanza defn to-double (b:ref<Byte>) -> ref<Double> : return new Double{b.value as double}
public lostanza defn to-double (i:ref<Int>) -> ref<Double> : return new Double{i.value as double}
public lostanza defn to-double (l:ref<Long>) -> ref<Double> : return new Double{l.value as double}
public lostanza defn to-double (f:ref<Float>) -> ref<Double> : return new Double{f.value}
public lostanza defn to-double (d:ref<Double>) -> ref<Double> : return d

;                Numeric Reinterpretations
;                =========================

public lostanza defn bits (f:ref<Float>) -> ref<Int> :
  val v = f.value
  return new Int{($ls-prim bits v)}

public lostanza defn bits (d:ref<Double>) -> ref<Long> :
  val v = d.value
  return new Long{($ls-prim bits v)}

public lostanza defn bits-as-float (i:ref<Int>) -> ref<Float> :
  val v = i.value
  return new Float{($ls-prim fnum v)}

public lostanza defn bits-as-double (i:ref<Long>) -> ref<Double> :
  val v = i.value
  return new Double{($ls-prim fnum v)}

;============================================================
;==================== Number Parsing ========================
;============================================================

;                     Error Checking
;                     ==============

#for (to-value! in [to-byte! to-int! to-long! to-float! to-double!]
      to-value in [to-byte to-int to-long to-float to-double]
      Value in [Byte Int Long Float Double]
      name in ["byte" "int" "long" "float" "double"]) :
  public defn to-value! (s:String) -> Value :
    #if-defined(OPTIMIZE) :
      to-value(s) as Value
    #else :
      match(to-value(s)) :
        (v:Value) : v
        (v:False) : fatal("String %~ cannot be converted to a %_." % [s, name])

;                        Drivers
;                        =======

public defn to-byte (s:String) -> False|Byte :
  match(to-int(s)) :
    (i:Int) : to-byte(i) when i >= 0 and i <= 255
    (i:False) : false

public lostanza defn to-int (s:ref<String>) -> ref<False|Int> :
  if prefix?(s, "-") :
    return neg-to-int(s, 1, 10)
  else if prefix?(s, "0x") :
    return bits-to-int(s, 2, 16, 4)
  else if prefix?(s, "0o") :
    return bits-to-int(s, 2, 8, 3)
  else if prefix?(s, "0b") :
    return bits-to-int(s, 2, 2, 1)
  else :
    return pos-to-int(s, 0, 10)

public lostanza defn to-long (s:ref<String>) -> ref<False|Long> :
  if prefix?(s, "-") :
    return neg-to-long(s, 1, 10)
  else if prefix?(s, "0x") :
    return bits-to-long(s, 2, 16, 4)
  else if prefix?(s, "0o") :
    return bits-to-long(s, 2, 8, 3)
  else if prefix?(s, "0b") :
    return bits-to-long(s, 2, 2, 1)
  else :
    return pos-to-long(s, 0, 10)

;TODO: This is necessary because addresses of local variables don't work yet.
lostanza var DOUBLE-BUFFER : double
lostanza var CHAR-BUFFER : byte
public lostanza defn to-double (s:ref<String>) -> ref<False|Double> :
  val n = call-c clib/sscanf(addr!(s.chars), "%lf%c", addr(DOUBLE-BUFFER), addr(CHAR-BUFFER))
  if n != 1 : return false
  else : return new Double{DOUBLE-BUFFER}

lostanza var FLOAT-BUFFER : float
public lostanza defn to-float (s:ref<String>) -> ref<False|Float> :
  val n = call-c clib/sscanf(addr!(s.chars), "%f%c", addr(FLOAT-BUFFER), addr(CHAR-BUFFER))
  if n != 1 : return false
  else : return new Float{FLOAT-BUFFER}

;                        Utilities
;                        =========

lostanza defn prefix? (str:ref<String>, prefix:ptr<byte>) -> int :
  for (var i:long = 0, 1, i = i + 1) :
    if prefix[i] == 0 : return 1
    else if str.chars[i] == 0 : return 0
    else if prefix[i] != str.chars[i] : return 0
  return 0

lostanza defn digit (c:byte, radix:int) -> int :
  var d:int
  if c >= '0' and c <= '9' : d = c - '0'
  else if c >= 'a' and c <= 'f' : d = c - 'a' + 10
  else if c >= 'A' and c <= 'F' : d = c - 'A' + 10
  else : return -1
  if d < radix : return d
  else : return -1

;                        Parsing Integers
;                        ================

lostanza defn pos-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
  if empty?(s) == true :
    return false
  var n:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix + d
        if n < 0 : return false
  fatal("Unreachable")
  return false

lostanza defn neg-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
  if empty?(s) == true :
    return false
  var n:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix - d
        if n > 0 : return false
  fatal("Unreachable")
  return false

lostanza defn bits-to-int (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Int> :
  if empty?(s) == true :
    return false
  var n:int = 0
  var nbits:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = (n << bits) | d
        nbits = nbits + bits
        if nbits >= 32 + bits : return false
  fatal("Unreachable")
  return false

;                        Parsing Longs
;                        =============

lostanza defn pos-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
  if empty?(s) == true :
    return false
  var n:long = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix + d
        if n < 0 : return false
  fatal("Unreachable")
  return false

lostanza defn neg-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
  if empty?(s) == true :
    return false
  var n:long = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix - d
        if n > 0 : return false
  fatal("Unreachable")
  return false

lostanza defn bits-to-long (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Long> :
  if empty?(s) == true :
    return false
  var n:long = 0
  var nbits:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = (n << bits) | d
        nbits = nbits + bits
        if nbits >= 64 + bits : return false
  fatal("Unreachable")
  return false

;============================================================
;======================= Limits =============================
;============================================================

public val BYTE-MAX = 255Y
public val BYTE-MIN = 0Y
public lostanza val INT-MAX:ref<Int> = new Int{(1 << 31) - 1}
public lostanza val INT-MIN:ref<Int> = new Int{1 << 31}
public lostanza val LONG-MAX:ref<Long> = new Long{(1L << 63L) - 1L}
public lostanza val LONG-MIN:ref<Long> = new Long{1L << 63L}

public val FLOAT-MAX = bits-as-float(0x7F7FFFFF)
public val FLOAT-MIN-NORMAL = bits-as-float(0x00800000)
public val FLOAT-MIN = bits-as-float(0x1)
public val FLOAT-NAN = bits-as-float(0x7FC00000)
public val FLOAT-POSITIVE-INFINITY = bits-as-float(0x7F800000)
public val FLOAT-NEGATIVE-INFINITY = bits-as-float(0xFF800000)

public val DOUBLE-MAX = bits-as-double(0x7fefffffffffffffL)
public val DOUBLE-MIN-NORMAL = bits-as-double(0x0010000000000000L)
public val DOUBLE-MIN = bits-as-double(0x1L)
public val DOUBLE-NAN = bits-as-double(0x7ff8000000000000L)
public val DOUBLE-POSITIVE-INFINITY = bits-as-double(0x7ff0000000000000L)
public val DOUBLE-NEGATIVE-INFINITY = bits-as-double(0xfff0000000000000L)

;============================================================
;==================== Arithmetic ============================
;============================================================

public defn max<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T :
  b when a < b else a

public defn min<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T :
  a when a < b else b

public defn minimum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, xs} $ fn (x, y) :
    if x < y : x
    else : y

public defn minimum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, x0, xs} $ fn (x, y) :
    if x < y : x
    else : y

public defn maximum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, xs} $ fn (x, y) :
    if x < y : y
    else : x

public defn maximum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, x0, xs} $ fn (x, y) :
    if x < y : y
    else : x

public defn minimum<?T> (xs:Seqable<?T&Comparable>) -> T : minimum(xs, less?)
public defn maximum<?T> (xs:Seqable<?T&Comparable>) -> T : maximum(xs, less?)

public defn minimum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : minimum(x0, xs, less?)
public defn maximum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : maximum(x0, xs, less?)

public defn minimum<?T> (key: T -> Comparable, input-xs:Seqable<?T>) -> T :
  val xs = to-seq(input-xs)
  var min-x:T = next(xs)
  var min-key:Comparable = key(min-x)
  for x in xs do :
    val k = key(x)
    if k < min-key :
      min-x = x
      min-key = k
  min-x

public defn maximum<?T> (key: T -> Comparable, input-xs:Seqable<?T>) -> T :
  val xs = to-seq(input-xs)
  var max-x:T = next(xs)
  var max-key:Comparable = key(max-x)
  for x in xs do :
    val k = key(x)
    if k > max-key :
      max-x = x
      max-key = k
  max-x

public defn ceil-log2 (i:Int) -> Int :
  defn* loop (n:Int, l:Int) :
    if i > n :
      if l == 30 : l + 1
      else : loop(n << 1, l + 1)
    else : l
  fatal("Log of non-positive number!") when i <= 0
  loop(1, 0)

public defn floor-log2 (i:Int) -> Int :
  defn* loop (n:Int, l:Int) :
    if i == n : l
    else if i < n : l - 1
    else if l == 30 : l
    else : loop(n << 1, l + 1)
  fatal("Log of non-positive number!") when i <= 0
  loop(1, 0)

public defn ceil-log2 (i:Long) -> Int :
  defn* loop (n:Long, l:Int) :
    if i > n :
      if l == 62 : l + 1
      else : loop(n << to-long(1), l + 1)
    else : l
  fatal("Log of non-positive number!") when i <= to-long(0)
  loop(to-long(1), 0)

public defn floor-log2 (i:Long) -> Int :
  defn* loop (n:Long, l:Int) :
    if n == i : l
    else if i < n : l - 1
    else if l == 62 : l
    else : loop(n << to-long(1), l + 1)
  fatal("Log of non-positive number!") when i <= to-long(0)
  loop(to-long(1), 0)

public defn next-pow2 (i:Int) -> Int :
  ensure-non-negative("value", i)
  if i == 0 :
    i
  else :
    val n = ceil-log2(i)
    if n <= 30 : 1 << n
    else : fatal("Overflow")

public defn prev-pow2 (i:Int) -> Int :
  ensure-non-negative("value", i)
  if i == 0 :
    i
  else :
    1 << floor-log2(i)

public defn next-pow2 (i:Long) -> Long :
  val n = ceil-log2(i)
  if n <= 62 : to-long(1) << to-long(n)
  else : fatal("Overflow")

public defn prev-pow2 (i:Long) -> Long :
  to-long(1) << to-long(floor-log2(i))

public defn sum (xs: Seqable<Int>) -> Int : reduce(plus, 0, xs)
public defn sum (xs: Seqable<Long>) -> Long : reduce(plus, 0L, xs)
public defn sum (xs: Seqable<Float>) -> Float : reduce(plus, 0.0f, xs)
public defn sum (xs: Seqable<Double>) -> Double : reduce(plus, 0.0, xs)

public defn product (xs: Seqable<Int>) -> Int : reduce(times, 1, xs)
public defn product (xs: Seqable<Long>) -> Long : reduce(times, 1L, xs)
public defn product (xs: Seqable<Float>) -> Float : reduce(times, 1.0f, xs)
public defn product (xs: Seqable<Double>) -> Double : reduce(times, 1.0, xs)

;============================================================
;====================== Maybe ===============================
;============================================================

public deftype Maybe<T> <: Equalable & Comparable<Maybe<T>> & Hashable
public deftype None <: Maybe<Void>
public deftype One<T> <: Maybe<T>

;                      Interface
;                      =========

public defmulti value<?T> (x:One<?T>) -> T

;                     Constructors
;                     ============

public defn None () :
   new None

public defn One<?T> (x:?T) :
   new One<T> :
      defmethod value (this) : x

;                     Printers
;                     ========

defmethod print (o:OutputStream, x:None) :
   print(o, "None")
defmethod print (o:OutputStream, x:One) :
   print(o, "One(%~)" % [value(x)])

;                   Implementation
;                   ==============

public defn value!<?T> (x:Maybe<?T>) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : fatal("Object of type None has no value.")

public defn value?<?T> (x:Maybe<?T>, default:?T) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : default

public defn value?<?T> (x:Maybe<?T>) -> T|False :
   value?(x, false)

public defn empty? (x:Maybe) :
   x is None

defmethod equal? (a:None, b:None) :
   true

defmethod equal? (a:One, b:One) :
   value(a) == value(b)

defmethod hash (a:None) :
  1817

defmethod hash (a:One) :
  hash(value(a)) * 17

;                   Comparisons
;                   ===========

defmethod* compare<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : 0
      (x:None, y:One<T>) : -1
      (x:One<T>, y:None) : 1
      (x:One<T&Comparable<T>>, y:One<T>) : compare(value(x), value(y))

defmethod less?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) < value(y)

defmethod less-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) <= value(y)

defmethod greater?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) > value(y)

defmethod greater-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) >= value(y)

;============================================================
;====================== Ranges ==============================
;============================================================

public deftype Range <: Equalable

;                      Interface
;                      =========

public defmulti start (r:Range) -> Int
public defmulti end (r:Range) -> Int|False
public defmulti step (r:Range) -> Int
public defmulti inclusive? (r:Range) -> True|False

;                     Constructor
;                     ===========

public defn Range (start:Int, end:Int|False, step:Int, inclusive?:True|False) :
   ;Compute the length of the range
   val length = match(end, inclusive?) :
      (end:Int, inc:False) :
         if step == 0 :
            if start == end : 0
            else : false
         else if step == 1 :
            safe-minus(end, start)
         else if step == -1 :
            safe-minus(start, end)
         else if step > 0 :
            div?(safe-add(safe-minus(end, start), step - 1), step)
         else :
            div?(safe-add(safe-minus(end, start), step + 1), step)
      (end:Int, inc:True) :
         if step == 0 :
            false
         else if step == 1 :
            safe-add(safe-minus(end, start), 1)
         else if step == -1 :
            safe-add(safe-minus(start, end), 1)
         else :
            div?(safe-add(safe-minus(end, start), step), step)
      (end:False, inc) :
         false

   match(length) :
      (length:Int) :
         new Range & Lengthable :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?
            defmethod length (this) : max(length, 0)
      (length:False) :
         new Range :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?

defn safe-add (x:Int, y:Int) :
  val z = x + y
  val sign-x = x >> 31
  val sign-y = y >> 31
  val sign-z = z >> 31
  val c = (sign-x ^ sign-y) | (1 ^ sign-x ^ sign-z)
  z when c == 1

defn safe-minus (x:Int, y:Int) :
  val z = x - y
  val sign-x = x >> 31
  val sign-y = y >> 31
  val sign-z = z >> 31
  val c = (1 ^ sign-x ^ sign-y) | (1 ^ sign-x ^ sign-z)
  z when c == 1

defn safe-add (x:False, y:Int) : false
defn safe-minus (x:False, y:Int) : false
defn div? (x:Int, y:Int) : x / y
defn div? (x:False, y:Int) : false

;                Conversion to Sequence
;                ======================



;             Reverse
;             =======
public defn reverse (r:Range) :
  ;Fields
  val start = start(r)
  val end = end(r)
  val step = step(r)
  val inc = inclusive?(r)

  ;Cases
  defn* empty-range () :
    Range(end as Int, start, (- step), inc)
  defn* reverse-range (last:Int) :
    last through start by (- step)
  defn* infinite-range () :
    start through start by 0
  defn* no-last-element () :
    fatal("Range %_ cannot be reversed." % [r])

  if step == 0 :
    match(start == end, inc) :
      (eq:False, inc) : infinite-range()
      (eq:True, inc:True) : infinite-range()
      (eq:True, inc:False) : empty-range()
  else if end is False :
    no-last-element()
  else :
    val end = end as Int
    match(step > 0, end > start) :
      (r1:True, r2:False) :
        empty-range()
      (r1:False, r2:True) :
        empty-range()
      (r1, r2) :
        val sgn-step = 1 when r1 else -1
        val n = if inc : (end - start + step) / step
                else : (end - start + step - sgn-step) / step
        reverse-range(start + (n - 1) * step)



;             Looping
;             =======

defmethod do (f: Int -> ?, r:Range) :
  match(r) :
    (r:Range&Lengthable) :
      val s = step(r)
      let loop (i:Int = start(r), n:Int = length(r)) :
        if n > 0 :
          f(i)
          loop(i + s, n - 1)
    (r:Range) :
      val s = step(r)
      let loop (i:Int = start(r)) :
        f(i)
        loop(i + s)

;                  Inclusion
;                  =========

defmethod contains? (r:Range, x:Int) :
  val start = start(r)
  val step = step(r)
  match(end(r), inclusive?(r)) :
    (end:Int, inc:False) :
      if step == 0 :
        if start == end : false
        else : start == x
      else if step == 1 :
        x >= start and x < end
      else if step == -1 :
        x <= start and x > end
      else if step > 0 :
        x >= start and x < end and ((x - start) % step == 0)
      else :
        x <= start and x > end and ((x - start) % step == 0)
    (end:Int, inc:True) :
      if step == 0 :
        start == x
      else if step == 1 :
        x >= start and x <= end
      else if step == -1 :
        x <= start and x >= end
      else if step > 0 :
        x >= start and x <= end and ((x - start) % step == 0)
      else :
        x <= start and x >= end and ((x - start) % step == 0)
    (end:False, inc) :
      if step == 0 :
        start == x
      else if step == 1 :
        x >= start
      else if step == -1 :
        x <= start
      else if step > 0 :
        x >= start and ((x - start) % step == 0)
      else :
        x <= start and ((x - start) % step == 0)

;                 Comparison
;                 ==========

defmethod equal? (a:Range, b:Range) :
   start(a) == start(b) and
   end(a) == end(b) and
   step(a) == step(b) and
   inclusive?(a) == inclusive?(b)

;                  Printing
;                  ========

defmethod print (o:OutputStream, x:Range) :
   val op = "through" when inclusive?(x) else "to"
   if step(x) == 1 : print(o, "%_ %_ %_" % [start(x), op, end(x)])
   else : print(o, "%_ %_ %_ by %_" % [start(x), op, end(x), step(x)])

;                  Mapping
;                  =======

public defn map<?R> (f: Int -> ?R, r:Range) -> List<R> :
   fatal("Infinite Range") when r is-not Range&Lengthable
   to-list(seq(f, r))

;============================================================
;================== Optimized Ranges ========================
;============================================================

public deftype SimpleRange <: Range
defmethod step (r:SimpleRange) : 1
defmethod inclusive? (r:SimpleRange) : false

public defn SimpleRange (start:Int, end:Int) -> SimpleRange :
  val len = safe-minus(end, start)
  match(len:Int) :
    new SimpleRange&Lengthable :
      defmethod start (this) : start
      defmethod end (this) : end
      defmethod length (this) : len
  else :
    new SimpleRange :
      defmethod start (this) : start
      defmethod end (this) : end

public defn SimpleRange (start:Int, end:False) -> Range :
  Range(start, end, 1, false)

defmethod do (f: Int -> ?, r:SimpleRange) :
  val end = end(r) as Int
  let loop (i:Int = start(r)) :
    if i < end :
      f(i)
      loop(i + 1)

;============================================================
;==================== KeyValue Pairs ========================
;============================================================

public deftype KeyValue<K,V> <: Equalable & Hashable

;                       Interface
;                       =========

public defmulti key<?K> (kv:KeyValue<?K,?>) -> K
public defmulti value<?V> (kv:KeyValue<?,?V>) -> V

;                      Constructor
;                      ===========

public defn KeyValue<?K,?V> (k:?K, v:?V) -> KeyValue<K,V> :
   new KeyValue<K,V> :
      defmethod key (this) : k
      defmethod value (this) : v

defmethod print (o:OutputStream, v:KeyValue) :
   write(o, key(v))
   print(o, " => ")
   write(o, value(v))

defmethod equal? (a:KeyValue, b:KeyValue) :
   key(a) == key(b) and
   value(a) == value(b)

defmethod hash (x:KeyValue<Hashable,Hashable>) :
   hash(key(x)) + 7 * hash(value(x))

;============================================================
;====================== Tokens ==============================
;============================================================

public deftype Token <: Equalable

;                      Interface
;                      =========

public defmulti item (t:Token) -> ?
public defmulti info (t:Token) -> FileInfo

;                     Constructor
;                     ===========

public defn Token (item, info:FileInfo) :
   new Token :
      defmethod item (this) : item
      defmethod info (this) : info

public defn unwrap-token (t) :
   match(t) :
      (t:Token) : unwrap-token(item(t))
      (t) : t

public defn sub-token-item? (t, x) -> ? :
  match(t, x) :
    (t, x:Token) : x
    (t:Token, x) : Token(x, info(t))
    (t, x) : x

public defn unwrap-all (t) -> ? :
   match(t) :
      (t:Token) : unwrap-all(item(t))
      (t:List) : map(unwrap-all, t)
      (t) : t

defmethod print (o:OutputStream, t:Token) :
   write(o, item(t))

defmethod equal? (a:Token, b:Token) :
   (item(a) == item(b)) and
   (info(a) == info(b))

;============================================================
;===================== FileInfo =============================
;============================================================

public deftype FileInfo <: Equalable & Hashable & Comparable<FileInfo>

;                     Interface
;                     =========

public defmulti filename (i:FileInfo) -> String
public defmulti line (i:FileInfo) -> Int
public defmulti column (i:FileInfo) -> Int

;                  Implementation
;                  ==============

public defn FileInfo (f:String, l:Int, c:Int) :
   new FileInfo :
      defmethod filename (this) : f
      defmethod line (this) : l
      defmethod column (this) : c

defmethod equal? (a:FileInfo, b:FileInfo) :
   filename(a) == filename(b) and
   line(a) == line(b) and
   column(a) == column(b)

defmethod hash (i:FileInfo) :
   hash(filename(i)) +
   7 * hash(line(i)) +
   49 * hash(column(i))

defmethod compare (a:FileInfo, b:FileInfo) :
   val c = compare(filename(a), filename(b))
   if c == 0 :
      val c = compare(line(a), line(b))
      if c == 0 :
         compare(column(a), column(b))
      else : c
   else : c

defmethod print (o:OutputStream, i:FileInfo) :
   print(o, filename(i))
   print(o, ":")
   print(o, line(i))
   print(o, ".")
   print(o, column(i))

;============================================================
;======================= Sequences ==========================
;============================================================

public deftype Seqable<T> :
  Collection<T> <: Seqable<T>

public deftype Seq<T> <: Seqable<T>

public deftype Collection<T> :
  Range <: Collection<Int>
  String <: Collection<Char>
  List<T> <: Collection<T>
  Tuple<T> <: Collection<T>
  IndexedCollection<T> <: Collection<T>

public defmulti to-seq<?T> (s:Seqable<?T>) -> Seq<T>
defmethod to-seq<?T> (s:Seq<?T>) : s

public defmulti next<?T> (s:Seq<?T>) -> T
public defmulti peek<?T> (s:Seq<?T>) -> T
public defmulti empty? (s:Seq) -> True|False
public defmulti free (s:Seq) -> False
defmethod free (s:Seq) : false

defn* do-seq<?T,?R> (f: Seq<T> -> ?R, s:Seqable<?T>) -> R :
  match(s) :
   (s:Seq<T>) :
     f(s)
   (s) :
     val s-seq = to-seq(s)
     with-finally(
       fn* () : f(s-seq)
       fn* () : free(s-seq))

;===== Conversion to Sequence =====

defmethod to-seq<?T> (x:Tuple<?T>) :
   seq({x[_]}, 0 to length(x))

defmethod to-seq (s:String) :
   seq({s[_]}, 0 to length(s))

defmethod to-seq<?T> (x:List<?T>) :
   var l = x
   new Seq<T> :
      defmethod empty? (this) :
         empty?(l)
      defmethod next (this) :
         val x = peek(this)
         l = tail(l)
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         head(l)

defmethod to-seq<?T> (xs:IndexedCollection<?T>) -> Seq<T> :
   seq({xs[_]}, 0 to length(xs))

defmethod to-seq (r:Range) :
  match(r) :
    (r:Range & Lengthable) :
      var i = start(r)
      var n = length(r)
      new Seq<Int> & Lengthable :
        defmethod next (this) :
          val i* = peek(this)
          i = i + step(r)
          n = n - 1
          i*
        defmethod peek (this) :
          fatal("Empty Sequence") when empty?(this)
          i
        defmethod empty? (this) :
          n == 0
        defmethod length (this) :
          n
    (r:Range) :
      var i = start(r)
      new Seq<Int> :
        defmethod next (this) :
          val i* = i
          i = i + step(r)
          i*
        defmethod peek (this) :
          i
        defmethod empty? (this) :
          false

;===== Conversion from Sequence =====

public defn to-tuple<?T> (xs:Seqable<?T>) -> Tuple<T> :
   match(xs) :
      (xs:Tuple<T>) :
         xs
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val t = Tuple(n, false as ?)
         for (x in xs, i in 0 to n) do :
            t[i] = x
         t
      (xs) :
         to-tuple(to-vector<T>(xs))

public defn String (cs:Seqable<Char>) -> String :
   match(cs) :
      (cs:Seqable<Char> & Lengthable) :
         val n = length(cs)
         val s = String(n, ' ')
         for (c in cs, i in 0 to false) do :
            s[i] = c
         s
      (c) :
         String(to-vector<Char>(cs))

public defn to-list<?T> (xs:Seqable<?T>) -> List<T> :
   match(xs) :
      (xs:List<T>) :
         xs
      (xs) :
         val vec = to-vector<T>(xs)
         defn* loop (i:Int, accum:List<T>) :
            if i >= 0 : loop(i - 1, cons(vec[i], accum))
            else : accum
         loop(length(vec) - 1, List())

public defn to-array<T> (xs:Seqable<T>) -> Array<T> :
  match(xs) :
    (xs:Vector<T>|Tuple<T>|Array<T>) :
      val n = length(xs)
      val a = Array<T>(n)
      for i in 0 to n do :
        a[i] = xs[i]
      a
    (xs) :
      to-array<T>(to-vector<T>(xs))

public defn symbol-join (xs:Seqable) -> Symbol :
   to-symbol(string-join(xs))

;============================================================
;================== Sequence Library ========================
;============================================================

public defmulti do<?T> (f:T -> ?, xs:Seqable<?T>) -> False
public defmulti do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False
public defmulti do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False

defmethod do<?T> (f:T -> ?, xs:Seqable<?T>) -> False :
   for xs-seq in xs do-seq :
      while not empty?(xs-seq) :
         f(next(xs-seq))

defmethod do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         while (not empty?(xs-seq)) and (not empty?(ys-seq)) :
            f(next(xs-seq), next(ys-seq))

defmethod do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            while (not empty?(xs-seq)) and (not empty?(ys-seq)) and (not empty?(zs-seq)) :
               f(next(xs-seq), next(ys-seq), next(zs-seq))

;Specialization
defmethod do<?T> (f: T -> ?, xs:Array<?T>) :
   val n = length(xs)
   let loop (i:Int = 0) :
      if i < n :
         f(xs[i])
         loop(i + 1)

defmethod do<?T> (f: T -> ?, xs:Tuple<?T>) :
   val n = length(xs)
   let loop (i:Int = 0) :
      if i < n :
         f(xs[i])
         loop(i + 1)

#for (Prim in [Byte Int Long Float Double]
      PrimArray in [ByteArray IntArray LongArray FloatArray DoubleArray]) :
   defmethod do (f: Prim -> ?, xs:PrimArray) :
      val n = length(xs)
      let loop (i:Int = 0) :
         if i < n :
            f(xs[i])
            loop(i + 1)

defmethod do (f: Char -> ?, xs:String) :
   val n = length(xs)
   let loop (i:Int = 0) :
      if i < n :
         f(xs[i])
         loop(i + 1)

defmethod do<?T> (f:T -> ?, xs:List<?T>) -> False :
   let loop (xs:List<T> = xs) :
      if not empty?(xs) :
         f(head(xs))
         loop(tail(xs))

defn wrap-length<?T> (xs:Seq<?T>, length:() -> Int) :
  new Seq<T> & Lengthable :
    defmethod next (this) : next(xs)
    defmethod peek (this) : peek(xs)
    defmethod empty? (this) : empty?(xs)
    defmethod length (this) : length()

public defn to-collection<?T> (f:() -> Seq<?T>) -> Collection<T> :
  new Collection<T> :
    defmethod to-seq (this) : f()

public defn seq<?T,?S> (f:T -> ?S, xs:Seqable<?T>) -> Seq<S> :
  val xs-seq = to-seq(xs)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) : None()
    else : One(f(next(xs-seq)))
  match(xs-seq) :
    (xs:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + length(xs)})
    (xs) : rs

public defn seq<?T,?S,?R> (f:(T,S) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
  val xs-seq = to-seq(xs)
  val ys-seq = to-seq(ys)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) or empty?(ys-seq) : None()
    else : One(f(next(xs-seq), next(ys-seq)))
  match(xs-seq, ys-seq) :
    (xs:Seq&Lengthable, ys:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + min(length(xs), length(ys))})
    (xs, ys) : rs

public defn seq<?T,?S,?U,?R> (f:(T,S,U) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
  val xs-seq = to-seq(xs)
  val ys-seq = to-seq(ys)
  val zs-seq = to-seq(zs)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) or empty?(ys-seq) or empty?(zs-seq) : None()
    else : One(f(next(xs-seq), next(ys-seq), next(zs-seq)))
  match(xs-seq, ys-seq, zs-seq) :
    (xs:Seq&Lengthable, ys:Seq&Lengthable, zs:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + min(length(xs), min(length(ys), length(zs)))})
    (xs, ys, zs) : rs

public defmulti in-reverse<?T> (xs:Seqable<?T>) -> Seq<T>
defmethod in-reverse<?T> (xs:Seqable<?T>) :
  in-reverse(to-vector<T>(xs))

defmethod in-reverse<?T> (xs:IndexedCollection<?T>) :
  val n = length(xs)
  for i in (n - 1) through 0 by -1 seq :
    xs[i]

defmethod in-reverse (r:Range) :
  to-seq(reverse(r))

defmethod in-reverse<?T> (xs:List<?T>) -> Seq<T> :
  generate<T> :
    defn loop (xs:List<T>) :
      if not empty?(xs) :
        loop(tail(xs))
        yield(head(xs))
    loop(xs)

public defmulti contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False
defmethod contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False :
   label<False|True> return :
      for x in xs do :
         return(true) when x == y

public defn find<?T> (f: T -> True|False, xs:Seqable<?T>) -> T|False :
   label<False|T> return :
      for x in xs do :
         return(x) when f(x)

public defn find<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> T|False :
   label<False|T> return :
      for (x in xs, y in ys) do :
         return(x) when f(x, y)

public defn find!<?T> (f: T -> True|False, xs:Seqable<?T>) : find(f, xs) as T
public defn find!<?T, ?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : find(f, xs, ys) as T

public defn first<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Maybe<R> :
   label<Maybe<R>> return :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()

public defn first<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Maybe<R> :
   label<Maybe<R>> return :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()

public defn first!<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) : value!(first(f, xs))
public defn first!<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) : value!(first(f, xs, ys))

public defn seq?<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Seq<R> :
   generate<R> :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?U,?R> (f: (T,S,U) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys, z in zs) do :
         match(f(x, y, z)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn filter<?T> (f: T -> True|False, xs:Seqable<?T>) -> Seq<T> :
   generate<T> :
      for x in xs do :
         yield(x) when f(x)

public defn filter<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<T> :
   generate<T> :
      for (x in xs, y in ys) do :
         yield(x) when f(x, y)

public defn filter<?T> (xs:Seqable<?T>, sel:Seqable<True|False>) -> Seq<T> :
   for (x in xs, s in sel) filter : s

public defn index-of (xs:Seqable<Equalable>, y:Equalable) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when x == y

public defn index-of! (xs:Seqable<Equalable>, y:Equalable) : index-of(xs, y) as Int

public defn index-when<?T> (f: T -> True|False, xs:Seqable<?T>) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when f(x)

public defn index-when<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Int|False :
   label<Int|False> return :
      for (x in xs, y in ys, i in 0 to false) do :
         return(i) when f(x, y)

public defn index-when!<?T> (f: T -> True|False, xs:Seqable<?T>) : index-when(f, xs) as Int
public defn index-when!<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : index-when(f, xs, ys) as Int

public defn split!<?T> (f: T -> True|False, xs: Seqable<?T>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for x in xs do :
      add{_, x} $
         if f(x) : true-xs
         else : false-xs
   [true-xs, false-xs]

public defn split!<?T,?S> (f: (T, S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
  val true-xs = Vector<T>()
  val false-xs = Vector<T>()
  for (x in xs, y in ys) do :
    add{_, x} $
      if f(x, y) : true-xs
      else : false-xs
  [true-xs, false-xs]

public defn split!<?T> (xs:Seqable<?T>, ss:Seqable<True|False>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for (x in xs, s in ss) do :
      add{_, x} $
         if s : true-xs
         else : false-xs
   [true-xs, false-xs]

public defn split<?T> (f:T -> True|False, xs-items:Seqable<?T>) -> [Seq<T>, Seq<T>] :
  val xs = to-seq(xs-items)
  val a-items = Queue<T>()
  val b-items = Queue<T>()

  ;Pull next item onto queues
  defn pull () :
    val x = next(xs)
    if f(x) : add(a-items, x)
    else : add(b-items, x)

  ;Try to fill a queue, returns true if filled
  defn* fill (items:Queue<T>) -> True|False :
    if empty?(items) :
      if not empty?(xs) :
        pull()
        fill(items)
    else :
      true

  ;Create seq from queue
  defn queue-seq (items:Queue<T>) :
    new Seq<T> :
      defmethod next (this) :
        if fill(items) : pop(items)
        else : fatal("No more items")
      defmethod peek (this) :
        if fill(items) : peek(items)
        else : fatal("No more items")
      defmethod empty? (this) :
        not fill(items)

  [queue-seq(a-items), queue-seq(b-items)]

public defn fork<?T> (xs-items:Seqable<?T>) -> [Seq<T>, Seq<T>] :
  val xs = to-seq(xs-items)
  val a-items = Queue<T>()
  val b-items = Queue<T>()

  defn queue-seq (items:Queue<T>, other:Queue<T>) :
    new Seq<T> :
      defmethod next (this) :
        if empty?(items) :
          val x = next(xs)
          add(other, x)
          x
        else :
          pop(items)
      defmethod peek (this) :
        if empty?(items) : peek(xs)
        else : peek(items)
      defmethod empty? (this) :
        empty?(items) and empty?(xs)

  [queue-seq(a-items, b-items),
   queue-seq(b-items, a-items)]

public defn fork<?T> (xs-items:Seqable<?T>, n:Int) -> Tuple<Seq<T>> :
  val xs = to-seq(xs-items)
  val items = to-tuple(repeatedly(Queue<T>{}, n))

  ;Pull next item all queues except queue n
  defn pull (n:Int) :
    val x = next(xs)
    for (q in items, i in 0 to false) do :
      add(q, x) when i != n
    x

  to-tuple $ for i in 0 to n seq :
    val items = items[i]
    new Seq<T> :
      defmethod next (this) :
        if empty?(items) : pull(i)
        else : pop(items)
      defmethod peek (this) :
        if empty?(items) : peek(xs)
        else : peek(items)
      defmethod empty? (this) :
        empty?(items) and empty?(xs)

public defn take-while<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = peek(xs-seq)
               if f(x) :
                  next(xs-seq)
                  yield(x)
                  loop()
         loop()

public defn take-until<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = next(xs-seq)
               yield(x)
               loop() when not f(x)
         loop()

public defn take-n<?T> (n:Int, xs:Seqable<?T>) :
   ensure-non-negative("length", n)
   var len = n
   val xs-seq = to-seq(xs)
   new Seq<T> & Lengthable :
      defmethod next (this) :
         val v = peek(this)
         next(xs-seq)
         len = len - 1
         v
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         peek(xs-seq)
      defmethod empty? (this) :
         len == 0
      defmethod length (this) :
         len
      defmethod free (this) :
         free(xs-seq)

public defn take-up-to-n<?T> (n:Int, xs:Seqable<?T>) :
   ensure-non-negative("length", n)
   var len = n
   val xs-seq = to-seq(xs)
   new Seq<T> :
      defmethod next (this) :
         val v = peek(this)
         next(xs-seq)
         len = len - 1
         v
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         peek(xs-seq)
      defmethod empty? (this) :
         (len == 0) or empty?(xs-seq)
      defmethod free (this) :
         free(xs-seq)

public defn cat<?T> (a:Seqable<?T>, b:Seqable<?T>) -> Seq<T> :
   cat-all([a, b])

public defn cat-all<?T> (input-xss:Seqable<Seqable<?T>>) -> Seq<T> :
  val xss = to-seq(input-xss)
  var xs:Seq<T>|False|Sentinel = sentinel
  defn* load-next-seq () :
    if empty?(xss) :
      xs = false
    else :
      xs = to-seq(next(xss))
      fill()
  defn* fill () -> Seq<T>|False :
    match(xs) :
      (xs:False) : false
      (xs:Seq<T>) : load-next-seq() when empty?(xs) else xs
      (xs:Sentinel) : load-next-seq()
  defn fill! () :
    match(fill()) :
      (xs:Seq<T>) : xs
      (xs:False) : fatal("Empty Sequence")
  new Seq :
    defmethod next (this) :
      next(fill!())
    defmethod peek (this) :
      peek(fill!())
    defmethod empty? (this) :
      fill() is False
    defmethod free (this) :
      match(xs:Seq<T>) : free(xs)
      free(xss)
      xs = false

public defn seq-cat<?T,?R> (f:T -> Seqable<?R>, xs:Seqable<?T>) -> Seq<R> :
   cat-all(seq(f, xs))

public defn seq-cat<?T,?S,?R> (f:(T,S) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   cat-all(seq(f, xs, ys))

public defn seq-cat<?T,?S,?U,?R> (f:(T,S,U) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   cat-all(seq(f, xs, ys, zs))

public defn all?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   for xs-seq in xs do-seq :
      defn* loop () :
         if empty?(xs-seq) : true
         else : pred?(next(xs-seq)) and loop()
      loop()

public defn all?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         defn* loop () :
            if empty?(xs-seq) or empty?(ys-seq) : true
            else : pred?(next(xs-seq), next(ys-seq)) and loop()
         loop()

public defn all?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            defn* loop () :
               if empty?(xs-seq) or empty?(ys-seq) or empty?(zs-seq) : true
               else : pred?(next(xs-seq), next(ys-seq), next(zs-seq)) and loop()
            loop()

public defn none?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   defn notp (x) : not pred?(x)
   all?(notp, xs)

public defn none?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   defn notp (x1, x2) : not pred?(x1, x2)
   all?(notp, xs, ys)

public defn none?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   defn notp (x1, x2, x3) : not pred?(x1, x2, x3)
   all?(notp, xs, ys, zs)

public defn any?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   not none?(pred?, xs)

public defn any?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   not none?(pred?, xs, ys)

public defn any?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   not none?(pred?, xs, ys, zs)

public defn count (xs:Seqable) -> Int :
  match(xs) :
    (xs:Seqable & Lengthable) :
      length(xs)
    (xs) :
      var accum:Int = 0
      for x in xs do :
        accum = accum + 1
      accum

public defn count<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> Int :
   var accum:Int = 0
   for x in xs do :
      if pred?(x) : accum = accum + 1
   accum

public defn join<?T,?S> (xs0:Seqable<?T>, y:?S) -> Seq<T|S> :
  val xs = to-seq(xs0)
  var join? = false
  val rs = new Seq<T|S> :
    defmethod next (this) :
      fatal("Empty Sequence") when empty?(xs)
      val result = y when join? else next(xs)
      join? = not join?
      result
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(xs)
      y when join? else peek(xs)
    defmethod empty? (this) :
      empty?(xs)
  match(xs) :
    (xs:Seq<T> & Lengthable) :
      defn rs-length () :
        if join? : length(xs) * 2
        else : length(xs) * 2 - 1
      wrap-length(rs, rs-length)
    (xs) : rs

public defn interleave<?T,?S> (xs0:Seqable<?T>, ys0:Seqable<?S>) -> Seq<T|S> :
  val xs = to-seq(xs0)
  val ys = to-seq(ys0)
  var yield-x? = true
  val rs = new Seq<T|S> :
    defmethod next (this) :
      fatal("Empty Sequence") when empty?(this)
      val result = next(xs) when yield-x? else next(ys)
      yield-x? = not yield-x?
      result
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(this)
      peek(xs) when yield-x? else peek(ys)
    defmethod empty? (this) :
      empty?(xs) when yield-x? else empty?(ys)
  match(xs, ys) :
    (xs:Seq<T> & Lengthable, ys:Seq<S> & Lengthable) :
      defn rs-length () :
        if yield-x? : 2 * min(length(xs), length(ys))
        else : 1 + 2 * min(length(xs), length(ys) - 1)
      wrap-length(rs, rs-length)
    (xs, ys) : rs

public defn reduce<?T,?S> (f: (T, S) -> ?T, x0: ?T, xs:Seqable<?S>) -> T :
   var accum = x0
   for x in xs do :
      accum = f(accum, x)
   accum

public defn reduce<?T,?S> (f: (T|S, T) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      reduce(f, next(xs-seq), xs-seq)

public defn reduce-right<?T,?S> (f: (S, T) -> ?T, xs:Seqable<?S>, xn:?T) -> T :
   for xs-seq in xs do-seq :
      defn loop () :
         if empty?(xs-seq) : xn
         else : f(next(xs-seq), loop())
      loop()

public defn reduce-right<?T,?S> (f: (T, T|S) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      defn loop (x:T) :
         if empty?(xs-seq) : x
         else : f(x, loop(next(xs-seq)))
      loop(next(xs-seq))

public defn repeat<?T> (x:?T) -> Seq<T> :
   new Seq<T> :
      defmethod next (this) : x
      defmethod peek (this) : x
      defmethod empty? (this) : false

public defn repeat<?T> (x:?T, n:Int) :
   ensure-non-negative("length", n)
   var len = n
   new Seq<T> & Lengthable :
      defmethod next (this) :
         fatal("Empty Sequence") when len == 0
         len = len - 1
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         x
      defmethod empty? (this) :
         len == 0
      defmethod length (this) :
         len

deftype RepeatWhileSeq<T> <: Seq<T>
defmulti cached (s:RepeatWhileSeq) -> Int

public defn repeat-while<?T> (f: () -> Maybe<?T>) -> RepeatWhileSeq<T> :
  var item = sentinel
  defn fill () : (item = f()) when item is Sentinel

  new RepeatWhileSeq<T> :
    defmethod next (this) :
      val x = peek(this)
      item = sentinel
      x
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(this)
      value(item as One<T>)
    defmethod empty? (this) :
      fill()
      item is None
    defmethod cached (this) :
      1 when item is One else 0

public defn repeatedly<?T> (f:() -> ?T) -> Seq<T> :
   var item = sentinel
   defn fill () : (item = f()) when item is Sentinel

   defn empty () :
      val x = item as T
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         item as T
      defmethod empty? (this) :
         false

public defn repeatedly<?T> (f:() -> ?T, n:Int) :
   take-n(n, repeatedly(f))

public defn zip<?T,?S> (xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<[T,S]> :
   for (x in xs, y in ys) seq : [x, y]

public defn zip<?T,?S,?U> (xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<[T,S,U]> :
   for (x in xs, y in ys, z in zs) seq : [x, y, z]

public defn zip-all<?T> (xs:Seqable<Seqable<?T>>) :
   val seqs = to-tuple(seq(to-seq, xs))
   fatal("No Sequences Given") when empty?(seqs)
   val ret-seq = new Seq<Tuple<T>> :
      defmethod next (this) :
         map(next, seqs)
      defmethod peek (this) :
         map(peek, seqs)
      defmethod empty? (this) :
         any?(empty?, seqs)
   if all?({_ is Lengthable&Seq}, seqs) :
      val len = minimum{seq(length{_ as Lengthable&Seq}, seqs)}
      wrap-length(ret-seq, len)
   else :
      ret-seq

public defn unique<?T> (xs:Seqable<?T&Equalable>) -> List<T> :
   ;Manage Visited Set
   val table = HashTable<Hashable,True|False>()
   val accum = Vector<Equalable>()

   defn add-to-unique-set (x:T&Equalable) :
      match(x) :
         (x:T&Equalable&Hashable) : table[x] = true
         (x:T&Equalable) : add(accum, x)
   defn visited? (x:T&Equalable) :
      match(x) :
         (x:T&Equalable&Hashable) : key?(table, x)
         (x:T&Equalable) : contains?(accum, x)

   ;Filter
   to-list $ for x in xs filter :
      if not visited?(x) :
         add-to-unique-set(x)
         true

public defn lookup?<?K,?V,?D> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable, default:?D) -> D|V :
   label<V|D> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      default

public defn lookup?<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> False|V :
   lookup?(xs, k, false)

public defn lookup<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> V :
   label<V> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      fatal("Key %~ not found in entries." % [k])

public defn fork-on-seq<?T,?X,?Y> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y) -> [X,Y] :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val fco = make-co(f)
   val gco = make-co(g)

   ;Store function results
   var fresult = resume(fco, None())
   var gresult = resume(gco, None())

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         if fresult is None :
            fresult = resume(fco, v)
         if gresult is None :
            gresult = resume(gco, v)
         (fresult is None) or
         (gresult is None)
      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   [value!(fresult),
    value!(gresult)]

public defn fork-on-seq<?T,?X,?Y,?Z> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y, h:Seq<T> -> ?Z) -> [X,Y,Z] :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val fco = make-co(f)
   val gco = make-co(g)
   val hco = make-co(h)

   ;Store function results
   var fresult = resume(fco, None())
   var gresult = resume(gco, None())
   var hresult = resume(hco, None())

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         if fresult is None :
            fresult = resume(fco, v)
         if gresult is None :
            gresult = resume(gco, v)
         if hresult is None :
            hresult = resume(hco, v)
         (fresult is None) or
         (gresult is None) or
         (hresult is None)
      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   [value!(fresult),
    value!(gresult),
    value!(hresult)]

public defn fork-on-seq<?T,?S> (xs:Seqable<?T>, fs:Seqable<(Seq<T> -> ?S)>) -> Tuple<S> :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val cos = to-tuple(seq(make-co, fs))

   ;Store function results
   val results = to-array<Maybe<S>>(seq(resume{_, None()}, cos))

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         var more? = false
         for (co in cos, i in 0 to false) do :
            if results[i] is None :
               val r = resume(co, v)
               results[i] = r
               more? = more? or (r is None)
         more?

      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   to-tuple(seq(value!, results))

;============================================================
;=============== Commandline Arguments ======================
;============================================================

public lostanza defn command-line-arguments () -> ref<Array<String>> :
  val r = Array<String>(new Int{clib/input_argc})
  for (var i:int = 0, i < clib/input_argc, i = i + 1) :
    val str = clib/input_argv[i]
    set(r, new Int{i}, String(str))
  return r

public lostanza defn set-command-line-arguments (args:ref<Tuple<String>>) -> ref<False> :
  ;Free old arguments if necessary
  if clib/input_argv_needs_free :
    val n = clib/input_argc
    val ss = clib/input_argv
    for (var i:int = 0, i < n, i = i + 1) :
      call-c clib/free(ss[i])
    call-c clib/free(ss)

  ;Malloc array for new arguments
  val n = length(args).value
  val argvs:ptr<ptr<byte>> = call-c clib/malloc((n + 1) * sizeof(ptr<?>))

  ;Copy strings to new array
  for (var i:int = 0, i < n, i = i + 1) :
    argvs[i] = copy-chars(args.items[i])
  argvs[n] = null

  ;Set to global variables
  clib/input_argc = n
  clib/input_argv = argvs

  ;Set flag to indicate that the newly allocated arguments need to be freed.
  clib/input_argv_needs_free = 1

  ;Return from function
  return false

lostanza defn copy-chars (s:ref<String>) -> ptr<byte> :
  val n = length(s).value + 1
  val p:ptr<byte> = call-c clib/malloc(n)
  call-c clib/memcpy(p, addr!(s.chars), n)
  return p

;============================================================
;===================== Random Numbers =======================
;============================================================

public lostanza deftype Random :
  var state: long
lostanza defn next-state (s0:long) -> long :
  return (s0 * 0x5deece66dL + 0xbL) & 0xFFFFFFFFFFFFL
lostanza defn extract-bits (s:long, n:int) -> int :
  return (s >>> (48 - n)) as int
lostanza defn next-bits (r:ref<Random>, n:int) -> int :
  val s = next-state(r.state)
  r.state = s
  return extract-bits(s, n)

public lostanza defn Random (state:ref<Long>) -> ref<Random> :
  return new Random{next-state(state.value)}

public lostanza defn state (r:ref<Random>) -> ref<Long> :
  return new Long{r.state}

public lostanza defn set-state (r:ref<Random>, state:ref<Long>) -> ref<False> :
  r.state = state.value
  return false

public defn Random () :
  Random(current-time-us())

public lostanza defn next-int (r:ref<Random>) -> ref<Int> :
  return new Int{next-bits(r, 31)}

public lostanza defn next-signed-int (r:ref<Random>) -> ref<Int> :
  return new Int{next-bits(r, 32)}

val LIMIT-STR = String("limit")
public lostanza defn next-int (r:ref<Random>, n0:ref<Int>) -> ref<Int> :
  ensure-positive(LIMIT-STR, n0)

  ;Extract lostanza values
  val n = n0.value

  ;Power of 2
  if n & (- n) == n :
    val bits = next-bits(r, 31) as long
    return new Int{((n * bits) >> 31) as int}

  ;Otherwise
  labels :
    loop :
      val bits = next-bits(r, 31)
      val v = bits % n
      if bits - v + (n - 1) < 0 : goto loop
      else : return new Int{v}

public lostanza defn next-bytes (r:ref<Random>, bs:ref<ByteArray>) -> ref<False> :
  val n = bs.length
  labels :
    begin: goto loop(r.state, 0)
    loop (s:long, i:long) :
      if i + 4 < n :
        val s* = next-state(s)
        [addr!(bs.data[i]) as ptr<int>] = extract-bits(s*, 32)
        goto loop(s*, i + 4)
      else : goto end(s, i)
    end (s:long, i:long) :
      if i < n :
        val s* = next-state(s)
        bs.data[i] = extract-bits(s*, 8) as byte
        goto end(s*, i + 1)
      else :
        r.state = s
        return false

public defn next-int (rand:Random, r:Range) :
  ;Returns an integer between lo and hi inclusive
  defn from-interval (lo:Int, hi:Int) :
    val spread = hi - lo + 1
    if spread < 0 :
      let loop () :
        val r = next-int(rand)
        if r >= lo and r <= hi : r
        else : loop()
    else :
      lo + next-int(rand, spread)

  ;Check
  #if-not-defined(OPTIMIZE) :
    if step(r) != 1 :
      fatal("Ranges with step sizes other than 1 not supported.")
  val s = start(r)
  match(end(r), inclusive?(r)) :
    (e:Int, inc:True) :
      ensure-start-before-end(s, e)
      from-interval(s, e)
    (e:Int, inc:False) :
      #if-not-defined(OPTIMIZE) :
        if e == s : fatal("Empty range.")
        else : ensure-start-before-end(s, e)
      from-interval(s, e - 1)
    (e:False, inc) :
      from-interval(s, INT-MAX)

public lostanza defn next-long (rand:ref<Random>) -> ref<Long> :
  val x0 = next-bits(rand, 31) as long
  val x1 = next-bits(rand, 32) as long & 0xFFFFFFFFL
  val r0 = (x0 << 32L)
  return new Long{x0 << 32L | x1}

public lostanza defn next-signed-long (rand:ref<Random>) -> ref<Long> :
  val x0 = next-bits(rand, 32) as long
  val x1 = next-bits(rand, 32) as long & 0xFFFFFFFFL
  return new Long{x0 << 32L | x1}

public lostanza defn next-float (rand:ref<Random>) -> ref<Float> :
  return new Float{next-bits(rand,24) as float / (1 << 24) as float}

public lostanza defn next-double (rand:ref<Random>) -> ref<Double> :
  val num = ((next-bits(rand, 26) as long) << 27) + next-bits(rand, 27)
  val den = (1L << 53L) as double
  return new Double{num as double / den}

val RANDOM = Random(current-time-us())
public defn current-random () : RANDOM
public defn srand (n:Long) : set-state(RANDOM, n)
public defn rand () : next-int(RANDOM)
public defn rand-long () : next-long(RANDOM)
public defn rand-float () : next-float(RANDOM)
public defn rand-double () : next-double(RANDOM)
public defn rand (n:Int) : next-int(RANDOM, n)
public defn rand (r:Range) : next-int(RANDOM, r)

;============================================================
;======================== Sleep =============================
;============================================================

extern sleep_us : long -> int
extern sleep_ms : long -> int

public lostanza defn sleep-us (us:ref<Long>) -> ref<False> :
  val res = call-c sleep_us(us.value)
  if res < 0 : throw(SystemCallException(linux-error-msg()))
  return false

public lostanza defn sleep-ms (ms:ref<Long>) -> ref<False> :
  val res = call-c sleep_ms(ms.value)
  if res < 0 : throw(SystemCallException(linux-error-msg()))
  return false

;============================================================
;======================= Platform ===========================
;============================================================

public defenum Platform :
  Windows
  Linux
  OS-X

public val CURRENT-PLATFORM:Platform =
  #if-defined(PLATFORM-WINDOWS) :
    Windows
  #else :
    #if-defined(PLATFORM-OS-X) :
      OS-X
    #else :
      #if-defined(PLATFORM-LINUX) :
        Linux
      #else :
        fatal("Unreachable")

;============================================================
;=================== Process Library ========================
;============================================================

;                   Process Structure
;                   =================

;- done-state: If the last call to state() indicates that the
;  process has finished, then this state is saved here. This is
;  necessary because we are not allowed to check the state
;  of an already-exited process more than once.
;  If this field is false, it means that either we haven't
;  called state() yet, or the previous call to state() indicates
;  that the process is still running.
public lostanza deftype Process <: Unique :
  var pid: long
  var handle: ptr<?>
  var pipeid: int
  var input: ptr<?>
  var output: ptr<?>
  var error: ptr<?>
  var input-stream: ref<False|FileOutputStream>
  var output-stream: ref<False|FileInputStream>
  var error-stream: ref<False|FileInputStream>
  var done-state: ref<ProcessState|False>

;                 Process State Structure
;                 =======================

public deftype ProcessState
public defstruct ProcessRunning <: ProcessState
public defstruct ProcessDone <: ProcessState : (value:Int)
public defstruct ProcessTerminated <: ProcessState : (signal:Int)
public defstruct ProcessStopped <: ProcessState : (signal:Int)

defmethod print (o:OutputStream, s:ProcessState) :
  print{o, _} $ match(s) :
    (s:ProcessRunning) : "Running"
    (s:ProcessDone) : "Done(exit value = %_)" % [value(s)]
    (s:ProcessTerminated) : "Terminated(signal = %_)" % [signal(s)]
    (s:ProcessStopped) : "Stopped(signal = %_)" % [signal(s)]

;                   Stream Specifier
;                   ================

public defstruct StreamSpecifier <: Equalable : (value:Int)
public val STANDARD-IN = StreamSpecifier(0)
public val STANDARD-OUT = StreamSpecifier(1)
public val PROCESS-IN = StreamSpecifier(2)
public val PROCESS-OUT = StreamSpecifier(3)
public val STANDARD-ERR = StreamSpecifier(4)
public val PROCESS-ERR = StreamSpecifier(5)

defmethod equal? (a:StreamSpecifier, b:StreamSpecifier) :
  value(a) == value(b)

defmethod print (o:OutputStream, s:StreamSpecifier) :
  print{o, _} $ switch(value(s)) :
    0 : "STANDARD-IN"
    1 : "STANDARD-OUT"
    2 : "PROCESS-IN"
    3 : "PROCESS-OUT"
    4 : "STANDARD-ERR"
    5 : "PROCESS-ERR"

;                      Process Errors
;                      ==============
public defstruct ProcessAbortedError <: Exception :
  state: ProcessState
defmethod print (o:OutputStream, e:ProcessAbortedError) :
  match(state(e)) :
    (s:ProcessTerminated) : print(o, "Process prematurely terminated with signal %_." % [signal(s)])
    (s:ProcessStopped) : print(o, "Process prematurely stopped with signal %_." % [signal(s)])

public deftype SystemCallException <: Exception
public defn SystemCallException (msg:String) :
  new SystemCallException :
    defmethod print (o:OutputStream, this) :
      print(o, msg)

;Choose what to do with environment variables.
;- AddEnvVars: Add the given environment variables to the current list.
;- ReplaceEnvVars: Ignore current variables, and use the given env vars as is.
public defenum EnvVarMode :
  AddEnvVars
  ReplaceEnvVars

;Process the env var list against the mode that is given to obtain
;the final full list of env vars.
defn process-env-var-mode (env-vars:Tuple<KeyValue<String,String>>|False,
                           mode:EnvVarMode) -> Tuple<KeyValue<String,String>> :
  switch(mode) :
    AddEnvVars :
      match(env-vars) :
        (vs:False) : get-env-vars()
        (vs:Tuple<KeyValue<String,String>>) :
          to-tuple $ to-hashtable<String,String>(
            cat(get-env-vars(), vs))
    ReplaceEnvVars :
      match(env-vars) :
        (vs:False) : fatal("If ReplaceEnvVars is given as mode, then list of env vars must be provided.")
        (vs:Tuple<KeyValue<String,String>>) : vs

;                           Constructor
;                           ===========
#if-defined(PLATFORM-WINDOWS):
  public lostanza defn Process (filename:ref<String>,
                                args0:ref<Seqable<String>>,
                                input:ref<StreamSpecifier>,
                                output:ref<StreamSpecifier>,
                                error:ref<StreamSpecifier>,
                                working-dir:ref<String|False>,
                                env-vars:ref<Tuple<KeyValue<String,String>>|False>
                                env-var-mode:ref<EnvVarMode>) -> ref<Process> :
    ensure-valid-env-var-names!(env-vars)
    ensure-valid-stream-specifiers(input, output, error)
    val proc = new Process{0, null, -1, null, null, null, false, false, false, false}

    ; Create a command line from the given filename and args (discarding the first argument).
    ; This is necessary because Windows' process API expects a command line (not a list of arguments).
    ; We discard the first argument because, on Windows, the first argument is used to look-up
    ; the executable (e.g. in the current directiory, in the PATH, etc.) whereas on POSIX
    ; it is typically only exists as a convention.
    val args = cons(filename, tail(to-list(args0)))
    val command-line = escape-shell-command(args)
    val input_v = value(input).value
    val output_v = value(output).value
    val error_v = value(error).value

    ;Create the environment variable string.
    val full-env-vars = process-env-var-mode(env-vars, env-var-mode)
    val env-var-string = to-windows-env-var-string(full-env-vars)

    ;Retrieve the characters of the working directory (or null if false).
    var working-dir-chars:ptr<byte>
    match(working-dir) :
      (working-dir:ref<String>) : working-dir-chars = addr!(working-dir.chars)
      (working-dir:ref<False>) : working-dir-chars = null

    ;Launch the process
    val launch_success = call-c clib/launch_process(
      addr!(command-line.chars), input_v, output_v, error_v, working-dir-chars, env-var-string, addr!([proc]))
    ;Free any malloc'd memory.
    if env-var-string != null : call-c clib/free(env-var-string)
    ;Throw an exception if launch failed.
    if launch_success != 0 :
      throw(ProcessLaunchError(filename, windows-error-msg()))

    ;If the process was created successfully, then create a finalizer
    ;to close the process handle.
    add-finalizer(new ProcessFinalizer{proc.handle}, proc)

    ;Return the newly created process.
    return proc

  ;Finalizer for closing the process handle.
  lostanza deftype ProcessFinalizer <: Finalizer :
    handle:ptr<?>

  ;Call close process handle when the process is collected.
  lostanza defmethod run (f:ref<ProcessFinalizer>) -> ref<False> :
    call-c clib/close_process_handle(f.handle)
    return false

  ;Format the given tuple of key-value pairs into an environment variable string
  ;to pass to Windows.
  ;Format of the final string is: "MYVAR1=MYVALUE1\0MYVAR2=MYVALUE2\0\0". Note the
  ;final \0 at the end to signify the end of the list itself.
  defn create-windows-env-var-string (env-vars:Tuple<KeyValue<String,String>>) -> ByteBuffer :
    val buffer = ByteBuffer()
    for entry in env-vars do :
      print(buffer, "%_=%_" % [key(entry), value(entry)])
      put(buffer, 0Y)
    put(buffer, 0Y)
    buffer

  ;Create a stable memory location for use in holding the windows env-var string.
  lostanza defn to-windows-env-var-string (env-vars:ref<Tuple<KeyValue<String,String>>|False>) -> ptr<byte> :
    match(env-vars) :
      (vs:ref<False>) :
        return null
      (vs:ref<Tuple<KeyValue<String,String>>>) :
        val buffer = create-windows-env-var-string(vs)
        return copy-buffer-to-stable-memory(buffer)

#else:
  val PIPE-ID-GENERATOR = Random()

  public lostanza defn Process (filename:ref<String>,
                                args0:ref<Seqable<String>>,
                                input:ref<StreamSpecifier>,
                                output:ref<StreamSpecifier>,
                                error:ref<StreamSpecifier>,
                                working-dir:ref<String|False>
                                env-vars:ref<Tuple<KeyValue<String,String>>|False>
                                env-var-mode:ref<EnvVarMode>) -> ref<Process> :
    ensure-valid-env-var-names!(env-vars)
    ensure-valid-stream-specifiers(input, output, error)
    val args = to-tuple(args0)
    val pipe-id = next-int(PIPE-ID-GENERATOR).value
    val proc = new Process{0, null, pipe-id, null, null, null, false, false, false, false}
    val input_v = value(input).value
    val output_v = value(output).value
    val error_v = value(error).value
    val nargs = args.length
    val argvs:ptr<ptr<byte>> = call-c clib/malloc((nargs + 1) * sizeof(ptr<?>))
    argvs[nargs] = null
    for (var i:long = 0, i < nargs, i = i + 1) :
      argvs[i] = addr!(args.items[i].chars)

    ;Create the array of environment variable strings.
    val full-env-vars = process-env-var-mode(env-vars, env-var-mode)
    val env-var-string = to-linux-env-var-string(full-env-vars)

    ;Retrieve the characters of the working directory (or null if false).
    var working-dir-chars:ptr<byte>
    match(working-dir) :
      (working-dir:ref<String>) : working-dir-chars = addr!(working-dir.chars)
      (working-dir:ref<False>) : working-dir-chars = null

    ;Launch the process
    val launch_succ = call-c clib/launch_process(addr!(filename.chars), argvs,
      input_v, output_v, error_v, proc.pipeid, working-dir-chars, env-var-string, addr!([proc]))

    ;Free the memory created using malloc.
    free-linux-env-var-string(env-var-string)

    ;Throw an exception if launch failed.
    if launch_succ != 0 :
      throw(ProcessLaunchError(filename, linux-error-msg()))
    ;Return the newly created process.
    return proc

  ;Convert a tuple of key-value pairs into the array of strings as required by Linux.
  lostanza defn to-linux-env-var-string (env-vars:ref<Tuple<KeyValue<String,String>>|False>) -> ptr<ptr<byte>> :
    match(env-vars) :
      (env-vars:ref<False>) :
        return null
      (env-vars:ref<Tuple<KeyValue<String,String>>>) :        
        val n = env-vars.length
        val scratch = ByteBuffer()
        val env-array:ptr<ptr<byte>> = call-c clib/malloc((n + 1) * sizeof(ptr<?>))
        for (var i:int = 0, i < n, i = i + 1) :
          env-array[i] = to-env-var-entry(scratch, env-vars.items[i])
        env-array[n] = null
        return env-array

  ;Free all memory allocated for the linux env-var string.
  lostanza defn free-linux-env-var-string (str:ptr<ptr<byte>>) -> ref<False> :
    if str != null :
      var i:int = 0
      while str[i] != null :
        call-c clib/free(str[i])
        i = i + 1
      call-c clib/free(str)
    return false

  ;Return a malloc'd string representing the given key-value pair.
  lostanza defn to-env-var-entry (scratch:ref<ByteBuffer>, entry:ref<KeyValue<String,String>>) -> ptr<byte> :
    print-env-var-entry(scratch, entry)
    return copy-buffer-to-stable-memory(scratch)

  ;Fill the byte buffer with the contents of the env-var entry string.
  defn print-env-var-entry (scratch:ByteBuffer, entry:KeyValue<String,String>) -> False :
    clear(scratch)
    print(scratch, "%_=%_" % [key(entry), value(entry)])
    put(scratch, 0Y)

;Helper: Copy the given byte buffer to a malloc'd piece of stable memory.
lostanza defn copy-buffer-to-stable-memory (buffer:ref<ByteBuffer>) -> ptr<byte> :
  val n = length(buffer).value
  val data = data(buffer)
  val copy = call-c clib/malloc(n)
  call-c clib/memcpy(copy, data, n)
  return copy

;Helper: Verify valid environment variable names.
defn ensure-valid-env-var-names! (vars:Tuple<KeyValue<String,String>>|False) -> False :
  match(vars:Tuple<KeyValue<String,String>>) :
    for entry in vars do :
      if contains?(key(entry), '=') :
        fatal("Because of operating system limitations, %~ is not a valid environment variable for 'call-system'. \
               Environment variables are not allowed to contain a '=' character." % [key(entry)])

;Helper: Ensure that the given stream specifiers are valid.
defn ensure-valid-stream-specifiers (input:StreamSpecifier, output:StreamSpecifier, error:StreamSpecifier) :
  if not contains?([STANDARD-IN, PROCESS-IN], input) :
    fatal("%_ is not a valid input stream specifier." % [input])
  if not contains?([STANDARD-OUT, PROCESS-OUT, PROCESS-ERR], output) :
    fatal("%_ is not a valid output stream specifier." % [output])
  if not contains?([STANDARD-ERR, PROCESS-OUT, PROCESS-ERR], error) :
    fatal("%_ is not a valid error stream specifier." % [error])

;------------------------------------------------------------
;------------------- Error Message --------------------------
;------------------------------------------------------------
;This error message was customized and added because it is
;difficult to generate a good error message from Windows otherwise.
;The most common message during process launch is:
;  "%1 is not a valid win32 application."

public defstruct ProcessLaunchError <: SystemCallException :
  filename: String
  msg: String

defmethod print (o:OutputStream, e:ProcessLaunchError) :
  print(o, "Error when attempting to launch program %~: %_" % [filename(e), msg(e)])

;------------------------------------------------------------
;----------------- Convenient Overloads ---------------------
;------------------------------------------------------------
;Default env-var-mode is AddEnvVars.
public defn Process (filename:String,
                     args:Seqable<String>,
                     input:StreamSpecifier,
                     output:StreamSpecifier,
                     error:StreamSpecifier,
                     working-dir:String|False,
                     env-vars:Tuple<KeyValue<String,String>>|False) -> Process :
  Process(filename, args, input, output, error, working-dir, env-vars, AddEnvVars)
                                
;Default working-dir is false. Default env-vars is false.
public defn Process (filename:String, args:Seqable<String>,
                     input:StreamSpecifier, output:StreamSpecifier, error:StreamSpecifier) -> Process :
  Process(filename, args, input, output, error, false, false)

public defn Process (filename:String, args:Seqable<String>,
                     working-dir:String|False, env:Tuple<KeyValue<String,String>>|False) -> Process :
  Process(filename, args, STANDARD-IN, STANDARD-OUT, STANDARD-ERR, working-dir, env)

public defn Process (filename:String, args:Seqable<String>) :
  Process(filename, args, STANDARD-IN, STANDARD-OUT, STANDARD-ERR, false, false)

;                            Stream API
;                            ==========
public lostanza defn input-stream (p:ref<Process>) -> ref<FileOutputStream> :
  if p.input-stream == false :
    if p.input == null : fatal(String("Process has no input stream."))
    p.input-stream = new FileOutputStream{p.input, 0}
  return p.input-stream as ref<FileOutputStream>
public lostanza defn output-stream (p:ref<Process>) -> ref<InputStream> :
  if p.output-stream == false :
    if p.output == null : fatal(String("Process has no output stream."))
    p.output-stream = new FileInputStream{p.output, 0}
  return p.output-stream as ref<FileInputStream>
public lostanza defn error-stream (p:ref<Process>) -> ref<InputStream> :
  if p.error-stream == false :
    if p.error == null : fatal(String("Process has no error stream."))
    p.error-stream = new FileInputStream{p.error, 0}
  return p.error-stream as ref<FileInputStream>

;                          Initialization
;                          ==============
public lostanza defn initialize-process-launcher () -> ref<False> :
  #if-not-defined(PLATFORM-WINDOWS):
    call-c clib/initialize_launcher_process()
  return false

;                            State API
;                            =========
lostanza deftype StateStruct :
  var state: int
  var code: int
lostanza defn retrieve-state (p:ref<Process>, wait-for-termination?:ref<True|False>) -> ref<ProcessState> :
  val s = new StateStruct{0, 0}
  val ec = call-c clib/retrieve_process_state(addr!([p]), addr!([s]), (wait-for-termination? == true) as int)
  if ec != 0 :
    throw(SystemCallException(platform-error-msg()))

  ;State Codes
  val RUNNING = 0
  val DONE = 1
  val TERMINATED = 2
  val STOPPED = 3

  #if-not-defined(PLATFORM-WINDOWS):
    if s.state != RUNNING and p.pipeid != -1 :
      val res = call-c clib/delete_process_pipes(p.input, p.output, p.error, p.pipeid)
      if res < 0 :
        throw(SystemCallException(linux-error-msg()))
      p.pipeid = -1

  ;Translation
  if s.state == RUNNING :
    return ProcessRunning()
  else if s.state == DONE :
    return ProcessDone(new Int{s.code})
  else if s.state == TERMINATED :
    return ProcessTerminated(new Int{s.code})
  else if s.state == STOPPED :
    return ProcessStopped(new Int{s.code})
  else :
    return fatal(String("Unreachable"))

public lostanza defn state (p:ref<Process>) -> ref<ProcessState> :
  ;Check what is saved in the done-state field.
  match(p.done-state) :
    ;If nothing is saved, then call retrieve-state
    ;to request the current state of the process.
    (f:ref<False>) :
      ;Retrieve the state and determine whether
      ;the process is still running.
      match(retrieve-state(p, false)) :
        ;If the process is still running, then just return
        ;ProcessRunning.
        (s:ref<ProcessRunning>) :
          return s
        ;If the process has finished, then save its terminating
        ;state before returning it.
        (s:ref<ProcessState>) :
          p.done-state = s
          return s
    ;The process has already finished, and its
    ;state is saved, so just return it.
    (s:ref<ProcessState>) :
      return s

public defn* wait (p:Process) -> ProcessState :
  val s = retrieve-state(p, true)
  match(s:ProcessRunning) : wait(p)
  else : s

;                         System Call API
;                         ===============
public defn call-system (filename:String,
                         args:Seqable<String>,
                         working-dir:String|False,
                         env-vars:Tuple<KeyValue<String,String>>|False) -> Int :
  match(wait(Process(filename, args, working-dir, env-vars))) :
    (s:ProcessDone) : value(s)
    (s) : throw(ProcessAbortedError(s))  

public defn call-system (file:String, args:Seqable<String>) -> Int :
  call-system(file, args, false, false)

public defn call-system (args:Tuple<String>,
                         working-dir:String|False,
                         env-vars:Tuple<KeyValue<String,String>>|False) -> Int :
  if empty?(args) :                       
    fatal("Arguments must have length 1. Program name is expected to be first argument.")
  call-system(args[0], args, working-dir, env-vars)

public defn call-system (args:Tuple<String>) -> Int :
  if empty?(args) :                       
    fatal("Arguments must have minimum length 1. Program name is expected to be first argument.")
  call-system(args[0], args, false, false)

;============================================================
;=========== Call System and Retrieve Output ================
;============================================================

public defn call-system-and-get-output (file:String,
                                        args:Seqable<String>,
                                        working-dir:String|False,
                                        env-vars:Tuple<KeyValue<String,String>>|False) -> String :
  val buffer = StringBuffer()
  val proc = Process(file, args, STANDARD-IN, PROCESS-OUT, PROCESS-OUT, working-dir, env-vars)
  val proc-out = output-stream(proc)
  let loop () :
    val c = get-char(proc-out)
    match(c:Char) :
      add(buffer,c)
      loop()
  wait(proc)
  to-string(buffer)

public defn call-system-and-get-output (file:String, args:Seqable<String>) -> String :
  call-system-and-get-output(file, args, false, false)

public defn call-system-and-get-output (args:Tuple<String>,
                                        working-dir:String|False,
                                        env-vars:Tuple<KeyValue<String,String>>|False) -> String :
  if empty?(args) :                       
    fatal("Arguments must have minimum length 1. Program name is expected to be first argument.")  
  call-system-and-get-output(args[0],
                             args,
                             working-dir,
                             env-vars)

public defn call-system-and-get-output (args:Tuple<String>) -> String :
  if empty?(args) :                       
    fatal("Arguments must have minimum length 1. Program name is expected to be first argument.")  
  call-system-and-get-output(args[0], args, false, false)

;============================================================
;=============== Replace Current Process ====================
;============================================================

public defn replace-current-process (path:String, args:Tuple<String>) :
  replace-current-process(path, args, true)

public lostanza defn replace-current-process (path:ref<String>,
                                              args:ref<Tuple<String>>,
                                              resolve-path?:ref<True|False>) -> ref<Void> :
  ;Create null-terminated C-array of arguments
  val len = length(args).value
  val argvs:ptr<ptr<byte>> = call-c clib/malloc((len + 1) * sizeof(ptr<byte>))
  for (var i:long = 0L, i < len, i = i + 1) :
    argvs[i] = addr!(args.items[i].chars)
  argvs[len] = null
  ;Call either execvp or execv
  var result:int
  if resolve-path? == true :
    result = call-c clib/execvp(addr!(path.chars), argvs)
  else :
    result = call-c clib/execv(addr!(path.chars), argvs)
  ;Issue error
  return throw(SystemCallException(linux-error-msg()))

;============================================================
;================== Shell Escaping ==========================
;============================================================

;Tokenize shell command:
;The C programming language models incoming command-line arguments as
;an array of strings, however when interacting with the terminal,
;the user actually types in a shell command as a single long string.
;This function takes as input the shell command typed by the user
;and tokenizes it into the array of strings that would be
;passed to the C main function.

public defn tokenize-shell-command (s:String) -> Collection<String> :
  defn whitespace? (c:Char) :
    (c == ' ') or
    (c == '\n') or
    (c == '\t') or
    (c == '\b') or
    (c == '\r')

  ;Buffer management
  val buffer = StringBuffer()
  val args = Vector<String>()
  defn add-char (c:Char) :
    add(buffer, c)
  defn make-arg () :
    add(args, to-string(buffer))
    clear(buffer)

  ;View characters as stream
  val stream = StringInputStream(s)

  ;Determine whether backslashes are an escape
  ;character
  val backslash-escape? = CURRENT-PLATFORM is OS-X|Linux

  ;General read dispatch
  defn* read () :
    val c = peek?(stream)
    match(c:Char) :
      if whitespace?(c) :
        get-char(stream)
        read()
      else :
        read-arg()

  defn* read-arg () :
    val c = peek?(stream)
    match(c:Char) :
      if whitespace?(c) :
        make-arg()
        read()
      else if c == '"' or c == '\'' :
        get-char(stream)
        read-until(c)
        read-arg()
      else if backslash-escape? and c == '\\' :
        get-char(stream)
        val c2 = get-char(stream)
        match(c2:Char) :
          add-char(c2)
          read-arg()
        else :
          make-arg()
      else :
        get-char(stream)
        add-char(c)
        read-arg()
    else :
      make-arg()


  defn* read-until (end:Char) :
    val c = get-char(stream)
    match(c:Char) :
      if c == '\\' :
        val c2 = peek?(stream)
        match(c2:Char) :
          if c2 == end :
            get-char(stream)
            add-char(c2)
            read-until(end)
          else :
            add-char(c)
            read-until(end)
        else :
          add-char(c)
      else if c != end :
        add-char(c)
        read-until(end)

  ;End
  read()
  args

;Escape shell command:
;The C programming language models incoming command-line arguments as
;an array of strings, however when interacting with the terminal,
;the user actually types in a shell command as a single long string.
;This function takes an array of command-line arguments (as given to C)
;and returns the shell command that the user would have typed.
;Windows is handled specially in that the first argument
;must be escaped differently than the remaining arguments.

public defn escape-shell-command (args:Seqable<String>) -> String :
  defn replace-double-quotes (s:String) :
    replace(s, "\"", "\\\"")
  defn replace-backslashes (s:String) :
    replace(s, "\\", "\\\\")
  defn surround-with-quotes (s:String) :
    string-join(['"' s '"'])

  #if-defined(PLATFORM-WINDOWS) :
    defn escape (s:String, i:Int) :
      if i == 0 :
        s $> surround-with-quotes
      else :
        s $> replace-backslashes
          $> replace-double-quotes
          $> surround-with-quotes
    val escaped = seq(escape, args, 0 to false)
    to-string("%s" % [escaped])

  #else :
    defn escape (s:String) :
      s $> replace-backslashes
        $> replace-double-quotes
        $> surround-with-quotes
    to-string("%s" % [seq(escape, args)])

;============================================================
;===================== Id Pool ==============================
;============================================================

val ID-SEQ = to-seq(0 to false)
val FREE-IDS = Vector<Int>()
val OBJ-MAP = Vector<?>()

public lostanza defn box-object (x:ref<?>) -> int :
   var id:ref<Int>
   if empty?(FREE-IDS) == true : id = next(ID-SEQ)
   else : id = pop(FREE-IDS)
   set(OBJ-MAP, id, x)
   return id.value

public lostanza defn free-box (id:int) -> ref<?> :
   add(FREE-IDS, new Int{id})
   val obj = get(OBJ-MAP, new Int{id})
   set(OBJ-MAP, new Int{id}, false)
   return obj

public lostanza defn boxed-object (id:int) -> ref<?> :
   return get(OBJ-MAP, new Int{id})

;============================================================
;==================== Resources =============================
;============================================================

public deftype Resource
public defmulti free (r:Resource) -> False

protected defn with-resource<?T,?S> (f:T -> ?S, x:?T&Resource) -> S :
   try : f(x)
   finally : free(x)

;============================================================
;==================== Autofree ==============================
;============================================================
;
;lostanza deftype FreeCallback :
;   c-convention:int
;   free:ptr<(ptr<?> -> int)>
;   value:ptr<?>
;
;lostanza defn free (c:ref<FreeCallback>) -> ref<False> :
;   if c.c-convention :
;      call-c [c.free](c.value)
;   else :
;      [c.free](c.value)
;   return false
;
;public lostanza defn c-autofree-marker (free:ptr<(ptr<?> -> int)>, value:ptr<?>) -> ref<LivenessMarker> :
;   val t = LivenessTracker(new FreeCallback{1, free, value})
;   add(FREE-CALLBACKS, t)
;   return marker!(t)
;
;public lostanza defn autofree-marker (free:ptr<(ptr<?> -> int)>, value:ptr<?>) -> ref<LivenessMarker> :
;   val t = LivenessTracker(new FreeCallback{0, free, value})
;   add(FREE-CALLBACKS, t)
;   return marker!(t)
;
;val FREE-CALLBACKS = Vector<LivenessTracker<FreeCallback>>()
;add-gc-notifier $ fn () :
;   for t in FREE-CALLBACKS remove-when :
;      if marker(t) is False :
;         free(value(t))
;         true
;
;============================================================
;=================== Pretty Printer =========================
;============================================================

;                  General Interface
;                  =================

public defmulti write (o:OutputStream, x) -> False

;                Default Implementation
;                ======================

defmethod write (o:OutputStream, x) :
   print(o, x)

public defn write-all (o:OutputStream, xs:Seqable) -> False :
   val xs-seq = to-seq(xs)
   if not empty?(xs-seq) :
      write(o, next(xs-seq))
   while not empty?(xs-seq) :
      print(o, " ")
      write(o, next(xs-seq))

;                 Convenience Functions
;                 =====================


public defn writeln (o:OutputStream, x) :
  write(o, x)
  print(o, NL)

public defn lnwrite (o:OutputStream, x) :
  print(o, NL)
  write(o, x)

public defn writeln-all (o:OutputStream, xs:Seqable) :
  write-all(o, xs)
  print(o, NL)

public defn written (x) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      write(o, x)

;              Write to Current Output Stream
;              ==============================

public defn write (x) :
  write(CURRENT-OUTPUT-STREAM, x)

public defn write-all (xs:Seqable) :
  write-all(CURRENT-OUTPUT-STREAM, xs)

public defn writeln (x) :
  writeln(CURRENT-OUTPUT-STREAM, x)

public defn lnwrite (x) :
  lnwrite(CURRENT-OUTPUT-STREAM, x)

public defn writeln-all (xs:Seqable) :
  writeln-all(CURRENT-OUTPUT-STREAM, xs)


;                    Escape Sequences
;                    ================

defn general-escape (o:OutputStream, c:Char) :
  defn escape (c:Char) :
    print(o, '\\')
    print(o, c)
  switch {c == _} :
    to-char(0x07Y) : escape('a')
    to-char(0x1bY) : escape('e')
    to-char(0x0CY) : escape('f')
    to-char(0x0BY) : escape('v')
    '\"' : escape('\"')
    '\'' : escape('\'')
    '\t' : escape('t')
    '\b' : escape('b')
    '\r' : escape('r')
    '\n' : escape('n')
    '\\' : escape('\\')
    else : print(o, c)

defn escape-for-string (o:OutputStream, c:Char) :
   if c == '\"' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

defn escape-for-symbol (o:OutputStream, c:Char) :
   if c == '|' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

defn escape-for-char (o:OutputStream, c:Char) :
   if c == '\'' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

;              Determination Whether Symbol Requires Escape
;              ============================================

lostanza var NECESSARY-IDENTIFIER-CHARS:ref<String>
lostanza var IDENTIFIER-CHARS:ref<String>
lostanza var OPERATOR-CHARS:ref<String>

lostanza defn tag-char (table:ref<String>, c:byte) -> int :
   table.chars[c] = 1 as byte
   return 0

lostanza defn tag-chars (table:ref<String>, cs:ptr<byte>) -> int :
   for (var i:long = 0, 1, i = i + 1) :
      val c = cs[i]
      if c == 0 : return 0
      tag-char(table, c)
   fatal("Unreachable")
   return 0

lostanza let :
  NECESSARY-IDENTIFIER-CHARS = String(256, 0 as byte)
  IDENTIFIER-CHARS = String(256, 0 as byte)
  OPERATOR-CHARS = String(256, 0 as byte)

  val L = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
  val U = "_?"
  val D = "0123456789"
  val P = "~!@#$%^*+-=/"
  val S = ".:<>&|"

  tag-chars(NECESSARY-IDENTIFIER-CHARS, L)
  tag-chars(NECESSARY-IDENTIFIER-CHARS, U)

  tag-chars(IDENTIFIER-CHARS, L)
  tag-chars(IDENTIFIER-CHARS, U)
  tag-chars(IDENTIFIER-CHARS, D)
  tag-chars(IDENTIFIER-CHARS, P)

  tag-chars(OPERATOR-CHARS, P)
  tag-chars(OPERATOR-CHARS, S)

public deftype SymbolParseClass
public defstruct NumberClass <: SymbolParseClass
public defstruct IdentifierClass <: SymbolParseClass
public defstruct OperatorClass <: SymbolParseClass

defmethod print (o:OutputStream, c:SymbolParseClass) :
  print{o, _} $ match(c) :
    (c:NumberClass) : "Number"
    (c:IdentifierClass) : "Identifier"
    (c:OperatorClass) : "Operator"

lostanza defn digit-char? (b:byte) -> long :
  if b >= '0' and b <= '9' : return 1
  else : return 0

lostanza defn gensymbol? (s:ref<Symbol>) -> long :
  match(s) :
    (s:ref<GenSymbol>) : return 1
    (s) : return 0

public lostanza defn parse-as? (c:ref<Symbol>) -> ref<SymbolParseClass|False> :
  ;Does it parse as a number?
  val name = name(c)
  val l = length(name).value
  if (l == 0 and gensymbol?(c)) or
     digit-char?(name.chars[0]) or
     (name.chars[0] == '-' and l == 1 and gensymbol?(c)) or
     (name.chars[0] == '-' and l > 1 and digit-char?(name.chars[1])) :
    return NumberClass()

  ;Collect statistics
  var all-id:long = 1
  var all-op:long = 1
  var has-nid:long = 0
  for (var i:long = 0, i < l, i = i + 1) :
    val c = name.chars[i]
    if NECESSARY-IDENTIFIER-CHARS.chars[c] == 1 : has-nid = 1
    if IDENTIFIER-CHARS.chars[c] == 0 : all-id = 0
    if OPERATOR-CHARS.chars[c] == 0 : all-op = 0
  if gensymbol?(c) : all-op = 0

  ;Classify
  if l == 0 : return false
  else if all-id and has-nid : return IdentifierClass()
  else if all-op : return OperatorClass()
  else : return false

public defn escape? (s:Symbol) :
  parse-as?(s) is NumberClass|False

;                  Escaped Primitive Values
;                  ========================

defmethod write (o:OutputStream, c:Char) :
   print(o, '\'')
   escape-for-char(o, c)
   print(o, '\'')

defmethod write (o:OutputStream, s:String) :
   print(o, '"')
   for c in s do :
      escape-for-string(o, c)
   print(o, '"')

defmethod write (o:OutputStream, x:Byte) :
   print(o, x)
   print(o, 'Y')

defmethod write (o:OutputStream, x:Long) :
   print(o, x)
   print(o, 'L')

defmethod write (o:OutputStream, b:Float) :
   print(o, b)
   print(o, 'f')

defmethod write (o:OutputStream, s:StringSymbol) :
   if escape?(s) :
      print(o, "\\|")
      for c in name(s) do :
         escape-for-symbol(o, c)
      print(o, '|')
   else :
      print(o, name(s))

defmethod write (o:OutputStream, s:GenSymbol) :
   if escape?(s) :
      print(o, "\\|")
      for c in name(s) do :
         escape-for-symbol(o, c)
      print(o, id(s))
      print(o, '|')
   else :
      print(o, name(s))
      print(o, id(s))

;============================================================
;===================== Timers ===============================
;============================================================

public lostanza defn current-time-ms () -> ref<Long> :
   val ms = call-c clib/current_time_ms()
   return new Long{ms}

public lostanza defn current-time-us () -> ref<Long> :
   val us = call-c clib/current_time_us()
   return new Long{us}

public deftype Timer
public defmulti start (t:Timer) -> False
public defmulti stop (t:Timer) -> False
public defmulti time (t:Timer) -> Long
public defmulti running? (t:Timer) -> True|False

defn Timer (name:String, get-time: () -> Long) :
   var total-time:Long = 0L
   var last-time:Long = 0L
   var running = false
   new Timer :
      defmethod start (this) :
         fatal("Timer already running.") when running
         last-time = get-time()
         running = true
      defmethod stop (this) :
         fatal("Timer is not running.") when not running
         val time = get-time()
         total-time = total-time + time - last-time
         last-time = time
         running = false
      defmethod time (this) :
         if running : total-time + get-time() - last-time
         else : total-time
      defmethod running? (this) :
         running
      defmethod print (o:OutputStream, this) :
         print(o, "[%_ Timer : %_]" % [name, time(this)])

public defn MillisecondTimer (name:String) :
   Timer(name, current-time-ms)

public defn MicrosecondTimer (name:String) :
   Timer(name, current-time-us)

public defn PiggybackTimer (name:String, t:Timer) :
   Timer(name, time{t})

;============================================================
;==================== Reified Types =========================
;============================================================

public deftype TypeObject<T>
public defmulti typeof?<?T> (x, t:TypeObject<?T>) -> True|False
public defmulti name (t:TypeObject) -> String

;############################################################
;################## Math Package ############################
;############################################################

defpackage math :
   import core

public lostanza val PI:ref<Double> = new Double{3.141592653589793}
public lostanza val PI-F:ref<Float> = new Float{3.1415927f}

public lostanza defn exp (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/exp(x.value)}
public lostanza defn exp (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/exp(x.value) as float}

public lostanza defn log (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/log(x.value)}
public lostanza defn log (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/log(x.value) as float}

public lostanza defn log10 (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/log10(x.value)}
public lostanza defn log10 (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/log10(x.value) as float}

public lostanza defn sqrt (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sqrt(x.value)}
public lostanza defn sqrt (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sqrt(x.value) as float}

public lostanza defn pow (x:ref<Double>, y:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/pow(x.value, y.value)}
public lostanza defn pow (x:ref<Float>, y:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/pow(x.value, y.value) as float}

public lostanza defn sin (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sin(x.value)}
public lostanza defn sin (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sin(x.value) as float}

public lostanza defn cos (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/cos(x.value)}
public lostanza defn cos (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/cos(x.value) as float}

public lostanza defn tan (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/tan(x.value)}
public lostanza defn tan (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/tan(x.value) as float}

public lostanza defn asin (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/asin(x.value)}
public lostanza defn asin (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/asin(x.value) as float}

public lostanza defn acos (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/acos(x.value)}
public lostanza defn acos (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/acos(x.value) as float}

public lostanza defn atan (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/atan(x.value)}
public lostanza defn atan (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/atan(x.value) as float}

public lostanza defn atan2 (y:ref<Double>, x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/atan2(y.value, x.value)}
public lostanza defn atan2 (y:ref<Float>, x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/atan2(y.value, x.value) as float}

public lostanza defn sinh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sinh(x.value)}
public lostanza defn sinh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sinh(x.value) as float}

public lostanza defn cosh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/cosh(x.value)}
public lostanza defn cosh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/cosh(x.value) as float}

public lostanza defn tanh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/tanh(x.value)}
public lostanza defn tanh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/tanh(x.value) as float}

public lostanza defn ceil (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/ceil(x.value)}
public lostanza defn ceil (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/ceil(x.value) as float}

public lostanza defn floor (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/floor(x.value)}
public lostanza defn floor (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/floor(x.value) as float}

public lostanza defn round (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/round(x.value)}
public lostanza defn round (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/round(x.value) as float}

public lostanza defn to-radians (degrees:ref<Double>) -> ref<Double> :
   val pi = 3.141592653589793
   return new Double{degrees.value * pi / 180.0}

public lostanza defn to-degrees (radians:ref<Double>) -> ref<Double> :
   val pi = 3.141592653589793
   return new Double{radians.value * 180.0 / pi}
