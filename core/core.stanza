;################################################################################
;############################## C Library #######################################
;################################################################################

;================================================================================
;================================ Boot Sequence =================================
;================================================================================

defpackage clib

protected extern memcpy: (ptr<?>, ptr<?>, long) -> int
protected extern remove: (ptr<byte>) -> int
protected extern rename: (ptr<byte>, ptr<byte>) -> int
protected extern ftell: (ptr<?>) -> long
protected extern fclose: (ptr<?>) -> int
protected extern fflush: (ptr<?>) -> int
protected extern fopen: (ptr<byte>, ptr<byte>) -> ptr<?>
protected extern fputs: (ptr<byte>, ptr<?>) -> int
protected extern fputc: (byte, ptr<?>) -> int
protected extern fgetc: (ptr<?>) -> int
protected extern ferror: (ptr<?>) -> int
protected extern fprintf: (ptr<?>, ptr<byte>, ? ...) -> int
protected extern sprintf: (ptr<byte>, ptr<byte>, ? ...) -> int
protected extern sscanf: (ptr<byte>, ptr<byte>, ptr<?> ...) -> int
protected extern printf: (ptr<byte>, ? ...) -> int
protected extern malloc: long -> ptr<?>
protected extern stz_malloc: long -> ptr<?>
protected extern free: ptr<?> -> int
protected extern stz_free: ptr<?> -> int
protected extern exit: int -> int
protected extern get_stdout: () -> ptr<?>
protected extern get_stderr: () -> ptr<?>
protected extern get_stdin: () -> ptr<?>
protected extern get_eof: () -> int
protected extern input_argc: int
protected extern input_argv: ptr<ptr<byte>>
protected extern input_argv_needs_free: int
protected extern strlen: ptr<byte> -> int
protected extern current_time_us: () -> long
protected extern current_time_ms: () -> long
protected extern getenv: (ptr<byte>) -> ptr<byte>
protected extern setenv: (ptr<byte>, ptr<byte>, int) -> int
protected extern unsetenv: (ptr<byte>) -> int
protected extern system: (ptr<byte>) -> int
protected extern strerror: (int) -> ptr<byte>
protected extern get_errno: () -> int
protected extern resolve_path: (ptr<byte>) -> ptr<byte>
protected extern get_file_size: ptr<?> -> long
protected extern file_set_length: (ptr<?>, long) -> int
protected extern file_seek: (ptr<?>, long) -> int
protected extern file_skip: (ptr<?>, long) -> int
protected extern file_read_block: (ptr<?>, ptr<byte>, long) -> long
protected extern file_write_block: (ptr<?>, ptr<byte>, long) -> long
protected extern file_time_modified: ptr<byte> -> long

;Process libraries
protected extern launch_process: (ptr<byte>, ptr<ptr<byte>>, int, int, int, ptr<?>) -> int
protected extern retrieve_process_state: (long, ptr<?>) -> int
protected extern initialize_launcher_process: () -> int

;Math libraries
protected extern exp: double -> double
protected extern log: double -> double
protected extern log10: double -> double
protected extern sqrt: double -> double
protected extern pow: (double, double) -> double
protected extern sin: double -> double
protected extern cos: double -> double
protected extern tan: double -> double
protected extern asin: double -> double
protected extern acos: double -> double
protected extern atan: double -> double
protected extern atan2: (double, double) -> double
protected extern sinh: double -> double
protected extern cosh: double -> double
protected extern tanh: double -> double
protected extern ceil: double -> double
protected extern floor: double -> double
protected extern round: double -> double

;################################################################################
;############################## Core Library ####################################
;################################################################################

;================================================================================
;=============================== Boot Sequence ==================================
;================================================================================

defpackage core :
  import collections

;============================================================
;===================== Internal Types =======================
;============================================================

protected lostanza deftype Fn :
   length: long
   code: ptr<?>
   free: ref<?> ...
protected lostanza deftype Box :
   item: ref<?>
protected lostanza deftype Type :
   length: long
   code: ptr<?>
   free: ref<?> ...
protected lostanza deftype StackFrame :
  return: long
  liveness-map: long
  slots: long ...
protected lostanza deftype Stack :
  size: long
  frames: ptr<StackFrame>
  stack-pointer: ptr<StackFrame>
  pc: long

lostanza deftype GlobalRoots :
  length: int
  roots: int ...

lostanza deftype StackMap :
  size: int
  num-roots: int
  roots: int ...

lostanza deftype FileInfoTable :
  length: long
  entries: FileInfoEntry ...

lostanza deftype FileInfoEntry :
  lbl: ptr<?>
  file: ptr<byte>
  line: int
  column: int

lostanza deftype ClassRecord :
  name:ptr<byte>
  size:int
  item-size:int
  num-roots:int
  roots:int ...

lostanza deftype ArrayRecord :
  name:ptr<byte>
  base-size:int
  item-size:int
  num-base-roots:int
  num-item-roots:int
  roots:int ...

protected lostanza deftype VMState :
  ;Permanent State
  ;Changes in-between each code load
  instructions: ptr<byte>
  registers: ptr<long>
  global-offsets: ptr<long>
  global-mem: ptr<byte>
  const-table: ptr<long>
  const-mem: ptr<byte>
  data-offsets: ptr<int>
  data-mem: ptr<byte>
  code-offsets: ptr<int>
  ;Variable State
  ;Changes in-between each boundary change
  heap: ptr<long>
  heap-top: ptr<long>
  heap-limit: ptr<long>
  free: ptr<long>
  free-limit: ptr<long>
  current-stack: long
  ;Need for system stubs
  system-stack: long
  system-registers: ptr<long>
  ;Tables
  class-table: ptr<ptr<ClassRecord>>
  global-root-table: ptr<GlobalRoots>
  stackmap-table: ptr<ptr<StackMap>>
  info-table: ptr<FileInfoTable>
  extern-table: ptr<ExternTable>
  callback-index-table: ptr<ExternDefnTable>

lostanza deftype ExternTable :
  length: long
  entries: ExternEntry ...

lostanza deftype ExternEntry :
  name:ptr<byte>
  address:long

lostanza deftype ExternDefnTable :
  length: long
  entries: ExternDefnEntry ...

lostanza deftype ExternDefnEntry :
  name:ptr<byte>
  index:long

;============================================================
;================== Internal Callbacks ======================
;============================================================

protected lostanza defn arity-error (arity:long) -> ref<Void> :
  return fatal(arity-message(new Int{arity as int}))
defn arity-message (arity:Int) :
  "Function cannot be called with %_ arguments." % [arity]

protected defn no-method-error (multi:String, args:Tuple) :
  fatal("Multi %_ has no appropriate method for arguments of type (%,)." % [multi, seq(object-type,args)])

protected defn amb-method-error (multi:String, args:Tuple) :
  fatal("Multi %_ has multiple appropriate methods for arguments of type (%,)." % [multi, seq(object-type,args)])

protected defn no-branch-error (args:Tuple) :
  fatal("No appropriate branch for arguments of type (%,)." % [seq(object-type, args)])

protected defn amb-branch-error (args:Tuple) :
  fatal("Multiple appropriate branches for arguments of type (%,)." % [seq(object-type, args)])

protected lostanza defn tuple-length-error (actual-len:long, expected-len:long) -> ref<Void> :
  return fatal(tuple-length-message(new Int{actual-len as int}, new Int{expected-len as int}))
defn tuple-length-message (actual-len:Int, expected-len:Int) :
  "Cannot destructure tuple of length %_ into %_ items." % [actual-len, expected-len]

protected defn variable-uninitialized-error (name:String|False) -> Void :
  match(name) :
    (name:String) : fatal("Variable %_ has not been initialized." % [name])
    (name:False) : fatal("Variable has not been initialized.")

protected lostanza defn cast-error (type:ref<Type>, obj:ref<?>, ctxt:int) -> ref<Void> :
  return fatal(cast-message(type, obj, new Int{ctxt}))

protected lostanza defn invalid-return-error () -> ref<Void> :
  return fatal("Unexpected return from function declared with Void return type.")

defn cast-message (t:Type, x, ctxt:Int) :
  val objt = object-type(x)
  switch(ctxt) :
    0 : "Cannot cast value of type %_ to type %_." % [objt, t]
    1 : "Argument was expected to be of type %_, but was passed a value of type %_." % [
          t, objt]
    2 : "The expected return type of this function is %_, but a value of type %_ was returned." % [
          t, objt]
    3 : "Cannot initialize a variable of type %_ with a value of type %_." % [t, objt]
    4 : "Cannot assign a value of type %_ to a variable with declared type %_." % [objt, t]
    5 : "Cannot call a value of type %_ as if it were a function." % [objt]
    6 : "Cannot deconstruct a value of type %_ into a tuple." % [objt]
    7 : "The variable was expected to have type %_, but we retrieved a value of type %_ from it." % [
          t, objt]
    8 : "Branch argument was expected to be of type %_, but was passed a value of type %_." % [
          t, objt]

;============================================================
;=================== Fatal Errors ===========================
;============================================================

public lostanza defn fatal! (msg:ptr<byte>) -> ref<Void> :
  call-c clib/fflush(stdout)
  call-c clib/fprintf(current-err, "FATAL ERROR: %s\n", msg)
  print-stack-trace()
  call-c clib/exit(-1)
  ;Unreachable
  return false as ref<?>

public lostanza defn fatal (msg:ptr<byte>) -> ref<Void> :
  call-c clib/fflush(stdout)
  call-c clib/fprintf(current-err, "FATAL ERROR: %s\n", msg)
  print-stack-trace()
  return halt()

public defn fatal (msg) -> Void :
  flush(STANDARD-OUTPUT-STREAM as FileOutputStream)
  print(CURRENT-ERROR-STREAM, "FATAL ERROR: ")
  println(CURRENT-ERROR-STREAM, msg)
  print-stack-trace()
  halt()

public lostanza defn print-stack-trace () -> ref<False> :
  call-prim flush-vm()
  labels :
    begin :
      goto loop(current-coroutine)
    loop (co:ref<RawCoroutine>) :
      call-prim print-stack-trace(co.stack)
      match(co.parent) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : ()
  return false

var EXECUTION-HALT:() -> Void

defn halt () -> Void :
  EXECUTION-HALT()

defn initialize-launcher () :
  EXECUTION-HALT = fn () : exit(-1)

defn execute-toplevel-command (f:() -> False) :
  label break :
    let-var EXECUTION-HALT = break :
      f()

public defn* execute-with-error-handler<?T> (f:() -> ?T, fail:() -> ?T) :
  val result = label<Maybe<T>> break :
    defn fail () : break(None())
    One $ let-var EXECUTION-HALT = fail : f()
  fail() when empty?(result) else value!(result)

public defn execute-with-halt-interceptor<?T> (body:() -> ?T, halt-function:() -> Void) -> T :
  let-var EXECUTION-HALT = halt-function :
    body()

;============================================================
;================== Pointer Copying =========================
;============================================================

protected lostanza defn resize-ptr (p:ptr<?>, oldsize:long, newsize:long) -> ptr<?> :
  val p2 = call-c clib/stz_malloc(newsize)
  call-c clib/memcpy(p2, p, oldsize)
  call-c clib/stz_free(p)
  return p2

;============================================================
;===================== Stack Trace ==========================
;============================================================

lostanza defn print-stack-trace (stack:ref<Stack>) -> ref<False> :
  val vms:ptr<VMState> = call-prim flush-vm()

  ;Discover return addresses
  val buffer = LSLongVector()

  val end-sp = stack.stack-pointer
  labels :
    begin : goto loop(stack.frames)
    loop (sp:ptr<StackFrame>) :
      ;Store in return buffer
      add(buffer, sp.return)

      ;Continue if we're not at the end of the stack
      if sp < end-sp :
        val map-index = sp.liveness-map
        val stackmap = vms.stackmap-table[map-index]
        goto loop(sp + stackmap.size)

  ;Print buffer
  for (var i:long = buffer.length - 1, i >= 0, i = i - 1) :
    val entry = file-info-entry(buffer.items[i], vms.info-table)
    if entry != null :
      call-c clib/fprintf(current-err, "  at %s:%d.%d\n", entry.file, entry.line, entry.column)

  ;Free the buffer
  free(buffer)
  return false

lostanza defn file-info-entry (ret:long, info-table:ptr<FileInfoTable>) -> ptr<FileInfoEntry> :
  for (var i:int = 0, i < info-table.length, i = i + 1) :
    val entry-addr = addr(info-table.entries[i])
    val entry = info-table.entries[i]
    if ret == (entry.lbl as long) :
      return addr(info-table.entries[i])
  return null

;============================================================
;====================== LS Long Vector ======================
;============================================================

lostanza deftype LSLongVector :
  capacity: int
  length: int
  items: ptr<long>

lostanza defn LSLongVector (capacity:int) -> ptr<LSLongVector> :
  val v:ptr<LSLongVector> = call-c clib/stz_malloc(sizeof(LSLongVector))
  v.capacity = capacity
  v.length = 0
  v.items = call-c clib/stz_malloc(capacity * sizeof(long))
  return v

lostanza defn LSLongVector () -> ptr<LSLongVector> :
  return LSLongVector(8)

lostanza defn ensure-capacity (v:ptr<LSLongVector>, new-capacity:int) -> int :
  if v.capacity < new-capacity :
    var c:int = v.capacity
    while c < new-capacity : c = c * 2
    v.items = resize-ptr(v.items, v.capacity * sizeof(long), c * sizeof(long))
    v.capacity = c
  return 0

lostanza defn add (v:ptr<LSLongVector>, x:long) -> int :
  ensure-capacity(v, v.length + 1)
  v.items[v.length] = x
  v.length = v.length + 1
  return 0

lostanza defn free (v:ptr<LSLongVector>) -> int :
  call-c clib/stz_free(v.items)
  call-c clib/stz_free(v)
  return 0

;============================================================
;==================== Class Name ============================
;============================================================

lostanza defn class-name (x:int) -> ptr<byte> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val record = vms.class-table[x]
  return record.name

;============================================================
;======================= Core Types =========================
;============================================================

public lostanza deftype Byte :
  value: byte

public lostanza deftype Char :
  value: byte

public lostanza deftype Int :
  value: int

public lostanza deftype Long :
  value: long

public lostanza deftype Float :
  value: float

public lostanza deftype Double :
  value: double

public lostanza deftype String :
  length: long
  hash: int
  chars: byte ...

public deftype Symbol
public lostanza deftype StringSymbol <: Symbol :
  name: ref<String>
public deftype GenSymbol <: Symbol

public lostanza deftype True
public lostanza deftype False

public lostanza deftype Tuple<T> :
  length: long
  items: ref<T> ...

public deftype List<T>
lostanza deftype FullList<T> <: List<T> :
  head: ref<T>
  tail: ref<List<T>>
lostanza deftype NilList <: List<Void>

public deftype Coroutine<I,O>

;============================================================
;============== Standard Streams ============================
;============================================================

lostanza val stdout:ptr<?> = call-c clib/get_stdout()
lostanza val stderr:ptr<?> = call-c clib/get_stderr()
lostanza val stdin:ptr<?> = call-c clib/get_stdin()
lostanza val EOF:int = call-c clib/get_eof()

;============================================================
;================ Constant Initialization ===================
;============================================================

lostanza var const-ptr:ptr<?>
lostanza val BYTE-CONST-TAG : int = 0
lostanza val CHAR-CONST-TAG : int = 1
lostanza val INT-CONST-TAG : int = 2
lostanza val LONG-CONST-TAG : int = 3
lostanza val FLOAT-CONST-TAG : int = 4
lostanza val DOUBLE-CONST-TAG : int = 5
lostanza val TRUE-CONST-TAG : int = 6
lostanza val FALSE-CONST-TAG : int = 7
lostanza val LIST-CONST-TAG : int = 8
lostanza val STRING-CONST-TAG : int = 9
lostanza val SYMBOL-CONST-TAG : int = 10
lostanza val TYPE-CONST-TAG : int = 11
lostanza val FN-CONST-TAG : int = 12
lostanza val INTERNED-CONST-TAG : int = 13
lostanza var initialized-symbol-table? : long = 0L
lostanza var consts-top : long = 4L
lostanza var num-loaded-consts : long = 0L

protected lostanza defn initialize-constants () -> ref<False> :
  ;Initialize read pointer to beginning of the constant table
  ;[num, constants ...]
  val vms:ptr<VMState> = call-prim flush-vm()
  val consts-data = vms.const-mem

  ;Read total number of constants
  const-ptr = consts-data
  val n-consts = read-const-int()

  ;Populate constants vector
  const-ptr = consts-data + consts-top
  var cs:ptr<ref<?>> = vms.const-table as ptr<ref<?>>
  while num-loaded-consts < n-consts :
    cs[num-loaded-consts] = read-const(vms)
    num-loaded-consts = num-loaded-consts + 1

  ;Set new top
  consts-top = const-ptr - consts-data
  return false

lostanza defn read-const (vms:ptr<VMState>) -> ref<?> :
  val tag = read-const-int()
  if tag == BYTE-CONST-TAG :
    return new Byte{read-const-byte()}
  else if tag == CHAR-CONST-TAG :
    return new Char{read-const-byte()}
  else if tag == INT-CONST-TAG :
    return new Int{read-const-int()}
  else if tag == LONG-CONST-TAG :
    return new Long{read-const-long()}
  else if tag == FLOAT-CONST-TAG :
    return new Float{read-const-float()}
  else if tag == DOUBLE-CONST-TAG :
    return new Double{read-const-double()}
  else if tag == TRUE-CONST-TAG :
    return true
  else if tag == FALSE-CONST-TAG :
    return false
  else if tag == LIST-CONST-TAG :
    val len = read-const-int()
    return read-const-list(len, vms)
  else if tag == STRING-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)
    return String(len, chars)
  else if tag == SYMBOL-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)
    val str = String(len, chars)
    if initialized-symbol-table? : return to-symbol(str)
    else : return new StringSymbol{str}
  else if tag == TYPE-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Type{0, code}
  else if tag == FN-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Fn{0, code}
  else if tag == INTERNED-CONST-TAG :
    val i = read-const-int()
    val cs = vms.const-table as ptr<ref<?>>
    return cs[i]
  else :
    call-c clib/printf("Unknown constant tag: %d\n", tag)
    return fatal("Unknown constant tag")

lostanza defn read-const-list (n:int, vms:ptr<VMState>) -> ref<List> :
  if n == 0 : return new NilList{}
  else : return new FullList{read-const(vms), read-const-list(n - 1, vms)}

lostanza defn read-const-byte () -> byte :
  val value = [const-ptr as ptr<byte>]
  const-ptr = const-ptr + sizeof(byte)
  return value

lostanza defn read-const-int () -> int :
  val value = [const-ptr as ptr<int>]
  const-ptr = const-ptr + sizeof(int)
  return value

lostanza defn read-const-long () -> long :
  val value = [const-ptr as ptr<long>]
  const-ptr = const-ptr + sizeof(long)
  return value

lostanza defn read-const-float () -> float :
  val value = [const-ptr as ptr<float>]
  const-ptr = const-ptr + sizeof(float)
  return value

lostanza defn read-const-double () -> double :
  val value = [const-ptr as ptr<double>]
  const-ptr = const-ptr + sizeof(double)
  return value

lostanza defn read-const-chars (len:long) -> ptr<byte> :
  val value = const-ptr as ptr<byte>
  ;length chars + pad to nearest 4 bytes
  val n = (len + 3) & -4
  const-ptr = (const-ptr + n) as ptr<?>
  return value

;============================================================
;=================== Garbage Collection =====================
;============================================================

lostanza var initialized-gc-notifiers? : long = 0L
lostanza var MAXIMUM-HEAP-SIZE : long = 4L * 1024L * 1024L * 1024L

lostanza defn extend-heap (size:long) -> long :
  ;Collect garbage, and ensure we freed enough space
  val remaining = call-prim collect-garbage(size)
  free-unmarked-stacks(addr(STACK-POOL))
  if remaining < size : fatal!("Out of memory.")
  ;Now run the GC notifiers, if they have been initialized
  if initialized-gc-notifiers? :
    run-gc-notifiers()
  ;If GC notifiers allocated too much space, then collect the garbage again
  ;(Happens rarely.)
  val vms:ptr<VMState> = call-prim flush-vm()
  val remaining-after-notifiers = vms.heap-limit - vms.heap-top
  if remaining-after-notifiers < size :
    ;Collect garbage, and ensure we freed enough space
    val remaining = call-prim collect-garbage(size)
    free-unmarked-stacks(addr(STACK-POOL))
    if remaining < size : fatal!("Out of memory.")  
  return 0

;============================================================
;================== GC Notifiers ============================
;============================================================

var GC-NOTIFIERS:Vector<(() -> ?)>

lostanza defn initialize-gc-notifiers () -> ref<False> :
  GC-NOTIFIERS = Vector<(() -> ?)>()
  initialized-gc-notifiers? = 1L
  return false

defn run-gc-notifiers () :
  for f in GC-NOTIFIERS do :
    f()

public defn add-gc-notifier (f: () -> ?) :
   add(GC-NOTIFIERS, f)

;<doc>=======================================================
;====================== Stack Pool ==========================
;============================================================

Concerns:
  - How do we retrieve a new stack from the stack pool?
  - How do we put a stack back into the stack pool?
  - How are the initial stacks created by the driver tracked?
  - What happens during stack extension? When we double the size of
    the current stack?
  - After GC, how do we release the frames used by all the dead
    stacks?

State of Stack Pool:
  stacks:ptr<StackFrameHeader>
    - Array holding the allocated pointers of all the frames in
      the pool.
    - The used stacks are all in the first half of the array.
    - The free stacks are in the second half of the array.
    - All stacks in the array are of size INITIAL-STACK-SIZE.
  capacity:int
    - The length of the stacks array.
  num-used:int
    - The number of used stacks in the stack pool.
  big-stacks:ptr<StackFrameHeader>
    - Array holding all the larger stacks.
  big-capacity:int
    - The length of the big-stacks array.
  big-size:int
    - The number of stacks stored in the big-stacks.

Memory Layout of Stack Frame Header:
  pool-index:int
    - The index of the stack frame in the stack pool.
    - This index is -1 if the frame does not exist in the stack pool.
  mark:int
    - This mark is 0 by default during normal operation.
    - The mark will be set to 1 during GC to indicate that the frames
      are currently in use.
  frames:StackFrame ...
    - The frames start immediately after the header. The stack size is
      counted starting from here.

Global Variables:
  INITIAL-STACK-SIZE:long
    - The size of all stacks in the stack pool.
  STACK-POOL:StackPool
    - The global stack pool.
Interface:
  take-next-stack(pool:ptr<StackPool>, size:long)
    - Retrieve a stack of the desired size from the StackPool.
  free-stack(pool:ptr<StackPool>, stack:ptr<StackFrameHeader>)
    - Release the given stack into the StackPool.
  gc-if-no-stacks(pool:ptr<StackPool>)
    - If there are no stacks available, and it is appropriate to do so,
      run the garbage collector in an effort to free up some stacks.
  free-unmarked-stacks(pool:ptr<StackPool>)
    - Free all unmarked stacks. Meant as a hook to be used by the
      garbage collector.

;============================================================
;=======================================================<doc>

lostanza deftype StackFrameHeader :
  pool-index:int
  mark:int
  frames:StackFrame ...

lostanza deftype StackPool :
  capacity:int
  num-used:int
  stacks:ptr<ptr<StackFrameHeader>>
  big-capacity:int
  big-size:int
  big-stacks:ptr<ptr<StackFrameHeader>>

lostanza defn StackPool () -> StackPool :
  ;Allocate pool for small stacks
  val capacity = 4
  val stacks:ptr<ptr<StackFrameHeader>> = call-c clib/stz_malloc(capacity * sizeof(ptr<?>))
  for (var i:int = 0, i < capacity, i = i + 1) :
    stacks[i] = alloc-stack-frames(i, INITIAL-STACK-SIZE)
  ;Allocate pool for big stacks
  val big-capacity = 4
  val big-stacks = call-c clib/stz_malloc(big-capacity * sizeof(ptr<?>))
  return StackPool{capacity, 0, stacks, big-capacity, 0, big-stacks}

lostanza defn ensure-capacity (pool:ptr<StackPool>, capacity:int) -> int :
  ;Do something only if we are under capacity
  if pool.capacity < capacity :
    ;Double the capacity until it reaches desired capacity
    var c:int = pool.capacity
    while c < capacity : c = c * 2
    ;Allocate a new stacks array, and copy the old contents over.
    pool.stacks = resize-ptr(pool.stacks, pool.capacity * sizeof(ptr<?>), c * sizeof(ptr<?>))
    ;Fill the newly-allocated slots with new stacks
    for (var i:int = pool.capacity, i < c, i = i + 1) :
      pool.stacks[i] = alloc-stack-frames(i, INITIAL-STACK-SIZE)
    ;Register the newly-increased capacity
    pool.capacity = c
  return 0

lostanza defn ensure-big-capacity (pool:ptr<StackPool>, capacity:int) -> int :
  ;Do something only if we are under capacity
  if pool.big-capacity < capacity :
    ;Double the capacity until it reaches desired capacity
    var c:int = pool.big-capacity
    while c < capacity : c = c * 2
    ;Allocate a new stacks array, and copy the old contents over.
    pool.big-stacks = resize-ptr(pool.big-stacks, pool.big-capacity * sizeof(ptr<?>), c * sizeof(ptr<?>))
    ;Register the newly-increased capacity
    pool.big-capacity = c
  return 0

lostanza defn alloc-stack-frames (index:int, size:long) -> ptr<StackFrameHeader> :
  ;The total size of the StackFrame object is the size of the header
  ;with the size of the stack frames.
  val frame-size = sizeof(StackFrameHeader) + size
  val fh:ptr<StackFrameHeader> = call-c clib/stz_malloc(frame-size)
  ;Initialize parameters and return
  fh.pool-index = index
  ;call-c clib/printf("A) set pool index of %p to %d\n", fh, index)
  fh.mark = 0
  return fh

lostanza defn print-pool-state (pool:ptr<StackPool>) -> int :
  call-c clib/printf("Pool State:\n")
  var good?:int = 1
  for (var i:int = 0, i < pool.capacity, i = i + 1) :
    val s = pool.stacks[i]
    call-c clib/printf("%d) %p (index = %d, mark = %d)", i, s, s.pool-index, s.mark)
    if i != s.pool-index : good? = 0
    if i < pool.num-used :
      call-c clib/printf(" (used)\n")
    else :
      call-c clib/printf("\n")
  if good? == 0 :
    call-c clib/printf("corrupted state\n")
    call-c clib/exit(-1)

  return 0

lostanza defn take-next-stack (pool:ptr<StackPool>, size:long) -> ptr<StackFrameHeader> :
  ;call-c clib/printf("take-next-stack(%ld)\n", size)
  ;If the size is equal to INITIAL-STACK-SIZE then allocate the stack
  ;from the stack pool.
  if size == INITIAL-STACK-SIZE :
    ;call-c clib/printf("Request a standard stack\n")
    ;call-c clib/printf("There are %d used stacks\n", pool.num-used)
    ;Create more stacks if none available
    ensure-capacity(pool, pool.num-used + 1)
    ;Retrieve the next free stack
    val s = pool.stacks[pool.num-used]
    ;Increment the number of used stacks
    pool.num-used = pool.num-used + 1
    ;call-c clib/printf("Return new standard stack frame %p (index = %d)\n", s, s.pool-index)
    ;Return the stack
    return s
  ;Otherwise, allocate the stack from the big pool.
  else :
    ;Allocate the stack frame object
    val s = alloc-stack-frames(-1, size)
    ;And register it within the big pool
    ensure-big-capacity(pool, pool.big-size + 1)
    pool.big-stacks[pool.big-size] = s
    pool.big-size = pool.big-size + 1
    ;Return the stack
    ;call-c clib/printf("Return new big stack frame %p\n", s)
    return s

lostanza defn free-stack (pool:ptr<StackPool>, stack:ptr<StackFrameHeader>) -> int :
  ;call-c clib/printf("free-stack(%p)\n", stack)
  ;This function does nothing if the stack is not in the stack pool.
  if stack.pool-index < 0 :
    ;call-c clib/printf("Freeing a stack %p that is not in the pool.\n", stack)
    return 0

  ;A used stack is in the first half of the pool.
  ;To return the stack, it must be moved to the second half of the pool.
  ;So swap its place with the last used one in the pool.
  ;call-c clib/printf("Free stack index %d\n", stack.pool-index)
  val swap-index = pool.num-used - 1
  ;call-c clib/printf("swap-index = %d\n", swap-index)
  if swap-index != stack.pool-index :
    val x = stack
    val xi = stack.pool-index
    val y = pool.stacks[swap-index]
    val yi = swap-index
    pool.stacks[xi] = y
    pool.stacks[yi] = x
    x.pool-index = yi
    ;call-c clib/printf("B) set pool index of %p to %d\n", x, yi)
    y.pool-index = xi
    ;call-c clib/printf("C) set pool index of %p to %d\n", y, xi)
  ;Decrement the number of used stacks
  pool.num-used = pool.num-used - 1
  ;call-c clib/printf("Now there are %d used stacks\n", pool.num-used)
  return 0

lostanza defn gc-if-no-stacks (pool:ptr<StackPool>) -> int :
  ;This function tries running the garbage collector to free up some stacks.
  ;To prevent thrashing, the remaining logic is for ensuring a specific usage ratio.
  ;If there are no stacks remaining, then run the garbage collector.
  ;Next measure the usage ratio: if the usage ratio is over 0.6 then
  ;increase the number of stacks (capped by the maximum number of stacks).

  if pool.num-used == pool.capacity :
    ;call-c clib/printf("Running garbage collector to release some stacks\n")
    extend-heap(0)
  return 0

lostanza defn free-unmarked-stacks (pool:ptr<StackPool>) -> int :
  ;Free all stacks in small pool
  labels :
    begin : goto loop(0)
    loop (i:int) :
      if i < pool.num-used :
        val s = pool.stacks[i]
        if s.mark == 0 :
          free-stack(pool, s)
          goto loop(i)
        else :
          s.mark = 0
          goto loop(i + 1)
  ;Free all stacks in big pool
  labels :
    begin : goto loop(0, 0)
    loop (n:int, i:int) :
      if i < pool.big-size :
        val s = pool.big-stacks[i]
        if s.mark == 0 :
          call-c clib/stz_free(s)
          goto loop(n, i + 1)
        else :
          s.mark = 0
          pool.big-stacks[n] = s
          goto loop(n + 1, i + 1)
      else :
        pool.big-size = n
  ;Check that all stacks are now unmarked.
  #if-not-defined(OPTIMIZE) :
    for (var i:int = 0, i < pool.capacity, i = i + 1) :
      val s = pool.stacks[i]
      if s.mark : fatal!("Marked stacks remaining.\n")
    for (var i:int = 0, i < pool.big-size, i = i + 1) :
      val s = pool.big-stacks[i]
      if s.mark : fatal!("Marked stacks remaining.\n")
  return 0

lostanza defn header (p:ptr<StackFrame>) -> ptr<StackFrameHeader> :
  return (p - sizeof(StackFrameHeader)) as ptr<StackFrameHeader>

lostanza defn free (s:ref<Stack>) -> int :
  ;call-c clib/printf("freeing coroutine\n")
  free-stack(addr(STACK-POOL), header(s.frames))
  s.frames = null
  s.stack-pointer = null
  return 0

;Global stack pool
lostanza val INITIAL-STACK-SIZE:long = 4L * 1024L
lostanza val STACK-POOL:StackPool = StackPool()

;<doc>=======================================================
;====================== Stack Extension =====================
;============================================================

Computing the new size of the stack:
  - The desired-size is:
      stack-pointer + size - frames
  - Double the current size until it is larger than the
    desired size, and then cap it at the maximum allowable size.
  - If the new size is still less than the desired size, then
    stack overflow.

;============================================================
;=======================================================<doc>

lostanza defn extend-stack (size:long) -> long :
  ;Retrieve stack
  val vms:ptr<VMState> = call-prim flush-vm()
  val s:ptr<Stack> = addr!([vms.system-stack as ref<Stack>])

  ;Compute new size of stack
  val maximum-size = 1024L * 1024L * 1024L
  val desired-size = s.stack-pointer + size - s.frames
  var size*:long = s.size
  while size* < desired-size : size* = size* * 2
  size* = min(size*, maximum-size)

  ;Check for stack overflow
  if size* < desired-size :
    fatal!("Stack overflow")

  ;Allocate new frames and copy over old frames
  val frameheader = take-next-stack(addr(STACK-POOL), size*)
  val frames* = addr(frameheader.frames)
  call-c clib/memcpy(frames*, s.frames, s.size)
  ;call-c clib/printf("extending stack\n")
  free-stack(addr(STACK-POOL), header(s.frames))

  ;Swap in new frames
  s.stack-pointer = s.stack-pointer + (frames* - s.frames)
  s.size = size*
  s.frames = frames*

  ;Return
  return 0

;<doc>=======================================================
;============= Garbage Collector with Resizing ==============
;============================================================

Pre-emptive heap resizing:
  The collector tries to maintain a usage-ratio below 0.5.
  If the usage-ratio exceeds 0.5, then we double the free space
  available for use for next time. This doubling means that
  occasionally the free space is larger than the heap space.
  Therefore after the garbage collector runs, and the free space is
  swapped with the heap space, we need to ensure that the free space
  is at least the size of the heap space.

;============================================================
;=======================================================<doc>

lostanza defn collect-garbage (size:long) -> long :
  ;Retrieve state
  val vms:ptr<VMState> = call-prim flush-vm()

  ;First run the garbage collector,
  collect-garbage(vms)

  ;Check whether we're still out of space.
  if vms.heap-top + size > vms.heap-limit :
    ;Compute desired heap size
    val desired-space = vms.heap-top + size - vms.heap
    ;If desired-space is satisfiable
    if desired-space <= MAXIMUM-HEAP-SIZE :
      ;Expand the heap
      var space:long = vms.heap-limit - vms.heap
      while space < desired-space : space = space * 2
      space = min(space, MAXIMUM-HEAP-SIZE)

      ;Resize the heap and use the GC to move contents over
      resize-freespace(vms, space)
      collect-garbage(vms)
      resize-freespace(vms, space)

  ;We're not out of space, so we don't need to expand the heap,
  ;but we might want to for next time.
  else :
    ;Expand the freeheap if we're using more than 50% of it,
    ;or if the heapspace is bigger than the freespace.
    val used-space = vms.heap-top - vms.heap
    val heap-space = vms.heap-limit - vms.heap
    val free-space = vms.free-limit - vms.free
    val usage-ratio = (used-space as float) / (heap-space as float)

    ;Compute the new heap-space
    var new-space:long = heap-space
    if usage-ratio > 0.5f :
      new-space = min(MAXIMUM-HEAP-SIZE, heap-space * 2)

    ;Resize free if necessary
    if new-space > free-space :
      resize-freespace(vms, new-space)

  ;Return the new space remaining
  return vms.heap-limit - vms.heap

lostanza defn resize-freespace (vms:ptr<VMState>, space:long) -> int :
  call-c clib/stz_free(vms.free)
  vms.free = call-c clib/stz_malloc(space)
  vms.free-limit = vms.free + space
  return 0

;============================================================
;==================== Garbage Collector =====================
;============================================================

lostanza deftype LivenessTrackerObj :
  tag: long
  value: long
  tail: ptr<LivenessTrackerObj>

lostanza deftype ObjectLayout :
  tag: long
  slots: long ...

lostanza deftype BrokenHeartLayout :
  tag: long
  forward: long

lostanza defn tag (x:ptr<?>) -> long :
  return (x + 1) as long

lostanza defn untag (x:long) -> ptr<?> :
  val tagbits = x & 7L
  if tagbits != 1 : fatal("Not a heap-allocated object!")
  return (x - 1 + 8) as ptr<?>

lostanza var TRACKER-CHAIN:ptr<LivenessTrackerObj>
lostanza defn collect-garbage (vms:ptr<VMState>) -> long :
  ;Print diagnostics
  ;call-c clib/printf("Before collect Garbage:\n")
  ;dump-heap(vms)
  ;call-c clib/printf("collect garbage\n")

  ;Swap free with heap
  val heap = vms.heap
  val heap-limit = vms.heap-limit
  val free = vms.free
  val free-limit = vms.free-limit
  vms.heap = free
  vms.heap-top = free
  vms.heap-limit = free-limit
  vms.free = heap
  vms.free-limit = heap-limit

  ;Initialize tracker chain
  TRACKER-CHAIN = null

  ;Scan global roots
  ;call-c clib/printf("scan globals\n")
  val globals = vms.global-mem as ptr<long>
  val roots = vms.global-root-table
  val nroots = roots.length
  for (var i:int = 0, i < nroots, i = i + 1) :
    val r = roots.roots[i]
    globals[r] = post-gc-object(globals[r], vms)

  ;Scan const roots
  ;call-c clib/printf("scan consts\n")
  val consts = vms.const-table
  val nconsts = [vms.const-mem as ptr<int>]
  for (var i:int = 0, i < nconsts, i = i + 1) :
    consts[i] = post-gc-object(consts[i], vms)

  ;Scan stack roots
  ;call-c clib/printf("scan stacks\n")
  vms.current-stack = post-gc-object(vms.current-stack, vms)
  vms.system-stack = post-gc-object(vms.system-stack, vms)

  ;Scan heap
  ;call-c clib/printf("scan heap\n")
  scan-heap(vms)

  ;Scan tracker chain
  ;call-c clib/printf("scan tracker chain\n")
  scan-tracker-chain(TRACKER-CHAIN)

  ;Print diagnostics
  ;call-c clib/printf("After collect Garbage:\n")
  ;dump-heap(vms)

  ;Return
  return 0

lostanza defn object-size-on-heap (sz:long) -> long :
  val ceiled = (8L + sz + 7L) & -8L
  return max(ceiled, 16L)
lostanza defn object-size-on-heap (sz:ref<Int>) -> ref<Int> :
  return new Int{object-size-on-heap(sz.value) as int}

lostanza defn scan-frames (frames:ptr<StackFrame>, f-end:ptr<StackFrame>, vms:ptr<VMState>) -> int :
  if frames != null :
    val frameheader = header(frames)
    frameheader.mark = 1
    var f:ptr<StackFrame> = frames
    while f <= f-end :
      ;call-c clib/printf("  scan frame %p of %p (map = %ld)\n", f, f-end, f.liveness-map)
      val map = vms.stackmap-table[f.liveness-map]
      ;call-c clib/printf("num-roots = %d, size = %d\n", map.num-roots, map.size)
      val num-live = map.num-roots
      for (var i:int = 0, i < num-live, i = i + 1) :
        val s = map.roots[i]
        ;call-c clib/printf("scanning slot %d\n", s)
        f.slots[s] = post-gc-object(f.slots[s], vms)
      f = f + map.size
  return 0

lostanza defn scan-heap (vms:ptr<VMState>) -> int :
  var p:ptr<long> = vms.heap
  while p < vms.heap-top :
    p = scan-object(p, vms)
  return 0

lostanza defn scan-tracker-chain (tracker-chain:ptr<LivenessTrackerObj>) -> int :
  var t:ptr<LivenessTrackerObj> = tracker-chain
  while t != null :
    t.value = post-gc-weak-object(t.value)
    t = t.tail
  return 0

lostanza defn post-gc-weak-object (ref:long) -> long :
  val tagbits = ref & 7L
  if tagbits == 1 :
    val obj = (ref - 1) as ptr<long>
    val obj-tag = [obj]
    ;Case: Broken Heart
    if obj-tag == -1L :
      val heart = obj as ptr<BrokenHeartLayout>
      return heart.forward
    ;Case: Uncopied object
    else :
      return false-marker()
  else :
    return ref

lostanza defn false-marker () -> long :
  return tagof(False) << 3L + 2

lostanza defn scan-object (p:ptr<long>, vms:ptr<VMState>) -> ptr<long> :
  ;p is [tag, cells ...]
  val tag = [p] as int
  ;call-c clib/printf("scan-object %p (tag = %d)\n", p, tag)

  ;Leaf class
  val class-rec = vms.class-table[tag]
  if class-rec.item-size == 0 :
    ;If it's a LivenessTracker, then extend the chain
    if tag == tagof(LivenessTracker) :
      val t = p as ptr<LivenessTrackerObj>
      t.tail = TRACKER-CHAIN
      TRACKER-CHAIN = t
      return p + sizeof(LivenessTrackerObj)
    else :
      ;Scan the frames of a stack
      if tag == tagof(Stack) :
        val s = (p + 8) as ptr<Stack>
        scan-frames(s.frames, s.stack-pointer, vms)
      ;Get properties
      val size = object-size-on-heap(class-rec.size)
      val roots = addr(class-rec.roots)
      val num-roots = class-rec.num-roots
      ;call-c clib/printf("size = %d, heap-size = %d\n", class-rec.size, size)
      ;call-c clib/printf("num-roots = %d\n", num-roots)
      ;Scan slots
      val obj = p as ptr<ObjectLayout>
      for (var i:int = 0, i < num-roots, i = i + 1) :
        val r = roots[i]
        ;call-c clib/printf("scan root %d\n", r)
        obj.slots[r] = post-gc-object(obj.slots[r], vms)
      ;Return end of object
      return p + size
  ;Array class
  else :
    val array-rec = class-rec as ptr<ArrayRecord>
    ;Get properties
    val base-size = array-rec.base-size
    val item-size = array-rec.item-size
    val num-base-roots = array-rec.num-base-roots
    val num-item-roots = array-rec.num-item-roots
    val base-roots = addr(array-rec.roots)
    val item-roots = addr(array-rec.roots[num-base-roots])
    ;Scan base roots
    val array = p as ptr<ObjectLayout>
    val len = array.slots[0]
    ;call-c clib/printf("base-size = %d, item-size = %d, len = %ld\n", base-size, item-size, len)
    for (var i:int = 0, i < num-base-roots, i = i + 1) :
      val r = base-roots[i]
      ;call-c clib/printf("scan base root %d\n", r)
      array.slots[r] = post-gc-object(array.slots[r], vms)
    ;Scan item roots
    var items:ptr<long> = addr(array.slots) + base-size
    if num-item-roots > 0 :
      for (var n:long = 0, n < len, n = n + 1) :
        for (var i:int = 0, i < num-item-roots, i = i + 1) :
          val r = item-roots[i]
          ;call-c clib/printf("scan item root %d of item %ld\n", r, n)
          items[r] = post-gc-object(items[r], vms)
        items = items + item-size
    ;Return end of array
    return p + object-size-on-heap(base-size + item-size * len)

lostanza defn post-gc-object (ref:long, vms:ptr<VMState>) -> long :
  ;call-c clib/printf("post-gc-object(%p)\n", ref)
  val tagbits = ref & 7L
  if tagbits == 1L :
    val obj = (ref - 1L) as ptr<long>
    val obj-tag = [obj]
    ;call-c clib/printf("tag = %ld\n", obj-tag)
    ;Case: Broken Heart
    if obj-tag == -1L :
      val heart = obj as ptr<BrokenHeartLayout>
      return heart.forward
    ;Case: Uncopied object
    else :
      val obj* = tag(vms.heap-top)
      val class-rec = vms.class-table[obj-tag]
      copy-bytes-to-heap(obj, num-bytes(obj, class-rec), vms)
      set-broken-heart(obj, obj*)
      ;call-c clib/printf("Copied object from %p to %p\n", obj, obj*)
      return obj*
  else :
    return ref

lostanza defn set-broken-heart (obj:ptr<long>, obj*:long) -> int :
  val heart = obj as ptr<BrokenHeartLayout>
  heart.tag = -1L
  heart.forward = obj*
  return 0

lostanza defn num-bytes (obj:ptr<?>, class:ptr<ClassRecord>) -> long :
  if class.item-size == 0 :
    return object-size-on-heap(class.size)
  else :
    val class = class as ptr<ArrayRecord>
    val array = obj as ptr<ObjectLayout>
    val len = array.slots[0]
    val base-size = class.base-size
    val item-size = class.item-size
    return object-size-on-heap(base-size + len * item-size)

lostanza defn copy-bytes-to-heap (p:ptr<?>, n:long, vms:ptr<VMState>) -> int :
  val heap = vms.heap-top
  val nwords = n >>> 3
  val src = p as ptr<long>
  for (var i:long = 0, i < nwords, i = i + 1) :
    heap[i] = src[i]
  vms.heap-top = heap + n
  return 0

lostanza defn max (x:long, y:long) -> long :
  if x < y : return y
  else : return x

lostanza defn min (x:long, y:long) -> long :
  if x < y : return x
  else : return y

;============================================================
;===================== Debugging ============================
;============================================================

lostanza defn dump-heap (vms:ptr<VMState>) -> int :
  return dump-heap(vms.heap, vms.heap-top, vms)

lostanza defn dump-heap (pstart:ptr<long>, pend:ptr<long>, vms:ptr<VMState>) -> int :
  val stackrefs = LSLongVector()
  call-c clib/printf("Heap:\n")
  var p:ptr<long> = pstart
  while p < pend :
    val tag = [p] as int
    if tag == tagof(Stack) :
      add(stackrefs, /tag(p))
    val class = vms.class-table[tag]
    if class.item-size == 0 :
      val obj = p as ptr<ObjectLayout>
      val size = class.size
      call-c clib/printf("  %p: [Object %d, size = %d]", /tag(p), tag, size)
      for (var i:long = 0, i < size, i = i + 8) :
        call-c clib/printf("  %lx", [p + 8 + i])
      call-c clib/printf("\n")
      ;Advance to next object
      p = p + object-size-on-heap(size)
    else :
      val class = class as ptr<ArrayRecord>
      val array = p as ptr<ObjectLayout>
      val len = array.slots[0]
      val base-size = class.base-size
      val item-size = class.item-size
      val size = base-size + item-size * len
      call-c clib/printf("  %p: [Array %d, length = %ld, base-size = %d, item-size = %d]",
                         /tag(p), tag, len, base-size, item-size)
      for (var i:long = 0, i < size, i = i + 8) :
        call-c clib/printf("  %lx", [p + 8 + i])
      call-c clib/printf("\n")
      ;Advance to next object
      p = p + object-size-on-heap(size)
  ;Dump stacks
  for (var i:int = 0, i < stackrefs.length, i = i + 1) :
    val s = stackrefs.items[i]
    dump-stack(s, vms)
  return 0

lostanza defn dump-stack (stackref:long, vms:ptr<VMState>) -> int :
  val stk:ptr<Stack> = untag(stackref)
  val f-end = stk.stack-pointer
  call-c clib/printf("Stack %p (last frame %p):\n", stackref, f-end)
  if stk.frames != null :
    labels :
      begin :
        goto loop(stk.frames)
      loop (f:ptr<StackFrame>) :
        if f <= f-end :
          ;Get frame properties
          val map-index = f.liveness-map
          val map = vms.stackmap-table[map-index]
          val live-slots = addr(map.roots)
          val num-slots = (map.size - 16) / 8
          ;Print properties
          val num-live = map.num-roots
          var slot-i:int = 0
          call-c clib/printf("  %p: [StackFrame %ld, num-slots = %d]\n", f, f.liveness-map, num-slots)
          for (var i:int = 0, i < num-slots, i = i + 1) :
            if slot-i < num-live and live-slots[slot-i] == i :
              call-c clib/printf("    %d: [%lx]\n", i, f.slots[i])
              slot-i = slot-i + 1
            else :
              call-c clib/printf("    %d: %lx\n", i, f.slots[i])

          if f != f-end :
            val f* = f + map.size
            if f* > f-end :
              call-c clib/printf("New stack %p is past end\n", f)
              call-c clib/exit(-1)
            goto loop(f*)
  return 0


;============================================================
;====================== CONSTANTS ===========================
;============================================================

val COROUTINE-ACTIVE = 0
val COROUTINE-CLOSED = 1
val COROUTINE-SUSPENDED = 2
val COROUTINE-OPEN = 3

lostanza val INT-TAG-BITS:long = 0L
lostanza val REF-TAG-BITS:long = 1L
lostanza val MARKER-TAG-BITS:long = 2L
lostanza val BYTE-TAG-BITS:long = 3L
lostanza val CHAR-TAG-BITS:long = 4L
lostanza val FLOAT-TAG-BITS:long = 5L

lostanza val FALSE-TYPE:int = 0
lostanza val TRUE-TYPE:int = 1
lostanza val BYTE-TYPE:int = 2
lostanza val CHAR-TYPE:int = 3
lostanza val INT-TYPE:int = 4
lostanza val FLOAT-TYPE:int = 5

public lostanza val null:ptr<?> = 0L as ptr<?>

;============================================================
;======================= Bytes ==============================
;============================================================

public lostanza defn shift-left (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value << b.value}

public lostanza defn shift-right (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value >> b.value}

public lostanza defn bit-or (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value | b.value}

public lostanza defn bit-xor (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value & b.value}

public lostanza defn bit-not (a:ref<Byte>) -> ref<Byte> :
  return new Byte{(~ a.value)}

public lostanza defn plus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value + b.value}

public lostanza defn minus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value - b.value}

public lostanza defn times (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value * b.value}

public lostanza defn divide (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  ensure-divide-non-zero(b)
  return new Byte{a.value / b.value}

public lostanza defn modulo (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  ensure-divide-non-zero(b)
  return new Byte{a.value % b.value}

;============================================================
;====================== Integers ============================
;============================================================

public defn shift-left (a:Int, b:Int) -> Int :
  ($prim shl a b)

public defn shift-right (a:Int, b:Int) -> Int :
  ($prim shr a b)

public defn arithmetic-shift-right (a:Int, b:Int) -> Int :
  ($prim ashr a b)

public defn bit-or (a:Int, b:Int) -> Int :
  ($prim or a b)

public defn bit-and (a:Int, b:Int) -> Int :
  ($prim and a b)

public defn bit-xor (a:Int, b:Int) -> Int :
  ($prim xor a b)

public defn bit-not (a:Int) -> Int :
  ($prim not a)

public defn negate (a:Int) -> Int :
  ($prim neg a)

public defn abs (a:Int) -> Int :
  (- a) when a < 0 else a

public defn plus (a:Int, b:Int) -> Int :
  ($prim add a b)

public defn minus (a:Int, b:Int) -> Int :
  ($prim sub a b)

public defn times (a:Int, b:Int) -> Int :
  ($prim mul a b)

public defn divide (a:Int, b:Int) -> Int :
  ensure-divide-non-zero(b)
  ($prim div a b)

public defn modulo (a:Int, b:Int) -> Int :
  ensure-divide-non-zero(b)
  ($prim mod a b)

;============================================================
;======================== Longs =============================
;============================================================

public lostanza defn shift-left (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value << b.value}

public lostanza defn shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value >> b.value}

public lostanza defn arithmetic-shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value >>> b.value}

public lostanza defn bit-or (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value | b.value}

public lostanza defn bit-xor (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value & b.value}

public lostanza defn bit-not (a:ref<Long>) -> ref<Long> :
  return new Long{(~ a.value)}

public lostanza defn negate (a:ref<Long>) -> ref<Long> :
  return new Long{(- a.value)}

public defn abs (a:Long) -> Long :
  (- a) when a < 0L else a

public lostanza defn plus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value + b.value}

public lostanza defn minus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value - b.value}

public lostanza defn times (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value * b.value}

public lostanza defn divide (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  ensure-divide-non-zero(b)
  return new Long{a.value / b.value}

public lostanza defn modulo (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  ensure-divide-non-zero(b)
  return new Long{a.value % b.value}

;============================================================
;======================= Floats =============================
;============================================================

public lostanza defn negate (a:ref<Float>) -> ref<Float> :
  return new Float{(- a.value)}

public defn abs (a:Float) -> Float :
  (- a) when a < 0.0f else a

public lostanza defn plus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value + b.value}

public lostanza defn minus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value - b.value}

public lostanza defn times (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value * b.value}

public lostanza defn divide (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value / b.value}

public lostanza defn nan? (x:ref<Float>) -> ref<True|False> :
  val v = x.value
  if v != v : return true
  else : return false

;============================================================
;======================= Doubles ============================
;============================================================

public lostanza defn negate (a:ref<Double>) -> ref<Double> :
  return new Double{(- a.value)}

public defn abs (a:Double) -> Double :
  (- a) when a < 0.0 else a

public lostanza defn plus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value + b.value}

public lostanza defn minus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value - b.value}

public lostanza defn times (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value * b.value}

public lostanza defn divide (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value / b.value}

public lostanza defn nan? (x:ref<Double>) -> ref<True|False> :
  val v = x.value
  if v != v : return true
  else : return false

;============================================================
;======================== Strings ===========================
;============================================================

public lostanza defn String (len:long) -> ref<String> :
  return new String{len + 1, 0}

public lostanza defn String (len:long, chars:ptr<byte>) -> ref<String> :
  return initialize(String(len), chars)

public lostanza defn String (len:long, chars:ref<ByteArray>) -> ref<String> :
  return initialize(String(len), addr!(chars.data))

public lostanza defn initialize (s:ref<String>, chars:ptr<byte>) -> ref<String> :
  val l = s.length - 1
  call-c clib/memcpy(addr!(s.chars), chars, l)
  s.chars[l] = 0Y
  return s

;============================================================
;======================= Lists ==============================
;============================================================

public lostanza defn List () -> ref<List> :
  return new NilList{}

public lostanza defn cons<?T> (x:ref<?T>, t:ref<List<?T>>) -> ref<List<T>> :
  return new FullList<T>{x, t}

public defmulti head<?T> (x:List<?T>) -> T
public defmulti tail<?T> (x:List<?T>) -> List<T>
public defmulti empty? (x:List) -> True|False

defmethod head (x:NilList) : fatal("Cannot retrieve head of empty list.")
defmethod tail (x:NilList) : fatal("Cannot retrieve tail of empty list.")
defmethod empty? (x:NilList) : true
lostanza defmethod head (x:ref<FullList>) -> ref<?> : return x.head
lostanza defmethod tail (x:ref<FullList>) -> ref<?> : return x.tail
defmethod empty? (x:FullList) : false

;============================================================
;======================= Booleans ===========================
;============================================================

public defn complement (a:True|False) -> True|False :
  if a : false
  else : true

;============================================================
;====================== Comparable ==========================
;============================================================

public deftype Comparable<T> :
  Char <: Comparable<Char>
  Byte <: Comparable<Byte>
  Int <: Comparable<Int>
  Long <: Comparable<Long>
  Float <: Comparable<Float>
  Double <: Comparable<Double>
  Tuple<T> <: Comparable<Tuple<T>>
  String <: Comparable<String>
  Symbol <: Comparable<Symbol>
  List<T> <: Comparable<List<T>>

public defmulti compare<?T> (a:Comparable<?T>, b:T) -> Int
public defmulti less?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti greater?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti less-eq?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti greater-eq?<?T> (a:Comparable<?T>, b:T) -> True|False

defmethod less?<?T> (a:Comparable<?T>, b:T) : compare(a, b) < 0
defmethod greater?<?T> (a:Comparable<?T>, b:T) : compare(a, b) > 0
defmethod less-eq?<?T> (a:Comparable<?T>, b:T) : compare(a, b) <= 0
defmethod greater-eq?<?T> (a:Comparable<?T>, b:T) : compare(a, b) >= 0

lostanza defmethod compare (a:ref<Char>, b:ref<Char>) -> ref<Int> :
  return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Byte>, b:ref<Byte>) -> ref<Int> :
  return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

defmethod compare (a:Int, b:Int) -> Int :
  if a < b : -1
  else if a > b : 1
  else : 0

defmethod less? (a:Int, b:Int) -> True|False :
  ($prim lt a b)

defmethod less-eq? (a:Int, b:Int) -> True|False :
  ($prim le a b)

defmethod greater? (a:Int, b:Int) -> True|False :
  ($prim gt a b)

defmethod greater-eq? (a:Int, b:Int) -> True|False :
  ($prim ge a b)

lostanza defmethod compare (a:ref<Long>, b:ref<Long>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Float>, b:ref<Float>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Double>, b:ref<Double>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Tuple<Comparable>>, b:ref<Tuple<Comparable>>) -> ref<Int> :
  val la = a.length
  val lb = b.length
  labels :
    begin :
      goto loop(0)
    loop (i:long) :
      if i < la and i < lb :
        val c = compare(a.items[i], b.items[i])
        if c.value : return c
        else : goto loop(i + 1)
      else :
        return compare(new Int{la as int}, new Int{lb as int})

lostanza defmethod compare (a:ref<String>, b:ref<String>) -> ref<Int> :
  val na = strlen(a)
  val nb = strlen(b)
  labels :
    begin :
      goto loop(0)
    loop (i:long) :
      if (i == na) and (i == nb) :
        return new Int{0}
      else if i == na :
        return new Int{-1}
      else if i == nb :
        return new Int{1}
      else :
        val ac = a.chars[i]
        val bc = b.chars[i]
        if ac < bc : return new Int{-1}
        else if ac > bc : return new Int{1}
        else : goto loop(i + 1)

defmethod compare (xs:List<Comparable>, ys:List<Comparable>) -> Int :
  defn* loop (xs:List<Comparable>, ys:List<Comparable>) :
    match(empty?(xs), empty?(ys)) :
      (ex:True, ey:True) : 0
      (ex:True, ey:False) : -1
      (ex:False, ey:True) : 1
      (ex:False, ey:False) :
        val c = compare(head(xs), head(ys))
        if c == 0 : loop(tail(xs), tail(ys))
        else : c
  loop(xs, ys)

defmethod compare (a:Symbol, b:Symbol) :
  defn rank (s:Symbol) :
    match(s) :
      (s:StringSymbol) : 0
      (s:GenSymbol) : 1
  match(a, b) :
    (a:StringSymbol, b:StringSymbol) :
      compare(name(a), name(b))
    (a:GenSymbol, b:GenSymbol) :
      val c = compare(name(a), name(b))
      if c == 0 : compare(id(a), id(b))
      else : c
    (a, b) :
      compare(rank(a), rank(b))

;============================================================
;======================== Equalable =========================
;============================================================

public deftype Equalable :
  Char <: Equalable
  Byte <: Equalable
  Int <: Equalable
  Long <: Equalable
  Float <: Equalable
  Double <: Equalable
  Tuple<T> <: Equalable
  String <: Equalable
  Symbol <: Equalable
  List<T> <: Equalable
  True <: Equalable
  False <: Equalable

public defmulti equal? (a:Equalable, b:Equalable) -> True|False
defmethod equal? (a:Equalable, b:Equalable) : false

public defn not-equal? (a:Equalable, b:Equalable) -> True|False :
  not equal?(a, b)

defmethod equal? (a:Char, b:Char) -> True|False :
  ($prim identical? a b)

defmethod equal? (a:Byte, b:Byte) -> True|False :
  ($prim identical? a b)

defmethod equal? (a:Int, b:Int) -> True|False :
  ($prim eq a b)

lostanza defmethod equal? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

lostanza defmethod equal? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

lostanza defmethod equal? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

defmethod equal? (a:True|False, b:True|False) -> True|False :
  ($prim identical? a b)

lostanza defmethod equal? (x:ref<Tuple>, y:ref<Tuple>) -> ref<True|False> :
  val n = x.length
  if n != y.length : return false
  for (var i:long = 0, i < n, i = i + 1) :
    if equal?(x.items[i], y.items[i]) == false :
      return false
  return true

lostanza defmethod equal? (a:ref<String>, b:ref<String>) -> ref<True|False> :
  val n = strlen(a)
  if n == strlen(b) :
    for (var i:long = 0, i < n, i = i + 1) :
      if a.chars[i] != b.chars[i] :
        return false
    return true
  else :
    return false

defmethod equal? (a:List, b:List) -> True|False :
  defn* loop (a:List, b:List) :
    match(empty?(a), empty?(b)) :
      (ea:True, eb:True) : true
      (ea:False, eb:False) :
        if head(a) == head(b) :
          loop(tail(a), tail(b))
      (ea, eb) : false
  loop(a, b)

defmethod equal? (a:Symbol, b:Symbol) -> True|False :
  ($prim identical? a b)

;============================================================
;====================== Lengthable ==========================
;============================================================

public deftype Lengthable :
  String <: Lengthable
  Tuple<T> <: Lengthable
  List<T> <: Lengthable

public defmulti length (l:Lengthable) -> Int

lostanza defmethod length (x:ref<Tuple>) -> ref<Int> :
  return new Int{x.length as int}

lostanza defmethod length (s:ref<String>) -> ref<Int> :
  return new Int{s.length as int - 1}

defmethod length (x:List) :
  defn* loop (x:List, n:Int) :
    if empty?(x) : n
    else : loop(tail(x), n + 1)
  loop(x, 0)

;============================================================
;=================== Winders ================================
;============================================================
defstruct Winder :
  in: False|(() -> ?)
  out: False|(? -> ?)

var WINDER-STACK:List<Winder>
var NUM-WINDERS:Int

defn initialize-winders () :
  WINDER-STACK = List()
  NUM-WINDERS = 0

defn pop-winder () :
  val w = head(WINDER-STACK)
  WINDER-STACK = tail(WINDER-STACK)
  NUM-WINDERS = NUM-WINDERS - 1
  w

defn push-winder (w:Winder) :
  WINDER-STACK = cons(w, WINDER-STACK)
  NUM-WINDERS = NUM-WINDERS + 1

defn pop-winders (n:Int) :
  defn pop (n:Int) :
    if n > 0 : cons(pop-winder(), pop(n - 1))
    else : List()
  pop(NUM-WINDERS - n)

defn push-winders (ws:List<Winder>) :
  if not empty?(ws) :
    push-winders(tail(ws))
    push-winder(head(ws))

defn total-winders (c:False|RawCoroutine) -> Int :
  match(c) :
    (c:False) : 0
    (c:RawCoroutine) : total-winders(parent(c)) + num-winders(c)

defn wind-in (ws:List<Winder>) :
  if not empty?(ws) :
    wind-in(tail(ws))
    call?(in(head(ws)))

defn wind-out (ws:List<Winder>, f:True|False) :
  if not empty?(ws) :
    call?(out(head(ws)), f)
    wind-out(tail(ws), f)

defn* call? (f: False|(() -> ?)) :
  match(f) :
    (f:() -> ?) : f()
    (f:False) : false

defn* call? (f: False|(? -> ?), x: ?) :
  match(f) :
    (f:? -> ?) : f(x)
    (f:False) : false

lostanza defn inc-winders (c:ref<RawCoroutine>, n:ref<Int>) -> ref<False> :
  c.num-winders = c.num-winders + n.value
  return false

lostanza defn num-winders (c:ref<RawCoroutine>) -> ref<Int> :
  return new Int{c.num-winders}

public defn dynamic-wind<?T> (in:False|(() -> ?),
                              body:() -> ?T,
                              out:False|(True|False -> ?)) -> T :
  call?(in)
  push-winder(Winder(in, out))
  inc-winders(current-coroutine, 1)
  val result = body()
  pop-winder()
  inc-winders(current-coroutine, -1)
  call?(out, true)
  result

;============================================================
;====================== Coroutines ==========================
;============================================================

public defmulti active? (c:Coroutine) -> True|False
public defmulti open? (c:Coroutine) -> True|False
public defmulti resume<?I,?O> (c:Coroutine<?I,?O>, x:I) -> O
public defmulti suspend<?I,?O> (c:Coroutine<?I,?O>, x:O) -> I
public defmulti break<?O> (c:Coroutine<?,?O>, x:O) -> Void
public defmulti close (c:Coroutine) -> False

;                  Wrapped Coroutines
;                  ==================

#if-defined(OPTIMIZE) :

  public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
    RawCoroutine(enter)

#else :

  deftype WrappedCoroutine<I,O> <: Coroutine<I,O>
  defmulti raw (c:WrappedCoroutine) -> RawCoroutine

  public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
    var rc
    val c = new WrappedCoroutine<I,O> :
      defmethod active? (this) : active?(rc)
      defmethod open? (this) : open?(rc)
      defmethod resume (this, x:I) : resume(rc, x)
      defmethod suspend (this, x:O) : suspend(rc, x)
      defmethod break (this, x:O) : break(rc, x)
      defmethod close (this) : close(rc)
      defmethod raw (this) : rc
    rc = RawCoroutine $ fn (rc, x0) :
      enter(c, x0)
    c

  defmethod print (o:OutputStream, c:WrappedCoroutine) :
    print(o, raw(c))

protected lostanza deftype RawCoroutine <: Coroutine :
  id: long
  stack: ref<Stack>
  parent: ref<False|RawCoroutine>
  status: ref<Int>
  num-winders: int
  crsp: long

lostanza deftype CoroutineParams :
  parent-stack: ref<Stack>
  coroutine: ref<RawCoroutine>
  enter: ref<((RawCoroutine, ?) -> ?)>

protected lostanza var current-coroutine:ref<RawCoroutine>
lostanza var COROUTINE-COUNTER:long

lostanza defn initialize-coroutines () -> ref<False> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val current-stack = vms.current-stack as ref<Stack>
  val crsp = call-prim crsp() as long
  current-coroutine = new RawCoroutine{0L, current-stack, false, COROUTINE-ACTIVE, 0, crsp}
  COROUTINE-COUNTER = 1L
  return false

lostanza defn allocate-stack () -> ref<Stack> :
  ;Note: The stack must be allocated before retrieving the stack frames.
  ;Because,
  val stack-size = INITIAL-STACK-SIZE
  val stack = new Stack{stack-size, null, null, 0}
  val frameheader = take-next-stack(addr(STACK-POOL), stack-size)
  val frames = addr(frameheader.frames)
  frames.return = -1L
  frames.liveness-map = 0L
  stack.frames = frames
  return stack;

public lostanza defn RawCoroutine (enter:ref<((RawCoroutine, ?) -> ?)>) -> ref<RawCoroutine> :
  val stk = allocate-stack()
  stk.pc = addr(setup-coroutine) as long
  val vms:ptr<VMState> = call-prim flush-vm()
  val current-stack = vms.current-stack as ref<Stack>
  return call-prim enter-stack(stk, current-stack, enter)

lostanza defn parent (c:ref<RawCoroutine>) -> ref<False|RawCoroutine> :
  return c.parent
lostanza defn status (c:ref<RawCoroutine>) -> ref<Int> :
  return c.status
lostanza defn id (c:ref<RawCoroutine>) -> ref<Int> :
  return new Int{c.id as int}

lostanza defmethod active? (c:ref<RawCoroutine>) -> ref<True|False> :
  if c.status == COROUTINE-ACTIVE : return true
  else : return false

lostanza defmethod open? (c:ref<RawCoroutine>) -> ref<True|False> :
  if c.status == COROUTINE-OPEN : return true
  else : return false

lostanza defn* setup-coroutine (stack:ref<Stack>, parent-stack:ref<Stack>, enter:ref<((RawCoroutine, ?) -> ?)>) -> ref<?> :
  val crsp = call-prim crsp() as long
  val co = new RawCoroutine{COROUTINE-COUNTER, stack, false, COROUTINE-OPEN, 0, crsp}
  ;call-c clib/printf("Created coroutine %ld #%d (stack frames = %p)\n", co, co.id, co.stack.frames)
  COROUTINE-COUNTER = COROUTINE-COUNTER + 1L
  val x0 = call-prim yield(parent-stack, co)
  return break(co, [enter](co, x0))

lostanza defmethod resume (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
  ;call-c clib/printf("[from coroutine %d] resuming coroutine %d (stackframes = %ld)\n", current-coroutine.id, c.id, c.stack.frames)
  ;Ensure coroutine is re-entrant
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot resume coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-ACTIVE :
    return fatal("Cannot resume coroutine. Coroutine is already active.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot resume coroutine. Coroutine's parent is suspended.")

  ;Adjust state
  attach-coroutine(c)

  ;Begin execution
  return call-prim yield(current-coroutine.stack, x)

lostanza defmethod* suspend (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
  ;call-c clib/printf("[from coroutine %d] suspending coroutine %d (%ld)\n", current-coroutine.id, c.id, c)

  ;Ensure coroutine is active
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot suspend coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-OPEN :
    return fatal("Cannot suspend coroutine. Coroutine is already suspended.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot suspend coroutine. Coroutine is already suspended.")

  ;Ensure coroutine was launched within same c context
  ensure-target-in-same-c-ctxt!(c)

  ;Set target winder environment and wind out
  val winders = pop-winders(total-winders(c.parent))
  wind-out(winders, false)

  ;Detach coroutine
  detach-coroutine(c)

  ;Return to resume
  val result = call-prim yield(current-coroutine.stack, x)

  ;Wind in and restore original winder environment
  wind-in(winders)
  push-winders(winders)

  ;Return execution
  return result

lostanza defmethod close (c:ref<RawCoroutine>) -> ref<False> :
  ;call-c clib/printf("[from coroutine %d] closing coroutine %d\n", current-coroutine.id, c.id)
  ;Ensure coroutine is re-entrant
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot close coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-ACTIVE :
    return fatal("Cannot close coroutine. Coroutine is active.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot close coroutine. Coroutine's parent is suspended.")
  free-coroutine(c)
  return false

lostanza defmethod break (c:ref<RawCoroutine>, x:ref<?>) -> ref<Void> :
  ;call-c clib/printf("[from coroutine %d] breaking coroutine %d\n", current-coroutine.id, c.id)

  ;Ensure coroutine is active
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot break from coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-OPEN :
    return fatal("Cannot break from coroutine. Coroutine is already suspended.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot break from coroutine. Coroutine is already suspended.")

  ;Ensure coroutine was launched within same c context
  ensure-target-in-same-c-ctxt!(c)

  ;Set target winder environment and wind out
  val winders = pop-winders(total-winders(c.parent))
  wind-out(winders, false)

  ;Adjust state
  detach-coroutine(c)
  free-coroutine(c)

  ;Begin execution
  return call-prim yield(current-coroutine.stack, x)

lostanza defn ensure-target-in-same-c-ctxt! (c:ref<RawCoroutine>) -> int :
  val crsp = call-prim crsp() as long
  if c.crsp != crsp :
    fatal!("Cannot suspend coroutine. Coroutine was launched from a different C context. All 'extern defn' callbacks must return properly.")  
  return 0

lostanza defn free-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(c)
    loop (c:ref<RawCoroutine>) :
      val parent = c.parent
      c.parent = false
      c.status = COROUTINE-CLOSED
      free(c.stack)
      match(parent) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : return 0

lostanza defn attach-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(c)
    loop (c:ref<RawCoroutine>) :
      val p = c.parent
      c.parent = current-coroutine
      c.status = COROUTINE-ACTIVE
      c.crsp = call-prim crsp() as long
      current-coroutine = c
      match(p) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : return 0

lostanza defn detach-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(false)
    loop (tail:ref<RawCoroutine|False>) :
      val cc = current-coroutine
      val ccp = current-coroutine.parent as ref<RawCoroutine>
      cc.parent = tail
      current-coroutine = ccp
      if cc == c :
        cc.status = COROUTINE-OPEN
        return 0
      else :
        cc.status = COROUTINE-SUSPENDED
        goto loop(cc)

;============================================================
;================== Runtime Configuration ===================
;============================================================

public lostanza defn current-heap-size () -> ref<Long> :
  val vms:ptr<VMState> = call-prim flush-vm()
  return new Long{vms.heap-limit - vms.heap-top}

public lostanza defn current-max-heap-size () -> ref<Long> :
  return new Long{MAXIMUM-HEAP-SIZE}

defn ensure-valid-max-heap-size (sz:Long) :
  val cur-sz = current-heap-size()
  if sz < cur-sz :
    fatal("Cannot set heap size to %_ bytes which is smaller than the current heap size (%_ bytes)." % [
      sz, cur-sz])
public lostanza defn set-max-heap-size (sz:ref<Long>) -> ref<False> :
  ensure-valid-max-heap-size(sz)
  MAXIMUM-HEAP-SIZE = sz.value
  return false

;============================================================
;=================== Generic Printing =======================
;============================================================

lostanza defn object-type-id (x:ref<?>) -> int :
  val ref = x as long
  val tagbits = ref & 0x7L
  if tagbits == INT-TAG-BITS : return INT-TYPE
  else if tagbits == BYTE-TAG-BITS : return BYTE-TYPE
  else if tagbits == CHAR-TAG-BITS : return CHAR-TYPE
  else if tagbits == FLOAT-TAG-BITS : return FLOAT-TYPE
  else if tagbits == MARKER-TAG-BITS :
    return (ref >> 3L) as int
  else if tagbits == REF-TAG-BITS :
    val p = (ref - REF-TAG-BITS) as ptr<long>
    return [p] as int
  else :
    fatal("Illegal tag bits\n")
    return 0

public lostanza defn object-type (x:ref<?>) -> ref<String> :
  val chars = call-prim class-name(object-type-id(x))
  return String(chars)

;============================================================
;=================== Initialize Constants ===================
;============================================================
initialize-constants()

;============================================================
;=================== Compound Constants =====================
;============================================================

lostanza deftype Sentinel
lostanza val sentinel:ref<Sentinel> = new Sentinel{}

protected deftype Uninitialized
protected val uninitialized = new Uninitialized

#if-defined(PLATFORM-WINDOWS) :
  lostanza val LS-NL:ptr<?> = "\r\n"
  val NL = "\r\n"
#else :
  lostanza val LS-NL:ptr<?> = "\n"
  val NL = "\n"

;============================================================
;=================== Initialize Remaining ===================
;============================================================

initialize-launcher()
initialize-winders()
initialize-coroutines()
initialize-gc-notifiers()
initialize-symbol-table()

;================================================================================
;========================== End of Boot Sequence ================================
;================================================================================

;============================================================
;============= ExternTable and Callback Index Table =========
;============================================================

public lostanza defn extern-address (index:int) -> long :
  val vms:ptr<VMState> = call-prim flush-vm()
  val table = vms.extern-table
  val entry = table.entries[index]
  return entry.address

public lostanza defn extern-address (index:ref<Int>) -> ref<Long> :
  return new Long{extern-address(index.value)}

public lostanza defn extern-id-table () -> ref<HashTable<Symbol,Int>> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val table = vms.extern-table
  val n = table.length
  val return-table = HashTable<Symbol,Int>()
  for (var i:long = 0, i < n, i = i + 1) :
    val entry = table.entries[i]
    val name = to-symbol(String(entry.name))
    set(return-table, name, new Int{i as int})
  return return-table

public lostanza defn callback-index-table () -> ref<HashTable<Symbol,Int>> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val table = vms.callback-index-table
  val n = table.length
  val return-table = HashTable<Symbol,Int>()
  for (var i:long = 0, i < n, i = i + 1) :
    val entry = table.entries[i]
    val name = to-symbol(String(entry.name))
    set(return-table, name, new Int{entry.index as int})
  return return-table

;============================================================
;===================== Utilities ============================
;============================================================

protected lostanza defn linux-error-msg () -> ref<String> :
  val s = call-c clib/strerror(call-c clib/get_errno())
  return String(s)

;============================================================
;====================== ToString ============================
;============================================================

public defmulti to-string (x) -> String

;                Default Implementation
;                ======================

defmethod to-string (x) -> String :
   val s = StringBuffer()
   print(s, x)
   to-string(s)

defmethod to-string (x:String) : x
defmethod to-string (x:True) : "true"
defmethod to-string (x:False) : "false"

;============================================================
;====================== Error Preconditions =================
;============================================================

defn ensure-divide-non-zero (i:Byte) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0Y)
defn ensure-divide-non-zero (i:Int) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0)
defn ensure-divide-non-zero (i:Long) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0L)

protected defn ensure-index-in-bounds (xs:Lengthable, i:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if i < 0 or i >= length(xs) :
      fatal("Index (%_) out of bounds." % [i])

protected defn ensure-length-in-bounds (xs:Lengthable, i:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if i < 0 or i > length(xs) :
      fatal("Index (%_) out of bounds." % [i])

defn ensure-start-before-end (s:Int, e:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if e < s :
      fatal("Given end index (%_) is smaller than start index (%_)." % [e, s])

protected defn ensure-non-negative (quantity:String, n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if n < 0 :
      fatal("Given %_ (%_) is negative." % [quantity, n])

protected defn ensure-positive (quantity:String, n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if n <= 0 :
      fatal("Given %_ (%_) is not positive." % [quantity, n])

protected defn ensure-non-negative-length (n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    ensure-non-negative("length", n)

protected defn ensure-index-range (xs:Lengthable, r:Range) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if step(r) != 1 :
      fatal("Given index range (%_) does not have a step of 1." % [r])
    val s = start(r)
    match(end(r), inclusive?(r)) :
      (e:Int, inc?:True) :
        ensure-index-in-bounds(xs, s)
        ensure-index-in-bounds(xs, e)
        ensure-start-before-end(s, e)
      (e:Int, inc?:False) :
        ensure-length-in-bounds(xs, s)
        ensure-length-in-bounds(xs, e)
        ensure-start-before-end(s, e)
      (e:False, inc?) :
        ensure-length-in-bounds(xs, s)

protected defn range-bound (s:Lengthable, r:Range) -> [Int, Int] :
  match(end(r), inclusive?(r)) :
    (e:Int, i:True) : [start(r), e + 1]
    (e:Int, i:False) : [start(r), e]
    (e:False, i) : [start(r), length(s)]

;============================================================
;===================== Hashable =============================
;============================================================

public deftype Hashable :
  Char <: Hashable
  Byte <: Hashable
  Int <: Hashable
  Long <: Hashable
  Float <: Hashable
  Double <: Hashable
  Tuple<T> <: Hashable
  List<T> <: Hashable
  String <: Hashable
  Symbol <: Hashable
  True <: Hashable
  False <: Hashable

public defmulti hash (h:Hashable) -> Int

lostanza defmethod hash (a:ref<Char>) -> ref<Int> :
  return new Int{a.value}

lostanza defmethod hash (a:ref<Byte>) -> ref<Int> :
  return new Int{a.value}

defmethod hash (a:Int) -> Int :
  a

lostanza defmethod hash (a:ref<Long>) -> ref<Int> :
  val v = a.value
  return new Int{(v ^ (v >> 32)) as int}

defmethod hash (a:Float) -> Int :
  bits(a)

lostanza defmethod hash (a:ref<Double>) -> ref<Int> :
  val v = a.value
  val bits = ($ls-prim bits v)
  return new Int{(bits ^ (bits >> 32)) as int}

defmethod hash (xs:Tuple<Hashable>) :
  var i = length(xs)
  for x in xs do :
     i = (7 * i) + hash(x)
  i

defmethod hash (xs:List<Hashable>) -> Int :
  var i = 0
  for x in xs do :
    i = (7 * i) + hash(x)
  i

defmethod hash (a:True) : 1
defmethod hash (a:False) : 0

public lostanza defmethod hash (s:ref<String>) -> ref<Int> :
  if s.hash == 0 :
    val n = strlen(s)
    var h:int = 0
    for (var i:long = 0, i < n, i = i + 1) :
      h = (31 * h) + s.chars[i]
    if h == 0 : s.hash = 1
    else : s.hash = h
  return new Int{s.hash}

lostanza defmethod hash (s:ref<StringSymbol>) -> ref<Int> :
  return hash(s.name)

lostanza defmethod hash (s:ref<GenSymbol>) -> ref<Int> :
  return id(s)

;============================================================
;======================= Symbols ============================
;============================================================

public defmulti name (a:Symbol) -> String
public defmulti qualified? (a:Symbol) -> True|False
public defmulti qualifier (a:Symbol) -> [False|Symbol, Symbol]

;                   StringSymbol Functions
;                   ======================
lostanza defn StringSymbol (name:ref<String>) -> ref<StringSymbol> :
  return new StringSymbol{name}

lostanza defmethod name (s:ref<StringSymbol>) -> ref<String> :
  return s.name

defmethod qualified? (s:StringSymbol) :
   contains?(name(s), '/')

defmethod qualifier (s:StringSymbol) :
   match(last-index-of-char(name(s), '/')) :
      (i:Int) :
         val part1 = intern-symbol(name(s)[0 to i])
         val part2 = intern-symbol(name(s)[(i + 1) to false])
         [part1, part2]
      (i:False) :
         [false, s]

defmethod to-string (s:StringSymbol) :
   name(s)

;                  GenSymbol Functions
;                  ===================
public defmulti id (s:GenSymbol) -> Int

defn GenSymbol (name:String) :
   defn make-sym (name:String) :
      val id = genid()
      new GenSymbol :
         defmethod id (this) : id
         defmethod name (this) : name
         defmethod qualified? (this) : false
         defmethod qualifier (this) : [false, this]

   match(last-index-of-char(name, '/')) :
      (i:Int) :
         val id = genid()
         val qualifier = intern-symbol(name[0 to i])
         val unqualified-sym = make-sym(name[(i + 1) to false])
         new GenSymbol :
            defmethod id (this) : id
            defmethod name (this) : name
            defmethod qualified? (this) : true
            defmethod qualifier (this) : [qualifier, unqualified-sym]
      (i:False) :
         make-sym(name)

val ID-COUNTER = to-seq(0 to false)

public defn gensym (x) :
   match(x) :
      (x:Symbol) : gensym(name(x))
      (s:String) : GenSymbol(s)
      (x) : gensym(to-string(x))

public defn gensym () :
   gensym("$gen")

public defn genid () :
   next(ID-COUNTER)

;                    General Functions
;                    =================

public defn prefix? (a:Symbol, p:String) -> True|False :
   prefix?(name(a), p)

;                    Symbol Interning
;                    ================

var INTERNED-SYMBOLS : HashTable<String,Symbol>

lostanza defn initialize-symbol-table () -> ref<False> :
  ;Read number of consts
  val vms:ptr<VMState> = call-prim flush-vm()
  val cdata = vms.const-mem as ptr<int>
  val n-consts = [cdata]

  ;Get pointer to constant table
  val consts = vms.const-table as ptr<ref<?>>

  ;Initialize symbol table
  INTERNED-SYMBOLS = HashTable-init<String,Symbol>(fn(StringSymbol))
  for (var i:int = 0, i < n-consts, i = i + 1) :
    match(consts[i]) :
      (s:ref<Symbol>) : set(INTERNED-SYMBOLS, name(s), s)
      (s) : ()

  ;Done initialization
  initialized-symbol-table? = 1L
  return false

defn intern-symbol (name:String) :
   INTERNED-SYMBOLS[name]

public defn to-symbol (x) :
   match(x) :
      (x:Symbol) : x
      (x:String) : intern-symbol(x)
      (x) : to-symbol(to-string(x))

;============================================================
;===================== OutputStream =========================
;============================================================

;                   General Interface
;                   =================
public deftype OutputStream
public defmulti print (o:OutputStream, x) -> False
public defmulti print-all (o:OutputStream, xs:Seqable) -> False
public defmulti put (o:OutputStream, x) -> False

;                Default Implementations
;                =======================

lostanza val CONVERSION-BUFFER: ptr<byte> = call-c clib/stz_malloc(64)

lostanza defn print-conversion-buffer-float (o:ref<OutputStream>, n:int) -> ref<False> :
  labels :
    begin :
      goto loop(0)
    loop (i:int) :
      if i < n :
        val c = CONVERSION-BUFFER[i]
        if c == '.' : goto rest(i)
        else if c == 'e' : goto add-dot(i)
        else :
          print(o, new Char{c})
          goto loop(i + 1)
      else : goto add-dot(i)
    add-dot (i:int) :
      print(o, new Char{'.'})
      print(o, new Char{'0'})
      goto rest(i)
    rest (i:int) :
      if i < n :
        print(o, new Char{CONVERSION-BUFFER[i]})
        goto rest(i + 1)
  return false

lostanza defn print-conversion-buffer-float (o:ptr<?>, n:int) -> ref<False> :
  labels :
    begin :
      goto loop(0)
    loop (i:int) :
      if i < n :
        val c = CONVERSION-BUFFER[i]
        if c == '.' : goto rest(i)
        else if c == 'e' : goto add-dot(i)
        else :
          call-c clib/fputc(c, o)
          goto loop(i + 1)
      else : goto add-dot(i)
    add-dot (i:int) :
      call-c clib/fputc('.', o)
      call-c clib/fputc('0', o)
      goto rest(i)
    rest (i:int) :
      if i < n :
        call-c clib/fputc(CONVERSION-BUFFER[i], o)
        goto rest(i + 1)
  return false

lostanza defn print-conversion-buffer (o:ref<OutputStream>, n:int) -> ref<False> :
   for (var i:int = 0, i < n, i = i + 1) :
      print(o, new Char{CONVERSION-BUFFER[i]})
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Byte>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value as int)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Int>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Long>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%lld", x.value)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Float>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.6g", x.value as double)
   print-conversion-buffer-float(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Double>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.15g", x.value)
   print-conversion-buffer-float(o, n)
   return false

defmethod print (o:OutputStream, x:True) :
   print(o, "true")

defmethod print (o:OutputStream, x:False) :
   print(o, "false")

defmethod print (o:OutputStream, x:String) :
   print-all(o, x)

lostanza defn stackframes (c:ref<RawCoroutine>) -> ref<Long> :
  return new Long{c.stack.frames as long}

defmethod print (o:OutputStream, c:RawCoroutine) :
  val s = switch {status(c) == _} :
    COROUTINE-ACTIVE : "ACTIVE"
    COROUTINE-CLOSED : "CLOSED"
    COROUTINE-SUSPENDED : "SUSPENDED"
    COROUTINE-OPEN : "OPEN"
  print(o, "<Coroutine #%_ : %_>" % [id(c), s])

defmethod print (o:OutputStream, t:Tuple) -> False :
   print(o, "[%@]" % [t])

defmethod print (o:OutputStream, xs:List) -> False :
   print(o, "(%@)" % [xs])

defmethod print (o:OutputStream, s:StringSymbol) :
   print(o, name(s))

defmethod print (o:OutputStream, s:GenSymbol) :
   print(o, name(s))
   print(o, id(s))

defmethod print (o:OutputStream, x) :
  print(o, "[%_ object]" % [object-type(x)])

defmethod print-all (o:OutputStream, xs:Seqable) :
   do(print{o, _}, xs)

;                 Convenience Functions
;                 =====================

public defn println (o:OutputStream, x) :
  print(o, x)
  print(o, NL)

public defn lnprint (o:OutputStream, x) :
  print(o, NL)
  print(o, x)

public defn println-all (o:OutputStream, xs:Seqable) :
   print-all(o, xs)
   print(o, NL)

;============================================================
;==================== Printing of Types =====================
;============================================================

defmethod print (o:OutputStream, t:Type) :
  defn loop (t:String|Type) :
    match(t) :
      (t:String) : print(o, t)
      (t:Type) : do(loop, parts(t))
  do(loop, parts(t))

lostanza defn parts (t:ref<Type>) -> ref<Tuple<String|Type>> :
  val code = t.code as ptr<(ref<Type> -> ref<Tuple>)>
  return [code](t)

;============================================================
;=================== FileOutputStream =======================
;============================================================

public lostanza deftype FileOutputStream <: OutputStream :
  file: ptr<?>
  closable?: long

public lostanza defn FileOutputStream (filename:ref<String>, append?:ref<True|False>) -> ref<FileOutputStream> :
   var file : ptr<?>
   if append? == true : file = call-c clib/fopen(addr!(filename.chars), "ab")
   else : file = call-c clib/fopen(addr!(filename.chars), "wb")
   if file == null : throw(FileOpenException(filename, linux-error-msg()))
   return new FileOutputStream{file, 1}

public defn FileOutputStream (filename:String) :
   FileOutputStream(filename, false)

public lostanza defn close (o:ref<FileOutputStream>) -> ref<False> :
   if o.closable? :
      val err = call-c clib/fclose(o.file)
      if err != 0 : throw(FileCloseException(linux-error-msg()))
   else : fatal("System OutputStream is not closable.")
   return false

public lostanza defn flush (o:ref<FileOutputStream>) -> ref<False> :
  val err = call-c clib/fflush(o.file)
  if err != 0 : throw(FileFlushException(linux-error-msg()))
  return false

lostanza defmethod put (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod put (o:ref<FileOutputStream>, x:ref<Char>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

defmethod put (o:OutputStream, c:Char) -> False :
   put(o, to-byte(c))

defmethod put (o:OutputStream, i:Int) -> False :
   put(o, to-byte(i))
   put(o, to-byte(i >> 8))
   put(o, to-byte(i >> 16))
   put(o, to-byte(i >> 24))

defmethod put (o:OutputStream, i:Long) -> False :
   put(o, to-byte(i))
   put(o, to-byte(i >> 8L))
   put(o, to-byte(i >> 16L))
   put(o, to-byte(i >> 24L))
   put(o, to-byte(i >> 32L))
   put(o, to-byte(i >> 40L))
   put(o, to-byte(i >> 48L))
   put(o, to-byte(i >> 56L))

defmethod put (o:OutputStream, i:Float) -> False :
   put(o, bits(i))

defmethod put (o:OutputStream, i:Double) -> False :
   put(o, bits(i))

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<String>) -> ref<False> :
   val r = call-c clib/fputs(addr!(x.chars), o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value as int)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Char>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Int>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Long>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%lld", x.value)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Float>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.6g", x.value as double)
   print-conversion-buffer-float(o.file, n)
   if call-c clib/ferror(o.file) != 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Double>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.15g", x.value)
   print-conversion-buffer-float(o.file, n)
   if call-c clib/ferror(o.file) != 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<True>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "true")
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<False>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "false")
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

public defn with-output-file<?T> (file:FileOutputStream, f: () -> ?T) -> T :
   try : with-output-stream(file, f)
   finally : close(file)

public defn spit (filename:String, x) -> False :
   val o = FileOutputStream(filename, false)
   try : print(o, x)
   finally : close(o)

;============================================================
;================ System Output Streams =====================
;============================================================

;                 System Output Streams
;                 =====================

public lostanza val STANDARD-OUTPUT-STREAM : ref<OutputStream> =
   new FileOutputStream{stdout, 0}

public lostanza val STANDARD-ERROR-STREAM : ref<OutputStream> =
   new FileOutputStream{stderr, 0}

public lostanza val STANDARD-INPUT-STREAM : ref<InputStream> =
   new FileInputStream{stdin, 0}

;                 Current Output Stream
;                 =====================

var CURRENT-OUTPUT-STREAM : OutputStream = STANDARD-OUTPUT-STREAM

public defn with-output-stream<?T> (o:OutputStream, f: () -> ?T) -> T :
  let-var CURRENT-OUTPUT-STREAM = o :
    f()

public defn current-output-stream () :
  CURRENT-OUTPUT-STREAM

public defn set-current-output-stream (o:OutputStream) :
  CURRENT-OUTPUT-STREAM = o

;                 Current Error Stream
;                 ====================

var CURRENT-ERROR-STREAM : OutputStream = STANDARD-ERROR-STREAM
lostanza var current-err:ptr<?> = stderr

public defn with-error-stream<?T> (o:OutputStream, body: () -> ?T) -> T :
  val oldv = CURRENT-ERROR-STREAM
  dynamic-wind(
    fn () : set-current-error-stream(o)
    body
    fn (f) : set-current-error-stream(oldv))

public defn current-error-stream () :
  CURRENT-ERROR-STREAM

public defn set-current-error-stream (o:OutputStream) :
  CURRENT-ERROR-STREAM = o
  match(o:FileOutputStream) :
    set-current-err(o)

lostanza defn set-current-err (o:ref<FileOutputStream>) -> ref<False> :
  current-err = o.file
  return false

;              Print to Current Output Stream
;              ==============================

public defn print (x) :
   print(CURRENT-OUTPUT-STREAM, x)

public defn println (x) :
   println(CURRENT-OUTPUT-STREAM, x)

public defn print-all (xs:Seqable) :
   do(print, xs)

public defn println-all (xs:Seqable) :
   println-all(CURRENT-OUTPUT-STREAM, xs)

;============================================================
;=================== Input Streams ==========================
;============================================================

;                      Interface
;                      =========

public deftype InputStream
public defmulti get-char (i:InputStream) -> Char|False
public defmulti get-byte (i:InputStream) -> Byte|False
public defmulti fill (xs:CharArray, r:Range, i:InputStream) -> Int

;                Abstract Implementations
;                ========================

defmethod fill (xs:CharArray, r:Range, s:InputStream) -> Int :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   defn* loop (i:Int) :
      if i < e :
         match(get-char(s)) :
            (c:Char) :
               xs[i] = c
               loop(i + 1)
            (c:False) : i - b
      else : i - b
   loop(b)

;============================================================
;=============== Buffered Input Streams =====================
;============================================================

public deftype BufferedInputStream <: InputStream

;                      Interface
;                      =========

public defmulti peek? (i:BufferedInputStream, n:Int) -> Char|False
public defmulti peek-fill (xs:CharArray, r:Range, i:BufferedInputStream) -> Int

;                Abstract Implementations
;                ========================

public defn peek? (i:BufferedInputStream) -> Char|False :
   peek?(i, 0)

;                     Creation
;                     ========

deftype CharQueue <: Lengthable
defmulti peek (c:CharQueue, i:Int) -> Char
defmulti pop (c:CharQueue) -> Char
defmulti peek-fill (xs:CharArray, b:Int, e:Int, c:CharQueue) -> Int
defmulti pop-fill (xs:CharArray, b:Int, e:Int, c:CharQueue) -> Int
defmulti fill (xs:CharQueue, stream:InputStream) -> False

defn CharQueue (cap:Int) :
   val array = CharArray(cap)
   var start:Int = 0
   var len:Int = 0

   defn wrap (i:Int) :
      val idx = start + i
      idx when idx < cap else idx - cap

   defn copy (xs:CharArray, b:Int, e:Int) :
      val n = e - b
      val n1 = cap - start
      val n2 = n - n1
      if n <= n1 :
         block-copy(n, xs, b, array, start)
      else :
         block-copy(n1, xs, b, array, start)
         block-copy(n2, xs, b + n1, array, 0)

   new CharQueue :
      defmethod length (this) :
         len
      defmethod peek (this, i:Int) :
         array[wrap(i)]
      defmethod pop (this) :
         val c = array[start]
         start = wrap(1)
         len = len - 1
         c
      defmethod peek-fill (xs:CharArray, b:Int, e:Int, this) -> Int :
         val n = min(e - b, len)
         copy(xs, b, b + n)
         n
      defmethod pop-fill (xs:CharArray, b:Int, e:Int, this) -> Int :
         val n = peek-fill(xs, b, e, this)
         start = wrap(n)
         len = len - n
         n
      defmethod fill (this, stream:InputStream) -> False :
         val pos = wrap(len)
         val total-read =
            if len == 0 :
               start = 0
               fill(array, 0 to cap, stream)
            else if start < pos :
               val n1 = cap - pos
               val n1* = fill(array, pos to cap, stream)
               if n1* < n1 : n1*
               else : n1* + fill(array, 0 to start, stream)
            else :
               fill(array, pos to start, stream)
         len = len + total-read

public defn BufferedInputStream (i:InputStream) -> BufferedInputStream :
   BufferedInputStream(i, 1024)

public defn BufferedInputStream (stream:InputStream, size:Int) -> BufferedInputStream :
   ensure-positive("buffer size", size)

   val buffer = CharQueue(size)

   new BufferedInputStream :
      defmethod peek? (this, i:Int) -> False|Char :
         #if-not-defined(OPTIMIZE) :
            if i < 0 :
               fatal("Cannot peek? into a BufferedInputStream at a negative index.")
            if i >= size :
               fatal("Cannot peek? %_ chars ahead into BufferedInputStream with buffer size %_." % [i, size])
         if length(buffer) > i :
            peek(buffer, i)
         else :
            fill(buffer, stream)
            peek(buffer, i) when length(buffer) > i

      defmethod peek-fill (xs:CharArray, r:Range, this) -> Int :
         val [b, e] = range-bound(xs, r)
         val n = e - b
         #if-not-defined(OPTIMIZE) :
            if n > size :
               fatal("Cannot peek more characters (%_) than capacity of buffer (%_)." % [n, size])
         fill(buffer, stream) when length(buffer) < n
         peek-fill(xs, b, e, buffer)

      defmethod fill (xs:CharArray, r:Range, this) -> Int :
         val [b, e] = range-bound(xs, r)
         val n = e - b
         if n < size :
            fill(buffer, stream) when length(buffer) < n
            pop-fill(xs, b, e, buffer)
         else :
            val n1 = pop-fill(xs, b, e, buffer)
            if n1 < n : n1 + fill(xs, (b + n1) to e, stream)
            else : n1

      defmethod get-char (this) -> False|Char :
         fill(buffer, stream) when length(buffer) == 0
         pop(buffer) when length(buffer) > 0

      defmethod get-byte (this) :
         match(get-char(this)) :
            (c:Char) : to-byte(c)
            (c:False) : false

;============================================================
;================= File Input Streams =======================
;============================================================

public lostanza deftype FileInputStream <: InputStream :
  file: ptr<?>
  closable?: long

public lostanza defn FileInputStream (filename:ref<String>) -> ref<FileInputStream> :
   val file = call-c clib/fopen(addr!(filename.chars), "rb")
   if file == null : throw(FileOpenException(filename, linux-error-msg()))
   return new FileInputStream{file, 1}

public lostanza defn close (i:ref<FileInputStream>) -> ref<False> :
   if i.closable? :
      val err = call-c clib/fclose(i.file)
      if err != 0 : throw(FileCloseException(linux-error-msg()))
   else : fatal("System Input Stream is not closable.")
   return false

lostanza defmethod get-char (i:ref<FileInputStream>) -> ref<Char|False> :
   val c = call-c clib/fgetc(i.file)
   if c == EOF :
      val err = call-c clib/ferror(i.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Char{c as byte}

lostanza defmethod get-byte (i:ref<FileInputStream>) -> ref<Byte|False> :
   val c = call-c clib/fgetc(i.file)
   if c == EOF :
      val err = call-c clib/ferror(i.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Byte{c as byte}

public defn get-int (i:InputStream) -> False|Int :
   defn get-byte! (i:InputStream) :
      match(get-byte(i)) :
         (b:Byte) : b
         (b:False) : fail()
   attempt :
      val b0 = to-int(get-byte!(i))
      val b1 = to-int(get-byte!(i))
      val b2 = to-int(get-byte!(i))
      val b3 = to-int(get-byte!(i))
      (b0) |
      (b1 << 8) |
      (b2 << 16) |
      (b3 << 24)

public defn get-long (i:InputStream) -> False|Long :
   defn get-int! (i:InputStream) :
      match(get-int(i)) :
         (x:Int) : x
         (x:False) : fail()
   attempt :
      val w0 = to-long(get-int!(i))
      val w1 = to-long(get-int!(i))
      (w0 & 0xFFFFFFFFL) |
      (w1 << 32L)

public defn get-float (i:InputStream) -> False|Float :
   match(get-int(i)) :
      (x:Int) : bits-as-float(x)
      (x:False) : false

public defn get-double (i:InputStream) -> False|Double :
   match(get-long(i)) :
      (x:Long) : bits-as-double(x)
      (x:False) : false

public defn slurp (filename:String) :
   val s = FileInputStream(filename)
   try :
      val buffer = StringBuffer()
      defn* loop () :
         match(get-char(s)) :
            (c:Char) :
               add(buffer, c)
               loop()
            (c:False) : false
      loop()
      to-string(buffer)
   finally : close(s)

public defn file-exists? (filename:String) :
   try :
      close(FileInputStream(filename))
      true
   catch (e:Exception) :
      false

;============================================================
;================== RandomAccessFiles =======================
;============================================================

public lostanza deftype RandomAccessFile :
  file: ptr<?>
  writable: ref<True|False>

public lostanza defn RandomAccessFile (filename:ref<String>, writable:ref<True|False>) -> ref<RandomAccessFile> :
  if writable == true :
    var file:ptr<?> = call-c clib/fopen(addr!(filename.chars), "r+b")
    if file == null :
      file = call-c clib/fopen(addr!(filename.chars), "w+b")
      if file == null : throw(FileOpenException(filename, linux-error-msg()))
      return new RandomAccessFile{file, writable}
    else :
      return new RandomAccessFile{file, writable}
  else :
    val file = call-c clib/fopen(addr!(filename.chars), "rb")
    if file == null : throw(FileOpenException(filename, linux-error-msg()))
    return new RandomAccessFile{file, writable}

public lostanza defn output-stream (file:ref<RandomAccessFile>) -> ref<FileOutputStream> :
  if file.writable == false :
    throw(FileNotWritableException())
  return new FileOutputStream{file.file, 0}

public lostanza defn input-stream (file:ref<RandomAccessFile>) -> ref<FileInputStream> :
  return new FileInputStream{file.file, 0}

public lostanza defn close (f:ref<RandomAccessFile>) -> ref<False> :
  val err = call-c clib/fclose(f.file)
  if err != 0 : throw(FileCloseException(linux-error-msg()))
  return false

public lostanza defn flush (f:ref<RandomAccessFile>) -> ref<False> :
  val err = call-c clib/fflush(f.file)
  if err != 0 : throw(FileFlushException(linux-error-msg()))
  return false

public lostanza defn writable? (f:ref<RandomAccessFile>) -> ref<True|False> :
  return f.writable

public lostanza defn length (f:ref<RandomAccessFile>) -> ref<Long> :
  return new Long{call-c clib/get_file_size(f.file)}

public lostanza defn position (f:ref<RandomAccessFile>) -> ref<Long> :
  return new Long{call-c clib/ftell(f.file)}

public lostanza defn time-modified (filename:ref<String>) -> ref<Long> :
  val t = call-c clib/file_time_modified(addr!(filename.chars))
  if t == 0 : throw(FileStatException(filename, linux-error-msg()))
  return new Long{t}

public lostanza defn set-length (f:ref<RandomAccessFile>, len:ref<Long>) -> ref<False> :
  val err = call-c clib/file_set_length(f.file, len.value)
  if err != 0 : throw(FileSetLengthException(linux-error-msg()))
  return false

public lostanza defn seek (f:ref<RandomAccessFile>, pos:ref<Long>) -> ref<False> :
  val err = call-c clib/file_seek(f.file, pos.value)
  if err != 0 : throw(FileSeekException(linux-error-msg()))
  return false

public lostanza defn skip (f:ref<RandomAccessFile>, pos:ref<Long>) -> ref<False> :
  val err = call-c clib/file_skip(f.file, pos.value)
  if err != 0 : throw(FileSeekException(linux-error-msg()))
  return false

public lostanza defn get-byte (f:ref<RandomAccessFile>) -> ref<Byte|False> :
  val c = call-c clib/fgetc(f.file)
  if c == EOF :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
    return false
  else :
    return new Byte{c as byte}

public defn get-char (f:RandomAccessFile) -> Char|False :
  match(get-byte(f)) :
    (b:Byte) : to-char(b)
    (b:False) : b

public lostanza defn get-int (f:ref<RandomAccessFile>) -> ref<Int|False> :
  val b0 = call-c clib/fgetc(f.file)
  val b1 = call-c clib/fgetc(f.file)
  val b2 = call-c clib/fgetc(f.file)
  val b3 = call-c clib/fgetc(f.file)
  if b3 == EOF :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
    return false
  else :
    return new Int{
      (b0) |
      (b1 << 8) |
      (b2 << 16) |
      (b3 << 24)}

public lostanza defn get-long (f:ref<RandomAccessFile>) -> ref<Long|False> :
  val b0 = call-c clib/fgetc(f.file)
  val b1 = call-c clib/fgetc(f.file)
  val b2 = call-c clib/fgetc(f.file)
  val b3 = call-c clib/fgetc(f.file)
  val b4 = call-c clib/fgetc(f.file)
  val b5 = call-c clib/fgetc(f.file)
  val b6 = call-c clib/fgetc(f.file)
  val b7 = call-c clib/fgetc(f.file)
  if b7 == EOF :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
    return false
  else :
    return new Long{
      (b0) |
      (b1 << 8L) |
      (b2 << 16L) |
      (b3 << 24L) |
      (b4 << 32L) |
      (b5 << 40L) |
      (b6 << 48L) |
      (b7 << 56L)}

public defn get-float (f:RandomAccessFile) -> Float|False :
  match(get-int(f)) :
    (i:Int) : bits-as-float(i)
    (i:False) : false

public defn get-double (f:RandomAccessFile) -> Double|False :
  match(get-long(f)) :
    (i:Long) : bits-as-double(i)
    (i:False) : false

public lostanza defn fill (a:ref<ByteArray>, r:ref<Range>, f:ref<RandomAccessFile>) -> ref<Long> :
  ;Get range bounds
  ensure-index-range(a, r)
  val rb = range-bound(a, r)
  val b = get(rb, new Int{0}).value
  val e = get(rb, new Int{1}).value
  val len = e - b
  ;Read block
  val ptr = addr!(a.data) + b
  val n = call-c clib/file_read_block(f.file, ptr, len)
  ;Check errors
  if n < len :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
  ;Return bytes read
  return new Long{n}

public defn fill (a:ByteArray, f:RandomAccessFile) -> Long :
  fill(a, 0 to false, f)

defn ensure-writable (f:RandomAccessFile) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if not writable?(f) :
      fatal("RandomAccessFile is not writable.")

public lostanza defn put (f:ref<RandomAccessFile>, xs:ref<ByteArray>, r:ref<Range>) -> ref<False> :
  ensure-writable(f)
  ;Get range bounds
  ensure-index-range(xs, r)
  val rb = range-bound(xs, r)
  val b = get(rb, new Int{0}).value
  val e = get(rb, new Int{1}).value
  val len = e - b
  ;Write block
  val ptr = addr!(xs.data) + b
  val n = call-c clib/file_write_block(f.file, ptr, len)
  ;Check errors
  if n < len :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileWriteException(linux-error-msg()))
  ;Done
  return false

public defn put (f:RandomAccessFile, xs:ByteArray) -> False :
  put(f, xs, 0 to false)

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Byte>) -> ref<False> :
  ensure-writable(f)
  val r = call-c clib/fputc(x.value, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Char>) -> ref<False> :
  ensure-writable(f)
  val r = call-c clib/fputc(x.value, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Int>) -> ref<False> :
  ensure-writable(f)
  val fp = f.file
  val xv = x.value
  call-c clib/fputc(xv as byte, f.file)
  call-c clib/fputc((xv >> 8) as byte, f.file)
  call-c clib/fputc((xv >> 16) as byte, f.file)
  val r = call-c clib/fputc((xv >> 24) as byte, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Long>) -> ref<False> :
  ensure-writable(f)
  val fp = f.file
  val xv = x.value
  call-c clib/fputc(xv as byte, f.file)
  call-c clib/fputc((xv >> 8L) as byte, f.file)
  call-c clib/fputc((xv >> 16L) as byte, f.file)
  call-c clib/fputc((xv >> 24L) as byte, f.file)
  call-c clib/fputc((xv >> 32L) as byte, f.file)
  call-c clib/fputc((xv >> 40L) as byte, f.file)
  call-c clib/fputc((xv >> 48L) as byte, f.file)
  val r = call-c clib/fputc((xv >> 56L) as byte, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public defn put (f:RandomAccessFile, x:Float) -> False :
  put(f, bits(x))

public defn put (f:RandomAccessFile, x:Double) -> False :
  put(f, bits(x))

;============================================================
;===================== ByteBuffer ===========================
;============================================================

public deftype ByteBuffer <: IndexedCollection<Byte> & OutputStream
public defmulti clear (b:ByteBuffer) -> False
public defmulti set-write-position (b:ByteBuffer, h:Int) -> False
public defmulti write-position (b:ByteBuffer) -> Int

public defn ByteBuffer (n:Int) -> ByteBuffer :
  ensure-non-negative("length", n)
  var buffer = ByteArray(n)
  var len:Int = 0
  var head:Int = 0

  defn ensure-capacity (c:Int) :
    defn set-capacity (c:Int) :
      val buffer* = ByteArray(c)
      block-copy(len, buffer*, 0, buffer, 0)
      buffer = buffer*
    val cur-c = length(buffer)
    set-capacity(max(c, 2 * cur-c)) when c > cur-c

  new ByteBuffer :
    defmethod backing-array (this) :
      buffer

    defmethod put (this, c:Byte) :
      ensure-capacity(head + 1)
      buffer[head] = c
      head = head + 1
      len = max(len, head)

    defmethod clear (this) :
      len = 0
      head = 0

    defmethod get (this, i:Int) :
      ensure-index-in-bounds(this, i)
      buffer[i]

    defmethod get (this, r:Range) :
      ensure-index-range(this, r)
      val [b, e] = range-bound(this, r)
      buffer[b to e]

    defmethod set (this, i:Int, b:Byte) :
      if i == head :
        put(this, b)
      else :
        ensure-index-in-bounds(this, i)
        buffer[i] = b

    defmethod length (this) :
      len

    defmethod set-write-position (this, h:Int) :
      ensure-length-in-bounds(this, h)
      head = h

    defmethod write-position (this) :
      head

defmulti backing-array (b:ByteBuffer) -> ByteArray
public lostanza defn data (b:ref<ByteBuffer>) -> ptr<byte> :
  return addr!(backing-array(b).data)

public defn ByteBuffer () :
  ByteBuffer(32)

defmethod print (b:ByteBuffer, c:Char) :
  put(b, to-byte(c))

defmethod print (o:OutputStream, b:ByteBuffer) :
  print(o, "[ByteBuffer: %_ bytes]" % [length(b)])

public defn OutputStream (b:ByteBuffer, i:Int) :
  var pos = i
  defn inc-pos () :
    val cur-pos = pos
    pos = pos + 1
    cur-pos
  new OutputStream :
    defmethod put (this, x:Byte) : b[inc-pos()] = x
    defmethod print (this, x:Char) : b[inc-pos()] = to-byte(x)

public defn InputStream (b:ByteBuffer, i:Int) :
  var pos = i
  defn inc-pos () :
    val cur-pos = pos
    pos = pos + 1
    cur-pos
  new InputStream :
    defmethod get-char (this) : to-char(b[inc-pos()]) when pos < length(b)
    defmethod get-byte (this) : b[inc-pos()] when pos < length(b)

public defn OutputStream (b:ByteBuffer) : OutputStream(b, 0)
public defn InputStream (b:ByteBuffer) : InputStream(b, 0)

;============================================================
;=================== StringBuffer ===========================
;============================================================

public deftype StringBuffer <: IndexedCollection<Char> & OutputStream

;                     Interface
;                     =========

public defmulti add (s:StringBuffer, c:Char) -> False
public defmulti add-all (s:StringBuffer, c:Seqable<Char>) -> False
public defmulti clear (s:StringBuffer) -> False

;               Abstract Implementation
;               =======================

defmethod add-all (s:StringBuffer, xs:Seqable<Char>) :
   do(add{s, _}, xs)

defmethod print (s:StringBuffer, c:Char) : add(s, c)
defmethod print (s:StringBuffer, cs:String) : add-all(s, cs)
defmethod print (s:StringBuffer, cs:StringBuffer) : add-all(s, cs)
defmethod print (s:StringBuffer, cs:CharArray) : add-all(s, cs)

defmethod print-all (s:StringBuffer, cs:String) : add-all(s, cs)
defmethod print-all (s:StringBuffer, cs:StringBuffer) : add-all(s, cs)
defmethod print-all (s:StringBuffer, cs:CharArray) : add-all(s, cs)

defmethod write (o:OutputStream, s:StringBuffer) :
   print(o, '"')
   for c in s do :
      escape-for-string(o, c)
   print(o, '"')

;                   Implementation
;                   ==============

public defn StringBuffer (n:Int) -> StringBuffer :
   ensure-non-negative("length", n)
   var buffer = CharArray(n)
   var len = 0

   defn ensure-capacity (c:Int) :
      defn set-capacity (c:Int) :
         val buffer* = CharArray(c)
         block-copy(len, buffer*, 0, buffer, 0)
         buffer = buffer*
      val cur-c = length(buffer)
      set-capacity(max(c, 2 * cur-c)) when c > cur-c

   new StringBuffer :
      defmethod add (this, c:Char) :
         ensure-capacity(len + 1)
         buffer[len] = c
         len = len + 1

      defmethod add-all (this, xs:Seqable<Char> & Lengthable) :
         val n = length(xs)
         ensure-capacity(len + n)
         for (x in xs, i in 0 to n) do :
            buffer[len + i] = x
         len = len + n

      defmethod clear (this) :
         len = 0

      defmethod get (this, i:Int) :
         ensure-index-in-bounds(this, i)
         buffer[i]

      defmethod get (this, r:Range) :
         ensure-index-range(this, r)
         val [b, e] = range-bound(this, r)
         buffer[b to e]

      defmethod set (this, i:Int, c:Char) :
         if i == len :
            add(this, c)
         else :
            ensure-index-in-bounds(this, i)
            buffer[i] = c

      defmethod length (this) :
         len

      defmethod to-string (this) :
         buffer[0 to len] as String

public defn StringBuffer () :
   StringBuffer(32)

;============================================================
;==================== Remove File ===========================
;============================================================

public lostanza defn delete-file (path:ref<String>) -> ref<False> :
   val r = call-c clib/remove(addr!(path.chars))
   if r == -1 : throw(FileDeletionError(path, linux-error-msg()))
   return false

public deftype FileDeletionError <: Exception
public defn FileDeletionError (path:String, msg:String) :
   new FileDeletionError :
      defmethod print (o:OutputStream, this) :
         print{o, _} $
         "Error when attempting to delete %_. %_." % [path, msg]

;============================================================
;====================== Rename a File =======================
;============================================================

public lostanza defn rename-file (path:ref<String>, new-path:ref<String>) -> ref<False> :
  val r = call-c clib/rename(addr!(path.chars), addr!(new-path.chars))
  if r == -1 : throw(FileRenameError(path, linux-error-msg()))
  return false

public deftype FileRenameError <: Exception
public defn FileRenameError (path:String, msg:String) :
   new FileRenameError :
      defmethod print (o:OutputStream, this) :
         print{o, _} $
         "Error when attempting to rename %_. %_." % [path, msg]

;============================================================
;===================== Copying a File =======================
;============================================================

public defn copy-file (old-path:String, new-path:String) :
  val old-file = RandomAccessFile(old-path, false)
  val new-file = RandomAccessFile(new-path, true)
  try :
    val buffer = ByteArray(1042 * 1024)
    val end = length(old-file)
    while position(old-file) < end :
      val nbytes = to-int(fill(buffer, old-file))
      put(new-file, buffer, 0 to nbytes)
  finally :
    close(old-file)
    close(new-file)

;============================================================
;===================== FilePaths ============================
;============================================================

public lostanza defn resolve-path (path:ref<String>) -> ref<String|False> :
   val rpath = call-c clib/resolve_path(addr!(path.chars))
   if rpath == null :
      return false
   else :
      val s = String(rpath)
      call-c clib/stz_free(rpath)
      return s

public defn resolve-path! (path:String) -> String :
  match(resolve-path(path)) :
    (p:String) : p
    (f:False) : throw(PathResolutionError(path))

public defn norm-path (path) -> String :
   #if-defined(PLATFORM-WINDOWS) :
      replace(to-string(path), '/', '\\')
   #else :
      to-string(path)

;============================================================
;================= Get the File Type ========================
;============================================================

public deftype FileType
public defstruct RegularFileType <: FileType
public defstruct DirectoryType <: FileType
public defstruct OtherType <: FileType

defmethod print (o:OutputStream, t:FileType) :
  print{o, _} $ match(t) :
    (t:RegularFileType) : "Regular File"
    (t:DirectoryType) : "Directory"
    (t:OtherType) : "Other"

extern get_file_type: ptr<byte> -> int
public lostanza defn file-type (filename:ref<String>) -> ref<FileType> :
  val r = call-c get_file_type(addr!(filename.chars))
  if r == -1 : throw(FileTypeException(filename, linux-error-msg()))
  if r == 0 : return RegularFileType()
  else if r == 1 : return DirectoryType()
  else if r == 2 : return OtherType()
  else : return throw(FileTypeException(filename))

public defstruct FileTypeException <: IOException :
  filename: String
  cause: String|False with: (default => false)
defmethod print (o:OutputStream, e:FileTypeException) :
  val cause-str = match(cause(e)) :
    (c:String) : ": %_" % [c]
    (c:False) : ""
  print(o, "Error occurred when determining type of file %_%_." % [filename(e), cause-str])

;============================================================
;================ List Contents of Directory ================
;============================================================

extern free_stringlist : ptr<StringList> -> int
lostanza deftype StringList :
  n: int
  capacity: int
  strings: ptr<ptr<byte>>
  
extern list_dir: ptr<byte> -> ptr<StringList>
public lostanza defn dir-files (dirname:ref<String>, include-parents?:ref<True|False>) -> ref<Tuple<String>> :
  ;Call list dir
  val list = call-c list_dir(addr!(dirname.chars))
  val null = 0L as ptr<?>
  if list == null: throw(DirException(dirname, linux-error-msg()))
  ;Convert to vector
  val strings = Vector<String>()
  for (var i:int = 0, i < list.n, i = i + 1) :
    add(strings, String(list.strings[i]))
  ;Free stringlist
  call-c free_stringlist(list)
  ;Apply filter
  if include-parents? == true : return to-tuple(strings)
  else : return to-tuple(filter(fn(without-parents), strings))

defn without-parents (name:String) : name != "." and name != ".."

public defn dir-files (dirname:String) : dir-files(dirname, false)

public defstruct DirException <: IOException :
  filename: String
  cause: String
defmethod print (o:OutputStream, e:DirException) :
  print(o, "Error occurred when listing contents of directory %_: %_." % 
    [filename(e), cause(e)])

;============================================================
;================== Split a Filepath ========================
;============================================================

public defn split-filepath (path:String) -> [String, String] :
  val n = length(path)
  match(last-index-of-char(path, '/')) :
    (i:Int) :
      throw(PathEndsWithSlash(path)) when i == n - 1        
      [path[0 through i], path[(i + 1) to false]]
    (i:False) :
      throw(EmptyPath()) when n == 0
      ["./", path]

public deftype PathException <: Exception

public defstruct PathEndsWithSlash <: PathException :
  path: String
defmethod print (o:OutputStream, e:PathEndsWithSlash) :
  print(o, PEWS-MSG % [path(e)])
val PEWS-MSG = "Could not determine project name. Path %~ ends with a slash."

public defstruct EmptyPath <: PathException
defmethod print (o:OutputStream, e:EmptyPath) :
  print(o, EP-MSG)
val EP-MSG = "Could not determine project name. The given path is empty."

;============================================================
;================== Recursively Delete ======================
;============================================================

public defn delete-recursive (path:String) :
  if file-type(path) is DirectoryType :
    for file in dir-files(path) do :
      delete-recursive(norm-path("%_/%_" % [path, file]))
  delete-file(path)

;============================================================
;================ Create a New Directory ====================
;============================================================

extern mkdir: (ptr<byte>, long) -> int

public lostanza defn create-dir (dirname:ref<String>, 
                                 permissions:ref<Int>) -> ref<False> :
  val result = call-c mkdir(addr!(dirname.chars), permissions.value)
  if result == -1 : throw(CreateDirException(dirname, linux-error-msg()))  
  return false

public defn create-dir (dirname:String) :
  create-dir(dirname, 0o777)

public defstruct CreateDirException <: IOException :
  filename: String
  cause: String
defmethod print (o:OutputStream, e:CreateDirException) :
  print(o, "Error occurred when attempting to create directory %_: %_." % 
    [filename(e), cause(e)])

;============================================================
;================ Environment Variables =====================
;============================================================

public lostanza defn get-env (name:ref<String>) -> ref<String|False> :
  val value = call-c clib/getenv(addr!(name.chars))
  if value == null : return false
  else : return String(value)

public defn get-env! (name:String) -> String :
  val v = get-env(name)
  match(v:String) : v
  else : throw(NoEnvVarError(name))

public lostanza defn set-env (name:ref<String>, value:ref<String>, overwrite:ref<True|False>) -> ref<False> :
  var ov:int = 0
  if overwrite == true : ov = 1
  val r = call-c clib/setenv(addr!(name.chars), addr!(value.chars), ov)
  if r != 0 : throw(SetEnvException(name, value, linux-error-msg()))
  return false

public defn set-env (name:String, value:String) :
  set-env(name, value, true)

public lostanza defn unset-env (name:ref<String>) -> ref<False> :
  val r = call-c clib/unsetenv(addr!(name.chars))
  if r != 0 : throw(UnsetEnvException(name, linux-error-msg()))
  return false

public defstruct NoEnvVarError <: Exception :
  name: String

public defstruct SetEnvException <: Exception :
  name: String
  value: String
  cause: String

defmethod print (o:OutputStream, e:SetEnvException) :
   print(o, "Could not set environment variable %_ to %~. %_." % [name(e), value(e), cause(e)])

public defstruct UnsetEnvException <: Exception :
  name: String
  cause: String
defmethod print (o:OutputStream, e:UnsetEnvException) :
  print(o, "Could not unset environment variable %_. %_." % [name(e), cause(e)])

;============================================================
;================== Exit System =============================
;============================================================

public lostanza defn exit (code:ref<Int>) -> ref<Void> :
   call-c clib/exit(code.value)
   return null as ref<Void>

;============================================================
;===================== Exceptions ===========================
;============================================================

public deftype Exception

public defn Exception (msg) :
   new Exception :
      defmethod print (o:OutputStream, this) :
         print(o, msg)

var CURRENT-EXCEPTION-HANDLER : Exception -> Void =
   fn (e:Exception) :
      fatal(e)

public defn throw (e:Exception) :
   CURRENT-EXCEPTION-HANDLER(e)

defstruct ExceptionResult : (exception: Exception)
defstruct NormalResult : (result)

public defn with-exception-handler<?T> (body: () -> ?T,
                                        handler: Exception -> ?T) -> T :
   val r = label<ExceptionResult|NormalResult> break :
      let-var CURRENT-EXCEPTION-HANDLER = break{ExceptionResult(_)} :
         NormalResult(body())
   match(r) :
      (r:ExceptionResult) : handler(exception(r))
      (r:NormalResult) : result(r)

public defn with-finally<?T> (body: () -> ?T, finally: (True|False) -> ?) -> T :
   var entered? = false
   dynamic-wind(
      fn () :
         fatal("Cannot re-enter body with finally clause.") when entered?
         entered? = true
      body
      finally)

;============================================================
;============== Input/Output Exceptions =====================
;============================================================

public deftype IOException <: Exception

public defstruct FileStatException <: IOException :
  filename: String
  cause: String

defmethod print (o:OutputStream, e:FileStatException) :
  print(o, "Error occurred when attempting to read statistics of file %_. %_." % [
    filename(e), cause(e)])

public defstruct FileOpenException <: IOException :
   filename: String
   cause: String

defmethod print (o:OutputStream, e:FileOpenException) :
   print(o, "Error occurred when attempting to open file %_. %_." % [filename(e), cause(e)])

public defstruct FileCloseException <: IOException :
   cause: String

public defstruct FileNotWritableException <: IOException
defmethod print (o:OutputStream, e:FileNotWritableException) :
  print(o, "The given random access file is not allowed to be written to.")

defmethod print (o:OutputStream, e:FileCloseException) :
   print(o, "Error occurred when attempting to close file. %_." % [cause(e)])

public defstruct FileFlushException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileFlushException) :
   print(o, "Error occurred when attempting to flush file. %_." % [cause(e)])

public defstruct FileReadException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileReadException) :
   print(o, "Error occurred when attempting to read from file. %_." % [cause(e)])

public defstruct FileWriteException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileWriteException) :
   print(o, "Error occurred when attempting to write to file. %_." % [cause(e)])

public defstruct FileSeekException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileSeekException) :
   print(o, "Error occurred when attempting to seek in file. %_." % [cause(e)])

public defstruct FileSetLengthException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileSetLengthException) :
   print(o, "Error occurred when attempting to seek in file. %_." % [cause(e)])

public defstruct PathResolutionError <: Exception :
   filename: String
defmethod print (o:OutputStream, e:PathResolutionError) :
  print(o, "Could not resolve path %~." % [filename(e)])

;============================================================
;================ String Input Streams ======================
;============================================================

public deftype StringInputStream <: InputStream & Lengthable

;                       Interface
;                       =========

public defmulti peek? (s:StringInputStream, i:Int) -> False|Char
public defmulti info (s:StringInputStream) -> FileInfo
public defmulti get-chars (s:StringInputStream, n:Int) -> String


;                Abstract Implementations
;                ========================

public defn peek? (s:StringInputStream) :
   peek?(s, 0)

public defn peek (s:StringInputStream, i:Int) :
   match(peek?(s, i)) :
      (c:Char) : c
      (c:False) : fatal("No more characters in stream.")

public defn peek (s:StringInputStream) :
   peek(s, 0)

;                   Implementation
;                   ==============

public defn StringInputStream (string:String, filename:String) :
  StringInputStream(string, FileInfo(filename, 1, 0))

public defn StringInputStream (string:String, fileinfo:FileInfo) :
   var start = 0
   var line = line(fileinfo)
   var column = column(fileinfo)
   val n = length(string)

   new StringInputStream :
      defmethod get-char (this) :
         if start < n :
            val c = string[start]
            start = start + 1
            if c == '\n' :
               line = line + 1
               column = 0
            else :
               column = column + 1
            c

      defmethod get-chars (this, n:Int) :
         #if-not-defined(OPTIMIZE) :
            if length(this) < n :
               fatal("Cannot eat %_ chars from StringInputStream with %_ chars remaining." % [n, length(this)])
         val ret = string[start to start + n]
         do(get-char{this}, 0 to n)
         ret

      defmethod get-byte (this) :
         match(get-char(this)) :
            (c:Char) : to-byte(c)
            (c:False) : false

      defmethod info (this) :
         FileInfo(filename(fileinfo), line, column)

      defmethod peek? (this, i:Int) :
         string[start + i] when start + i < n

      defmethod length (this) :
         n - start

public defn StringInputStream (string:String) :
   StringInputStream(string, "UnnamedStream")

;============================================================
;======================= Chars ==============================
;============================================================

public lostanza defn digit? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= '0' and b <= '9' : return true
   else : return false

public lostanza defn letter? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'a' and b <= 'z' : return true
   else if b >= 'A' and b <= 'Z' : return true
   else : return false

public lostanza defn upper-case? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'A' and b <= 'Z' : return true
   else : return false

public lostanza defn lower-case? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'a' and b <= 'z' : return true
   else : return false

public lostanza defn lower-case (c:ref<Char>) -> ref<Char> :
   val cv = c.value
   if cv >= 'A' and cv <= 'Z' : return new Char{cv - 'A' + 'a'}
   else : return c

public lostanza defn upper-case (c:ref<Char>) -> ref<Char> :
   val cv = c.value
   if cv >= 'a' and cv <= 'z' : return new Char{cv - 'a' + 'A'}
   else : return c

;============================================================
;===================== Tuples ===============================
;============================================================

protected lostanza defn void-tuple (n:long) -> ref<Tuple> :
  val x = new Tuple{n}
  for (var i:long = 0, i < n, i = i + 1) :
    x.items[i] = sentinel
  return x

public lostanza defn Tuple<?T> (n:ref<Int>, x:ref<?T>) -> ref<Tuple<T>> :
   ensure-non-negative-length(n)
   val len = n.value
   val t = new Tuple<T>{len}
   for (var i:long = 0, i < len, i = i + 1) :
      t.items[i] = x
   return t

lostanza defn set<?T> (x:ref<Tuple<?T>>, i:ref<Int>, v:ref<T>) -> ref<False> :
   ensure-index-in-bounds(x, i)
   x.items[i.value] = v
   return false

public lostanza defn get<?T> (x:ref<Tuple<?T>>, i:ref<Int>) -> ref<T> :
   ensure-index-in-bounds(x, i)
   return x.items[i.value]

public defn get<?T> (xs:Tuple<?T>, r:Range) -> Tuple<T> :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])

public defn empty? (t:Tuple) :
   length(t) == 0

public defn map<?T,?R> (f:T -> ?R, xs:Tuple<?T>) -> Tuple<R> :
   to-tuple(seq(f, xs))

;============================================================
;===================== Strings ==============================
;============================================================

public lostanza defn String (chars:ptr<byte>) -> ref<String> :
  val len = call-c clib/strlen(chars)
  return String(len, chars)

public lostanza defn String (len:long, c:byte) -> ref<String> :
  val s = String(len)
  for (var i:long = 0, i < len, i = i + 1) :
    s.chars[i] = c
  s.chars[len] = 0 as byte
  return s

public lostanza defn String (len:ref<Int>, c:ref<Char>) -> ref<String> :
  ensure-non-negative-length(len)
  return String(len.value, c.value)

public lostanza defn get (s:ref<String>, i:ref<Int>) -> ref<Char> :
  ensure-index-in-bounds(s, i)
  return new Char{s.chars[i.value]}

lostanza defn set (s:ref<String>, i:ref<Int>, c:ref<Char>) -> ref<False> :
  ensure-index-in-bounds(s, i)
  s.chars[i.value] = c.value
  return false

lostanza defn copy-string (s:ref<String>) -> ref<String> :
  return String(s.length, addr!(s.chars))

;============================================================
;======================= String Library =====================
;============================================================

lostanza defn strlen (s:ref<String>) -> long :
  return s.length - 1

lostanza defn copy (dst:ref<String>, src:ref<String>, dst-i:long) -> ref<False> :
   val src-len = strlen(src)
   call-c clib/memcpy(addr!(dst.chars[dst-i]), addr!(src.chars), src-len)
   return false

public defn matches? (a:String, start:Int, b:String) :
   ensure-length-in-bounds(a, start)
   val an = length(a)
   val bn = length(b)
   if (start + bn) <= an :
      for i in 0 to bn all? :
         a[start + i] == b[i]

public defn prefix? (s:String, prefix:String) :
   matches?(s, 0, prefix)

public defn suffix? (s:String, suffix:String) :
   val start = max(0, length(s) - length(suffix))
   matches?(s, start, suffix)

public defn empty? (s:String) :
   length(s) == 0

lostanza defn substring! (str:ref<String>, b:ref<Int>, e:ref<Int>) -> ref<String> :
   val s = b.value
   val n = e.value - s
   val ret = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      ret.chars[i] = str.chars[i + s]
   ret.chars[n] = 0 as byte
   return ret

public defn get (s:String, r:Range) -> String :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   substring!(s, b, e)

public lostanza defn append (a:ref<String>, b:ref<String>) -> ref<String> :
   val al = strlen(a)
   val bl = strlen(b)
   val n = al + bl
   val s = String(n)
   copy(s, a, 0)
   copy(s, b, al)
   s.chars[n] = 0 as byte
   return s

public lostanza defn append-all (xs:ref<Seqable<String>>) -> ref<String> :
   match(xs) :
      (xs:ref<Collection<String>>) :
         val len = sum(seq(fn(length), xs))
         val ret = String(len.value)
         val xs-seq = to-seq(xs)
         var accum : long = 0
         while empty?(xs-seq) == false :
            val s = next(xs-seq)
            copy(ret, s, accum)
            accum = accum + strlen(s)
         ret.chars[len.value] = 0 as byte
         return ret
      (xs:ref<Seqable<String>>) :
         return append-all(to-vector<String>(xs))

public defn string-join (xs:Seqable) -> String :
   val s = StringBuffer()
   print-all(s, xs)
   to-string(s)

public defn string-join (xs:Seqable, j) -> String :
   string-join(join(xs, j))

public defn index-of-char (s:String, r:Range, c:Char) -> False|Int :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   for i in b to e find :
      s[i] == c

public defn index-of-char (s:String, c:Char) -> False|Int :
   index-of-char(s, 0 to false, c)

public defn index-of-chars (a:String, r:Range, b:String) -> False|Int :
   ensure-index-range(a, r)
   val [s, e] = range-bound(a, r)
   val an = e - s
   val bn = length(b)
   if bn <= an :
      for i in s through (e - bn) find :
         matches?(a, i, b)

;Returns the index at which b occurs within a.
public defn index-of-chars (a:String, b:String) -> False|Int :
   index-of-chars(a, 0 to false, b)

;Returns true if b is a substring of a.
public defn substring? (a:String, b:String) -> True|False :
  index-of-chars(a, b) is Int

;Returns true if b is a substring of the given range within a.
public defn substring? (a:String, r:Range, b:String) -> True|False :
  index-of-chars(a, r, b) is Int

public defn last-index-of-char (s:String, r:Range, c:Char) -> False|Int :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   for i in (e - 1) through b by -1 find :
      s[i] == c

public defn last-index-of-char (s:String, c:Char) -> False|Int :
   last-index-of-char(s, 0 to false, c)

public defn last-index-of-chars (a:String, r:Range, b:String) -> False|Int :
   ensure-index-range(a, r)
   val [s, e] = range-bound(a, r)
   val an = e - s
   val bn = length(b)
   if bn <= an :
      for i in (e - bn) through s by -1 find :
         matches?(a, i, b)

public defn last-index-of-chars (a:String, b:String) -> False|Int :
   last-index-of-chars(a, 0 to false, b)

public defn replace (s:String, i:Int, c:Char) -> String :
  val s2 = copy-string(s)
  s2[i] = c
  s2

public lostanza defn replace (s:ref<String>, c1:ref<Char>, c2:ref<Char>) -> ref<String> :
   val b1 = c1.value
   val b2 = c2.value
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc == b1 : r.chars[i] = b2
      else : r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public defn replace (str:String, s1:String, s2:String) -> String :
   fatal("String to be replaced cannot be empty.") when empty?(s1)
   val buf = StringBuffer(length(str))
   val n = length(str)
   val s1n = length(s1)
   defn* loop (i:Int) :
      if i < n :
         if matches?(str, i, s1) :
            print(buf, s2)
            loop(i + s1n)
         else :
            print(buf, str[i])
            loop(i + 1)
   loop(0)
   to-string(buf)

public defn split (str:String, s:String) -> Seq<String> :
   generate<String> :
      val strl = length(str)
      val sl = length(s)
      defn loop (b:Int) :
         if b < strl :
            match(index-of-chars(str, b to false, s)) :
               (i:Int) :
                  yield(str[b to i])
                  loop(i + sl)
               (i:False) :
                  yield(str[b to false])
      loop(0)

public defn split (str:String, s:String, n:Int) -> Seq<String> :
   if n <= 0 :
      fatal("Maximum number of splits (%_) is not positive." % [n])
   generate<String> :
      val strl = length(str)
      val sl = length(s)
      defn* loop (b:Int, n:Int) :
         if b < strl :
            if n > 1 :
               match(index-of-chars(str, b to false, s)) :
                  (i:Int) :
                     yield(str[b to i])
                     loop(i + sl, n - 1)
                  (i:False) :
                     yield(str[b to false])
            else :
               yield(str[b to false])
      loop(0, n)

public lostanza defn lower-case (s:ref<String>) -> ref<String> :
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc >= 'A' and sc <= 'Z' :
         r.chars[i] = sc - 'A' + 'a'
      else :
         r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public lostanza defn upper-case (s:ref<String>) -> ref<String> :
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc >= 'a' and sc <= 'z' :
         r.chars[i] = sc - 'a' + 'A'
      else :
         r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public defn trim (pred: Char -> True|False, s:String) :
   defn not-pred (c:Char) : not pred(c)
   match(index-when(not-pred, s)) :
      (i:Int) :
         val n = length(s)
         val j = for i in (n - 1) through 0 by -1 find! :
            not-pred(s[i])
         s[i through j]
      (i:False) : ""

public defn trim (s:String) -> String :
   defn whitespace? (c:Char) :
      (c == ' ') or
      (c == '\n') or
      (c == '\t') or
      (c == '\b') or
      (c == '\r')
   trim(whitespace?, s)

;============================================================
;======================= Lists ==============================
;============================================================

public defn cons<?T> (x:?T, y:?T, t:List<?T>) -> List<T> :
   cons(x, cons(y, t))

public defn cons<?T> (x:?T, y:?T, z:?T, t:List<?T>) -> List<T> :
   cons(x, cons(y, cons(z, t)))

public defn List<?T> (x:?T) -> List<T> :
   cons(x, List())

public defn List<?T> (x:?T, y:?T) -> List<T> :
   cons(x, cons(y, List()))

public defn List<?T> (x:?T, y:?T, z:?T) -> List<T> :
   cons(x, cons(y, cons(z, List())))

public defn List<?T> (w:?T, x:?T, y:?T, z:?T) -> List<T> :
   cons(w, cons(x, cons(y, cons(z, List()))))

;============================================================
;====================== List Library ========================
;============================================================

public defn* get<?T> (xs:List<?T>, i:Int) -> T :
   if i == 0 : head(xs)
   else : get(tail(xs), i - 1)

public defn headn<?T> (l:List<?T>, n:Int) -> List<T> :
   if n == 0 : List()
   else : cons(head(l), headn(tail(l), n - 1))

public defn* tailn<?T> (l:List<?T>, n:Int) -> List<T> :
   if n == 0 : l
   else : tailn(tail(l), n - 1)

public defn append<?T> (xs:Seqable<?T>, ys:List<?T>) -> List<T> :
   if empty?(ys) :
      to-list(xs)
   else :
      val items = to-vector<T>(xs)
      defn* loop (i:Int, tail:List<T>) :
         if i >= 0 : loop(i - 1, cons(items[i], tail))
         else : tail
      loop(length(items) - 1, ys)

public defn append-all<?T> (xs:Seqable<List<?T>>) -> List<T> :
   val xs-seq = to-seq(xs)
   defn loop () :
      if empty?(xs-seq) : List()
      else : append(next(xs-seq), loop())
   loop()

public defn seq-append<?T,?R> (f: T -> List<?R>, xs:Seqable<?T>) -> List<R> :
   append-all(seq(f, xs))

public defn seq-append<?T,?S,?R> (f: (T,S) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> List<R> :
   append-all(seq(f, xs, ys))

public defn seq-append<?T,?S,?U,?R> (f: (T,S,U) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R> :
   append-all(seq(f, xs, ys, zs))

public defn map<?T,?R> (f: T -> ?R, xs:List<?T>) -> List<R> :
  let loop (xs:List<T> = xs, i:Int = 0) :
    if i < 16 :
      if empty?(xs) : List()
      else : cons(f(head(xs)), loop(tail(xs), i + 1))
    else : to-list(seq(f, xs))

public defn map<?T,?S,?R> (f: (T,S) -> ?R, xs:List<?T>, ys:Seqable<?S>) -> List<R> :
   to-list(seq(f, xs, ys))

public defn map<?T,?S,?U,?R> (f: (T,S,U) -> ?R, xs:List<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R> :
   to-list(seq(f, xs, ys, zs))

public defn transpose<?T> (xs:List<List<?T>>) -> List<List<T>> :
   if empty?(xs) :
      List()
   else if any?(empty?, xs) :
      List()
   else :
      val hs = map(head, xs)
      val ts = map(tail, xs)
      cons(hs, transpose(ts))

public defn last<?T> (xs:List<?T>) -> T :
   fatal("Empty List") when empty?(xs)
   defn* loop (xs:List<T>) :
      if empty?(tail(xs)) : head(xs)
      else : loop(tail(xs))
   loop(xs)

public defn but-last<?T> (xs:List<?T>) -> List<T> :
   fatal("Empty List") when empty?(xs)
   defn* loop (xs:List<T>) :
      if empty?(tail(xs)) : List()
      else : cons(head(xs), but-last(tail(xs)))
   loop(xs)

public defn reverse<?T> (xs:List<?T>) -> List<T> :
   if empty?(xs) :
      xs
   else :
      var accum = List()
      for x in xs do :
         accum = cons(x, accum)
      accum

;============================================================
;====================== Formatting ==========================
;============================================================

public deftype Printable

public defn modulo (format:String, args:Seqable) -> Printable :
  new Printable :
    defmethod* print (o:OutputStream, this) :
      val seq = to-seq(args)
      defn next-arg () :
        #if-not-defined(OPTIMIZE) :
          fatal("Format string %~ is expecting more arguments." % [format]) when empty?(seq)
        next(seq)
      defn next-seq () :
        val x = next-arg()
        #if-not-defined(OPTIMIZE) :
          if x is-not Seqable :
            fatal("Format string %~ is expecting a sequence, but received: %~." % [format, x])
        x

      val n = length(format)
      defn* loop (i:Int) :
        if i < n :
          val c = format[i]
          if c == '%' :
            if i + 1 < n :
              val modifier = format[i + 1]
              switch {modifier == _} :
                '_' : print(o, next-arg())
                '*' : print-all(o, next-seq())
                ',' : print-all(o, join(next-seq(), ", "))
                's' : print-all(o, join(next-seq(), " "))
                'n' : print-all(o, join(next-seq(), "\n"))
                '~' : write(o, next-arg())
                '@' : write-all(o, next-seq())
                '%' : print(o, c)
                else : fatal("Invalid argument specifier %~ in format string %~." % [modifier, format])
              loop(i + 2)
            else :
              fatal("Incomplete argument specifier %% at end of format string %~." % [format])
          else :
            print(o, c)
            loop(i + 1)
        else :
          if not empty?(seq) :
            fatal("Unexpected end of format string %~. More arguments remaining." % [format])
      loop(0)

;============================================================
;=================== Indented Streams =======================
;============================================================

public deftype IndentedStream <: OutputStream
public defmulti stream (s:IndentedStream) -> OutputStream
public defmulti indent (s:IndentedStream) -> Int

public defn IndentedStream (o:OutputStream) :
  IndentedStream(o, 2)

public defn IndentedStream (o:OutputStream, n:Int) :
   match(o) :
      (o:IndentedStream) :
         IndentedStream(stream(o), n + indent(o))
      (o) :
         var start-of-line? = true
         val spaces = String(n, ' ')
         defn put (c:Char) :
            if start-of-line? :
               print(o, spaces)
               start-of-line? = false
            print(o, c)
            if c == '\n' :
               start-of-line? = true

         new IndentedStream :
            defmethod stream (this) : o
            defmethod indent (this) : n
            defmethod print (this, c:Char) : put(c)

public defn do-indented<?T> (f: IndentedStream -> ?T, o:OutputStream) :
   f(IndentedStream(o))

public defn indented<?T> (f: () -> ?T) :
   let-var CURRENT-OUTPUT-STREAM = IndentedStream(CURRENT-OUTPUT-STREAM) :
      f()

;============================================================
;===================== Generators ===========================
;============================================================

public defn Generator<T> (thunk : (T -> False, (T -> Void) & (() -> Void)) -> ?) -> Seq<T> :
   ;State
   var item = sentinel

   ;Generator Coroutine
   val co = Coroutine<False, T|Sentinel> $ fn (co, x0) :
      defn co-yield (x:T) :
         suspend(co, x)
      val co-break = multifn :
         (x:T) : break(co, x)
         () : break(co, sentinel)
      thunk(co-yield, co-break)
      sentinel

   ;Fill state: Returns whether empty
   defn fill () :
      if (item is Sentinel) and open?(co) :
         item = resume(co, false)
      item is Sentinel

   ;Peek
   defn peek () :
      if item is Sentinel :
         fatal("Empty Sequence")
      item as T

   ;Empty bucket
   defn empty () :
      val x = peek()
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         peek()
      defmethod empty? (this) :
         fill()
      defmethod free (this) :
         close(co) when open?(co)

;============================================================
;====================== Labels ==============================
;============================================================

public defn* LabeledScope<T> (thunk: (T -> Void) -> T) -> T :
   val c = Coroutine<False,T> $ fn* (c, x0) :
      thunk(break{c, _})
   resume(c, false)

public defn* LabeledScope* (thunk: (() -> Void) -> ?) -> False :
   val c = Coroutine<False,False> $ fn* (c, x0) :
      thunk(fn () : break(c, false))
      false
   resume(c, false)

;============================================================
;================== Failure Handler =========================
;============================================================

var CURRENT-FAILURE-HANDLER : () -> Void =
   fn () :
      fatal("Uncaught failure")

public defn fail () :
   CURRENT-FAILURE-HANDLER()

public defn with-attempt<?T> (conseq: () -> ?T, alt: () -> ?T) :
   val result = label<Maybe<T>> return :
      let-var CURRENT-FAILURE-HANDLER = fn* () : return(None()) :
         One(conseq())
   match(result) :
      (r:One<T>) : value(r)
      (r:None) : alt()

;============================================================
;=================== IndexedCollections =====================
;============================================================

public deftype IndexedCollection<T> <: Lengthable

;                       Interface
;                       =========

public defmulti get<?T> (a:IndexedCollection<?T>, i:Int) -> T
public defmulti set<?T> (a:IndexedCollection<?T>, i:Int, v:T) -> False
public defmulti get<?T> (a:IndexedCollection<?T>, r:Range) -> Collection<T>
public defmulti set<?T> (a:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False
public defmulti set-all<?T> (a:IndexedCollection<?T>, r:Range, v:T) -> False
public defmulti map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False

;                 Abstract Implementations
;                 ========================

public defn empty? (v:IndexedCollection) :
   length(v) == 0

defmethod print (o:OutputStream, a:IndexedCollection) -> False :
   print(o, "[%@]" % [a])

defmethod map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False :
   for i in 0 to length(xs) do :
      xs[i] = f(xs[i])

defmethod get<?T> (xs:IndexedCollection<?T>, r:Range) -> Tuple<T> :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])

defmethod set<?T> (xs:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   val vs-seq = to-seq(vs)
   for i in b to e do : xs[i] = next(vs-seq)

defmethod set-all<?T> (xs:IndexedCollection<?T>, r:Range, v:T) -> False :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   for i in b to e do : xs[i] = v

public defn reverse!<?T> (xs:IndexedCollection<?T>) -> False :
   val n = length(xs)
   for i in 0 to n / 2 do :
      val j = n - 1 - i
      val xi = xs[i]
      val xj = xs[j]
      xs[i] = xj
      xs[j] = xi

;                       Sorting
;                       =======

public defn qsort!<?T> (xs:IndexedCollection<?T>, is-less?:(T,T) -> True|False) -> False :
   ;Random
   val rand = Random(0L)

   ;Swap element i with element j
   defn swap (i:Int, j:Int) :
      if i != j :
         val xi = xs[i]
         val xj = xs[j]
         xs[i] = xj
         xs[j] = xi

   ;Rearrange elements from b to e, such that the first elements is less than pivot.
   ;Returns a s.t. all elements from b to a are less than pivot.
   defn partition (b:Int, e:Int, pivot:T) :
      defn* loop (a:Int, b:Int) -> Int :
         if b < e :
            val xb = xs[b]
            if is-less?(xb, pivot) :
               swap(a, b)
               loop(a + 1, b + 1)
            else : loop(a, b + 1)
         else : a
      loop(b, b)

   ;Driver
   defn* sort (b:Int, e:Int) :
      val n = e - b
      if n > 2 :
         swap(next-int(rand,b to e), e - 1) when n > 10
         val e1 = partition(b, e - 1, xs[e - 1])
         swap(e1, e - 1)
         sort(b, e1)
         sort(e1 + 1, e)
      else if n == 2 :
         swap(b, b + 1) when is-less?(xs[b + 1], xs[b])

   sort(0, length(xs))

public defn qsort!<?T> (xs:IndexedCollection<?T>, cmp:(T,T) -> Int) -> False :
   ;Random
   val rand = Random(0L)

   ;Swap element i with element j
   defn swap (i:Int, j:Int) :
      if i != j :
         val xi = xs[i]
         val xj = xs[j]
         xs[i] = xj
         xs[j] = xi

   ;Rearrange elements from b to e, such that:
   ;   b to lt is less than v
   ;   lt to gt is equal to v
   ;   gt to e is greater than v
   ;Returns [lt, gt]
   defn partition (b:Int, e:Int, pivot:T) -> [Int, Int] :
      defn* loop (lt:Int, gt:Int, i:Int) :
         if i < gt :
            val c = cmp(xs[i], pivot)
            if c < 0 :
               swap(i, lt)
               loop(lt + 1, gt, i + 1)
            else if c > 0 :
               swap(i, gt - 1)
               loop(lt, gt - 1, i)
            else :
               loop(lt, gt, i + 1)
         else :
            [lt, gt]
      loop(b, e, b)

   ;Driver
   defn* sort (b:Int, e:Int) :
      val n = e - b
      if n > 2 :
         val [lt, gt] = partition(b, e, xs[next-int(rand, b to e)])
         sort(b, lt)
         sort(gt, e)
      else if n == 2 :
         swap(b, b + 1) when cmp(xs[b + 1], xs[b]) < 0

   sort(0, length(xs))

public defn qsort!<?T> (xs:IndexedCollection<?T&Comparable<T>>) -> False :
   qsort!(xs, compare)

public defn qsort!<?T,?S> (key:T -> ?S&Comparable<S>, xs:IndexedCollection<?T>) -> False :
   qsort!(xs, compare{key(_), key(_)})

;                        Non-Destructive Sorting
;                        =======================

val SORT-BUFFER = Vector<?>()
defn clear-sort-buffer () :
  val ret = to-tuple(SORT-BUFFER)
  clear(SORT-BUFFER)
  ret

public defn qsort<?T> (coll:Seqable<?T>, is-less?:(T,T) -> True|False) -> Tuple<T> :
  add-all(SORT-BUFFER, coll)
  qsort!(SORT-BUFFER, is-less?)
  clear-sort-buffer()

public defn qsort<?T> (coll:Seqable<?T>, cmp:(T,T) -> Int) -> Tuple<T> :
  add-all(SORT-BUFFER, coll)
  qsort!(SORT-BUFFER, cmp)
  clear-sort-buffer()

public defn qsort<?T> (coll:Seqable<?T&Comparable<T>>) -> Tuple<T> :
  add-all(SORT-BUFFER, coll)
  qsort!(SORT-BUFFER)
  clear-sort-buffer()

public defn qsort<?T,?S> (key:T -> ?S&Comparable<S>, coll:Seqable<?T>) -> Tuple<T> :
  add-all(SORT-BUFFER, coll)
  qsort!(key as ? -> ?, SORT-BUFFER)
  clear-sort-buffer()

;                       Lazy Sorting
;                       ============

public defn lazy-qsort<?T> (coll:Seqable<?T>, is-less?:(T,T) -> True|False) -> Collection<T> & Lengthable :
   ;Random
   val rand = Random(0L)

   ;Convert to a vector
   val xs = to-vector<T>(coll)

   ;Sort Progress
   defn sort-progress () :
      generate<Int> :
         ;Swap element i with element j
         defn swap (i:Int, j:Int) :
            if i != j :
               val xi = xs[i]
               val xj = xs[j]
               xs[i] = xj
               xs[j] = xi

         ;Rearrange elements from b to e, such that the first elements is less than pivot.
         ;Returns a s.t. all elements from b to a are less than pivot.
         defn partition (b:Int, e:Int, pivot:T) :
            defn* loop (a:Int, b:Int) -> Int :
               if b < e :
                  val xb = xs[b]
                  if is-less?(xb, pivot) :
                     swap(a, b)
                     loop(a + 1, b + 1)
                  else : loop(a, b + 1)
               else : a
            loop(b, b)

         ;Driver
         defn* sort (b:Int, e:Int) :
            val n = e - b
            if n > 2 :
               swap(next-int(rand, b to e), e - 1) when n > 10
               val e1 = partition(b, e - 1, xs[e - 1])
               swap(e1, e - 1)
               sort(b, e1)
               yield(e1 + 1)
               sort(e1 + 1, e)
            else if n == 2 :
               swap(b, b + 1) when is-less?(xs[b + 1], xs[b])

         sort(0, length(xs))
         break(length(xs))

   ;Ensuring Progress
   var sorted = 0
   val sorter = sort-progress()
   defn* ensure-sorted (n:Int) :
      if sorted < n :
         sorted = next(sorter)
         ensure-sorted(n)

   ;Return object
   new Collection<T> & Lengthable :
      defmethod length (this) :
         length(xs)
      defmethod to-seq (this) :
         for i in 0 to length(xs) seq :
            ensure-sorted(i + 1)
            xs[i]


public defn lazy-qsort<?T> (coll:Seqable<?T>, cmp:(T,T) -> Int) -> Collection<T> & Lengthable :
   ;Random
   val rand = Random(0L)

   ;Convert to a vector
   val xs = to-vector<T>(coll)

   ;Sort Progress
   defn sort-progress () :
      generate<Int> :
         ;Swap element i with element j
         defn swap (i:Int, j:Int) :
            if i != j :
               val xi = xs[i]
               val xj = xs[j]
               xs[i] = xj
               xs[j] = xi

         ;Rearrange elements from b to e, such that:
         ;   b to lt is less than v
         ;   lt to gt is equal to v
         ;   gt to e is greater than v
         ;Returns [lt, gt]
         defn partition (b:Int, e:Int, pivot:T) -> [Int, Int] :
            defn* loop (lt:Int, gt:Int, i:Int) :
               if i < gt :
                  val c = cmp(xs[i], pivot)
                  if c < 0 :
                     swap(i, lt)
                     loop(lt + 1, gt, i + 1)
                  else if c > 0 :
                     swap(i, gt - 1)
                     loop(lt, gt - 1, i)
                  else :
                     loop(lt, gt, i + 1)
               else :
                  [lt, gt]
            loop(b, e, b)

         ;Driver
         defn* sort (b:Int, e:Int) :
            val n = e - b
            if n > 2 :
               val [lt, gt] = partition(b, e, xs[next-int(rand,b to e)])
               sort(b, lt)
               yield(gt)
               sort(gt, e)
            else if n == 2 :
               swap(b, b + 1) when cmp(xs[b + 1], xs[b]) < 0

         sort(0, length(xs))
         break(length(xs))

   ;Ensuring Progress
   var sorted = 0
   val sorter = sort-progress()
   defn* ensure-sorted (n:Int) :
      if sorted < n :
         sorted = next(sorter)
         ensure-sorted(n)

   ;Return object
   new Collection<T> & Lengthable :
      defmethod length (this) :
         length(xs)
      defmethod to-seq (this) :
         for i in 0 to length(xs) seq :
            ensure-sorted(i + 1)
            xs[i]

public defn lazy-qsort<?T> (coll:Seqable<?T&Comparable<T>>) :
   lazy-qsort(coll, compare)

public defn lazy-qsort<?T,?S> (key:T -> ?S&Comparable<S>, coll:Seqable<?T>) :
   lazy-qsort(coll, compare{key(_), key(_)})

;============================================================
;======================= Arrays =============================
;============================================================

public deftype Array<T> <: IndexedCollection<T> & Equalable

;                     Implementation
;                     ==============

lostanza deftype RawArray <: Array :
   length: long
   items: ref<?> ...

lostanza defn RawArray (n:ref<Int>, x:ref<?>) -> ref<RawArray> :
   val l = n.value
   val a = new RawArray{l}
   for (var i:long = 0, i < l, i = i + 1) :
      a.items[i] = x
   return a

lostanza defmethod get (a:ref<RawArray>, i:ref<Int>) -> ref<?> :
  return a.items[i.value]

lostanza defmethod set (a:ref<RawArray>, i:ref<Int>, v:ref<?>) -> ref<False> :
  a.items[i.value] = v
  return false

lostanza defmethod set-all (xs:ref<RawArray>, r:ref<Range>, v:ref<?>) -> ref<False> :
   val range = range-bound(xs, r) as ref<Tuple<Int>>
   val b = range.items[0].value
   val e = range.items[1].value
   for (var i:long = b, i < e, i = i + 1) :
      xs.items[i] = v
   return false

lostanza defmethod length (a:ref<RawArray>) -> ref<Int> :
   return new Int{a.length as int}

defmethod print (o:OutputStream, a:RawArray) -> False :
   print(o, "[%@]" % [a])

defmethod equal? (a:RawArray, b:RawArray) :
   ($prim identical? a b)

;                     Wrapping
;                     ========

#if-defined(OPTIMIZE) :

   public defn Array<T> (n:Int) -> Array<T> :
      RawArray(n, sentinel)

   public defn Array<T> (n:Int, x:T) -> Array<T> :
      RawArray(n, x)

#else :

   deftype WrappedArray<T> <: Array<T>
   defmulti raw (a:WrappedArray) -> RawArray

   public defn Array<T> (n:Int) -> Array<T> :
      ensure-non-negative("length", n)
      Array<T>(RawArray(n, sentinel))

   public defn Array<T> (n:Int, x:T) -> Array<T> :
      ensure-non-negative("length", n)
      Array<T>(RawArray(n, x))

   defn Array<T> (a:RawArray) -> Array<T> :
      new WrappedArray<T> :
         defmethod raw (this) : a
         defmethod get (this, i:Int) :
            ensure-index-in-bounds(a, i)
            match(a[i]) :
               (v:Sentinel) : fatal("Index (%_) is uninitialized." % [i])
               (v) : v
         defmethod set (this, i:Int, v:T) :
            ensure-index-in-bounds(a, i)
            a[i] = v
         defmethod set-all (this, r:Range, v:T) :
            ensure-index-range(a, r)
            set-all(a, r, v)
         defmethod length (this) :
            length(a)
         defmethod print (o:OutputStream, this) :
            print(o, a)
         defmethod equal? (this, x:WrappedArray) :
            a == raw(x)

public defn map<R,?T> (f: T -> R, xs:Array<?T>) -> Array<R> :
   val ret = Array<R>(length(xs))
   for (x in xs, i in 0 to false) do :
      ret[i] = f(x)
   ret

;============================================================
;==================== Primitive Arrays ======================
;============================================================

#for (Prim in [Byte Int Long Float Double]
      prim in [byte int long float double]
      PrimArray in [ByteArray IntArray LongArray FloatArray DoubleArray]
      x0 in [0Y 0 0L 0.0F 0.0]) :

  ;                     Declaration
  ;                     ===========
  public lostanza deftype PrimArray <: Array<Prim> :
    length: long
    data: prim ...

  ;                     Implementation
  ;                     ==============
  public lostanza defn PrimArray (n:ref<Int>, x:ref<Prim>) -> ref<PrimArray> :
    ensure-non-negative-length(n)
    val l = n.value
    val a = new PrimArray{l}
    val xv = x.value
    for (var i:long = 0, i < l, i = i + 1) :
      a.data[i] = xv
    return a

  public defn PrimArray (n:Int) -> PrimArray :
    PrimArray(n, x0)

  lostanza defmethod get (a:ref<PrimArray>, i:ref<Int>) -> ref<Prim> :
    ensure-index-in-bounds(a, i)
    return new Prim{a.data[i.value]}

  lostanza defmethod set (a:ref<PrimArray>, i:ref<Int>, x:ref<Prim>) -> ref<False> :
    ensure-index-in-bounds(a, i)
    a.data[i.value] = x.value
    return false

  lostanza defmethod length (a:ref<PrimArray>) -> ref<Int> :
    return new Int{a.length as int}

  lostanza defmethod get (a:ref<PrimArray>, r:ref<Range>) -> ref<PrimArray> :
    ensure-index-range(a, r)
    val rb = range-bound(a, r)
    val b = get(rb, new Int{0}).value
    val e = get(rb, new Int{1}).value
    val len = e - b
    val ret = new PrimArray{len}
    for (var i:long = 0, i < len, i = i + 1) :
      ret.data[i] = a.data[i + b]
    return ret

  lostanza defmethod set (a:ref<PrimArray>, r:ref<Range>, xs:ref<PrimArray>) -> ref<False> :
    ensure-index-range(a, r)
    val rb = range-bound(a, r)
    val b = get(rb, new Int{0}).value
    val e = get(rb, new Int{1}).value
    val len = e - b
    #if-not-defined(OPTIMIZE) :
      ensure-len-le-xs(new Int{len}, xs)
    for (var i:long = 0, i < len, i = i + 1) :
      a.data[i + b] = xs.data[i]
    return false
  defn ensure-len-le-xs (len:Int, xs:PrimArray) :
    if len > length(xs) :
      fatal("Length of range (%_) is greater than length of values array (%_)." % [
        len, length(xs)])

;============================================================
;==================== CharArrays ============================
;============================================================

public lostanza deftype CharArray <: Array<Char> :
  length: long
  chars: byte ...

;                     Implementation
;                     ==============

public lostanza defn CharArray (n:ref<Int>, x:ref<Char>) -> ref<CharArray> :
   ensure-non-negative-length(n)
   val l = n.value
   val a = new CharArray{l}
   val c = x.value
   for (var i:long = 0, i < l, i = i + 1) :
      a.chars[i] = c
   return a

public defn CharArray (n:Int) -> CharArray :
   CharArray(n, ' ')

lostanza defmethod get (a:ref<CharArray>, i:ref<Int>) -> ref<Char> :
  ensure-index-in-bounds(a, i)
  return new Char{a.chars[i.value]}

lostanza defmethod set (a:ref<CharArray>, i:ref<Int>, v:ref<Char>) -> ref<False> :
  ensure-index-in-bounds(a, i)
  a.chars[i.value] = v.value
  return false

lostanza defmethod length (a:ref<CharArray>) -> ref<Int> :
   return new Int{a.length as int}

lostanza defn substring! (a:ref<CharArray>, b:ref<Int>, e:ref<Int>) -> ref<String> :
   val len = e.value - b.value
   val start = b.value
   val s = String(len)
   for (var i:long = 0, i < len, i = i + 1) :
      s.chars[i] = a.chars[i + start]
   s.chars[len] = 0 as byte
   return s

defmethod get (a:CharArray, r:Range) -> String :
   ensure-index-range(a, r)
   val [b, e] = range-bound(a, r)
   substring!(a, b, e)

;                     Looping
;                     =======

defmethod do (f: Char -> ?, xs:CharArray) :
   val n = length(xs)
   let loop (i:Int = 0) :
      if i < n :
         f(xs[i])
         loop(i + 1)

;============================================================
;==================== Block Copying =========================
;============================================================

public defmulti block-copy<?T> (n:Int, dst:IndexedCollection<?T>, di:Int, src:IndexedCollection<T>, si:Int) -> False

defmethod block-copy<?T> (n:Int, dst:IndexedCollection<?T>, di:Int, src:IndexedCollection<T>, si:Int) :
  ensure-block-copy-preconditions(n, dst, di, src, si)
   for i in 0 to n do :
      dst[di + i] = src[si + i]

lostanza defmethod block-copy (ref-n:ref<Int>, dst:ref<RawArray>, ref-di:ref<Int>, src:ref<RawArray>, ref-si:ref<Int>) -> ref<False> :
  ensure-block-copy-preconditions(ref-n, dst, ref-di, src, ref-si)
  val dst-ptr = addr!(dst.items)
  val src-ptr = addr!(src.items)
  val di = ref-di.value
  val si = ref-si.value
  val n = ref-n.value
  call-c clib/memcpy(addr!(dst-ptr[di]), addr!(src-ptr[si]), n * sizeof(ref<?>))
  return false

defmethod block-copy (n:Int, dst:ByteBuffer, di:Int, src:ByteBuffer, si:Int) :
  ensure-block-copy-preconditions(n, dst, di, src, si)
  block-copy(n, backing-array(dst), di, backing-array(src), si)

#for (PrimArray in [ByteArray IntArray LongArray FloatArray DoubleArray]
      prim in [byte int long float double]) :
  lostanza defmethod block-copy (ref-n:ref<Int>, dst:ref<PrimArray>, ref-di:ref<Int>, src:ref<PrimArray>, ref-si:ref<Int>) -> ref<False> :
    ensure-block-copy-preconditions(ref-n, dst, ref-di, src, ref-si)
    val dst-ptr = addr!(dst.data)
    val src-ptr = addr!(src.data)
    val di = ref-di.value
    val si = ref-si.value
    val n = ref-n.value
    call-c clib/memcpy(addr!(dst-ptr[di]), addr!(src-ptr[si]), n * sizeof(prim))
    return false

defn ensure-block-copy-preconditions (n:Int, dst:IndexedCollection, di:Int, src:IndexedCollection, si:Int) :
  #if-not-defined(OPTIMIZE) :
    ensure-non-negative("number of elements", n)
    ensure-non-negative("destination index", di)
    ensure-non-negative("source index", si)
    if length(dst) < di + n : fatal("Attempt to write past bounds of destination collection.")
    if length(src) < si + n : fatal("Attempt to read past bounds of source collection.")
  false

;============================================================
;==================== Conversions ===========================
;============================================================

;                 Numeric Conversions
;                 ===================

public lostanza defn to-byte (b:ref<Byte>) -> ref<Byte> : return b
public lostanza defn to-byte (c:ref<Char>) -> ref<Byte> : return new Byte{c.value}
public lostanza defn to-byte (i:ref<Int>) -> ref<Byte> : return new Byte{i.value as byte}
public lostanza defn to-byte (l:ref<Long>) -> ref<Byte> : return new Byte{l.value as byte}
public lostanza defn to-byte (f:ref<Float>) -> ref<Byte> : return new Byte{f.value as byte}
public lostanza defn to-byte (d:ref<Double>) -> ref<Byte> : return new Byte{d.value as byte}
public lostanza defn to-char (b:ref<Byte>) -> ref<Char> : return new Char{b.value}
public lostanza defn to-char (c:ref<Char>) -> ref<Char> : return c
public lostanza defn to-char (i:ref<Int>) -> ref<Char> : return new Char{i.value as byte}
public lostanza defn to-int (b:ref<Byte>) -> ref<Int> : return new Int{b.value}
public lostanza defn to-int (c:ref<Char>) -> ref<Int> : return new Int{c.value}
public lostanza defn to-int (i:ref<Int>) -> ref<Int> : return i
public lostanza defn to-int (l:ref<Long>) -> ref<Int> : return new Int{l.value as int}
public lostanza defn to-int (f:ref<Float>) -> ref<Int> : return new Int{f.value as int}
public lostanza defn to-int (d:ref<Double>) -> ref<Int> : return new Int{d.value as int}
public lostanza defn to-long (b:ref<Byte>) -> ref<Long> : return new Long{b.value}
public lostanza defn to-long (i:ref<Int>) -> ref<Long> : return new Long{i.value}
public lostanza defn to-long (l:ref<Long>) -> ref<Long> : return l
public lostanza defn to-long (f:ref<Float>) -> ref<Long> : return new Long{f.value as long}
public lostanza defn to-long (d:ref<Double>) -> ref<Long> : return new Long{d.value as long}
public lostanza defn to-float (b:ref<Byte>) -> ref<Float> : return new Float{b.value as float}
public lostanza defn to-float (i:ref<Int>) -> ref<Float> : return new Float{i.value as float}
public lostanza defn to-float (l:ref<Long>) -> ref<Float> : return new Float{l.value as float}
public lostanza defn to-float (f:ref<Float>) -> ref<Float> : return f
public lostanza defn to-float (d:ref<Double>) -> ref<Float> : return new Float{d.value as float}
public lostanza defn to-double (b:ref<Byte>) -> ref<Double> : return new Double{b.value as double}
public lostanza defn to-double (i:ref<Int>) -> ref<Double> : return new Double{i.value as double}
public lostanza defn to-double (l:ref<Long>) -> ref<Double> : return new Double{l.value as double}
public lostanza defn to-double (f:ref<Float>) -> ref<Double> : return new Double{f.value}
public lostanza defn to-double (d:ref<Double>) -> ref<Double> : return d

;                Numeric Reinterpretations
;                =========================

public lostanza defn bits (f:ref<Float>) -> ref<Int> :
  val v = f.value
  return new Int{($ls-prim bits v)}

public lostanza defn bits (d:ref<Double>) -> ref<Long> :
  val v = d.value
  return new Long{($ls-prim bits v)}

public lostanza defn bits-as-float (i:ref<Int>) -> ref<Float> :
  val v = i.value
  return new Float{($ls-prim fnum v)}

public lostanza defn bits-as-double (i:ref<Long>) -> ref<Double> :
  val v = i.value
  return new Double{($ls-prim fnum v)}

;============================================================
;==================== Number Parsing ========================
;============================================================

;                     Error Checking
;                     ==============

#for (to-value! in [to-byte! to-int! to-long! to-float! to-double!]
      to-value in [to-byte to-int to-long to-float to-double]
      Value in [Byte Int Long Float Double]
      name in ["byte" "int" "long" "float" "double"]) :
  public defn to-value! (s:String) -> Value :
    #if-defined(OPTIMIZE) :
      to-value(s) as Value
    #else :
      match(to-value(s)) :
        (v:Value) : v
        (v:False) : fatal("String %~ cannot be converted to a %_." % [s, name])

;                        Drivers
;                        =======

public defn to-byte (s:String) -> False|Byte :
  match(to-int(s)) :
    (i:Int) : to-byte(i) when i >= 0 and i <= 255
    (i:False) : false

public lostanza defn to-int (s:ref<String>) -> ref<False|Int> :
  if prefix?(s, "-") :
    return neg-to-int(s, 1, 10)
  else if prefix?(s, "0x") :
    return bits-to-int(s, 2, 16, 4)
  else if prefix?(s, "0o") :
    return bits-to-int(s, 2, 8, 3)
  else if prefix?(s, "0b") :
    return bits-to-int(s, 2, 2, 1)
  else :
    return pos-to-int(s, 0, 10)

public lostanza defn to-long (s:ref<String>) -> ref<False|Long> :
  if prefix?(s, "-") :
    return neg-to-long(s, 1, 10)
  else if prefix?(s, "0x") :
    return bits-to-long(s, 2, 16, 4)
  else if prefix?(s, "0o") :
    return bits-to-long(s, 2, 8, 3)
  else if prefix?(s, "0b") :
    return bits-to-long(s, 2, 2, 1)
  else :
    return pos-to-long(s, 0, 10)

;TODO: This is necessary because addresses of local variables don't work yet.
lostanza var DOUBLE-BUFFER : double
lostanza var CHAR-BUFFER : byte
public lostanza defn to-double (s:ref<String>) -> ref<False|Double> :
  val n = call-c clib/sscanf(addr!(s.chars), "%lf%c", addr(DOUBLE-BUFFER), addr(CHAR-BUFFER))
  if n != 1 : return false
  else : return new Double{DOUBLE-BUFFER}

lostanza var FLOAT-BUFFER : float
public lostanza defn to-float (s:ref<String>) -> ref<False|Float> :
  val n = call-c clib/sscanf(addr!(s.chars), "%f%c", addr(FLOAT-BUFFER), addr(CHAR-BUFFER))
  if n != 1 : return false
  else : return new Float{FLOAT-BUFFER}

;                        Utilities
;                        =========

lostanza defn prefix? (str:ref<String>, prefix:ptr<byte>) -> int :
  for (var i:long = 0, 1, i = i + 1) :
    if prefix[i] == 0 : return 1
    else if str.chars[i] == 0 : return 0
    else if prefix[i] != str.chars[i] : return 0
  return 0

lostanza defn digit (c:byte, radix:int) -> int :
  var d:int
  if c >= '0' and c <= '9' : d = c - '0'
  else if c >= 'a' and c <= 'f' : d = c - 'a' + 10
  else if c >= 'A' and c <= 'F' : d = c - 'A' + 10
  else : return -1
  if d < radix : return d
  else : return -1

;                        Parsing Integers
;                        ================

lostanza defn pos-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
  var n:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix + d
        if n < 0 : return false
  fatal("Unreachable")
  return false

lostanza defn neg-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
  var n:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix - d
        if n > 0 : return false
  fatal("Unreachable")
  return false

lostanza defn bits-to-int (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Int> :
  var n:int = 0
  var nbits:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = (n << bits) | d
        nbits = nbits + bits
        if nbits >= 32 + bits : return false
  fatal("Unreachable")
  return false

;                        Parsing Longs
;                        =============

lostanza defn pos-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
  var n:long = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix + d
        if n < 0 : return false
  fatal("Unreachable")
  return false

lostanza defn neg-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
  var n:long = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix - d
        if n > 0 : return false
  fatal("Unreachable")
  return false

lostanza defn bits-to-long (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Long> :
  var n:long = 0
  var nbits:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = (n << bits) | d
        nbits = nbits + bits
        if nbits >= 64 + bits : return false
  fatal("Unreachable")
  return false

;============================================================
;=================== Limits =================================
;============================================================

public val BYTE-MAX = 255Y
public val BYTE-MIN = 0Y
public lostanza val INT-MAX:ref<Int> = new Int{(1 << 31) - 1}
public lostanza val INT-MIN:ref<Int> = new Int{1 << 31}
public lostanza val LONG-MAX:ref<Long> = new Long{(1L << 63L) - 1L}
public lostanza val LONG-MIN:ref<Long> = new Long{1L << 63L}

public val FLOAT-MAX = bits-as-float(0x7F7FFFFF)
public val FLOAT-MIN-NORMAL = bits-as-float(0x00800000)
public val FLOAT-MIN = bits-as-float(0x1)
public val FLOAT-NAN = bits-as-float(0x7FC00000)
public val FLOAT-POSITIVE-INFINITY = bits-as-float(0x7F800000)
public val FLOAT-NEGATIVE-INFINITY = bits-as-float(0xFF800000)

public val DOUBLE-MAX = bits-as-double(0x7fefffffffffffffL)
public val DOUBLE-MIN-NORMAL = bits-as-double(0x0010000000000000L)
public val DOUBLE-MIN = bits-as-double(0x1L)
public val DOUBLE-NAN = bits-as-double(0x7ff8000000000000L)
public val DOUBLE-POSITIVE-INFINITY = bits-as-double(0x7ff0000000000000L)
public val DOUBLE-NEGATIVE-INFINITY = bits-as-double(0xfff0000000000000L)

;============================================================
;==================== Arithmetic ============================
;============================================================

public defn max<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T :
  b when a < b else a

public defn min<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T :
  a when a < b else b

public defn minimum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, xs} $ fn (x, y) :
    if x < y : x
    else : y

public defn minimum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, x0, xs} $ fn (x, y) :
    if x < y : x
    else : y

public defn maximum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, xs} $ fn (x, y) :
    if x < y : y
    else : x

public defn maximum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, x0, xs} $ fn (x, y) :
    if x < y : y
    else : x

public defn minimum<?T> (xs:Seqable<?T&Comparable>) -> T : minimum(xs, less?)
public defn maximum<?T> (xs:Seqable<?T&Comparable>) -> T : maximum(xs, less?)

public defn minimum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : minimum(x0, xs, less?)
public defn maximum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : maximum(x0, xs, less?)

public defn minimum<?T> (key: T -> Comparable, input-xs:Seqable<?T>) -> T :
  val xs = to-seq(input-xs)
  var min-x:T = next(xs)
  var min-key:Comparable = key(min-x)
  for x in xs do :
    val k = key(x)
    if k < min-key :
      min-x = x
      min-key = k
  min-x
  
public defn maximum<?T> (key: T -> Comparable, input-xs:Seqable<?T>) -> T :
  val xs = to-seq(input-xs)
  var max-x:T = next(xs)
  var max-key:Comparable = key(max-x)
  for x in xs do :
    val k = key(x)
    if k > max-key :
      max-x = x
      max-key = k
  max-x

public defn ceil-log2 (i:Int) -> Int :
  defn* loop (n:Int, l:Int) :
    if i > n :
      if l == 30 : l + 1
      else : loop(n << 1, l + 1)
    else : l
  fatal("Log of non-positive number!") when i <= 0
  loop(1, 0)

public defn floor-log2 (i:Int) -> Int :
  defn* loop (n:Int, l:Int) :
    if i == n : l
    else if i < n : l - 1
    else if l == 30 : l
    else : loop(n << 1, l + 1)
  fatal("Log of non-positive number!") when i <= 0
  loop(1, 0)

public defn ceil-log2 (i:Long) -> Int :
  defn* loop (n:Long, l:Int) :
    if i > n :
      if l == 62 : l + 1
      else : loop(n << to-long(1), l + 1)
    else : l
  fatal("Log of non-positive number!") when i <= to-long(0)
  loop(to-long(1), 0)

public defn floor-log2 (i:Long) -> Int :
  defn* loop (n:Long, l:Int) :
    if n == i : l
    else if i < n : l - 1
    else if l == 62 : l
    else : loop(n << to-long(1), l + 1)
  fatal("Log of non-positive number!") when i <= to-long(0)
  loop(to-long(1), 0)

public defn next-pow2 (i:Int) -> Int :
  ensure-non-negative("value", i)
  if i == 0 :
    i
  else :
    val n = ceil-log2(i)
    if n <= 30 : 1 << n
    else : fatal("Overflow")

public defn prev-pow2 (i:Int) -> Int :
  ensure-non-negative("value", i)
  if i == 0 :
    i
  else :
    1 << floor-log2(i)

public defn next-pow2 (i:Long) -> Long :
  val n = ceil-log2(i)
  if n <= 62 : to-long(1) << to-long(n)
  else : fatal("Overflow")

public defn prev-pow2 (i:Long) -> Long :
  to-long(1) << to-long(floor-log2(i))

public defn sum (xs: Seqable<Int>) -> Int : reduce(plus, 0, xs)
public defn sum (xs: Seqable<Long>) -> Long : reduce(plus, 0L, xs)
public defn sum (xs: Seqable<Float>) -> Float : reduce(plus, 0.0f, xs)
public defn sum (xs: Seqable<Double>) -> Double : reduce(plus, 0.0, xs)

public defn product (xs: Seqable<Int>) -> Int : reduce(times, 1, xs)
public defn product (xs: Seqable<Long>) -> Long : reduce(times, 1L, xs)
public defn product (xs: Seqable<Float>) -> Float : reduce(times, 1.0f, xs)
public defn product (xs: Seqable<Double>) -> Double : reduce(times, 1.0, xs)

;============================================================
;====================== Maybe ===============================
;============================================================

public deftype Maybe<T> <: Equalable & Comparable<Maybe<T>> & Hashable
public deftype None <: Maybe<Void>
public deftype One<T> <: Maybe<T>

;                      Interface
;                      =========

public defmulti value<?T> (x:One<?T>) -> T

;                     Constructors
;                     ============

public defn None () :
   new None

public defn One<?T> (x:?T) :
   new One<T> :
      defmethod value (this) : x

;                     Printers
;                     ========

defmethod print (o:OutputStream, x:None) :
   print(o, "None")
defmethod print (o:OutputStream, x:One) :
   print(o, "One(%~)" % [value(x)])

;                   Implementation
;                   ==============

public defn value!<?T> (x:Maybe<?T>) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : fatal("Object of type None has no value.")

public defn value?<?T> (x:Maybe<?T>, default:?T) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : default

public defn value?<?T> (x:Maybe<?T>) -> T|False :
   value?(x, false)

public defn empty? (x:Maybe) :
   x is None

defmethod equal? (a:None, b:None) :
   true

defmethod equal? (a:One, b:One) :
   value(a) == value(b)

defmethod hash (a:None) :
  1817

defmethod hash (a:One) :
  hash(value(a)) * 17

;                   Comparisons
;                   ===========

defmethod* compare<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : 0
      (x:None, y:One<T>) : -1
      (x:One<T>, y:None) : 1
      (x:One<T&Comparable<T>>, y:One<T>) : compare(value(x), value(y))

defmethod less?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) < value(y)

defmethod less-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) <= value(y)

defmethod greater?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) > value(y)

defmethod greater-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) >= value(y)

;============================================================
;====================== Ranges ==============================
;============================================================

public deftype Range <: Equalable

;                      Interface
;                      =========

public defmulti start (r:Range) -> Int
public defmulti end (r:Range) -> Int|False
public defmulti step (r:Range) -> Int
public defmulti inclusive? (r:Range) -> True|False

;                     Constructor
;                     ===========

public defn Range (start:Int, end:Int|False, step:Int, inclusive?:True|False) :
   ;Compute the length of the range
   val length = match(end, inclusive?) :
      (end:Int, inc:False) :
         if step == 0 :
            if start == end : 0
            else : false
         else if step == 1 :
            safe-minus(end, start)
         else if step == -1 :
            safe-minus(start, end)
         else if step > 0 :
            div?(safe-add(safe-minus(end, start), step - 1), step)
         else :
            div?(safe-add(safe-minus(end, start), step + 1), step)
      (end:Int, inc:True) :
         if step == 0 :
            false
         else if step == 1 :
            safe-add(safe-minus(end, start), 1)
         else if step == -1 :
            safe-add(safe-minus(start, end), 1)
         else :
            div?(safe-add(safe-minus(end, start), step), step)
      (end:False, inc) :
         false

   match(length) :
      (length:Int) :
         new Range & Lengthable :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?
            defmethod length (this) : max(length, 0)
      (length:False) :
         new Range :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?

defn safe-add (x:Int, y:Int) :
  val z = x + y
  val sign-x = x >> 31
  val sign-y = y >> 31
  val sign-z = z >> 31
  val c = (sign-x ^ sign-y) | (1 ^ sign-x ^ sign-z)
  z when c == 1

defn safe-minus (x:Int, y:Int) :
  val z = x - y
  val sign-x = x >> 31
  val sign-y = y >> 31
  val sign-z = z >> 31
  val c = (1 ^ sign-x ^ sign-y) | (1 ^ sign-x ^ sign-z)
  z when c == 1

defn safe-add (x:False, y:Int) : false
defn safe-minus (x:False, y:Int) : false
defn div? (x:Int, y:Int) : x / y
defn div? (x:False, y:Int) : false

;                Conversion to Sequence
;                ======================



;             Reverse
;             =======
public defn reverse (r:Range) :
  ;Fields
  val start = start(r)
  val end = end(r)
  val step = step(r)
  val inc = inclusive?(r)

  ;Cases
  defn* empty-range () :
    Range(end as Int, start, (- step), inc)
  defn* reverse-range (last:Int) :
    last through start by (- step)
  defn* infinite-range () :
    start through start by 0
  defn* no-last-element () :
    fatal("Range %_ cannot be reversed." % [r])

  if step == 0 :
    match(start == end, inc) :
      (eq:False, inc) : infinite-range()
      (eq:True, inc:True) : infinite-range()
      (eq:True, inc:False) : empty-range()
  else if end is False :
    no-last-element()
  else :
    val end = end as Int
    match(step > 0, end > start) :
      (r1:True, r2:False) :
        empty-range()
      (r1:False, r2:True) :
        empty-range()
      (r1, r2) :
        val sgn-step = 1 when r1 else -1
        val n = if inc : (end - start + step) / step
                else : (end - start + step - sgn-step) / step
        reverse-range(start + (n - 1) * step)



;             Looping
;             =======

defmethod do (f: Int -> ?, r:Range&Lengthable) :
   val s = step(r)
   let loop (i:Int = start(r), n:Int = length(r)) :
      if n > 0 :
         f(i)
         loop(i + s, n - 1)

defmethod do (f: Int -> ?, r:Range) :
   val s = step(r)
   let loop (i:Int = start(r)) :
      f(i)
      loop(i + s)

;                  Inclusion
;                  =========

defmethod contains? (r:Range, x:Int) :
  val start = start(r)
  val step = step(r)
  match(end(r), inclusive?(r)) :
    (end:Int, inc:False) :
      if step == 0 :
        if start == end : false
        else : start == x
      else if step == 1 :
        x >= start and x < end
      else if step == -1 :
        x <= start and x > end
      else if step > 0 :
        x >= start and x < end and ((x - start) % step == 0)
      else :
        x <= start and x > end and ((x - start) % step == 0)
    (end:Int, inc:True) :
      if step == 0 :
        start == x
      else if step == 1 :
        x >= start and x <= end
      else if step == -1 :
        x <= start and x >= end
      else if step > 0 :
        x >= start and x <= end and ((x - start) % step == 0)
      else :
        x <= start and x >= end and ((x - start) % step == 0)
    (end:False, inc) :
      if step == 0 :
        start == x
      else if step == 1 :
        x >= start
      else if step == -1 :
        x <= start
      else if step > 0 :
        x >= start and ((x - start) % step == 0)
      else :
        x <= start and ((x - start) % step == 0)

;                 Comparison
;                 ==========

defmethod equal? (a:Range, b:Range) :
   start(a) == start(b) and
   end(a) == end(b) and
   step(a) == step(b) and
   inclusive?(a) == inclusive?(b)

;                  Printing
;                  ========

defmethod print (o:OutputStream, x:Range) :
   val op = "through" when inclusive?(x) else "to"
   if step(x) == 1 : print(o, "%_ %_ %_" % [start(x), op, end(x)])
   else : print(o, "%_ %_ %_ by %_" % [start(x), op, end(x), step(x)])

;                  Mapping
;                  =======

public defn map<?R> (f: Int -> ?R, r:Range) -> List<R> :
   fatal("Infinite Range") when r is-not Range&Lengthable
   to-list(seq(f, r))

;============================================================
;==================== KeyValue Pairs ========================
;============================================================

public deftype KeyValue<K,V> <: Equalable & Hashable

;                       Interface
;                       =========

public defmulti key<?K> (kv:KeyValue<?K,?>) -> K
public defmulti value<?V> (kv:KeyValue<?,?V>) -> V

;                      Constructor
;                      ===========

public defn KeyValue<?K,?V> (k:?K, v:?V) -> KeyValue<K,V> :
   new KeyValue<K,V> :
      defmethod key (this) : k
      defmethod value (this) : v

defmethod print (o:OutputStream, v:KeyValue) :
   write(o, key(v))
   print(o, " => ")
   write(o, value(v))

defmethod equal? (a:KeyValue, b:KeyValue) :
   key(a) == key(b) and
   value(a) == value(b)

defmethod hash (x:KeyValue<Hashable,Hashable>) :
   hash(key(x)) + 7 * hash(value(x))

;============================================================
;====================== Tokens ==============================
;============================================================

public deftype Token <: Equalable

;                      Interface
;                      =========

public defmulti item (t:Token) -> ?
public defmulti info (t:Token) -> FileInfo

;                     Constructor
;                     ===========

public defn Token (item, info:FileInfo) :
   new Token :
      defmethod item (this) : item
      defmethod info (this) : info

public defn unwrap-token (t) :
   match(t) :
      (t:Token) : unwrap-token(item(t))
      (t) : t

public defn unwrap-all (t) -> ? :
   match(t) :
      (t:Token) : unwrap-all(item(t))
      (t:List) : map(unwrap-all, t)
      (t) : t

defmethod print (o:OutputStream, t:Token) :
   write(o, item(t))

defmethod equal? (a:Token, b:Token) :
   (item(a) == item(b)) and
   (info(a) == info(b))

;============================================================
;===================== FileInfo =============================
;============================================================

public deftype FileInfo <: Equalable & Hashable & Comparable<FileInfo>

;                     Interface
;                     =========

public defmulti filename (i:FileInfo) -> String
public defmulti line (i:FileInfo) -> Int
public defmulti column (i:FileInfo) -> Int

;                  Implementation
;                  ==============

public defn FileInfo (f:String, l:Int, c:Int) :
   new FileInfo :
      defmethod filename (this) : f
      defmethod line (this) : l
      defmethod column (this) : c

defmethod equal? (a:FileInfo, b:FileInfo) :
   filename(a) == filename(b) and
   line(a) == line(b) and
   column(a) == column(b)

defmethod hash (i:FileInfo) :
   hash(filename(i)) +
   7 * hash(line(i)) +
   49 * hash(column(i))

defmethod compare (a:FileInfo, b:FileInfo) :
   val c = compare(filename(a), filename(b))
   if c == 0 :
      val c = compare(line(a), line(b))
      if c == 0 :
         compare(column(a), column(b))
      else : c
   else : c

defmethod print (o:OutputStream, i:FileInfo) :
   print(o, filename(i))
   print(o, ":")
   print(o, line(i))
   print(o, ".")
   print(o, column(i))

;============================================================
;======================= Sequences ==========================
;============================================================

public deftype Seqable<T> :
  Collection<T> <: Seqable<T>

public deftype Seq<T> <: Seqable<T>

public deftype Collection<T> :
  Range <: Collection<Int>
  String <: Collection<Char>
  List<T> <: Collection<T>
  Tuple<T> <: Collection<T>
  IndexedCollection<T> <: Collection<T>

public defmulti to-seq<?T> (s:Seqable<?T>) -> Seq<T>
defmethod to-seq<?T> (s:Seq<?T>) : s

public defmulti next<?T> (s:Seq<?T>) -> T
public defmulti peek<?T> (s:Seq<?T>) -> T
public defmulti empty? (s:Seq) -> True|False
public defmulti free (s:Seq) -> False
defmethod free (s:Seq) : false

defn* do-seq<?T,?R> (f: Seq<T> -> ?R, s:Seqable<?T>) -> R :
   match(s) :
      (s:Seq<T>) :
         f(s)
      (s) :
         val s-seq = to-seq(s)
         dynamic-wind(
            false,
            fn* () : f(s-seq)
            fn* (final?) : free(s-seq) when final?)

;===== Conversion to Sequence =====

defmethod to-seq<?T> (x:Tuple<?T>) :
   seq({x[_]}, 0 to length(x))

defmethod to-seq (s:String) :
   seq({s[_]}, 0 to length(s))

defmethod to-seq<?T> (x:List<?T>) :
   var l = x
   new Seq<T> :
      defmethod empty? (this) :
         empty?(l)
      defmethod next (this) :
         val x = peek(this)
         l = tail(l)
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         head(l)

defmethod to-seq<?T> (xs:IndexedCollection<?T>) -> Seq<T> :
   seq({xs[_]}, 0 to length(xs))

defmethod to-seq (r:Range) :
  match(r) :
    (r:Range & Lengthable) :
      var i = start(r)
      var n = length(r)
      new Seq<Int> & Lengthable :
        defmethod next (this) :
          val i* = peek(this)
          i = i + step(r)
          n = n - 1
          i*
        defmethod peek (this) :
          fatal("Empty Sequence") when empty?(this)
          i
        defmethod empty? (this) :
          n == 0
        defmethod length (this) :
          n
    (r:Range) :
      var i = start(r)
      new Seq<Int> :
        defmethod next (this) :
          val i* = i
          i = i + step(r)
          i*
        defmethod peek (this) :
          i
        defmethod empty? (this) :
          false

;===== Conversion from Sequence =====

public defn to-tuple<?T> (xs:Seqable<?T>) -> Tuple<T> :
   match(xs) :
      (xs:Tuple<T>) :
         xs
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val t = Tuple(n, false as ?)
         for (x in xs, i in 0 to n) do :
            t[i] = x
         t
      (xs) :
         to-tuple(to-vector<T>(xs))

public defn String (cs:Seqable<Char>) -> String :
   match(cs) :
      (cs:Seqable<Char> & Lengthable) :
         val n = length(cs)
         val s = String(n, ' ')
         for (c in cs, i in 0 to false) do :
            s[i] = c
         s
      (c) :
         String(to-vector<Char>(cs))

public defn to-list<?T> (xs:Seqable<?T>) -> List<T> :
   match(xs) :
      (xs:List<T>) :
         xs
      (xs) :
         val vec = to-vector<T>(xs)
         defn* loop (i:Int, accum:List<T>) :
            if i >= 0 : loop(i - 1, cons(vec[i], accum))
            else : accum
         loop(length(vec) - 1, List())

public defn to-array<T> (xs:Seqable<T>) -> Array<T> :
   match(xs) :
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val a = Array<T>(n)
         for (x in xs, i in 0 to n) do :
            a[i] = x
         a
      (xs) :
         to-array<T>(to-list(xs))

public defn symbol-join (xs:Seqable) -> Symbol :
   to-symbol(string-join(xs))

;============================================================
;================== Sequence Library ========================
;============================================================

public defmulti do<?T> (f:T -> ?, xs:Seqable<?T>) -> False
public defmulti do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False
public defmulti do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False

defmethod do<?T> (f:T -> ?, xs:Seqable<?T>) -> False :
   for xs-seq in xs do-seq :
      while not empty?(xs-seq) :
         f(next(xs-seq))

defmethod do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         while (not empty?(xs-seq)) and (not empty?(ys-seq)) :
            f(next(xs-seq), next(ys-seq))

defmethod do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            while (not empty?(xs-seq)) and (not empty?(ys-seq)) and (not empty?(zs-seq)) :
               f(next(xs-seq), next(ys-seq), next(zs-seq))

;Specialization
defmethod do<?T> (f: T -> ?, xs:Array<?T>) :
   val n = length(xs)
   let loop (i:Int = 0) :
      if i < n :
         f(xs[i])
         loop(i + 1)

defmethod do<?T> (f: T -> ?, xs:Tuple<?T>) :
   val n = length(xs)
   let loop (i:Int = 0) :
      if i < n :
         f(xs[i])
         loop(i + 1)

#for (Prim in [Byte Int Long Float Double]
      PrimArray in [ByteArray IntArray LongArray FloatArray DoubleArray]) :
   defmethod do (f: Prim -> ?, xs:PrimArray) :
      val n = length(xs)
      let loop (i:Int = 0) :
         if i < n :
            f(xs[i])
            loop(i + 1)

defmethod do (f: Char -> ?, xs:String) :
   val n = length(xs)
   let loop (i:Int = 0) :
      if i < n :
         f(xs[i])
         loop(i + 1)

defmethod do<?T> (f:T -> ?, xs:List<?T>) -> False :
   let loop (xs:List<T> = xs) :
      if not empty?(xs) :
         f(head(xs))
         loop(tail(xs))

defn wrap-length<?T> (xs:Seq<?T>, length:() -> Int) :
  new Seq<T> & Lengthable :
    defmethod next (this) : next(xs)
    defmethod peek (this) : peek(xs)
    defmethod empty? (this) : empty?(xs)
    defmethod length (this) : length()

public defn to-collection<?T> (f:() -> Seq<?T>) -> Collection<T> :
  new Collection<T> :
    defmethod to-seq (this) : f()

public defn seq<?T,?S> (f:T -> ?S, xs:Seqable<?T>) -> Seq<S> :
  val xs-seq = to-seq(xs)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) : None()
    else : One(f(next(xs-seq)))
  match(xs-seq) :
    (xs:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + length(xs)})
    (xs) : rs

public defn seq<?T,?S,?R> (f:(T,S) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
  val xs-seq = to-seq(xs)
  val ys-seq = to-seq(ys)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) or empty?(ys-seq) : None()
    else : One(f(next(xs-seq), next(ys-seq)))
  match(xs-seq, ys-seq) :
    (xs:Seq&Lengthable, ys:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + min(length(xs), length(ys))})
    (xs, ys) : rs

public defn seq<?T,?S,?U,?R> (f:(T,S,U) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
  val xs-seq = to-seq(xs)
  val ys-seq = to-seq(ys)
  val zs-seq = to-seq(zs)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) or empty?(ys-seq) or empty?(zs-seq) : None()
    else : One(f(next(xs-seq), next(ys-seq), next(zs-seq)))
  match(xs-seq, ys-seq, zs-seq) :
    (xs:Seq&Lengthable, ys:Seq&Lengthable, zs:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + min(length(xs), min(length(ys), length(zs)))})
    (xs, ys, zs) : rs

public defmulti in-reverse<?T> (xs:Seqable<?T>) -> Seq<T>
defmethod in-reverse<?T> (xs:Seqable<?T>) :
  in-reverse(to-vector<T>(xs))

defmethod in-reverse<?T> (xs:IndexedCollection<?T>) :
  val n = length(xs)
  for i in (n - 1) through 0 by -1 seq :
    xs[i]

defmethod in-reverse (r:Range) :
  to-seq(reverse(r))

defmethod in-reverse<?T> (xs:List<?T>) -> Seq<T> :
  generate<T> :
    defn loop (xs:List<T>) :
      if not empty?(xs) :
        loop(tail(xs))
        yield(head(xs))
    loop(xs)

public defmulti contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False
defmethod contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False :
   label<False|True> return :
      for x in xs do :
         return(true) when x == y

public defn find<?T> (f: T -> True|False, xs:Seqable<?T>) -> T|False :
   label<False|T> return :
      for x in xs do :
         return(x) when f(x)

public defn find<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> T|False :
   label<False|T> return :
      for (x in xs, y in ys) do :
         return(x) when f(x, y)

public defn find!<?T> (f: T -> True|False, xs:Seqable<?T>) : find(f, xs) as T
public defn find!<?T, ?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : find(f, xs, ys) as T

public defn first<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Maybe<R> :
   label<Maybe<R>> return :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()

public defn first<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Maybe<R> :
   label<Maybe<R>> return :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()

public defn first!<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) : value!(first(f, xs))
public defn first!<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) : value!(first(f, xs, ys))

public defn seq?<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Seq<R> :
   generate<R> :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?U,?R> (f: (T,S,U) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys, z in zs) do :
         match(f(x, y, z)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn filter<?T> (f: T -> True|False, xs:Seqable<?T>) -> Seq<T> :
   generate<T> :
      for x in xs do :
         yield(x) when f(x)

public defn filter<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<T> :
   generate<T> :
      for (x in xs, y in ys) do :
         yield(x) when f(x, y)

public defn filter<?T> (xs:Seqable<?T>, sel:Seqable<True|False>) -> Seq<T> :
   for (x in xs, s in sel) filter : s

public defn index-of (xs:Seqable<Equalable>, y:Equalable) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when x == y

public defn index-of! (xs:Seqable<Equalable>, y:Equalable) : index-of(xs, y) as Int

public defn index-when<?T> (f: T -> True|False, xs:Seqable<?T>) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when f(x)

public defn index-when<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Int|False :
   label<Int|False> return :
      for (x in xs, y in ys, i in 0 to false) do :
         return(i) when f(x, y)

public defn index-when!<?T> (f: T -> True|False, xs:Seqable<?T>) : index-when(f, xs) as Int
public defn index-when!<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : index-when(f, xs, ys) as Int

public defn split!<?T> (f: T -> True|False, xs: Seqable<?T>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for x in xs do :
      add{_, x} $
         if f(x) : true-xs
         else : false-xs
   [true-xs, false-xs]

public defn split!<?T,?S> (f: (T, S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
  val true-xs = Vector<T>()
  val false-xs = Vector<T>()
  for (x in xs, y in ys) do :
    add{_, x} $
      if f(x, y) : true-xs
      else : false-xs
  [true-xs, false-xs]

public defn split!<?T> (xs:Seqable<?T>, ss:Seqable<True|False>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for (x in xs, s in ss) do :
      add{_, x} $
         if s : true-xs
         else : false-xs
   [true-xs, false-xs]

public defn split<?T> (f:T -> True|False, xs-items:Seqable<?T>) -> [Seq<T>, Seq<T>] :
  val xs = to-seq(xs-items)
  val a-items = Queue<T>()
  val b-items = Queue<T>()

  ;Pull next item onto queues
  defn pull () :
    val x = next(xs)
    if f(x) : add(a-items, x)
    else : add(b-items, x)

  ;Try to fill a queue, returns true if filled
  defn* fill (items:Queue<T>) -> True|False :
    if empty?(items) :
      if not empty?(xs) :
        pull()
        fill(items)
    else :
      true

  ;Create seq from queue
  defn queue-seq (items:Queue<T>) :
    new Seq<T> :
      defmethod next (this) :
        if fill(items) : pop(items)
        else : fatal("No more items")
      defmethod peek (this) :
        if fill(items) : peek(items)
        else : fatal("No more items")
      defmethod empty? (this) :
        not fill(items)

  [queue-seq(a-items), queue-seq(b-items)]

public defn fork<?T> (xs-items:Seqable<?T>) -> [Seq<T>, Seq<T>] :
  val xs = to-seq(xs-items)
  val a-items = Queue<T>()
  val b-items = Queue<T>()

  defn queue-seq (items:Queue<T>, other:Queue<T>) :
    new Seq<T> :
      defmethod next (this) :
        if empty?(items) :
          val x = next(xs)
          add(other, x)
          x
        else :
          pop(items)
      defmethod peek (this) :
        if empty?(items) : peek(xs)
        else : peek(items)
      defmethod empty? (this) :
        empty?(items) and empty?(xs)

  [queue-seq(a-items, b-items),
   queue-seq(b-items, a-items)]

public defn fork<?T> (xs-items:Seqable<?T>, n:Int) -> Tuple<Seq<T>> :
  val xs = to-seq(xs-items)
  val items = to-tuple(repeatedly(Queue<T>{}, n))

  ;Pull next item all queues except queue n
  defn pull (n:Int) :
    val x = next(xs)
    for (q in items, i in 0 to false) do :
      add(q, x) when i != n
    x

  to-tuple $ for i in 0 to n seq :
    val items = items[i]
    new Seq<T> :
      defmethod next (this) :
        if empty?(items) : pull(i)
        else : pop(items)
      defmethod peek (this) :
        if empty?(items) : peek(xs)
        else : peek(items)
      defmethod empty? (this) :
        empty?(items) and empty?(xs)

public defn take-while<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = peek(xs-seq)
               if f(x) :
                  next(xs-seq)
                  yield(x)
                  loop()
         loop()

public defn take-until<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = next(xs-seq)
               yield(x)
               loop() when not f(x)
         loop()

public defn take-n<?T> (n:Int, xs:Seqable<?T>) :
   ensure-non-negative("length", n)
   var len = n
   val xs-seq = to-seq(xs)
   new Seq<T> & Lengthable :
      defmethod next (this) :
         val v = peek(this)
         next(xs-seq)
         len = len - 1
         v
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         peek(xs-seq)
      defmethod empty? (this) :
         len == 0
      defmethod length (this) :
         len
      defmethod free (this) :
         free(xs-seq)

public defn take-up-to-n<?T> (n:Int, xs:Seqable<?T>) :
   ensure-non-negative("length", n)
   var len = n
   val xs-seq = to-seq(xs)
   new Seq<T> :
      defmethod next (this) :
         val v = peek(this)
         next(xs-seq)
         len = len - 1
         v
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         peek(xs-seq)
      defmethod empty? (this) :
         (len == 0) or empty?(xs-seq)
      defmethod free (this) :
         free(xs-seq)

public defn cat<?T> (a:Seqable<?T>, b:Seqable<?T>) -> Seq<T> :
   cat-all([a, b])

public defn cat-all<?T> (xss: Seqable<Seqable<?T>>) -> Seq<T> :
   generate<T> :
      for xs in xss do :
         do(yield, xs)

public defn seq-cat<?T,?R> (f:T -> Seqable<?R>, xs:Seqable<?T>) -> Seq<R> :
   cat-all(seq(f, xs))

public defn seq-cat<?T,?S,?R> (f:(T,S) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   cat-all(seq(f, xs, ys))

public defn seq-cat<?T,?S,?U,?R> (f:(T,S,U) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   cat-all(seq(f, xs, ys, zs))

public defn all?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   for xs-seq in xs do-seq :
      defn* loop () :
         if empty?(xs-seq) : true
         else : pred?(next(xs-seq)) and loop()
      loop()

public defn all?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         defn* loop () :
            if empty?(xs-seq) or empty?(ys-seq) : true
            else : pred?(next(xs-seq), next(ys-seq)) and loop()
         loop()

public defn all?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            defn* loop () :
               if empty?(xs-seq) or empty?(ys-seq) or empty?(zs-seq) : true
               else : pred?(next(xs-seq), next(ys-seq), next(zs-seq)) and loop()
            loop()

public defn none?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   defn notp (x) : not pred?(x)
   all?(notp, xs)

public defn none?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   defn notp (x1, x2) : not pred?(x1, x2)
   all?(notp, xs, ys)

public defn none?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   defn notp (x1, x2, x3) : not pred?(x1, x2, x3)
   all?(notp, xs, ys, zs)

public defn any?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   not none?(pred?, xs)

public defn any?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   not none?(pred?, xs, ys)

public defn any?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   not none?(pred?, xs, ys, zs)

public defn count (xs:Seqable) -> Int :
  match(xs) :
    (xs:Seqable & Lengthable) :
      length(xs)
    (xs) :
      var accum:Int = 0
      for x in xs do :
        accum = accum + 1
      accum

public defn count<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> Int :
   var accum:Int = 0
   for x in xs do :
      if pred?(x) : accum = accum + 1
   accum

public defn join<?T,?S> (xs0:Seqable<?T>, y:?S) -> Seq<T|S> :
  val xs = to-seq(xs0)
  var join? = false
  val rs = new Seq<T|S> :
    defmethod next (this) :
      fatal("Empty Sequence") when empty?(xs)
      val result = y when join? else next(xs)
      join? = not join?
      result
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(xs)
      y when join? else peek(xs)
    defmethod empty? (this) :
      empty?(xs)
  match(xs) :
    (xs:Seq<T> & Lengthable) :
      defn rs-length () :
        if join? : length(xs) * 2
        else : length(xs) * 2 - 1
      wrap-length(rs, rs-length)
    (xs) : rs

public defn interleave<?T,?S> (xs0:Seqable<?T>, ys0:Seqable<?S>) -> Seq<T|S> :
  val xs = to-seq(xs0)
  val ys = to-seq(ys0)
  var yield-x? = true
  val rs = new Seq<T|S> :
    defmethod next (this) :
      fatal("Empty Sequence") when empty?(this)
      val result = next(xs) when yield-x? else next(ys)
      yield-x? = not yield-x?
      result
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(this)
      peek(xs) when yield-x? else peek(ys)
    defmethod empty? (this) :
      empty?(xs) when yield-x? else empty?(ys)
  match(xs, ys) :
    (xs:Seq<T> & Lengthable, ys:Seq<S> & Lengthable) :
      defn rs-length () :
        if yield-x? : 2 * min(length(xs), length(ys))
        else : 1 + 2 * min(length(xs), length(ys) - 1)
      wrap-length(rs, rs-length)
    (xs, ys) : rs

public defn reduce<?T,?S> (f: (T, S) -> ?T, x0: ?T, xs:Seqable<?S>) -> T :
   var accum = x0
   for x in xs do :
      accum = f(accum, x)
   accum

public defn reduce<?T,?S> (f: (T|S, T) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      reduce(f, next(xs-seq), xs-seq)

public defn reduce-right<?T,?S> (f: (S, T) -> ?T, xs:Seqable<?S>, xn:?T) -> T :
   for xs-seq in xs do-seq :
      defn loop () :
         if empty?(xs-seq) : xn
         else : f(next(xs-seq), loop())
      loop()

public defn reduce-right<?T,?S> (f: (T, T|S) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      defn loop (x:T) :
         if empty?(xs-seq) : x
         else : f(x, loop(next(xs-seq)))
      loop(next(xs-seq))

public defn repeat<?T> (x:?T) -> Seq<T> :
   new Seq<T> :
      defmethod next (this) : x
      defmethod peek (this) : x
      defmethod empty? (this) : false

public defn repeat<?T> (x:?T, n:Int) :
   ensure-non-negative("length", n)
   var len = n
   new Seq<T> & Lengthable :
      defmethod next (this) :
         fatal("Empty Sequence") when len == 0
         len = len - 1
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         x
      defmethod empty? (this) :
         len == 0
      defmethod length (this) :
         len

deftype RepeatWhileSeq<T> <: Seq<T>
defmulti cached (s:RepeatWhileSeq) -> Int

public defn repeat-while<?T> (f: () -> Maybe<?T>) -> RepeatWhileSeq<T> :
  var item = sentinel
  defn fill () : (item = f()) when item is Sentinel

  new RepeatWhileSeq<T> :
    defmethod next (this) :
      val x = peek(this)
      item = sentinel
      x
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(this)
      value(item as One<T>)
    defmethod empty? (this) :
      fill()
      item is None
    defmethod cached (this) :
      1 when item is One else 0

public defn repeatedly<?T> (f:() -> ?T) -> Seq<T> :
   var item = sentinel
   defn fill () : (item = f()) when item is Sentinel

   defn empty () :
      val x = item as T
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         item as T
      defmethod empty? (this) :
         false

public defn repeatedly<?T> (f:() -> ?T, n:Int) :
   take-n(n, repeatedly(f))

public defn zip<?T,?S> (xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<[T,S]> :
   for (x in xs, y in ys) seq : [x, y]

public defn zip<?T,?S,?U> (xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<[T,S,U]> :
   for (x in xs, y in ys, z in zs) seq : [x, y, z]

public defn zip-all<?T> (xs:Seqable<Seqable<?T>>) :
   val seqs = to-tuple(seq(to-seq, xs))
   fatal("No Sequences Given") when empty?(seqs)
   val ret-seq = new Seq<Tuple<T>> :
      defmethod next (this) :
         map(next, seqs)
      defmethod peek (this) :
         map(peek, seqs)
      defmethod empty? (this) :
         any?(empty?, seqs)
   if all?({_ is Lengthable&Seq}, seqs) :
      val len = minimum{seq(length{_ as Lengthable&Seq}, seqs)}
      wrap-length(ret-seq, len)
   else :
      ret-seq

public defn unique<?T> (xs:Seqable<?T&Equalable>) -> List<T> :
   ;Manage Visited Set
   val table = HashTable<Hashable,True|False>()
   val accum = Vector<Equalable>()

   defn add-to-unique-set (x:T&Equalable) :
      match(x) :
         (x:T&Equalable&Hashable) : table[x] = true
         (x:T&Equalable) : add(accum, x)
   defn visited? (x:T&Equalable) :
      match(x) :
         (x:T&Equalable&Hashable) : key?(table, x)
         (x:T&Equalable) : contains?(accum, x)

   ;Filter
   to-list $ for x in xs filter :
      if not visited?(x) :
         add-to-unique-set(x)
         true

public defn lookup?<?K,?V,?D> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable, default:?D) -> D|V :
   label<V|D> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      default

public defn lookup?<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> False|V :
   lookup?(xs, k, false)

public defn lookup<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> V :
   label<V> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      fatal("Key %~ not found in entries." % [k])

public defn fork-on-seq<?T,?X,?Y> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y) -> [X,Y] :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val fco = make-co(f)
   val gco = make-co(g)

   ;Store function results
   var fresult = resume(fco, None())
   var gresult = resume(gco, None())

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         if fresult is None :
            fresult = resume(fco, v)
         if gresult is None :
            gresult = resume(gco, v)
         (fresult is None) or
         (gresult is None)
      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   [value!(fresult),
    value!(gresult)]

public defn fork-on-seq<?T,?X,?Y,?Z> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y, h:Seq<T> -> ?Z) -> [X,Y,Z] :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val fco = make-co(f)
   val gco = make-co(g)
   val hco = make-co(h)

   ;Store function results
   var fresult = resume(fco, None())
   var gresult = resume(gco, None())
   var hresult = resume(hco, None())

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         if fresult is None :
            fresult = resume(fco, v)
         if gresult is None :
            gresult = resume(gco, v)
         if hresult is None :
            hresult = resume(hco, v)
         (fresult is None) or
         (gresult is None) or
         (hresult is None)
      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   [value!(fresult),
    value!(gresult),
    value!(hresult)]

public defn fork-on-seq<?T,?S> (xs:Seqable<?T>, fs:Seqable<(Seq<T> -> ?S)>) -> Tuple<S> :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val cos = to-tuple(seq(make-co, fs))

   ;Store function results
   val results = to-array<Maybe<S>>(seq(resume{_, None()}, cos))

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         var more? = false
         for (co in cos, i in 0 to false) do :
            if results[i] is None :
               val r = resume(co, v)
               results[i] = r
               more? = more? or (r is None)
         more?

      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   to-tuple(seq(value!, results))

;============================================================
;=============== Commandline Arguments ======================
;============================================================

public lostanza defn command-line-arguments () -> ref<Array<String>> :
  val r = Array<String>(new Int{clib/input_argc})
  for (var i:int = 0, i < clib/input_argc, i = i + 1) :
    val str = clib/input_argv[i]
    set(r, new Int{i}, String(str))
  return r

public lostanza defn set-command-line-arguments (args:ref<Tuple<String>>) -> ref<False> :
  ;Free old arguments if necessary
  if clib/input_argv_needs_free :
    val n = clib/input_argc
    val ss = clib/input_argv
    for (var i:int = 0, i < n, i = i + 1) :
      call-c clib/stz_free(ss[i])
    call-c clib/stz_free(ss)

  ;Malloc array for new arguments
  val n = length(args).value
  val argvs:ptr<ptr<byte>> = call-c clib/stz_malloc((n + 1) * sizeof(ptr<?>))
  
  ;Copy strings to new array
  for (var i:int = 0, i < n, i = i + 1) :
    argvs[i] = copy-chars(args.items[i])
  argvs[n] = null
  
  ;Set to global variables
  clib/input_argc = n
  clib/input_argv = argvs
  
  ;Set flag to indicate that the newly allocated arguments need to be freed.
  clib/input_argv_needs_free = 1
  
  ;Return from function
  return false

lostanza defn copy-chars (s:ref<String>) -> ptr<byte> :
  val n = length(s).value + 1
  val p:ptr<byte> = call-c clib/stz_malloc(n)
  call-c clib/memcpy(p, addr!(s.chars), n)
  return p

;============================================================
;===================== Random Numbers =======================
;============================================================

public lostanza deftype Random :
  state: long
lostanza defn next-state (s0:long) -> long :
  return (s0 * 0x5deece66dL + 0xbL) & 0xFFFFFFFFFFFFL
lostanza defn extract-bits (s:long, n:int) -> int :
  return (s >>> (48 - n)) as int
lostanza defn next-bits (r:ref<Random>, n:int) -> int :
  val s = next-state(r.state)
  r.state = s
  return extract-bits(s, n)

public lostanza defn Random (state:ref<Long>) -> ref<Random> :
  return new Random{next-state(state.value)}

public lostanza defn state (r:ref<Random>) -> ref<Long> :
  return new Long{r.state}

public lostanza defn set-state (r:ref<Random>, state:ref<Long>) -> ref<False> :
  r.state = state.value
  return false

public defn Random () :
  Random(current-time-us())

public lostanza defn next-int (r:ref<Random>) -> ref<Int> :
  return new Int{next-bits(r, 31)}

public lostanza defn next-signed-int (r:ref<Random>) -> ref<Int> :
  return new Int{next-bits(r, 32)}

val LIMIT-STR = String("limit")
public lostanza defn next-int (r:ref<Random>, n0:ref<Int>) -> ref<Int> :
  ensure-positive(LIMIT-STR, n0)

  ;Extract lostanza values
  val n = n0.value

  ;Power of 2
  if n & (- n) == n :
    val bits = next-bits(r, 31) as long
    return new Int{((n * bits) >> 31) as int}

  ;Otherwise
  labels :
    loop :
      val bits = next-bits(r, 31)
      val v = bits % n
      if bits - v + (n - 1) < 0 : goto loop
      else : return new Int{v}

public lostanza defn next-bytes (r:ref<Random>, bs:ref<ByteArray>) -> ref<False> :
  val n = bs.length
  labels :
    begin: goto loop(r.state, 0)
    loop (s:long, i:long) :
      if i + 4 < n :
        val s* = next-state(s)
        [addr!(bs.data[i]) as ptr<int>] = extract-bits(s*, 32)
        goto loop(s*, i + 4)
      else : goto end(s, i)
    end (s:long, i:long) :
      if i < n :
        val s* = next-state(s)
        bs.data[i] = extract-bits(s*, 8) as byte
        goto end(s*, i + 1)
      else :
        r.state = s
        return false

public defn next-int (rand:Random, r:Range) :
  ;Returns an integer between lo and hi inclusive
  defn from-interval (lo:Int, hi:Int) :
    val spread = hi - lo + 1
    if spread < 0 :
      let loop () :
        val r = next-int(rand)
        if r >= lo and r <= hi : r
        else : loop()
    else :
      lo + next-int(rand, spread)

  ;Check
  #if-not-defined(OPTIMIZE) :
    if step(r) != 1 :
      fatal("Ranges with step sizes other than 1 not supported.")
  val s = start(r)
  match(end(r), inclusive?(r)) :
    (e:Int, inc:True) :
      ensure-start-before-end(s, e)
      from-interval(s, e)
    (e:Int, inc:False) :
      #if-not-defined(OPTIMIZE) :
        if e == s : fatal("Empty range.")
        else : ensure-start-before-end(s, e)
      from-interval(s, e - 1)
    (e:False, inc) :
      from-interval(s, INT-MAX)

public lostanza defn next-long (rand:ref<Random>) -> ref<Long> :
  val x0 = next-bits(rand, 31) as long
  val x1 = next-bits(rand, 32) as long & 0xFFFFFFFFL
  val r0 = (x0 << 32L)
  return new Long{x0 << 32L | x1}

public lostanza defn next-signed-long (rand:ref<Random>) -> ref<Long> :
  val x0 = next-bits(rand, 32) as long
  val x1 = next-bits(rand, 32) as long & 0xFFFFFFFFL
  return new Long{x0 << 32L | x1}

public lostanza defn next-float (rand:ref<Random>) -> ref<Float> :
  return new Float{next-bits(rand,24) as float / (1 << 24) as float}

public lostanza defn next-double (rand:ref<Random>) -> ref<Double> :
  val num = ((next-bits(rand, 26) as long) << 27) + next-bits(rand, 27)
  val den = (1L << 53L) as double
  return new Double{num as double / den}

val RANDOM = Random(current-time-us())
public defn current-random () : RANDOM
public defn srand (n:Long) : set-state(RANDOM, n)
public defn rand () : next-int(RANDOM)
public defn rand-long () : next-long(RANDOM)
public defn rand-float () : next-float(RANDOM)
public defn rand-double () : next-double(RANDOM)
public defn rand (n:Int) : next-int(RANDOM, n)
public defn rand (r:Range) : next-int(RANDOM, r)

;============================================================
;======================== Sleep =============================
;============================================================

extern sleep_us : long -> int
public lostanza defn sleep-us (us:ref<Long>) -> ref<False> :
  call-c sleep_us(us.value)
  return false

;============================================================
;=================== Process Library ========================
;============================================================

;                   Process Structure
;                   =================

public lostanza deftype Process :
  pid: long
  input: ptr<?>
  output: ptr<?>
  error: ptr<?>
  input-stream: ref<False|FileOutputStream>
  output-stream: ref<False|FileInputStream>
  error-stream: ref<False|FileInputStream>

;                 Process State Structure
;                 =======================

public deftype ProcessState
public defstruct ProcessRunning <: ProcessState
public defstruct ProcessDone <: ProcessState : (value:Int)
public defstruct ProcessTerminated <: ProcessState : (signal:Int)
public defstruct ProcessStopped <: ProcessState : (signal:Int)

defmethod print (o:OutputStream, s:ProcessState) :
  print{o, _} $ match(s) :
    (s:ProcessRunning) : "Running"
    (s:ProcessDone) : "Done(exit value = %_)" % [value(s)]
    (s:ProcessTerminated) : "Terminated(signal = %_)" % [signal(s)]
    (s:ProcessStopped) : "Stopped(signal = %_)" % [signal(s)]

;                   Stream Specifier
;                   ================

public defstruct StreamSpecifier <: Equalable : (value:Int)
public val STANDARD-IN = StreamSpecifier(0)
public val STANDARD-OUT = StreamSpecifier(1)
public val PROCESS-IN = StreamSpecifier(2)
public val PROCESS-OUT = StreamSpecifier(3)
public val STANDARD-ERR = StreamSpecifier(4)
public val PROCESS-ERR = StreamSpecifier(5)

defmethod equal? (a:StreamSpecifier, b:StreamSpecifier) :
  value(a) == value(b)

defmethod print (o:OutputStream, s:StreamSpecifier) :
  print{o, _} $ switch(value(s)) :
    0 : "STANDARD-IN"
    1 : "STANDARD-OUT"
    2 : "PROCESS-IN"
    3 : "PROCESS-OUT"
    4 : "STANDARD-ERR"
    5 : "PROCESS-ERR"

;                      Process Errors
;                      ==============
public defstruct ProcessAbortedError <: Exception :
  state: ProcessState
defmethod print (o:OutputStream, e:ProcessAbortedError) :
  match(state(e)) :
    (s:ProcessTerminated) : print(o, "Process prematurely terminated with signal %_." % [signal(s)])
    (s:ProcessStopped) : print(o, "Process prematurely stopped with signal %_." % [signal(s)])

public deftype SystemCallException <: Exception
defn SystemCallException (msg:String) :
  new SystemCallException :
    defmethod print (o:OutputStream, this) :
      print(o, msg)

#if-defined(PLATFORM-WINDOWS) :
  #for (F in splice([
         (Process (filename:String, args:Seqable<String>,
                   input:StreamSpecifier, output:StreamSpecifier, error:StreamSpecifier))
         (Process (filename:String, args:Seqable<String>))
         (input-stream (p:Process))
         (output-stream (p:Process))
         (error-stream (p:Process))
         (state (p:Process))])) :
    public defn F :
      fatal("Process library not yet supported on Windows.")

  public defn call-system (file:String, args:Seqable<String>) -> Int :
    val args-seq = to-seq(args)
    fatal("Arguments list is empty.") when empty?(args-seq)
    next(args-seq) ;Remove first one
    val cmd = escape-shell-command(cat([file], args-seq))
    val r = call-system(cmd)
    throw(SystemCallException(linux-error-msg())) when r < 0
    r

  public defn initialize-process-launcher () :
    false

  lostanza defn call-system (cmd:ref<String>) -> ref<Int> :
    return new Int{call-c clib/system(addr!(cmd.chars))}

#else :

  ;                           Constructor
  ;                           ===========
  public lostanza defn Process (filename:ref<String>,
                                args0:ref<Seqable<String>>,
                                input:ref<StreamSpecifier>,
                                output:ref<StreamSpecifier>,
                                error:ref<StreamSpecifier>) -> ref<Process> :
    ensure-valid-stream-specifiers(input, output, error)
    val args = to-tuple(args0)
    val proc = new Process{0, null, null, null, false, false, false}
    val input_v = value(input).value
    val output_v = value(output).value
    val error_v = value(error).value
    val nargs = args.length
    val argvs:ptr<ptr<byte>> = call-c clib/stz_malloc((nargs + 1) * sizeof(ptr<?>))
    argvs[nargs] = null
    for (var i:long = 0, i < nargs, i = i + 1) :
      argvs[i] = addr!(args.items[i].chars)
    val launch_succ = call-c clib/launch_process(addr!(filename.chars), argvs,
      input_v, output_v, error_v, addr!([proc]))
    if launch_succ < 0 :
      throw(SystemCallException(linux-error-msg()))
    return proc
  public defn Process (filename:String, args:Seqable<String>) :
    Process(filename, args, STANDARD-IN, STANDARD-OUT, STANDARD-ERR)

  defn ensure-valid-stream-specifiers (input:StreamSpecifier, output:StreamSpecifier, error:StreamSpecifier) :
    if not contains?([STANDARD-IN, PROCESS-IN], input) :
      fatal("%_ is not a valid input stream specifier." % [input])
    if not contains?([STANDARD-OUT, PROCESS-OUT, PROCESS-ERR], output) :
      fatal("%_ is not a valid output stream specifier." % [output])
    if not contains?([STANDARD-ERR, PROCESS-OUT, PROCESS-ERR], error) :
      fatal("%_ is not a valid error stream specifier." % [error])

  ;                            Stream API
  ;                            ==========
  public lostanza defn input-stream (p:ref<Process>) -> ref<FileOutputStream> :
    if p.input-stream == false :
      if p.input == null : fatal(String("Process has no input stream."))
      p.input-stream = new FileOutputStream{p.input, 0}
    return p.input-stream as ref<FileOutputStream>
  public lostanza defn output-stream (p:ref<Process>) -> ref<InputStream> :
    if p.output-stream == false :
      if p.output == null : fatal(String("Process has no output stream."))
      p.output-stream = new FileInputStream{p.output, 0}
    return p.output-stream as ref<FileInputStream>
  public lostanza defn error-stream (p:ref<Process>) -> ref<InputStream> :
    if p.error-stream == false :
      if p.error == null : fatal(String("Process has no error stream."))
      p.error-stream = new FileInputStream{p.error, 0}
    return p.error-stream as ref<FileInputStream>

  ;                          Initialization
  ;                          ==============
  public lostanza defn initialize-process-launcher () -> ref<False> :
    call-c clib/initialize_launcher_process()
    return false

  ;                            State API
  ;                            =========
  lostanza deftype StateStruct :
    state: int
    code: int
  public lostanza defn state (p:ref<Process>) -> ref<ProcessState> :
    val s = new StateStruct{0, 0}
    call-c clib/retrieve_process_state(p.pid, addr!([s]))

    ;State Codes
    val RUNNING = 0
    val DONE = 1
    val TERMINATED = 2
    val STOPPED = 3

    ;Translation
    if s.state == RUNNING :
      return ProcessRunning()
    else if s.state == DONE :
      return ProcessDone(new Int{s.code})
    else if s.state == TERMINATED :
      return ProcessTerminated(new Int{s.code})
    else if s.state == STOPPED :
      return ProcessStopped(new Int{s.code})
    else :
      return fatal(String("Unreachable"))

  ;                         System Call API
  ;                         ===============
  public defn call-system (file:String, args:Seqable<String>) -> Int :
    val p = Process(file, args)
    let loop () :
      match(state(p)) :
        (s:ProcessRunning) : loop()
        (s:ProcessDone) : value(s)
        (s) : throw(ProcessAbortedError(s))

;============================================================
;================== Shell Escaping ==========================
;============================================================

;Tokenize the given string using typical shell parsing rules.
public defn tokenize-shell-command (s:String) -> Collection<String> :
  defn whitespace? (c:Char) :
    (c == ' ') or
    (c == '\n') or
    (c == '\t') or
    (c == '\b') or
    (c == '\r')

  ;Buffer management
  val buffer = StringBuffer()
  val args = Vector<String>()
  defn add-char (c:Char) :
    add(buffer, c)
  defn make-arg () :
    add(args, to-string(buffer))
    clear(buffer)

  ;View characters as stream
  val stream = StringInputStream(s)

  ;General read dispatch
  defn* read () :
    val c = peek?(stream)
    match(c:Char) :
      if whitespace?(c) :
        get-char(stream)
        read()
      else :
        read-arg()

  defn* read-arg () :
    val c = peek?(stream)
    match(c:Char) :
      if whitespace?(c) :
        make-arg()
        read()
      else if c == '"' or c == '\'' :
        get-char(stream)
        read-until(c)
        read-arg()
      else if c == '\\' :
        get-char(stream)
        val c2 = get-char(stream)
        match(c2:Char) :
          add-char(c2)
          read-arg()
        else :
          make-arg()
      else :
        get-char(stream)
        add-char(c)
        read-arg()
    else :
      make-arg()


  defn* read-until (end:Char) :
    val c = get-char(stream)
    match(c:Char) :
      if c == '\\' :
        val c2 = peek?(stream)
        match(c2:Char) :
          if c2 == end :
            get-char(stream)
            add-char(c2)
            read-until(end)
          else :
            add-char(c)
            read-until(end)
        else :
          add-char(c)
      else if c != end :
        add-char(c)
        read-until(end)

  ;End
  read()
  args

;Escape shell command
public defn escape-shell-command (args:Seqable<String>) -> String :
  #if-defined(PLATFORM-WINDOWS) :
    defn escape (s:String, i:Int) :
      val s* =
        replace{_, "\"", "\\\""} $
        replace{_, "\\", "\\\\"} $
        s
      if i == 0 : s*
      else : "\"%_\"" % [s*]
    val escaped = seq(escape, args, 0 to false)
    to-string("%s" % [escaped])
  #else :
    defn escape (s:String) :
      {"\"%_\"" % [_]} $
      replace{_, "\"", "\\\""} $
      replace{_, "\\", "\\\\"} $
      s
    to-string("%s" % [seq(escape, args)])

;============================================================
;===================== Id Pool ==============================
;============================================================

val ID-SEQ = to-seq(0 to false)
val FREE-IDS = Vector<Int>()
val OBJ-MAP = Vector<?>()

public lostanza defn box-object (x:ref<?>) -> int :
   var id:ref<Int>
   if empty?(FREE-IDS) == true : id = next(ID-SEQ)
   else : id = pop(FREE-IDS)
   set(OBJ-MAP, id, x)
   return id.value

public lostanza defn free-box (id:int) -> ref<False> :
   add(FREE-IDS, new Int{id})
   set(OBJ-MAP, new Int{id}, false)
   return false

public lostanza defn boxed-object (id:int) -> ref<?> :
   return get(OBJ-MAP, new Int{id})

public lostanza defn boxed-object? (id:int) -> int :
   val n = length(OBJ-MAP).value
   if id >= 0 and id < n : return 1
   else : return 0

;============================================================
;==================== Resources =============================
;============================================================

public deftype Resource
public defmulti free (r:Resource) -> False

protected defn with-resource<?T,?S> (f:T -> ?S, x:?T&Resource) -> S :
   try : f(x)
   finally : free(x)

;============================================================
;==================== LivenessTracker =======================
;============================================================

public deftype Unique

public lostanza deftype LivenessTracker :
  value: ref<False|Unique>
  tail: ptr<?>

public lostanza defn LivenessTracker (value:ref<Unique>) -> ref<LivenessTracker> :
  return new LivenessTracker{value, null}

public lostanza defn value (t:ref<LivenessTracker>) -> ref<False|Unique> :
  return t.value

;============================================================
;======================= Finalizers =========================
;============================================================

;LivenessHandler/run returns true if the LivenessHandler ran,
;and thus should be removed from the LivenessHandler list.
deftype LivenessHandler
defmulti run (f:LivenessHandler) -> True|False

val LIVENESS-HANDLERS = Vector<LivenessHandler>()
val QUEUED-LIVENESS-HANDLERS = Vector<LivenessHandler>()
add-gc-notifier $ fn () :
  add-all(LIVENESS-HANDLERS, QUEUED-LIVENESS-HANDLERS)
  clear(QUEUED-LIVENESS-HANDLERS)
  remove-when(run, LIVENESS-HANDLERS)

public deftype Finalizer
public defmulti run (f:Finalizer) -> ?

public defn add-finalizer (f:Finalizer, v:Unique) :
  val tracker = LivenessTracker(v)
  val liveness-handler = new LivenessHandler :
    defmethod run (this) :
      if value(tracker) is False :
        run(f)
        true
  add(QUEUED-LIVENESS-HANDLERS, liveness-handler)

public defn add-finalizer (f:() -> ?, v:Unique) :
  val tracker = LivenessTracker(v)
  val liveness-handler = new LivenessHandler :
    defmethod run (this) :
      if value(tracker) is False :
        f()
        true
  add(QUEUED-LIVENESS-HANDLERS, liveness-handler)

;============================================================
;==================== Autofree ==============================
;============================================================
;
;lostanza deftype FreeCallback :
;   c-convention:int
;   free:ptr<(ptr<?> -> int)>
;   value:ptr<?>
;
;lostanza defn free (c:ref<FreeCallback>) -> ref<False> :
;   if c.c-convention :
;      call-c [c.free](c.value)
;   else :
;      [c.free](c.value)
;   return false
;
;public lostanza defn c-autofree-marker (free:ptr<(ptr<?> -> int)>, value:ptr<?>) -> ref<LivenessMarker> :
;   val t = LivenessTracker(new FreeCallback{1, free, value})
;   add(FREE-CALLBACKS, t)
;   return marker!(t)
;
;public lostanza defn autofree-marker (free:ptr<(ptr<?> -> int)>, value:ptr<?>) -> ref<LivenessMarker> :
;   val t = LivenessTracker(new FreeCallback{0, free, value})
;   add(FREE-CALLBACKS, t)
;   return marker!(t)
;
;val FREE-CALLBACKS = Vector<LivenessTracker<FreeCallback>>()
;add-gc-notifier $ fn () :
;   for t in FREE-CALLBACKS remove-when :
;      if marker(t) is False :
;         free(value(t))
;         true
;
;============================================================
;=================== Pretty Printer =========================
;============================================================

;                  General Interface
;                  =================

public defmulti write (o:OutputStream, x) -> False

;                Default Implementation
;                ======================

defmethod write (o:OutputStream, x) :
   print(o, x)

public defn write-all (o:OutputStream, xs:Seqable) -> False :
   val xs-seq = to-seq(xs)
   if not empty?(xs-seq) :
      write(o, next(xs-seq))
   while not empty?(xs-seq) :
      print(o, " ")
      write(o, next(xs-seq))

;                    Escape Sequences
;                    ================

defn general-escape (o:OutputStream, c:Char) :
   defn escape (c:Char) :
      print(o, '\\')
      print(o, c)
   switch {c == _} :
      '\t' : escape('t')
      '\b' : escape('b')
      '\r' : escape('r')
      '\n' : escape('n')
      '\\' : escape('\\')
      else : print(o, c)

defn escape-for-string (o:OutputStream, c:Char) :
   if c == '\"' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

defn escape-for-symbol (o:OutputStream, c:Char) :
   if c == '|' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

defn escape-for-char (o:OutputStream, c:Char) :
   if c == '\'' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

;              Determination Whether Symbol Requires Escape
;              ============================================

lostanza var NECESSARY-IDENTIFIER-CHARS:ref<String>
lostanza var IDENTIFIER-CHARS:ref<String>
lostanza var OPERATOR-CHARS:ref<String>

lostanza defn tag-char (table:ref<String>, c:byte) -> int :
   table.chars[c] = 1 as byte
   return 0

lostanza defn tag-chars (table:ref<String>, cs:ptr<byte>) -> int :
   for (var i:long = 0, 1, i = i + 1) :
      val c = cs[i]
      if c == 0 : return 0
      tag-char(table, c)
   fatal("Unreachable")
   return 0

lostanza let :
  NECESSARY-IDENTIFIER-CHARS = String(256, 0 as byte)
  IDENTIFIER-CHARS = String(256, 0 as byte)
  OPERATOR-CHARS = String(256, 0 as byte)

  val L = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
  val U = "_?"
  val D = "0123456789"
  val P = "~!@#$%^*+-=/"
  val S = ".:<>&|"

  tag-chars(NECESSARY-IDENTIFIER-CHARS, L)
  tag-chars(NECESSARY-IDENTIFIER-CHARS, U)

  tag-chars(IDENTIFIER-CHARS, L)
  tag-chars(IDENTIFIER-CHARS, U)
  tag-chars(IDENTIFIER-CHARS, D)
  tag-chars(IDENTIFIER-CHARS, P)

  tag-chars(OPERATOR-CHARS, P)
  tag-chars(OPERATOR-CHARS, S)

public deftype SymbolParseClass
public defstruct NumberClass <: SymbolParseClass
public defstruct IdentifierClass <: SymbolParseClass
public defstruct OperatorClass <: SymbolParseClass

defmethod print (o:OutputStream, c:SymbolParseClass) :
  print{o, _} $ match(c) :
    (c:NumberClass) : "Number"
    (c:IdentifierClass) : "Identifier"
    (c:OperatorClass) : "Operator"

lostanza defn digit-char? (b:byte) -> long :
  if b >= '0' and b <= '9' : return 1
  else : return 0

lostanza defn gensymbol? (s:ref<Symbol>) -> long :
  match(s) :
    (s:ref<GenSymbol>) : return 1
    (s) : return 0

public lostanza defn parse-as? (c:ref<Symbol>) -> ref<SymbolParseClass|False> :
  ;Does it parse as a number?
  val name = name(c)
  val l = length(name).value
  if (l == 0 and gensymbol?(c)) or
     digit-char?(name.chars[0]) or
     (name.chars[0] == '-' and l == 1 and gensymbol?(c)) or
     (name.chars[0] == '-' and l > 1 and digit-char?(name.chars[1])) :
    return NumberClass()

  ;Collect statistics
  var all-id:long = 1
  var all-op:long = 1
  var has-nid:long = 0
  for (var i:long = 0, i < l, i = i + 1) :
    val c = name.chars[i]
    if NECESSARY-IDENTIFIER-CHARS.chars[c] == 1 : has-nid = 1
    if IDENTIFIER-CHARS.chars[c] == 0 : all-id = 0
    if OPERATOR-CHARS.chars[c] == 0 : all-op = 0
  if gensymbol?(c) : all-op = 0

  ;Classify
  if l == 0 : return false
  else if all-id and has-nid : return IdentifierClass()
  else if all-op : return OperatorClass()
  else : return false

public defn escape? (s:Symbol) :
  parse-as?(s) is NumberClass|False

;                  Escaped Primitive Values
;                  ========================

defmethod write (o:OutputStream, c:Char) :
   print(o, '\'')
   escape-for-char(o, c)
   print(o, '\'')

defmethod write (o:OutputStream, s:String) :
   print(o, '"')
   for c in s do :
      escape-for-string(o, c)
   print(o, '"')

defmethod write (o:OutputStream, x:Byte) :
   print(o, x)
   print(o, 'Y')

defmethod write (o:OutputStream, x:Long) :
   print(o, x)
   print(o, 'L')

defmethod write (o:OutputStream, b:Float) :
   print(o, b)
   print(o, 'f')

defmethod write (o:OutputStream, s:StringSymbol) :
   if escape?(s) :
      print(o, "\\|")
      for c in name(s) do :
         escape-for-symbol(o, c)
      print(o, '|')
   else :
      print(o, name(s))

defmethod write (o:OutputStream, s:GenSymbol) :
   if escape?(s) :
      print(o, "\\|")
      for c in name(s) do :
         escape-for-symbol(o, c)
      print(o, id(s))
      print(o, '|')
   else :
      print(o, name(s))
      print(o, id(s))

;============================================================
;===================== Timers ===============================
;============================================================

public lostanza defn current-time-ms () -> ref<Long> :
   val ms = call-c clib/current_time_ms()
   return new Long{ms}

public lostanza defn current-time-us () -> ref<Long> :
   val us = call-c clib/current_time_us()
   return new Long{us}

public deftype Timer
public defmulti start (t:Timer) -> False
public defmulti stop (t:Timer) -> False
public defmulti time (t:Timer) -> Long

defn Timer (name:String, get-time: () -> Long) :
   var total-time:Long = 0L
   var last-time:Long = 0L
   var running = false
   new Timer :
      defmethod start (this) :
         fatal("Timer already running.") when running
         last-time = get-time()
         running = true
      defmethod stop (this) :
         fatal("Timer is not running.") when not running
         val time = get-time()
         total-time = total-time + time - last-time
         last-time = time
         running = false
      defmethod time (this) :
         if running : total-time + get-time() - last-time
         else : total-time
      defmethod print (o:OutputStream, this) :
         print(o, "[%_ Timer : %_]" % [name, time(this)])

public defn MillisecondTimer (name:String) :
   Timer(name, current-time-ms)

public defn MicrosecondTimer (name:String) :
   Timer(name, current-time-us)

public defn PiggybackTimer (name:String, t:Timer) :
   Timer(name, time{t})

;============================================================
;==================== Reified Types =========================
;============================================================

public deftype TypeObject<T>
public defmulti typeof?<?T> (x, t:TypeObject<?T>) -> True|False
public defmulti name (t:TypeObject) -> String

;############################################################
;################## Math Package ############################
;############################################################

defpackage math :
   import core

public lostanza val PI:ref<Double> = new Double{3.141592653589793}
public lostanza val PI-F:ref<Float> = new Float{3.1415927f}

public lostanza defn exp (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/exp(x.value)}
public lostanza defn exp (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/exp(x.value) as float}

public lostanza defn log (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/log(x.value)}
public lostanza defn log (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/log(x.value) as float}

public lostanza defn log10 (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/log10(x.value)}
public lostanza defn log10 (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/log10(x.value) as float}

public lostanza defn sqrt (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sqrt(x.value)}
public lostanza defn sqrt (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sqrt(x.value) as float}

public lostanza defn pow (x:ref<Double>, y:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/pow(x.value, y.value)}
public lostanza defn pow (x:ref<Float>, y:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/pow(x.value, y.value) as float}

public lostanza defn sin (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sin(x.value)}
public lostanza defn sin (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sin(x.value) as float}

public lostanza defn cos (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/cos(x.value)}
public lostanza defn cos (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/cos(x.value) as float}

public lostanza defn tan (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/tan(x.value)}
public lostanza defn tan (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/tan(x.value) as float}

public lostanza defn asin (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/asin(x.value)}
public lostanza defn asin (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/asin(x.value) as float}

public lostanza defn acos (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/acos(x.value)}
public lostanza defn acos (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/acos(x.value) as float}

public lostanza defn atan (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/atan(x.value)}
public lostanza defn atan (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/atan(x.value) as float}

public lostanza defn atan2 (y:ref<Double>, x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/atan2(y.value, x.value)}
public lostanza defn atan2 (y:ref<Float>, x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/atan2(y.value, x.value) as float}

public lostanza defn sinh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sinh(x.value)}
public lostanza defn sinh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sinh(x.value) as float}

public lostanza defn cosh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/cosh(x.value)}
public lostanza defn cosh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/cosh(x.value) as float}

public lostanza defn tanh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/tanh(x.value)}
public lostanza defn tanh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/tanh(x.value) as float}

public lostanza defn ceil (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/ceil(x.value)}
public lostanza defn ceil (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/ceil(x.value) as float}

public lostanza defn floor (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/floor(x.value)}
public lostanza defn floor (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/floor(x.value) as float}

public lostanza defn round (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/round(x.value)}
public lostanza defn round (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/round(x.value) as float}

public lostanza defn to-radians (degrees:ref<Double>) -> ref<Double> :
   val pi = 3.141592653589793
   return new Double{degrees.value * pi / 180.0}

public lostanza defn to-degrees (radians:ref<Double>) -> ref<Double> :
   val pi = 3.141592653589793
   return new Double{radians.value * 180.0 / pi}
