defpackage core/local-table :
  import core
  import collections
  
;============================================================
;========== Lostanza Reflection of Binary Layout ============
;============================================================

public lostanza deftype LSLocalVarTable :
  varmaps:ptr<LSVarMaps>
  contexts:ptr<LSVarContexts>
  named-vars:ptr<LSNamedVars>
  index-maps:ptr<LSIndexMaps>
  indices:ptr<LSIndices>

public lostanza deftype LSVarMaps :
  length:long
  entries:LSVarMapEntry ...

public lostanza deftype LSVarMapEntry :
  code-label:ptr<?>
  context-index:int
  index-map-index:int

public lostanza deftype LSVarContexts :
  length:int
  var-indices:int ...

public lostanza deftype LSNamedVars :
  length:long
  vars:LSNamedVar ...

public lostanza deftype LSNamedVar :
  stack-offset:long
  name:ptr<byte>

public lostanza deftype LSIndexMaps :
  length:int
  start-indices:int ...

public lostanza deftype LSIndices :
  length:int
  indices:int ...

;============================================================
;======================= Accessors ==========================
;============================================================

;HiStanza handle for the LocalVarTable.
public lostanza deftype LocalVarTable :
  value:ptr<LSLocalVarTable>

;HiStanza handle for a VarContext.
public lostanza deftype VarContext :
  vartable:ptr<LSLocalVarTable>
  entry:LSVarMapEntry

;Create a LocalVarTable from a pointer to the underlying binary data.
public lostanza defn LocalVarTable (data:ptr<LSLocalVarTable>) -> ref<LocalVarTable> :
  return new LocalVarTable{data}

;Retrieve the VarContext for the given code position, if there is one.
public lostanza defn context (table:ref<LocalVarTable>, codepos:ptr<?>) -> ref<VarContext|False> :
  val varmaps = table.value.varmaps
  for (var i:long = 0, i < varmaps.length, i = i + 1) :
    if varmaps.entries[i].code-label == codepos :
      return new VarContext{table.value, varmaps.entries[i]}
  return false