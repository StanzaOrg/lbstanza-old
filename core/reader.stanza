;See License.txt for details about licensing.
defpackage reader :
   import core with :
      prefix(digit?) => core-
   import collections

;============================================================
;================== Public Interface ========================
;============================================================

;public defn read (eater:StringInputStream) :
;   val info = info(eater)
;   init-lexer(eater)
;   eat-lexeme()
;   while (peek?(EATER) != false) and not empty?(SCOPES) :
;      eat-lexeme()
;   val forms = lex-all(group-all())
;   throw(LexerExceptions(ERRORS)) when not empty?(ERRORS)
;   throw(NoForm(info)) when empty?(forms)
;   head(forms)

public defn read-all (s:StringInputStream) :
   group-all(tokenize(s))

public defn read-all (text:String) -> List :
   read-all(StringInputStream(text))

public defn read-file (filename:String) -> List :
   read-all(StringInputStream(slurp(filename), filename))

;============================================================
;================== Token Classes ===========================
;============================================================

defstruct Indentation :
   indent:Int
defmethod print (o:OutputStream, i:Indentation) :
   print-all(o, ["[Indentation " indent(i) "]"])

defstruct OpenToken :
   symbol:Symbol
defmethod print (o:OutputStream, t:OpenToken) :
   print-all(o, ["OPEN[" symbol(t) "]"])

defstruct CloseToken :
   symbol:Symbol
defmethod print (o:OutputStream, t:CloseToken) :
   print-all(o, ["CLOSE[" symbol(t) "]"])

defstruct QuoteToken
defmethod print (o:OutputStream, t:QuoteToken) :
   print(o, "QUOTE")

defstruct CaptureToken :
   symbol: Symbol
defmethod print (o:OutputStream, t:CaptureToken) :
   print-all(o, ["CAP[" symbol(t) "]"])

;============================================================
;================ Generator Refactor ========================
;============================================================

defn tokenize (s:StringInputStream) :
   ;TODO: Use get-char! when sure.

   ;Scope stack
   val scopes = Vector<Symbol>()

   ;Determine if character is operator character
   defn operator-char? (c) :
      if c == '>' :
         empty?(scopes) or (peek(scopes) != `>)
      else :
         class?(c, OPERATOR-CHAR)

   ;Convert escape specifier to character
   defn escape-char (c:Char) -> Char : ;TODO: Use a map instead
      switch {c == _} :
         't' : '\t'
         'b' : '\b'
         'r' : '\r'
         'n' : '\n'
         '\\' : c
         '\"' : c
         '\'' : c
         '|' : c
         else : throw(InvalidEscapeChar(info(s), c))

   ;Eat paired characters
   defn eat-escaped-chars () :
      val buf = StringBuffer() ;TODO: Pull out stringbuffer
      val end-char = peek?(s)
      val end = loop(1) where :
         defn* loop (i:Int) :  ;TODO: Directly consume characters instead of calculating index
            val c1 = peek?(s, i)
            val c2 = peek?(s, i + 1)
            if c1 == false :
               false
            else if c1 == end-char :
               i + 1
            else if c1 == '\\' and c2 != false :
               add(buf, escape-char(c2 as Char))
               loop(i + 2)
            else :
               add(buf, c1 as Char)
               loop(i + 1)
      if end != false :
         get-chars(s, end as Int)
         to-string(buf)

   ;Eat until end of line
   defn eat-comment () -> True|False :
      if peek?(s) == ';' :
         while (peek?(s) != false and peek?(s) != '\n') :
            get-char(s)
         true

   ;Eat whitespace
   defn eat-whitespace () :
      while whitespace?(peek?(s)) :
         get-char!(s)

   ;Compute the ending index of a symbol
   ;TODO: alpha? needs a better name
   defn symbol-end (start:Int) -> False|Int :
      defn* loop (a?:True|False, i:Int) :
         if symbol-char?(peek?(s,i)) :
            loop(a? or alpha?(peek?(s,i)), i + 1)    ;TODO: Simplify this function
         else if a? :
            i
      loop(false, start)

   ;Compute the ending index of a number
   defn* number-end (i:Int) -> Int : ;TODO: Pull out map
      val c = peek?(s,i)
      if c == false or
         c == '\n' or
         c == ':' or
         open-brace?(c) or
         close-brace?(c) or
         whitespace?(c) : i
      else : number-end(i + 1)

   ;e.g. 'c'
   defn* eat-char () :
      val info = info(s)
      if peek?(s) == '\'' :
         match(eat-escaped-chars()) :
            (s:String) :
               if length(s) == 1 : Token(s[0], info)
               else : throw(InvalidCharString(info))
            (s:False) : throw(UnclosedCharString(info))

   ;e.g. "This is their\'s."
   defn* eat-string () :
      val info = info(s)
      if peek?(s) == '\"' :
         match(eat-escaped-chars()) :
            (s:String) : Token(s, info)
            (s:False) : throw(UnclosedString(info))

   ;e.g. \|My house|
   defn* eat-escaped-symbol () :
      val info = info(s)
      if peek?(s) == '\\' and peek?(s, 1) == '|' :
         get-char(s)
         match(eat-escaped-chars()) :
            (s:String) : Token(to-symbol(s), info)
            (s:False) : throw(UnclosedSymbol(info))

   ;A symbol is a string of SYMBOL characters that contains at
   ;least one alpha character. Some special symbols represent values.
   ;e.g. my/identifier
   defn* eat-symbol () :
      match(symbol-end(0)) :
         (len:Int) :
            val info = info(s)
            val str = get-chars(s, len)
            switch {str == _} :
               "true" : Token(true, info)
               "false" : Token(false, info)
               else : Token(to-symbol(str), info)
         (len:False) :
            false

   ;An operator is a reluctant string of OPERATOR characters.
   ;e.g. <:
   defn eat-operator () :
      val len = look-forward(0) where :
         defn* look-forward (i:Int) :
            if operator-char?(peek?(s,i)) : look-forward(i + 1)
            else if alpha?(peek?(s,i)) : look-back(i - 1)
            else : i
         defn* look-back (i:Int) :
            if symbol-char?(peek?(s,i)) : look-back(i - 1)
            else : i + 1
      if len > 0 :
         val info = info(s)
         Token(to-symbol(get-chars(s, len)), info)

   ;Eat a starting indent (assumes beginning of line)
   defn* eat-indent () :
      val info = info(s)
      val len = find!({peek?(s,_) != ' '}, 0 to false)
      get-chars(s, len)
      val indent = Token(Indentation(len), info)
      if eat-comment() :
         eat-indent()
      else if peek?(s) == '\n' :
         get-char(s)
         eat-indent()
      else :
         indent

   ;Eat a number
   ;e.g. 103L
   defn eat-number () :
      if digit?(peek?(s,0)) or
         (peek?(s) == '-' and digit?(peek?(s,1))) :
         val info = info(s)
         val str = get-chars(s, number-end(0))
         defn number? (x) :
            match(x) :
               (x:False) : throw(InvalidNumber(info))
               (x) : Token(x, info)
         if contains?(str, '.') :
            if suffix?(str, "f") or suffix?(str, "F") :
               number?(to-float(but-last(str)))
            else : number?(to-double(str))
         else :
            if suffix?(str, "y") or suffix?(str, "Y") :
               number?(to-byte(but-last(str)))
            else if suffix?(str, "l") or suffix?(str, "L") :
               number?(to-long(but-last(str)))
            else : number?(to-int(str))

   ;Eat a here string
   ;e.g. \<STR>This is my String<STR>
   defn eat-here-string () :
      if peek?(s) == '\\' and peek?(s,1) == '<' :
         val info = info(s)
         get-char!(s)
         val tag-len =
            match(find({peek?(s,_) == '>'}, 0 to length(s))) :
               (i:Int) : i + 1
               (n:False) : throw(InvalidTag(info))
         defn tag? (i:Int) :                          ;TODO: Use string:index-of instead
            for j in 0 to tag-len all? :
               peek?(s, i + j) == peek?(s, j)
         val str-len =
            match(find(tag?, tag-len to length(s))) :
               (i:Int) : i - tag-len
               (n:False) : throw(NoEndTagFound(info))
         get-chars(s, tag-len)
         val str = get-chars(s, str-len)
         get-chars(s, tag-len)
         Token(str, info)

   ;e.g. [
   defn eat-structural-token () :
      val info = info(s)
      if open-brace?(peek?(s)) :
         Token(OpenToken(to-symbol(get-char!(s))), info)
      else if close-brace?(peek?(s)) :
         Token(CloseToken(to-symbol(get-char!(s))), info)
      else if punc?(peek?(s)) :
         get-char!(s)
         Token(QuoteToken(), info)

   ;e.g. (
   defn eat-star-token () :
      val info = info(s)
      if open-brace?(peek?(s)) :
         Token(OpenToken(symbol-join(["*" get-char!(s)])), info)

   ;e.g. ?x
   defn eat-capture () :
      if (peek?(s) == '?') :
         match(symbol-end(1)) :
            (end:Int) :
               val info = info(s)
               get-char!(s)
               val sym = to-symbol(get-chars(s, end - 1))
               Token(CaptureToken(sym), info)
            (end:False) :
               false

   ;Update the scope stack
   defn update-stack (info:FileInfo, c:Symbol) :
      defn pop-stack () :
         if empty?(scopes) :
            throw(ExtraClosingToken(info, c))
         else if peek(scopes) != c :
            throw(WrongClosingToken(info, peek(scopes), c))
         else :
            pop(scopes)

      switch {c == _} :
         `\|<| : add(scopes, `\|>|)
         `\|[| : add(scopes, `\|]|)
         `\|{| : add(scopes, `\|}|)
         `\|(| : add(scopes, `\|)|)
         `\|*<| : add(scopes, `\|>|)
         `\|*[| : add(scopes, `\|]|)
         `\|*{| : add(scopes, `\|}|)
         `\|*(| : add(scopes, `\|)|)
         `\|>| : pop-stack()
         `\|]| : pop-stack()
         `\|}| : pop-stack()
         `\|)| : pop-stack()
         else : fatal("Invalid stack symbol: %~" % [c])

   generate<Token> :
      defn eat? (f: () -> False|Token) :
         match(f()) :
            (t:Token) :
               ;Yield out the token
               yield(t)
               ;Update the stack
               match(item(t)) :
                  (x:OpenToken) : update-stack(info(t), symbol(x)) ;TODO: Make use of this differentiation
                  (x:CloseToken) : update-stack(info(t), symbol(x))
                  (x) : false
               ;Eat a star token if necessary
               val star? = match(item(t)) :
                  (x:CloseToken) : true
                  (x:CaptureToken) : true
                  (x:Byte|Char|Int|Long|Float|Double|True|False|String) : true
                  (x:Symbol) : any?(alpha?, to-string(x)) ;TODO: This seems redundant
                  (x) : false
               eat?(eat-star-token) when star? ;TODO: A bit messy: Shouldn't be recursing on eat?
               ;Return true if we successfully ate something
               true
            (t:False) :
               false

      defn eat-lexeme! () :
         val eaten =
            eat?(eat-capture) or
            eat?(eat-here-string) or
            eat?(eat-escaped-symbol) or
            eat?(eat-char) or
            eat?(eat-string) or
            eat?(eat-number) or
            eat?(eat-symbol) or
            eat?(eat-operator) or
            eat?(eat-structural-token)
         throw(InvalidToken(info(s))) when not eaten

      defn* eat-lexeme () :
         eat-whitespace()
         if peek?(s) is-not False :
            if eat-comment() :
               eat-lexeme()
            else if peek?(s) == '\n' :
               get-char!(s)
               eat-indent()
            else :
               eat-lexeme!()

      while peek?(s) is-not False : ;TODO: Have eat-lexeme return true or false for loop
         eat-lexeme()

;============================================================
;================== Lexer State =============================
;============================================================

;TODO: Use Coroutine to generate LEXEMES?
;var LEXEMES: Vector<Token>
;var SCOPES: Vector<Symbol>
;var ERRORS: Vector<LexerException>
;var EATER: StringInputStream
;var STAR?: True|False
;
;defn init-lexer (eater:StringInputStream) :
;   EATER = eater
;   LEXEMES = Vector<Token>()
;   SCOPES = Vector<Symbol>()
;   ERRORS = Vector<LexerException>()
;   STAR? = false

;============================================================
;================= Character Classes ========================
;============================================================

;TODO: Use the existing BitArray to do this.
;      Or implement a new CharMap
val CHAR-CLASSES = CharArray(256, to-char(0))
defn class? (c, bit:Int) -> True|False :
   match(c) :
      (c:Char) :
         val mask = to-int(CHAR-CLASSES[to-int(c as Char)])
         ((mask >> bit) & 1) == 1
      (c) :
         false

defn tag-class (c:Char, bit:Int) :
   val tag = 1 << bit
   val i = to-int(c)
   val mask = to-int(CHAR-CLASSES[i])
   val c2 = to-char(mask | tag)
   CHAR-CLASSES[i] = c2

defn tag-class (class:String, bit:Int) :
   for c in class do :
      tag-class(c, bit)

val DIGIT-CHAR = 0
val ALPHA-CHAR = 1
val PUNC-CHAR = 2
val OPEN-BRACE-CHAR = 3
val CLOSE-BRACE-CHAR = 4
val OPERATOR-CHAR = 5
val SYMBOL-CHAR = 6
val WHITESPACE-CHAR = 7

let :
   val digits = "0123456789"
   val letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
   tag-class(letters, ALPHA-CHAR)
   tag-class("_?", ALPHA-CHAR)

   tag-class(letters, SYMBOL-CHAR)
   tag-class("_?", SYMBOL-CHAR)
   tag-class("~!@#$%^*+-=/", SYMBOL-CHAR)
   tag-class(digits, SYMBOL-CHAR)

   tag-class("~!@#$%^*+-=/", OPERATOR-CHAR)
   tag-class(".:<&|", OPERATOR-CHAR)

   tag-class(digits, DIGIT-CHAR)
   tag-class("`", PUNC-CHAR)
   tag-class("([{<", OPEN-BRACE-CHAR)
   tag-class(")]}>", CLOSE-BRACE-CHAR)

   tag-class(" ,\r", WHITESPACE-CHAR)

;Test if a character is whitespace
defn whitespace? (c) :
   class?(c, WHITESPACE-CHAR)

;Test if a character is a digit
defn digit? (c) :
   class?(c, DIGIT-CHAR)

defn alpha? (c) :
   class?(c, ALPHA-CHAR)

defn punc? (c) :
   class?(c, PUNC-CHAR) ;TODO: This is now unnecessary

defn open-brace? (c) :
   class?(c, OPEN-BRACE-CHAR)

defn close-brace? (c) :
   class?(c, CLOSE-BRACE-CHAR)

defn number-char? (c) :
   digit?(c) or (c == '.')

defn symbol-char? (c) :
   class?(c, SYMBOL-CHAR)

;============================================================
;================== Utilities ===============================
;============================================================

defn get-char! (s:InputStream) : get-char(s) as Char

defn but-last (str:String) :
   str[0 to (length(str) - 1)]

;============================================================
;================= Eating Functions =========================
;============================================================





;============================================================
;===================== Grouping =============================
;============================================================

;TODO: Get rid of the need for these. Change them to characters
val OPEN-PAREN = `\|(|
val STAR-PAREN = `\|*(|
val CLOSE-PAREN = `\|)|
val OPEN-BRACKET = `\|{|
val STAR-BRACKET = `\|*{|
val CLOSE-BRACKET = `\|}|
val OPEN-BRACE = `\|[|
val STAR-BRACE = `\|*[|
val CLOSE-BRACE = `\|]|
val STAR-ANGLE = `\|*<|
val CLOSE-ANGLE = `\|>|
val COLON = `:
val QUESTION = `?
val BACKTICK = `\|`|

defn matching-end (s:Symbol) :
   if s == OPEN-PAREN : CLOSE-PAREN
   else if s == STAR-PAREN : CLOSE-PAREN
   else if s == OPEN-BRACKET : CLOSE-BRACKET
   else if s == STAR-BRACKET : CLOSE-BRACKET
   else if s == OPEN-BRACE : CLOSE-BRACE
   else if s == STAR-BRACE : CLOSE-BRACE
   else if s == STAR-ANGLE : CLOSE-ANGLE
   else : fatal("No matching end")

defn group-all (s:Seq<Token>) -> List<Token> :
   ;Open shorthands
   defn shorthand (t:OpenToken, xs:List) :
      switch {symbol(t) == _} :
         OPEN-PAREN : xs
         OPEN-BRACE : cons(`@tuple, xs)
         OPEN-BRACKET : cons(`@afn, xs)
         STAR-PAREN : cons(`@do, xs)
         STAR-BRACE : cons(`@get, xs)
         STAR-BRACKET : cons(`@do-afn, xs)
         STAR-ANGLE : cons(`@of, xs)
         else : fatal("Invalid token: %_" % [t])
   ;Capture shorthand
   defn shorthand (t:CaptureToken) :
      List(`@cap, symbol(t))
   ;Quote shorthand
   defn shorthand (t:QuoteToken, x) :
      List(`@quote, x)

   ;Parse until ending token
   defn loop (open, open-info:False|FileInfo) -> List<Token> : ;TODO: Is it actually a list of tokens?
      ;No more tokens
      if empty?(s) :
         match(open) :
            (open:OpenToken) :
               throw(NoClosingToken(open-info as FileInfo, matching-end(symbol(open))))
            (open) :
               List()
      else :
         val x = peek(s)
         match(item(x), open) :
            ; ... x y z )
            (t:CloseToken, open:OpenToken) :
               next(s)
               List()
            ;(let :
            ;    a b) c d
            (t:CloseToken, open:Indentation) :
               List()
            ;(x y z ...
            (t:OpenToken, open) :
               next(s)
               val xs = loop(t, info(x))
               val h = Token(shorthand(t,xs), info(x))
               cons(h, loop(open, open-info))
            ;?x y ...
            (t:CaptureToken, open) :
               next(s)
               val h = Token(shorthand(t), info(x))
               cons(h, loop(open, open-info))
            ;` x y ...
            (t:QuoteToken, open) :
               next(s)
               val rest = loop(open, open-info)
               throw(NoQuotedValue(info(x))) when empty?(rest)
               val h = Token(shorthand(t, head(rest)), info(x))
               cons(h, tail(rest))
            ;x
            (t:Symbol, open) :
               next(s)
               if t == COLON :
                  match(item(peek(s))) :
                     ;line ending colon
                     (i:Indentation) :
                        val y = next(s)
                        val g = loop(i, open-info)
                        val h = Token(cons(y, g), info(y))
                        cons(x, h, loop(open, open-info))
                     ;normal colon
                     (t) :
                        cons(x, loop(open, open-info))
               else :
                  cons(x, loop(open, open-info))
            ;automatic indentation
            (t:Indentation, open:Indentation) :
               ;block ending indentation
               if indent(t) < indent(open) :
                  List()
               ;whitespace indentation
               else :
                  next(s)
                  loop(open, open-info)
            ;other tokens
            (t, open) :
               next(s)
               cons(x, loop(open, open-info))
   ;Driver
   loop(false, false)

;============================================================
;=================== Lexer Errors ===========================
;============================================================

deftype LexerException <: Exception
defn LexerException (s:String) :
   new LexerException :
      defmethod print (o:OutputStream, this) :
         print(o, s)

defn LexerExceptions (xs:Seqable<LexerException>) :
   LexerException(string-join(xs, "\n"))

defn NoClosingToken (info:FileInfo, end:Symbol) :
   LexerException $ string-join $
   [info ": No closing token found. Expecting " end "."]

defn InvalidNumber (info:FileInfo) :
   LexerException $ string-join $
   [info ": Invalid number."]

defn InvalidToken (info:FileInfo) :
   LexerException $ string-join $
   [info ": Invalid token."]

defn InvalidEscapeChar (info:FileInfo, c:Char) :
   LexerException $ string-join $
   [info ": Invalid escape character: " c "."]

defn UnclosedString (info:FileInfo) :
   LexerException $ string-join $
   [info ": Unclosed string. "]

defn UnclosedCharString (info:FileInfo) :
   LexerException $ string-join $
   [info ": Unclosed character. "]

defn UnclosedSymbol (info:FileInfo) :
   LexerException $ string-join $
   [info ": Unclosed symbol. "]

defn InvalidCharString (info:FileInfo) :
   LexerException $ string-join $
   [info ": Invalid character string. Must have length 1."]

defn WrongClosingToken (info:FileInfo, expected:Symbol, actual:Symbol) :
   LexerException $ string-join $
   [info ": Wrong closing parenthesis. Expecting " expected " but got " actual "."]

defn ExtraClosingToken (info:FileInfo, c:Symbol) :
   LexerException $ string-join $
   [info ": Extra closing token found: " c "."]

defn InvalidTag (info:FileInfo) :
   LexerException $ string-join $
   [info ": Invalid tag for here string."]

defn NoEndTagFound (info:FileInfo) :
   LexerException $ string-join $
   [info ": No ending tag found for here string."]

defn NoForm (info:FileInfo) :
   LexerException $ string-join $
   [info ": No forms left in stream."]

defn NoQuotedValue (info:FileInfo) :
   LexerException $ string-join $
   [info ": No s-expression following quote operator."]