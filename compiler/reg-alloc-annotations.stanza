defpackage stz/reg-alloc-annotations :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-engine
  import stz/reg-alloc-block-engine

;Annotate a block with save/load/context information.
;After each operation:
;  (V0) = op(V1, V2)
;This pass will insert the following annotations:
;  Save V0 - to indicate that V0 should be saved immediately.
;  Unload V0 - to indicate that V0's register should be released immediately.
;Operation statements will be replaced with:
;  AnnotatedOperationStmt which contains information about:
;    Which of the arguments are killed.
;    What registers we prefer the results to be in.

public defn annotate-block (e:BlockEngine) -> False :
  ;Record the save/load preferences of variables.
  val save-prefs = IntTable<SavePref>()
  val load-prefs = IntTable<LoadPref>()
  val liveset = IntSet()

  defn emit (stmt:ProgramStmt) :
    false

  ;Initialize based upon the output ports of the block.
  for p in outputs(e) do :
    val prefs = prefs(p) as PortPref
    add(liveset, id(p))
    save-prefs[id(p)] = save-pref(prefs)
    load-prefs[id(p)] = load-pref(prefs)

  ;Scan through the instructions in reverse.
  within (i, stmt) = instructions-in-reverse(e) :
    match(stmt) :
      (op:OperationStmt) :
        ;After result, 


        ;Remove statuses for this variable.
        ;Computed statuses no longer apply.
        for v in results(op) do :
          remove(liveset, v)
          remove(save-prefs, v)
          remove(load-prefs, v)
          
        ;If the operation clears all registers, then
        ;the live variables need to be saved, and the
        ;variables do not need to be loaded.
        if clears-registers?(e, op) :
          for v in liveset do :
            save-prefs[v] = PreferSave
            load-prefs[v] = PreferNoLoad

        ;All the arguments to the operation are now live,
        ;and they prefer to be loaded.
        for v in args(op) do :
          add(liveset, v)
          load-prefs[v] = PreferLoad

      (op) :
        ;Emit the instruction unchanged.
        emit(op)

  ;Write the calculated quantities to the block.
  ;val new-input-ports = to-tuple $ for p in inputs(b) seq :
  ;  val pref = PortPref(
  ;               get?(save-prefs, id(p), PreferNoSave)
  ;               get?(load-prefs, id(p), PreferNoLoad))
  ;  sub-prefs(p, pref)
  ;set-contents(inputs(b), new-input-ports)

      

;Call f on all the instructions in reverse.
defn instructions-in-reverse (f:(Int, ProgramStmt) -> ?,
                              e:BlockEngine) -> False :
  val indices = reverse(0 to length(instructions(e)))
  for i in indices do :
    f(i, instructions(e)[i])

;Helper: Return true if the given operation calls clear-registers.
defn clears-registers? (e:BlockEngine, op:OperationStmt) -> True|False :
  val props = model-properties(e)[op-id(op)]
  clears-registers?(props)