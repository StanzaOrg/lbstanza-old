defpackage stz/reg-alloc-annotations :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-model-env
  import stz/reg-alloc-block-stmt-processor
  import stz/reg-alloc-pref-scanner
  import stz/reg-alloc-model-properties

;Annotate a block with save/load/context information.
;After each operation:
;  (V0) = op(V1, V2)
;This pass will insert the following annotations for the results:
;  Save V0 - to indicate that V0 should be saved immediately.
;  Unload V0 - to indicate that V0's register should be released immediately.
;The following annotations will be inserted for the arguments:
;  Unload V1 - to indicate that V1 is still live but should be greedily
;              unloaded because we no longer require its value in a register.
;Operation statements will be replaced with:
;  AnnotatedOperationStmt which contains information about:
;    Which of the arguments are killed.
;    What registers we prefer the results to be in.
;    When will each of the results/args be next used.
;    How many registers are required to execute this operation.

;Here is the order of an OperationStmt, along with
;where the scan-defs and scan-args sequence fits into the sequence.
;
;Order of OperationStmt:
;
;  --- Scan Args ---
;
;  1) Arguments are Loaded
;
;  2) Operation Happens
;
;  3) Registers are Released
;
;  --- Scan Defs ---
;
;  4) Results are Stored

public defn annotate-block (proc:BlockStmtProcessor,
                            models:ModelEnv) -> False :
  ;Scan using a preference scanner.
  val pref-scanner = PrefScanner(models)

  ;State: Track the preferred registers for all the variables.
  val pref-regs = IntTable<Register>()

  ;Update preferred output registers based on successor ports.
  if not empty?(successor-ports(proc)) :
    val reg-table = IntTable<Register|False>(false)    
    defn merge (ra:Register|False, rb:Register|False) -> Register|False :
      match(ra, rb) :
        (ra:Register, rb) : ra
        (ra, rb:Register) : rb
        (ra, rb) : false
    for ports in successor-ports(proc) do :
      for port in ports do :
        update(reg-table, merge{reg-pref(prefs!(port)), _}, id(port))
    for port in proc update-outputs :
      sub-reg-pref(port, reg-table[id(port)])

  ;Initialize based upon the output ports of the block.
  scan-output-ports(pref-scanner, outputs(proc))

  ;Initialize the preferred registers based on output ports.
  for p in outputs(proc) do :
    match(reg-pref(p)) :
      (reg:Register) : pref-regs[id(p)] = reg
      (f:False) : false

  ;Scan through the instructions in reverse.
  within (i, stmt) = stmts-in-reverse(proc) :
    match(stmt) :
      (op:OperationStmt|SetStmt) :
        ;Greedily emit operations for processing the result variables
        ;as soon as they are created.
        ;Save the result if they prefer to be saved.
        ;Unload the result if they prefer to be unloaded or they are dead.
        for v in results(op) do :
          ensure-live-variable-saved-before-unload!(pref-scanner, v)
          val pref = preference(pref-scanner, v)
          if load-pref(pref) is PreferUnload :
            emit(proc, Unload(v))
          if save-pref(pref) is PreferSave :
            emit(proc, Save(v, vartype(proc,v)))

        ;Greedily emit operations for processing argument variables.
        ;Unload the argument if they are live but prefer to be unloaded.
        ;(Arguments that are dead are left to be processed using the
        ;killed-args annotation.)
        for v in args(op) do :
          ensure-live-variable-saved-before-unload!(pref-scanner, v)
          if next-usage(pref-scanner,v) is-not False :
            val pref = preference(pref-scanner, v)
            if load-pref(pref) is PreferUnload :
              emit(proc, Unload(v))

        ;Determine the preferred registers for results.
        val result-prefs = for v in results(op) map :
          get?(pref-regs, v)

        ;Determine the next usages of results and args.
        val result-uses = for v in results(op) map :
          next-usage(pref-scanner, v)
        val arg-uses = for v in args(op) map :
          next-usage(pref-scanner, v)
        
        ;Determine which args are killed.
        val killed-args = to-tuple $
          for (i in 0 to false, v in args(op)) filter :
            next-usage(pref-scanner, v) is False

        ;Compute the appropriate annotations for each type of statement.
        match(op) :
          ;OperationStmt needs to compute UsedRegisters.
          (op:OperationStmt) :

            ;Compute the used registers.
            val ctxt = UsageContext(killed-args)        
            val used-registers = used-registers(models, op-id(op), ctxt)

            ;Sanity check before updating preferred registers.
            if length(args(op)) != length(arg-prefs(used-registers)) :
              fatal("Number of arguments does not match number of argument preferences.")

            ;If the operation clears every register, then all of the
            ;preferred registers are gone.
            if clears-registers?(models, op-id(op)) :
              clear(pref-regs)

            ;Update the preferred registers for the argument variables.
            for (arg in args(op), pref in arg-prefs(used-registers)) do :
              match(pref) :
                ;Case: The argument prefers to be in the same register as one of the results.
                (pref:PreferSame) :              
                  ;Compute the preferred register of that result.
                  val result-index = id(pref)
                  val pref-reg = result-prefs[result-index]

                  ;If it's a specific register, then store it in the
                  ;pref-reg table, otherwise remove this entry from the
                  ;table.
                  match(pref-reg:Register) : pref-regs[arg] = pref-reg
                  else : remove(pref-regs, arg)
                  
                ;Case: The argument prefers to be in a specific register.
                (pref:PreferRegister) :
                  pref-regs[arg] = reg(pref)
                  
                ;Case: The argument has no preference which register it is in.
                (pref:NoPreference) :
                  remove(pref-regs, arg)

            ;Annotate the operation statement and emit.
            emit(proc,
                 AnnotatedOperationStmt(op, used-registers, killed-args,
                                        arg-uses, result-uses, result-prefs))

          ;SetStmt just needs updated preferences.
          (op:SetStmt) :

            ;Compute the used registers.
            val used-registers = used-registers(proc, op, killed-args)

            ;Update the preferred registers for the argument variables.
            for (arg in args(op), pref in result-prefs) do :
              ;The argument prefers to be in a specific register.                
              match(pref:Register) :
                pref-regs[arg] = pref
              ;The argument has no preference which register it is in.
              else :
                remove(pref-regs, arg)
                
            ;Annotate the set statement and emit.
            emit(proc,
                 AnnotatedSetStmt(op, used-registers, killed-args,
                                  arg-uses, result-uses, result-prefs))

        ;Scan using preference scanner to continue.
        scan-stmt(pref-scanner, i, op)

      (op) :
        ;Emit the instruction unchanged.
        emit(proc,op)

  ;The port preferences for input ports have already been
  ;annotated. Annotate the ports with their preferred registers.
  for p in proc update-inputs :
    val reg = get?(pref-regs, id(p))
    sub-reg-pref(p, reg)

;Helper: Compute the number of used registers used by a SetStatement.
defn used-registers (proc:BlockStmtProcessor,
                     op:SetStmt,
                     killed-args:Tuple<Int>) -> UsedRegisters :
  val count-arg-regs = to-seq(0 to false)
  val count-arg-fregs = to-seq(0 to false)
  val count-result-regs = to-seq(0 to false)
  val count-result-fregs = to-seq(0 to false)
  defn inc (t:RegisterType, reg-count:Seq<Int>, freg-count:Seq<Int>) :
    match(t) :
      (t:AnyReg) : next(reg-count)
      (t:AnyFReg) : next(freg-count)
  for i in killed-args do :
    val v = args(op)[i]
    inc(vartype(proc,v), count-arg-regs, count-arg-fregs)
  for v in results(op) do :
    inc(vartype(proc,v), count-result-regs, count-result-fregs)
  val used-regs = max(0, peek(count-result-regs) - peek(count-arg-regs))
  val used-fregs = max(0, peek(count-result-fregs) - peek(count-arg-fregs))
  UsedRegisters(used-regs, used-fregs, map(PreferSame, results(op)))

;Live variables should always be saved before unloaded.
;Ensure that the computed preference indicates this.
defn ensure-live-variable-saved-before-unload! (pref-scanner:PrefScanner,
                                                v:Int) -> False :
  #if-not-defined(OPTIMIZE) :
    if next-usage(pref-scanner, v) is-not False :
      val pref = preference(pref-scanner,v)
      if load-pref(pref) is PreferUnload and
         save-pref(pref) is NoPreferSave :
        fatal("Unexpected unload of live variable V%_ without save." % [v])  
  false

