defpackage stz/reg-alloc-annotations :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-engine
  import stz/reg-alloc-block-engine
  import stz/reg-alloc-pref-scanner
  import stz/reg-alloc-model-analysis

;Annotate a block with save/load/context information.
;After each operation:
;  (V0) = op(V1, V2)
;This pass will insert the following annotations:
;  Save V0 - to indicate that V0 should be saved immediately.
;  Unload V0 - to indicate that V0's register should be released immediately.
;Operation statements will be replaced with:
;  AnnotatedOperationStmt which contains information about:
;    Which of the arguments are killed.
;    What registers we prefer the results to be in.

public defn annotate-block (e:BlockEngine) -> False :
  ;Scan using a preference scanner.
  val pref-scanner = PrefScanner(model-properties(e))

  ;State: Track the preferred registers for all the variables.
  val pref-regs = IntTable<Reg|FReg>()

  ;Initialize based upon the output ports of the block.
  scan-output-ports(pref-scanner, outputs(e))

  ;Scan through the instructions in reverse.
  within (i, stmt) = instructions-in-reverse(e) :
    println("PROCESSING %_) %_" % [i, stmt])
    match(stmt) :
      (op:OperationStmt) :
        ;Determine the preferred registers for results.
        val result-prefs = for v in results(op) map :
          get?(pref-regs, v)
        println("result-prefs = %_" % [result-prefs])

        ;Determine the next usages of args and results.
        val result-uses = for v in results(op) map :
          next-usage(pref-scanner, v)
        val arg-uses = for v in args(op) map :
          next-usage(pref-scanner, v)
        println("result-uses = %_" % [result-uses])
        println("arg-uses = %_" % [arg-uses])
        
        ;Determine which args are killed.
        val killed-args = to-tuple $
          for (i in 0 to false, v in args(op)) filter :
            next-usage(pref-scanner, v) is False
        println("killed-args = %_" % [killed-args])

        ;Compute the used registers.
        ;[TODO]

        ;Update the preferred registers for the argument variables.

        ;Scan using preference scanner
        scan-stmt(pref-scanner, i, op)
        false

      (op) :
        ;Emit the instruction unchanged.
        false

;Call f on all the instructions in reverse.
defn instructions-in-reverse (f:(Int, ProgramStmt) -> ?,
                              e:BlockEngine) -> False :
  val indices = reverse(0 to length(instructions(e)))
  for i in indices do :
    f(i, instructions(e)[i])

;Helper: Return true if the given operation calls clear-registers.
defn clears-registers? (e:BlockEngine, op:OperationStmt) -> True|False :
  val props = model-properties(e)[op-id(op)]
  clears-registers?(props)