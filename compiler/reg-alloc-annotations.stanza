defpackage stz/reg-alloc-annotations :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-model-env
  import stz/reg-alloc-block-stmt-processor
  import stz/reg-alloc-pref-scanner
  import stz/reg-alloc-model-properties

;Annotate a block with save/load/context information.
;After each operation:
;  (V0) = op(V1, V2)
;This pass will insert the following annotations for the results:
;  Save V0 - to indicate that V0 should be saved immediately.
;  Unload V0 - to indicate that V0's register should be released immediately.
;The following annotations will be inserted for the arguments:
;  Unload V1 - to indicate that V1 is still live but should be greedily
;              unloaded because we no longer require its value in a register.
;Operation statements will be replaced with:
;  AnnotatedOperationStmt which contains information about:
;    Which of the arguments are killed.
;    What registers we prefer the results to be in.
;    When will each of the results/args be next used.
;    How many registers are required to execute this operation.

;Here is the order of an OperationStmt, along with
;where the scan-defs and scan-args sequence fits into the sequence.
;
;Order of OperationStmt:
;
;  --- Scan Args ---
;
;  1) Arguments are Loaded
;
;  2) Operation Happens
;
;  3) Registers are Released
;
;  --- Scan Defs ---
;
;  4) Results are Stored

public defn annotate-block (proc:BlockStmtProcessor,
                            models:ModelEnv) -> False :
  ;Scan using a preference scanner.
  val pref-scanner = PrefScanner(models)

  ;State: Track the preferred registers for all the variables.
  val pref-regs = IntTable<Register>()

  ;Initialize based upon the output ports of the block.
  scan-output-ports(pref-scanner, outputs(proc))

  ;Initialize the preferred registers based on output ports.
  for p in outputs(proc) do :
    match(reg-pref(p)) :
      (reg:Register) : pref-regs[id(p)] = reg
      (f:False) : false

  ;Scan through the instructions in reverse.
  within (i, stmt) = stmts-in-reverse(proc) :
    match(stmt) :
      (op:OperationStmt) :
        ;Greedily emit operations for processing the result variables
        ;as soon as they are created.
        ;Save the result if they prefer to be saved.
        ;Unload the result if they prefer to be unloaded or they are dead.
        for v in results(op) do :
          ensure-live-variable-saved-before-unload!(pref-scanner, v)
          val pref = preference(pref-scanner, v)
          if load-pref(pref) is PreferUnload :
            emit(proc, Unload(v))
          if save-pref(pref) is PreferSave :
            emit(proc, Save(v, type(vars(proc)[v])))

        ;Determine the preferred registers for results.
        val result-prefs = for v in results(op) map :
          get?(pref-regs, v)

        ;Determine the next usages of results.
        val result-uses = for v in results(op) map :
          next-usage(pref-scanner, v)

        ;Scan the defs section of the operation.
        scan-defs(pref-scanner, i, op)

        ;Greedily emit operations for processing argument variables.
        ;Unload the argument if they are live but prefer to be unloaded.
        ;(Arguments that are dead are left to be processed using the
        ;killed-args annotation.)
        for v in args(op) do :
          ensure-live-variable-saved-before-unload!(pref-scanner, v)
          if next-usage(pref-scanner,v) is-not False :
            val pref = preference(pref-scanner, v)
            if load-pref(pref) is PreferUnload :
              emit(proc, Unload(v))

        ;Determine the next usages of args and results.
        val arg-uses = for v in args(op) map :
          next-usage(pref-scanner, v)
        
        ;Determine which args are killed.
        val killed-args = to-tuple $
          for (i in 0 to false, v in args(op)) filter :
            next-usage(pref-scanner, v) is False

        ;Compute the used registers.
        val ctxt = UsageContext(killed-args)        
        val used-registers = used-registers(models, op-id(op), ctxt)

        ;Sanity check before updating preferred registers.
        if length(args(op)) != length(arg-prefs(used-registers)) :
          fatal("Number of arguments does not match number of argument preferences.")

        ;If the operation clears every register, then all of the
        ;preferred registers are gone.
        if clears-registers?(models, op-id(op)) :
          clear(pref-regs)

        ;Update the preferred registers for the argument variables.
        for (arg in args(op), pref in arg-prefs(used-registers)) do :
          match(pref) :
            ;Case: The argument prefers to be in the same register as one of the results.
            (pref:PreferSame) :              
              ;Compute the preferred register of that result.
              val result-index = id(pref)
              val pref-reg = result-prefs[result-index]

              ;If it's a specific register, then store it in the
              ;pref-reg table, otherwise remove this entry from the
              ;table.
              match(pref-reg:Register) : pref-regs[arg] = pref-reg
              else : remove(pref-regs, arg)
              
            ;Case: The argument prefers to be in a specific register.
            (pref:PreferRegister) :
              pref-regs[arg] = reg(pref)
              
            ;Case: The argument has no preference which register it is in.
            (pref:NoPreference) :
              remove(pref-regs, arg)

        ;Annotate the operation statement and emit.
        emit(proc,
             AnnotatedOperationStmt(op, used-registers, killed-args,
                                    arg-uses, result-uses, result-prefs))

        ;Scan using preference scanner to continue.
        scan-args(pref-scanner, i, op)

      (op) :
        ;Emit the instruction unchanged.
        emit(proc,op)

  ;The port preferences for input ports have already been
  ;annotated. Annotate the ports with their preferred registers.
  for p in proc update-inputs :
    val reg = get?(pref-regs, id(p))
    sub-reg-pref(p, reg)

;Live variables should always be saved before unloaded.
;Ensure that the computed preference indicates this.
defn ensure-live-variable-saved-before-unload! (pref-scanner:PrefScanner,
                                                v:Int) -> False :
  #if-not-defined(OPTIMIZE) :
    if next-usage(pref-scanner, v) is-not False :
      val pref = preference(pref-scanner,v)
      if load-pref(pref) is PreferUnload and
         save-pref(pref) is NoPreferSave :
        fatal("Unexpected unload of live variable V%_ without save." % [v])  
  false

