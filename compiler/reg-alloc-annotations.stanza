defpackage stz/reg-alloc-annotations :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-engine
  import stz/reg-alloc-block-engine
  import stz/reg-alloc-pref-scanner
  import stz/reg-alloc-model-analysis

;Annotate a block with save/load/context information.
;After each operation:
;  (V0) = op(V1, V2)
;This pass will insert the following annotations for the results:
;  Save V0 - to indicate that V0 should be saved immediately.
;  Unload V0 - to indicate that V0's register should be released immediately.
;The following annotations will be inserted for the arguments:
;  Unload V1 - to indicate that V1 is still live but should be greedily
;              unloaded because we no longer require its value in a register.
;Operation statements will be replaced with:
;  AnnotatedOperationStmt which contains information about:
;    Which of the arguments are killed.
;    What registers we prefer the results to be in.
;    When will each of the results/args be next used.
;    How many registers are required to execute this operation.

;Here is the order of an OperationStmt, along with
;where the scan-defs and scan-args sequence fits into the sequence.
;
;Order of OperationStmt:
;
;  --- Scan Args ---
;
;  1) Arguments are Loaded
;
;  2) Operation Happens
;
;  3) Registers are Released
;
;  --- Scan Defs ---
;
;  4) Results are Stored

public defn annotate-block (e:BlockEngine) -> False :
  ;Scan using a preference scanner.
  val pref-scanner = PrefScanner(model-properties(e))

  ;State: Track the preferred registers for all the variables.
  val pref-regs = IntTable<Register>()

  ;Initialize based upon the output ports of the block.
  scan-output-ports(pref-scanner, outputs(e))

  ;Initialize the preferred registers based on output ports.
  for p in outputs(e) do :
    match(reg-pref(p)) :
      (reg:Register) : pref-regs[id(p)] = reg
      (f:False) : false

  ;Scan through the instructions in reverse.
  within (i, stmt, emit) = process-instructions-in-reverse(e) :
    match(stmt) :
      (op:OperationStmt) :
        ;Greedily emit operations for processing the result variables
        ;as soon as they are created.
        ;Save the result if they prefer to be saved.
        ;Unload the result if they prefer to be unloaded or they are dead.
        for v in results(op) do :
          ;Emit unload if result is dead.
          if next-usage(pref-scanner, v) is False :
            emit(Unload(v))
          ;Otherwise:
          ;- If we do not prefer for it to be loaded then:
          ;  Emit unload unless it is unsafe to do so.
          ;  It is unsafe to do so, if the variable is unsaved, and
          ;  there's no preference to save it.
          ;- If we prefer for the variable to be saved, then
          ;  save it.
          else :
            val pref = preference(pref-scanner, v)
            ;Emit unload if result prefers to be saved
            ;instead of loaded.
            if load-pref(pref) is PreferNoLoad and
               save-pref(pref) == PreferSave :
              emit(Unload(v))
            ;Emit save if result prefers to be saved.
            if save-pref(pref) == PreferSave :
              emit(Save(v))

        ;Determine the preferred registers for results.
        val result-prefs = for v in results(op) map :
          get?(pref-regs, v)

        ;Determine the next usages of results.
        val result-uses = for v in results(op) map :
          next-usage(pref-scanner, v)

        ;Scan the defs section of the operation.
        scan-defs(pref-scanner, i, op)

        ;Greedily emit operations for processing argument variables.
        ;Unload the argument if they are live but prefer to be unloaded.
        ;(Arguments that are dead are left to be processed using the
        ;killed-args annotation.)
        for v in args(op) do :
          if next-usage(pref-scanner,v) is-not False :
            val pref = preference(pref-scanner, v)
            ;Emit unload if result prefers to be unloaded
            ;instead of saved.
            if load-pref(pref) is PreferNoLoad and
               save-pref(pref) == PreferSave :
              emit(Unload(v))

        ;Determine the next usages of args and results.
        val arg-uses = for v in args(op) map :
          next-usage(pref-scanner, v)
        
        ;Determine which args are killed.
        val killed-args = to-tuple $
          for (i in 0 to false, v in args(op)) filter :
            next-usage(pref-scanner, v) is False

        ;Compute the used registers.
        val args-tuple = to-tuple(0 to length(args(op)))
        val ctxt = UsageContext(args-tuple, killed-args)        
        val used-registers = used-registers(model-analyzer(e), op-id(op), ctxt)

        ;Sanity check before updating preferred registers.
        if length(args(op)) != length(arg-prefs(used-registers)) :
          fatal("Number of arguments does not match number of argument preferences.")
        if length(results(op)) != length(results(used-registers)) :
          fatal("Number of results does not match number of result locations.")

        ;If the operation clears every register, then all of the
        ;preferred registers are gone.
        if clears-registers?(e, op) :
          clear(pref-regs)

        ;Update the preferred registers for the argument variables.
        for (arg in args(op), pref in arg-prefs(used-registers)) do :
          match(pref) :
            ;Case: The argument prefers to be in the same register as one of the results.
            (pref:PreferSame) :              
              ;Compute which that register should be:
              ;- result-index: The index of the result.
              ;- result-var: The result variable.
              ;- result-reg: The register that the operation puts the result in.
              ;- pref-reg: The preferred register where the downstream code wants the result.
              ;- pref-arg-reg: The register that the argument prefers to be in.
              val result-index = /arg(pref)
              val result-var = results(op)[result-index]
              val result-reg = results(used-registers)[result-index]
              val pref-reg = get?(pref-regs, result-var)
              val pref-arg-reg = max-specificity(result-reg, pref-reg)

              ;If the argument prefers to be in a specific register, then store
              ;it in the pref-reg table, otherwise remove this entry from the table.              
              match(pref-arg-reg:Reg|FReg) : pref-regs[arg] = pref-arg-reg
              else : remove(pref-regs, arg)
              
            ;Case: The argument prefers to be in a specific register.
            (pref:PreferRegister) :
              pref-regs[arg] = reg(pref)
              
            ;Case: The argument has no preference which register it is in.
            (pref:NoPreference) :
              remove(pref-regs, arg)

        ;Annotate the operation statement and emit.
        emit $ AnnotatedOperationStmt(op, used-registers, killed-args,
                                      result-prefs, arg-uses, result-uses)

        ;Scan using preference scanner to continue.
        scan-args(pref-scanner, i, op)

      (op) :
        ;Emit the instruction unchanged.
        emit(op)

  ;The port preferences for input ports have already been
  ;annotated. Annotate the ports with their preferred registers.
  val new-input-ports = for p in inputs(e) map<Port> :
    val reg = get?(pref-regs, id(p))
    sub-pref-reg(p, reg)
  set-contents(inputs(e), new-input-ports)

;Helper: Return a if a is already a specific register,
;otherwise return b. Used for calculating the actual/preferred register
;for the result of an operation.
defn max-specificity (a:Location, b:Reg|FReg|False) -> Reg|FReg|False :
  match(a) :
    (a:Reg|FReg) : a
    (a) : b

;Helper: Return true if the given operation calls clear-registers.
defn clears-registers? (e:BlockEngine, op:OperationStmt) -> True|False :
  val props = model-properties(e)[op-id(op)]
  clears-registers?(props)

;Helper: Set the contents of the given vector.
defn set-contents<?T> (vs:Vector<?T>, xs:Seqable<T>) :
  clear(vs)
  add-all(vs,xs)      