defpackage stz/tgt :
   import core
   import verse
   import stz/ids
   import stz/utils
   import stz/tgt-ir
   import stz/bb with :
      prefix => bb-
   import stz/asm-ir with :
      prefix => asm-
   import stz/asm-emitter with :
      prefix => asm-
   import stz/backend   
         

;                     Call Lowering
;                     =============

defn spill-call-args (def:DefFn, backend:Backend) :
   ;     Type Layer
   ;     ----------
   val int-values = HashTable<Int,True|False>({_})
   for d in defs(def) do :
      int-values[n(d)] = int?(type(d))

   defn int? (x:Imm) :
      match(x) :
         (x:Var) : int-values[n(x)]
         (x) : true
      
   ;     Output State
   ;     ------------
   val output = Vector<Ins>()
   val defvars = Vector<DefVar>()
   do(add{defvars, _}, defs(def))
   defn emit (i:Ins) :
      add(output, i)
   defn make-var (t:TgtType) :
      val n = fresh-id()
      add(defvars, DefVar(n, t))
      Var(n)

   ;     Split Locations
   ;     ---------------
   ;Split a group of values into which go into memory, and which go
   ;into registers.
   defn split-mem-locs<?T> (xs:List<?T&Imm>, nregs:Int, nfregs:Int) :
      defn cms (xs) : join(xs, ", ")
      val regs = to-stream(0 to nregs)
      val fregs = to-stream(0 to nfregs)
      val reg-xs = Vector<T&Imm>()
      val mem-xs = Vector<T&Imm>()
      for x in xs do :
         if int?(x) :
            if more?(regs) :
               next(regs)
               add(reg-xs, x)
            else :
               add(mem-xs, x)
         else :
            if more?(fregs) :
               next(fregs)
               add(reg-xs, x)
            else :
               add(mem-xs, x)
      [to-list(reg-xs), to-list(mem-xs)]
   defn split-call-locs<?T> (xs:List<?T&Imm>) :
      split-mem-locs(xs, length(call-regs(backend)), length(call-fregs(backend)))
   defn split-callc-locs<?T> (xs:List<?T&Imm>) :
      split-mem-locs(xs, length(callc-regs(backend)), length(callc-fregs(backend)))

   ;     Main Algorithm
   ;     --------------
   ;Convert calls
   for e in body(def) do :
      match(e) :
         (e:ArgsIns) :
            val [xs, mxs] = split-call-locs(xs(e))
            emit(ArgsIns(xs))
            for (x in mxs, o in 0 to false by 8) do :
               emit(Load(x, Mem(ARG-LBL,0), o))
         (e:Return) :
            val [xs, mxs] = split-call-locs(xs(e))
            for (x in mxs, o in 0 to false by 8) do :
               emit(Store(x, Mem(ARG-LBL,0), o))
            emit(Return(xs))   
         (e:Call) :
            val [ys, mys] = split-call-locs(ys(e))
            val [xs, mxs] = split-call-locs(xs(e))
            for (y in mys, o in 0 to false by 8) do :
               emit(Store(Mem(ARG-LBL,0), y, o))
            emit(Call(arity(e), xs, f(e), ys))
            for (x in mxs, o in 0 to false by 8) do :
               emit(Load(x, Mem(ARG-LBL,0), o))
         (e:TCall) :
            val [ys, mys] = split-call-locs(ys(e))
            for (y in mys, o in 0 to false by 8) do :
               emit(Store(Mem(ARG-LBL,0), y, o))
            emit(TCall(arity(e), f(e), ys))            
         (e:CallC) :
            val [ys, mys] = split-callc-locs(ys(e))
            if empty?(mys) :
               emit(CallC(1, xs(e), f(e), ys))
            else :
               val n = if length(mys) % 2 == 0 : length(mys) + 1
                       else : length(mys)
               val p = make-var(LONG-TYPE)
               emit(Load(p, Mem(C-RSP-LBL,0), 0))
               for (y in mys, i in 0 to false) do :
                  emit(Store(p, y, 8 * (i - n)))
               emit(CallC(n, xs(e), f(e), ys))
         (e) :
            emit(e)

   ;Return result   
   DefFn(n(def), defvars, output)
   


;                          Compilation
;                          ===========

;x86-64 Register Mapping
;%rax: R0
;%rbx: R1
;%rcx: R2
;%rdx: R3
;%rsi: R4
;%rdi: R5
;%rbp: R6
;%r8: R7
;%r9: R8
;%r10: R9
;%r11: R10
;%r12: R11
;%r13: R12
;%r14: R13
;%r15: R14

public defn compile (p:Program, filename:String) :
   ;     Parameters
   ;     ----------
   val backend = X86Backend()
   
   ;     Output State
   ;     ------------
   val output = Vector<asm-Ins>()
   defn emit (i:asm-Ins) : add(output, i)

   ;     Helper Functions
   ;     ----------------
   val LT = asm-LONG-TYPE
   defn mem (n:Int) : asm-Mem(n,0)
   defn int (v:Int) : asm-IntImm(v)
   
   val RSP = asm-RegSP()
   val R0 = asm-Reg(0)
   val R1 = asm-Reg(1)
   val R2 = asm-Reg(2)
   val R3 = asm-Reg(3)
   val R4 = asm-Reg(4)
   val R5 = asm-Reg(5)
   val R6 = asm-Reg(6)
   val R7 = asm-Reg(7)
   val R8 = asm-Reg(8)
   val R9 = asm-Reg(9)
   val R10 = asm-Reg(10)
   val R11 = asm-Reg(11)
   val R12 = asm-Reg(12)
   val R13 = asm-Reg(13)
   val R14 = asm-Reg(14)
   val R15 = asm-Reg(15)
   
   defn store-op (x:asm-Imm, y:asm-Imm) :
      emit(asm-Store(LT, x, y, 0))
   defn load-op (x:asm-Loc, y:asm-Imm) :
      emit(asm-Load(LT, x, y, 0))
   defn add-op (x:asm-Loc, y:asm-Imm, z:asm-Imm) :
      emit(asm-BinOp(LT, x, asm-ADD-OP, y, z))
   defn set-op (x:asm-Loc, y:asm-Imm) :
      emit(asm-SetIns(LT, x, y))
   defn call-op (x:asm-Imm) :
      emit(asm-Call(x))
   defn return-op () :
      emit(asm-Return())

   ;     Reserved Space
   ;     --------------
   let :
      emit(asm-DefData())
      emit(asm-Label(ARG-LBL))
      emit(asm-DefSpace(256 * 8))
      emit(asm-Label(SWAP-LBL))
      emit(asm-DefLong(0))
      emit(asm-DefText())

   ;     Entry Function
   ;     --------------
   let :      
      ;Stored C Parameters
      defn deflong (lbl:Int) :
         emit(asm-Label(lbl))
         emit(asm-DefLong(0))
         
      emit(asm-DefData())
      deflong(C-RSP-LBL)
      deflong(C-RBX-LBL)
      deflong(C-RBP-LBL)
      deflong(C-R12-LBL)
      deflong(C-R13-LBL)
      deflong(C-R14-LBL)
      deflong(C-R15-LBL)
      emit(asm-DefText())

      ;System Parameters
      emit(asm-ExLabel(`_stanza_stack_size))
      emit(asm-DefLong(STACK-SIZE))

      ;Entry Function
      emit(asm-ExLabel(`_stanza_entry))
      
      ;Save C Parameters
      store-op(mem(C-RSP-LBL), RSP)
      store-op(mem(C-RBX-LBL), R1)
      store-op(mem(C-RBP-LBL), R6)
      store-op(mem(C-R12-LBL), R11)
      store-op(mem(C-R13-LBL), R12)
      store-op(mem(C-R14-LBL), R13)
      store-op(mem(C-R15-LBL), R14)

      ;Set passed stack pointer as initial stack
      add-op(R0, R5, int(REF-TAG-BITS))
      store-op(mem(STACK-LBL), R0)
      ;Set stack limit
      add-op(R0, R5, int(STACK-SIZE))
      store-op(mem(STACK-LIM-LBL), R0)
      ;Set RSP to passed stack pointer
      add-op(RSP, R5, int(STACK-ITEMS-OFFSET + 8))
      ;Call entry
      call-op(mem(entry(p)))

      ;Transfer return result to C
      set-op(R0, R2)

      ;Restore C parameters
      load-op(RSP, mem(C-RSP-LBL))
      load-op(R1, mem(C-RBX-LBL))
      load-op(R6, mem(C-RBP-LBL))
      load-op(R11, mem(C-R12-LBL))
      load-op(R12, mem(C-R13-LBL))
      load-op(R13, mem(C-R14-LBL))
      load-op(R14, mem(C-R15-LBL))

      ;Return
      return-op()

   ;     Stack Retraction
   ;     ----------------
   ;let :
   ;   emit(asm-Label(RETRACT-STACK-ID))
   ;   
   ;   ;1. Increment number of free stacks        ;DEBUG: Is R0 used for anything? (e.g. arity?)
   ;   load-op(R0, mem(NUM-FREE-STACKS-LBL))
   ;   sub-op(R0, R0, int(1))
   ;   store-op(mem(NUM-FREE-STACKS-LBL), R0)
   ;   
   ;   ;2. (flip flop)
   ;   stack-pool -= 8
   ;   val swap = [stack-pool]
   ;   swap: stack-list[swap.index] stack-list[stk.index]
   ;   swap: swap.index stk.index
   ;
   ;   ;3. update the current stack and limits
   ;   ;update stack register
   ;   val p = stk.parent
   ;   rsp = p.sp
   ;   ;update stack limit and current stack
   ;   stack-limit = p + stack-size
   ;   stack = p
   ;   
   ;   ;4.return
   ;   return

   ;     Compile all constructs
   ;     ----------------------
   for i in ins(p) do :
      match(i) :
         ;Compile a function
         (i:DefFn) :
            headline("Spill Call Args")
            val i2 = spill-call-args(i, backend)
            println(i2)
            
            emit(asm-Label(n(i2)))
            bb-compile(i2, backend, output)
         ;Compile other constructs   
         (i:DefData) : emit(asm-DefData())
         (i:DefText) : emit(asm-DefText())
         (i:DefByte) : emit(asm-DefByte(value(i)))
         (i:DefInt) : emit(asm-DefInt(value(i)))
         (i:DefLong) : emit(asm-DefLong(value(i)))
         (i:DefFloat) : emit(asm-DefFloat(value(i)))
         (i:DefDouble) : emit(asm-DefDouble(value(i)))
         (i:DefString) : emit(asm-DefString(value(i)))
         (i:DefSpace) : emit(asm-DefSpace(size(i)))
         (i:DefLabel) : emit(asm-DefLabel(n(i)))
         (i:TLabel) : emit(asm-Label(n(i)))

   println("Compiled:")
   do(println, output)   

   ;     ;Emit output to file
   ;     -------------------
   with-output-file(filename, asm-emit{output})