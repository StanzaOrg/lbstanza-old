#include<"core/stringeater.stanza">
#include<"compiler/stz-algorithms.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">
#include("compiler/stz-utils.stanza")
#include("compiler/stz-tgt-ir.stanza")
#include("compiler/stz-bb-ir.stanza")
#include("compiler/stz-bb.stanza")
#include("compiler/stz-asm-ir.stanza")
#include("compiler/stz-asm-emitter.stanza")
#include("compiler/stz-padder.stanza")


defpackage stz/tgt :
   import core
   import verse
   import stz/lexer
   import stz/utils   
   import stz/tgt-ir
   import stz/bb with :
      prefix => bb-
   import stz/asm-ir with :
      prefix => asm-
   import stz/asm-emitter with :
      prefix => asm-

;                        Special Labels
;                        ==============

;C Parameter Labels
public val C-RSP-LBL = fresh-id()
public val C-RBX-LBL = fresh-id()
public val C-RBP-LBL = fresh-id()
public val C-R12-LBL = fresh-id()
public val C-R13-LBL = fresh-id()
public val C-R14-LBL = fresh-id()
public val C-R15-LBL = fresh-id()

;Argument Label
public val ARG-LBL = fresh-id()

;Swap Label
public val SWAP-LBL = fresh-id()

;Stack Labels
public val STACK-PTR-LBL = fresh-id()
public val STACK-LIM-LBL = fresh-id()


;                            Parser
;                            ======

defsyntax tgt-ir :
   val ut = unwrap-token

   val sym-table = HashTable<Symbol,Int>(symbol-hash)
   defn sym-num (x:Symbol) :
      match(get?(sym-table, x, false)) :
         (n:Int) :
            n
         (f:False) :
            val n = fresh-id()
            sym-table[x] = n
            n         

   defrule :
      sym = (?x) when ut(x) typeof Symbol : ut(x)
      int = (?x) when ut(x) typeof Int : ut(x)

      imm = (int(?n:#int)) : IntImm(n)
      imm = (mem<?x:#sym>) : Mem(sym-num(x))
      imm = (?x:#sym) : Var(sym-num(x))

      op = (add) : ADD-OP
      op = (sub) : SUB-OP
      op = (mul) : MUL-OP
      op = (div) : DIV-OP
      op = (mod) : MOD-OP
      op = (and) : AND-OP
      op = (or) : OR-OP
      op = (xor) : XOR-OP
      op = (shl) : SHL-OP
      op = (shr) : SHR-OP
      op = (ashr) : ASHR-OP
      op = (eq) : EQ-OP
      op = (ne) : NE-OP
      op = (lt) : LT-OP
      op = (gt) : GT-OP
      op = (le) : LE-OP
      op = (ge) : GE-OP
      op = (ule) : ULE-OP
      op = (ult) : ULT-OP
      op = (ugt) : UGT-OP
      op = (uge) : UGE-OP

      ins = (?x:#imm = ?op:#op(?y:#imm, ?z:#imm)) : BinOp(x, op, y, z)
      ins = ((?xs:#imm ...) = Args) : ArgsIns(xs)
      ins = ((?xs:#imm ...) = callc ?f:#imm(?ys:#imm ...)) : CallC(0, xs, f, ys)
      ins = ((?xs:#imm ...) = ?f:#imm(?ys:#imm ...) / ?n:#int) : Call(n, xs, f, ys)
      ins = ((?xs:#imm ...) = ?f:#imm(?ys:#imm ...)) : Call(length(ys), xs, f, ys)
      ins = (?x:#imm = ?y:#imm) : SetIns(x, y)
      ins = (return (?xs:#imm ...)) : Return(xs)
      ins = (label<?n:#sym>) : Label(sym-num(n))
      ins = (goto label<?n:#sym>) : Goto(sym-num(n))
      ins = (branch label<?n:#sym> when ?op:#op(?x:#imm, ?y:#imm)) : Branch(sym-num(n), op, x, y)

      type = (byte) : BYTE-TYPE
      type = (int) : INT-TYPE
      type = (long) : LONG-TYPE
      type = (float) : FLOAT-TYPE
      type = (double) : DOUBLE-TYPE
      type = (ref) : REF-TYPE

      defvar = (?x:#sym : ?t:#type) : DefVar(sym-num(x), t)

      defins = (defn ?f:#sym :
                   locals: (?locals:#defvar ...)
                   ?body:#ins ...) :
         DefFn(sym-num(f), to-vector(locals), to-vector(body))

      program = (program(?e:#sym) :
                    ?ins:#defins ...) :
         Program(to-vector(ins), sym-num(e))


defn parse-tgt-ir (file:String) :
   val lexed = lex-file(file)
   with-syntax(tgt-ir) :
      match-syntax(lexed) :
         (?p:#program) : p
         

;                     Call Lowering
;                     =============

defn spill-call-args (def:DefFn) :
   ;     Type Layer
   ;     ----------
   val int-values = HashTable<Int,True|False>({_})
   for d in defs(def) do :
      int-values[n(d)] = int?(type(d))

   defn int? (x:Imm) :
      match(x) :
         (x:Var) : int-values[n(x)]
         (x) : true
      
   ;     Output State
   ;     ------------
   val output = Vector<Ins>()
   val defvars = Vector<DefVar>()
   do(add{defvars, _}, defs(def))
   defn emit (i:Ins) :
      add(output, i)
   defn make-var (t:TgtType) :
      val n = fresh-id()
      add(defvars, DefVar(n, t))
      Var(n)

   ;     Split Locations
   ;     ---------------
   ;Split a group of values into which go into memory, and which go
   ;into registers.
   defn split-mem-locs<?T> (xs:List<?T&Imm>, nregs:Int, nfregs:Int) :
      val regs = to-stream(0 to nregs)
      val fregs = to-stream(0 to nfregs)
      val reg-xs = Vector<T&Imm>()
      val mem-xs = Vector<T&Imm>()
      for x in xs filter :
         if int?(x) :
            if more?(regs) :
               next(regs)
               add(reg-xs, x)
            else :
               add(mem-xs, x)
         else :
            if more?(fregs) :
               next(fregs)
               add(reg-xs, x)
            else :
               add(mem-xs, x)
      [to-list(reg-xs), to-list(mem-xs)]
   defn split-call-locs<?T> (xs:List<?T&Imm>) :
      split-mem-locs(xs, 8 - 2, 8)
   defn split-callc-locs<?T> (xs:List<?T&Imm>) :
      split-mem-locs(xs, 6, 8)

   ;     Main Algorithm
   ;     --------------
   ;Convert calls
   for e in body(def) do :
      match(e) :
         (e:ArgsIns) :
            val [xs, mxs] = split-call-locs(xs(e))
            emit(ArgsIns(xs))
            for (x in mxs, o in 0 to false by 8) do :
               emit(Load(x, Mem(ARG-LBL), o))
         (e:Return) :
            val [xs, mxs] = split-call-locs(xs(e))
            for (x in mxs, o in 0 to false by 8) do :
               emit(Store(x, Mem(ARG-LBL), o))
            emit(Return(xs))   
         (e:Call) :
            val [ys, mys] = split-call-locs(ys(e))
            val [xs, mxs] = split-call-locs(xs(e))
            for (y in mys, o in 0 to false by 8) do :
               emit(Store(Mem(ARG-LBL), y, o))
            emit(Call(arity(e), xs, f(e), ys))
            for (x in mxs, o in 0 to false by 8) do :
               emit(Load(x, Mem(ARG-LBL), o))
         (e:TCall) :
            val [ys, mys] = split-call-locs(ys(e))
            for (y in mys, o in 0 to false by 8) do :
               emit(Store(Mem(ARG-LBL), y, o))
            emit(TCall(arity(e), f(e), ys))            
         (e:CallC) :
            val [ys, mys] = split-callc-locs(ys(e))
            val [xs, mxs] = split-callc-locs(xs(e))
            val n = if length(mys) % 2 == 0 : length(mys) + 1
                    else : length(mys)
            val p = make-var(LONG-TYPE)
            Load(p, Mem(C-RSP-LBL), 0)
            for (y in mys, i in 0 to false) do :
               emit(Store(p, y, 8 * (i - n)))
            emit(CallC(n, xs, f(e), ys))
         (e) :
            emit(e)

   ;Return result   
   DefFn(n(def), defvars, output)
   


;                          Compilation
;                          ===========

;x86-64 Register Mapping
;%rax: R0
;%rbx: R1
;%rcx: R2
;%rdx: R3
;%rsi: R4
;%rdi: R5
;%rbp: R6
;%r8: R7
;%r9: R8
;%r10: R9
;%r11: R10
;%r12: R11
;%r13: R12
;%r14: R13
;%r15: R14

defn compile (p:Program, filename:String) :
   ;     Output State
   ;     ------------
   val output = Vector<asm-Ins>()
   defn emit (i:asm-Ins) : add(output, i)


   ;     Entry Function
   ;     --------------
   let :      
      ;Stored C Parameters
      defn deflong (lbl:Int) :
         emit(asm-Label(lbl))
         emit(asm-DefLong(0))
      emit(asm-DefData())
      deflong(C-RSP-LBL)
      deflong(C-RBX-LBL)
      deflong(C-RBP-LBL)
      deflong(C-R12-LBL)
      deflong(C-R13-LBL)
      deflong(C-R14-LBL)
      deflong(C-R15-LBL)
      emit(asm-DefText())

      ;Entry Function
      emit(asm-ExLabel(`_stanza_entry))
      
      ;Save C Parameters
      val LT = asm-LONG-TYPE
      emit(asm-Store(LT, asm-Mem(C-RSP-LBL), asm-RegSP(), 0))
      emit(asm-Store(LT, asm-Mem(C-RBX-LBL), asm-Reg(1), 0))
      emit(asm-Store(LT, asm-Mem(C-RBP-LBL), asm-Reg(6), 0))
      emit(asm-Store(LT, asm-Mem(C-R12-LBL), asm-Reg(11), 0))
      emit(asm-Store(LT, asm-Mem(C-R13-LBL), asm-Reg(12), 0))
      emit(asm-Store(LT, asm-Mem(C-R14-LBL), asm-Reg(13), 0))
      emit(asm-Store(LT, asm-Mem(C-R15-LBL), asm-Reg(14), 0))

      ;Set RSP to passed stack pointer, and call entry
      emit(asm-SetIns(LT, asm-RegSP(), asm-Reg(5)))
      emit(asm-BinOp(LT, asm-RegSP(), asm-ADD-OP, asm-RegSP(), asm-IntImm(8)))
      emit(asm-Call(asm-Mem(entry(p))))

      ;Transfer return result to C
      emit(asm-SetIns(LT, asm-Reg(0), asm-Reg(2)))

      ;Restore C parameters
      emit(asm-Load(LT, asm-RegSP(), asm-Mem(C-RSP-LBL), 0))
      emit(asm-Load(LT, asm-Reg(1), asm-Mem(C-RBX-LBL), 0))
      emit(asm-Load(LT, asm-Reg(6), asm-Mem(C-RBP-LBL), 0))
      emit(asm-Load(LT, asm-Reg(11), asm-Mem(C-R12-LBL), 0))
      emit(asm-Load(LT, asm-Reg(12), asm-Mem(C-R13-LBL), 0))
      emit(asm-Load(LT, asm-Reg(13), asm-Mem(C-R14-LBL), 0))
      emit(asm-Load(LT, asm-Reg(14), asm-Mem(C-R15-LBL), 0))

      ;Return      
      emit(asm-Return())   


   ;     Reserved Space
   ;     --------------
   let :
      emit(asm-DefData())
      emit(asm-Label(ARG-LBL))
      emit(asm-DefSpace(256 * 8))
      emit(asm-Label(SWAP-LBL))
      emit(asm-DefLong(0))
      emit(asm-Label(STACK-PTR-LBL))
      emit(asm-DefLong(0))
      emit(asm-Label(STACK-LIM-LBL))
      emit(asm-DefLong(0))
      emit(asm-DefText())

   ;     Compile all constructs
   ;     ----------------------
   for i in ins(p) do :
      match(i) :
         ;Compile a function
         (i:DefFn) :
            emit(asm-Label(n(i)))
            bb-compile(i, output)
         ;Compile other constructs   
         (i:DefData) : emit(asm-DefData())
         (i:DefText) : emit(asm-DefText())
         (i:DefByte) : emit(asm-DefByte(value(i)))
         (i:DefInt) : emit(asm-DefInt(value(i)))
         (i:DefLong) : emit(asm-DefLong(value(i)))
         (i:DefFloat) : emit(asm-DefFloat(value(i)))
         (i:DefDouble) : emit(asm-DefDouble(value(i)))
         (i:DefString) : emit(asm-DefString(value(i)))
         (i:DefSpace) : emit(asm-DefSpace(size(i)))
         (i:DefLabel) : emit(asm-DefLabel(n(i)))
         (i:TLabel) : emit(asm-Label(n(i)))
            

   ;     ;Emit output to file
   ;     -------------------
   with-output-file(filename, asm-emit{output})


;                          Main Driver
;                          ===========

defn headline (str:String) :
   val n = length(str)
   val m = 30 - n / 2
   println()
   do(print{" "}, 0 to m)
   println(str)
   do(print{" "}, 0 to m)
   do(print{"="}, 0 to n)
   println()
      
defn main () :
   val filename = commandline-arguments()[1]
   val program = parse-tgt-ir(filename)
   
   headline("Program")
   println(program)

   headline("Compilation")
   compile(program, "test.s")   

main()