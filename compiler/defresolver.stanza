#include<"core/stringeater.stanza">
#include<"core/macro-utils.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">
#include<"compiler/stz-algorithms.stanza">

defpackage stz/resolver-lang :
   import core
   import verse
   import core/macro-utils
   import stz/lexer

;======== Parse Structures ========
definterface Arg
defstruct Define <: Arg :
   name: Symbol
defstruct Field <: Arg :
   name: Symbol
   prod: Symbol
defstruct Scope <: Arg :
   arg: Arg
defstruct Begin <: Arg :
   args: List<Arg>

definterface Clause
defstruct MapClause <: Clause :
   node
   prod: Symbol
defstruct ResolveClause <: Clause :
   node
   type: Symbol
defstruct PlusClause <: Clause :
   prod: Symbol
defstruct NodeClause <: Clause :
   node: Symbol
   arg: Arg

definterface Prod
defstruct DefineProd <: Prod :
   abbr: Symbol
   type: ?
   clauses: List<Clause>
defstruct ResolveProd <: Prod :
   abbr: Symbol
   type: ?
   clauses: List<Clause>

defstruct Structure :
   nodes: List<Symbol>
   args: List<List<Symbol>>

defstruct DefResolver :
   name
   type
   structure: Structure
   prods: List<Prod>

;======== Syntax Definition ========
defsyntax stz/resolver-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      prefix-op = (defresolver ?name:#sym ?type:#type :
                      ?s:#structure
                      ?ps:#prod ...) :
         compile(DefResolver(name, type, structure, ps))

      structure = (structure :
                      (?nodes:#sym (?args:#sym ...)) @...) :
         Structure(nodes, args)
         
      prod = (define ?abbr:#sym ?type:#type? : (?cs:#clause ...)) :
         DefineProd(abbr, type, cs)
      prod = (resolve ?abbr:#sym ?type:#type? : (?cs:#clause ...)) :
         ResolveProd(abbr, type, cs)

      type? = ((?t:#type)) : t
      type? = () : false

      clause = (?node:#type : (~ _:?p:#sym)) : MapClause(node, p)
      clause = (?node:#type : resolve ?type:#sym) : ResolveClause(node, type)
      clause = (+ ?prod:#sym) : PlusClause(prod)
      clause = (?node:#sym : ?arg:#arg) : NodeClause(node, arg)
      
      arg = (?name:#sym :+) : Define(name)
      arg = (?name:#sym : ?prod:#sym) : Field(name, prod)
      arg = ({?args:#arg ...}) : Scope(Begin(args))
      arg = ((?args:#arg ...)) : Begin(args)

      ; === Temp ===
      exp = (?x) : x


;======== Compilation ========
defn fill-each<?T> (f: T -> Streamable<KeyValue<Symbol,?>>, xs:Streamable<?T>) :
   nested(stream(f, xs))

defn compile (d:DefRenamers) :
   defn memoize<?T> (f: Symbol -> ?T) :
      val table = HashTable<Symbol,T>(symbol-hash)
      fn (x:Symbol) :
         if not key?(table, x) :
            table[x] = f(x)
         table[x]

   ;Temporary names
   val #e = gensym()

   ;Temporary names for arguments
   val arg-names = memoize(gensym)
   defn #name (a:SimpleArg|IgnoreArg) :
      arg-names(name(a))
   defn #names (a:List<Arg>) -> List<Symbol> :
      map-append(#names, a)
   defn #names (a:Arg) :
      match(a) :
         (a:SimpleArg|IgnoreArg) : list(#name(a))
         (a:ScopeArg|GroupArg|PublicArg) : #names(args(a))      

   ;Renamer name given abbreviation
   val abbr-name = memoize $ fn (ab:Symbol) :
      val r = for r in renamers(d) find :
         abbr(r) == ab
      match(r) :
         (r:False) : error("No renamer with abbreviation ~." % [ab])
         (r:Renamer) : name(r)
   defn #type (a:SimpleArg) : abbr-name(type(a))
   defn #type (b:MapBody|RecurBody) : abbr-name(type(b))

   defn compile (a:Arg) :
      match(a) :
         (a:SimpleArg) :
            fill-template(`(val #name = #map(t, name(e))), [
               `t => #type(a)
               `name => name(a)
               `#name => #name(a)
               `e => #e])
         (a:IgnoreArg) :
            fill-template(`(val #name = name(e)), [
               `name => name(a)
               `#name => #name(a)
               `e => #e])
         (a:ScopeArg) :
            val template = `(
               begin-scope()
               args
               end-scope())               
            fill-template(template, [
               `args => splice(stream(compile, args(a)))])
         (a:GroupArg) :
            val template = `(
               begin-group()
               args
               end-group())
            fill-template(template, [
               `args => splice(stream(compile, args(a)))])
         (a:PublicArg) :
            val template = `(
               val #vis = visibility
               visibility = Public()
               args
               visibility = #vis)
            fill-template(template, [
               `#vis => gensym()
               `args => splice(stream(compile, args(a)))])

   defn compile (node:Symbol, b:Body) :
      match(b) :
         (b:IgnoreBody) :
            #e            
         (b:FormBody) :
            fill-template(`(args, Node(#args)), [
               `args => splice(stream(compile, args(b)))
               `#args => splice(#names(args(b)))
               `Node => node])            
         (b:MapBody) :
            fill-template(`(map(t, e)), [
               `t => #type(b)
               `e => #e])
         (b:RecurBody) :
            fill-template(`(t(e)), [
               `t => #type(b)
               `e => #e])

   defn compile (r:Renamer) :
      match(r) :
         (r:TypeRenamer) :
            val template = `(
               defn name (e:IExp) :
                  match(e) :
                     clauses{(e:Node) : body})
            fill-template(template, [
               `name => name(r)
               `e => #e
               `clauses => for c in clauses(r) fill-each : [
                  `Node => node(c)
                  `body => compile(node(c), body(c))]])
         (r:CustomRenamer) :
            val template = `(defn name arglist : body)
            fill-template(template, [
               `name => name(r)
               `arglist => arglist(r)
               `body => body(r)])

   val r = list(map(compile, renamers(d)))
   println("=== defrenamer ===")
   println(r)
   r

;;======== Debuggin ========
;#with-overlay(stz/printer-lang) :
;   defprinter (e:CType) :
;      SymType :
;         ($sym type)
;      RestType :
;         ($rest type)
;      ListType :
;         ($list types ...)
;
;   defprinter (e:Checker) :
;      FormChecker :
;         ($form (args ...) (types ...))
;      IfChecker :
;         ($if pred conseq alt)
;      CustomChecker :
;         ($custom exp)
;      SwitchChecker :
;         ($switch pred (clauses ...) else-clause)
;      BeginChecker :
;         ($begin checkers ...)
;
;   defprinter (e:Clause) :
;      TypeClause :
;         ($type type checker)
;      PlusClause :
;         ($plus type)
;      AfterClause :
;         ($after exp)
;
;   defprinter (e:FormSpec) :
;      FormSpec :
;         ($spec type description clauses ...)
;
;   defprinter (e:DefCheck) :
;      DefCheck :
;         ($defcheck exp type specs ...)

;======== Test ========
defn main () :
   val filename = commandline-arguments()[1]
   val lexed = lex-file(filename)
   with-syntax(stz/rename-lang) :
      match-syntax(lexed) :
         (?e:#prefix-op) :
            println(e)
main()