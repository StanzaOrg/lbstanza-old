#include<"core/stringeater.stanza">
#include<"core/macro-utils.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">
#include<"compiler/stz-algorithms.stanza">

defpackage stz/resolver-lang :
   import core
   import verse
   import core/macro-utils
   import stz/lexer

;======== Parse Structures ========
definterface Arg
defstruct Define <: Arg :
   name: Symbol
defstruct Field <: Arg :
   name: Symbol
   prod: Symbol
defstruct Scope <: Arg :
   arg: Arg
defstruct Begin <: Arg :
   args: List<Arg>

definterface Clause
defstruct MapClause <: Clause :
   node
   prod: Symbol
defstruct ResolveClause <: Clause :
   node
   type: Symbol
defstruct PlusClause <: Clause :
   prod: Symbol
defstruct NodeClause <: Clause :
   node: Symbol
   arg: Arg

definterface Prod
defstruct DefineProd <: Prod :
   abbr: Symbol
   type: ?
   clauses: List<Clause>
defstruct ResolveProd <: Prod :
   abbr: Symbol
   type: ?
   clauses: List<Clause>

defstruct Structure :
   nodes: List<Symbol>
   args: List<List<Symbol>>

defstruct DefResolver :
   name
   exp
   type
   eng
   eng-type
   structure: Structure
   prods: List<Prod>

;======== Syntax Definition ========
defsyntax stz/resolver-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      prefix-op = (defresolver ?name:#sym (?exp:#sym:?type:#type, ?eng:#sym:?eng-type:#type) :
                      ?s:#structure
                      ?ps:#prod ...) :
         println(DefResolver(name, exp, type, eng, eng-type, s, ps))
         false

      structure = (structure :
                      (?nodes:#sym (?args:#sym ...)) @...) :
         Structure(nodes, args)
         
      prod = (define ?abbr:#sym ?type:#type? : (?cs:#clause ...)) :
         DefineProd(abbr, type, cs)
      prod = (resolve ?abbr:#sym ?type:#type? : (?cs:#clause ...)) :
         ResolveProd(abbr, type, cs)

      type? = ((?t:#type)) : t
      type? = () : false

      clause = (?node:#type : (~ _:?p:#sym)) : MapClause(node, p)
      clause = (?node:#type : resolve ?type:#sym) : ResolveClause(node, type)
      clause = (+ ?prod:#sym) : PlusClause(prod)
      clause = (?node:#sym : ?arg:#arg) : NodeClause(node, arg)
      
      arg = (?name:#sym :+) : Define(name)
      arg = (?name:#sym : ?prod:#sym) : Field(name, prod)
      arg = ({?args:#arg ...}) : Scope(Begin(args))
      arg = ((?args:#arg ...)) : Begin(args)

      ; === Temp ===
      exp = (?x) : x
      type = (?x) : x


;======== Compilation ========
defn fill-each<?T> (f: T -> Streamable<KeyValue<Symbol,?>>, xs:Streamable<?T>) :
   nested(stream(f, xs))

defn compile (d:DefResolver) :
   compiling an arg :
      Define :
         new-definition(engine, name(e))
      Field :
         if define?(prod) : #do(#prod, name(e))
         else : val #name = #map(#prod, name(e))
      Scope : 
         new-scope(engine)
         compile(arg)
         end-scope(engine)
      Begin :
         do(compile, args)
         
   compiling a general clause :
      MapClause :
         (e:Node) :
            if define?(prod) : #do(#prod, e)
            else : #map(#prod, e)
      ResolveClause :
         (e:Node) :
            resolve-type(e)
      PlusClause :
         (e) :
            #prod(e)

   compiling a define node clause :
      NodeClause :
         (e:Node) :
            compile(arg)
            false
      else compile general      

   compiling a resolve node clause :
      NodeClause :
         (e:Node) :
            compile(arg)
            Node(fs{arg})
         where :
            arg => if define? : name(e)
                   else : #name
      else
         compile general

   compiling a prod :
      DefineProd :
         defn #prod (e:type) -> False :
            match(e) :            
               clauses ...
      ResolveProd :
         defn #prod (e:type) :
            match(e) :            
               clauses ...         

   compiling defresolver :
      defn name (e:type, eng:engtype) :
         resolvers ...

;======== Debuggin ========
#with-overlay(stz/printer-lang) :
   defprinter (a:Arg) :
      Define :
         ($define name)
      Field :
         ($field name prod)
      Scope :
         ($scope arg)
      Begin :
         ($begin args ...)

   defprinter (c:Clause) :
      MapClause :
         ($map node prod)
      ResolveClause :
         ($resolve node type)
      PlusClause :
         ($plus prod)
      NodeClause :
         ($node node arg)

   defprinter (p:Prod) :
      DefineProd :
         ($define abbr type clauses ...)
      ResolveProd :
         ($resolve abbr type clauses ...)

   defprinter (s:Structure) :
      Structure :
         ($structure (nodes ...) (args ...))

   defprinter (d:DefResolver) :
      DefResolver :
         ($defresolver name type structure prods ...)

;======== Test ========
defn main () :
   val filename = commandline-arguments()[1]
   val lexed = lex-file(filename)
   with-syntax(stz/resolver-lang) :
      match-syntax(lexed) :
         (?e:#prefix-op) :
            println(e)
main()