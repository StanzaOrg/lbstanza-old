#include<"core/stringeater.stanza">
#include<"core/macro-utils.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">
#include<"compiler/stz-algorithms.stanza">

defpackage stz/resolver-lang :
   import core
   import verse
   import core/macro-utils
   import stz/lexer

;======== Parse Structures ========
definterface Arg
defstruct Define <: Arg :
   name: Symbol
defstruct Field <: Arg :
   name: Symbol
   prod: Symbol
defstruct Scope <: Arg :
   arg: Arg
defstruct Begin <: Arg :
   args: List<Arg>

definterface Clause
defstruct MapClause <: Clause :
   node
   prod: Symbol
defstruct ResolveClause <: Clause :
   node
   type: Symbol
defstruct PlusClause <: Clause :
   prod: Symbol
defstruct NodeClause <: Clause :
   node: Symbol
   arg: Arg

definterface Prod
defmulti prod (p:Prod) -> Symbol
defmulti type (p:Prod) -> ?
defstruct DefineProd <: Prod :
   prod: Symbol with: (as-method => true)
   type: ? with: (as-method => true)
   clauses: List<Clause>
defstruct ResolveProd <: Prod :
   prod: Symbol with: (as-method => true)
   type: ? with: (as-method => true)
   clauses: List<Clause>

defstruct Structure :
   nodes: List<Symbol>
   args: List<List<Symbol>>

defstruct DefResolver :
   name
   exp
   type
   eng
   eng-type
   structure: Structure
   prods: List<Prod>

;======== Syntax Definition ========
defsyntax stz/resolver-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      prefix-op = (defresolver ?name:#sym (?exp:#sym:?type:#type, ?eng:#sym:?eng-type:#type) :
                      ?s:#structure
                      ?ps:#prod ...) :
         println(compile(DefResolver(name, exp, type, eng, eng-type, s, ps)))
         false

      structure = (structure :
                      (?nodes:#sym (?args:#sym ...)) @...) :
         Structure(nodes, args)
         
      prod = (define ?prod:#sym ?type:#type? : (?cs:#clause ...)) :
         DefineProd(prod, type, cs)
      prod = (resolve ?prod:#sym ?type:#type? : (?cs:#clause ...)) :
         ResolveProd(prod, type, cs)

      type? = ((?t:#type)) : t
      type? = () : false

      clause = (?node:#type : (~ _:?p:#sym)) : MapClause(node, p)
      clause = (?node:#type : resolve ?type:#sym) : ResolveClause(node, type)
      clause = (+ ?prod:#sym) : PlusClause(prod)
      clause = (?node:#sym : ?arg:#arg) : NodeClause(node, arg)
      
      arg = (?name:#sym :+) : Define(name)
      arg = (?name:#sym : ?prod:#sym) : Field(name, prod)
      arg = ({?args:#arg ...}) : Scope(Begin(args))
      arg = ((?args:#arg ...)) : Begin(args)

      ; === Temp ===
      exp = (?x) : x
      type = (?x) : x


;======== Compilation ========
defn fill-each<?T> (f: T -> Streamable<KeyValue<Symbol,?>>, xs:Streamable<?T>) :
   nested(stream(f, xs))

defn compile (d:DefResolver) :
   ;Utilities
   defn memoize<?T> (f: Symbol -> ?T) :
      val table = HashTable<Symbol,T>(symbol-hash)
      fn (x:Symbol) :
         if not key?(table, x) :
            table[x] = f(x)
         table[x]

   ;Temporaries
   val #e = gensym()
   val #eng = gensym()

   ;Field name
   val #get-name = memoize(gensym{})
   defn #name (x:Symbol) : #get-name(x)
   defn #name (a:Field) : #get-name(name(a))
   
   ;Production name table
   val prod-table = HashTable<Symbol,Symbol>(symbol-hash)
   for p in prods(d) do : prod-table[prod(p)] = gensym()
   defn #prod (x:Field|MapClause|PlusClause|Prod) :
      prod-table[prod(x)]

   ;First resolver
   val resolver0 = #prod{_ as Prod} $
      for p in prods(d) find :
         p typeof ResolveProd
      
   ;Define table   
   val def-table = HashTable<Symbol,True|False>(symbol-hash)
   for p in prods(d) do : def-table[prod(p)] = p typeof DefineProd
   defn define? (prod:Symbol) :
      def-table[prod]

   ;Structure table
   val struct-table = HashTable<Symbol, List<Symbol>>(symbol-hash)
   for (n in nodes(structure(d)), args in args(structure(d))) do : struct-table[n] = args
   defn constructor-args (n:Symbol, arg:Arg) :
      for x in struct-table[n] map :
         if mapped?(x, arg) : #name(x)
         else : qquote(~ x(~ #e))

   defn mapped? (x:Symbol, a:Arg) :
      match(a) :
         (a:Define) : false
         (a:Field) : (name(a) == x) and (not define?(prod(a)))
         (a:Scope) : mapped?(x, arg(a))
         (a:Begin) : for a in args(a) any? : mapped?(x, a)
   
   defn compile (a:Arg) -> ? :
      match(a) :
         (a:Define) :
            fill-template(`(#do(#new-definition, name(#e))), [
               `#eng => #eng,
               `#e => #e,
               `name => name(a)])
         (a:Field) :
            val template = `(
               define?{
                  #do(#prod, name(#e))}{
                  val #name = #map(#prod, name(#e))})
            fill-template(template, [
               `define? => choice(define?(prod(a)))
               `#prod => #prod(a)
               `#e => #e
               `#name => #name(a)
               `name => name(a)])
         (a:Scope) :
            val template = `(
               new-scope(#eng)
               arg
               end-scope(#eng))
            fill-template(template, [
               `#eng => #eng
               `arg => compile(arg(a))])
         (a:Begin) :
            map(compile, args(a))

   defn compile (def?:True|False, c:Clause) :
      match(def?, c) :
         (_, c:MapClause) :
            val template = `(
               (#e:Node) : 
                  define?{
                     do(#prod, #e)}{
                     map(#prod, #e)})
            fill-template(template, [
               `define? => choice(define?(prod(c)))
               `#prod => #prod(c)
               `#e => #e               
               `Node => node(c)])
         (_, c:ResolveClause) :
            val template = `(
               (#e:Node) :
                  resolve-type(#eng, #e))
            fill-template(template, [
               `#eng => #eng
               `#e => #e
               `Node => node(c)
               `resolve-type => to-symbol("resolve-~" << [type(c)])])               
         (_, c:PlusClause) :
            val template = `(
               (#e) : #prod(#e))
            fill-template(template, [
               `#e => #e
               `#prod => #prod(c)])
         (_:True, c:NodeClause) :
            fill-template(`((#e:Node) : arg), [
               `#e => #e
               `Node => node(c)
               `arg => compile(arg(c))])
         (_:False, c:NodeClause) :
            val template = `(
               (#e:Node) :
                  arg
                  Node(fields))
            fill-template(template, [
               `#e => #e
               `Node => node(c)
               `arg => compile(arg(c))
               `fields => splice(constructor-args(node(c), arg(c)))])

   defn compile (p:Prod) :
      match(p) :
         (p:DefineProd) :
            val template = `(
               defn #prod (#e:type) -> core/False :
                  match(#e) :
                     clauses{c})
            fill-template(template, [
               `#prod => #prod(p)
               `#e => #e
               `type => type!(p)
               `clauses => for c in clauses(p) fill-each : [
                  `c => splice(compile(true, c))]])
         (p:ResolveProd) :
            val template = `(
               defn #prod (#e:type) :
                  match(#e) :
                     clauses{c})
            fill-template(template, [
               `#prod => #prod(p)
               `#e => #e
               `type => type!(p)
               `clauses => for c in clauses(p) fill-each : [
                  `c => splice(compile(false, c))]])

   defn type! (p:Prod) :
      match(type(p)) :
         (p:False) : type(d)
         (p) : p

   val template = `(
      defn name (#e:type, #eng:engtype) :
         defn #map<?S,?T> (f:T -> ?S , x: ?T) : f(x)
         defn #map<?S,?T> (f:T -> ?S, x: List<?T>) : core/map(f, x)
         defn #do<?S,?T> (f:T -> ?S , x: ?T) : f(x)
         defn #do<?S,?T> (f:T -> ?S, x: List<?T>) : core/do(f, x)
         defn #new-definition (#e:type) : new-definition(#eng, #e)
         resolvers
         resolver0(#e))
   fill-template(template, [
      `name => name(d),
      `#e => #e
      `type => type(d)
      `#eng => #eng
      `engtype => eng-type(d)
      `resolvers => map(compile, prods(d))
      `resolver0 => resolver0])

;======== Debuggin ========
#with-overlay(stz/printer-lang) :
   defprinter (a:Arg) :
      Define :
         ($define name)
      Field :
         ($field name prod)
      Scope :
         ($scope arg)
      Begin :
         ($begin args ...)

   defprinter (c:Clause) :
      MapClause :
         ($map node prod)
      ResolveClause :
         ($resolve node type)
      PlusClause :
         ($plus prod)
      NodeClause :
         ($node node arg)

   defprinter (p:Prod) :
      DefineProd :
         ($define prod type clauses ...)
      ResolveProd :
         ($resolve prod type clauses ...)

   defprinter (s:Structure) :
      Structure :
         ($structure (nodes ...) (args ...))

   defprinter (d:DefResolver) :
      DefResolver :
         ($defresolver name type structure prods ...)

;======== Test ========
defn main () :
   val filename = commandline-arguments()[1]
   val lexed = lex-file(filename)
   with-syntax(stz/resolver-lang) :
      match-syntax(lexed) :
         (?e:#prefix-op) :
            println(e)
main()