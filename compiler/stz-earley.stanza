#use-added-syntax(tests)
defpackage stz/earley :
  import core
  import collections
  import stz/utils

;============================================================
;====================== Definitions =========================
;============================================================

defstruct GRule :
  name: Symbol
  tokens: Tuple<GToken>
  precedence: Int with: (default => 100)
  associativity: Associativity with: (default => RightAssociative)

defenum Associativity :
  LeftAssociative
  RightAssociative

deftype GToken <: Equalable
defstruct GTerminal <: GToken :
  item: Symbol
defstruct GProduction <: GToken :
  name: Symbol

defstruct EItem :
  rule:Int
  num-parsed:Int
  parent:Int
  null-advanced:True|False with: (default => false)
  completion-cache:EItem|False with: (default => false, updater => sub-completion-cache)

defstruct ESet :
  index:Int
  items: Vector<EItem>
  
defstruct EParent :
  rule: Int
  start: Int
  index: Int
  child: ParsedRange
with:
  printer => true
  
defstruct ParsedRange <: Hashable&Equalable :
  rule: Int
  start: Int
  end: Int
with:
  printer => true

defstruct ParseEdge :
  parent: ParsedRange
  index: Int
  child: ParsedRange

;============================================================
;======================== Equalable =========================
;============================================================

defmethod equal? (a:GToken, b:GToken) :
  match(a, b) :
    (a:GTerminal, b:GTerminal) : item(a) == item(b)
    (a:GProduction, b:GProduction) : name(a) == name(b)
    (a, b) : false

defn key (r:ParsedRange) : [rule(r), start(r), end(r)]
defmethod equal? (a:ParsedRange, b:ParsedRange) : key(a) == key(b)
defmethod hash (a:ParsedRange) : hash(key(a))

;============================================================
;======================= Printers ===========================
;============================================================

defmethod print (o:OutputStream, t:GTerminal) :
  print(o, item(t))

defmethod print (o:OutputStream, t:GProduction) :
  print(o, name(t))

defmethod print (o:OutputStream, r:GRule) :
  print(o, "%_ = %s" % [name(r), tokens(r)])

;============================================================
;======================== Utilities =========================
;============================================================

defn length (r:ParsedRange) : end(r) - start(r)

defn inc-num-parsed (x:EItem) :
  inc-num-parsed(x, false)

defn inc-num-parsed (x:EItem, null-advanced:True|False) :
  EItem(rule(x), num-parsed(x) + 1, parent(x), null-advanced, false)

;============================================================
;====================== Nullable Set ========================
;============================================================

defn compute-nullable-set (grammar:Tuple<GRule>) :
  val null-table = HashTable<Symbol,True|False>()
  val rule-table = group-by(name, grammar)
  defn nullable? (t:GToken) :
    match(t) :
      (t:GTerminal) : false
      (t:GProduction) : nullable?(name(t))
  defn nullable? (name:Symbol) :
    if key?(null-table, name) :
      null-table[name]
    else :
      null-table[name] = false
      null-table[name] = for rule in rule-table[name] any? :
        all?(nullable?, tokens(rule))        
      null-table[name]
  do(nullable?{name(_)}, grammar)
  to-hashset<Symbol>(seq(key, filter(value, null-table)))

;============================================================
;====================== Algorithm ===========================
;============================================================

defn parse (grammar:Tuple<GRule>, input:Tuple<Symbol>) :
  val sets = Vector<ESet>()
  val parents = Vector<EParent>()
  val nullable-set = compute-nullable-set(grammar)
  
  defn make-initial-set () :
    val set0 = ESet(0, Vector<EItem>())
    add(items(set0), EItem(0, 0, 0))
    add(sets, set0)

  defn format (e:EItem) :
    new Printable :
      defmethod print (o:OutputStream, this) :
        val r = grammar[rule(e)]
        print(o, "[%_ =" % [name(r)])
        for (t in tokens(r), i in 0 to false) do :
          if num-parsed(e) == i :
            print(o, " • ")
            print(o, t)
          else :
            print(o, " ")
            print(o, t)
        if num-parsed(e) == length(tokens(r)) :
          print(o, " •")
        val null-str = ", null-advanced" when null-advanced(e) else ""
        val comp-str = "" when completion-cache(e) is False
                  else " (completed to %_)" % [format(completion-cache(e) as EItem)]
        print(o, ", S%_%_]%_" % [parent(e), null-str, comp-str])

  defn format (r:ParsedRange) :
    new Printable :
      defmethod print (o:OutputStream, this) :
        val rule = grammar[rule(r)]
        print(o, "[%_ to %_: %_]" % [start(r), end(r), rule])

  defn format (e:ParseEdge) :
    "%_ index %_ => %_" % [format(parent(e)), index(e), format(child(e))]
    
  defn format (p:EParent) :
    "%_ from %_ (index %_) => %_" % [grammar[rule(p)], start(p), index(p), format(child(p))]

  defn print-sets () :
    for (s in sets, i in 0 to false) do :
      println("Set %_:" % [i])
      within indented() :
        println("Index = %_" % [index(s)])
        do(println, seq(format, items(s)))

  defn upcoming (item:EItem) :
    val r = grammar[rule(item)]
    if num-parsed(item) < length(tokens(r)) :
      tokens(r)[num-parsed(item)]

  defn production-items (eset:ESet, name:Symbol) :
    for item in items(eset) filter :
      upcoming(item) == GProduction(name)

  defn process-set (set-index:Int) :
    val eset = sets[set-index]
    val item-index = to-seq(0 to false)
    val prediction-set = HashSet<Symbol>()
    val advance-set = HashSet<[Int,Int]>()
    while peek(item-index) < length(items(eset)) :
      val item = items(eset)[next(item-index)]
      defn dispatch () :
        match(upcoming(item)) :
          (f:False) :
            end-of-rule(item)
          (p:GProduction) :
            upcoming-production(item, p)
          (t:GTerminal) :
            if index(eset) < length(input) and
               input[index(eset)] == /item(t) :
              upcoming-terminal(item)
            else : nonmatched-terminal()            
      defn upcoming-terminal (item:EItem) :
        add(items(sets[set-index + 1]), inc-num-parsed(item))
      defn nonmatched-terminal () :
        false
      defn upcoming-production (item:EItem, t:GProduction) :
        if nullable-set[name(t)] :
          val item* = inc-num-parsed(item,true)
          add(items(eset), item*)
        if add(prediction-set, name(t)) :
          for (rule in grammar, i in 0 to false) do :
            if name(rule) == name(t) :
              val item* = EItem(i, 0, set-index)
              add(items(eset), item*)
      defn end-of-rule (completed-item:EItem) :
        if parent(completed-item) < index(eset) :
          val grule = grammar[rule(completed-item)]
          val pset = sets[parent(completed-item)]
          val range = ParsedRange(rule(completed-item), index(pset), index(eset))
          for item in production-items(pset, name(grule)) do :
            if not null-advanced(item) :
              val parent-start = index(sets[parent(item)])
              val item* = match(completion-cache(item)) :
                            (item*:EItem) : item*
                            (f:False) : inc-num-parsed(item)
              add(parents, EParent(rule(item), parent-start, num-parsed(item), range))
              if add(advance-set, [rule(item*), parent(item*)]) :
                add(items(eset), item*)
      dispatch()
    defn compute-completion-cache () :
      ;Compute count table
      val counts = HashTable<Symbol,Int>(0)
      for item in items(eset) do :
        match(upcoming(item)) :
          (t:GProduction) : update(counts, {_ + 1}, name(t))
          (t) : false
      ;Determine whether deterministic reduction
      defn deterministic-reduction? (item:EItem) :
        val num-tokens = length(tokens(grammar[rule(item)]))
        if num-parsed(item) == num-tokens - 1 :
          match(upcoming(item)) :
            (t:GProduction) : counts[name(t)] == 1              
            (t) : false            
      ;Compute completion
      defn complete (item:EItem) :
        if deterministic-reduction?(item) :
          val pset = sets[parent(item)]
          val items = production-items(pset, name(upcoming(item) as GProduction))
          val cached-completion = completion-cache(next(items)) when not empty?(items)
          val completion = if cached-completion is False : inc-num-parsed(item)
                           else : cached-completion
          sub-completion-cache(item, completion)
        else :
          item
      ;Compute all completions
      map!(complete, items(eset))
    compute-completion-cache()

  defn* process-until-finished () :
    val set-index = length(sets) - 1
    val eset = sets[set-index]
    if not empty?(items(eset)) :
      add(sets, ESet(index(eset) + 1, Vector<EItem>()))
      process-set(set-index)
      process-until-finished()
 
  defn* determine-reachable-graph () :
    println("PARENTS:")
    within indented() :
      for p in parents do :
        println(format(p))
    val used-ranges = HashSet<ParsedRange>()
    val edges = Vector<ParseEdge>()
    val children-table = group-by(key, parents) where :
      defn key (p:EParent) : [rule(p), start(p), index(p)]
    defn children (r:ParsedRange, index:Int) :
      val key = [rule(r), start(r), index]
      children-table[key]
    defn mark-used (r:ParsedRange) :
      if add(used-ranges, r) :
        val tokens = tokens(grammar[rule(r)])
        let loop (index:Int = length(tokens) - 1,
                  ends:List<Int> = List(end(r))) :                  
          if index >= 0 :
            match(tokens[index]) :
              (t:GTerminal) :
                loop(index - 1, map({_ - 1}, ends))
              (t:GProduction) :
                val child-relationships = to-list $ 
                  for relation in children(r, index) filter :
                    contains?(ends, end(child(relation)))
                for rel in child-relationships do :
                  add(edges, ParseEdge(r, index, child(rel)))
                  mark-used(child(rel))
                loop(index - 1, map(start{child(_)}, child-relationships))
    mark-used(ParsedRange(0, 0, length(input)))
    to-tuple(edges)

  defn* disambiguate (edges:Tuple<ParseEdge>) :
    println("PARSE EDGES:")
    within indented() :
      for e in edges do :
        println(format(e))
    val candidate-table = group-by(key, edges) where :
      defn key (e:ParseEdge) : [parent(e), index(e)]
    defn candidates (r:ParsedRange, index:Int, position:Int) :
      for c in candidate-table[[r,index]] filter :
        start(child(c)) == position
    defn most-specific (a:ParseEdge, b:ParseEdge) -> Int :
      defn compare-associativity (a:ParseEdge, b:ParseEdge) :
        val parent-rule = grammar[rule(parent(a))]
        switch(associativity(parent-rule)) :
          RightAssociative : compare(length(child(a)), length(child(b)))
          LeftAssociative : compare(length(child(b)), length(child(a)))
      defn compare-precedence (a:ParseEdge, b:ParseEdge) :
        val arule = grammar[rule(child(a))]
        val brule = grammar[rule(child(b))]
        compare(precedence(arule), precedence(brule))
      defn compare-order (a:ParseEdge, b:ParseEdge) :
        compare(rule(child(a)), rule(child(b)))
      val c1 = compare-associativity(a, b)
      if c1 == 0 :
        val c2 = compare-precedence(a, b)
        if c2 == 0 : compare-order(a, b)        
        else : c2
      else : c1

    val kept-edges = Vector<ParseEdge>()
    defn mark-used (r:ParsedRange) :
      val rule = grammar[rule(r)]
      val num-tokens = length(tokens(rule))
      let loop (index:Int = 0, position:Int = start(r)) :
        if index < num-tokens :
          match(tokens(rule)[index]) :
            (t:GProduction) :
              val candidates = candidates(r, index, position)
              val candidate = minimum(candidates, {most-specific(_, _) < 0})
              add(kept-edges, candidate)
              mark-used(child(candidate))
              loop(index + 1, end(child(candidate)))
            (t:GTerminal) :
              loop(index + 1, position + 1)
    mark-used(ParsedRange(0, 0, length(input)))
    to-tuple(kept-edges)

  defn main () :
    make-initial-set()
    process-until-finished()
    print-sets()
    ;val edges = disambiguate(determine-reachable-graph())
    ;println("Disambiguated:")
    ;do(println{format(_)}, edges)


  main()

;============================================================
;======================= Test Case ==========================
;============================================================

defn example-grammar () :
  val E = GProduction(`E)
  val N = GTerminal(`N)
  val PLUS = GTerminal(`+)
  val TIMES = GTerminal(`x)
  val LPAREN = GTerminal(`L)
  val RPAREN = GTerminal(`R)
  [GRule(`S, [E])
   GRule(`E, [E PLUS E])
   GRule(`E, [E TIMES E], 1, RightAssociative)
   GRule(`E, [LPAREN E RPAREN])
   GRule(`E, [N])]

deftest print-grammar :
  val g = example-grammar()
  do(println, g)

deftest parse :
  val g = example-grammar()
  parse(g, to-tuple $ `(N x N x L N + N R x N x N + N x N x N))

defn example-grammar-2 () :
  val S = GProduction(`S)
  val E = GProduction(`E)
  val F = GProduction(`F)
  val A = GTerminal(`A)
  val B = GTerminal(`B)
  val X = GTerminal(`X)
  val Y = GTerminal(`Y)
  [GRule(`Start, [S])
   GRule(`S, [E E X])
   GRule(`S, [F F Y])
   GRule(`E, [A A B])
   GRule(`F, [A A B])]

deftest parse-2 :
  val g = example-grammar-2()
  parse(g, to-tuple $ `(A A B A A B Y))

defn example-grammar-3 () :
  val S = GProduction(`S)
  val E = GProduction(`E)
  val F = GProduction(`F)
  val A = GTerminal(`A)
  val X = GTerminal(`X)
  val Y = GTerminal(`Y)
  [GRule(`Start, [S])
   GRule(`S, [E F X])
   GRule(`S, [F E X])
   GRule(`S, [F F F Y])
   GRule(`E, [A A])
   GRule(`F, [A])]

deftest parse-3 :
  val g = example-grammar-3()
  parse(g, to-tuple $ `(A A A X))

defn example-grammar-4 () :
  val S = GProduction(`S)
  val E = GProduction(`E)
  val A = GTerminal(`A)
  val X = GTerminal(`X)
  [GRule(`Start, [S])
   GRule(`S, [E E X])
   GRule(`E, [A A])
   GRule(`E, [A])]

deftest parse-4 :
  val g = example-grammar-4()
  parse(g, to-tuple $ `(A A A A X))


defn example-grammar-5 () :
  #for E in [ES, E, IF-E, SCLAUSES, SCLAUSE, ECLAUSE] :
    val E = GProduction(`E)
  #for (X in [PLUS, TIMES, LPAREN, RPAREN, N, EQ, LET, IN, IF, COLON, ELSE, SWITCH],
        x in [+, x, L, R, N, =, let, in, if, :, else, switch]) :
    val X = GTerminal(`x)
  [GRule(`Start, [ES])
   GRule(`ES, [ES E])
   GRule(`ES, [])
   GRule(`E, [E PLUS E], 200, LeftAssociative)
   GRule(`E, [E TIMES E], 210, LeftAssociative)
   GRule(`E, [LPAREN E RPAREN])
   GRule(`E, [N])
   GRule(`E, [E EQ E])
   GRule(`E, [LET E EQ E IN E])
   GRule(`E, [IF-E])
   GRule(`IF-E, [IF E COLON E ELSE IF-E])
   GRule(`IF-E, [IF E COLON E ELSE COLON E])
   GRule(`E, [SWITCH LPAREN SCLAUSES ECLAUSE RPAREN])
   GRule(`E, [SWITCH LPAREN SCLAUSES RPAREN])
   GRule(`SCLAUSES, [SCLAUSES SCLAUSE])
   GRule(`SCLAUSES, [])
   GRule(`SCLAUSE, [E COLON E])
   GRule(`ECLAUSE, [ELSE COLON E])]

deftest parse-5 :
  val g = example-grammar-5()
  parse(g, to-tuple $ `(
    switch L
      N : N x N
      N x N : N
      N + N : N + N
      else : N x N      
    R))

deftest parse-6 :
  val g = example-grammar-5()
  parse(g, to-tuple $ unwrap-all $ reader/read-file("test.txt"))

defn example-grammar-6 () :
  #for E in [ES, E] :
    val E = GProduction(`E)
  #for (X in [A B C],
        x in [a b c]) :
    val X = GTerminal(`x)
  [GRule(`Start, [ES])
   GRule(`ES, [E, ES])
   GRule(`ES, [])
   GRule(`E, [A])
   GRule(`E, [B C])]  

deftest parse-7 :
  val g = example-grammar-6()
  parse(g, to-tuple $ `(a a b c a a b c b c a a a a a a a a a a a a a a a a))

defn example-null-grammar () :
  #for X in [S Ap E] :
    val X = GProduction(`X)
  #for (X in [A],
        x in [a]) :
    val X = GTerminal(`x)
  [GRule(`Start, [S])
   GRule(`S, [Ap Ap Ap Ap])
   GRule(`Ap, [A])
   GRule(`Ap, [E])
   GRule(`E, [])]  

deftest calc-null-set :
  println("Null set = %," % [compute-nullable-set(example-grammar-5())])

deftest parse-null :
  val g = example-null-grammar()
  parse(g, to-tuple $ `(a))