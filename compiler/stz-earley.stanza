#use-added-syntax(tests)
defpackage stz/earley :
  import core
  import collections
  import stz/utils
  import stz/earley-search
  import stz/earley-grammar
  import stz/earley-grammar-analysis  
  import stz/earley-eval
  import stz/earley-eval-result
  import stz/earley-parse-tree
  import stz/earley-errors

;============================================================
;======================== Main ==============================
;============================================================

public deftype ParseProgress
public defmulti created-grammar (p:ParseProgress, g:Grammar) -> False
public defmulti parsed (p:ParseProgress, node:ParseNode) -> False
public defmulti failed (p:ParseProgress, e:ParsingErrors) -> False
defmethod created-grammar (p:ParseProgress, g:Grammar) : false
defmethod parsed (p:ParseProgress, node:ParseNode) : false
defmethod failed (p:ParseProgress, e:ParsingErrors) : false

public defn parse (rules:Tuple<GRule>, input:List) :
  parse(rules, input, new ParseProgress)

public defn parse (rules:Tuple<GRule>, input:List, progress:ParseProgress) -> ? :
  val grammar = Grammar(rules)
  created-grammar(progress,grammar)
  match(search(grammar, input)) :
    (r:SearchSuccess) :
      val parse-node = parse(grammar, setlist(r))
      parsed(progress, parse-node)
      evaluate-parse-tree(grammar, parse-node, inputlist(r), infolist(r))
    (f:SearchFailure) :
      val errors = to-exception(grammar, missing(f))
      failed(progress, errors)
      throw(errors)

;============================================================
;====================== Testing =============================
;============================================================
;<testing>
public defn test-parse-without-action (rules:Tuple<GRule>, input:List) :
  label break :
    var grammar:Grammar
    val progress = new ParseProgress :
      defmethod created-grammar (this, g:Grammar) :
        grammar = g
      defmethod parsed (this, node:ParseNode) :
        println(format(grammar, node))
        break()
      defmethod failed (this, e:ParsingErrors) :
        println(e)
        break()
    parse(rules, input, progress)

public defn test-parse (rules:Tuple<GRule>, input:List) :
  label break :
    var grammar:Grammar
    val progress = new ParseProgress :
      defmethod created-grammar (this, g:Grammar) :
        grammar = g
      defmethod parsed (this, node:ParseNode) :
        println(format(grammar, node))
      defmethod failed (this, e:ParsingErrors) :
        println(e)
        break()
    val result = parse(rules, input, progress)
    println("Parsed:")
    println(result)

deftype RulesCreator
defmulti make-production (rc:RulesCreator, name:Symbol) -> GProduction
defmulti make-rule (rc:RulesCreator, p:GProduction, tokens:Tuple<GToken>) -> False
public defn RulesCreator () :
  val prods = Vector<GDefProduction>()
  val rules = Vector<GRule>()
  new RulesCreator :
    defmethod make-production (this, name:Symbol) :
      val id = length(prods)
      add(prods, GDefProduction(id, name))
      GProduction(id)
    defmethod make-rule (this, p:GProduction, tokens:Tuple<GToken>) :
      add(rules, GTokenRule(id(p), tokens))
    defmethod rules (this) :
      GRules(to-tuple(prods), to-tuple(rules))

;============================================================
;===================== Examples =============================
;============================================================

defn example-grammar () :
  val E = GProduction(`E)
  val N = GKeyword(`N)  
  val PLUS = GKeyword(`+)
  val TIMES = GKeyword(`x)
  val LPAREN = GKeyword(`L)
  val RPAREN = GKeyword(`R)
  
  [GTokenRule(`S, [GListStart(), E, GListEnd()])
   GTokenRule(`E, [E PLUS E], 90, LeftAssociative)
   GTokenRule(`E, [E TIMES E], 80, LeftAssociative)
   GTokenRule(`E, [LPAREN E RPAREN])
   GTokenRule(`E, [N])]

deftest print-grammar :
  val g = example-grammar()
  do(println, g)

deftest parse :
  test-parse-without-action(example-grammar(), `(N x N x L N + N R x N x N + N x N x N))

defn example-grammar-2 () :
  val S = GProduction(`S)
  val E = GProduction(`E)
  val F = GProduction(`F)
  val A = GKeyword(`A)
  val B = GKeyword(`B)
  val X = GKeyword(`X)
  val Y = GKeyword(`Y)
  [GTokenRule(`Start, [GListStart() S GListEnd()])
   GTokenRule(`S, [E E X])
   GTokenRule(`S, [F F Y])
   GTokenRule(`E, [A A B])
   GTokenRule(`F, [A A B])]

deftest parse-2 :
  val g = example-grammar-2()
  test-parse-without-action(g, `(A A B A A B Y))

defn example-grammar-3 () :
  val S = GProduction(`S)
  val E = GProduction(`E)
  val F = GProduction(`F)
  val A = GKeyword(`A)
  val X = GKeyword(`X)
  val Y = GKeyword(`Y)
  [GTokenRule(`Start, [GListStart() S GListEnd()])
   GTokenRule(`S, [E F X])
   GTokenRule(`S, [F E X])
   GTokenRule(`S, [F F F Y])
   GTokenRule(`E, [A A])
   GTokenRule(`F, [A])]

deftest parse-3 :
  val g = example-grammar-3()
  test-parse-without-action(g, `(A A A X))

defn example-grammar-10 () :
  val S = GProduction(`S)
  val W = GProduction(`W)
  val X = GProduction(`X)
  val Y = GProduction(`Y)
  val Z = GProduction(`Z)
  val A = GKeyword(`A)
  val B = GKeyword(`B)
  val C = GKeyword(`C)
  [GTokenRule(`Start, [GListStart() S GListEnd()])
   GTokenRule(`S, [X Y Z])
   GTokenRule(`S, [W X Y])
   GTokenRule(`W, [A])
   GTokenRule(`X, [A A])
   GTokenRule(`Y, [B B])
   GTokenRule(`Z, [C C])]

deftest parse-10 :
  val g = example-grammar-10()
  test-parse-without-action(g, `(Y A A A B B A X))

defn example-grammar-4 () :
  val S = GProduction(`S)
  val E = GProduction(`E)
  val A = GKeyword(`A)
  val X = GKeyword(`X)
  [GTokenRule(`Start, [GListStart() S GListEnd()])
   GTokenRule(`S, [E E X])
   GTokenRule(`E, [A])
   GTokenRule(`E, [A A])]

deftest parse-4 :
  val g = example-grammar-4()
  test-parse-without-action(g, `(A A A A X))

defn example-grammar-5 () :
  #for E in [ES, E, IF-E, SCLAUSES, SCLAUSE, ECLAUSE] :
    val E = GProduction(`E)
  #for (X in [PLUS, TIMES, LPAREN, RPAREN, N, EQ, LET, IN, IF, COLON, ELSE, SWITCH],
        x in [+, x, L, R, N, =, let, in, if, :, else, switch]) :
    val X = GKeyword(`x)
  [GTokenRule(`Start, [GListStart() ES GListEnd()])
   GTokenRule(`ES, [E ES])
   GTokenRule(`ES, [])
   GTokenRule(`E, [E PLUS E], 90, LeftAssociative)
   GTokenRule(`E, [E TIMES E], 80, LeftAssociative)
   GTokenRule(`E, [LPAREN E RPAREN])
   GTokenRule(`E, [N])
   GTokenRule(`E, [E EQ E])
   GTokenRule(`E, [LET E EQ E IN E])
   GTokenRule(`E, [IF-E])
   GTokenRule(`IF-E, [IF E COLON E ELSE IF-E])
   GTokenRule(`IF-E, [IF E COLON E ELSE COLON E])
   GTokenRule(`E, [SWITCH LPAREN SCLAUSES ECLAUSE RPAREN])
   GTokenRule(`E, [SWITCH LPAREN SCLAUSES RPAREN])
   GTokenRule(`SCLAUSES, [SCLAUSE SCLAUSES])
   GTokenRule(`SCLAUSES, [])
   GTokenRule(`SCLAUSE, [E COLON E])
   GTokenRule(`ECLAUSE, [ELSE COLON E])]

deftest grammar-calc :
  Grammar(example-grammar-5())

deftest parse-5 :
  val g = example-grammar-5()
  test-parse-without-action(g, `(
    switch L
      N : N x N
      N x N : N
      N + N : N + N 
      else : N x N
    R))

deftest parse-5-2 :
  val g = example-grammar-5()
  test-parse-without-action(g, `(N + N x N + N))

deftest parse-6 :
  test-parse-without-action(example-grammar-5(), reader/read-file("test.txt"))

defn example-grammar-6 () :
  #for E in [ES, E] :
    val E = GProduction(`E)
  #for (X in [A B C],
        x in [a b c]) :
    val X = GKeyword(`x)
  [GTokenRule(`Start, [GListStart() ES GListEnd()])
   GTokenRule(`ES, [E, ES])
   GTokenRule(`ES, [])
   GTokenRule(`E, [A])
   GTokenRule(`E, [B C])]

deftest parse-7 :
  val g = example-grammar-6()
  test-parse-without-action(g, `(a a b c a a b c b c a a a b c a a a a a a a a a a a a a a))

defn example-grammar-8 () :
  #for E in [AS, BS] :
    val E = GProduction(`E)
  #for (X in [A],
        x in [a]) :
    val X = GKeyword(`x)
  [GTokenRule(`Start, [GListStart() AS GListEnd()])
   GTokenRule(`AS, [A, BS])
   GTokenRule(`BS, [A, AS])
   GTokenRule(`BS, [A])]

deftest parse-simple-mutual-right-recursive :
  val g = example-grammar-8()
  test-parse-without-action(g, `(a a a a a a a a a a a a a a a a a a a a a a a a a a))

defn example-grammar-9 () :
  #for E in [AS, BS] :
    val E = GProduction(`E)
  #for (X in [A],
        x in [a]) :
    val X = GKeyword(`x)
  [GTokenRule(`Start, [GListStart() AS GListEnd()])
   GTokenRule(`AS, [BS, A])
   GTokenRule(`BS, [AS, A])
   GTokenRule(`BS, [A])]

deftest parse-simple-mutual-left-recursive :
  val g = example-grammar-9()
  test-parse-without-action(g, `(a a a a a a a a a a a a a a a a a a a a a a a a a a))
  
deftest parse-mutually-right-recursive :
  #for E in [AS BS CS A B C X] :
    val E = GProduction(`E)
  #for (X in [x a b c],
        x in [x a b c]) :
    val X = GKeyword(`x)
  val rules = [
    GTokenRule(`Start, [GListStart() X X X AS GListEnd()])
    GTokenRule(`AS, [A, X, BS])
    GTokenRule(`BS, [B, X, CS])
    GTokenRule(`CS, [X])
    GTokenRule(`CS, [C, X, AS])
    GTokenRule(`X, [x])
    GTokenRule(`A, [a])
    GTokenRule(`B, [b])
    GTokenRule(`C, [c])]
  test-parse-without-action(rules, `(x x x a x b x c x a x b x c x a x b x x))

deftest right-recursive-priority :
  #for E in [E A BS] :
    val E = GProduction(`E)
  #for (X in [a],
        x in [a]) :
    val X = GKeyword(`x)
  val rules = [
    GTokenRule(`Start, [GListStart() E GListEnd()])
    GTokenRule(`E, [A BS])
    GTokenRule(`E, [A A A A], 200)
    GTokenRule(`BS, [A BS])
    GTokenRule(`BS, [])
    GTokenRule(`A, [a])]
  test-parse-without-action(rules, `(a a a a))

defn example-null-grammar () :
  #for X in [S Ap E] :
    val X = GProduction(`X)
  #for (X in [A],
        x in [a]) :
    val X = GKeyword(`x)
  [GTokenRule(`Start, [GListStart() S GListEnd()])
   GTokenRule(`S, [Ap Ap Ap Ap])
   GTokenRule(`Ap, [A])
   GTokenRule(`Ap, [E])
   GTokenRule(`E, [])]

deftest parse-null :
  val g = example-null-grammar()
  test-parse-without-action(g, `(a a a))

defn example-tricky-null-grammar () :
  #for E in [S, A, B] :
    val E = GProduction(`E)
  #for (X in [w, x, d],
        x in [w, x, d]) :
    val X = GKeyword(`x)
  [GTokenRule(`Start, [GListStart() S GListEnd()])
   GTokenRule(`S, [w A d])
   GTokenRule(`S, [A d])
   GTokenRule(`S, [w B A A A d])
   GTokenRule(`A, [x])
   GTokenRule(`A, [])
   GTokenRule(`B, [x])]

deftest parse-tricky-null :
  val g = example-tricky-null-grammar()
  test-parse-without-action(g, `(w x x d))

defn example-tricky-null-grammar-2 () :
  #for E in [B S A] :
    val E = GProduction(`E)
  #for (X in [w, x, d],
        x in [w, x, d]) :
    val X = GKeyword(`x)
  [GTokenRule(`Start, [GListStart() B GListEnd()])
   GTokenRule(`B, [S])
   GTokenRule(`B, [A])
   GTokenRule(`S, [w x A A A A d], 100, LeftAssociative)
   GTokenRule(`A, [w x])
   GTokenRule(`A, [])]

deftest parse-tricky-null-2 :
  val g = example-tricky-null-grammar-2()
  test-parse-without-action(g, `(w x w x w x w x d))

defn list-grammar () :
  #for E in [S, A, B, C, D, L, R, CD, CDs] :
    val E = GProduction(`E)
  #for (X in [a b c d],
        x in [a b c d]) :
    val X = GKeyword(`x)
  [GTokenRule(`Start, [GListStart() S GListEnd()])
   GTokenRule(`S, [A B CDs L CDs R CDs])
   GTokenRule(`S, [A B C])
   GTokenRule(`CDs, [CD, CDs])
   GTokenRule(`CDs, [])
   GTokenRule(`CD, [L C D R])
   GTokenRule(`A, [a])
   GTokenRule(`B, [b])
   GTokenRule(`C, [c])
   GTokenRule(`D, [d])
   GTokenRule(`L, [GListStart()])
   GTokenRule(`R, [GListEnd()])]

deftest parse-list :
  val g = list-grammar()
  test-parse-without-action(g, `(a b (c d) (c d) ((c d) (c d) (c d)) (c d)))

defn any-vs-list-grammar () :
  #for E in [S] :
    val E = GProduction(`E)
  #for (X in [done],
        x in [done]) :
    val X = GKeyword(`x)
  [GTokenRule(`Start, [GListStart() S GListEnd()])
   GTokenRule(`S, [GAny() done])
   GTokenRule(`S, [GListStart() done GListEnd() done])]

deftest parse-any-vs-list :
  val g = any-vs-list-grammar()
  test-parse-without-action(g, `((done) done))

defn any-as-list-grammar () :
  #for E in [S A As Xs] :
    val E = GProduction(`E)
;  #for (X in [],
;        x in [a b c d]) :
;    val X = GKeyword(`x)
  [GTokenRule(`Start, [GListStart() S GListEnd()])
   GTokenRule(`S, [Xs Xs])
   GTokenRule(`S, [A A])
   GTokenRule(`A, [GAny()])
   GTokenRule(`A, [GListStart(true) As GListEnd()])
   GTokenRule(`As, [A As])
   GTokenRule(`As, [])
   GTokenRule(`Xs, [GListStart() GKeyword(`x) GListEnd()])]

deftest parse-any-as-list :
  val g = any-as-list-grammar()
  test-parse-without-action(g, `((x) (x y z)))

defn list-recovery-grammar () :
  #for E in [S] :
    val E = GProduction(`E)
  #for (X in [a b c],
        x in [a b c]) :
    val X = GKeyword(`x)
  [GTokenRule(`Start, [GListStart() S GListEnd()])
   GTokenRule(`S, [a GListStart() b GListEnd() c])]

deftest parse-list-recovery :
  val g = list-recovery-grammar()
  test-parse-without-action(g, `(a b c))

defn rest-grammar () :
  #for E in [S] :
    val E = GProduction(`E)
  #for (X in [a b c],
        x in [a b c]) :
    val X = GKeyword(`x)
  [GTokenRule(`Start, [GListStart() S GListEnd()])
   GTokenRule(`S, [GListStart() a b c GListEnd()])
   GTokenRule(`S, [GListStart() a b GListRest() GListEnd()])]

deftest parse-rest :
  val g = rest-grammar()
  test-parse-without-action(g, `((a b d e f)))

defn full-any-grammar () :
  #for E in [S A As R] :
    val E = GProduction(`E)
  #for (X in [a b c d],
        x in [a b c d]) :
    val X = GKeyword(`x)
  val LP = GListStart()
  val LP* = GListStart(true)
  val RP = GListEnd()
  [GTokenRule(`Start, [GListStart() S GListEnd()])
   GTokenRule(`S, [LP a b LP c d R RP RP])   
   GTokenRule(`S, [LP a b LP c RP RP])   
   
   GTokenRule(`S, [A])
   GTokenRule(`As, [A As])
   GTokenRule(`As, [])
   GTokenRule(`A, [GAny()])
   GTokenRule(`A, [LP* R RP])
   GTokenRule(`R, [GAny(Reluctant) R])
   GTokenRule(`R, [LP* R RP R])
   GTokenRule(`R, [GListRest()])
   GTokenRule(`R, [])]  

deftest parse-full-any-grammar :
  val g = full-any-grammar()
  test-parse-without-action(g, `((a b (c d))))

defn full-any-grammar-2 () :
  #for E in [S A As R] :
    val E = GProduction(`E)
  #for (X in [a b c d],
        x in [a b c d]) :
    val X = GKeyword(`x)
  val LP = GListStart()
  val LP* = GListStart(true)
  val RP = GListEnd()
  [GTokenRule(`Start, [GListStart() S GListEnd()])
   GTokenRule(`S, [A a b c]) 
   GTokenRule(`S, [R])   
   GTokenRule(`A, [GAny()])
   GTokenRule(`A, [LP* R RP])
   GTokenRule(`R, [GAny(Reluctant) R])
   GTokenRule(`R, [LP* R RP R])
   GTokenRule(`R, [GListRest()])
   GTokenRule(`R, [])]  

deftest parse-full-any-grammar-2 :
  val g = full-any-grammar-2()
  test-parse-without-action(g, `((x y z) a b c))

defn amb-grammar () :
  #for E in [S ES E] :
    val E = GProduction(`E)
  #for (X in [red dog],
        x in [red dog]) :
    val X = GKeyword(`x)
  val LP = GListStart()
  val RP = GListEnd()
  [GTokenRule(`Start, [LP S RP])
   GTokenRule(`S, [ES])
   GTokenRule(`ES, [E ES], 100, LeftAssociative)
   GTokenRule(`ES, [])
   GTokenRule(`E, [dog])
   GTokenRule(`E, [red])
   GTokenRule(`E, [dog dog])]    

deftest parse-amb-grammar :
  val g = amb-grammar()
  test-parse-without-action(g, `(red red dog dog red dog dog dog))

defn amb-grammar-2 () :
  #for E in [S ES E] :
    val E = GProduction(`E)
  #for (X in [red dog],
        x in [red dog]) :
    val X = GKeyword(`x)
  val LP = GListStart()
  val RP = GListEnd()
  [GTokenRule(`Start, [LP S RP])
   GTokenRule(`S, [ES])
   GTokenRule(`ES, [E])
   GTokenRule(`ES, [E ES], 100, LeftAssociative)
   GTokenRule(`E, [dog])
   GTokenRule(`E, [red])
   GTokenRule(`E, [dog dog])
   GTokenRule(`E, [red dog])]    

deftest parse-amb-grammar-2 :
  val g = amb-grammar-2()
  test-parse-without-action(g, `(red dog dog dog dog red red dog dog red red dog dog dog red dog dog red dog dog))

defn if-grammar () :
  #for E in [S ES E] :
    val E = GProduction(`E)
  #for (X in [IF THEN ELSE N],
        x in [if then else N]) :
    val X = GKeyword(`x)
  val LP = GListStart()
  val RP = GListEnd()
  [GTokenRule(`Start, [LP S RP])
   GTokenRule(`S, [ES])
   GTokenRule(`ES, [E ES], 100, LeftAssociative)
   GTokenRule(`ES, [])
   GTokenRule(`E, [LP E RP])   
   GTokenRule(`E, [IF E THEN E], 100, LeftAssociative)      
   GTokenRule(`E, [IF E THEN E ELSE E], 100, LeftAssociative)
   GTokenRule(`E, [N])]    

deftest parse-if-grammar :
  val g = if-grammar()
  test-parse-without-action(g, `(if N then if N then N else N))

defn matcher-grammar () :
  #for E in [ES E Id BId RId] :
    val E = GProduction(`E)
  #for (X in [VAR EQ N DOT],
        x in [var = N .]) :
    val X = GKeyword(`x)
  val LP = GListStart()
  val RP = GListEnd()

  defn prefix-symbol? (form, prefix:String) :
    val s = unwrap-token(form) as Symbol
    prefix?(name(s), prefix)
  [GTokenRule(`Start, [LP ES RP])
   GTokenRule(`ES, [E ES])
   GTokenRule(`ES, [])
   GTokenRule(`E, [VAR Id EQ E])
   GTokenRule(`E, [N])
   GTokenRule(`Id, [BId DOT RId])
   GMatcherRule(`BId, GPrimToken(GSymbolType), prefix-symbol?{_, "B"})
   GMatcherRule(`RId, GPrimToken(GSymbolType), prefix-symbol?{_, "R"})]

deftest parse-matcher-grammar :
  val g = matcher-grammar()
  test-parse-without-action(g, `(var B10.R18 = N N))

deftest parse-matcher-grammar-error :
  val g = matcher-grammar()
  test-parse-without-action(g, `("hello world"))

defn core-form-grammar () :
  #for E in [ES E A R] :
    val E = GProduction(`E)
  #for (X in [CORE],
        x in [$core]) :
    val X = GKeyword(`x)
  val LP = GListStart()
  val RP = GListEnd()

  defn core-form? (form) :
    match(unwrap-token(form)) :
      (f:List) : not empty?(f) and unwrap-token(head(f)) == `$core
      (f) : false
      
  [GTokenRule(`Start, [LP ES RP])
   GTokenRule(`ES, [E ES])
   GTokenRule(`ES, [])
   GTokenRule(`E, [CORE])
   GTokenRule(`E, [LP ES RP])   
   GMatcherRule(`E, GAny(Atomic), core-form?)

   GTokenRule(`A, [GAny()])
   GTokenRule(`A, [LP R RP])
   GTokenRule(`R, [GAny() R])
   GTokenRule(`R, [LP R RP R])
   GTokenRule(`R, [GListRest()])
   GTokenRule(`R, [])]

deftest parse-core-form-grammar :
  val g = core-form-grammar()
  test-parse-without-action(g, `($core ($core a b c d) $core))

defn exp-grammar () :
  #for E in [ES E ID A R] :
    val E = GProduction(`E)
  #for (X in [VAR VAL FOR LET IN EQ COLON PLUS TIMES N DO],
        x in [var val for let in = : + * N @do]) :
    val X = GKeyword(`x)
  val LP = GListStart()
  val LP* = GListStart(true)
  val RP = GListEnd()
      
  [GTokenRule(`Start, [LP ES RP], fn (result) :
     result[1])
  
   GTokenRule(`keywords, [VAR])     
   GTokenRule(`keywords, [VAL])     
   GTokenRule(`keywords, [FOR])     
   GTokenRule(`keywords, [LET])     
   GTokenRule(`keywords, [IN])
   GTokenRule(`keywords, [EQ])
   GTokenRule(`keywords, [COLON])
   GTokenRule(`keywords, [DO])

   GTokenRule(`A, [GAny()], fn (result) : result[0])
   GTokenRule(`A, [LP* R RP], fn (result) : result[0])
   GTokenRule(`R, [GAny(Reluctant) R], fn (result) : form(result))
   GTokenRule(`R, [LP* R RP R], fn (result) : form(result))
   GTokenRule(`R, [GListRest()], fn (result) : form(result))
   GTokenRule(`R, [], fn (result) : form(result))

   GTokenRule(`ID, [A], fn (result) :
     result[0])
   ;GNegationRule(`ID, GProduction(`keywords))
   
   GTokenRule(`ES, [E ES], 100, LeftAssociative, fn (result) :
     cons(result[0], result[1]))
   GTokenRule(`ES, [], fn (result) :
     List())
   
   GTokenRule(`E, [VAR ID EQ E], fn (result) :
     qquote($var ~(result[1]) ~(result[3])))
   GTokenRule(`E, [VAL ID EQ E], fn (result) :
     qquote($val ~(result[1]) ~(result[3])))
   GTokenRule(`E, [FOR ID IN E COLON E], fn (result) :
       qquote($for ~(result[1]) ~(result[3]) ~(result[5])))
   GTokenRule(`E, [LET ID EQ E COLON E], fn (result) :
     qquote($let ~(result[1]) ~(result[3]) ~(result[5])))     
   GTokenRule(`E, [E LP DO ES RP], 70, LeftAssociative, fn (result) :
     qquote($call ~(result[0]) ~@(result[3])))
   GTokenRule(`E, [LP E RP], fn (result) :
     result[1])
   GTokenRule(`E, [LP ES RP], fn (result) :
     qquote($begin ~@(result[1])))
   GTokenRule(`E, [N], fn (result) :
     result[0])
   GTokenRule(`E, [GPrimToken(GIntType)], fn (result) :
     result[0])
   GTokenRule(`E, [E PLUS E], 90, LeftAssociative, fn (result) :
     qquote($plus ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E TIMES E], 80, LeftAssociative, fn (result) :
     qquote($times ~(result[0]), ~(result[2])))]

deftest parse-exp-grammar :
  test-parse(exp-grammar(), reader/read-file("exp-test.txt"))

deftest action-exp-grammar :
  test-parse-without-action(exp-grammar(), reader/read-file("exp-test.txt"))

defn rest-priority-grammar () :
  #for E in [ES E F A R] :
    val E = GProduction(`E)
  #for (X in [PLUS N],
        x in [+ N]) :
    val X = GKeyword(`x)
  val LP = GListStart()
  val LP* = GListStart(true)
  val RP = GListEnd()
      
  [GTokenRule(`Start, [LP F RP])

   GTokenRule(`F, [E E], 100, LeftAssociative)
   
   GTokenRule(`E, [E PLUS E], 90, LeftAssociative)
   ;GTokenRule(`E, [N R], true)
   GTokenRule(`E, [N])

   GTokenRule(`A, [GAny()])
   GTokenRule(`A, [LP* R RP])
   GTokenRule(`R, [GAny(Reluctant) R])
   GTokenRule(`R, [LP* R RP R])
   GTokenRule(`R, [GListRest()])
   GTokenRule(`R, [])]

deftest parse-rest-priority-grammar :
  val g = rest-priority-grammar()
  test-parse-without-action(g, `(N + N + N N + N))

deftest parse-blowup-grammar :
  #for E in [E] :
    val E = GProduction(`E)
  #for (X in [N],
        x in [N]) :
    val X = GKeyword(`x)
  val grammar = [
    GTokenRule(`Start, [GListStart() E GListEnd()])
    GTokenRule(`E, [E E E])
    GTokenRule(`E, [N])]  

;  test-parse-without-action(grammar, `(N N N N N N N N N N N N N N N N N
;                        N N N N N N N N N N N N N N N N N N))

  test-parse-without-action(grammar, `(N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N
                        N N N N N N N N N N N N N N N N N N N))

defn substanza-grammar () :
  ;Define productions
  #for E in [ES E ID A R IFE TYPE TYPES] :
    val E = GProduction(`E)

  ;Define keywords
  #for (X in [VAR VAL FOR LET IN EQ COLON PLUS MINUS TIMES DIV, MOD, DO TUPLE IF ELSE AND OR ARROW OF QUESTION VOID CAP
              AND-WORD, OR-WORD, NOT, EQEQ, NOTEQ, LESS, LESSEQ, GREATER, GREATEREQ, SHL, SHR, ASHR, CARAT],
        x in [var val for let in = : + - * / % @do @tuple if else & | -> @of ? Void @cap
              and or not == != < <= > >= << >> >>> ^]) :
    val X = GKeyword(`x)

  ;Define list terminals
  val LP = GListStart()
  val LP* = GListStart(true)
  val RP = GListEnd()

  ;Define reserved keywords
  val reserved = to-hashset<Symbol> $ `(
    @do @get @do-afn @afn @quote @tuple @of @cap
    var val for let in if else = : + - / * % & | -> ? Void
    and or not == < <= > >= << >> >>> ^)
  defn identifier? (x) :
    not reserved[unwrap-token(x)]
  
  [;Starting Rule
   GTokenRule(`Start, [LP ES RP], fn (result) : result[1]) 

   ;Any Rules
   GTokenRule(`A, [GAny()], fn (result) : result[0])
   GTokenRule(`A, [LP* R RP], fn (result) : result[0])
   GTokenRule(`R, [GAny(Reluctant) R], fn (result) : form(result))
   GTokenRule(`R, [LP* R RP R], fn (result) : form(result))
   GTokenRule(`R, [GListRest()], fn (result) : form(result))
   GTokenRule(`R, [], fn (result) : form(result))

   ;Identifier
   GMatcherRule(`ID, GPrimToken(GSymbolType), identifier?, fn (result) : result[0])

   ;Expression List
   GTokenRule(`ES, [E ES], fn (result) : cons(result[0], result[1]))
   GTokenRule(`ES, [], fn (result) : List())

   ;Type List
   GTokenRule(`TYPES, [TYPE TYPES], fn (result) : cons(result[0], result[1]))
   GTokenRule(`TYPES, [], fn (result) : List())

   ;Type
   GTokenRule(`TYPE, [TYPE ARROW TYPE], 100, RightAssociative, fn (result) :
     qquote($-> (~(result[0])) ~(result[2])))
   GTokenRule(`TYPE, [LP TYPES RP ARROW TYPE], 100, RightAssociative, fn (result) :
     qquote($-> (~@(result[1])) ~(result[4])))
   GTokenRule(`TYPE, [TYPE OR TYPE], 80, LeftAssociative, fn (result) :
     qquote($or ~(result[0]) ~(result[2])))
   GTokenRule(`TYPE, [TYPE AND TYPE], 70, LeftAssociative, fn (result) :
     qquote($and ~(result[0]) ~(result[2])))
   GTokenRule(`TYPE, [TYPE LP OF TYPES RP], fn (result) :
     qquote($of ~(result[0]) ~@(result[3])))
   GTokenRule(`TYPE, [LP TYPE RP], fn (result) :
     result[1])
   GTokenRule(`TYPE, [LP CAP ID RP], fn (result) :
     qquote($cap ~(result[2])))     
   GTokenRule(`TYPE, [ID], fn (result) :
     result[0])
   GTokenRule(`TYPE, [QUESTION], fn (result) :
     `($?))
   GTokenRule(`TYPE, [VOID], fn (result) :
     `($void))
   GTokenRule(`TYPE, [LP TUPLE TYPES RP], fn (result) :
     qquote($tuple ~@(result[2])))
     

   ;Expression
   GTokenRule(`E, [ID], fn (result) : result[0])
   GTokenRule(`E, [VAR ID COLON TYPE], fn (result) :
     qquote($var ~(result[1]) ~(result[3]) ($none)))
   GTokenRule(`E, [VAR ID EQ E], fn (result) :
     qquote($var ~(result[1]) ($none) ~(result[3])))
   GTokenRule(`E, [VAL ID EQ E], fn (result) :
     qquote($val ~(result[1]) ($none) ~(result[3])))
   GTokenRule(`E, [FOR ID IN E COLON E], fn (result) :
       qquote($for ~(result[1]) ~(result[3]) ~(result[5])))
   GTokenRule(`E, [LET COLON E], fn (result) :
     qquote($let ~(result[2])))
   GTokenRule(`E, [E LP DO ES RP], 30, LeftAssociative, fn (result) :
     qquote($do ~(result[0]) ~@(result[3])))
   GTokenRule(`E, [IFE], fn (result) : result[0])
   GTokenRule(`IFE, [IF E COLON E], fn (result) :
     qquote($if ~(result[1]) ~(result[3])))
   GTokenRule(`IFE, [IF E COLON E ELSE IFE], fn (result) :
     qquote($if ~(result[1]) ~(result[3]) ~(result[5])))
   GTokenRule(`IFE, [IF E COLON E ELSE COLON E], fn (result) :
     qquote($if ~(result[1]) ~(result[3]) ~(result[6])))
   GTokenRule(`E, [LP E RP], fn (result) :
     result[1])
   GTokenRule(`E, [LP ES RP], fn (result) :
     qquote($begin ~@(result[1])))
   GTokenRule(`E, [GPrimToken(GIntType)], fn (result) :
     result[0])

   ;Operators
   GTokenRule(`E, [E AND-WORD E], 90, LeftAssociative, fn (result) :
     qquote($and ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E OR-WORD E], 90, LeftAssociative, fn (result) :
     qquote($or ~(result[0]), ~(result[2])))

   ;Comparison Operators
   GTokenRule(`E, [NOT E], 80, NonAssociative, fn (result) :
     qquote($not ~(result[1])))
   GTokenRule(`E, [E EQEQ E], 80, LeftAssociative, fn (result) :
     qquote($eq ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E NOTEQ E], 80, LeftAssociative, fn (result) :
     qquote($noteq ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E LESS E], 80, LeftAssociative, fn (result) :
     qquote($less ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E LESSEQ E], 80, LeftAssociative, fn (result) :
     qquote($less-eq ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E GREATER E], 80, LeftAssociative, fn (result) :
     qquote($greater ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E GREATEREQ E], 80, LeftAssociative, fn (result) :
     qquote($greater-eq ~(result[0]), ~(result[2])))

   ;Arithmetic Operators
   GTokenRule(`E, [E PLUS E], 70, LeftAssociative, fn (result) :
     qquote($plus ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E MINUS E], 70, LeftAssociative, fn (result) :
     qquote($minus ~(result[0]), ~(result[2])))

   ;Multiply Operators     
   GTokenRule(`E, [E TIMES E], 60, LeftAssociative, fn (result) :
     qquote($times ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E DIV E], 60, LeftAssociative, fn (result) :
     qquote($div ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E MOD E], 60, LeftAssociative, fn (result) :
     qquote($mod ~(result[0]), ~(result[2])))

   ;Bit operators
   GTokenRule(`E, [E OR E], 50, LeftAssociative, fn (result) :
     qquote($bit-or ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E AND E], 50, LeftAssociative, fn (result) :
     qquote($bit-and ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E CARAT E], 50, LeftAssociative, fn (result) :
     qquote($bit-xor ~(result[0]), ~(result[2])))

   ;Bit shift operators
   GTokenRule(`E, [E SHL E], 40, LeftAssociative, fn (result) :
     qquote($bit-shl ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E SHR E], 40, LeftAssociative, fn (result) :
     qquote($bit-shr ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E ASHR E], 40, LeftAssociative, fn (result) :
     qquote($bit-ashr ~(result[0]), ~(result[2])))]

deftest parse-stanza-grammar :
  test-parse(substanza-grammar(), reader/read-file("stanza-test.txt"))

defn rewrite-amb-grammar () :
  ;Define productions
  #for E in [ES E E0 ID A R] :
    val E = GProduction(`E)

  ;Define keywords
  #for (X in [PLUS, MINUS],
        x in [+ -]) :
    val X = GKeyword(`x)

  ;Define list terminals
  val LP = GListStart()
  val LP* = GListStart(true)
  val RP = GListEnd()

  ;Define reserved keywords
  val reserved = to-hashset<Symbol> $ `(+ -)
  defn identifier? (x) :
    not reserved[unwrap-token(x)]
  
  [;Starting Rule
   GTokenRule(`Start, [LP ES RP], fn (result) : result[1]) 

   ;Any Rules
   GTokenRule(`A, [GAny()], fn (result) : result[0])
   GTokenRule(`A, [LP* R RP], fn (result) : result[0])
   GTokenRule(`R, [GAny(Reluctant) R], fn (result) : form(result))
   GTokenRule(`R, [LP* R RP R], fn (result) : form(result))
   GTokenRule(`R, [GListRest()], fn (result) : form(result))
   GTokenRule(`R, [], fn (result) : form(result))

   ;Identifier
   GMatcherRule(`ID, GPrimToken(GSymbolType), identifier?, fn (result) : result[0])

   ;Expression List
   GTokenRule(`ES, [E ES], fn (result) : cons(result[0], result[1]))
   GTokenRule(`ES, [], fn (result) : List())     

   ;Expression
   GTokenRule(`E, [E0], fn (result) : result[0])
   GTokenRule(`E0, [ID], fn (result) : result[0])

   ;Arithmetic Operators
   GTokenRule(`E, [E PLUS E0], 70, LeftAssociative, fn (result) :
     qquote($plus ~(result[0]), ~(result[2])))
   GTokenRule(`E, [E MINUS E0], 70, LeftAssociative, fn (result) :
     qquote($minus ~(result[0]), ~(result[2])))


     ]

let :;deftest parse-rewrite-grammar :
  val forms = `(x0 + x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x10 +
                x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 +
                x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 +
                x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 +
                x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 +
                x51 + x52 + x53 + x54 + x55 + x56 + x57 + x58 + x59 + x60 +
                x61 + x62 + x63 + x64 + x65 + x66 + x67 + x68 + x69 + x70 +
                x71 + x72 + x73 + x74 + x75 + x76 + x77 + x78 + x79 + x80 +
                x81 + x82 + x83 + x84 + x85 + x86 + x87 + x88 + x89 + x90 +
                x91 + x92 + x93 + x94 + x95 + x96 + x97 + x98 + x99 + x100)
  test-parse(rewrite-amb-grammar(), forms)
;<testing>