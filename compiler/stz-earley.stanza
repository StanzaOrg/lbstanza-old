#use-added-syntax(tests)
defpackage stz/earley :
  import core
  import collections
  import stz/utils

;============================================================
;====================== Definitions =========================
;============================================================

defstruct GRule :
  name: Symbol
  tokens: Tuple<GToken>
  precedence: Int with: (default => 100)
  associativity: Associativity with: (default => RightAssociative)

defenum Associativity :
  LeftAssociative
  RightAssociative

deftype GToken <: Equalable
defstruct GTerminal <: GToken :
  item: Symbol
defstruct GProduction <: GToken :
  name: Symbol

defstruct EItem :
  rule:Int
  num-parsed:Int
  parent:Int
  completion-cache:EItem|False with: (init => false, updater => sub-completion-cache)

defstruct EParent :
  rule: Int
  start: Int
  index: Int
  id: Int
with:
  printer => true

defstruct ParsedRange <: Hashable&Equalable :
  id: Int
  rule: Int
  start: Int
  end: Int
with:
  printer => true

defstruct ParseEdge :
  parent: ParsedRange
  index: Int
  child: ParsedRange

;============================================================
;======================== Equalable =========================
;============================================================

defmethod equal? (a:GToken, b:GToken) :
  match(a, b) :
    (a:GTerminal, b:GTerminal) : item(a) == item(b)
    (a:GProduction, b:GProduction) : name(a) == name(b)
    (a, b) : false

defn key (r:ParsedRange) : [rule(r), start(r), end(r)]
defmethod equal? (a:ParsedRange, b:ParsedRange) : key(a) == key(b)
defmethod hash (a:ParsedRange) : hash(key(a))

;============================================================
;======================= Printers ===========================
;============================================================

defmethod print (o:OutputStream, t:GTerminal) :
  print(o, item(t))

defmethod print (o:OutputStream, t:GProduction) :
  print(o, name(t))

defmethod print (o:OutputStream, r:GRule) :
  print(o, "%_ = %s" % [name(r), tokens(r)])

;============================================================
;======================== Utilities =========================
;============================================================

defn length (r:ParsedRange) :
  end(r) - start(r)

defn inc-num-parsed (x:EItem) :
  EItem(rule(x), num-parsed(x) + 1, parent(x))

defn upcoming (grammar:Grammar, item:EItem) -> GToken|False :
  val r = grammar[rule(item)]
  val i = num-parsed(item)
  val num-tokens = length(tokens(r))
  tokens(r)[i] when i < num-tokens

defn upcoming-production! (grammar:Grammar, item:EItem) :
  name(upcoming(grammar,item) as GProduction)

defn production (grammar:Grammar, item:EItem) -> Symbol :
  name(grammar[rule(item)])

defn do-all (f:EItem -> ?, eset:Vector<EItem>) :
  val item-index = to-seq(0 to false)
  while peek(item-index) < length(eset) :
    f(eset[next(item-index)])

;============================================================
;==================== Grammar Analysis ======================
;============================================================

deftype Grammar
defmulti get (g:Grammar, i:Int) -> GRule
defmulti nullable? (g:Grammar, production:Symbol) -> True|False
defmulti rules (g:Grammar, production:Symbol, next-input:Symbol|False) -> Seqable<Int>

defn Grammar (rules:Tuple<GRule>) :
  val [null-table, null-rules, rule-fsets] = nullables-and-firstsets(rules)
  val null-rules-table = nullables-to-rule-table(rules, null-rules)
  val input-rule-table = input-to-rule-table(rules, null-rules-table, rule-fsets)
  new Grammar :
    defmethod get (this, i:Int) :
      rules[i]
    defmethod nullable? (this, production:Symbol) :
      null-table[production]
    defmethod rules (this, production:Symbol, next-input:Symbol|False) :
      match(next-input:Symbol) : cat(null-rules-table[production], input-rule-table[[production,next-input]])
      else : null-rules-table[production]

defn input-to-rule-table (rules:Tuple<GRule>,
                          null-rules-table:HashTable<Symbol,List<Int>>,
                          rule-fsets:Tuple<Tuple<Symbol>>) ->
                          HashTable<[Symbol, Symbol],List<Int>> :
  ;Utility to subtract one set from another.
  val buffer = IntSet()
  defn minus (a:Collection<Int>, b:Collection<Int>) :
    add-all(buffer, a)
    for x in b do : remove(buffer,x)
    val result = to-list(buffer)
    clear(buffer)
    result

  ;Compute [prod, input-terminal] => (rules ...) table.
  val table = group-by{key, value, _} $
    for (rule in rules, rule-index in 0 to false) seq-cat :
      for terminal in rule-fsets[rule-index] seq :
        [name(rule), terminal] => rule-index

  ;Remove all rules that are already accounted for by null table.
  for entry in table map! :
    val [prod, input] = key(entry)
    value(entry) - null-rules-table[prod]

  ;Return final table
  table

defn nullables-to-rule-table (rules:Tuple<GRule>, null-rules:Tuple<Int>) ->
                              HashTable<Symbol,List<Int>> :
  defn production (i:Int) : name(rules[i])
  group-by(production, null-rules)

defn nullables-and-firstsets (grammar:Tuple<GRule>) ->
                             [HashTable<Symbol,True|False>,
                              Tuple<Int>,
                              Tuple<Tuple<Symbol>>] :
  ;Compute parent rules that contain each production.
  val parent-table:HashTable<Symbol,List<Int>> = group-by{key, value, _} $
    for (rule in grammar, rule-index in 0 to false) seq-cat :
      for prod in filter-by<GProduction>(tokens(rule)) seq :
        name(prod) => rule-index

  ;Worklist algorithm
  defn worklist (f:(GRule, Symbol -> False) -> ?) :
    val queue = Queue<Int>()
    do(add{queue, _}, 0 to length(grammar))
    defn enqueue (prod:Symbol) :
      do(add{queue, _}, parent-table[prod])
    while not empty?(queue) :
      val rule = grammar[pop(queue)]
      f(rule, enqueue)

  ;Compute null table
  val null-table = HashTable<Symbol,True|False>(false)
  defn nullable? (t:GToken) :
    match(t) :
      (t:GTerminal) : false
      (t:GProduction) : null-table[name(t)]
  defn nullable? (rule:GRule) :
    all?(nullable?, tokens(rule))
  within (rule, enqueue) = worklist() :
    if not null-table[name(rule)] and nullable?(rule) :
      null-table[name(rule)] = true
      enqueue(name(rule))

  ;Compute first sets
  val fset-table = HashTable<Symbol,Tuple<Symbol>>([])
  defn first-sets (t:GToken) :
    match(t) :
      (t:GTerminal) : [item(t)]
      (t:GProduction) : fset-table[name(t)]
  defn first-sets (rule:GRule) :
    val terminals = Vector<Symbol>()
    let loop (i:Int = 0) :
      if i < length(tokens(rule)) :
        val t = tokens(rule)[i]
        add-all(terminals, first-sets(t))
        loop(i + 1) when nullable?(t)
    terminals
  within (rule, enqueue) = worklist() :
    val fset = to-hashset<Symbol> $ fset-table[name(rule)]
    val old-length = length(fset)
    add-all(fset, first-sets(rule))
    if length(fset) > old-length :
      fset-table[name(rule)] = to-tuple(fset)
      enqueue(name(rule))

  ;Compute null rules
  val null-rules = to-tuple $
    filter(nullable?{grammar[_]}, 0 to length(grammar))

  ;Compute rule first sets
  val rule-fsets = for rule in grammar map :
    to-tuple $ unique $ first-sets(rule)

  ;Return all tables
  [null-table, null-rules, rule-fsets]

defn nullable-productions (grammar:Tuple<GRule>) :
  val [null-table, null-rules, rule-fsets] = nullables-and-firstsets(grammar)
  to-hashset<Symbol> $ seq(key, filter(value, null-table))

;============================================================
;======================== ESetList ==========================
;============================================================

deftype ESetList
defmulti add (l:ESetList, items:Seqable<EItem>) -> False
defmulti clear-markers (l:ESetList) -> False
defmulti items (return:EItem -> ?, l:ESetList, index:Int, production:Symbol, mark?:True|False) -> False
defmulti first-item (l:ESetList, index:Int, production:Symbol) -> EItem|False
defmulti sets (l:ESetList) -> Seqable<Seqable<EItem>>

defstruct EItemSet :
  start: Int
  length: Int

defn ESetList (grammar:Grammar) :
  val items = Vector<EItem>()
  val markers = Vector<Int>()
  val sets = Vector<EItemSet>()
  val buffer = Vector<EItem>()
  var current-marker:Int = 1

  defn production! (item:EItem) :
    upcoming-production!(grammar, item)

  defn productions (return:EItem -> ?, start:Int, end:Int, production:Symbol) :
    let loop (i:Int = start) :
      if i < end :
        val item = items[i]
        if production!(item) == production :
          return(item)
          loop(i + 1)

  new ESetList :
    defmethod add (this, new-items:Seqable<EItem>) :
      add-all(buffer, new-items)
      qsort!(production!, buffer)
      add(sets, EItemSet(length(items), length(buffer)))
      add-all(items, buffer)
      lengthen(markers, length(items), 0)
      clear(buffer)
    defmethod items (return:EItem -> ?, this, index:Int, production:Symbol, mark?:True|False) :
      val eset = sets[index]
      val i = bsearch(production!, items, start(eset), start(eset) + length(eset), production)
      match(i:Int) :
        if mark? :
          if markers[i] != current-marker :
            markers[i] = current-marker
            productions(return, i, start(eset) + length(eset), production)
        else :
          productions(return, i, start(eset) + length(eset), production)
    defmethod first-item (this, index:Int, production:Symbol) :
      val eset = sets[index]
      val i = bsearch(production!, items, start(eset), start(eset) + length(eset), production)
      match(i:Int) : items[i]
    defmethod clear-markers (this) :
      current-marker = current-marker + 1
    defmethod sets (this) :
      for eset in sets seq :
        for i in 0 to length(eset) seq :
          items[start(eset) + i]

;Binary search:
;It returns i such that all items at index < i satisfy key(xs[i]) < v.
defn bsearch<?T> (key:T -> Comparable, xs:Vector<?T>, start:Int, end:Int, v:Comparable) -> Int|False :
  ;All items with index less than i are known to be smaller than v.
  ;All items with index greater than j are known to be greater or equal to v.
  let loop (i:Int = start, j:Int = end) :
    if i == j :
      i when i < end and compare(key(xs[i]), v) == 0
    else :
      val m = (i + j) / 2
      if key(xs[m]) < v : loop(m + 1, j)
      else : loop(i, m)

;============================================================
;============== ProductionTable/ProductionSet ===============
;============================================================

deftype ProductionTable<T>
defmulti get<?T> (t:ProductionTable<?T>, key:Symbol) -> T
defmulti set<?T> (t:ProductionTable<?T>, key:Symbol, v:T) -> False
defmulti clear (t:ProductionTable) -> False

defn ProductionTable<T> (default:T) :
  val table = HashTable<Symbol,T>(default)
  new ProductionTable<T> :
    defmethod get (this, key:Symbol) : table[key]
    defmethod set (this, key:Symbol, v:T) : table[key] = v
    defmethod clear (this) : clear(table)

deftype ProductionSet
defmulti get (t:ProductionSet, key:Symbol) -> True|False
defmulti add (t:ProductionSet, key:Symbol) -> True|False
defmulti clear (t:ProductionSet) -> False

defn ProductionSet () :
  val keys = HashSet<Symbol>()
  new ProductionSet :
    defmethod get (this, key:Symbol) : keys[key]
    defmethod add (this, key:Symbol) : add(keys,key)
    defmethod clear (this) : clear(keys)

deftype CompletionSet
defmulti add (s:CompletionSet, item:EItem) -> True|False
defmulti get (s:CompletionSet, item:EItem) -> True|False
defmulti clear (s:CompletionSet) -> False

defn CompletionSet () :
  val keys = HashSet<[Int,Int,Int]>()
  new CompletionSet :
    defmethod add (this, item:EItem) :
      add(keys, [rule(item), num-parsed(item), parent(item)])
    defmethod get (this, item:EItem) :
      keys[[rule(item), num-parsed(item), parent(item)]]
    defmethod clear (this) :
      clear(keys)

;============================================================
;====================== Debugging ===========================
;============================================================

defn printable-stream (return:OutputStream -> ?) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      return(o)

defn format (grammar:Grammar, e:EItem) :
  within o = printable-stream() :
    val r = grammar[rule(e)]
    print(o, "[%_ =" % [name(r)])
    for (t in tokens(r), i in 0 to false) do :
      val prefix = " • " when num-parsed(e) == i else " "
      print-all(o, [prefix, t])
    if num-parsed(e) == length(tokens(r)) :
      print(o, " •")
    print(o, ", S%_]" % [parent(e)])
    if completion-cache(e) is EItem :
      val msg = format(grammar, completion-cache(e) as EItem)
      print(o, " (completed to %_)" % [msg])

defn format (grammar:Grammar, setlist:ESetList) :
  within o = printable-stream() :
    val o2 = IndentedStream(o)
    for (eset in sets(setlist), i in 0 to false) do :
      print(o, "\n") when i > 0
      print(o, "Set %_:" % [i])
      do(lnprint{o2, format(grammar,_)}, eset)

defn format (grammar:Grammar, eset:Vector<EItem>) :
  within o = printable-stream() :
    val o2 = IndentedStream(o)
    print(o, "ESet :")
    do(lnprint{o2, format(grammar,_)}, eset)

;  defn format (r:ParsedRange) :
;    new Printable :
;      defmethod print (o:OutputStream, this) :
;        val rule = grammar[rule(r)]
;        print(o, "[%_ to %_: %_]" % [start(r), end(r), rule])
;
;  defn format (e:ParseEdge) :
;    "%_ index %_ => %_" % [format(parent(e)), index(e), format(child(e))]
;
;  defn format (p:EParent) :
;    "%_ from %_ (index %_) => %_" % [grammar[rule(p)], start(p), index(p), format(child(p))]

;============================================================
;====================== Algorithm ===========================
;============================================================

defn parse (grammar:Grammar, input:Tuple<Symbol>) :
  val setlist = ESetList(grammar)
  val prediction-set = ProductionSet()
  val completion-set = CompletionSet()
  val production-count = ProductionTable<Int>(0)
  val parents = Vector<EParent>()
  val ranges = Vector<ParsedRange>()

  defn process-set (set-index:Int, current-set:Vector<EItem>, next-set:Vector<EItem>, next-input:Symbol|False) :
    ;Clear state
    clear-markers(setlist)
    clear(prediction-set)
    clear(completion-set)

    ;Iterate through each item
    for item in current-set do-all :
      match(upcoming(grammar,item)) :
        (t:GTerminal) : upcoming-terminal(item, t)
        (p:GProduction) : upcoming-production(item, p)
        (f:False) : end-of-rule(item)
      where :
        defn upcoming-terminal (item:EItem, t:GTerminal) :
          if next-input == /item(t) :
            add(next-set, inc-num-parsed(item))
        defn upcoming-production (item:EItem, t:GProduction) :
          if nullable?(grammar, name(t)) and not completion-set[item] :
            add(current-set, inc-num-parsed(item))
          if add(prediction-set, name(t)) :
            for rule in rules(grammar, name(t), next-input) do :
              add(current-set, EItem(rule, 0, set-index))
        defn end-of-rule (completed-item:EItem) :
          val prod = production(grammar,completed-item)
          if parent(completed-item) < set-index :
            within item = items(setlist, parent(completed-item), prod, true) :
              add(completion-set, item) when nullable?(grammar,prod)
              val item* = match(completion-cache(item)) :
                            (item*:EItem) : item*
                            (f:False) : inc-num-parsed(item)
              add(current-set, item*)

  defn compute-completion-cache (set-index:Int, current-set:Vector<EItem>) :
    ;Compute count table
    clear(production-count)
    for item in current-set do :
      val t = upcoming(grammar,item)
      match(t:GProduction) :
        production-count[name(t)] = production-count[name(t)] + 1
    ;Determine whether deterministic reduction
    defn deterministic-reduction? (item:EItem) :
      val num-tokens = length(tokens(grammar[rule(item)]))
      if num-parsed(item) == num-tokens - 1 :
        val t = upcoming(grammar,item)
        match(t:GProduction) : production-count[name(t)] == 1
    ;Compute completion
    defn complete (item:EItem) :
      if parent(item) < set-index :
        val pitem = first-item(setlist, parent(item), upcoming-production!(grammar,item))
        match(pitem:EItem) : completion-cache(pitem)
    ;Compute completions of all deterministic reductions.
    for item in current-set map! :
      if deterministic-reduction?(item) :
        match(complete(item)) :
          (c:EItem) : sub-completion-cache(item,c)
          (f:False) : sub-completion-cache(item, inc-num-parsed(item))
      else : item

  defn add-to-setlist (current-set:Vector<EItem>) :
    defn prod? (e:EItem) : upcoming(grammar,e) is GProduction
    add(setlist, filter(prod?, current-set))

  ;Debug print current set
  defn print-current-set (set-index:Int, current-set:Vector<EItem>) :
    println("Completed set %_" % [set-index])
    within indented() :
      do(println{format(grammar,_)}, current-set)

  defn record-completions (set-index:Int, current-set:Vector<EItem>) -> Int|False :
    defn complete? (item:EItem) : upcoming(grammar,item) is False
    var start-id:Int|False = false
    for item in filter(complete?, current-set) do :
      val id = length(ranges)
      (start-id = id) when rule(item) == 0
      add(ranges, ParsedRange(id, rule(item), parent(item), set-index))
      within pitem = items(setlist, parent(item), production(grammar, item), false) :
        add(parents, EParent(rule(pitem), parent(pitem), num-parsed(pitem), id))
    start-id

  defn process-all-sets () -> Int|False :
    ;Initialize current-set and next-set.
    val current-set = Vector<EItem>()
    val next-set = Vector<EItem>()
    add(current-set, EItem(0, 0, 0))
    ;Process sets until finished.
    let loop (set-index:Int = 0,
              current-set:Vector<EItem> = current-set,
              next-set:Vector<EItem> = next-set) :
      val next-input = input[set-index] when set-index < length(input)
      process-set(set-index, current-set, next-set, next-input)
      compute-completion-cache(set-index, current-set)
      ;print-current-set(set-index, current-set)
      add-to-setlist(current-set)
      val start-id = record-completions(set-index, current-set)
      if empty?(next-set) :
        start-id
      else :
        clear(current-set)
        loop(set-index + 1, next-set, current-set)

  ;Return -1 if a should take precedence over b during
  ;a right-to-left disambiguation sweep of the parse forest.
  defn compare-specificity (a:EParent, b:EParent) -> Int :
    ;Retrieve fields
    val parent-rule = grammar[rule(a)]
    val range-a = ranges[id(a)]
    val range-b = ranges[id(b)]
    val rule-a = grammar[rule(range-a)]
    val rule-b = grammar[rule(range-b)]

    defn compare-associativity () :
      switch(associativity(parent-rule)) :
        RightAssociative : compare(length(range-b), length(range-a))
        LeftAssociative : compare(length(range-a), length(range-b))
    defn compare-precedence () :
      compare(precedence(rule-a), precedence(rule-b))
    defn compare-order () :
      compare(rule(range-a), rule(range-b))
    val c1 = compare-associativity()
    if c1 == 0 :
      val c2 = compare-precedence()
      if c2 == 0 : compare-order()
      else : c2
    else : c1  

  ;Select a single tree after disambiguation.
  defn select-tree (start-id:Int) :
    val children-table = group-by(key, parents) where :
      defn key (p:EParent) :
        val child = ranges[id(p)]
        [rule(p), start(p), index(p), end(child)]
    println("Children Table:")
    do(println, children-table)
    
    defn children (id:Int, index:Int, end:Int) :
      val range = ranges[id]
      val key = [rule(range), start(range), index, end]
      val result = children-table[key]
      println("Children of range %_ index %_ finishing at end %_ = %_" % [id, index, end, result])
      result
    
    val select-ranges = Vector<Int>()
    val select-parents = Vector<EParent>()
    defn select (id:Int) -> Int :
      add(select-ranges, id)
      val range = ranges[id]
      val rule = grammar[rule(range)]
      val num-tokens = length(tokens(rule))
      let loop (index:Int = num-tokens - 1, end-position:Int = end(range)) :
        if index >= 0 :
          match(tokens(rule)[index]) :
            (t:GTerminal) :
              loop(index - 1, end-position - 1)
            (t:GProduction) :
              val children = children(id, index, end-position)
              val child = minimum(children, {compare-specificity(_, _) < 0})
              add(select-parents, child)
              val child-start = select(/id(child))
              loop(index - 1, child-start)
      start(range)        
    select(start-id)
    println("Selected Tree:")
    do(println, select-parents)
    println("Ranges:")
    do(println, select-ranges)
    
;    defn mark-used (r:ParsedRange) :
;      val rule = grammar[rule(r)]
;      val num-tokens = length(tokens(rule))
;      let loop (index:Int = 0, position:Int = start(r)) :
;        if index < num-tokens :
;          match(tokens(rule)[index]) :
;            (t:GProduction) :
;              val candidates = candidates(r, index, position)
;              val candidate = minimum(candidates, {most-specific(_, _) < 0})
;              add(kept-edges, candidate)
;              mark-used(child(candidate))
;              loop(index + 1, end(child(candidate)))
;            (t:GTerminal) :
;              loop(index + 1, position + 1)
;    mark-used(ParsedRange(0, 0, length(input)))    
      

;  defn* determine-reachable-graph () :
;    println("PARENTS:")
;    within indented() :
;      for p in parents do :
;        println(format(p))
;    val used-ranges = HashSet<ParsedRange>()
;    val edges = Vector<ParseEdge>()
;    val children-table = group-by(key, parents) where :
;      defn key (p:EParent) : [rule(p), start(p), index(p)]
;    defn children (r:ParsedRange, index:Int) :
;      val key = [rule(r), start(r), index]
;      children-table[key]
;    defn mark-used (r:ParsedRange) :
;      if add(used-ranges, r) :
;        val tokens = tokens(grammar[rule(r)])
;        let loop (index:Int = length(tokens) - 1,
;                  ends:List<Int> = List(end(r))) :
;          if index >= 0 :
;            match(tokens[index]) :
;              (t:GTerminal) :
;                loop(index - 1, map({_ - 1}, ends))
;              (t:GProduction) :
;                val child-relationships = to-list $
;                  for relation in children(r, index) filter :
;                    contains?(ends, end(child(relation)))
;                for rel in child-relationships do :
;                  add(edges, ParseEdge(r, index, child(rel)))
;                  mark-used(child(rel))
;                loop(index - 1, map(start{child(_)}, child-relationships))
;    mark-used(ParsedRange(0, 0, length(input)))
;    to-tuple(edges)
;
;  defn* disambiguate (edges:Tuple<ParseEdge>) :
;    println("PARSE EDGES:")
;    within indented() :
;      for e in edges do :
;        println(format(e))
;    val candidate-table = group-by(key, edges) where :
;      defn key (e:ParseEdge) : [parent(e), index(e)]
;    defn candidates (r:ParsedRange, index:Int, position:Int) :
;      for c in candidate-table[[r,index]] filter :
;        start(child(c)) == position
;    defn most-specific (a:ParseEdge, b:ParseEdge) -> Int :
;      defn compare-associativity (a:ParseEdge, b:ParseEdge) :
;        val parent-rule = grammar[rule(parent(a))]
;        switch(associativity(parent-rule)) :
;          RightAssociative : compare(length(child(a)), length(child(b)))
;          LeftAssociative : compare(length(child(b)), length(child(a)))
;      defn compare-precedence (a:ParseEdge, b:ParseEdge) :
;        val arule = grammar[rule(child(a))]
;        val brule = grammar[rule(child(b))]
;        compare(precedence(arule), precedence(brule))
;      defn compare-order (a:ParseEdge, b:ParseEdge) :
;        compare(rule(child(a)), rule(child(b)))
;      val c1 = compare-associativity(a, b)
;      if c1 == 0 :
;        val c2 = compare-precedence(a, b)
;        if c2 == 0 : compare-order(a, b)
;        else : c2
;      else : c1
;
;    val kept-edges = Vector<ParseEdge>()
;    defn mark-used (r:ParsedRange) :
;      val rule = grammar[rule(r)]
;      val num-tokens = length(tokens(rule))
;      let loop (index:Int = 0, position:Int = start(r)) :
;        if index < num-tokens :
;          match(tokens(rule)[index]) :
;            (t:GProduction) :
;              val candidates = candidates(r, index, position)
;              val candidate = minimum(candidates, {most-specific(_, _) < 0})
;              add(kept-edges, candidate)
;              mark-used(child(candidate))
;              loop(index + 1, end(child(candidate)))
;            (t:GTerminal) :
;              loop(index + 1, position + 1)
;    mark-used(ParsedRange(0, 0, length(input)))
;    to-tuple(kept-edges)

  defn main () :
    val start-id = process-all-sets()
    println("start-id = %_" % [start-id])
    println(format(grammar, setlist))
    println("Ranges:")
    do(println, ranges)
    println("Parents:")
    do(println, parents)
    match(start-id:Int) : select-tree(start-id)
    
    ;val edges = disambiguate(determine-reachable-graph())
    ;println("Disambiguated:")
    ;do(println{format(_)}, edges)


  main()

;============================================================
;======================= Test Case ==========================
;============================================================

defn example-grammar () :
  val E = GProduction(`E)
  val N = GTerminal(`N)
  val PLUS = GTerminal(`+)
  val TIMES = GTerminal(`x)
  val LPAREN = GTerminal(`L)
  val RPAREN = GTerminal(`R)
  [GRule(`S, [E])
   GRule(`E, [E PLUS E])
   GRule(`E, [E TIMES E], 1, RightAssociative)
   GRule(`E, [LPAREN E RPAREN])
   GRule(`E, [N])]

deftest print-grammar :
  val g = example-grammar()
  do(println, g)

let :;deftest parse :
  val g = example-grammar()
  ;parse(Grammar(g), to-tuple $ `(N x N x L N + N R x N x N + N x N x N))
  parse(Grammar(g), to-tuple $ `(N x N + N))

defn example-grammar-2 () :
  val S = GProduction(`S)
  val E = GProduction(`E)
  val F = GProduction(`F)
  val A = GTerminal(`A)
  val B = GTerminal(`B)
  val X = GTerminal(`X)
  val Y = GTerminal(`Y)
  [GRule(`Start, [S])
   GRule(`S, [E E X])
   GRule(`S, [F F Y])
   GRule(`E, [A A B])
   GRule(`F, [A A B])]

deftest parse-2 :
  val g = example-grammar-2()
  parse(Grammar(g), to-tuple $ `(A A B A A B Y))

defn example-grammar-3 () :
  val S = GProduction(`S)
  val E = GProduction(`E)
  val F = GProduction(`F)
  val A = GTerminal(`A)
  val X = GTerminal(`X)
  val Y = GTerminal(`Y)
  [GRule(`Start, [S])
   GRule(`S, [E F X])
   GRule(`S, [F E X])
   GRule(`S, [F F F Y])
   GRule(`E, [A A])
   GRule(`F, [A])]

deftest parse-3 :
  val g = example-grammar-3()
  parse(Grammar(g), to-tuple $ `(A A A X))

defn example-grammar-4 () :
  val S = GProduction(`S)
  val E = GProduction(`E)
  val A = GTerminal(`A)
  val X = GTerminal(`X)
  [GRule(`Start, [S])
   GRule(`S, [E E X])
   GRule(`E, [A A])
   GRule(`E, [A])]

deftest parse-4 :
  val g = example-grammar-4()
  parse(Grammar(g), to-tuple $ `(A A A A X))

defn example-grammar-5 () :
  #for E in [ES, E, IF-E, SCLAUSES, SCLAUSE, ECLAUSE] :
    val E = GProduction(`E)
  #for (X in [PLUS, TIMES, LPAREN, RPAREN, N, EQ, LET, IN, IF, COLON, ELSE, SWITCH],
        x in [+, x, L, R, N, =, let, in, if, :, else, switch]) :
    val X = GTerminal(`x)
  [GRule(`Start, [ES])
   GRule(`ES, [ES E])
   GRule(`ES, [])
   GRule(`E, [E PLUS E], 200, LeftAssociative)
   GRule(`E, [E TIMES E], 210, LeftAssociative)
   GRule(`E, [LPAREN E RPAREN])
   GRule(`E, [N])
   GRule(`E, [E EQ E])
   GRule(`E, [LET E EQ E IN E])
   GRule(`E, [IF-E])
   GRule(`IF-E, [IF E COLON E ELSE IF-E])
   GRule(`IF-E, [IF E COLON E ELSE COLON E])
   GRule(`E, [SWITCH LPAREN SCLAUSES ECLAUSE RPAREN])
   GRule(`E, [SWITCH LPAREN SCLAUSES RPAREN])
   GRule(`SCLAUSES, [SCLAUSES SCLAUSE])
   GRule(`SCLAUSES, [])
   GRule(`SCLAUSE, [E COLON E])
   GRule(`ECLAUSE, [ELSE COLON E])]

deftest grammar-calc :
  Grammar(example-grammar-5())

deftest parse-5 :
  val g = example-grammar-5()
  parse(Grammar(g), to-tuple $ `(
    switch L
      N : N x N
      N x N : N
      N + N : N + N
      else : N x N
    R))

deftest parse-6 :
  val g = example-grammar-5()
  parse(Grammar(g), to-tuple $ unwrap-all $ reader/read-file("test.txt"))

defn example-grammar-6 () :
  #for E in [ES, E] :
    val E = GProduction(`E)
  #for (X in [A B C],
        x in [a b c]) :
    val X = GTerminal(`x)
  [GRule(`Start, [ES])
   GRule(`ES, [E, ES])
   GRule(`ES, [])
   GRule(`E, [A])
   GRule(`E, [B C])]

deftest parse-7 :
  val g = example-grammar-6()
  parse(Grammar(g), to-tuple $ `(a a b c a a b c b c a a a a a a a a a a a a a a a a))

defn example-null-grammar () :
  #for X in [S Ap E] :
    val X = GProduction(`X)
  #for (X in [A],
        x in [a]) :
    val X = GTerminal(`x)
  [GRule(`Start, [S])
   GRule(`S, [Ap Ap Ap Ap])
   GRule(`Ap, [A])
   GRule(`Ap, [E])
   GRule(`E, [])]

deftest parse-null :
  val g = example-null-grammar()
  parse(Grammar(g), to-tuple $ `(a a a))

defn example-tricky-null-grammar () :
  #for E in [S, A, B] :
    val E = GProduction(`E)
  #for (X in [w, x, d],
        x in [w, x, d]) :
    val X = GTerminal(`x)
  [GRule(`Start, [S])
   GRule(`S, [w A d])
   GRule(`S, [A d])
   GRule(`S, [w B A A A d])
   GRule(`A, [x])
   GRule(`A, [])
   GRule(`B, [x])]

deftest parse-tricky-null :
  val g = example-tricky-null-grammar()
  parse(Grammar(g), to-tuple $ `(w x x d))

defn example-tricky-null-grammar-2 () :
  #for E in [B S A] :
    val E = GProduction(`E)
  #for (X in [w, x, d],
        x in [w, x, d]) :
    val X = GTerminal(`x)
  [GRule(`Start, [B])
   GRule(`B, [S])
   GRule(`B, [A])
   GRule(`S, [w x A A A A d])
   GRule(`A, [w x])
   GRule(`A, [])]

deftest parse-tricky-null-2 :
  val g = example-tricky-null-grammar-2()
  parse(Grammar(g), to-tuple $ `(w x w x d))