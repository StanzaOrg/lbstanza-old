;============================================================
;=============== defrenamer lang ============================
;============================================================

defpackage stz/renamer-lang :
   import core
   import verse
   import core/macro-utils
   import stz/lexer

;======== Parse Structures ========
definterface Arg
defstruct SimpleArg <: Arg :
   name: Symbol
   type: Symbol
defstruct MapArg <: Arg :
   type: Symbol
defstruct BeginArg <: Arg :
   args: List<Arg>
defstruct ScopeArg <: Arg :
   arg: Arg   
defstruct GroupArg <: Arg :
   arg: Arg
defstruct PublicArg <: Arg :
   arg: Arg
defstruct ProtectedArg <: Arg :
   arg: Arg
defstruct CustomArg <: Arg :
   exp
defstruct GotoArg <: Arg :
   type: Symbol
defstruct RegisterArg <: Arg :
   type: Symbol

defstruct Clause :
   node: Symbol
   arg: Arg   

defstruct Renamer :
   name: Symbol
   clauses: List<Clause>

defstruct DefRenamer :
   name: Symbol
   exp: Symbol
   type: Symbol
   eng: Symbol
   engtype
   renamers: List<Renamer>

;======== Syntax Definition ========
defsyntax stz/renamer-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      prefix-op = (defrenamer ?name:#sym (?exp:#sym : ?exptype:#sym, ?eng:#sym : ?engtype:#type) :
                      ?rs:#renamer ...) :
         val r = compile(DefRenamer(name, exp, exptype, eng, engtype, rs))
         #if-defined(DEBUG) :
            println(r)
         #else :   
            stz/langs/expande(r)

      renamer = (?name:#sym : (?cs:#clause ...)) : Renamer(name, cs)
      clause = (?node:#sym : ?arg:#arg) : Clause(node, arg)
      arg = (register ?type:#sym) : RegisterArg(type)
      arg = (goto ?type:#sym) : GotoArg(type)
      arg = (custom{?exp:#exp}) : CustomArg(exp)
      arg = (group{?args:#arg ...}) : GroupArg(BeginArg(args))
      arg = (public{?args:#arg ...}) : PublicArg(BeginArg(args))
      arg = (protected{?args:#arg ...}) : ProtectedArg(BeginArg(args))
      arg = ({?args:#arg ...}) : ScopeArg(BeginArg(args))
      arg = ((?args:#arg ...)) : BeginArg(args)
      arg = (~ _ : ?type:#sym) : MapArg(type)
      arg = (?name:#sym : ?type:#sym) : SimpleArg(name, type)

;======== Compilation ========
defstruct ReadProd :
   ret: Symbol
   name: Symbol
defstruct DoProd :
   ret: Symbol
   type: Symbol
   #name: Symbol
defstruct MapProd :
   type: Symbol
defstruct BuildProd :
   node: Symbol
   args: List<Symbol>
defstruct GotoProd :
   type: Symbol
defstruct CustomProd :
   exp
defstruct RegisterProd :
   type: Symbol
defstruct PushScope
defstruct PopScope
defstruct PushGroup
defstruct PopGroup
defstruct PushVisibility : (type: Symbol)
defstruct PopVisibility

defn to-prods (node:Symbol, get-node-args:Symbol -> List<Symbol>, a:Arg) :
   val field-table = HashTable<Symbol,Symbol>(symbol-hash)
   val prods = Vector<?>()

   defn get-#name (arg:Symbol) :      
      if not key?(field-table, arg) :
         val ret = gensym()
         add(prods, ReadProd(ret, arg))
         field-table[arg] = ret
         ret
      else :
         field-table[arg]

   defn build () :
      if more?(to-stream(field-table)) :
         add(prods, BuildProd(node, map(get-#name, get-node-args(node))))
         clear(field-table)

   defn loop (a:Arg) :
      match(a) :
         (a:SimpleArg) :
            val n = get-#name(name(a))
            val ret = gensym()
            add(prods, DoProd(ret, type(a), n))
            field-table[name(a)] = ret
         (a:MapArg) :
            build()
            add(prods, MapProd(type(a)))
         (a:BeginArg) :
            do(loop, args(a))
         (a:ScopeArg) :
            add(prods, PushScope())
            loop(arg(a))
            add(prods, PopScope())
         (a:GroupArg) :
            add(prods, PushGroup())
            loop(arg(a))
            add(prods, PopGroup())
         (a:PublicArg) :
            add(prods, PushVisibility(`Public))
            loop(arg(a))
            add(prods, PopVisibility())
         (a:ProtectedArg) :
            add(prods, PushVisibility(`Protected))
            loop(arg(a))
            add(prods, PopVisibility())
         (a:CustomArg) :
            build()
            add(prods, CustomProd(exp(a)))
         (a:GotoArg) :
            build()
            add(prods, GotoProd(type(a)))
         (a:RegisterArg) :
            build()
            add(prods, RegisterProd(type(a)))

   loop(a)
   build()
   prods

defn fill-each<?T> (f: T -> Streamable<KeyValue<Symbol,?>>, xs:Streamable<?T>) :
   nested(stream(f, xs))

defn compile (d:DefRenamer) :
   ;Temporary names of production functions
   defn memoize<?T> (f: Symbol -> ?T) :
      val table = HashTable<Symbol,T>(symbol-hash)
      fn (x:Symbol) :
         if not key?(table, x) :
            table[x] = f(x)
         table[x]
   val get-#type = memoize(gensym{})
   defn #type (p:DoProd|MapProd|GotoProd) : get-#type(type(p))
   defn #type (r:Renamer) : get-#type(name(r))

   ;Getting the node argument structure
   val structure = stz/ast-lang/nodes(stz/ast-lang/AST-TABLE[type(d)])
   defn get-node-args (n:Symbol) : lookup!(structure, n)

   ;Compiling an argument
   defn compile (node-name:Symbol, a:Arg) :
      val ps = to-prods(node-name, get-node-args, a)
      defn loop (i:Int) :
         if i < length(ps) :
            match(ps[i]) :
               (p:ReadProd) :
                  fill-template(`(let : (val ret = name(e), body)), [
                     `ret => ret(p)
                     `name => name(p)
                     `e => exp(d)
                     `body => loop(i + 1)])
               (p:DoProd) :
                  fill-template(`(let : (val ret = f(x), body)), [
                     `ret => ret(p)
                     `f => #type(p)
                     `x => #name(p)
                     `body => loop(i + 1)])
               (p:MapProd) :
                  fill-template(`(let : (val e = map(f, e), body)), [
                     `f => #type(p)
                     `e => exp(d)
                     `body => loop(i + 1)])
               (p:BuildProd) :
                  fill-template(`(let : (val e = node(args), body)), [
                     `e => exp(d)
                     `node => node(p)
                     `args => splice(args(p))
                     `body => loop(i + 1)])
               (p:GotoProd) :
                  fill-template(`(let : (val e = f(e), body)), [
                     `e => exp(d)
                     `f => #type(p)
                     `body => loop(i + 1)])
               (p:CustomProd) :
                  fill-template(`(let : (val e = exp, body)), [
                     `e => exp(d)
                     `exp => exp(p)
                     `body => loop(i + 1)])
               (p:RegisterProd) :
                  fill-template(`(let : (val e = register-type(e), body)), [
                     `e => exp(d)
                     `register-type => to-symbol("register-~" << [type(p)])
                     `body => loop(i + 1)])
                     
               (p:PushScope) :
                  fill-template(`(push-scope(eng), body), [
                     `eng => eng(d)
                     `body => loop(i + 1)])
               (p:PopScope) :
                  fill-template(`(pop-scope(eng), body), [
                     `eng => eng(d)
                     `body => loop(i + 1)])
               (p:PushGroup) :
                  fill-template(`(push-group(eng), body), [
                     `eng => eng(d)
                     `body => loop(i + 1)])
               (p:PopGroup) :
                  fill-template(`(pop-group(eng), body), [
                     `eng => eng(d)
                     `body => loop(i + 1)])
               (p:PushVisibility) :
                  fill-template(`(push-visibility(eng, vis()), body), [
                     `eng => eng(d)
                     `vis => type(p)
                     `body => loop(i + 1)])
               (p:PopVisibility) :
                  fill-template(`(pop-visibility(eng), body), [
                     `eng => eng(d)
                     `body => loop(i + 1)])
         else :
            exp(d)
      loop(0)

   defn compile (r:Renamer) :
      val template = `(
         defn name (e:type) :
            match(e) :
               clauses{(e:Node) : arg})
      fill-template(template, [
         `name => #type(r)
         `e => exp(d)
         `type => type(d)
         `clauses => for c in clauses(r) fill-each : [
            `Node => node(c)
            `arg => compile(node(c), arg(c))]])

   val template = `(
      defn name (e:type, eng:engtype) :
         renamers
         renamer0(e))
   fill-template(template, [
      `e => exp(d)
      `type => type(d)
      `eng => eng(d)
      `engtype => engtype(d)
      `renamers => map(compile, renamers(d))
      `renamer0 => #type(head(renamers(d)))])