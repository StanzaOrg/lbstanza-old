defpackage stz/types :
  import core
  import collections

;============================================================
;====================== Types ===============================
;============================================================

;Represents first-class types, types that may appear within
;type expressions.
public deftype Type

;Represents a ground type with some parametric arguments.
public defstruct TOf <: Type :
  n:Int
  args:Tuple<Type> with:
    default => []
with:
  printer => true

;Represents a finite tuple type.
public defstruct TTuple <: Type :
  args:Tuple<Type>
with:
  printer => true

;Represents the ? type.
public defstruct TGradual <: Type
with:
  printer => true

;Represents the function type.
public defstruct TArrow <: Type :
  a1:Tuple<Type>
  a2:Type
with:
  printer => true

;Represents the Void type.
public defstruct TBot <: Type
with:
  printer => true

;Represents the intersection type.
public defstruct TAnd <: Type :
  a:Type
  b:Type
with:
  printer => true

;Represents the union type.
public defstruct TOr <: Type :
  a:Type
  b:Type
with:
  printer => true

;Represents a type variable.
public defstruct TVar <: Type :
  n:Int
  name:Symbol|False
with:
  printer => true

;Represents a type that has yet to be solved.
public defstruct TUVar <: Type :
  n:Int
with:
  printer => true

;Represents a literal type that is used only for inference
;of tuple-getters.
public defstruct LitType <: Type :
  value:Int
with:
  printer => true

;------------------------------------------------------------
;-------------------- Defn Definitions ----------------------
;------------------------------------------------------------

;Represents a type that can only be used for 'defn' definitions.
public defstruct TFunction <: Type :
  targs:Tuple<Int>
  cargs:Tuple<Int>
  a1:Tuple<FArg> with: (ensure => good-fn-args!)
  a2:Type with: (ensure => user-type!)
with:
  printer => true

;Used within a TFunction to represent a capturing position.
public defstruct TCap <: Type :
  n:Int
  name:Symbol|False
with:
  printer => true

;Represents an argument specification with a TFunction.
public deftype FArg

;Retrieve the type of the argument.
public defmulti type (arg:FArg) -> Type

;Represents a normal position argument.
public defstruct PositionalArg <: FArg :
  optional?:True|False
  type:Type with: (as-method => true)
with:
  printer => true

;Represents a keyword argument.
public defstruct KeywordArg <: FArg :
  name:Symbol
  optional?:True|False
  type:Type with: (as-method => true)
with:
  printer => true

;Represents a variable-arity argument.
public defstruct VarArg <: FArg :
  type:Type with: (as-method => true)
with:
  printer => true

;============================================================
;======================= Mappers ============================
;============================================================

public deftype TypeItem :
  Type <: TypeItem
  FArg <: TypeItem

public defn map<?T> (f:TypeItem -> TypeItem, x:TypeItem&?T) -> T :
  defn h (x:Type) : f(x) as Type
  defn h (x:FArg) : f(x) as FArg
  defn h (xs:Tuple<Type>) : map(h,xs)
  defn h (xs:Tuple<FArg>) : map(h,xs)

  val result = match(x) :
    (x:TOf) : TOf(n(x), h(args(x)))
    (x:TTuple) : TTuple(h(args(x)))
    (x:TGradual) : x
    (x:TArrow) : TArrow(h(a1(x)), h(a2(x)))
    (x:TBot) : x
    (x:TAnd) : TAnd(h(a(x)), h(b(x)))
    (x:TOr) : TOr(h(a(x)), h(b(x)))
    (x:TVar) : x
    (x:TUVar) : x
    (x:LitType) : x
    (x:TFunction) : TFunction(targs(x), cargs(x), h(a1(x)), h(a2(x)))
    (x:TCap) : x
    (x:PositionalArg) : PositionalArg(optional?(x), h(type(x)))
    (x:KeywordArg) : KeywordArg(name(x), optional?(x), h(type(x)))
    (x:VarArg) : VarArg(h(type(x)))
  result as TypeItem&T

public defn do (f:TypeItem -> ?, x:TypeItem) -> False :
  defn g (x:TypeItem) : (f(x), x)
  map(g, x)
  false

public defn all? (f:TypeItem -> True|False, x:TypeItem) -> True|False :
  label<True|False> return :
    for xi in x do :
      return(false) when not f(xi)
    true

public defn any? (f:TypeItem -> True|False, x:TypeItem) -> True|False :
  label<True|False> return :
    for xi in x do :
      return(true) when f(xi)
    false

public defn none? (f:TypeItem -> True|False, x:TypeItem) -> True|False :
  label<True|False> return :
    for xi in x do :
      return(false) when f(xi)
    true

;============================================================
;================== Categories of Types =====================
;============================================================

;Types that can be used by the user in type expressions.
public defn user-type? (t:Type,
                        include-uvar?:True|False) -> True|False :
  match(t) :
    (t:TUVar) :
      include-uvar?
    (t:TOf|TGradual|TArrow|TBot|TAnd|TOr|TVar) :
      all?(user-type?{_ as Type, include-uvar?}, t)
    (t) :
      false

;Types that can be used by the user for the types of fnargs.
public defn fnarg-type? (t:Type) -> True|False :
  match(t) :
    (t:TOf|TGradual|TArrow|TBot|TAnd|TOr|TVar|TCap) :
      all?(fnarg-type?{_ as Type}, t)
    (t) :
      false

;A FArg is typically used as a specification for the allowed
;arguments to a function. We also use it to represent the
;values that a function is called with, but in this case
;the optional? fields don't have any meaning, so we
;require them to be false.
public defn used-as-value? (a:FArg) -> True|False :
  match(a) :
    (a:PositionalArg) : not optional?(a)
    (a:KeywordArg) : not optional?(a)
    (a:VarArg) : false

;============================================================
;=================== Preconditions ==========================
;============================================================

;Returns true if the given arguments are good.
defn good-fn-args? (args:Tuple<FArg>) -> True|False :
  val num-pos-args = count({_ is PositionalArg}, args)
  val num-args = length(args)
  val keywords = HashSet<Symbol>()
  for (a in args, i in 0 to false) all? :
    fnarg-type?(type(a)) and
    match(a) :
      (a:PositionalArg) :
        true
      (a:KeywordArg) :
        add(keywords, name(a)) and i >= num-pos-args
      (a:VarArg) :
        i == num-args - 1

;Ensure arguments are good.
defn good-fn-args! (description:String, args:Tuple<FArg>) :
  if not good-fn-args?(args) :
    fatal("Bad arguments given to %_." % [description])

;Ensure type is a user-type.
defn user-type! (description:String, t:Type) :
  if not user-type?(t, true) :
    fatal("Bad type given to %_." % [description])