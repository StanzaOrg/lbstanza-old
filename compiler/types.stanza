#use-added-syntax(ast-lang2)
defpackage stz/types :
  import core
  import collections

;============================================================
;=================== Common Multis ==========================
;============================================================

;Retrieve the type of the argument.
public defmulti type (arg:FArg) -> Type
public defmulti type (arg:LSFArg) -> LSType

;============================================================
;====================== Types ===============================
;============================================================

public defast :

  ;----------------------------------------------------------
  ;---------------------- Types -----------------------------
  ;----------------------------------------------------------

  defnodes Type <: Hashable & Equalable :
    common-options :
      printer => true
      equalable => true
      hashable => true
      
    ;Represents a class.
    TOf : (n:Int, args:Tuple<Type> with: (default => []))

    ;Represents a finite tuple type.
    TTuple : (args:Tuple<Type>)

    ;Represents the ? type.
    TGradual : ()

    ;Represents the function type.
    TArrow : (a1:Tuple<Type>, a2:Type)

    ;Represents the Void type.
    TBot : ()

    ;Represents the intersection type.
    TAnd : (a:Type, b:Type)

    ;Represents the union type.
    TOr : (a:Type, b:Type)

    ;Represents a type variable.
    TVar : (n:Int, name:Symbol|False with: (default => false))

    ;Represents a type that has yet to be solved.
    TUVar : (n:Int)

    ;Represents a literal type that is used only for inference
    ;of tuple-getters.
    LitType : (value:Int)

    ;Represents a type that can only be used for 'defn' definitions.
    TFunction :
      targs:Tuple<Int>
      cargs:Tuple<Int>
      a1:Tuple<FArg> with: (ensure => good-fn-args!)
      a2:Type with: (ensure => user-type!)

    ;Used within a TFunction to represent a capturing position.
    TCap : (n:Int, name:Symbol|False)

    ;Represents the Top type. Only used for
    ;inference purposes.
    TTop : ()

  ;----------------------------------------------------------
  ;-------------------- LoStanza Types ----------------------
  ;----------------------------------------------------------

  defnodes LSType <: Hashable & Equalable :
    common-options :
      printer => true
      equalable => true
      hashable => true

    ;Represents the primitive numbers.
    ByteT: ()
    IntT: ()
    LongT: ()
    FloatT: ()
    DoubleT: ()

    ;Used for representing the void pointer.
    UnknownT: ()
    
    ;Used for variable-length LoStanza types.
    RestT: (type:LSType)

    ;Represents the ptr<T> type.
    PtrT: (type:LSType)

    ;Represents the ref<T> type.
    RefT: (type:Type)

    ;Represents a function in LoStanza.
    FnT: (a:Tuple<LSType>, r:False|LSType, b:LSType)

    ;Represents a struct.
    StructT: (n:Int, args:Tuple<Type> with: (default => []))

    ;Represents a LoStanza type that has yet to be solved.
    UVarT: (n:Int)

    ;Represents a type that can only be used for 'lostanza defn' definitions.
    TLSFunction:
      targs:Tuple<Int>
      cargs:Tuple<Int>
      a1:Tuple<LSFArg>
      a2:LSType

  ;----------------------------------------------------------
  ;-------------- Argument Specification --------------------
  ;----------------------------------------------------------

  defnodes FArg <: Hashable & Equalable :  
    common-options :
      printer => true
      equalable => true
      hashable => true      
      
    ;Represents a normal positional argument.
    PositionalArg :
      optional?:True|False
      type:Type with: (as-method => true)

    ;Represents a keyword argument.
    KeywordArg :
      name:Symbol
      optional?:True|False
      type:Type with: (as-method => true)

    ;Represents a variable-arity argument.
    VarArg :
      name:Symbol
      type:Type with: (as-method => true)

  ;----------------------------------------------------------
  ;------------- LoStanza Argument Specification ------------
  ;----------------------------------------------------------

  defnodes LSFArg <: Hashable & Equalable :
    common :
      type:LSType with: (as-method => true)
      
    common-options :
      printer => true
      equalable => true
      hashable => true

    ;Represents a normal positional argument.
    LSPositionalArg :
      optional?:True|False

    ;Represents a keyword argument.
    LSKeywordArg :
      name:Symbol
      optional?:True|False

    ;Represents a variable-arity argument.
    LSVarArg :
      name:Symbol

  ;----------------------------------------------------------
  ;-------------------- Mappers and Doers -------------------
  ;----------------------------------------------------------
  defmapper (f:TypeItem -> TypeItem) :
    (x:Type) : f(x) as Type
    (x:Tuple<Type>) : map({f(_) as Type}, x)
    (x:Tuple<FArg>) : map({f(_) as FArg}, x)
    (x:Tuple<LSFArg>) : map({f(_) as LSFArg}, x)
    (x:LSType) : f(x) as LSType
    (x:Tuple<LSType>) : map({f(_) as LSType}, x)
    (x:False|LSType) : (f(x as LSType) as LSType) when x is LSType

  defdoer (f:TypeItem -> ?) :
    (x:Type) : f(x)
    (x:Tuple<Type>) : do(f,x)
    (x:Tuple<FArg>) : do(f,x)
    (x:Tuple<LSFArg>) : do(f,x)
    (x:LSType) : f(x)
    (x:Tuple<LSType>) : do(f,x)
    (x:False|LSType) : f(x as LSType) when x is LSType

  ignore :
    True|False
    Int
    Symbol|False
    Symbol
    Tuple<Int>

  make-mapper :
    func: TypeItem -> TypeItem
    item: TypeItem
    nodes: (FArg, Type, LSType)

  make-doer :
    func: TypeItem -> ?
    item: TypeItem
    nodes: (FArg, Type, LSType)
    

;============================================================
;======================= Mappers ============================
;============================================================

public deftype TypeItem :
  Type <: TypeItem
  LSType <: TypeItem
  FArg <: TypeItem
  LSFArg <: TypeItem

public defn all? (f:TypeItem -> True|False, x:TypeItem) -> True|False :
  label<True|False> return :
    for xi in x do :
      return(false) when not f(xi)
    true

public defn any? (f:TypeItem -> True|False, x:TypeItem) -> True|False :
  label<True|False> return :
    for xi in x do :
      return(true) when f(xi)
    false

public defn none? (f:TypeItem -> True|False, x:TypeItem) -> True|False :
  label<True|False> return :
    for xi in x do :
      return(false) when f(xi)
    true

;============================================================
;===================== Simplifiers ==========================
;============================================================

;Eliminates redundancy in TOr, and TAnd types.
public defn simplify (t:Type) -> Type :
  match(t) :
    (t:TOr) :
      val ts = simplified-or-types(t)
      if empty?(ts) : TBot()
      else : reduce(TOr,ts)
    (t:TAnd) :
      val ts = simplified-and-types(t)
      if empty?(ts) : TTop()
      else : reduce(TAnd,ts)
    (t) :
      map(simplify{_ as Type}, t)

;Simplify the given and types.
defn simplified-and-types (t:TAnd) -> Tuple<Type> :
  label<Tuple<Type>> return :
    val table = HashSet<Type>()
    let loop (t:Type = t) :
      match(t:TAnd) :
        loop(a(t))
        loop(b(t))
      else :
        match(simplify(t)) :
          (st:TTop) : false
          (st:TBot) : return([TBot()])
          (st) : add(table,st)
    to-tuple(table)

;Simplify the given or types.
defn simplified-or-types (t:TOr) -> Tuple<Type> :
  label<Tuple<Type>> return :
    val table = HashSet<Type>()
    let loop (t:Type = t) :
      match(t:TOr) :
        loop(a(t))
        loop(b(t))
      else :
        match(simplify(t)) :
          (st:TTop) : return([TTop()])
          (st:TBot) : false
          (st) : add(table,st)
    to-tuple(table)

;============================================================
;=================== Substitute Variables ===================
;============================================================

;Perform the given substitutions into the given type.
public defn sub (t:Type, env:Seqable<KeyValue<Int, Type>>) -> Type :
  ;Sanity check.
  if not user-type?(t,false) :
    fatal("Illegal type for substitution: %_." % [t])

  ;Put substitutions in table.
  val table = to-inttable<Type>(env)

  ;Recursively substitute all TVar.
  let loop (t:Type = t) :
    match(t) :
      (t:TVar) : get?(table, n(t), t)
      (t) : map(loop{_ as Type}, t)

;Perform the given substitutions into the given type, treating
;captures specially.
;It is assumed that if value(entry) is Int, then it is the identifier
;of a TUVar.
public defn sub-caps (t:Type, env:Seqable<KeyValue<Int,Type|Int>>) -> Type :
  ;Sanity check.
  if not fnarg-type?(t,false) :
    fatal("Illegal type for substitution: %_." % [t])

  ;Put substitutions in table.
  val table = to-inttable<Type|Int>(env)

  ;Recursively substitute all TVar.
  let loop (t:Type = t) :
    match(t) :
      (t:TVar) :
        match(get?(table,n(t))) :
          (t:Type) : t
          (n:Int) : TUVar(n)
          (f:False) : t
      (t:TCap) :
        match(get?(table,n(t))) :
          (t:Type) : t
          (n:Int) : TCap(n,false)
          (f:False) : t          
      (t) :
        map(loop{_ as Type}, t)  

;Convenience: Perform on multiple types.
public defn sub-caps (ts:Tuple<Type>, env:Seqable<KeyValue<Int,Type|Int>>) -> Tuple<Type> :
  println("[TODO] Slow implementation")
  map(sub-caps{_, to-tuple(env)}, ts)

;Convenience: Perform on multiple types.
public defn sub (ts:Tuple<Type>, env:Seqable<KeyValue<Int,Type>>) -> Tuple<Type> :
  println("[TODO] Slow implementation")
  map(sub{_, to-tuple(env)}, ts)

;============================================================
;================== Uncap Types =============================
;============================================================

;Convert all captured variables to TVar.
public defn uncap (t:Type) -> Type :
  match(t:TCap) : TVar(n(t),false)
  else : map(uncap{_ as Type}, t)

;============================================================
;=========== Instantiation of Polymorphic Functions =========
;============================================================

;Represents one particular instantiation of a TFunction or TLFunction.
;If args[1] = 4, it means that the second argument passed to the
;instantiated function actually corresponds to argument 5 in the original
;function.
public defstruct FnInst :
  args:Tuple<InstArg>
with:
  printer => true

;Represents which function arg a value is provided to.
public defstruct InstArg :
  arg-index:Int
  mode:ArgMode

;Represents the mode in which a provided value is passed to
;a function argument.
public defenum ArgMode :
  ToPositionalArg
  ToVarArg
  ToKeywordArg
  ToKeywordVarArg

;Represent the arities of a function.
defstruct FnArities :
  targ-arity:Int
  min-arity:Int
  max-arity:Int
  num-optional:Int
  var-arity:True|False

;Return true if FnArities represents a fixed arity function.
defn fixed-arity? (a:FnArities) -> True|False :
  num-optional(a) == 0 and not var-arity(a)

;Compute the arities of a function.
defn arities (func:TFunction) -> FnArities :
  val num-required = to-seq(0 to false)
  val num-optional = to-seq(0 to false)
  var var-arity:True|False = false
  for arg in a1(func) do :
    match(arg) :
      (arg:PositionalArg) :
        if optional?(arg) : next(num-optional)
        else : next(num-required)
      (arg:KeywordArg) :
        false
      (arg:VarArg) :
        var-arity = true
  FnArities(length(targs(func)),
            peek(num-required),
            peek(num-required) + peek(num-optional),
            peek(num-optional),
            var-arity)

;Instantiate a function to be called with the given arguments.
public defn instantiate (func:TFunction, tarity:Int, args:Tuple<FArg>) -> FnInst|False :
  ;Compute the arities of the function.
  val arities = arities(func)

  ;Classify given arguments into positional and keywords arguments.
  val given-pos-args = Vector<PositionalArg>()
  val given-keyword-args = HashTable<Symbol,KeywordArg>()
  for a in args do :
    match(a) :
      (a:PositionalArg) : add(given-pos-args, a)
      (a:KeywordArg) : given-keyword-args[name(a)] = a

  ;Classify expected arguments into positional and keyword arguments.
  val expected-pos-args = Vector<PositionalArg>()
  val expected-keyword-args = HashTable<Symbol,KeywordArg>()
  var expected-vararg:VarArg|False = false
  for a in a1(func) do :
    match(a) :
      (a:PositionalArg) : add(expected-pos-args, a)
      (a:KeywordArg) : expected-keyword-args[name(a)] = a
      (a:VarArg) : expected-vararg = a

  ;Compute whether the function arity is correct.
  defn correct-arity? () -> True|False :
    ;Determine whether max-arity applies.
    val max-arity-applies? = match(expected-vararg) :
      (vararg:VarArg) : key?(given-keyword-args, name(vararg))
      (f:False) : true
    ;Ensure arity within range.
    val n = length(given-pos-args)
    if max-arity-applies? :
      n >= min-arity(arities) and n <= max-arity(arities)
    else :
      n >= min-arity(arities)

  ;Return true if 'name' is the name of the expected vararg.
  defn vararg-name? (name:Symbol) -> True|False :
    match(expected-vararg:VarArg) :
      name == /name(expected-vararg)

  ;Compute whether the correct keyword arguments are given.
  defn correct-keywords? () -> True|False :
    val required-is-given? =
      for a in values(expected-keyword-args) all? :
        optional?(a) or key?(given-keyword-args, name(a))
    val given-is-expected? =
      for a in values(given-keyword-args) all? :
        key?(expected-keyword-args,name(a)) or vararg-name?(name(a))
    required-is-given? and given-is-expected?

  ;Compute the instantiated arguments.
  defn compute-inst-args () -> Tuple<InstArg> :
    ;Compute the vector of InstArg corresponding to the positional arguments.
    val num-given = length(given-pos-args)
    val num-used-optional = min(num-optional(arities), num-given - min-arity(arities))
    val num-used-varargs = max(0, num-given - max-arity(arities))
    val num-optional = to-seq(0 to false)
    val vararg-index = index-when({_ is VarArg}, a1(func))
    val pos-args = Vector<InstArg>()
    for (a in a1(func), i in 0 to false) do :
      match(a:PositionalArg) :
        val used-arg? =
          if optional?(a) : next(num-optional) < num-used-optional
          else : true
        add(pos-args, InstArg(i, ToPositionalArg)) when used-arg?
    for i in 0 to num-used-varargs do :
      add(pos-args, InstArg(vararg-index as Int, ToVarArg))

    ;Compute the InstArgs corresponding to the given keyword arguments.
    val keyword-args = HashTable<Symbol,InstArg>()
    for (a in a1(func), i in 0 to false) do :
      match(a:KeywordArg) :
        if key?(given-keyword-args, name(a)) :
          keyword-args[name(a)] = InstArg(i, ToKeywordArg)
          
    ;Add the vararg keyword argument if used.
    match(expected-vararg:VarArg) :
      if key?(given-keyword-args, name(expected-vararg)) :
        keyword-args[name(expected-vararg)] = InstArg(vararg-index as Int, ToKeywordVarArg)

    ;Finally iterate through the actual given arguments and read
    ;off their corresponding function arguments.
    val pos-arg-index = to-seq(0 to false)
    for arg in args map :
      match(arg) :
        (arg:PositionalArg) : pos-args[next(pos-arg-index)]
        (arg:KeywordArg) : keyword-args[name(arg)]
    
  ;Launch the overall algorithm.
  if correct-arity?() and correct-keywords?() :
    FnInst(compute-inst-args())

;Instantiate a function to be passed to an expected type.
public defn instantiate (func:TFunction, expected:Type) -> Tuple<FnInst> :
  ;Compute function arities.
  val arities = arities(func)
  
  ;Compute whether function can be instantiated in this
  ;context.
  defn no-required-keywords? () -> True|False :
    for a in a1(func) none? :
      match(a:KeywordArg) : not optional?(a)
  defn no-targs? () -> True|False :
    targ-arity(arities) == 0

  ;Compute set of all arities indicated by the given type,
  ;or mark that we want all possible arities.
  defn instantiated-arities () -> Tuple<Int> :
    val arity-set = HashSet<Int>()
    let loop (t:Type = expected) :
      match(t) :
        (t:TAnd|TOr) : (loop(a(t)), loop(b(t)))
        (t:TArrow) : add(arity-set, length(a1(t)))
        (t:TGradual|TTop) : add-all(arity-set, min-arity(arities) through max-arity(arities))
        (t) : false
    to-tuple(arity-set)

  ;Return true if func supports n as an arity.
  defn supports-arity? (n:Int) -> True|False :
    if var-arity(arities) : n >= min-arity(arities)
    else : n >= min-arity(arities) and n <= max-arity(arities)

  ;Compute the instantiated function. Assumes it is supported.
  defn instantiate-arity (n:Int) -> FnInst :
    val num-used-optional = min(num-optional(arities), n - min-arity(arities))
    val num-optional = to-seq(0 to false)
    val num-varargs = max(0, n - max-arity(arities))
    val args = Vector<InstArg>()
    for (a in a1(func), i in 0 to false) do :
      match(a) :
        (a:PositionalArg) :
          if optional?(a) :
            if next(num-optional) < num-used-optional :
              add(args, InstArg(i, ToPositionalArg))
          else :
            add(args, InstArg(i, ToPositionalArg))
        (a:VarArg) :
          for j in 0 to num-varargs do :
            add(args, InstArg(i, ToVarArg))
        (a:KeywordArg) :
          false
    FnInst(to-tuple(args))

  ;Launch!
  if no-required-keywords?() and no-targs?() :
    if fixed-arity?(arities) :
      [instantiate-arity(min-arity(arities))]
    else :
      val ns = instantiated-arities()
      to-tuple $ seq(instantiate-arity,
        filter(supports-arity?, ns))
  else :
    []

;Return the instantiated arrow for the given instantiation.
public defn arrow (t:TFunction, inst:FnInst, tuple-n:Int) -> TArrow :
  ;Retrieve the argument types.
  val a1 = for arg in args(inst) map :
    val farg = a1(t)[arg-index(arg)]
    if mode(arg) == ToKeywordVarArg : TOf(tuple-n, [type(farg)])
    else : type(farg)
  ;Form the resulting TArrow.
  TArrow(a1, a2(t))  


;============================================================
;================== Categories of Types =====================
;============================================================

;Types that can be used by the user in type expressions.
public defn user-type? (t:Type,
                        include-uvar?:True|False) -> True|False :
  match(t) :
    (t:TUVar) :
      include-uvar?
    (t:TOf|TGradual|TArrow|TBot|TAnd|TOr|TVar|TTuple) :
      all?(user-type?{_ as Type, include-uvar?}, t)
    (t) :
      false

;Types that can be used by the user for the types of fnargs.
public defn fnarg-type? (t:Type,
                         include-uvar?:True|False) -> True|False :
  match(t) :
    (t:TUVar) :
      include-uvar?
    (t:TOf|TGradual|TArrow|TBot|TAnd|TOr|TVar|TTuple|TCap) :
      all?(fnarg-type?{_ as Type, include-uvar?}, t)
    (t) :
      false

;A FArg is typically used as a specification for the allowed
;arguments to a function. We also use it to represent the
;values that a function is called with, but in this case
;the optional? fields don't have any meaning, so we
;require them to be false.
public defn used-as-value? (a:FArg) -> True|False :
  match(a) :
    (a:PositionalArg) : not optional?(a)
    (a:KeywordArg) : not optional?(a)
    (a:VarArg) : false

;============================================================
;=================== Preconditions ==========================
;============================================================

;Returns true if the given arguments are good.
defn good-fn-args? (args:Tuple<FArg>) -> True|False :
  val num-pos-args = count({_ is PositionalArg}, args)
  val num-args = length(args)
  val keywords = HashSet<Symbol>()
  for (a in args, i in 0 to false) all? :
    fnarg-type?(type(a), true) and
    match(a) :
      (a:PositionalArg) :
        true
      (a:KeywordArg) :
        add(keywords, name(a)) and i >= num-pos-args
      (a:VarArg) :
        i == num-args - 1

;Ensure arguments are good.
defn good-fn-args! (description:String, args:Tuple<FArg>) :
  if not good-fn-args?(args) :
    fatal("Bad arguments given to %_: %_" % [description, args])

;Ensure type is a user-type.
defn user-type! (description:String, t:Type) :
  if not user-type?(t, true) :
    fatal("Bad type given to %_." % [description])

;Ensure that a TFunction has no targs or cargs remaining.
public defn no-type-args! (description:String, f:TFunction) -> False :
  if not (empty?(targs(f)) and empty?(cargs(f))) :
    fatal("Type given to %_ contains type variables." % [description])

;Create an ensure to use on tuples.
public defn tuple-of!<T> (f:(String, T) -> ?) :
  fn (description:String, xs:Tuple<T>) :
    for x in xs do : f(description, x)

;Ensure an appropriate type for the type of a function argument.
public defn fnarg-type! (description:String, v:Type) :
  if not fnarg-type?(v,true) :
    fatal("Type given to %_ is not a function argument type." % [description])