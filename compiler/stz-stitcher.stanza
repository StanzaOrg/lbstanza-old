defpackage stz/stitcher :
  import core
  import collections
  import stz/asm-ir
  import stz/codegen
  import stz/dl-ir
  import stz/vm-ir
  import stz/utils
  import stz/padder
  import stz/const-pool
  import stz/dyn-tree
  import stz/typeset
  import stz/backend
  import stz/algorithms
  import stz/bindings
  import stz/conversion-utils
  import stz/dispatch-dag with:
    prefix(Branch) => Dag
  import stz/set-utils
  import stz/binary-tree

;<DOC>=======================================================
;===================== Documentation ========================
;============================================================

Input:
  Functions compiled into ASM IR.  
Output:
  Pure ASM IR

Constructs that are removed:
  LocalMem
  TagImm
  StackMap
  LinkId
  Match
  Dispatch
  MethodDispatch
  TypeofOp

Labels are unique-ified so that we can compile multiple packages into
the same assembly file.

Removal strategies for each construct:
  TagImm:
    Becomes integer immediates.
    Requires each class to have an integer tag assigned to it.
    If it is a marker, then becomes (tag << 3) + marker-ref-bits.
    If it is not a marker, then becomes tag.
  StackMap:
    Becomes an integer immediate.
    Requires every unique stackmap to have an integer id assigned to it.
    Output the id.
  LinkId:
    The linkids can refer to one of the following:
      CodeId:
        Becomes a Mem immediate referencing the starting label of the function.
        Requires all functions to have a unique label assigned to it.
      ExternId:
        Becomes an ExMem immediate referencing the external label of the variable.
      ExternDefnId:
        Becomes an ExMem immediate referencing the external label of the function.
      DataId:
        Becomes a Mem immediate referencing the label of the data packet.
      GlobalId:
        Becomes a Mem immediate referencing the global constant pool table, with
        the appropriate offset. 
      ConstId:
        Becomes a Mem immediate referencing the global constant pool table, with
        the appropriate offset.
        Requires constants to be interned and assigned indices. 
  Match, Dispatch:
    Requires the class hierarchy to be indexed.
    Convert the branches into a trie and then emit the instructions
    for performing the branching.
  MethodDispatch:
    Requires the class hierarchy to be indexed.
    Requires the method branches for each multi to be collected.
    Convert the branches into a trie and then emit the instructions
    for performing the branching.
  TypeofOp :
    Requires the class hierarchy to be indexed.
    No trie is needed, just the list of concrete tags.

Implementation of Global Table:
  Input:
    Sequence of VMGlobals:
      defstruct VMGlobal :
        id: Int
        size: Int
        roots: Tuple<Int>
  Output:
    For each global:
      Compute an offset.
    Compute the reference mask.
    Compute the number of words in the mask.

Implementation of Constant Table:
  Input:
    Sequence of VMConst:
      defstruct VMConst :
        id: Int
        value: VMValue
  Output:
    The index of each interned VMConst.
    The Consts corresponding to each index, ready to be
    encoded as a table.

Implementation of Class Table:
  Goal:
    The objective of the class table is to help compile the
    match/dispatch statements. The key feature needed is the ability
    to convert a TypeSet into an ISet to perform the trie conversion.
  Therefore:
    Given a single typeid, within a package. Convert it to an ISet.
  Therefore:
    Given a single typeid, we need to resolve it to a global typeid.
  Therefore:
    Each global typeid needs a node in the class dynamic tree.
  Implementation:
    Sweep through every vmclass definition in each package, and if it
    is a concrete class, then assign its ClassProp property with its
    assigned tag.
    At the same time, for each vmclass definition, add a definition in
    the class dynamic tree using its global id (not its tag).
  Output:
    For each TypeSet, its ISet mapping to its global tags, because we
    need to distinguish marker objects from non-marker objects.

Implementation of Match/Dispatch instructions:
  Input:
    Match :
      xs: List<Imm>
      branches: List<Branch>
      no-branch: Int
    Branch :
      tags: List<TypeSet>
      n: Int
  Output:
    Emitted code for performing the dispatch.
  Assumptions:
    We can assume that the arguments have been placed in the appropriate
    registers and argument slots for the platform.
  Implementation:
    Requires conversion of a typeset to an ISet.
    This can be done using the DynTree implementation, once we
    have finished assigning class tags to all concrete classes.

;============================================================
;=======================================================<DOC>

;============================================================
;=================== StitcherEmitter ========================
;============================================================

public deftype Stitcher
public defmulti emit-tables (s:Stitcher, emitter:CodeEmitter) -> False
public defmulti emitter (s:Stitcher, package:Symbol, emitter:CodeEmitter) -> StitchEmitter
defmulti stubs (s:Stitcher) -> AsmStubs
defmulti core-fn (s:Stitcher, id:FnId) -> Imm

public deftype StitchEmitter <: CodeEmitter

;============================================================
;=============== Create the Stitcher Tables =================
;============================================================

deftype PackageIds
defmulti global-id (ids:PackageIds, lid:Int) -> Int|False
defmulti set-global-id (ids:PackageIds, lid:Int, gid:Int) -> False

defn global-id! (ids:PackageIds, lid:Int) :
  match(global-id(ids,lid)) :
    (id:Int) : id
    (id:False) : fatal("No global id registered for local id: %_" % [lid])

public defn Stitcher (packages:Collection<VMPackage>, bindings:Bindings|False, stubs:AsmStubs) :
  ;Records
  val global-recs = Vector<Rec>()
  val global-props = Vector<GProps|False>()
  val id-indices = HashTable<RecId,Int>()
  val package-ids = HashTable<Symbol,PackageIds>()

  ;Acceleration
  val sf = SetFlattener()

  ;Add a new global record
  defn add-global-record (r:Rec) -> Int :
    val global-id = length(global-props)
    add(global-recs, r)
    add(global-props, false)
    id-indices[id(r)] = global-id
    global-id

  ;Ensure that the following local id in the package
  ;has a reserved global id. Returns its global-id.
  defn ensure-global-id (pkgids:PackageIds, lid:Int) -> Int :
    match(global-id(pkgids, lid)) :
      (gid:Int) :
        gid
      (_:False) :
        val gid = length(global-props)
        add(global-props, false)
        set-global-id(pkgids, lid, gid)
        gid

  ;Set the property of a given local id
  defn set-global-prop (pkgids:PackageIds, lid:Int, p:GProps) :
    val gid = ensure-global-id(pkgids, lid)
    global-props[gid] = p

  ;Initialize record tables
  defn initialize-record-tables () :
    ;Accumulate initializers to run after we populate
    ;exported records.
    val initializers = Vector<(() -> ?)>()
    defn initialize (f:() -> ?) :
      add(initializers, f)      

    ;Initialize package ids
    for packageio in seq(packageio, packages) do :
      val local-ids = IntTable<Int>()
      for e in exports(packageio) do :
        local-ids[n(e)] = add-global-record(rec(e))
      within initialize() :
        for i in imports(packageio) do :
          local-ids[n(i)] = id-indices[id(rec(i))]
      package-ids[package(packageio)] = new PackageIds :
        defmethod global-id (this, lid:Int) :
          get?(local-ids, lid)
        defmethod set-global-id (this, lid:Int, gid:Int) :
          local-ids[lid] = gid
        
    ;Run initializers
    for init in initializers do :
      init()

  ;Simple properties
  defn initialize-simple-props () :    
    for p in packages do :
      val pkgids = package-ids[package(p)]
      for f in funcs(p) do :
        set-global-prop(pkgids, id(f), CodeProps(unique-id(stubs)))
      for e in extern-defns(p) do :
        set-global-prop(pkgids, fid(e), ExternDefnProps(lbl(e)))
      for e in externs(p) do :
        set-global-prop(pkgids, id(e), ExternProps(name(e)))
      for d in datas(p) do :
        set-global-prop(pkgids, id(d), DataProps(unique-id(stubs)))

  ;Global table
  var total-global-size:Int = 0
  val global-roots = Vector<Int>()
  defn initialize-global-table () :
    val offset-counter = Counter(0)
    for p in packages do :
      val pkgids = package-ids[package(p)]
      defn global-alignment (g:VMGlobal) :
        if size(g) >= 8 : 8
        else : size(g)
      val [padded-globals, _] = pad(global-alignment, size, globals(p), 8)      
      for g in padded-globals do :
        match(g) :
          (g:Padding) :
            next(offset-counter, size(g))
          (g:VMGlobal) :
            val offset = next(offset-counter, size(g))
            set-global-prop(pkgids, id(g), GlobalProps(offset))
            for r in roots(g) do :
              fatal("Unaligned global reference") when offset % 8 != 0
              add(global-roots, offset / 8 + r)
    total-global-size = value(offset-counter)

  ;Constant pool
  val const-pool = ConstantPool()
  defn initialize-const-table () :    
    for p in packages do :
      val pkgids = package-ids[package(p)]
      defn resolve-code-ids (v:VMValue) -> VMValue :
        defn to-global (x:CodeId) : CodeId(global-id!(pkgids, id(x)))
        match(v) :
          (v:List) : map(resolve-code-ids, v)
          (v:VMTypeObject) : VMTypeObject(to-global(id(v)))
          (v:VMClosure) : VMClosure(to-global(id(v)))
          (v) : v              
      for c in consts(p) do :
        val v* = resolve-code-ids(value(c))
        val c* = intern(const-pool, v*)
        set-global-prop(pkgids, id(c), ConstProps(id(id(c*))))

  ;Class properties
  val class-tree = DynTree()
  val class-table = Vector<VMClass>()
  var num-concrete-classes:Int 
  
  defn initialize-class-props () :
    ;Compute mapping from global-ids to core tags
    val core-tag-table = IntTable<Int>()
    for entry in [CORE-FALSE-ID => FALSE-TYPE
                  CORE-TRUE-ID => TRUE-TYPE
                  CORE-BYTE-ID => BYTE-TYPE
                  CORE-CHAR-ID => CHAR-TYPE
                  CORE-INT-ID => INT-TYPE
                  CORE-FLOAT-ID => FLOAT-TYPE
                  CORE-STACK-ID => STACK-TYPE
                  CORE-FN-ID => FN-TYPE
                  CORE-TYPE-ID => TYPE-TYPE
                  CORE-LIVENESS-TRACKER-ID => LIVENESS-TRACKER-TYPE] do :
      val gid = id-indices[key(entry)]
      core-tag-table[gid] = value(entry)

    ;Resolve all parent and child links to their global ids.
    defn resolve (pkgids:PackageIds, c:VMClass) :
      defn gid (n:Int) : global-id!(pkgids, n)
      defn gids (ns:Tuple<Int>) : map(gid, ns)
      match(c) :
        (c:VMArrayClass) : sub-id(sub-parents(c, gids(parents(c))), gid(id(c)))
        (c:VMLeafClass) : sub-id(sub-parents(c, gids(parents(c))), gid(id(c)))
        (c:VMAbstractClass) : VMAbstractClass(gid(id(c)), gids(parents(c)), gids(children(c)))

    ;Categorize class definitions
    val builtin-classes = Array<VMArrayClass|VMLeafClass>(NUM-BUILTIN-TYPES)
    val concrete-classes = Vector<VMArrayClass|VMLeafClass>()
    val abstract-classes = Vector<VMAbstractClass>()
    for p in packages do :
      val pkgids = package-ids[package(p)]
      for c in classes(p) do :
        val cid = ensure-global-id(pkgids, id(c))
        match(resolve(pkgids, c)) :
          (c:VMArrayClass|VMLeafClass) :
            match(get?(core-tag-table,cid)) :
              (tag:Int) : builtin-classes[tag] = c
              (_:False) : add(concrete-classes, c)             
          (c:VMAbstractClass) :
            add(abstract-classes, c)
    num-concrete-classes = length(builtin-classes) + length(concrete-classes)
    add-all(class-table, cat-all([builtin-classes, concrete-classes, abstract-classes]))

    ;Build class tree
    add(class-tree, node-states) where :
      val node-states = for c in class-table seq :
        match(c) :
          (c:VMArrayClass|VMLeafClass) : NodeState(id(c), parents(c), [], true)
          (c:VMAbstractClass) : NodeState(id(c), parents(c), children(c), false)

    ;Determine whether a class is represented as a marker
    val unique-id = id-indices[CORE-UNIQUE-ID]
    defn marker? (c:VMClass) :
      match(c:VMLeafClass) :
        val no-fields = size(c) == 0
        val unique = parent?(class-tree, id(c), unique-id)
        no-fields and not unique

    ;Add all classes to props table and assign tags for
    ;each of them.
    for (c in class-table, tag in 0 to false) do :
      global-props[id(c)] = ClassProps(tag, marker?(c))

  ;Method Table
  val method-table = IntListTable<Branch>()
  defn initialize-method-table () :
    for p in packages do :
      val pkgids = package-ids[package(p)]
      for m in methods(p) do :
        val multi* = global-id!(pkgids,multi(m))
        val fid* = global-id!(pkgids, fid(m))
        val lbl = lbl(global-props[fid*] as CodeProps)
        val types* = map(resolve{pkgids, _}, types(m))
        val branch* = Branch(to-list(types*), M(lbl))
        add(method-table, multi*, branch*)

  ;Resolve a package-local TypeSet to use global ids
  defn resolve (pkgids:PackageIds, t:TypeSet) -> TypeSet :
    let loop (t:TypeSet = t) :
      match(t) :
        (t:TopType) : t
        (t:AndType) : AndType?(seq(loop,types(t)))
        (t:OrType) : OrType?(seq(loop,types(t)))
        (t:SingleType) : SingleType(global-id!(pkgids,type(t)))

  ;Create stackmap table
  defn stackmap-hash (x:StackMap) :
    hash $ [size(x), indices(x)]
  val stackmap-table = HashTable<StackMap,Int>(stackmap-hash, equal?)
  val stackmaps = Vector<StackMap>()
  defn stackmap-index (m:StackMap) :
    if not key?(stackmap-table,m) :
      val i = length(stackmaps)
      add(stackmaps, m)
      stackmap-table[m] = i
    stackmap-table[m]

  ;Accumulate info table
  val file-info-table = Vector<KeyValue<Int,FileInfo>>()
  defn add-info-table (n:Int, info:FileInfo) :
    add(file-info-table, n => info)

  ;Create a function-local emitter
  defn emitter (package:Symbol, code-emitter:CodeEmitter) :
    val pkgids = package-ids[package]
    val label-table = IntTable-init<Int>(unique-id{stubs})

    ;Link an immediate, remove all non-handled items.
    defn link (x:Imm) :
      match(x) :
        (x:LocalMem) :
          Mem(label-table[n(x)],0)
        (x:TagImm) : 
          tag-imm(global-id!(pkgids, n(x)), marker?(x))
        (x:StackMap) :
          IntImm(stackmap-index(x))
        (x:LinkId) :
          val gid = global-id!(pkgids, id(x))
          match(global-props[gid]) :
            (p:CodeProps) :
              Mem(lbl(p), 0)
            (p:ExternProps) :
              ExMem(exlbl(p), 0)
            (p:ExternDefnProps) :
              ExMem(exlbl(p), 0)
            (p:DataProps) :
              Mem(lbl(p), 0)
            (p:ConstProps) :
              Mem(const-table(stubs), index(p) * 8)
            (p:GlobalProps) :
              Mem(globals(stubs), offset(p))
        (x) :
          x

    ;Return the numerical tag for the given global id
    defn tag-imm (gid:Int, marker?:True|False) :
      val props = global-props[gid] as ClassProps
      if marker? : INT(tag(props) << 3 + 2)
      else : INT(tag(props))

    ;Resolve a typeset from package ids to global ids
    defn resolve-branch (b:Branch) :
      val tags* = map(resolve{pkgids, _}, tags(b))
      Branch(tags*, dst(b))

    ;Convert branches into branch table
    defn to-dag (ts:Seqable<Seqable<TypeSet>>, topological?:True|False) :
      val bs = to-branches(ts, all-children{class-tree, _}, sf)
      val btable = BranchTable(bs, non-leaves(class-tree))
      compute-dispatch-dag(btable, topological?)

    ;Emit code for producing dag (args is a helper)
    defn emit-dag (dag:Dag, targets:Tuple<Imm>, default-target:Imm, amb-target:Imm|False, args:Tuple<Imm>) :
      ;Is the given type a marker?
      ;Is it both empty, and not a subtype of Unique?
      defn marker? (x:Int) :
        /marker?(global-props[x] as ClassProps)

      ;Calculate labels for all entries
      val labels = map(M{unique-id(stubs)}, entries(dag))
      defn to-label (v:Int|Soln) -> Imm :
        match(v) :
          (v:Int) : labels[v]
          (v:NoSoln) : default-target
          (v:AmbSoln) : amb-target as Imm
          (v:UniqueSoln) : targets[index(v)]

      ;Emit a single dag entry
      defn emit-dag-entry (dag-e:DagEntry) :
        if empty?(entries(dag-e)) :
          E $ Goto(to-label(default(dag-e)))
        else :
          ;Categorize branches
          val prim-targets = Vector<KeyValue<Int,Imm>>()
          val marker-targets = Vector<KeyValue<Int,Imm>>()
          val ref-targets = Vector<KeyValue<Int,Imm>>()
          val default-target = to-label(default(dag-e))
          for entry in entries(dag-e) do :
            val tgt = to-label(value(entry))
            for x in values(key(entry))  do :
              if x == id-indices[CORE-BYTE-ID] : add(prim-targets, x => tgt)
              else if x == id-indices[CORE-CHAR-ID] : add(prim-targets, x => tgt)
              else if x == id-indices[CORE-INT-ID] : add(prim-targets, x => tgt)
              else if x == id-indices[CORE-FLOAT-ID] : add(prim-targets, x => tgt)
              else if marker?(x) : add(marker-targets, x => tgt)
              else : add(ref-targets, x => tgt)              

          ;Registers
          val OBJ = R0
          val BITS = R1
          val TAG = R1

          ;Load object
          val object = match(args[depth(dag-e)]) :
            (a:Reg) :
              a
            (a:Mem) :
              E $ LoadL(OBJ, a)
              OBJ

          ;Test bits
          val marker-branches = unique-id(stubs)
          val ref-branches = unique-id(stubs)
          val prim-targets? = not empty?(prim-targets)
          val marker-targets? = not empty?(marker-targets)
          val ref-targets? = not empty?(ref-targets)

          ;Checking for primitives or references requires knowing the tag bits.
          ;So create the tag bits if we have either case.
          if prim-targets? or ref-targets? :
            E $ AndL(BITS, object, INT(7))

          ;Jump to the appropriate primitive target if the object
          ;is one of the given primitives.
          for entry in prim-targets do :
            val x = key(entry)
            val target = value(entry)
            val tagbits =
              if x == id-indices[CORE-BYTE-ID] : INT(3)
              else if x == id-indices[CORE-CHAR-ID] : INT(4)
              else if x == id-indices[CORE-INT-ID] : INT(0)
              else if x == id-indices[CORE-FLOAT-ID] : INT(5)
              else : fatal("Not a primitive type")
            E $ BreakL(target, EqOp(), BITS, tagbits)

          ;Skip the reference branches if the object is not a reference.
          val label-after-refs = M(marker-branches) when marker-targets?
                            else default-target
          if ref-targets? : E $ BreakL(label-after-refs, NeOp(), BITS, INT(1))
          else if not marker-targets? : E $ Goto(label-after-refs)

          ;Jump to the appropriate reference branches if the object
          ;is one of the given references
          if ref-targets? :
            defn ref-tree () :
              BinaryNode $ for e in ref-targets seq :
                val header = tag-imm(key(e), false)
                (value(header) as Int) => value(e)
            E $ Label(ref-branches)
            E $ LoadL(TAG, object, -1)
            let loop (tree:BinaryNode<Imm> = ref-tree()) :
              match(tree) :
                (tree:InnerNode<Imm>) :
                  val left-tree = unique-id(stubs)
                  E $ BreakL(M(left-tree), UleOp(), TAG, IntImm(value(tree)))
                  loop(right(tree))
                  E $ Label(left-tree)
                  loop(left(tree))
                (tree:LeafNode<Imm>) :
                  for e in entries(tree) do :
                    val x = key(e)
                    val target = value(e)
                    E $ BreakL(target, EqOp(), TAG, IntImm(x))
                  E $ Goto(default-target)

          ;Jump to the appropriate marker branches if the object is one
          ;of the given marker branches.
          if marker-targets? :
            defn marker-tree () :
              BinaryNode $ for e in marker-targets seq :
                val header = tag-imm(key(e), true)
                (value(header) as Int) => value(e)
            E $ Label(marker-branches)
            let loop (tree:BinaryNode<Imm> = marker-tree()) :
              match(tree) :
                (tree:InnerNode<Imm>) :
                  val left-tree = unique-id(stubs)
                  E $ BreakL(M(left-tree), UleOp(), object, IntImm(value(tree)))
                  loop(right(tree))
                  E $ Label(left-tree)
                  loop(left(tree))
                (tree:LeafNode<Imm>) :
                  for e in entries(tree) do :
                    val x = key(e)
                    val target = value(e)
                    E $ BreakL(target, EqOp(), object, IntImm(x))
                  E $ Goto(default-target)

      ;Emit all entries
      for (e in entries(dag), l in labels) do :
        E $ Label(n(l))
        emit-dag-entry(e)

    ;Emit code for producing typeof
    defn emit-typeof (x:Loc, y:Imm, arg:Arg) :
      match(arg) :
        ;Return true always
        (arg:Top) :
          E $ SetL(x, INT(1))
        ;Return false
        (arg:Nums) :
          ;Is the given type a marker?
          defn marker? (x:Int) :
            /marker?(global-props[x] as ClassProps)

          ;Categorize branches
          val prims = Vector<Int>()
          val markers = Vector<Int>()
          val refs = Vector<Int>()
          for x in values(arg) do :
            if x == id-indices[CORE-BYTE-ID] : add(prims, x)
            else if x == id-indices[CORE-CHAR-ID] : add(prims, x)
            else if x == id-indices[CORE-INT-ID] : add(prims, x)
            else if x == id-indices[CORE-FLOAT-ID] : add(prims, x)
            else if marker?(x) : add(markers, x)
            else : add(refs, x)              

          ;Registers
          val OBJ = R0
          val BITS = R1
          val TAG = R1

          ;Labels
          val pass-lbl = unique-id(stubs)
          val end-lbl = unique-id(stubs)

          ;Load object
          E $ SetL(OBJ, y)

          ;Default is 0
          E $ SetL(x, INT(0))

          ;Test bits
          val marker-branches = unique-id(stubs)
          val ref-branches = unique-id(stubs)
          ;See above for case-based optimization
          val prim-targets? = not empty?(prims)
          val marker-targets? = not empty?(markers)
          val ref-targets? = not empty?(refs)

          if prim-targets? or ref-targets? :
            E $ AndL(BITS, OBJ, INT(7))
            
          for x in prims do :
            val tagbits =
              if x == id-indices[CORE-BYTE-ID] : INT(3)
              else if x == id-indices[CORE-CHAR-ID] : INT(4)
              else if x == id-indices[CORE-INT-ID] : INT(0)
              else if x == id-indices[CORE-FLOAT-ID] : INT(5)
              else : fatal("Not a primitive type")
            E $ BreakL(M(pass-lbl), EqOp(), BITS, tagbits)

          ;Skip the reference branches if the object is not a reference.
          val label-after-refs = M(marker-branches) when marker-targets?
                            else M(end-lbl)
          if ref-targets? : E $ BreakL(label-after-refs, NeOp(), BITS, INT(1))
          else if not marker-targets? : E $ Goto(label-after-refs)

          ;Ref branches
          if ref-targets?:
            E $ Label(ref-branches)
            E $ LoadL(TAG, OBJ, -1)
            for x in refs do :
              E $ BreakL(M(pass-lbl), EqOp(), TAG, tag-imm(x, false))
            E $ Goto(M(end-lbl))

          ;Marker branches
          if marker-targets?: 
            E $ Label(marker-branches)
            for x in markers do :
              E $ BreakL(M(pass-lbl), EqOp(), OBJ, tag-imm(x,true))
            E $ Goto(M(end-lbl))

          ;Pass and failure labels
          E $ Label(pass-lbl)
          E $ SetL(x, INT(1))
          E $ Label(end-lbl)

    ;Retrieve the arguments to a dag for a match/dispatch statement
    defn dag-args (dag:Dag, xs:List<Imm>) :
      val reg-args = xs as List<Reg>
      val mem-args = seq(Mem{registers(stubs), _}, 0 to false by 8)
      val all-args = cat(reg-args, mem-args)
      to-tuple(take-n(depth(dag), all-args))

    defn dag-method-args (dag:Dag, num-header-args:Int) :
      val reg-args = seq(R, tailn(call-regs(backend(stubs)), num-header-args))
      val mem-args = seq(Mem{registers(stubs), _}, 0 to false by 8)
      val all-args = cat(reg-args, mem-args)
      to-tuple(take-n(depth(dag), all-args))      

    ;Return new code emitter
    defn E (i:Ins) : emit(code-emitter, i)      
    new StitchEmitter :
      defmethod emit (this, i:Ins) :
        match(map(link,i)) :
          (i:LinkLabel) :
            val gid = global-id!(pkgids, id(i))
            match(global-props[gid]) :
              (p:CodeProps) : E $ Label(lbl(p))
              (p:ExternDefnProps) : E $ ExLabel(exlbl(p))            
          (i:Label) :
            val n* = label-table[n(i)]
            E $ Label(n*)
            match(info(i)) :
              (info:FileInfo) : add-info-table(n*, info)
              (info:False) : false
          (i:Match) :
            val branches* = map(resolve-branch, branches(i))
            val dag = to-dag(seq(tags,branches*), false)
            emit-dag(dag, to-tuple(seq(dst,branches*)), no-branch(i), false, dag-args(dag,xs(i)))
          (i:Dispatch) :
            val branches* = map(resolve-branch, branches(i))
            val dag = to-dag(seq(tags,branches*), true)
            emit-dag(dag, to-tuple(seq(dst,branches*)), no-branch(i), amb-branch(i), dag-args(dag,xs(i)))
          (i:MethodDispatch) :
            val multi-id = global-id!(pkgids, multi(i))
            val branches = method-table[multi-id]
            val dag = to-dag(seq(tags,branches), true)
            emit-dag(dag, to-tuple(seq(dst,branches)), no-branch(i), amb-branch(i), dag-method-args(dag,num-header-args(i)))
          (i:UnaOp) :
            match(op(i)) :
              (op:TypeofOp) :
                val tag* = resolve(pkgids, tag(op))
                val arg = to-arg(tag*, all-children{class-tree, _}, sf)
                emit-typeof(x(i), y(i), arg)
              (op) : E(i)
          (i) : E(i)    

  ;Initialization function
  defn emit-initialization-function (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)
    val frame-size = 16
    val stackmap = stackmap-index(StackMap(frame-size, []))
    E $ Label(init-function(stubs))
    E $ StoreL(RSP, INT(stackmap), 8)    
    for p in packages do :
      val pkgids = package-ids[package(p)]
      val init = init(p)
      match(init:Int) :
        E $ AddL(RSP, RSP, INT(frame-size + 8))
        val gid = global-id!(pkgids, init)
        val code-id = lbl(global-props[gid] as CodeProps)
        E $ Call(M(code-id))
        E $ SubL(RSP, RSP, INT(frame-size + 8))
    E $ SetL(R0, INT(0))
    E $ Return()

  ;Emit global table
  defn emit-global-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)
    ;Memory for globals
    E $ DefData()
    E $ Label(globals(stubs))
    defn DefSpace? (sz:Int) :
      E(DefSpace(sz)) when sz > 0
    var current-size:Int = 0
    for r in global-roots do :
      val offset = r * 8
      DefSpace?(offset - current-size)
      E $ DefLong(to-long(-1 << 3 + 2))
      current-size = offset + 8
    DefSpace?(total-global-size - current-size)
    E $ DefText()

    ;Memory for global roots
    E $ DefData()
    E $ Label(global-root-table(stubs))
    E $ DefInt(length(global-roots))
    for r in global-roots do :
      E $ DefInt(r)
    E $ DefText()

  ;Emit constant table
  defn emit-const-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)
    val consts = consts(const-pool)
    
    E $ DefData()
    E $ Label(const-table(stubs))
    for v in consts do :
      E $ DefLong(to-long(-1 << 3 + 2))
    E $ DefText()

    val writer = new ConstWriter :
      defmethod write (this, b:Byte) :
        E $ DefByte(b)
      defmethod write (this, i:Int) :
        E $ DefInt(i)
      defmethod write (this, l:Long) :
        E $ DefLong(l)
      defmethod write (this, cid:CodeId) :
        val props = global-props[id(cid)] as CodeProps
        E $ DefLabel(lbl(props))
    
    E $ DefData()
    E $ Label(const-mem(stubs))
    E $ DefInt(length(consts))
    for v in consts do :
      write-const(writer, v)
    E $ DefText()

  ;Emit data table
  defn emit-data-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)      
    for p in packages do :
      val pkgids = package-ids[package(p)]
      for d in datas(p) do :
        val props = global-props[global-id!(pkgids, id(d))] as DataProps
        E $ DefData()
        E $ Label(lbl(props))
        E $ DefBytes(data(d))
        E $ DefText()

  ;Emit class table
  ;Leaf Class Definition:
  ;  name:ptr<long>, size:Int, item-size:Int (0), num-roots:Int, roots:Int ...
  ;Array Class Definition:
  ;  name:ptr<long>, base-size:Int, item-size:Int,
  ;  num-base-roots:Int, num-item-roots:Int, base-roots:Int ..., item-roots:Int ...
  defn emit-class-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)

    ;Retrieve class name
    defn class-name (c:VMClass) -> String :
      defn name (x:Int) :
        if x < length(global-recs) :
          val tid = id(global-recs[x]) as TypeId
          /name(tid)
      match(name(id(c))) :
        ;Has a user-given name
        (name:Symbol) :
          to-string(name)
        ;Construct a name from parents
        (_:False) :
          val parent-names = seq(to-string{name(_)}, parents(c))
          string-join(parent-names, "&")

    ;Create class labels
    val class-lbls = to-tuple $
      repeatedly(unique-id{stubs}, num-concrete-classes)
    E $ DefData()
    E $ Label(/class-table(stubs))
    for lbl in class-lbls do :
      E $ DefLabel(lbl)
    for (c in class-table, lbl in class-lbls, i in 0 to false) do :
      val name-lbl = unique-id(stubs)
      E $ Label(lbl)
      E $ DefLabel(name-lbl)
      match(c) :
        (c:VMLeafClass) :
          E $ DefInt(size(c))
          E $ DefInt(0)
          E $ DefInt(length(roots(c)))
          do(E{DefInt(_)}, roots(c))
        (c:VMArrayClass) :
          E $ DefInt(base-size(c))
          E $ DefInt(item-size(c))
          E $ DefInt(length(base-roots(c)))
          E $ DefInt(length(item-roots(c)))
          do(E{DefInt(_)}, base-roots(c))
          do(E{DefInt(_)}, item-roots(c))
      E $ Label(name-lbl)
      E $ DefString(class-name(c))
      println("//Class %_ is %_" % [i, class-name(c)])
    E $ DefText()

  ;Emit stackmap table
  defn emit-stackmap-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)
    val map-lbls = to-tuple $
      repeatedly(unique-id{stubs}, length(stackmaps))
    E $ DefData()
    E $ Label(/stackmap-table(stubs))
    for lbl in map-lbls do :
      E $ DefLabel(lbl)
    for (m in stackmaps, lbl in map-lbls) do :
      E $ Label(lbl)
      E $ DefInt(size(m))
      E $ DefInt(length(indices(m)))
      for i in indices(m) do :
        E $ DefInt(i)
    E $ DefText()

  ;Emit info table
  defn emit-info-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)
    val string-lbls = HashTable-init<String,Int>(unique-id{stubs})
    E $ DefData()
    E $ Label(info-table(stubs))
    E $ DefLong(to-long(length(file-info-table)))
    for entry in file-info-table do :
      val [lbl, info] = [key(entry), value(entry)]
      E $ DefLabel(lbl)
      E $ DefLabel(string-lbls[filename(info)])
      E $ DefInt(line(info))
      E $ DefInt(column(info))
    E $ DefText()
    E $ DefData()
    for entry in string-lbls do :
      val [s, n] = [key(entry), value(entry)]
      E $ Label(n)
      E $ DefString(s)
    E $ DefText()

  ;Emit extern table
  defn emit-extern-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)
    val all-externs = HashSet<Symbol>()
    match(bindings:Bindings) :
      add-all(all-externs, seq(lbl, externs(bindings)))
      add-all(all-externs, seq(lbl, extern-defns(bindings)))
    for p in packages do :
      add-all(all-externs, seq(name, externs(p)))
    val extern-list = to-tuple(all-externs)
    val string-lbls = HashTable-init<String,Int>(unique-id{stubs})

    ;Externs
    ;Emit placeholder data
    E $ DefData()
    E $ Label(extern-table(stubs))
    E $ DefLong(to-long(length(extern-list)))
    for e in extern-list do :
      E $ DefLabel(string-lbls[to-string(e)])
      E $ DefLong(0L)
    E $ DefText()

    ;Extern Defns
    E $ DefData()
    E $ Label(extern-defn-table(stubs))
    match(bindings:Bindings) :
      E $ DefLong(to-long(length(extern-defns(bindings))))
      for (def in extern-defns(bindings), i in 0 to false) do :
        E $ DefLabel(string-lbls[to-string(lbl(def))])
        E $ DefLong(to-long(i))
    else :
      E $ DefLong(0L)
    E $ DefText()
      
    ;Emit string labels
    E $ DefData()
    for entry in string-lbls do :
      val [s, n] = [key(entry), value(entry)]
      E $ Label(n)
      E $ DefString(s)
    E $ DefText()
    
    ;Emit initializing routine
    E $ Label(init-extern-table(stubs))
    for (e in extern-list, i in 0 to false) do :
      E $ SetL(R1, ExMem(e, 0))
      E $ StoreL(M(extern-table(stubs)), R1, 8 + 16 * i + 8)
    E $ Goto(R0)    

  ;Initialize record tables
  initialize-record-tables()
  initialize-simple-props()
  initialize-global-table()
  initialize-const-table()
  initialize-class-props()
  initialize-method-table()

  ;Return new Stitcher
  new Stitcher :
    defmethod emitter (this, package:Symbol, code-emitter:CodeEmitter) :
      emitter(package, code-emitter)
    defmethod emit-tables (this, code-emitter:CodeEmitter) :
      emit-initialization-function(code-emitter)
      emit-global-table(code-emitter)
      emit-const-table(code-emitter)
      emit-data-table(code-emitter)
      emit-class-table(code-emitter)
      emit-stackmap-table(code-emitter)
      emit-info-table(code-emitter)
      emit-extern-table(code-emitter)
    defmethod stubs (this) :
      stubs
    defmethod core-fn (this, id:FnId) :
      val gid = id-indices[id]
      val lbl = lbl(global-props[gid] as CodeProps)
      M(lbl)
  
deftype GProps
defstruct CodeProps <: GProps :
  lbl:Int
defstruct ExternProps <: GProps :
  exlbl:Symbol
defstruct ExternDefnProps <: GProps :
  exlbl:Symbol
defstruct GlobalProps <: GProps :
  offset: Int
defstruct DataProps <: GProps :
  lbl:Int
defstruct ConstProps <: GProps :
  index:Int
defstruct ClassProps <: GProps :
  tag: Int
  marker?: True|False

;============================================================
;===================== Runtime Stubs ========================
;============================================================

public defn emit-stubs (s:Stitcher, emitter:CodeEmitter) :
  compile-extend-stack-stub(s, emitter)
  compile-collect-garbage-stub(s, emitter)
  compile-c-trampoline-stub(s, emitter)

;<doc>=======================================================
;==================== Stack Extension =======================
;============================================================

Extend Stack Stub:
  Input:
    R0 is return address.
    R1 is required stack size: (must satisfy: RSP + R1 <= stack-limit)
    RSP still points to caller's stack frame.
  Responsibilities:
    Save the current registers.
    Save the current stack parameters.
      (Save RSP)
      (Save return address)
    Switch to using the system stack.
      (Swap current stack with system stack)
      (Swap registers with system registers)
    Load the system stack parameters
      (Load RSP)
      (Load stack-limit)
    Call extend-stack:
      (argument 0 (unused) = ---)
      (argument 1 (arity) = 1)
      (argument 2 (size) = size)
      (call)
    Switch back to using the program stack.
      (Null the system stack pointer)
      (Swap current stack with system stack)
      (Swap registers with system registers)
    Load the stack parameters
      (Load RSP)
      (Load stack-limit)
    Restore current registers.
    Continue from stack.pc.

  Pseudocode:
    save R2 ... Rn
    
    current-stack.pc = return address (R0)
    current-stack.sp = RSP
      (use TMP:R2 for current-stack)
      TMP = [current-stack]
      TMP.pc = R0
      TMP.sp = RSP
      
    swap [current-stack] with [system-stack]
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [current-stack]
      TMP2 = [system-stack]
      [current-stack] = TMP2
      [system-stack] = TMP

    swap [registers] with [system_registers]
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [registers]
      TMP2 = [system-registers]
      [registers] = TMP
      [system-registers] = TMP2

    RSP = current-stack.frames
    stack-limit = current-stack.frames + current-stack.size
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [current-stack]
      RSP = TMP.frames
      TMP2 = TMP.size
      TMP2 += RSP
      [stack-limit] = TMP2

    (use size:R1)
    R3 = 1
    R4 = size
    
    RSP += 8
    call extend-stack
    (RSP -= 8) (Elided: Not used again)
    
    current-stack.stack-pointer = null
      (use TMP:R2)
      TMP = [current-stack]
      TMP.stack-pointer = null

    swap [current-stack] with [system-stack]
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [current-stack]
      TMP2 = [system-stack]
      [current-stack] = TMP2
      [system-stack] = TMP

    swap [registers] with [system_registers]
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [registers]
      TMP2 = [system-registers]
      [registers] = TMP
      [system-registers] = TMP2

    RSP = current-stack.sp
    stack-limit = current-stack.frames + current-stack.size
      (use TMP:R1)
      (use TMP2:R3)
      TMP = [current-stack]
      TMP2 = TMP.frames
      TMP = TMP.size
      TMP += TMP2
      [stack-limit] = TMP
      TMP = [current-stack]
      RSP = TMP.sp

    restore R2 ... Rn
    
    goto current-stack.pc
      (use TMP:R1)
      TMP = [current-stack]
      TMP = TMP.pc
      goto TMP

;============================================================
;=======================================================<doc>

defn compile-extend-stack-stub (stitcher:Stitcher, emitter:CodeEmitter) :
  val stubs = stubs(stitcher)
  val backend = backend(stubs)
  defn E (i:Ins) : emit(emitter, i)
  
  defn swap (r1:Reg, m1:Mem, r2:Reg, m2:Mem) :
    E $ LoadL(r1, m1)
    E $ LoadL(r2, m2)
    E $ StoreL(m1, r2)
    E $ StoreL(m2, r1)

  ;Compute stack offsets
  val stack-offset-counter = Counter(-1 + 8)
  val size-offset = next(stack-offset-counter, 8)
  val frames-offset = next(stack-offset-counter, 8)
  val sp-offset = next(stack-offset-counter, 8)
  val pc-offset = next(stack-offset-counter, 8)

  E $ Label(extend-stack(stubs))

  ;save R2 ... Rn
  for (r in call-regs(backend), loc in saved-regs(stubs)) do :
    E $ StoreL(M(loc), R(r))
  for (r in call-fregs(backend), loc in saved-fregs(stubs)) do :
    E $ StoreD(M(loc), F(r))

  ;current-stack.pc = return address (R0)
  ;current-stack.sp = RSP
  let :
    val TMP = R2
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ StoreL(TMP, R0, pc-offset)
    E $ StoreL(TMP, RSP, sp-offset)

  ;swap [current-stack] with [system-stack]
  ;swap [registers] with [system_registers]
  swap(R2, M(current-stack(stubs)), R3, M(system-stack(stubs)))  
  swap(R2, M(registers(stubs)), R3, M(system-registers(stubs)))

  ;RSP = current-stack.frames
  ;stack-limit = current-stack.frames + current-stack.size
  let :
    val TMP = R2
    val TMP2 = R3
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(RSP, TMP, frames-offset)
    E $ LoadL(TMP2, TMP, size-offset)
    E $ AddL(TMP2, TMP2, RSP)
    E $ StoreL(M(stack-limit(stubs)), TMP2)

  ;Call extend stack
  E $ SetL(R3, INT(1))
  E $ SetL(R4, R1)
  E $ AddL(RSP, RSP, INT(8))
  E $ Call(core-fn(stitcher, CORE-EXTEND-STACK-ID))

  ;current-stack.stack-pointer = null
  let :
    val TMP = R2
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ StoreL(TMP, INT(0), sp-offset)

  ;swap [current-stack] with [system-stack]
  ;swap [registers] with [system_registers]
  swap(R2, M(current-stack(stubs)), R3, M(system-stack(stubs)))  
  swap(R2, M(registers(stubs)), R3, M(system-registers(stubs)))  

  ;RSP = current-stack.sp
  ;stack-limit = current-stack.frames + current-stack.size
  let :
    val TMP = R1
    val TMP2 = R3
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(TMP2, TMP, frames-offset)
    E $ LoadL(TMP, TMP, size-offset)
    E $ AddL(TMP, TMP, TMP2)
    E $ StoreL(M(stack-limit(stubs)), TMP)
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(RSP, TMP, sp-offset)

  ;restore R2 ... Rn
  for (r in call-regs(backend), loc in saved-regs(stubs)) do :
    E $ LoadL(R(r), M(loc))
  for (r in call-fregs(backend), loc in saved-fregs(stubs)) do :
    E $ LoadD(F(r), M(loc))

  ;goto current-stack.pc
  let :
    val TMP = R1
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(TMP, TMP, pc-offset)
    E $ Goto(TMP)

;<doc>=======================================================
;==================== Garbage Collection ====================
;============================================================

Garbage Collection Stub:
  Input:
    R0 is return address.
    R2 is required heap size: (must satisfy: heap-top + R1 <= heap-limit)
    RSP still points to caller's stack frame.
  Responsibilities:
    Save the current registers.
    Save the current stack parameters.
      (Save RSP)
      (Save return address)
    Switch to using the system stack.
      (Swap current stack with system stack)
      (Swap registers with system registers)
    Load the system stack parameters
      (Load RSP)
      (Load stack-limit)
    Call collect-garbage:
      (argument 0 (unused) = ---)
      (argument 1 (arity) = 1)
      (argument 2 (size) = size)
      (call)
    Switch back to using the program stack.
      (Null the system stack pointer)
      (Swap current stack with system stack)
      (Swap registers with system registers)
    Load the stack parameters
      (Load RSP)
      (Load stack-limit)
    Restore current registers.
    Continue from stack.pc.

  Pseudocode:
    save R2 ... Rn
    
    current-stack.pc = return address (R0)
    current-stack.sp = RSP
      (use TMP:R1 for current-stack)
      TMP = [current-stack]
      TMP.pc = R0
      TMP.sp = RSP
      
    swap [current-stack] with [system-stack]
      (use TMP:R1)
      (use TMP2:R3)
      TMP = [current-stack]
      TMP2 = [system-stack]
      [current-stack] = TMP2
      [system-stack] = TMP

    swap [registers] with [system_registers]
      (use TMP:R1)
      (use TMP2:R3)
      TMP = [registers]
      TMP2 = [system-registers]
      [registers] = TMP
      [system-registers] = TMP2

    RSP = current-stack.frames
    stack-limit = current-stack.frames + current-stack.size
      (use TMP:R1)
      (use TMP2:R3)
      TMP = [current-stack]
      RSP = TMP.frames
      TMP2 = TMP.size
      TMP2 += RSP
      [stack-limit] = TMP2

    (use size:R2)
    R3 = 1
    R4 = size
    
    RSP += 8
    call collect-garbage
    (RSP -= 8) (Elided: Not used again)
    
    current-stack.stack-pointer = null
      (use TMP:R1)
      TMP = [current-stack]
      TMP.stack-pointer = null

    swap [current-stack] with [system-stack]
      (use TMP:R1)
      (use TMP2:R3)
      TMP = [current-stack]
      TMP2 = [system-stack]
      [current-stack] = TMP2
      [system-stack] = TMP

    swap [registers] with [system_registers]
      (use TMP:R1)
      (use TMP2:R3)
      TMP = [registers]
      TMP2 = [system-registers]
      [registers] = TMP
      [system-registers] = TMP2

    RSP = current-stack.sp
    stack-limit = current-stack.frames + current-stack.size
      (use TMP:R1)
      (use TMP2:R3)
      TMP = [current-stack]
      TMP2 = TMP.frames
      TMP = TMP.size
      TMP += TMP2
      [stack-limit] = TMP
      TMP = [current-stack]
      RSP = TMP.sp
      
    restore R2 ... Rn
    
    goto current-stack.pc
      (use TMP:R1)
      TMP = [current-stack]
      TMP = TMP.pc
      goto TMP

;============================================================
;=======================================================<doc>

defn compile-collect-garbage-stub (stitcher:Stitcher, emitter:CodeEmitter) :
  val stubs = stubs(stitcher)
  val backend = backend(stubs)
  defn E (i:Ins) : emit(emitter, i)
  
  defn swap (r1:Reg, m1:Mem, r2:Reg, m2:Mem) :
    E $ LoadL(r1, m1)
    E $ LoadL(r2, m2)
    E $ StoreL(m1, r2)
    E $ StoreL(m2, r1)

  ;Compute stack offsets
  val stack-offset-counter = Counter(-1 + 8)
  val size-offset = next(stack-offset-counter, 8)
  val frames-offset = next(stack-offset-counter, 8)
  val sp-offset = next(stack-offset-counter, 8)
  val pc-offset = next(stack-offset-counter, 8)

  E $ Label(collect-garbage(stubs))

  ;save R2 ... Rn
  for (r in call-regs(backend), loc in saved-regs(stubs)) do :
    E $ StoreL(M(loc), R(r))
  for (r in call-fregs(backend), loc in saved-fregs(stubs)) do :
    E $ StoreD(M(loc), F(r))

  ;current-stack.pc = return address (R0)
  ;current-stack.sp = RSP
  let :
    val TMP = R1
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ StoreL(TMP, R0, pc-offset)
    E $ StoreL(TMP, RSP, sp-offset)

  ;swap [current-stack] with [system-stack]
  ;swap [registers] with [system_registers]
  swap(R1, M(current-stack(stubs)), R3, M(system-stack(stubs)))  
  swap(R1, M(registers(stubs)), R3, M(system-registers(stubs)))

  ;RSP = current-stack.frames
  ;stack-limit = current-stack.frames + current-stack.size
  let :
    val TMP = R1
    val TMP2 = R3
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(RSP, TMP, frames-offset)
    E $ LoadL(TMP2, TMP, size-offset)
    E $ AddL(TMP2, TMP2, RSP)
    E $ StoreL(M(stack-limit(stubs)), TMP2)

  ;Call collect-garbage
  E $ SetL(R3, INT(1))
  E $ SetL(R4, R2)
  E $ AddL(RSP, RSP, INT(8))
  E $ Call(core-fn(stitcher, CORE-COLLECT-GARBAGE-ID))

  ;current-stack.stack-pointer = null
  let :
    val TMP = R1
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ StoreL(TMP, INT(0), sp-offset)

  ;swap [current-stack] with [system-stack]
  ;swap [registers] with [system_registers]
  swap(R1, M(current-stack(stubs)), R3, M(system-stack(stubs)))  
  swap(R1, M(registers(stubs)), R3, M(system-registers(stubs)))  

  ;RSP = current-stack.sp
  ;stack-limit = current-stack.frames + current-stack.size
  let :
    val TMP = R1
    val TMP2 = R3
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(TMP2, TMP, frames-offset)
    E $ LoadL(TMP, TMP, size-offset)
    E $ AddL(TMP, TMP, TMP2)
    E $ StoreL(M(stack-limit(stubs)), TMP)
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(RSP, TMP, sp-offset)

  ;restore R2 ... Rn
  for (r in call-regs(backend), loc in saved-regs(stubs)) do :
    E $ LoadL(R(r), M(loc))
  for (r in call-fregs(backend), loc in saved-fregs(stubs)) do :
    E $ LoadD(F(r), M(loc))

  ;goto current-stack.pc
  let :
    val TMP = R1
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(TMP, TMP, pc-offset)
    E $ Goto(TMP)

;<doc>=======================================================
;==================== C Trampoline ==========================
;============================================================

The C trampoline is a generated function to be called from C that
allows for calling a C function with a dynamically-generated list of
arguments.

Here is its interface :

  c_trampoline (void* fptr, void* args, void* ret) -> void

The arguments are:

  fptr: The function pointer to call.
  args: The buffer holding the arguments to the function.
  ret: The buffer holding the return values from the function. 

Here is the format of the argument buffer. Each slot in the buffer is
8-bytes. Note that we assume that the first integer argument holds the
number of floating point arguments in the call. (Typically %rax for
System-V systems)

  let A = 1 + nstk 
  let B = A + nfarg
  buffer[0] = number of stack arguments (nstk).
  buffer[1] = last stack argument
  ...
  buffer[1 + nstk - 1] = first stack argument
  buffer[A + 0] = number of floating-point register arguments (nfarg)
  buffer[A + 1] = last floating point argument
  ...
  buffer[A + 1 + nfarg - 1] = first floating point argument
  buffer[B + 0] = number of integer register arguments (narg)
  buffer[B + 1] = last integer argument
  ...
  buffer[B + 1 + narg - 1] = first integer argument
  
Here is the format of the return buffer:

  ret[0] = integer return value
  ret[1] = floating point return value

Here is the pseudo-code of the implementation:
  Let ARG0, ARG1, ARG2 be the C integer arguments.
  Let TMP0, TMP1 be integer scratch registers (Neither a C argument
  nor a C preserved register)

  On Entry:
    ARG0 is fptr
    ARG1 is args buffer
    ARG2 is ret buffer

  Save the return buffer (ARG2) to [RSP - 8]
  Preserve the stack in ARG2
  RSP -= 8

  Decrement RSP by shadow space if necessary
  RSP -= shadow space

  Use TMP0 as the counter register in the following code.
  counter (TMP0) = [args buffer (ARG1)]
  args buffer (ARG1) += 8
  while counter (TMP0) != 0
    RSP -= 8
    [RSP] = [args buffer (ARG1)] (Using TMP1 as swap)
    args buffer (ARG1) += 8
    counter (TMP0) -= 1

  Prepare stack frame for call
  RSP -= 8
  RSP &= -16
  [RSP] = preserved stack (ARG2)

  At this point:
    ARG0 is fptr
    ARG1 is current point in args buffer
    
  numfargs (TMP0) = [args buffer (ARG1)]
  args buffer (ARG1) += 8
  jump [FREGTABLE + numfargs << 3] (using TMP1 for swap)
fregs_max_fregs:
  FREG_MAX = [args buffer (ARG1)]
  args buffer (ARG1) += 8
...
fregs_0:

  move fptr from ARG0 to TMP0
  move buffer from ARG1 to TMP1
  numargs (ARG0) = [args buffer (TMP1)]
  args buffer (TMP1) += 8
  jump [REGTABLE + numargs (ARG0) << 3] (using ARG1 for swap)
regs_max_regs:
  REG_MAX = [args buffer (TMP1)]
  args buffer (TMP1) += 8
...  
regs_0:

  Call the function.
  call [fptr (TMP0)]

  Restore frame pointer
  RSP = [RSP]

  Restore buffer and write out return values
  buffer (TMP0) = [RSP - 8]
  [buffer (TMP) + 0] = R0
  [buffer (TMP) + 8] = F0

  Return
  ret

;============================================================
;=======================================================<doc>

defn compile-c-trampoline-stub (stitcher:Stitcher, emitter:CodeEmitter) :
  val stubs = stubs(stitcher)
  val backend = backend(stubs)
  defn E (i:Ins) : emit(emitter, i)

  ;Discover temp registers
  val tmp-regs = to-tuple(rs) where :
    val rs = to-intset(0 to num-regs(backend))
    defn remove-r (r:Int) : remove(rs, r)
    remove-r(0) ;num farg argument
    do(remove-r, callc-regs(backend))
    do(remove-r, c-preserved-regs(backend))

  ;Registers
  val ARG0 = R(callc-regs(backend)[0])
  val ARG1 = R(callc-regs(backend)[1])
  val ARG2 = R(callc-regs(backend)[2])
  val TMP0 = R(tmp-regs[0])
  val TMP1 = R(tmp-regs[1])
  val PRESERVED = R(c-preserved-regs(backend)[0])

  ;Shadow space
  val shadow-space = match(backend) :
    (backend:W64Backend) : 4 * 8
    (backend) : 0

  ;Entry
  E $ ExLabel(`c_trampoline)

  ;Save the return buffer (ARG2) to [RSP - 8]
  ;Preserve the stack in ARG2
  ;Decrement RSP by shadow space if necessary
  E $ StoreL(RSP, ARG2, -8)
  E $ StoreL(RSP, PRESERVED, -16)
  E $ SetL(PRESERVED, RSP)

  ;Shift RSP down
  E $ LoadL(TMP0, ARG1)
  E $ ShlL(TMP0, TMP0, INT(3))
  E $ SubL(RSP, RSP, TMP0)
  E $ SubL(RSP, RSP, INT(frame-size)) where :
    val frame-size = 8 ;saved return buffer
                   + 8 ;saved preserved register
                   + shadow-space ;shadow space
                   + 8 ;alignment operator
  E $ AndL(RSP, RSP, INT(-16))                 

  ;Reset RSP to prepare to put arguments in
  E $ AddL(RSP, RSP, TMP0)

  ;Use TMP0 as the counter register in the following code.
  ;counter (TMP0) = [args buffer (ARG1)]
  ;args buffer (ARG1) += 8
  ;while counter (TMP0) != 0
  ;  RSP -= 8
  ;  [RSP] = [args buffer (ARG1)] (Using TMP1 as swap)
  ;  args buffer (ARG1) += 8
  ;  counter (TMP0) -= 1
  let :
    val loop = unique-id(stubs)
    val loopend = unique-id(stubs)
    E $ LoadL(TMP0, ARG1)
    E $ AddL(ARG1, ARG1, INT(8))
    E $ Label(loop)
    E $ BreakL(M(loopend), EqOp(), TMP0, INT(0))
    E $ SubL(RSP, RSP, INT(8))
    E $ LoadL(TMP1, ARG1)
    E $ StoreL(RSP, TMP1)
    E $ AddL(ARG1, ARG1, INT(8))
    E $ SubL(TMP0, TMP0, INT(1))
    E $ Goto(M(loop))
    E $ Label(loopend)
  
  ;At this point:
  ;  ARG0 is fptr
  ;  ARG1 is current point in args buffer

  ;Jump table utility function
  ;Jump to the address stored in table[option].
  ;Destroys option and tmp registers.
  defn goto-jump-table (table:Int, option:Reg, tmp:Reg) :
    E $ ShlL(option, option, INT(3))
    E $ SetL(tmp, M(table))
    E $ AddL(tmp, tmp, option)
    E $ LoadL(tmp, tmp)
    E $ Goto(tmp)

  ;numfargs (TMP0) = [args buffer (ARG1)]
  ;args buffer (ARG1) += 8
  ;jump [FREGTABLE + numfargs (TMP0) << 3] (using TMP1 for swap)
  ;fregs_max_fregs:
  ;FREG_MAX = [args buffer (ARG1)]
  ;args buffer (ARG1) += 8
  ;...
  ;fregs_0:
  val fregtable = unique-id(stubs)
  val freglabels = to-tuple $ let :
    val fregs = to-tuple(callc-fregs(backend))
    for i in 0 through length(fregs) seq :
      unique-id(stubs) => F(fregs[i - 1]) when i > 0
  E $ LoadL(TMP0, ARG1)
  E $ AddL(ARG1, ARG1, INT(8))
  goto-jump-table(fregtable, TMP0, TMP1)
  for entry in in-reverse(freglabels) do :
    E $ Label(key(entry))
    if value(entry) is-not False :
      val freg = value(entry) as FReg
      E $ LoadD(freg, ARG1)
      E $ AddL(ARG1, ARG1, INT(8))

  ;move fptr from ARG0 to TMP0
  ;move buffer from ARG1 to TMP1
  E $ SetL(TMP0, ARG0)
  E $ SetL(TMP1, ARG1)

  ;numargs (ARG0) = [args buffer (TMP1)]
  ;args buffer (TMP1) += 8
  ;jump [REGTABLE + numargs (ARG0) << 3] (using ARG1 for swap)
  ;regs_max_regs:
  ;REG_MAX = [args buffer (TMP1)]
  ;args buffer (TMP1) += 8
  ;...  
  ;regs_0:
  val regtable = unique-id(stubs)
  val reglabels = to-tuple $ let :
    val regs = to-tuple(cat([0], callc-regs(backend)))
    for i in 0 through length(regs) seq :
      unique-id(stubs) => R(regs[i - 1]) when i > 0
  E $ LoadL(ARG0, TMP1)
  E $ AddL(TMP1, TMP1, INT(8))
  goto-jump-table(regtable, ARG0, ARG1)
  for entry in in-reverse(reglabels) do :
    E $ Label(key(entry))
    if value(entry) is-not False :
      val reg = value(entry) as Reg
      E $ LoadL(reg, TMP1)
      E $ AddL(TMP1, TMP1, INT(8))

  ;Call the function.
  E $ Call(TMP0)

  ;Restore frame pointer
  E $ SetL(RSP, PRESERVED)
  E $ LoadL(PRESERVED, RSP, -16)

  ;Restore buffer and write out return values
  ;buffer (TMP0) = [RSP - 8]
  ;[buffer (TMP0) + 0] = R0
  ;[buffer (TMP0) + 8] = F0
  E $ LoadL(TMP0, RSP, -8)
  E $ StoreL(TMP0, R0, 0)
  E $ StoreD(TMP0, F0, 8)

  ;Return
  E $ Return()

  ;Emit jump tables
  E $ DefData()
  E $ Label(fregtable)
  for entry in freglabels do :
    E $ DefLabel(key(entry))
  E $ Label(regtable)
  for entry in reglabels do :
    E $ DefLabel(key(entry))
  E $ DefText()
