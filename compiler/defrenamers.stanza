#include<"core/stringeater.stanza">
#include<"core/macro-utils.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">
#include<"compiler/stz-algorithms.stanza">

defpackage stz/renamer-lang :
   import core
   import verse
   import core/macro-utils
   import stz/lexer

;======== Parse Structures ========
definterface Arg
defstruct SimpleArg <: Arg :
   name: Symbol
   type: Symbol
defstruct IgnoreArg <: Arg :
   name: Symbol
defstruct ScopeArg <: Arg :
   args: List<Arg>
defstruct GroupArg <: Arg :
   args: List<Arg>
defstruct PublicArg <: Arg :
   args: List<Arg>

definterface Body
defstruct IgnoreBody <: Body
defstruct FormBody <: Body :
   args: List<Arg>
defstruct MapBody <: Body :
   type: Symbol
defstruct RecurBody <: Body :
   type: Symbol

defstruct Clause :
   node: Symbol
   body: Body

definterface Renamer
defmulti abbr (r:Renamer) -> Symbol
defmulti name (r:Renamer) -> Symbol
defstruct TypeRenamer <: Renamer :
   abbr: Symbol with: (as-method => true)
   name: Symbol with: (as-method => true)
   clauses: List<Clause>
defstruct CustomRenamer <: Renamer :
   abbr: Symbol with: (as-method => true)
   name: Symbol with: (as-method => true)
   arglist: List
   body

defstruct DefRenamers :
   renamers: List<Renamer>

;======== Syntax Definition ========
defsyntax stz/check-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      prefix-op = (defrenamers : (?rs:#renamer ...)) :
         compile(DefRenamers(rs))

      renamer = (custom ?abbr:#sym ?name:#name? (?arglist ...) : ?body:#exp) :
         CustomRenamer(abbr, name, arglist, body)
      renamer = (?abbr:#sym ?name:#name? : (?cs:#clause ...)) :
         TypeRenamer(abbr, name, cs)      
      name? = ((@do ?name:#sym)) : name      
      name? = () : gensym()

      clause = (?node:#sym : ?b:#body) :
         Clause(node, b)
      body = (goto ?type:#sym) :
         RecurBody(type)
      body = ((~ _:?)) :
         IgnoreBody()
      body = ((~ _:?type:#sym)) :
         MapBody(type)
      body = ((?xs:#arg ...)) :
         FormBody(xs)
         
      arg = (?x:#sym : ?) :
         IgnoreArg(x)
      arg = (?x:#sym : ?t:#sym) :
         SimpleArg(x, t)
      arg = ({?xs:#arg ...}) :
         ScopeArg(xs)
      arg = (group{?xs:#arg ...}) :
         GroupArg(xs)
      arg = (public{?xs:#arg ...}) :
         PublicArg(xs)

      ; === Temp ===
      exp = (?x) : x


;======== Compilation ========
defn fill-each<?T> (f: T -> Streamable<KeyValue<Symbol,?>>, xs:Streamable<?T>) :
   nested(stream(f, xs))

defn compile (d:DefRenamers) :
   defn memoize<?T> (f: Symbol -> ?T) :
      val table = HashTable<Symbol,T>(symbol-hash)
      fn (x:Symbol) :
         if not key?(table, x) :
            table[x] = f(x)
         table[x]

   ;Temporary names
   val #e = gensym()

   ;Temporary names for arguments
   val arg-names = memoize(gensym)
   defn #name (a:SimpleArg|IgnoreArg) :
      arg-names(name(a))
   defn #names (a:List<Arg>) -> List<Symbol> :
      map-append(#names, a)
   defn #names (a:Arg) :
      match(a) :
         (a:SimpleArg|IgnoreArg) : list(#name(a))
         (a:ScopeArg|GroupArg|PublicArg) : #names(args(a))      

   ;Renamer name given abbreviation
   val abbr-name = memoize $ fn (ab:Symbol) :
      val r = for r in renamers(d) find :
         abbr(r) == ab
      match(r) :
         (r:False) : error("No renamer with abbreviation ~." % [ab])
         (r:Renamer) : name(r)
   defn #type (a:SimpleArg) : abbr-name(type(a))
   defn #type (b:MapBody|RecurBody) : abbr-name(type(b))

   defn compile (a:Arg) :
      match(a) :
         (a:SimpleArg) :
            fill-template(`(val #name = #map(t, name(e))), [
               `t => #type(a)
               `name => name(a)
               `#name => #name(a)
               `e => #e])
         (a:IgnoreArg) :
            fill-template(`(val #name = name(e)), [
               `name => name(a)
               `#name => #name(a)
               `e => #e])
         (a:ScopeArg) :
            val template = `(
               begin-scope()
               args
               end-scope())               
            fill-template(template, [
               `args => splice(stream(compile, args(a)))])
         (a:GroupArg) :
            val template = `(
               begin-group()
               args
               end-group())
            fill-template(template, [
               `args => splice(stream(compile, args(a)))])
         (a:PublicArg) :
            val template = `(
               val #vis = visibility
               visibility = Public()
               args
               visibility = #vis)
            fill-template(template, [
               `#vis => gensym()
               `args => splice(stream(compile, args(a)))])

   defn compile (node:Symbol, b:Body) :
      match(b) :
         (b:IgnoreBody) :
            #e            
         (b:FormBody) :
            fill-template(`(args, Node(#args)), [
               `args => splice(stream(compile, args(b)))
               `#args => splice(#names(args(b)))
               `Node => node])            
         (b:MapBody) :
            fill-template(`(map(t, e)), [
               `t => #type(b)
               `e => #e])
         (b:RecurBody) :
            fill-template(`(t(e)), [
               `t => #type(b)
               `e => #e])

   defn compile (r:Renamer) :
      match(r) :
         (r:TypeRenamer) :
            val template = `(
               defn name (e:IExp) :
                  match(e) :
                     clauses{(e:Node) : body})
            fill-template(template, [
               `name => name(r)
               `e => #e
               `clauses => for c in clauses(r) fill-each : [
                  `Node => node(c)
                  `body => compile(node(c), body(c))]])
         (r:CustomRenamer) :
            val template = `(defn name arglist : body)
            fill-template(template, [
               `name => name(r)
               `arglist => arglist(r)
               `body => body(r)])

   val r = list(map(compile, renamers(d)))
   println("=== defrenamer ===")
   println(r)
   r

;;======== Debuggin ========
;#with-overlay(stz/printer-lang) :
;   defprinter (e:CType) :
;      SymType :
;         ($sym type)
;      RestType :
;         ($rest type)
;      ListType :
;         ($list types ...)
;
;   defprinter (e:Checker) :
;      FormChecker :
;         ($form (args ...) (types ...))
;      IfChecker :
;         ($if pred conseq alt)
;      CustomChecker :
;         ($custom exp)
;      SwitchChecker :
;         ($switch pred (clauses ...) else-clause)
;      BeginChecker :
;         ($begin checkers ...)
;
;   defprinter (e:Clause) :
;      TypeClause :
;         ($type type checker)
;      PlusClause :
;         ($plus type)
;      AfterClause :
;         ($after exp)
;
;   defprinter (e:FormSpec) :
;      FormSpec :
;         ($spec type description clauses ...)
;
;   defprinter (e:DefCheck) :
;      DefCheck :
;         ($defcheck exp type specs ...)

;======== Test ========
defn main () :
   val filename = commandline-arguments()[1]
   val lexed = lex-file(filename)
   with-syntax(stz/check-lang) :
      match-syntax(lexed) :
         (?e:#prefix-op) :
            println(e)
main()