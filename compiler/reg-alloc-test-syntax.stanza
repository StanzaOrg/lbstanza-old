defpackage stz/reg-alloc-test-syntax :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-reader
  import stz/reg-alloc-ports
  import stz/reg-alloc-errors
  import stz/printing-utils
  import stz/reg-alloc-model-properties

;============================================================
;==================== Datastructures ========================
;============================================================

;Represents programs to analyze, and the models to use
;to analyze them.
public defstruct AnalyzePrograms :
  num-regs: Int
  num-fregs: Int
  programs: Tuple<NameAndProgram>
  models: Tuple<OperationModel>

;Represents blocks to analyze, and the models to use
;to analyze them.
public defstruct AnalyzeBlocks :
  num-regs: Int
  num-fregs: Int
  blocks: Tuple<NameAndBlock>
  models: Tuple<OperationModel>

;A program together with a name.
public defstruct NameAndProgram :
  name:Symbol
  program:Program

;Represents a model to analyze, and the contexts under
;which to analyze them.
public defstruct AnalyzeModel :
  name: Symbol
  num-regs: Int
  num-fregs: Int
  model: OperationModel
  contexts: Tuple<UsageContext>

;Represents a shuffle to analyze.
public defstruct AnalyzeShuffle :
  name:Symbol
  vars:Tuple<Int>
  inputs:Tuple<Register>
  saved:Tuple<True|False>
  outputs:Tuple<Location>
  free-reg:Reg|False
  free-freg:FReg|False

;Represents only the statements for a block.
;Used for setting up a block for testing the analysis functions.
public defstruct NameAndBlock :
  name:Symbol
  vars:Tuple<VarDef>
  inputs:Tuple<Port>
  stmts:Tuple<ProgramStmt>
  outputs:Tuple<Port>

;============================================================
;====================== Printers ============================
;============================================================

defmethod print (o:OutputStream, b:NameAndBlock) :
  val items = [
    named-list-fields("vars", vars(b))
    named-list-fields("inputs", inputs(b))
    named-list-fields("stmts", stmts(b))
    named-list-fields("outputs", outputs(b))]
  print(o, "block %~%_" % [name(b), colon-field-list(items)])

defmethod print (o:OutputStream, s:AnalyzeShuffle) :
  defn input-str (v:Int, input:Register, saved:True|False) :
    val save-str = " (saved)" when saved else ""
    "V%_:%_%_" % [v, input, save-str]
  val items = [
    "inputs: (%,)" % [seq(input-str, vars(s), inputs(s), saved(s))]
    "outputs: (%,)" % [outputs(s)]
    falseable-field("free-reg", free-reg(s))
    falseable-field("free-freg", free-freg(s))]
  print(o, "analyze-shuffle %_%_" % [name(s), colon-field-list(items)])

;============================================================
;==================== Reader Functions ======================
;============================================================

;Parse a list of AnalyzeModel structures from the given forms.
public defn parse-models (forms) -> Tuple<AnalyzeModel> :
  to-tuple $ parse-syntax[reg-alloc-test-syntax / #analyze-model ...](forms)

;Parse the given forms as programs and models.
public defn parse-progs-and-models (forms:List) -> AnalyzePrograms :
  parse-syntax[reg-alloc-test-syntax / #analyze-programs](forms)

;Parse a list of AnalyzeShuffle structures from the given forms.
public defn parse-shuffles (forms) -> Tuple<AnalyzeShuffle> :
  to-tuple $ parse-syntax[reg-alloc-test-syntax / #analyze-shuffle ...](forms)

;Parse a list of AnalyzeModel structures from the given forms.
public defn parse-blocks-and-models (forms) -> AnalyzeBlocks :
  parse-syntax[reg-alloc-test-syntax / #analyze-blocks](forms)

;============================================================
;==================== Testing Syntax ========================
;============================================================

;Syntax for representing a model to analyze.
defsyntax reg-alloc-test-syntax :
  import (int!, symbol!, register,
          reg, freg, varid, loc, vardef!, port!, pstmt!, prog) from reg-alloc-ir
  public import model! from reg-alloc-ir

  public defproduction analyze-model: AnalyzeModel
  defrule analyze-model = (analyze ?name:#symbol! :
                             num-regs: ?num-regs:#int!
                             num-fregs: ?num-fregs:#int!
                             ?model:#model!
                             ?ctxts:#usage-ctxt! ...) :
    AnalyzeModel(name, num-regs, num-fregs, model, to-tuple(ctxts))

  public defproduction analyze-shuffle: AnalyzeShuffle
  defrule analyze-shuffle = (analyze-shuffle ?name:#symbol! :
                               inputs: (?shuf-inputs:#shuffle-input ...)
                               outputs: (?outputs:#loc ...)
                               ?free-reg:#free-reg?
                               ?free-freg:#free-freg?) :
    val vars = Vector<Int>()
    val inputs = Vector<Register>()
    val saved = Vector<True|False>()
    for [v, input, save] in shuf-inputs do :
      add(vars, v)
      add(inputs, input)
      add(saved, save)
    AnalyzeShuffle(name,
                   to-tuple(vars),
                   to-tuple(inputs),
                   to-tuple(saved),
                   to-tuple(outputs),
                   free-reg,
                   free-freg)

  public defproduction analyze-programs: AnalyzePrograms
  defrule analyze-programs = (num-regs: ?num-regs:#int!
                              num-fregs: ?num-fregs:#int!
                              ?programs:#named-program ...
                              ?models:#model! ...) :
    AnalyzePrograms(
      num-regs,
      num-fregs,
      to-tuple(programs),
      to-tuple(models))

  public defproduction analyze-blocks: AnalyzeBlocks
  defrule analyze-blocks = (num-regs: ?num-regs:#int!
                            num-fregs: ?num-fregs:#int!
                            ?blocks:#named-block ...
                            ?models:#model! ...) :
    AnalyzeBlocks(
      num-regs,
      num-fregs,
      to-tuple(blocks),
      to-tuple(models))

  defproduction named-program: NameAndProgram
  defrule named-program = (program ?name:#symbol! :
                             vars: (?vars:#vardef! ...)
                             ?stmts:#pstmt! ...) :
    NameAndProgram(
      name,
      Program(to-tuple(vars), to-tuple(stmts)))

  defproduction named-block: NameAndBlock
  defrule named-block = (block ?name:#symbol! :
                           vars: (?vars:#vardef! ...)
                           inputs: (?inputs:#port! ...)
                           instructions: (?stmts:#pstmt! ...)
                           outputs: (?outputs:#port! ...)) :
    NameAndBlock(
      name
      to-tuple(vars)
      to-tuple(inputs)
      to-tuple(stmts)
      to-tuple(outputs))

  defproduction shuffle-input: [Int, Register, True|False]
  defrule shuffle-input = (?v:#varid : ?r:#register ?s:#saved?) : [v, r, s]

  defproduction saved?: True|False
  defrule saved? = ((saved)) : true
  defrule saved? = () : false

  defproduction free-reg?: Reg|False
  defrule free-reg? = (free-reg: ?r:#reg)
  defrule free-reg? = () : false

  defproduction free-freg?: FReg|False
  defrule free-freg? = (free-freg: ?r:#freg)
  defrule free-freg? = () : false

  defproduction usage-ctxt: UsageContext
  defrule usage-ctxt = (UsageContext(killed = [?killed:#int! ...])) :
    UsageContext(to-tuple(killed))

  defproduction usage-ctxt!: UsageContext
  defrule usage-ctxt! = (?c:#usage-ctxt)
  fail-if usage-ctxt! = () :
    RegAllocSyntaxError(closest-info(), "Invalid usage context syntax.")