defpackage stz/resolver :
   import core
   import collections
   import stz/il-ir
   import stz/namemap
   import stz/primitives
   import stz/utils

;============================================================
;===================== Defresolver ==========================
;============================================================

#use-overlay(stz/resolver-lang)
defresolver resolve-exp (e:IExp, eng:Engine) :

   ;     Resolving Stanza Expressions
   ;     ----------------------------   
   ;Resolve top level expressions
   resolve te :
      IBegin: (exps:te)
      IDefType: {args:+, parent:t, children:te}
      IDefChild: (name:c, {args:+, parent:t})
      IDef: (type:t, value:e)
      IDefVar: (type:t, value:e)
      IDefn: {targs:+, args:+, a1:t, a2:t, body:e}
      IDefmulti: {targs:+, a1:t, a2:t}
      IDefmethod: (multi:m, {targs:+, args:+, a1:t, a2:t, body:e})
      IPublic: (exp:te)
      IProtected: (exp:te)
      + ltc
      + e

   ;Resolve Stanza expressions
   resolve e :
      Let: (def:e, body:e)
      LetRec: (defns:f+, defns:f, body:e)
      ILet: {exp:e}
      IDef: (type:t, value:e, name:+)
      IDefVar: (type:t, value:e, name:+)
      IFn: (a1:t, a2:t, {args:+, body:e})
      IBranch: (types:t, {args:+, body:e})
      INew: (class:pt, methods:dm)
      ICast: (exp:e, type:t)
      IUpCast: (exp:e, type:t)
      ISet: (name:v, value:e)
      IPrim: (op:prim, args:e)
      IDo: (func:farg, args:e)
      IVar: resolve var
      ILiteral: ()
      INone: ()
      IMulti: (_:e)
      IBegin: (_:e)
      IMatch: (_:e)
      ITuple: (_:e)      

   ;Stanza Nested functions
   resolve f :
      IDefn: {targs:+, args:+, a1:t, a2:t, body:e}

   ;Function arguments used in do forms
   resolve farg :
      IOf: (class:e, args:t)
      + e

   ;Nested defmethods in new forms
   resolve dm :
      IDefmethod: (multi:m, {targs:+, args:+, a1:t, a2:t, thisn:this, body:e})

   ;For resolving multis in defmethod forms
   resolve m :
      IVar: resolve multi

   ;For resolving the this argument in nested defmethod forms
   resolve this (Int|False) :
      Int|False: resolve this

   ;For resolving mutable variables in set forms
   resolve v :
      IVar: resolve mutable-var

   ;For resolving HiStanza primitive
   resolve prim :
      IVar: resolve prim

   ;For scanning for nested functions in a letrec form
   define f+ :
      IDefn: (name:+)

   ;     Resolving Types
   ;     ---------------
   ;Resolving a HiStanza type
   resolve t :
      IVar: resolve type
      ICap: (name:cap)
      IOf: (class:c, args:t)
      IExp: (_:t)
      
   ;For resolving class in a A<X> form
   resolve c :
      IVar: resolve class

   ;For resolving the captured type variable
   resolve cap :
      IVar: resolve capvar

   ;     Resolving Parent Types
   ;     ----------------------
   resolve pt :
      IVar: resolve raw-hs-class
      IOf: (class:hclass, args:t)
      IExp: (_:pt)
   resolve hclass :
      IVar: resolve hs-class

   ;     Resolving LoStanza
   ;     ------------------
   ;For resolving top level LoStanza commands
   resolve ltc :
      IBegin: (exps:ltc)
      ILSDef: (exp:le, type:lt)
      ILSDefVar: (exp:le, type:lt)
      ILSDefType: {args:+, parent:pt, types:lt, rtype:lt}
      ILSExtern: (type:lt)
      ILSDefn: {targs:+, a1:lt, a2:lt, args:+, body:lc}
      ILSDefmethod: (multi:m, {targs:+, a1:lt, a2:lt, args:+, body:lc})
      + lc

   ;For resolving LoStanza commands
   resolve lc :
      IBegin: (exps:lc)
      ILSSet: (exp:lval, value:le)
      ILSLabels: {names:+, body:lc}
      ILSLabel: (name:lbl)
      ILSGoto: (name:lbl)
      ILSReturn: (exp:le)
      ILSLet: {comm:lc}
      ILSIf: (pred:le, {conseq:lc}, {alt:lc})
      ILSMatch: (args:le, branches:lc)
      ILSBranch: (types:lt, {args:+, body:lc})
      ILSDef: (exp:le, type:lt, name:+)
      ILSDefVar: (exp:le, type:lt, name:+)
      ILSDo: (func:lfarg, args:le)
      ILSDoInStack: (ret:lt, func:lfarg, args:le)
      ILSDoStack: (ret:lt, func:le, arg:le)
      ILSPrim: (op:lprim, args:le)
      ILSCallC: (_:le)

   ;For resolving a LoStanza expression
   resolve le :
      IVar: resolve var
      ILSAddr: (exp:lval)
      ILSNew: (type:lt, args:le)
      ILSArray: (type:lt, args:le, length:le)
      ILSStruct: (type:lt, args:le)
      ILSField: (exp:le)
      ILSDo: (func:lfarg, args:le)
      ILSDoInStack: (ret:lt, func:lfarg, args:le)
      ILSDoStack: (ret:lt, func:le, arg:le)
      ILSPrim: (op:lprim, args:le)
      ILSSizeof: (type:lt)
      ILSTagof: (name:lclass)
      ILSAs: (exp:le, type:lt)
      ILSFn: (ref:fn)
      ILiteral: ()
      IExp: (_:le)

   ;For resolving functions in ls-fn forms
   resolve fn :
      IVar: resolve function

   ;For resolving labels in label/goto forms
   resolve lbl :
      IVar: resolve label

   ;For resolving the lvalue expression in a set form
   resolve lval :
      IVar: resolve var
      ILSDeref: (exp:le)
      ILSSlot: (exp:le index:le)
      ILSField: (exp:le)

   ;For resolving the name argument of a prim form
   resolve lprim :
      IVar: resolve ls-prim

   ;For resolving the function argument of a do form
   resolve lfarg :
      ILSOfT: (class:le, args:t)
      + le

   ;For resolving a LoStanza type
   resolve lt :
      IVar: resolve raw-ls-class
      ILSOfT: (class:lclass, args:t)
      ILSRefT: (type:t)
      IExp: (_:lt)
   resolve lclass :
      IVar: resolve ls-class


;============================================================
;=================== Implementation =========================
;============================================================

deftype Bucket
defmulti add (b:Bucket, n:Int, x:Symbol, scope:Int) -> False
defmulti get (b:Bucket, x:Symbol, scope:Int) -> List<Int>

defn Bucket () :
   val table = HashTable<[Symbol,Int], List<Int>>()
   new Bucket :
      defmethod add (this, n:Int, x:Symbol, scope:Int) :
         table[[x,scope]] = cons(n, this[x,scope])
      defmethod get (this, x:Symbol, scope:Int) :
         get?(table, [x,scope], List())

deftype ScopeBucket
defmulti add (s:ScopeBucket, x:Symbol, i:Int) -> False
defmulti begin-scope (s:ScopeBucket) -> False
defmulti end-scope (s:ScopeBucket) -> False
defmulti get (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>
defmulti get-local (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>
defmulti get-top (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>

defn ScopeBucket () :
   val bucket = Bucket()
   val scopes = Vector<Int>()
   val scope-counter = to-seq(1 to false)
   add(scopes, next(scope-counter))

   new ScopeBucket :
      defmethod add (this, x:Symbol, n:Int) :
         add(bucket, n, x, peek(scopes))
      defmethod begin-scope (this) :
         add(scopes, next(scope-counter))
      defmethod end-scope (this) :
         pop(scopes)
         false
      defmethod get (this, x:Symbol, f:Int -> True|False) :
         label<List<Int>> return :
            for s in in-reverse(scopes) do :
               val es = filter(f, bucket[x, s])
               return(to-list(es)) when not empty?(es)
            List()   
      defmethod get-local (this, x:Symbol, f:Int -> True|False) :
         to-list(filter(f, bucket[x, peek(scopes)]))
      defmethod get-top (this, x:Symbol, f:Int -> True|False) :
         to-list(filter(f, bucket[x, scopes[0]]))

;======== Prefixer ========
deftype Prefixer
defmulti set-all-prefix (p:Prefixer, prefix:Symbol) -> False
defmulti set-prefix (p:Prefixer, xs:List<Symbol>, prefix:Symbol) -> False
defmulti prefix (p:Prefixer, x:Symbol) -> Symbol

defn Prefixer () :
   var all-prefix:String|False = false
   val prefix-table = HashTable<Symbol,String>()

   new Prefixer :
      defmethod set-all-prefix (this, prefix:Symbol) :
         all-prefix = to-string(prefix)
         clear(prefix-table)
      defmethod set-prefix (this, xs:List<Symbol>, prefix:Symbol) :
         for x in xs do :
            prefix-table[x] = to-string(prefix)
      defmethod prefix (this, x:Symbol) :
         if key?(prefix-table, x) :
            symbol-join([prefix-table[x], x])
         else if all-prefix is-not False :
            symbol-join([all-prefix, x])
         else :
            x

;======== Base Environments ========
defstruct ResolveError <: Exception

defn make-prefixer (ps:List<IPrefix>) :
   defn prefix! (p:IPrefix) : name(prefix(p) as IVar)
   val prefixer = Prefixer()
   for p in ps do :
      match(names(p)) :
         (ns:False) : set-all-prefix(prefixer, prefix!(p))
         (ns:List<IVar>) : set-prefix(prefixer, map(name, ns), prefix!(p))
   prefixer

defn info-string (i:False|FileInfo) :
   match(i) :
      (i:False) : ""
      (i:FileInfo) : "%_: " % [i]

defn make-base-scopes (nm:NameMap, es:List<LetPackage>) :
   defn package! (i:IImport) : name(package(i) as IVar)

   ;Errors
   val errors = Vector<?>()
   defn no-package (info:False|FileInfo, name:Symbol) :
      add{errors, _} $
      "%_Failed to import undefined package %~." % [info-string(info), name]

   ;Classify defined globals
   val public-defs = HashTable<Symbol, Vector<Int>>()
   val protected-scopes = HashTable<Symbol, ScopeBucket>()
   val private-scopes = HashTable<Symbol, ScopeBucket>()
   for p in es do :
      val n = name(p)
      private-scopes[n] = ScopeBucket()
      protected-scopes[n] = ScopeBucket()
      public-defs[n] = Vector<Int>()
   for v in globals(nm) do :
      val [n, p, name, vis] = [n(v), package(v), name(v), visibility(v)]
      add(private-scopes[p], name, n) when vis is Private|Protected|Public
      add(protected-scopes[p], name, n) when vis is Protected|Public
      add(public-defs[p], n) when vis is Public

   ;Execute imports
   for e in es do :
      val [p, imports] = [name(e), imports(e) as List<IImport>]
      val scope = private-scopes[p]
      for i in imports do :
         val prefixer = make-prefixer(prefix(i) as List<IPrefix>)
         match(get?(public-defs, package!(i), false)) :
            (defs:Vector<Int>) :
               for n in defs do :
                  val name = prefix(prefixer, name(nm[n]))
                  add(scope, name, n)
            (f:False) :
               no-package(info(i), package!(i))

   ;Resolve errors
   if not empty?(errors) :
      do(println, errors)
      throw(ResolveError())

   ;Return protected and private scopes
   [protected-scopes, private-scopes]

;======== Resolve Engine ========
deftype Engine
defmulti new-definitions (eng:Engine, e:IExp) -> False
defmulti push-scope (eng:Engine) -> False
defmulti pop-scope (eng:Engine) -> False
defmulti resolve (e, eng:Engine, type:Symbol) -> ?

public defn resolve (nm:NameMap, e:IExp) -> IExp :
   ;======== Error System ========
   val errors = Vector<?>()
   defn resolve-error (msg) :
      add(errors, msg)
      throw(ResolveError())
   defn no-resolve (v:IVar) :
      resolve-error $
      "%_Could not resolve %~." % [info-string(info(v)), name(v)]
   defn amb-resolve (v:IVar, ns:List<Int>) :
      val others = for n in ns seq :
         val e = nm[n]
         "\n   %_%~ defined in package %~" % [info-string(info(e)), name(e), package(e)]
      resolve-error $ "%_Ambiguous reference to %~. Possibilities include:%*" %
         [info(v), name(v), others]
   defn not-mutable (v:IVar) :
      resolve-error $ "%_Cannot assign to immutable value %~." % [info-string(info(v)), name(v)]
   defn not-cap (v:IVar) :
      resolve-error $ "%_Cannot capture explicit type argument %~." % [info-string(info(v)), name(v)]
   defn no-package (info:False|FileInfo, name:Symbol) :
      resolve-error $ "%_No package found with name %~." % [info-string(info), name]
   defn not-hs-class (v:IVar) :
      resolve-error $ "%_Expected a HiStanza type here but received %~." % [info-string(info(v)), name(v)]
   defn not-ls-class (v:IVar) :
      resolve-error $ "%_Expected a LoStanza type here but received %~." % [info-string(info(v)), name(v)]
   defn not-fn (v:IVar) :
      resolve-error $ "%_Expected a function here but received %~." % [info-string(info(v)), name(v)]
   defn not-ls-prim (v:IVar) :
      resolve-error $ "%_%~ is not a recognized LoStanza primitive." % [info-string(info(v)), name(v)]
   defn not-prim (v:IVar) :
      resolve-error $ "%_%~ is not a recognized Stanza primitive." % [info-string(info(v)), name(v)]
   defn resolve-errors () :
      if not empty?(errors) :
         do(println, errors)
         throw(ResolveError())

   ;======== Find packages ========
   defn find-packages (e:IExp) :
      val ps = Vector<LetPackage>()
      defn loop (e:IExp) :
         match(e) :
            (e:LetPackage) : add(ps, e)
            (e) : do(loop, e)
      loop(e)
      to-list(ps)
   val ps = find-packages(e)

   ;======== Find base scopes ========
   val [protected-scopes, private-scopes] = make-base-scopes(nm, ps)

   ;======== Namespace Utilities ========
   defn type-pred (f: EType -> True|False) -> Int -> True|False :
      fn (i:Int) :
         f(type(nm[i]))
   defn get-name (e:VarN) :
      name(nm[n(e)])

   ;======== Resolve in a given package ========
   defn resolve (p:LetPackage) :
      val scope = private-scopes[name(p)]

      defn get-qualified-scope (info:False|FileInfo, str:False|Symbol) -> ScopeBucket :
         match(str) :
            (str:False) : scope
            (str:Symbol) :
               match(get?(protected-scopes, str, false)) :
                  (s:ScopeBucket) : s
                  (s:False) : no-package(info, str)

      defn resolve-name (name:Symbol, pass?: Int -> True|False) :
         if qualified?(name) :
            val [package, name] = qualifier(name)
            val scope = get-qualified-scope(info(e), package)
            get-top(scope, to-symbol(name), pass?)
         else :
            scope[name, pass?]

      defn resolve-one (e:IVar, pass?: Int -> True|False) :
         val ns = resolve-name(name(e), pass?)
         val l = length(ns)
         if l == 0 : no-resolve(e)
         else if l == 1 : head(ns)
         else : amb-resolve(e, ns)

      defn resolve-many (e:IVar, pass?: Int -> True|False) :
         val ns = resolve-name(name(e), pass?)            
         val l = length(ns)
         if l == 0 : no-resolve(e)
         else if l == 1 : head(ns)
         else : ns

      resolve-exp(body(p), engine) where :
         val engine = new Engine :
            defmethod new-definitions (this, e:IExp) :
               match(e) :
                  (e:VarN) : add(scope, get-name(e), n(e))
                  (e) : do(new-definitions{this, _}, e)

            defmethod push-scope (this) :
               begin-scope(scope)

            defmethod pop-scope (this) :
               end-scope(scope)

            defmethod resolve (e, this, type:Symbol) :
               val var? = type-pred({_ is LValE|LVarE|LFnE|ValE|VarE|FnE|MultiE})
               val mvar? = type-pred({_ is LVarE|VarE})
               val fn? = type-pred({_ is LFnE|FnE|MultiE})
               val multi? = type-pred({_ is MultiE})
               val type? = type-pred({_ is TVarE|CapVarE|TypeE|LTypeE})
               val class? = type-pred({_ is TypeE|LTypeE})
               val hs-class? = type-pred({_ is TypeE})
               val ls-class? = type-pred({_ is LTypeE})               
               val tvar? = type-pred({_ is TVarE|CapVarE})
               val capvar? = type-pred({_ is CapVarE})
               val label? = type-pred({_ is LabelE})

               try :
                  switch {type == _} :
                     `var :
                        match(resolve-many(e, var?)) :
                           (n:Int) :
                              VarN(n, info(e))
                           (ns:List<Int>) :
                              if all?(fn?, ns) : Mix(map(VarN{_, info(e)}, ns), info(e))
                              else : amb-resolve(e, ns)
                     `mutable-var :
                        val n = resolve-one(e, var?)
                        not-mutable(e) when not mvar?(n)
                        VarN(n, info(e))                        
                     `multi :
                        match(resolve-many(e, multi?)) :
                           (n:Int) : VarN(n, info(e))
                           (ns:List<Int>) : Mix(map(VarN{_, info(e)}, ns), info(e))
                     `this :
                        head(scope[`this, var?])
                     `type :
                        val n = resolve-one(e, type?)
                        if class?(n) : Raw(VarN(n, info(e)), info(e))
                        else : VarN(n, info(e))                        
                     `capvar :
                        val ns = get-local(scope, name(e), tvar?)
                        if empty?(ns) : no-resolve(e)
                        else if capvar?(head(ns)) : VarN(head(ns), info(e))
                        else : not-cap(e)
                     `class :
                        val n = resolve-one(e, class?)
                        VarN(n, info(e))
                     `raw-hs-class :
                        val n = resolve-one(e, type?)
                        if hs-class?(n) : Raw(VarN(n, info(e)), info(e))
                        else : not-hs-class(e)
                     `hs-class :
                        val n = resolve-one(e, type?)
                        if hs-class?(n) : VarN(n, info(e))
                        else : not-hs-class(e)
                     `raw-ls-class :
                        val n = resolve-one(e, type?)
                        if ls-class?(n) : Raw(VarN(n, info(e)), info(e))
                        else : not-ls-class(e)
                     `ls-class :
                        val n = resolve-one(e, type?)
                        if ls-class?(n) : VarN(n, info(e))
                        else : not-ls-class(e)
                     `label :
                        val n = resolve-one(e, label?)
                        VarN(n, info(e))
                     `function :
                        match(resolve-many(e, var?)) :
                           (n:Int) :
                              if fn?(n) : VarN(n, info(e))
                              else : not-fn(e)
                           (ns:List<Int>) :
                              if all?(fn?, ns) : Mix(map(VarN{_, info(e)}, ns), info(e))
                              else : amb-resolve(e, ns)
                     `ls-prim :
                        if ls-primitive?(name(e)) : e
                        else : not-ls-prim(e)
                     `prim :
                        if primitive?(name(e)) : e
                        else : not-prim(e)
                     else :
                        fatal("Unknown resolver %~" % [type])
               catch (err:ResolveError) :
                  e                          

   val resolved = map(resolve, ps)
   resolve-errors()
   IBegin(resolved, false)
