defpackage stz/resolver :
   import core
   import verse
   import stz/il-ir
   import stz/namemap

;============================================================
;===================== Defresolver ==========================
;============================================================

#use-overlay(stz/resolver-lang)
defresolver resolve-exp (e:IExp, eng:Engine) :

   ;     Resolving Stanza Expressions
   ;     ----------------------------   
   ;Resolve top level expressions
   resolve te :
      IBegin: (exps:te)
      IDefType: {args:+, parent:t}
      IDef: (type:t, value:e)
      IDefVar: (type:t, value:e)
      IDefn: {targs:+, args:+, a1:t, a2:t, body:e}
      IDefmulti: {targs:+, a1:t, a2:t}
      IDefmethod: (multi:m, {targs:+, args:+, a1:t, a2:t, body:e})
      IPublic: (exp:te)
      IProtected: (exp:te)
      + ltc
      + e

   ;Resolve Stanza expressions
   resolve e :
      Let: (def:e, body:e)
      IDef: (type:t, value:e, name:+)
      IDefVar: (type:t, value:e, name:+)
      LetRec: {defns:f+, defns:f, body:e}
      IFn: (a1:t, a2:t, {args:+, body:e})
      IBranch: (types:t, {args:+, body:e})
      INew: (class:pt, methods:dm)
      ICast: (exp:e, type:t)
      ISet: (name:v, value:e)
      IPrim: (args:e)
      IDo: (func:farg, args:e)
      IVar: resolve var
      ILiteral: ()
      IMulti: (_:e)
      IBegin: (_:e)
      IMatch: (_:e)
      ITuple: (_:e)


   ;Stanza Nested functions
   resolve f :
      IDefn: {targs:+, args:+, a1:t, a2:t, body:e}

   ;Function arguments used in do forms
   resolve farg :
      IOf: (class:e, args:t)
      + e

   ;Nested defmethods in new forms
   resolve dm :
      IDefmethod: (multi:m, {targs:+, args:+, a1:t, a2:t, thisn:this, body:e})

   ;For resolving multis in defmethod forms
   resolve m :
      IVar: resolve multi

   ;For resolving the this argument in nested defmethod forms
   resolve this (Int|False) :
      Int|False: resolve this

   ;For resolving mutable variables in set forms
   resolve v :
      IVar: resolve mutable-var

   ;For scanning for nested functions in a letrec form
   define f+ :
      IDefn: (name:+)

   ;     Resolving Types
   ;     ---------------
   ;Resolving a HiStanza type
   resolve t :
      IVar: resolve type
      ICap: (name:cap)
      IOf: (class:c, args:t)
      IExp: (_:t)
      
   ;For resolving class in a A<X> form
   resolve c :
      IVar: resolve class

   ;For resolving the captured type variable
   resolve cap :
      IVar: resolve capvar

   ;     Resolving Parent Types
   ;     ----------------------
   resolve pt :
      IVar: resolve raw-hs-class
      IOf: (class:hclass, args:t)
      IExp: (_:pt)
   resolve hclass :
      IVar: resolve hs-class

   ;     Resolving LoStanza
   ;     ------------------
   ;For resolving top level LoStanza commands
   resolve ltc :
      IBegin: (exps:ltc)
      ILSDef: (exp:le, type:lt)
      ILSDefVar: (exp:le, type:lt)
      ILSDefType: {args:+, parent:pt, types:lt, rtype:lt}
      ILSExtern: (type:lt)
      ILSDefn: (a1:lt, a2:lt, {args:+, body:lc})
      + lc

   ;For resolving LoStanza commands
   resolve lc :
      IBegin: (exps:lc)
      ILSSet: (exp:lval, value:le)
      ILSLabels: {names:+, body:lc}
      ILSLabel: (name:lbl)
      ILSGoto: (name:lbl)
      ILSReturn: (exp:le)
      ILSLet: {comm:lc}
      ILSIf: (pred:le, {conseq:lc}, {alt:lc})
      ILSMatch: (args:le, branches:lc)
      ILSBranch: (types:lt, {args:+, body:lc})
      ILSDef: (exp:le, type:lt, name:+)
      ILSDefVar: (exp:le, type:lt, name:+)

   ;For resolving a LoStanza expression
   resolve le :
      IVar: resolve var
      ILSNew: (type:lt, args:le)
      ILSArray: (type:lt, args:le, length:le)
      ILSStruct: (type:lt, args:le)
      ILSField: (exp:le)
      ILSDo: (func:lfarg, args:le)
      ILSPrim: (op:lprim, args:le)
      ILSSizeof: (type:lt)
      ILSTagof: (name:lclass)
      ILSAs: (exp:le, type:lt)
      ILiteral: ()
      IExp: (_:le)

   ;For resolving labels in label/goto forms
   resolve lbl :
      IVar: resolve label

   ;For resolving the lvalue expression in a set form
   resolve lval :
      IVar: resolve mutable-var
      ILSDeref: (exp:le)
      ILSSlot: (exp:le index:le)
      ILSField: (exp:le)

   ;For resolving the name argument of a prim form
   resolve lprim :
      ILSOfT: (class:lprim, args:t)
      IVar: ()

   ;For resolving the function argument of a do form
   resolve lfarg :
      ILSOfT: (class:le, args:t)
      IVar: resolve var

   ;For resolving a LoStanza type
   resolve lt :
      IVar: resolve raw-ls-class
      ILSOfT: (class:lclass, args:t)
      ILSRefT: (type:t)
      IExp: (_:lt)
   resolve lclass :
      IVar: resolve ls-class


;============================================================
;=================== Implementation =========================
;============================================================

;======== Single Bucket in ScopeBucket ========
defstruct Bucket :
   markers: Array<Int> with: (setter => set-markers)
   entries: Array<List<Int>> with: (setter => set-entries)
with :
   constructor => #Bucket

defn Bucket (n:Int) :
   #Bucket(Array<Int>(n, 0),
           Array<List<Int>>(n, List()))

defn ensure-length (b:Bucket, n:Int) :
   if n > length(markers(b)) :
      val n2 = max(n, length(markers(b)) * 2)
      val m = Array<Int>(n2, 0)
      val e = Array<List<Int>>(n2, List())
      for i in 0 to length(markers(b)) do :
         m[i] = markers(b)[i]
         e[i] = entries(b)[i]

defn marker? (b:Bucket, i:Int, m:Int) :
   val ms = markers(b)
   (length(ms) >= i) and (ms[i] == m)

defn add-entry (b:Bucket, i:Int, m:Int, v:Int) :
   ensure-length(b, i + 1)
   if markers(b)[i] == m :
      entries(b)[i] = List(v, entries(b)[i])
   else :
      markers(b)[i] = m
      entries(b)[i] = list(v)

;======== ScopeBucket ========
definterface ScopeBucket <: Streamable<KeyValue<Symbol, List<Int>>>
defmulti add (s:ScopeBucket, x:Symbol, i:Int) -> False
defmulti begin-scope (s:ScopeBucket) -> False
defmulti end-scope (s:ScopeBucket) -> False
defmulti get-local (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>
defmulti get (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>
defmulti get-top (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>

defn ScopeBucket () :
   val table = HashTable<Symbol, Bucket>(symbol-hash)
   val scopes = Vector<Int>()
   val scope-counter = to-stream(1 to false)
   add(scopes, next(scope-counter))

   new ScopeBucket :
      defmethod add (this, x:Symbol, i:Int) :
         if not key?(table, x) :
            table[x] = Bucket(i + 8)
         val s = peek(scopes)
         val l = length(scopes) - 1
         add-entry(table[x], l, s, i)
      defmethod begin-scope (this) :
         add(scopes, next(scope-counter))
      defmethod end-scope (this) :
         pop(scopes)
         false
      defmethod get (this, x:Symbol, f:Int -> True|False) :
         if key?(table, x) :
            val b = table[x]
            val xs = for i in (length(scopes) - 1) through 0 by -1 search :
               if marker?(b, i, scopes[i]) :
                  val es = filter(f, entries(b)[i])
                  to-list(es) when more?(es)
            match(xs) :
               (xs:List<Int>) : xs
               (xs:False) : List()
         else :
            List()
      defmethod get-local (this, x:Symbol, f:Int -> True|False) :
         if key?(table, x) :
            val b = table[x]
            val i = length(scopes) - 1
            if marker?(b, i, scopes[i]) :
               to-list(filter(f, entries(b)[i]))
            else :
               List()
         else :
            List()
      defmethod get-top (this, x:Symbol, f:Int -> True|False) :
         if key?(table, x) :
            val b = table[x]
            to-list(filter(f, entries(b)[0]))
         else :
            List()
      defmethod to-stream (this) :
         val s = peek(scopes)
         val i = length(scopes) - 1
         generate<KeyValue<Symbol,List<Int>>> :
            for entry in table do :
               val b = value(entry)
               if marker?(b, i, s) :
                  yield(key(entry) => entries(b)[i])
      defmethod print (o:OutputStream, this) :
         print(o, "[~@]" << [join(this, ", ")])

;======== Prefixer ========
definterface Prefixer
defmulti set-all-prefix (p:Prefixer, prefix:Symbol) -> False
defmulti set-prefix (p:Prefixer, xs:List<Symbol>, prefix:Symbol) -> False
defmulti prefix (p:Prefixer, x:Symbol) -> Symbol

defn Prefixer () :
   var all-prefix:String|False = false
   val prefix-table = HashTable<Symbol,String>(symbol-hash)

   new Prefixer :
      defmethod set-all-prefix (this, prefix:Symbol) :
         all-prefix = to-string(prefix)
         clear(prefix-table)
      defmethod set-prefix (this, xs:List<Symbol>, prefix:Symbol) :
         for x in xs do :
            prefix-table[x] = to-string(prefix)
      defmethod prefix (this, x:Symbol) :
         if key?(prefix-table, x) :
            to-symbol("~~" << [prefix-table[x], x])
         else if all-prefix != false :
            to-symbol("~~" << [all-prefix, x])
         else :
            x

;======== Base Environments ========
defstruct ResolveError <: Exception

defn make-prefixer (ps:List<IPrefix>) :
   defn prefix! (p:IPrefix) : name(prefix(p) as IVar)
   val prefixer = Prefixer()
   for p in ps do :
      match(names(p)) :
         (ns:False) : set-all-prefix(prefixer, prefix!(p))
         (ns:List<IVar>) : set-prefix(prefixer, map(name, ns), prefix!(p))
   prefixer

defn make-base-scopes (nm:NameMap, es:List<LetPackage>) :
   defn package! (i:IImport) : name(package(i) as IVar)

   ;Errors
   val errors = Vector<?>()
   defn no-package (info:FileInfo, name:Symbol) :
      add{errors, _} $
      "~: Failed to import undefined package ~." << [info, name]

   ;Classify defined globals
   val public-scopes = HashTable<Symbol, ScopeBucket>(symbol-hash)
   val protected-scopes = HashTable<Symbol, ScopeBucket>(symbol-hash)
   val private-scopes = HashTable<Symbol, ScopeBucket>(symbol-hash)
   for p in es do :
      val n = name(p)
      private-scopes[n] = ScopeBucket()
      protected-scopes[n] = ScopeBucket()
      public-scopes[n] = ScopeBucket()
   for v in globals(nm) do :
      val [n, p, name, vis] = [n(v), package(v), name(v), visibility(v)]
      add(private-scopes[p], name, n) when vis typeof Private|Protected|Public
      add(protected-scopes[p], name, n) when vis typeof Protected|Public
      add(public-scopes[p], name, n) when vis typeof Public

   ;Execute imports
   for e in es do :
      val [p, imports] = [name(e), imports(e) as List<IImport>]
      val scope = private-scopes[p]
      for i in imports do :
         val prefixer = make-prefixer(prefix(i) as List<IPrefix>)
         match(get?(public-scopes, package!(i), false)) :
            (s:ScopeBucket) :
               for entry in s do :
                  val name = prefix(prefixer, key(entry))
                  for v in value(entry) do : add(scope, name, v)
            (s:False) :
               no-package(info(i), package!(i))

   ;Resolve errors
   if not empty?(errors) :
      do(println, errors)
      throw(ResolveError())

   ;Return protected and private scopes
   [protected-scopes, private-scopes]

;======== Resolve Engine ========
defclass Engine
defmulti new-definitions (eng:Engine, e:IExp) -> False
defmulti push-scope (eng:Engine) -> False
defmulti pop-scope (eng:Engine) -> False
defmulti resolve (e, eng:Engine, type:Symbol) -> ?

public defn resolve (nm:NameMap, e:IExp) :
   ;======== Error System ========
   val errors = Vector<?>()
   defn no-resolve (v:IVar) :
      add(errors, "~: Could not resolve ~." << [info(v), name(v)])
      throw(ResolveError())
   defn amb-resolve (v:IVar, ns:List<Int>) :
      val others = for n in ns stream :
         val e = nm[n] as VarEntry
         "\n   ~: ~ defined in package ~" << [info(e), name(e), package(e)]
      val msg = "~: Ambiguous reference to ~. Possibilities include:~@" <<
         [info(v), name(v), others]
      add(errors, msg)
      throw(ResolveError())
   defn not-mutable (v:IVar) :
      val msg = "~: Cannot assign to immutable value ~." << [info(v), name(v)]
      add(errors, msg)
      throw(ResolveError())
   defn not-cap (v:IVar) :
      val msg = "~: Cannot capture explicit type argument ~." << [info(v), name(v)]
      add(errors, msg)
      throw(ResolveError())
   defn no-package (info:FileInfo, name:String) :
      val msg = "~: No package found with name ~." << [info, name]
      add(errors, msg)
      throw(ResolveError())
   defn not-hs-class (v:IVar) :
      val msg = "~: Expected a HiStanza type here but received ~." << [info(v), name(v)]
      add(errors, msg)
      throw(ResolveError())
   defn not-ls-class (v:IVar) :
      val msg = "~: Expected a LoStanza type here but received ~." << [info(v), name(v)]
      add(errors, msg)
      throw(ResolveError())      
   defn resolve-errors () :
      if not empty?(errors) :
         do(println, errors)
         throw(ResolveError())

   ;======== Find packages ========
   defn find-packages (e:IExp) :
      val ps = Vector<LetPackage>()
      defn loop (e:IExp) :
         match(e) :
            (e:LetPackage) : add(ps, e)
            (e) : do(loop, e)
      loop(e)
      to-list(ps)
   val ps = find-packages(e)

   ;======== Find base scopes ========
   val [protected-scopes, private-scopes] = make-base-scopes(nm, ps)

   ;======== Namespace Utilities ========
   defn type-pred (f: EType -> True|False) -> Int -> True|False :
      fn (i:Int) :
         f(type(nm[i] as VarEntry))
   defn get-name (e:VarN) :
      name(nm[n(e)] as VarEntry)

   ;======== Resolve in a given package ========
   defn resolve (p:LetPackage) :
      val scope = private-scopes[name(p)]

      defn get-qualified-scope (info:FileInfo, str:False|String) -> ScopeBucket :
         match(str) :
            (str:False) : scope
            (str:String) :
               match(get?(protected-scopes, to-symbol(str), false)) :
                  (s:ScopeBucket) : s
                  (s:False) : no-package(info, str)

      defn resolve-name (name:Symbol, pass?: Int -> True|False) :
         if qualified?(name) :
            val [package, name] = qualifier(name)
            val scope = get-qualified-scope(info(e), package)
            get-top(scope, to-symbol(name), pass?)
         else :
            scope[name, pass?]

      defn resolve-one (e:IVar, pass?: Int -> True|False) :
         val ns = resolve-name(name(e), pass?)
         val l = length(ns)
         if l == 0 : no-resolve(e)
         else if l == 1 : head(ns)
         else : amb-resolve(e, ns)

      defn resolve-many (e:IVar, pass?: Int -> True|False) :
         val ns = resolve-name(name(e), pass?)            
         val l = length(ns)
         if l == 0 : no-resolve(e)
         else if l == 1 : head(ns)
         else : ns

      resolve-exp(body(p), engine) where :
         val engine = new Engine :
            defmethod new-definitions (this, e:IExp) :
               match(e) :
                  (e:VarN) : add(scope, get-name(e), n(e))
                  (e) : do(new-definitions{this, _}, e)

            defmethod push-scope (this) :
               begin-scope(scope)

            defmethod pop-scope (this) :
               end-scope(scope)

            defmethod resolve (e, this, type:Symbol) :
               val var? = type-pred({_ typeof LValE|LVarE|LFnE|ValE|VarE|FnE|MultiE})
               val mvar? = type-pred({_ typeof LVarE|VarE})
               val fn? = type-pred({_ typeof LFnE|FnE|MultiE})
               val multi? = type-pred({_ typeof MultiE})
               val type? = type-pred({_ typeof TVarE|CapVarE|TypeE|LTypeE})
               val class? = type-pred({_ typeof TypeE|LTypeE})
               val hs-class? = type-pred({_ typeof TypeE})
               val ls-class? = type-pred({_ typeof LTypeE})               
               val tvar? = type-pred({_ typeof TVarE|CapVarE})
               val capvar? = type-pred({_ typeof CapVarE})
               val label? = type-pred({_ typeof LabelE})

               try :
                  switch {type == _} :
                     `var :
                        match(resolve-many(e, var?)) :
                           (n:Int) :
                              VarN(n, info(e))
                           (ns:List<Int>) :
                              if all?(fn?, ns) :
                                 Mix(map(VarN{_, info(e)}, ns), info(e))
                              else : amb-resolve(e, ns)
                     `mutable-var :
                        val n = resolve-one(e, var?)
                        not-mutable(e) when not mvar?(n)
                        VarN(n, info(e))                        
                     `multi :
                        match(resolve-many(e, multi?)) :
                           (n:Int) : VarN(n, info(e))
                           (ns:List<Int>) : Mix(map(VarN{_, info(e)}, ns), info(e))
                     `this :
                        head(scope[`this, var?])
                     `type :
                        val n = resolve-one(e, type?)
                        if class?(n) : Raw(VarN(n, info(e)), info(e))
                        else : VarN(n, info(e))                        
                     `capvar :
                        val ns = get-local(scope, name(e), tvar?)
                        if empty?(ns) : no-resolve(e)
                        else if capvar?(head(ns)) : VarN(head(ns), info(e))
                        else : not-cap(e)
                     `class :
                        val n = resolve-one(e, class?)
                        VarN(n, info(e))
                     `raw-hs-class :
                        val n = resolve-one(e, type?)
                        if hs-class?(n) : Raw(VarN(n, info(e)), info(e))
                        else : not-hs-class(e)
                     `hs-class :
                        val n = resolve-one(e, type?)
                        if hs-class?(n) : VarN(n, info(e))
                        else : not-hs-class(e)
                     `raw-ls-class :
                        val n = resolve-one(e, type?)
                        if ls-class?(n) : Raw(VarN(n, info(e)), info(e))
                        else : not-ls-class(e)
                     `ls-class :
                        val n = resolve-one(e, type?)
                        if ls-class?(n) : VarN(n, info(e))
                        else : not-ls-class(e)
                     `label :
                        val n = resolve-one(e, label?)
                        VarN(n, info(e))
                     else :
                        error("Unknown resolver ~" % [type])
               catch (err:ResolveError) :
                  e                          

   val resolved = map(resolve, ps)
   resolve-errors()
   IBegin(resolved, FileInfo())
