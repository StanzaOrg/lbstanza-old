defpackage stz/resolver :
   import core
   import verse
   import stz/il-ir
   import stz/namemap

;============================================================
;===================== Defresolver ==========================
;============================================================

#with-overlay(stz/resolver-lang) :
   defresolver resolve-exp (e:IExp, eng:Engine) :
      structure :
         IExport (exp, info)
         IDefType (class, args, parent, info)
         IDef (name, type, value, info)
         IDefVar (name, type, value, info)
         IDefn (tail?, name, targs, a1, a2, args, body, info)
         IDefmulti (name, targs, a1, a2, info)
         IDefmethod (tail?, multi, thisn, targs, a1, a2, args, body, info)
         IFn (tail?, a1, a2, args, body, info)
         IMulti (funcs, info)
         IBegin (exps, info)
         IMatch (args, branches, info)
         IBranch (types, args, body, info)
         INew (class, methods, info)
         IVar (name, info)
         ICast (exp, type, info)
         ISet (name, value, info)
         IDo (func, args, info)
         IPrim (function, args, info)
         ICallLS (function, args, info)
         ILiteral (value, info)
         ITuple (exps, info)
         IOf (class, args, info)
         IAnd (a, b, , info)
         IOr (a, b, info)
         IArrow (a1, a2, info)
         ICap (name, info)
         IGradual (info)
         IVoid (info)
         INone (info)
         ILSVar (name, info)
         ILSRef (name, args, info)
         ILSRefArray (name, length, args, info)
         ILSStruct (name, args, info)
         ILSPtr (exp, info)
         ILSDeref (exp, info)
         ILSSlot (exp, index, info)
         ILSField (exp, name, info)
         ILSDo (func, args, info)
         ILSCallC (func, args, info)
         ILSPrim (op, args, info)
         ILSSizeof (type, info)
         ILSTagof (name, info)
         ILSAs (exp, type, info)
         ILSSignedCast (exp, type, info)
         ILSUnsignedCast (exp, type, info)
         ILSValue (value, type, info)
         ILSAnd (a, b, info)
         ILSOr (a, b, info)
         ILSTCall (exp, info)
         ILSSet (exp, value, info)
         ILSLabel (name, info)
         ILSGoto (name, info)
         ILSReturn (exp, info)
         ILSLet (comm, info)
         ILSIf (pred, conseq, alt, info)
         ILSBegin (comms, info)
         ILSMatch (exp, branches, info)
         ILSBranch (exp, type, body, info)
         ILSDef (name, type, exp, info)
         ILSDefStruct (name, parents, types, rtype, fields, rfield, info)
         ILSExtern (name, type, info)
         ILSExternFn (name, type, info)
         ILSDefn (name, a1, a2, args, body, info)
         ILSByteT (info)
         ILSIntT (info)
         ILSLongT (info)
         ILSFloatT (info)
         ILSDoubleT (info)
         ILSUnknownT (info)
         ILSPtrT (type, info)
         ILSRefT (type, info)
         ILSFnT (a1, ar, a2, info)
         ILSIntrinsic (name, args, info)
         VarN (n, info)
         LSVarN (n, info)
         Let (def, body, info)
         LetRec (defns, body, info)
         LetPackage (name, imports, body, info)

      define f+ :
         IDefn : (name:+)

      resolve te :
         IBegin : (exps:te)
         IDefType : ({args:+, parent:t})
         IDef : (type:t, value:e)
         IDefVar : (type:t, value:e)
         IDefn : ({targs:+, args:+, a1:t, a2:t, body:e})
         IDefmulti : ({targs:+, a1:t, a2:t})
         IDefmethod : (multi:m, {targs:+, args:+, a1:t, a2:t, body:e})
         IExport : (exp:te)
         + e

      resolve e :
         IDef : (value:e, type:t, name:+)
         IDefVar : (value:e, type:t, name:+)
         LetRec : {defns:f+, defns:f, body:e}
         IFn : (a1:t, a2:t, {args:+, body:e})
         IBranch : (types:t {args:+, body:e})
         INew : (class:t, methods:dm)
         ICast : (exp:e, type:t)
         ISet : (name:v, value:e)
         IDo : (func:fa, args:e)
   ;      ICallLS : (function:lfa, args:e)
         IPrim : (args:e)
         IVar : resolve var
         IExp : (_:e)

      resolve f :
         IDefn : ({targs:+, args:+, a1:t, a2:t, body:e})

      resolve t :
         IVar : resolve tvar
         IOf : (class:c, args:t)
         IExp : (_:t)

      resolve c :
         IVar : resolve class

      resolve fa :
         IOf : (class:e, args:t)
         + e

      resolve dm :
         IDefmethod : (multi:m, {targs:+, args:+, a1:t, a2:t, thisn:this, body:e})

      resolve m :
         IVar : resolve multi

      resolve this ((Int|False)) :
         (Int|False) : resolve this

      resolve v :
         IVar : resolve mutable-var

   ;   resolve lfa :
   ;      IOf : (class:le, args:t)
   ;      + le


;============================================================
;=================== Implementation =========================
;============================================================

;======== Single Bucket in ScopeBucket ========
defstruct Bucket :
   markers: Array<Int> with: (setter => set-markers)
   entries: Array<List<Int>> with: (setter => set-entries)
with :
   constructor => #Bucket

defn Bucket (n:Int) :
   #Bucket(Array<Int>(n, 0),
           Array<List<Int>>(n, List()))

defn ensure-length (b:Bucket, n:Int) :
   if n > length(markers(b)) :
      val n2 = max(n, length(markers(b)) * 2)
      val m = Array<Int>(n2, 0)
      val e = Array<List<Int>>(n2, List())
      for i in 0 to length(markers(b)) do :
         m[i] = markers(b)[i]
         e[i] = entries(b)[i]

defn marker? (b:Bucket, i:Int, m:Int) :
   val ms = markers(b)
   (length(ms) >= i) and (ms[i] == m)

defn add-entry (b:Bucket, i:Int, m:Int, v:Int) :
   ensure-length(b, i + 1)
   if markers(b)[i] == m :
      entries(b)[i] = List(v, entries(b)[i])
   else :
      markers(b)[i] = m
      entries(b)[i] = list(v)

;======== ScopeBucket ========
definterface ScopeBucket <: Streamable<KeyValue<Symbol, List<Int>>>
defmulti add (s:ScopeBucket, x:Symbol, i:Int) -> False
defmulti begin-scope (s:ScopeBucket) -> False
defmulti end-scope (s:ScopeBucket) -> False
defmulti get-local (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>
defmulti get (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>
defmulti get-top (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>

defn ScopeBucket () :
   val table = HashTable<Symbol, Bucket>(symbol-hash)
   val scopes = Vector<Int>()
   val scope-counter = to-stream(1 to false)
   add(scopes, next(scope-counter))

   new ScopeBucket :
      defmethod add (this, x:Symbol, i:Int) :
         if not key?(table, x) :
            table[x] = Bucket(i + 8)
         val s = peek(scopes)
         val l = length(scopes) - 1
         add-entry(table[x], l, s, i)
      defmethod begin-scope (this) :
         add(scopes, next(scope-counter))
      defmethod end-scope (this) :
         pop(scopes)
         false
      defmethod get (this, x:Symbol, f:Int -> True|False) :
         if key?(table, x) :
            val b = table[x]
            val xs = for i in (length(scopes) - 1) through 0 by -1 search :
               if marker?(b, i, scopes[i]) :
                  val es = filter(f, entries(b)[i])
                  to-list(es) when more?(es)
            match(xs) :
               (xs:List<Int>) : xs
               (xs:False) : List()
         else :
            List()
      defmethod get-local (this, x:Symbol, f:Int -> True|False) :
         if key?(table, x) :
            val b = table[x]
            val i = length(scopes) - 1
            if marker?(b, i, scopes[i]) :
               to-list(filter(f, entries(b)[i]))
            else :
               List()
         else :
            List()
      defmethod get-top (this, x:Symbol, f:Int -> True|False) :
         if key?(table, x) :
            val b = table[x]
            to-list(filter(f, entries(b)[0]))
         else :
            List()
      defmethod to-stream (this) :
         val s = peek(scopes)
         val i = length(scopes) - 1
         generate<KeyValue<Symbol,List<Int>>> :
            for entry in table do :
               val b = value(entry)
               if marker?(b, i, s) :
                  yield(key(entry) => entries(b)[i])
      defmethod print (o:OutputStream, this) :
         print(o, "[~@]" << [join(this, ", ")])

;======== Prefixer ========
definterface Prefixer
defmulti set-all-prefix (p:Prefixer, prefix:Symbol) -> False
defmulti set-prefix (p:Prefixer, xs:List<Symbol>, prefix:Symbol) -> False
defmulti prefix (p:Prefixer, x:Symbol) -> Symbol

defn Prefixer () :
   var all-prefix:String|False = false
   val prefix-table = HashTable<Symbol,String>(symbol-hash)

   new Prefixer :
      defmethod set-all-prefix (this, prefix:Symbol) :
         all-prefix = to-string(prefix)
         clear(prefix-table)
      defmethod set-prefix (this, xs:List<Symbol>, prefix:Symbol) :
         for x in xs do :
            prefix-table[x] = to-string(prefix)
      defmethod prefix (this, x:Symbol) :
         if key?(prefix-table, x) :
            to-symbol("~~" << [prefix-table[x], x])
         else if all-prefix != false :
            to-symbol("~~" << [all-prefix, x])
         else :
            x

;======== Base Environments ========
defstruct ResolveError <: Exception

defn make-prefixer (ps:List<IPrefix>) :
   defn prefix! (p:IPrefix) : name(prefix(p) as IVar)
   val prefixer = Prefixer()
   for p in ps do :
      match(names(p)) :
         (ns:False) : set-all-prefix(prefixer, prefix!(p))
         (ns:List<IVar>) : set-prefix(prefixer, map(name, ns), prefix!(p))
   prefixer

defn make-base-scopes (nm:NameMap, es:List<LetPackage>) :
   defn package! (i:IImport) : name(package(i) as IVar)

   ;Errors
   val errors = Vector<?>()
   defn no-package (info:FileInfo, name:Symbol) :
      add{errors, _} $
      "~: Failed to import undefined package ~." << [info, name]

   ;Classify defined globals
   val public-scopes = HashTable<Symbol, ScopeBucket>(symbol-hash)
   val protected-scopes = HashTable<Symbol, ScopeBucket>(symbol-hash)
   val private-scopes = HashTable<Symbol, ScopeBucket>(symbol-hash)
   for p in es do :
      val n = name(p)
      private-scopes[n] = ScopeBucket()
      protected-scopes[n] = ScopeBucket()
      public-scopes[n] = ScopeBucket()
   for v in globals(nm) do :
      val [n, p, name, vis] = [n(v), package(v), name(v), visibility(v)]
      add(private-scopes[p], name, n) when vis typeof Private|Protected|Public
      add(protected-scopes[p], name, n) when vis typeof Protected|Public
      add(public-scopes[p], name, n) when vis typeof Public

   ;Execute imports
   for e in es do :
      val [p, imports] = [name(e), imports(e) as List<IImport>]
      val scope = private-scopes[p]
      for i in imports do :
         val prefixer = make-prefixer(prefix(i) as List<IPrefix>)
         match(get?(public-scopes, package!(i), false)) :
            (s:ScopeBucket) :
               for entry in s do :
                  val name = prefix(prefixer, key(entry))
                  for v in value(entry) do : add(scope, name, v)
            (s:False) :
               no-package(info(i), package!(i))

   ;Resolve errors
   if not empty?(errors) :
      do(println, errors)
      throw(ResolveError())

   ;Return protected and private scopes
   [protected-scopes, private-scopes]

;======== Resolve Engine ========
defclass Engine
defmulti new-definition (eng:Engine, e:IExp) -> False
defmulti new-scope (eng:Engine) -> False
defmulti end-scope (eng:Engine) -> False
defmulti resolve-var (eng:Engine, e:IVar) -> IExp
defmulti resolve-tvar (eng:Engine, e:IVar) -> IExp
defmulti resolve-class (eng:Engine, e:IVar) -> IExp
defmulti resolve-multi (eng:Engine, e:IVar) -> IExp
defmulti resolve-this (eng:Engine, e:Int|False) -> Int|False
defmulti resolve-mutable-var (eng:Engine, e:IVar) -> IExp

public defn resolve (nm:NameMap, e:IExp) :
   ;======== Error System ========
   val errors = Vector<?>()
   defn no-resolve (v:IVar) :
      add(errors, "~: Could not resolve ~." << [info(v), name(v)])
   defn amb-resolve (v:IVar, ns:List<Int>) :
      val others = for n in ns stream :
         val e = nm[n] as VarEntry
         "\n   ~: ~ defined in package ~" << [info(e), name(e), package(e)]
      val msg = "~: Ambiguous reference to ~. Possibilities include:~@" <<
         [info(v), name(v), others]
      add(errors, msg)
   defn not-mutable (v:IVar) :
      val msg = "~: Cannot assign to immutable value ~." << [info(v), name(v)]
      add(errors, msg)
   defn resolve-errors () :
      if not empty?(errors) :
         do(println, errors)
         throw(ResolveError())

   ;======== Find packages ========
   defn find-packages (e:IExp) :
      val ps = Vector<LetPackage>()
      defn loop (e:IExp) :
         match(e) :
            (e:LetPackage) : add(ps, e)
            (e) : do(loop, e)
      loop(e)
      to-list(ps)
   val ps = find-packages(e)

   ;======== Find base scopes ========
   val [protected-scopes, private-scopes] = make-base-scopes(nm, ps)

   ;======== Namespace Utilities ========
   defn type-pred (f: EType -> True|False) -> Int -> True|False :
      fn (i:Int) :
         f(type(nm[i] as VarEntry))
   defn get-name (e:VarN|LSVarN) :
      name(nm[n(e)] as VarEntry)

   ;======== Resolve in a given package ========
   defn resolve (p:LetPackage) :
      val scope = private-scopes[name(p)]

      defn resolve-one (e:IVar, pass?: Int -> True|False) :
         if qualified?(name(e)) :
            error("Resolved variables not yet implemented.")
         else :
            val ns = scope[name(e), pass?]
            val l = length(ns)
            if l == 0 : no-resolve(e)
            else if l == 1 : head(ns)
            else : amb-resolve(e, ns)

      defn resolve-many (e:IVar, pass?: Int -> True|False) :
         if qualified?(name(e)) :
            error("Resolved variables not yet implemented.")
         else :
            val ns = scope[name(e), pass?]
            val l = length(ns)
            if l == 0 : no-resolve(e)
            else if l == 1 : head(ns)
            else : ns

      resolve-exp(body(p), engine) where :
         val engine = new Engine :
            defmethod new-definition (this, e:IExp) :
               match(e) :
                  (e:VarN) : add(scope, get-name(e), n(e))
                  (e:LSVarN) : add(scope, get-name(e), n(e))
                  (e) : do(new-definition{this, _}, e)

            defmethod new-scope (this) :
               begin-scope(scope)

            defmethod end-scope (this) :
               end-scope(scope)

            defmethod resolve-var (this, e:IVar) :
               val var? = type-pred({_ typeof ValE|VarE|FnE|MultiE})
               val fn? = type-pred({_ typeof FnE|MultiE})
               match(resolve-many(e, var?)) :
                  (n:False) : e
                  (n:Int) : VarN(n, info(e))
                  (ns:List<Int>) :
                     if all?(fn?, ns) :
                        Mix(map(VarN{_, info(e)}, ns), info(e))
                     else :
                        amb-resolve(e, ns)
                        e

            defmethod resolve-tvar (this, e:IVar) :
               val tvar? = type-pred({_ typeof TVarE|TypeE})
               val type? = type-pred({_ typeof TypeE})
               match(resolve-one(e, tvar?)) :
                  (n:False) : e
                  (n:Int) :
                     if type?(n) : Raw(VarN(n, info(e)), info(e))
                     else : VarN(n, info(e))

            defmethod resolve-class (this, e:IVar) :
               val type? = type-pred({_ typeof TypeE})
               match(resolve-one(e, type?)) :
                  (n:False) : e
                  (n:Int) : VarN(n, info(e))

            defmethod resolve-multi (this, e:IVar) :
               val multi? = type-pred({_ typeof MultiE})
               match(resolve-one(e, multi?)) :
                  (n:False) : e
                  (n:Int) : VarN(n, info(e))

            defmethod resolve-this (this, e:Int|False) :
               head(scope[`this, {true}])

            defmethod resolve-mutable-var (this, e:IVar) :
               val var? = type-pred({_ typeof ValE|VarE|FnE|MultiE})
               val mvar? = type-pred({_ typeof VarE})
               match(resolve-one(e, var?)) :
                  (n:False) : e
                  (n:Int) :
                     if mvar?(n) :
                        VarN(n, info(e))
                     else :
                        not-mutable(e)
                        e

   val resolved = map(resolve, ps)
   resolve-errors()
   IBegin(resolved, FileInfo())
