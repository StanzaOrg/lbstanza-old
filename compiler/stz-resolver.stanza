defpackage stz/resolver :
   import core
   import verse
   import stz/il-ir
   import stz/namemap

;============================================================
;===================== Defresolver ==========================
;============================================================

(defn resolve-exp (e : IExp eng : Engine) : (defn #new-definitions (e : IExp) : new-definitions (@do eng e) defn #do (@of (@cap T)) (f : T -> ? x : (@cap T)) : f (@do x) defn #do (@of (@cap T)) (f : T -> ? x : List (@of (@cap T))) : core/do (@do f x) defn #map (@of (@cap S) (@cap T)) (f : T -> (@cap S) x : (@cap T)) : f (@do x) defn #map (@of (@cap S) (@cap T)) (f : T -> (@cap S) x : List (@of (@cap T))) : core/map (@do f x) ((defn gen88 (e : IExp) : (match (@do e) : ((e : IBegin) : (let : (val gen100 = exps (@do e) (let : (val gen101 = #map (@do gen88 gen100) (let : (val gen102 = info (@do e) (let : (val e = IBegin (@do gen101 gen102) e)))))))) (e : IDefType) : (push-scope (@do eng) (let : (val gen107 = args (@do e) (#do (@do #new-definitions gen107) (let : (val gen108 = parent (@do e) (let : (val gen109 = #map (@do gen97 gen108) (pop-scope (@do eng) (let : (val gen110 = class (@do e) (let : (val gen111 = info (@do e) (let : (val e = IDefType (@do gen110 gen107 gen109 gen111) e))))))))))))))) (e : IDef) : (let : (val gen121 = type (@do e) (let : (val gen122 = #map (@do gen97 gen121) (let : (val gen123 = value (@do e) (let : (val gen124 = #map (@do gen89 gen123) (let : (val gen125 = name (@do e) (let : (val gen126 = info (@do e) (let : (val e = IDef (@do gen125 gen122 gen124 gen126) e)))))))))))))) (e : IDefVar) : (let : (val gen134 = type (@do e) (let : (val gen135 = #map (@do gen97 gen134) (let : (val gen136 = value (@do e) (let : (val gen137 = #map (@do gen89 gen136) (let : (val gen138 = name (@do e) (let : (val gen139 = info (@do e) (let : (val e = IDefVar (@do gen138 gen135 gen137 gen139) e)))))))))))))) (e : IDefn) : (push-scope (@do eng) (let : (val gen147 = targs (@do e) (#do (@do #new-definitions gen147) (let : (val gen148 = args (@do e) (#do (@do #new-definitions gen148) (let : (val gen149 = a1 (@do e) (let : (val gen150 = #map (@do gen97 gen149) (let : (val gen151 = a2 (@do e) (let : (val gen152 = #map (@do gen97 gen151) (let : (val gen153 = body (@do e) (let : (val gen154 = #map (@do gen89 gen153) (pop-scope (@do eng) (let : (val gen155 = tail? (@do e) (let : (val gen156 = name (@do e) (let : (val gen157 = info (@do e) (let : (val e = IDefn (@do gen155 gen156 gen147 gen150 gen152 gen148 gen154 gen157) e)))))))))))))))))))))))))))) (e : IDefmulti) : (push-scope (@do eng) (let : (val gen174 = targs (@do e) (#do (@do #new-definitions gen174) (let : (val gen175 = a1 (@do e) (let : (val gen176 = #map (@do gen97 gen175) (let : (val gen177 = a2 (@do e) (let : (val gen178 = #map (@do gen97 gen177) (pop-scope (@do eng) (let : (val gen179 = name (@do e) (let : (val gen180 = info (@do e) (let : (val e = IDefmulti (@do gen179 gen174 gen176 gen178 gen180) e))))))))))))))))))) (e : IDefmethod) : (let : (val gen192 = multi (@do e) (let : (val gen193 = #map (@do gen93 gen192) (push-scope (@do eng) (let : (val gen194 = targs (@do e) (#do (@do #new-definitions gen194) (let : (val gen195 = args (@do e) (#do (@do #new-definitions gen195) (let : (val gen196 = a1 (@do e) (let : (val gen197 = #map (@do gen97 gen196) (let : (val gen198 = a2 (@do e) (let : (val gen199 = #map (@do gen97 gen198) (let : (val gen200 = body (@do e) (let : (val gen201 = #map (@do gen89 gen200) (pop-scope (@do eng) (let : (val gen202 = tail? (@do e) (let : (val gen203 = thisn (@do e) (let : (val gen204 = info (@do e) (let : (val e = IDefmethod (@do gen202 gen193 gen203 gen194 gen197 gen199 gen195 gen201 gen204) e)))))))))))))))))))))))))))))))) (e : IPublic) : (let : (val gen223 = exp (@do e) (let : (val gen224 = #map (@do gen88 gen223) (let : (val gen225 = info (@do e) (let : (val e = IPublic (@do gen224 gen225) e)))))))) (e : IProtected) : (let : (val gen230 = exp (@do e) (let : (val gen231 = #map (@do gen88 gen230) (let : (val gen232 = info (@do e) (let : (val e = IProtected (@do gen231 gen232) e)))))))) (e : IExp) : (let : (val e = gen89 (@do e) e))))) (defn gen89 (e : IExp) : (match (@do e) : ((e : IDef) : (let : (val gen259 = value (@do e) (let : (val gen260 = #map (@do gen89 gen259) (let : (val gen261 = type (@do e) (let : (val gen262 = #map (@do gen97 gen261) (let : (val gen263 = name (@do e) (#do (@do #new-definitions gen263) (let : (val gen264 = info (@do e) (let : (val e = IDef (@do gen263 gen262 gen260 gen264) e))))))))))))))) (e : IDefVar) : (let : (val gen273 = value (@do e) (let : (val gen274 = #map (@do gen89 gen273) (let : (val gen275 = type (@do e) (let : (val gen276 = #map (@do gen97 gen275) (let : (val gen277 = name (@do e) (#do (@do #new-definitions gen277) (let : (val gen278 = info (@do e) (let : (val e = IDefVar (@do gen277 gen276 gen274 gen278) e))))))))))))))) (e : LetRec) : (push-scope (@do eng) (let : (val gen287 = defns (@do e) (#do (@do gen96 gen287) (let : (val gen288 = #map (@do gen90 gen287) (let : (val gen289 = body (@do e) (let : (val gen290 = #map (@do gen89 gen289) (pop-scope (@do eng) (let : (val gen291 = info (@do e) (let : (val e = LetRec (@do gen288 gen290 gen291) e))))))))))))))) (e : IFn) : (let : (val gen301 = a1 (@do e) (let : (val gen302 = #map (@do gen97 gen301) (let : (val gen303 = a2 (@do e) (let : (val gen304 = #map (@do gen97 gen303) (push-scope (@do eng) (let : (val gen305 = args (@do e) (#do (@do #new-definitions gen305) (let : (val gen306 = body (@do e) (let : (val gen307 = #map (@do gen89 gen306) (pop-scope (@do eng) (let : (val gen308 = tail? (@do e) (let : (val gen309 = info (@do e) (let : (val e = IFn (@do gen308 gen302 gen304 gen305 gen307 gen309) e))))))))))))))))))))))) (e : IBranch) : (let : (val gen323 = types (@do e) (let : (val gen324 = #map (@do gen97 gen323) (push-scope (@do eng) (let : (val gen325 = args (@do e) (#do (@do #new-definitions gen325) (let : (val gen326 = body (@do e) (let : (val gen327 = #map (@do gen89 gen326) (pop-scope (@do eng) (let : (val gen328 = info (@do e) (let : (val e = IBranch (@do gen324 gen325 gen327 gen328) e))))))))))))))))) (e : INew) : (let : (val gen339 = class (@do e) (let : (val gen340 = #map (@do gen97 gen339) (let : (val gen341 = methods (@do e) (let : (val gen342 = #map (@do gen92 gen341) (let : (val gen343 = info (@do e) (let : (val e = INew (@do gen340 gen342 gen343) e)))))))))))) (e : ICast) : (let : (val gen350 = exp (@do e) (let : (val gen351 = #map (@do gen89 gen350) (let : (val gen352 = type (@do e) (let : (val gen353 = #map (@do gen97 gen352) (let : (val gen354 = info (@do e) (let : (val e = ICast (@do gen351 gen353 gen354) e)))))))))))) (e : ISet) : (let : (val gen361 = name (@do e) (let : (val gen362 = #map (@do gen95 gen361) (let : (val gen363 = value (@do e) (let : (val gen364 = #map (@do gen89 gen363) (let : (val gen365 = info (@do e) (let : (val e = ISet (@do gen362 gen364 gen365) e)))))))))))) (e : IDo) : (let : (val gen372 = func (@do e) (let : (val gen373 = #map (@do gen91 gen372) (let : (val gen374 = args (@do e) (let : (val gen375 = #map (@do gen89 gen374) (let : (val gen376 = info (@do e) (let : (val e = IDo (@do gen373 gen375 gen376) e)))))))))))) (e : IPrim) : (let : (val gen383 = args (@do e) (let : (val gen384 = #map (@do gen89 gen383) (let : (val gen385 = function (@do e) (let : (val gen386 = info (@do e) (let : (val e = IPrim (@do gen385 gen384 gen386) e)))))))))) (e : IVar) : (resolve-var (@do eng e) e) (e : IExp) : (let : (val e = map (@do gen89 e) e))))) (defn gen90 (e : IExp) : (match (@do e) : ((e : IDefn) : (push-scope (@do eng) (let : (val gen419 = targs (@do e) (#do (@do #new-definitions gen419) (let : (val gen420 = args (@do e) (#do (@do #new-definitions gen420) (let : (val gen421 = a1 (@do e) (let : (val gen422 = #map (@do gen97 gen421) (let : (val gen423 = a2 (@do e) (let : (val gen424 = #map (@do gen97 gen423) (let : (val gen425 = body (@do e) (let : (val gen426 = #map (@do gen89 gen425) (pop-scope (@do eng) (let : (val gen427 = tail? (@do e) (let : (val gen428 = name (@do e) (let : (val gen429 = info (@do e) (let : (val e = IDefn (@do gen427 gen428 gen419 gen422 gen424 gen420 gen426 gen429) e))))))))))))))))))))))))))))))) (defn gen91 (e : IExp) : (match (@do e) : ((e : IOf) : (let : (val gen449 = class (@do e) (let : (val gen450 = #map (@do gen89 gen449) (let : (val gen451 = args (@do e) (let : (val gen452 = #map (@do gen97 gen451) (let : (val gen453 = info (@do e) (let : (val e = IOf (@do gen450 gen452 gen453) e)))))))))))) (e : IExp) : (let : (val e = gen89 (@do e) e))))) (defn gen92 (e : IExp) : (match (@do e) : ((e : IDefmethod) : (let : (val gen466 = multi (@do e) (let : (val gen467 = #map (@do gen93 gen466) (push-scope (@do eng) (let : (val gen468 = targs (@do e) (#do (@do #new-definitions gen468) (let : (val gen469 = args (@do e) (#do (@do #new-definitions gen469) (let : (val gen470 = a1 (@do e) (let : (val gen471 = #map (@do gen97 gen470) (let : (val gen472 = a2 (@do e) (let : (val gen473 = #map (@do gen97 gen472) (let : (val gen474 = thisn (@do e) (let : (val gen475 = #map (@do gen94 gen474) (let : (val gen476 = body (@do e) (let : (val gen477 = #map (@do gen89 gen476) (pop-scope (@do eng) (let : (val gen478 = tail? (@do e) (let : (val gen479 = info (@do e) (let : (val e = IDefmethod (@do gen478 gen467 gen475 gen468 gen471 gen473 gen469 gen477 gen479) e))))))))))))))))))))))))))))))))))))) (defn gen93 (e : IExp) : (match (@do e) : ((e : IVar) : (resolve-multi (@do eng e) e)))) (defn gen94 (e : (Int | False)) : (match (@do e) : ((e : (Int | False)) : (resolve-this (@do eng e) e)))) (defn gen95 (e : IExp) : (match (@do e) : ((e : IVar) : (resolve-mutable-var (@do eng e) e)))) (defn gen96 (e : IExp) -> core/False : (match (@do e) : ((e : IDefn) : (let : (val gen514 = name (@do e) (#do (@do #new-definitions gen514) false)))))) (defn gen97 (e : IExp) : (match (@do e) : ((e : IVar) : (resolve-tvar (@do eng e) e) (e : ICap) : (let : (val gen521 = name (@do e) (let : (val gen522 = #map (@do gen99 gen521) (let : (val gen523 = info (@do e) (let : (val e = ICap (@do gen522 gen523) e)))))))) (e : IOf) : (let : (val gen528 = class (@do e) (let : (val gen529 = #map (@do gen98 gen528) (let : (val gen530 = args (@do e) (let : (val gen531 = #map (@do gen97 gen530) (let : (val gen532 = info (@do e) (let : (val e = IOf (@do gen529 gen531 gen532) e)))))))))))) (e : IExp) : (let : (val e = map (@do gen97 e) e))))) (defn gen98 (e : IExp) : (match (@do e) : ((e : IVar) : (resolve-class (@do eng e) e)))) (defn gen99 (e : IExp) : (match (@do e) : ((e : IVar) : (resolve-capvar (@do eng e) e))))) gen88 (@do e)))


;============================================================
;=================== Implementation =========================
;============================================================

;======== Single Bucket in ScopeBucket ========
defstruct Bucket :
   markers: Array<Int> with: (setter => set-markers)
   entries: Array<List<Int>> with: (setter => set-entries)
with :
   constructor => #Bucket

defn Bucket (n:Int) :
   #Bucket(Array<Int>(n, 0),
           Array<List<Int>>(n, List()))

defn ensure-length (b:Bucket, n:Int) :
   if n > length(markers(b)) :
      val n2 = max(n, length(markers(b)) * 2)
      val m = Array<Int>(n2, 0)
      val e = Array<List<Int>>(n2, List())
      for i in 0 to length(markers(b)) do :
         m[i] = markers(b)[i]
         e[i] = entries(b)[i]

defn marker? (b:Bucket, i:Int, m:Int) :
   val ms = markers(b)
   (length(ms) >= i) and (ms[i] == m)

defn add-entry (b:Bucket, i:Int, m:Int, v:Int) :
   ensure-length(b, i + 1)
   if markers(b)[i] == m :
      entries(b)[i] = List(v, entries(b)[i])
   else :
      markers(b)[i] = m
      entries(b)[i] = list(v)

;======== ScopeBucket ========
definterface ScopeBucket <: Streamable<KeyValue<Symbol, List<Int>>>
defmulti add (s:ScopeBucket, x:Symbol, i:Int) -> False
defmulti begin-scope (s:ScopeBucket) -> False
defmulti end-scope (s:ScopeBucket) -> False
defmulti get-local (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>
defmulti get (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>
defmulti get-top (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>

defn ScopeBucket () :
   val table = HashTable<Symbol, Bucket>(symbol-hash)
   val scopes = Vector<Int>()
   val scope-counter = to-stream(1 to false)
   add(scopes, next(scope-counter))

   new ScopeBucket :
      defmethod add (this, x:Symbol, i:Int) :
         if not key?(table, x) :
            table[x] = Bucket(i + 8)
         val s = peek(scopes)
         val l = length(scopes) - 1
         add-entry(table[x], l, s, i)
      defmethod begin-scope (this) :
         add(scopes, next(scope-counter))
      defmethod end-scope (this) :
         pop(scopes)
         false
      defmethod get (this, x:Symbol, f:Int -> True|False) :
         if key?(table, x) :
            val b = table[x]
            val xs = for i in (length(scopes) - 1) through 0 by -1 search :
               if marker?(b, i, scopes[i]) :
                  val es = filter(f, entries(b)[i])
                  to-list(es) when more?(es)
            match(xs) :
               (xs:List<Int>) : xs
               (xs:False) : List()
         else :
            List()
      defmethod get-local (this, x:Symbol, f:Int -> True|False) :
         if key?(table, x) :
            val b = table[x]
            val i = length(scopes) - 1
            if marker?(b, i, scopes[i]) :
               to-list(filter(f, entries(b)[i]))
            else :
               List()
         else :
            List()
      defmethod get-top (this, x:Symbol, f:Int -> True|False) :
         if key?(table, x) :
            val b = table[x]
            to-list(filter(f, entries(b)[0]))
         else :
            List()
      defmethod to-stream (this) :
         val s = peek(scopes)
         val i = length(scopes) - 1
         generate<KeyValue<Symbol,List<Int>>> :
            for entry in table do :
               val b = value(entry)
               if marker?(b, i, s) :
                  yield(key(entry) => entries(b)[i])
      defmethod print (o:OutputStream, this) :
         print(o, "[~@]" << [join(this, ", ")])

;======== Prefixer ========
definterface Prefixer
defmulti set-all-prefix (p:Prefixer, prefix:Symbol) -> False
defmulti set-prefix (p:Prefixer, xs:List<Symbol>, prefix:Symbol) -> False
defmulti prefix (p:Prefixer, x:Symbol) -> Symbol

defn Prefixer () :
   var all-prefix:String|False = false
   val prefix-table = HashTable<Symbol,String>(symbol-hash)

   new Prefixer :
      defmethod set-all-prefix (this, prefix:Symbol) :
         all-prefix = to-string(prefix)
         clear(prefix-table)
      defmethod set-prefix (this, xs:List<Symbol>, prefix:Symbol) :
         for x in xs do :
            prefix-table[x] = to-string(prefix)
      defmethod prefix (this, x:Symbol) :
         if key?(prefix-table, x) :
            to-symbol("~~" << [prefix-table[x], x])
         else if all-prefix != false :
            to-symbol("~~" << [all-prefix, x])
         else :
            x

;======== Base Environments ========
defstruct ResolveError <: Exception

defn make-prefixer (ps:List<IPrefix>) :
   defn prefix! (p:IPrefix) : name(prefix(p) as IVar)
   val prefixer = Prefixer()
   for p in ps do :
      match(names(p)) :
         (ns:False) : set-all-prefix(prefixer, prefix!(p))
         (ns:List<IVar>) : set-prefix(prefixer, map(name, ns), prefix!(p))
   prefixer

defn make-base-scopes (nm:NameMap, es:List<LetPackage>) :
   defn package! (i:IImport) : name(package(i) as IVar)

   ;Errors
   val errors = Vector<?>()
   defn no-package (info:FileInfo, name:Symbol) :
      add{errors, _} $
      "~: Failed to import undefined package ~." << [info, name]

   ;Classify defined globals
   val public-scopes = HashTable<Symbol, ScopeBucket>(symbol-hash)
   val protected-scopes = HashTable<Symbol, ScopeBucket>(symbol-hash)
   val private-scopes = HashTable<Symbol, ScopeBucket>(symbol-hash)
   for p in es do :
      val n = name(p)
      private-scopes[n] = ScopeBucket()
      protected-scopes[n] = ScopeBucket()
      public-scopes[n] = ScopeBucket()
   for v in globals(nm) do :
      val [n, p, name, vis] = [n(v), package(v), name(v), visibility(v)]
      add(private-scopes[p], name, n) when vis typeof Private|Protected|Public
      add(protected-scopes[p], name, n) when vis typeof Protected|Public
      add(public-scopes[p], name, n) when vis typeof Public

   ;Execute imports
   for e in es do :
      val [p, imports] = [name(e), imports(e) as List<IImport>]
      val scope = private-scopes[p]
      for i in imports do :
         val prefixer = make-prefixer(prefix(i) as List<IPrefix>)
         match(get?(public-scopes, package!(i), false)) :
            (s:ScopeBucket) :
               for entry in s do :
                  val name = prefix(prefixer, key(entry))
                  for v in value(entry) do : add(scope, name, v)
            (s:False) :
               no-package(info(i), package!(i))

   ;Resolve errors
   if not empty?(errors) :
      do(println, errors)
      throw(ResolveError())

   ;Return protected and private scopes
   [protected-scopes, private-scopes]

;======== Resolve Engine ========
defclass Engine
defmulti new-definitions (eng:Engine, e:IExp) -> False
defmulti push-scope (eng:Engine) -> False
defmulti pop-scope (eng:Engine) -> False
defmulti resolve-var (eng:Engine, e:IVar) -> IExp
defmulti resolve-tvar (eng:Engine, e:IVar) -> IExp
defmulti resolve-capvar (eng:Engine, e:IVar) -> IExp
defmulti resolve-class (eng:Engine, e:IVar) -> IExp
defmulti resolve-multi (eng:Engine, e:IVar) -> IExp
defmulti resolve-this (eng:Engine, e:Int|False) -> Int|False
defmulti resolve-mutable-var (eng:Engine, e:IVar) -> IExp

public defn resolve (nm:NameMap, e:IExp) :
   ;======== Error System ========
   val errors = Vector<?>()
   defn no-resolve (v:IVar) :
      add(errors, "~: Could not resolve ~." << [info(v), name(v)])
   defn amb-resolve (v:IVar, ns:List<Int>) :
      val others = for n in ns stream :
         val e = nm[n] as VarEntry
         "\n   ~: ~ defined in package ~" << [info(e), name(e), package(e)]
      val msg = "~: Ambiguous reference to ~. Possibilities include:~@" <<
         [info(v), name(v), others]
      add(errors, msg)
   defn not-mutable (v:IVar) :
      val msg = "~: Cannot assign to immutable value ~." << [info(v), name(v)]
      add(errors, msg)
   defn not-cap (v:IVar) :
      val msg = "~: Cannot capture explicit type argument ~." << [info(v), name(v)]
      add(errors, msg)
   defn resolve-errors () :
      if not empty?(errors) :
         do(println, errors)
         throw(ResolveError())

   ;======== Find packages ========
   defn find-packages (e:IExp) :
      val ps = Vector<LetPackage>()
      defn loop (e:IExp) :
         match(e) :
            (e:LetPackage) : add(ps, e)
            (e) : do(loop, e)
      loop(e)
      to-list(ps)
   val ps = find-packages(e)

   ;======== Find base scopes ========
   val [protected-scopes, private-scopes] = make-base-scopes(nm, ps)

   ;======== Namespace Utilities ========
   defn type-pred (f: EType -> True|False) -> Int -> True|False :
      fn (i:Int) :
         f(type(nm[i] as VarEntry))
   defn get-name (e:VarN|LSVarN) :
      name(nm[n(e)] as VarEntry)

   ;======== Resolve in a given package ========
   defn resolve (p:LetPackage) :
      val scope = private-scopes[name(p)]

      defn resolve-one (e:IVar, pass?: Int -> True|False) :
         if qualified?(name(e)) :
            error("Resolved variables not yet implemented.")
         else :
            val ns = scope[name(e), pass?]
            val l = length(ns)
            if l == 0 : no-resolve(e)
            else if l == 1 : head(ns)
            else : amb-resolve(e, ns)

      defn resolve-many (e:IVar, pass?: Int -> True|False) :
         if qualified?(name(e)) :
            error("Resolved variables not yet implemented.")
         else :
            val ns = scope[name(e), pass?]
            val l = length(ns)
            if l == 0 : no-resolve(e)
            else if l == 1 : head(ns)
            else : ns

      resolve-exp(body(p), engine) where :
         val engine = new Engine :
            defmethod new-definitions (this, e:IExp) :
               match(e) :
                  (e:VarN) : add(scope, get-name(e), n(e))
                  (e:LSVarN) : add(scope, get-name(e), n(e))
                  (e) : do(new-definitions{this, _}, e)

            defmethod push-scope (this) :
               begin-scope(scope)

            defmethod pop-scope (this) :
               end-scope(scope)

            defmethod resolve-var (this, e:IVar) :
               val var? = type-pred({_ typeof ValE|VarE|FnE|MultiE})
               val fn? = type-pred({_ typeof FnE|MultiE})
               match(resolve-many(e, var?)) :
                  (n:False) : e
                  (n:Int) : VarN(n, info(e))
                  (ns:List<Int>) :
                     if all?(fn?, ns) :
                        Mix(map(VarN{_, info(e)}, ns), info(e))
                     else :
                        amb-resolve(e, ns)
                        e

            defmethod resolve-tvar (this, e:IVar) :
               val tvar? = type-pred({_ typeof TVarE|CapVarE|TypeE})
               val type? = type-pred({_ typeof TypeE})
               match(resolve-one(e, tvar?)) :
                  (n:False) : e
                  (n:Int) :
                     if type?(n) : Raw(VarN(n, info(e)), info(e))
                     else : VarN(n, info(e))

            defmethod resolve-capvar (this, e:IVar) :
               val tvar? = type-pred({_ typeof TVarE|CapVarE})
               val capvar? = type-pred({_ typeof CapVarE})              
               val ns = get-local(scope, name(e), tvar?)
               if empty?(ns) :
                  no-resolve(e)
                  e
               else if capvar?(head(ns)) :
                  VarN(head(ns), info(e))
               else :
                  not-cap(e)
                  e

            defmethod resolve-class (this, e:IVar) :
               val type? = type-pred({_ typeof TypeE})
               match(resolve-one(e, type?)) :
                  (n:False) : e
                  (n:Int) : VarN(n, info(e))

            defmethod resolve-multi (this, e:IVar) :
               val multi? = type-pred({_ typeof MultiE})
               match(resolve-one(e, multi?)) :
                  (n:False) : e
                  (n:Int) : VarN(n, info(e))

            defmethod resolve-this (this, e:Int|False) :
               head(scope[`this, {true}])

            defmethod resolve-mutable-var (this, e:IVar) :
               val var? = type-pred({_ typeof ValE|VarE|FnE|MultiE})
               val mvar? = type-pred({_ typeof VarE})
               match(resolve-one(e, var?)) :
                  (n:False) : e
                  (n:Int) :
                     if mvar?(n) :
                        VarN(n, info(e))
                     else :
                        not-mutable(e)
                        e

   val resolved = map(resolve, ps)
   resolve-errors()
   IBegin(resolved, FileInfo())
