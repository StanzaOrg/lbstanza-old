defpackage stz/resolver :
   import core
   import verse
   import stz/il-ir
   import stz/namemap

(defn resolve-exp (gen17 : IExp gen18 : Engine) : (defn #map (@of (@cap S) (@cap T)) (f : T -> (@cap S) x : (@cap T)) : f (@do x) defn #map (@of (@cap S) (@cap T)) (f : T -> (@cap S) x : List (@of (@cap T))) : core/map (@do f x) defn #do (@of (@cap S) (@cap T)) (f : T -> (@cap S) x : (@cap T)) : f (@do x) defn #do (@of (@cap S) (@cap T)) (f : T -> (@cap S) x : List (@of (@cap T))) : core/do (@do f x) defn #new-definition (gen17 : IExp) : new-definition (@do gen18 gen17) ((defn gen19 (gen17 : IExp) -> core/False : (match (@do gen17) : ((gen17 : IDefn) : ((#do (@do #new-definition name (@do gen17))))))) (defn gen20 (gen17 : IExp) : (match (@do gen17) : ((gen17 : IBegin) : (((val gen35 = #map (@do gen20 exps (@do gen17)))) IBegin (@do gen35 (info (@do gen17)))) (gen17 : IDefType) : (((new-scope (@do gen18) ((#do (@do #new-definition args (@do gen17))) (val gen40 = #map (@do gen23 parent (@do gen17)))) end-scope (@do gen18))) IDefType (@do (class (@do gen17)) (args (@do gen17)) gen40 (info (@do gen17)))) (gen17 : IDef) : (((val gen45 = #map (@do gen23 type (@do gen17))) (val gen48 = #map (@do gen21 value (@do gen17)))) IDef (@do (name (@do gen17)) gen45 gen48 (info (@do gen17)))) (gen17 : IDefVar) : (((val gen45 = #map (@do gen23 type (@do gen17))) (val gen48 = #map (@do gen21 value (@do gen17)))) IDefVar (@do (name (@do gen17)) gen45 gen48 (info (@do gen17)))) (gen17 : IDefn) : (((new-scope (@do gen18) ((#do (@do #new-definition targs (@do gen17))) (#do (@do #new-definition args (@do gen17))) (val gen59 = #map (@do gen23 a1 (@do gen17))) (val gen62 = #map (@do gen23 a2 (@do gen17))) (val gen65 = #map (@do gen21 body (@do gen17)))) end-scope (@do gen18))) IDefn (@do (tail? (@do gen17)) (name (@do gen17)) (targs (@do gen17)) gen59 gen62 (args (@do gen17)) gen65 (info (@do gen17)))) (gen17 : IDefmulti) : (((new-scope (@do gen18) ((#do (@do #new-definition targs (@do gen17))) (val gen59 = #map (@do gen23 a1 (@do gen17))) (val gen62 = #map (@do gen23 a2 (@do gen17)))) end-scope (@do gen18))) IDefmulti (@do (name (@do gen17)) (targs (@do gen17)) gen59 gen62 (info (@do gen17)))) (gen17 : IDefmethod) : (((val gen77 = #map (@do gen27 multi (@do gen17))) (new-scope (@do gen18) ((#do (@do #new-definition targs (@do gen17))) (#do (@do #new-definition args (@do gen17))) (val gen59 = #map (@do gen23 a1 (@do gen17))) (val gen62 = #map (@do gen23 a2 (@do gen17))) (val gen65 = #map (@do gen21 body (@do gen17)))) end-scope (@do gen18))) IDefmethod (@do (tail? (@do gen17)) gen77 (thisn (@do gen17)) (targs (@do gen17)) gen59 gen62 (args (@do gen17)) gen65 (info (@do gen17)))) (gen17 : IExport) : (((val gen90 = #map (@do gen20 exp (@do gen17)))) IExport (@do gen90 (info (@do gen17)))) (gen17) : gen21 (@do gen17)))) (defn gen21 (gen17 : IExp) : (match (@do gen17) : ((gen17 : IDef) : (((val gen48 = #map (@do gen21 value (@do gen17))) (val gen45 = #map (@do gen23 type (@do gen17))) (#do (@do #new-definition name (@do gen17)))) IDef (@do (name (@do gen17)) gen45 gen48 (info (@do gen17)))) (gen17 : IDefVar) : (((val gen48 = #map (@do gen21 value (@do gen17))) (val gen45 = #map (@do gen23 type (@do gen17))) (#do (@do #new-definition name (@do gen17)))) IDefVar (@do (name (@do gen17)) gen45 gen48 (info (@do gen17)))) (gen17 : LetRec) : ((new-scope (@do gen18) ((#do (@do gen19 defns (@do gen17))) (val gen126 = #map (@do gen22 defns (@do gen17))) (val gen65 = #map (@do gen21 body (@do gen17)))) end-scope (@do gen18)) LetRec (@do gen126 gen65 (info (@do gen17)))) (gen17 : IFn) : (((val gen59 = #map (@do gen23 a1 (@do gen17))) (val gen62 = #map (@do gen23 a2 (@do gen17))) (new-scope (@do gen18) ((#do (@do #new-definition args (@do gen17))) (val gen65 = #map (@do gen21 body (@do gen17)))) end-scope (@do gen18))) IFn (@do (tail? (@do gen17)) gen59 gen62 (args (@do gen17)) gen65 (info (@do gen17)))) (gen17 : IBranch) : (((val gen144 = #map (@do gen23 types (@do gen17))) (new-scope (@do gen18) ((#do (@do #new-definition args (@do gen17))) (val gen65 = #map (@do gen21 body (@do gen17)))) end-scope (@do gen18))) IBranch (@do gen144 (args (@do gen17)) gen65 (info (@do gen17)))) (gen17 : INew) : (((val gen152 = #map (@do gen23 class (@do gen17))) (val gen155 = #map (@do gen26 methods (@do gen17)))) INew (@do gen152 gen155 (info (@do gen17)))) (gen17 : ICast) : (((val gen90 = #map (@do gen21 exp (@do gen17))) (val gen45 = #map (@do gen23 type (@do gen17)))) ICast (@do gen90 gen45 (info (@do gen17)))) (gen17 : ISet) : (((val gen164 = #map (@do gen29 name (@do gen17))) (val gen48 = #map (@do gen21 value (@do gen17)))) ISet (@do gen164 gen48 (info (@do gen17)))) (gen17 : IDo) : (((val gen170 = #map (@do gen25 func (@do gen17))) (val gen173 = #map (@do gen21 args (@do gen17)))) IDo (@do gen170 gen173 (info (@do gen17)))) (gen17 : IPrim) : (((val gen173 = #map (@do gen21 args (@do gen17)))) IPrim (@do (function (@do gen17)) gen173 (info (@do gen17)))) (gen17 : IVar) : (resolve-var (@do gen18 gen17)) (gen17 : IExp) : (map (@do gen21 gen17))))) (defn gen22 (gen17 : IExp) : (match (@do gen17) : ((gen17 : IDefn) : (((new-scope (@do gen18) ((#do (@do #new-definition targs (@do gen17))) (#do (@do #new-definition args (@do gen17))) (val gen59 = #map (@do gen23 a1 (@do gen17))) (val gen62 = #map (@do gen23 a2 (@do gen17))) (val gen65 = #map (@do gen21 body (@do gen17)))) end-scope (@do gen18))) IDefn (@do (tail? (@do gen17)) (name (@do gen17)) (targs (@do gen17)) gen59 gen62 (args (@do gen17)) gen65 (info (@do gen17))))))) (defn gen23 (gen17 : IExp) : (match (@do gen17) : ((gen17 : IVar) : (resolve-tvar (@do gen18 gen17)) (gen17 : IOf) : (((val gen152 = #map (@do gen24 class (@do gen17))) (val gen173 = #map (@do gen23 args (@do gen17)))) IOf (@do gen152 gen173 (info (@do gen17)))) (gen17 : IExp) : (map (@do gen23 gen17))))) (defn gen24 (gen17 : IExp) : (match (@do gen17) : ((gen17 : IVar) : (resolve-class (@do gen18 gen17))))) (defn gen25 (gen17 : IExp) : (match (@do gen17) : ((gen17 : IOf) : (((val gen152 = #map (@do gen21 class (@do gen17))) (val gen173 = #map (@do gen23 args (@do gen17)))) IOf (@do gen152 gen173 (info (@do gen17)))) (gen17) : gen21 (@do gen17)))) (defn gen26 (gen17 : IExp) : (match (@do gen17) : ((gen17 : IDefmethod) : (((val gen77 = #map (@do gen27 multi (@do gen17))) (new-scope (@do gen18) ((#do (@do #new-definition targs (@do gen17))) (#do (@do #new-definition args (@do gen17))) (val gen59 = #map (@do gen23 a1 (@do gen17))) (val gen62 = #map (@do gen23 a2 (@do gen17))) (val gen259 = #map (@do gen28 thisn (@do gen17))) (val gen65 = #map (@do gen21 body (@do gen17)))) end-scope (@do gen18))) IDefmethod (@do (tail? (@do gen17)) gen77 gen259 (targs (@do gen17)) gen59 gen62 (args (@do gen17)) gen65 (info (@do gen17))))))) (defn gen27 (gen17 : IExp) : (match (@do gen17) : ((gen17 : IVar) : (resolve-multi (@do gen18 gen17))))) (defn gen28 (gen17 : (Int | False)) : (match (@do gen17) : ((gen17 : (Int | False)) : (resolve-this (@do gen18 gen17))))) (defn gen29 (gen17 : IExp) : (match (@do gen17) : ((gen17 : IVar) : (resolve-mutable-var (@do gen18 gen17)))))) gen20 (@do gen17)))


;============================================================
;=================== Implementation =========================
;============================================================

;======== Single Bucket in ScopeBucket ========
defstruct Bucket :
   markers: Array<Int> with: (setter => set-markers)
   entries: Array<List<Int>> with: (setter => set-entries)
with :
   constructor => #Bucket
   
defn Bucket (n:Int) :
   #Bucket(Array<Int>(n, 0),
           Array<List<Int>>(n, List()))

defn ensure-length (b:Bucket, n:Int) :
   if n > length(markers(b)) :
      val n2 = max(n, length(markers(b)) * 2)
      val m = Array<Int>(n2, 0)
      val e = Array<List<Int>>(n2, List())
      for i in 0 to length(markers(b)) do :
         m[i] = markers(b)[i]
         e[i] = entries(b)[i]

defn marker? (b:Bucket, i:Int, m:Int) :
   val ms = markers(b)
   (length(ms) >= i) and (ms[i] == m)

defn add-entry (b:Bucket, i:Int, m:Int, v:Int) :
   ensure-length(b, i + 1)
   if markers(b)[i] == m :
      entries(b)[i] = List(v, entries(b)[i])
   else :
      markers(b)[i] = m
      entries(b)[i] = list(v)

;======== ScopeBucket ========
definterface ScopeBucket <: Streamable<KeyValue<Symbol, List<Int>>>
defmulti add (s:ScopeBucket, x:Symbol, i:Int) -> False
defmulti begin-scope (s:ScopeBucket) -> False
defmulti end-scope (s:ScopeBucket) -> False
defmulti get-local (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>
defmulti get (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>
defmulti get-top (s:ScopeBucket, x:Symbol, filter:Int -> True|False) -> List<Int>

defn ScopeBucket () :
   val table = HashTable<Symbol, Bucket>(symbol-hash)
   val scopes = Vector<Int>()
   val scope-counter = to-stream(1 to false)
   add(scopes, next(scope-counter))

   new ScopeBucket :
      defmethod add (this, x:Symbol, i:Int) :
         if not key?(table, x) :
            table[x] = Bucket(i + 8)
         val s = peek(scopes)
         val l = length(scopes) - 1
         add-entry(table[x], l, s, i)
      defmethod begin-scope (this) :
         add(scopes, next(scope-counter))
      defmethod end-scope (this) :
         pop(scopes)
         false
      defmethod get (this, x:Symbol, f:Int -> True|False) :
         if key?(table, x) :
            val b = table[x]
            val xs = for i in (length(scopes) - 1) through 0 by -1 search :
               if marker?(b, i, scopes[i]) :
                  val es = filter(f, entries(b)[i])
                  to-list(es) when more?(es)
            match(xs) :
               (xs:List<Int>) : xs
               (xs:False) : List()
         else :
            List()
      defmethod get-local (this, x:Symbol, f:Int -> True|False) :
         if key?(table, x) :
            val b = table[x]
            val i = length(scopes) - 1
            if marker?(b, i, scopes[i]) :
               to-list(filter(f, entries(b)[i]))
            else :
               List()   
         else :
            List()
      defmethod get-top (this, x:Symbol, f:Int -> True|False) :
         if key?(table, x) :
            val b = table[x]
            to-list(filter(f, entries(b)[0]))
         else :
            List()
      defmethod to-stream (this) :
         val s = peek(scopes)
         val i = length(scopes) - 1
         generate<KeyValue<Symbol,List<Int>>> :
            for entry in table do :
               val b = value(entry)
               if marker?(b, i, s) :
                  yield(key(entry) => entries(b)[i])
      defmethod print (o:OutputStream, this) :
         print(o, "[~@]" << [join(this, ", ")])

;======== Prefixer ========
definterface Prefixer
defmulti set-all-prefix (p:Prefixer, prefix:Symbol) -> False
defmulti set-prefix (p:Prefixer, xs:List<Symbol>, prefix:Symbol) -> False
defmulti prefix (p:Prefixer, x:Symbol) -> Symbol

defn Prefixer () :
   var all-prefix:String|False = false
   val prefix-table = HashTable<Symbol,String>(symbol-hash)
   
   new Prefixer :
      defmethod set-all-prefix (this, prefix:Symbol) :
         all-prefix = to-string(prefix)
         clear(prefix-table)
      defmethod set-prefix (this, xs:List<Symbol>, prefix:Symbol) :
         for x in xs do :
            prefix-table[x] = to-string(prefix)
      defmethod prefix (this, x:Symbol) :
         if key?(prefix-table, x) :
            to-symbol("~~" << [prefix-table[x], x])
         else if all-prefix != false :
            to-symbol("~~" << [all-prefix, x])
         else :
            x

;======== Base Environments ========
defstruct ResolveError <: Exception

defn make-prefixer (ps:List<IPrefix>) :
   defn prefix! (p:IPrefix) : name(prefix(p) as IVar)
   val prefixer = Prefixer()   
   for p in ps do :
      match(names(p)) :
         (ns:False) : set-all-prefix(prefixer, prefix!(p))
         (ns:List<IVar>) : set-prefix(prefixer, map(name, ns), prefix!(p))
   prefixer      

defn make-base-scopes (nm:NameMap, es:List<LetPackage>) :
   defn package! (i:IImport) : name(package(i) as IVar)

   ;Errors
   val errors = Vector<?>()
   defn no-package (info:FileInfo, name:Symbol) :
      add{errors, _} $
      "~: Failed to import undefined package ~." << [info, name]

   ;Classify defined globals
   val public-scopes = HashTable<Symbol, ScopeBucket>(symbol-hash)
   val protected-scopes = HashTable<Symbol, ScopeBucket>(symbol-hash)
   val private-scopes = HashTable<Symbol, ScopeBucket>(symbol-hash)
   for v in globals(nm) do :
      val [n, p, name, vis] = [n(v), package(v), name(v), visibility(v)]
      if not key?(public-scopes, p) :
         private-scopes[p] = ScopeBucket()
         protected-scopes[p] = ScopeBucket()
         public-scopes[p] = ScopeBucket()
      add(private-scopes[p], name, n) when vis typeof Private|Protected|Public
      add(protected-scopes[p], name, n) when vis typeof Protected|Public
      add(public-scopes[p], name, n) when vis typeof Public

   ;Execute imports
   for e in es do :
      val [p, imports] = [name(e), imports(e) as List<IImport>]
      val scope = private-scopes[p]
      for i in imports do :
         val prefixer = make-prefixer(prefix(i) as List<IPrefix>)
         match(get?(public-scopes, package!(i), false)) :
            (s:ScopeBucket) :
               for entry in s do :
                  val name = prefix(prefixer, key(entry))
                  for v in value(entry) do : add(scope, name, v)
            (s:False) :
               no-package(info(i), package!(i))

   ;Resolve errors
   if not empty?(errors) :
      do(println, errors)
      throw(ResolveError())

   ;Return protected and private scopes
   [protected-scopes, private-scopes]


defstruct Engine 

defn new-definition (eng:Engine, e:IExp) :
   println("new-definition(~)" << [e])
defn new-scope (eng:Engine) :
   println("start scope")
defn end-scope (eng:Engine) :
   println("end scope")
defn resolve-var (eng:Engine, e:IExp) :
   println("resolve-var(~)" << [e])
   e
defn resolve-tvar (eng:Engine, e:IExp) :
   println("resolve-tvar(~)" << [e])
   e
defn resolve-class (eng:Engine, e:IExp) :
   println("resolve-class(~)" << [e])
   e
defn resolve-multi (eng:Engine, e:IExp) :
   println("resolve-multi(~)" << [e])
   e
defn resolve-this (eng:Engine, e:Int|False) :
   println("resolve-this(~)" << [e])
   e
defn resolve-mutable-var (eng:Engine, e:IExp) :
   println("resolve-mutable-var(~)" << [e])
   e
defn resolve (eng:Engine, r: IExp -> IExp, e:IExp) :
   println("resolve(~)" << [e])
   val res = r(e)
   println("result = ~" << [res])   

public defn resolve (nm:NameMap, e:IExp) :
   defn find-packages (e:IExp) :
      val ps = Vector<LetPackage>()
      defn loop (e:IExp) :
         match(e) :
            (e:LetPackage) : add(ps, e)
            (e) : do(loop, e)
      loop(e)
      to-list(ps)

   val ps = find-packages(e)
   val [protected-scopes, private-scopes] = make-base-scopes(nm, ps)
   println("Protected-scopes")
   println-all(join(protected-scopes, "\n"))
   println("Private-scopes")
   println-all(join(private-scopes, "\n"))
