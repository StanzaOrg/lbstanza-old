#include<"core/stringeater.stanza">
#include<"compiler/stz-algorithms.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">

defpackage regalloc :
   import core
   import verse
   import stz/lexer
   import stz/parser
   import stz/algorithms

;========================================
definterface Loc
defstruct Stack <: Loc
defstruct Reg <: Loc
defstruct AnyLoc <: Loc
defstruct Dead <: Loc

definterface Ref
defmulti name (r:Ref) -> Symbol
defstruct Var <: Ref :
   name: Symbol with : (as-method => true)
defstruct LVar <: Ref :
   name: Symbol with : (as-method => true)
   loc: Loc

definterface Exp
defstruct Args <: Exp :
   xs: List<Ref>
defstruct Set <: Exp :
   x: Ref
   y: Ref
defstruct Op <: Exp :
   xs: List<Ref>
   ys: List<Ref>
defstruct Do <: Exp :
   xs: List<Ref>
   ys: List<Ref>
defstruct LDo <: Exp :
   xs: List<Ref>
   ys: List<Ref>
   live: List<Ref>

definterface Block
defmulti name (b:Block) -> Symbol
defmulti exps (b:Block) -> List<Exp>
defmulti next (b:Block) -> List<Symbol>

defstruct SBlock <: Block :
   name: Symbol with : (as-method => true)
   exps: List<Exp> with : (as-method => true)
   next: List<Symbol> with : (as-method => true)

defstruct LBlock <: Block :
   name: Symbol with : (as-method => true)
   exps: List<Exp> with : (as-method => true)
   next: List<Symbol> with : (as-method => true)
   live-in: List<Ref>
   live-out: List<Ref>

defstruct Program :
   blocks: List<Block>

;========================================

defstruct Save <: Exp :
   x: Ref
defstruct Load <: Exp :
   x: Ref

;========================================
defn cms (xs) : join(xs, ", ")

defmethod print (o:OutputStream, p:Program) :
   for b in join(blocks(p), "\n") do :
      print(o, b)

defmethod print (o:OutputStream, b:SBlock) :
   print(o, "block ~ :" << [name(b)])
   for e in exps(b) do :
      print(o, "\n   ~" << [e])
   print(o, "\n   goto (~@)" << [cms(next(b))])

defmethod print (o:OutputStream, b:LBlock) :
   print(o, "lblock ~ :" << [name(b)])
   for e in exps(b) do :
      print(o, "\n   ~" << [e])
   print(o, "\n   goto (~@)" << [cms(next(b))])
   print(o, "\n   live-in: (~@)" << [cms(live-in(b))])
   print(o, "\n   live-out: (~@)" << [cms(live-out(b))])

defmethod print (o:OutputStream, e:Exp) :
   print{o, _} $ match(e) :
      (e:Args) : "(~@) = args" << [cms(xs(e))]
      (e:Set) : "~ = ~" << [x(e), y(e)]
      (e:Op) : "(~@) = op(~@)" << [cms(xs(e)), cms(ys(e))]
      (e:Do) : "(~@) = f(~@)" << [cms(xs(e)), cms(ys(e))]
      (e:LDo) : "(~@) = f(~@) live:(~@)" << [cms(xs(e)), cms(ys(e)), cms(live(e))]
      (e:Save) : "save ~" << [x(e)]
      (e:Load) : "load ~" << [x(e)]

defmethod print (o:OutputStream, r:Ref) :
   print{o, _} $ match(r) :
      (r:Var) : name(r)
      (r:LVar) : "~:~" << [name(r), loc(r)]

defmethod print (o:OutputStream, l:Loc) :
   print{o, _} $ match(l) :
      (l:Stack) : "stack"
      (l:Reg) : "reg"
      (l:Dead) : "dead"
      (l:AnyLoc) : "any"

;========== Parser =====================
defsyntax regir :
   val ut = unwrap-token

   defrule :
      sym = (?x) when ut(x) typeof Symbol : ut(x)

      exp = ((?xs:#sym ...) = args) :
         Args(map(Var,xs))
      exp = (?x:#sym = ?y:#sym) :
         Set(Var(x), Var(y))
      exp = ((?xs:#sym ...) = op(?ys:#sym ...)) :
         Op(map(Var, xs), map(Var, ys))
      exp = ((?xs:#sym ...) = f(?ys:#sym ...)) :
         Do(map(Var, xs), map(Var, ys))

      block = (block ?name:#sym :
                  ?es:#exp ...
                  goto (?ns:#sym ...)) :
         SBlock(name, es, ns)

      prog = (?bs:#block ...) :
         Program(bs)

defn parse-regir (filename:String) -> Program :
   val lexed = lex-file(filename)
   with-syntax(regir) :
      match-syntax(lexed) :
         (?p:#prog) : p


;======== Liveness Analysis ============
;Block based liveness analysis
defstruct BlockLiveness :
   live-in: HashTable<Symbol,List<Symbol>>
   live-out: HashTable<Symbol,List<Symbol>>
   defs: HashTable<Symbol,List<Symbol>>

defmethod print (o:OutputStream, x:BlockLiveness) :
   defn ptable (name:String, t:HashTable) :
      print(o, "~: " << [name])
      for entry in t do :
         print(o, "\n   ~ : (~@)" << [key(entry), cms(value(entry))])
   ptable("Live In", live-in(x))
   ptable("\nLive Out", live-out(x))
   ptable("\nDefs", defs(x))

defn liveness-analysis (p:Program) :
   ;====== State ======
   val live-in = HashTable<Symbol, List<Symbol>>(symbol-hash)
   val live-out = HashTable<Symbol, List<Symbol>>(symbol-hash)
   val defs = HashTable<Symbol,List<Symbol>>(symbol-hash)

   ;====== Utilities ======
   defn #set-live-in (b:Block, xs:List<Symbol>) : live-in[name(b)] = xs
   defn #set-live-out (b:Block, xs:List<Symbol>) : live-out[name(b)] = xs
   defn #set-defs (b:Block, xs:List<Symbol>) : defs[name(b)] = xs

   ;Base case analysis of a block
   defn analyze (b:Block) :
      ;State
      val live-in-accum = Vector<Symbol>()
      val defs-accum = Vector<Symbol>()

      ;Utilities
      defn #def (x:Symbol) : add(defs-accum, x)
      defn #def (x:Ref) : #def(name(x))
      defn #def (xs:List<Ref>) : do(#def, xs)
      defn #def? (x:Symbol) : contains?(live-in-accum, x)
      defn #use (x:Symbol) : add(live-in-accum, x) when not #def?(x)
      defn #use (x:Ref) : #use(name(x))
      defn #use (xs:List<Ref>) : do(#use, xs)
      defn #live-in () : unique(live-in-accum)
      defn #defs () : unique(defs-accum)

      ;Analyze defs and uses
      for e in exps(b) do :
         match(e) :
            (e:Args) :
               #def(xs(e))
            (e:Set) :              
               #use(y(e))
               #def(x(e))
            (e:Op) :
               #use(ys(e))
               #def(xs(e))
            (e:Do) :
               #use(ys(e))
               #def(xs(e))
               
      #set-live-in(b, #live-in())
      #set-live-out(b, List())
      #set-defs(b, #defs())

   ;Propagation analysis of a block
   defn propagate () :
      fixpoint $ fn (progress) :
         ;=== Utilities ===
         defn #blocks () : blocks(p)
         defn #live-in (b:Symbol) : live-in[b]
         defn #live-out (b:Symbol) : live-out[b]
         defn #live-out (b:Block) : #live-out(name(b))
         defn #def? (b:Block, v:Symbol) : contains?(defs[name(b)], v)
         defn #add-live-out (b:Block, xs:List<Symbol>) : do(#add-live-out{b, _}, xs)
         defn #add-live-out (b:Block, x:Symbol) :
            val b* = name(b)
            if not contains?(live-out[b*], x) :
               live-out[b*] = List(x, live-out[b*])
               progress()
         defn #add-live-in (b:Block, x:Symbol) :
            val b* = name(b)
            if not contains?(live-in[b*], x) :
               live-in[b*] = List(x, live-in[b*])
               progress()

         ;=== Implementation ===
         for b in #blocks() do :
            for s in next(b) do :
               #add-live-out(b, #live-in(s))
         for b in #blocks() do :
            for v in #live-out(b) do :
               #add-live-in(b, v) when not #def?(b, v)

   ;Wrap in result
   defn wrap-results (b:Block) :
      defn #var (xs:List<Symbol>) : map(Var, xs)
      defn #live-in (b:Block) : live-in[name(b)]
      defn #live-out (b:Block) : live-out[name(b)]
      
      LBlock(name(b),
             exps(b),
             next(b),
             #var(#live-in(b))
             #var(#live-out(b)))
   
   do(analyze, blocks(p))
   propagate()
   Program(map(wrap-results, blocks(p)))

;====== Save/Load Emission ======
defn emit-save-load (b:LBlock) :
   ;====== State ======
   var exp-list = Vector<Exp>()
   val save-req = HashTable<Symbol,True|False>(symbol-hash)
   val load-req = HashTable<Symbol,True|False>(symbol-hash)
   
   ;====== Utilities ======
   defn #emit (e:Exp) : add(exp-list, e)
   defn #live-out () : live-out(b)
   defn #live-in () : live-in(b)   
   defn #req-save? (x:Ref) : get?(save-req, name(x), false)
   defn #req-save (x:Symbol, r:True|False) : save-req[x] = r
   defn #req-save (x:Ref, r:True|False) : #req-save(name(x), r)
   defn #req-save (xs:List<Ref>, r:True|False) : do(#req-save{_, r}, xs)
   defn #save (x:Ref) :
      #emit(Save(x)) when #req-save?(x)
      #req-save(x, false)
   defn #save (xs:List<Ref>) : do(#save, xs)
   defn #save (xs:Tuple<Ref|List<Ref>>) : do(#save, xs)
   defn #req-load? (x:Ref) : get?(load-req, name(x), false)
   defn #req-load (x:Symbol, r:True|False) : load-req[x] = r
   defn #req-load (x:Ref, r:True|False) : #req-load(name(x), r)
   defn #req-load (xs:List<Ref>, r:True|False) : do(#req-load{_, r}, xs)
   defn #load (x:Ref) :
      #emit(Load(x)) when #req-load?(x)
      #req-load(x, false)
   defn #load (xs:List<Ref>) : do(#load, xs)
   defn #load (xs:Tuple<Ref|List<Ref>>) : do(#load, xs)
   defn #strip-live (e:Exp) :
      match(e) :
         (e:LDo) : Do(xs(e), ys(e))
         (e) : e

   ;====== Implementation ======
   ;Generate the expressions in reverse order,
   ;calculating liveness as we go.
   defn #reverse-exps () :
      val live = HashTable<Symbol,True|False>(symbol-hash)
      defn #set-live (x:Symbol, l:True|False) : live[x] = l
      defn #set-live (x:Ref, l:True|False) : #set-live(name(x), l)
      defn #set-live (xs:List<Ref>, l:True|False) : do(#set-live{_, l}, xs)
      defn #live () : to-list(stream(Var{key(_)}, filter(value, live)))
      defn #with-live (e:Exp) :
         match(e) :
            (e:Do) : LDo(xs(e), ys(e), #live())
            (e) : e
      
      generate<Exp> :
         #set-live(#live-out(), true)
         for e in reverse(exps(b)) do :
            match(e) :
               (e:Args) : #set-live(xs(e), false)
               (e:Set) : #set-live(x(e), false)
               (e:Op) : #set-live(xs(e), false)
               (e:Do) : #set-live(xs(e), false)
            yield(#with-live(e))
            match(e) :
               (e:Args) : false
               (e:Set) : #set-live(y(e), true)
               (e:Op) : #set-live(ys(e), true)
               (e:Do) : #set-live(ys(e), true)

   ;Generate the new expressions in forward order.
   defn #forward-exps () :
      val exps = exp-list      
      exp-list = Vector<Exp>()
      for i in (length(exps) - 1) through 0 by -1 stream :
         exps[i]

   ;Save live values onto the stack.
   for e in #reverse-exps() do :
      ;Save defined values if required
      match(e) :
         (e:Args) : #save(xs(e))
         (e:Set) : #save(x(e))
         (e:Op) : #save(xs(e))
         (e:LDo) : #save(xs(e))
      ;Emit the expression
      #emit(e)
      ;Request live values to be saved
      match(e) :
         (e:LDo) : #req-save(live(e), true)
         (e) : false

   ;Load arguments into registers before operating.
   for e in #forward-exps() do :
      ;Load operands if required
      match(e) :
         (e:Args) : false
         (e:Set) : #load(y(e))
         (e:Op) : #load(ys(e))
         (e:LDo) : false
         (e:Save) : #load(x(e))
      ;Emit the expression
      #emit(#strip-live(e))
      ;Determine if load is required
      match(e) :
         (e:Args) : #req-load(xs(e), false)
         (e:Set) : #req-load(x(e), false)
         (e:Op) : #req-load(xs(e), false)
         (e:LDo) : 
            #req-load(live(e), true)
            #req-load(xs(e), false)
         (e:Save) : false

   LBlock(name(b),
          to-list(exp-list),
          next(b),
          live-in(b),
          live-out(b))

defn emit-save-load (p:Program) :
   val bs = blocks(p) as List<LBlock>
   Program(map(emit-save-load, bs))

;====== Finite Register Allocation ======
defstruct Use
defstruct Def

;defn finite-register-allocation (b:LBlock) :
;   defn #live-out () : live-out(b)
;   defn #live-in () : live-in(b)
;
;   defn exps-with-release () :
;      ;use(i,x) & next-position(x) != use   =>  last-use(i,x)
;      ;def(i,x) & next-position(x) != use   =>  no-use(i,x)
;      ;last-use(i,x)  =>  release(i,x)
;      ;no-use(i,x)  =>  release(i+1, x)
;      ;====== State ======
;      val next-appearance = HashTable<Symbol,Use|Def>(symbol-hash)
;      val last-use-list = Vector<List<Ref>>()
;      val no-use-list = Vector<List<Ref>>()
;      val exp-list = to-array(exps(b))
;
;      ;====== Utilities ======
;      val #n = length(exp-list)
;      defn #next (x:Ref) : get?(next-appearance, name(x), false)
;      defn #set-next (x:Ref, v:Use|Def) : next-appearance[name(x)] = v
;      defn #set-next (xs:List<Ref>, v:Use|Def) : do(#set-next{_, v}, xs)
;      defn #last-uses (i:Int) : last-use-list[#n - 1 - i]
;      defn #no-uses (i:Int) : no-use-list[#n - 1 - i]
;      defn #exp (i:Int) : exp-list[i]
;
;      ;====== Algorithm ======
;      #set-next(#live-out(), Use())
;      for i in (#n - 1) through 0 by -1 do :
;         ;====== Utilities ======
;         var last-uses = List()
;         var no-uses = List()
;         defn #def (x:Ref) :
;            if #next(x) not-typeof Use : no-uses = List(x, no-uses)
;            #set-next(x, Def())
;         defn #use (x:Ref) :
;            if #next(x) not-typeof Use : last-uses = List(x, last-uses)
;            #set-next(x, Use())
;         defn #def (xs:List<Ref>) : do(#def, xs)
;         defn #use (xs:List<Ref>) : do(#use, xs)
;
;         ;====== Implementation ======
;         match(#exp(i)) :
;            (e:Args) : (#def(xs(e)))
;            (e:Set) : (#def(x(e)), #use(y(e)))
;            (e:Op) : (#def(xs(e)), #use(ys(e)))
;            (e:Do) : (#def(xs(e)), #use(ys(e)))
;            (e:Load) : (#def(x(e)))
;            (e:Save) : (#use(x(e)))
;         add(last-use-list, last-uses)
;         add(no-use-list, no-uses)      
;
;      for i in 0 to #n stream :
;         val rs = if i > 0 : unique(concat(#last-uses(i), #no-uses(i - 1)))
;                  else : unique(#last-uses(i))
;         [#exp(i), rs]
;
;   defn allocate () :
;      ;====== State ======
;      var num-reg = 0
;      val loaded = HashTable<Symbol,True|False>(symbol-hash)
;      val exp-list = Vector<Exp>()
;
;      ;====== Utilities ======
;      defn #set-loaded (x:Ref, v:True|False) : loaded[name(x)] = v
;      defn #set-loaded (xs:List<Ref>, v:True|False) : do(#set-loaded{_, v}, xs)
;      defn #load (x:Ref) :
;         println("Load ~" << [x])
;         #emit(Load(x))
;         num-reg = num-reg + 1
;         println("Num-reg increased to ~" << [num-reg])
;         #set-loaded(x, true)
;      defn #use (x:Ref) :
;         println("~ is used." << [x])
;         #load(x) when not loaded[name(x)]
;      defn #release (x:Ref) :
;         println("Release ~" << [x])
;         num-reg = num-reg - 1
;         println("Num-reg decreased to ~" << [num-reg])
;         #set-loaded(x, false)
;      defn #def (x:Ref) :
;         println("~ was defined." << [x])
;         num-reg = num-reg + 1
;         println("Num-reg increased to ~" << [num-reg])
;         #set-loaded(x, true)
;      defn #use (xs:List<Ref>) : do(#use, xs)
;      defn #def (xs:List<Ref>) : do(#def, xs)
;      defn #release (xs:List<Ref>) : do(#release, xs)
;      defn #emit (e:Exp) : add(exp-list, e)
;
;      println("=== Try to allocate ===")
;      do(println, exps(b))
;      println("=== Work ===")
;
;      #set-loaded(#live-in(), true)
;      num-reg = num-reg + length(#live-in())
;      for [e, rs] in exps-with-release() do :
;         println("Considering: ~ with releases: ~@" << [e, cms(rs)])
;         match(e) :
;            (e:Args) :
;               #release(rs)
;               #def(xs(e))
;            (e:Set) :
;               #use(y(e))
;               #release(rs)
;               #def(x(e))
;            (e:Op) :
;               #use(ys(e))
;               #release(rs)
;               #def(xs(e))
;            (e:Do) :
;               #use(ys(e))
;               #release(rs)
;               #def(xs(e))
;            (e:Save) :
;               #use(x(e))
;               #release(rs)
;            (e:Load) :
;               #release(rs)
;               #def(x(e))
;         #emit(e)
;         println("After expression ~, num-reg = ~" << [e, num-reg])
;
;      ;====== Print out Result ======
;      println("=== Result ===")
;      for e in exp-list do :
;         println(e)
;
;   allocate()






;;========= LastUse =====================
;defn compute-last-use (b:LBlock) :
;   val last-uses = Vector<List<Symbol>>()
;   val dsts = HashTable<Symbol,Loc>(symbol-hash)
;
;   defn init-dsts () :
;      for v in live-out(b) as List<LVar> do :
;         dsts[name(v)] = loc(v)
;         
;   defn scan-exps (es:List<Exp>) :
;      for e in reverse(es) do :
;         ;Accumulate last use variables
;         var last = List<Symbol>()
;         defn mark-use (x:Ref) :
;            if get?(dsts, name(x), Dead()) typeof Dead :
;               last = List(name(x), last)
;            dsts[name(x)] = Reg()
;         defn mark-dead (x:Ref) :
;            dsts[name(x)] = Dead()
;            
;         match(e) :
;            (e:Args) :
;               do(mark-dead{Var(_)}, xs(e))
;            (e:Set) :
;               mark-dead(x(e))
;               mark-use(y(e))
;            (e:Op) :
;               do(mark-use, ys(e))
;               do(mark-dead, xs(e))
;            (e:Do) :
;               do(mark-use, ys(e))
;               do(mark-dead, xs(e))
;            (e:Save) :
;               mark-use(x(e))
;            (e:Load) :
;               mark-dead(x(e))
;
;         add(last-uses, last)
;
;   init-dsts()
;   scan-exps(exps(b))
;   reverse(to-list(last-uses))
;
;;========== Next Use ====================
;defn compute-uses (b:LBlock) :
;   val next-uses = Vector<List<Symbol>>()
;
;   defn scan-exps (es:List<Exp>) :
;      var uses = map(name, live-out(b))
;      defn mark-use (x:Ref) :
;         uses = List(name(x), uses)
;      for e in reverse(es) do :
;         add(next-uses, uses)
;         match(e) :
;            (e:Args) : false
;            (e:Set) : mark-use(y(e))
;            (e:Op) : do(mark-use, ys(e))
;            (e:Do) : do(mark-use, ys(e))
;            (e:Save) : mark-use(x(e))
;            (e:Load) : false
;
;   scan-exps(exps(b))
;   reverse(to-list(next-uses))
;
;defn find-next-uses (xs:List<Symbol>) :
;   val t = HashTable<Symbol,True>(symbol-hash)
;   defn loop (xs:List<Symbol>) :
;      if empty?(xs) : List()
;      else if key?(t, head(xs)) : loop(tail(xs))
;      else : List(head(xs), loop(tail(xs)))
;   loop(xs)
;
;;========== Spill Registers =============
;defn spill-registers (b:LBlock, N:Int) :
;   val last-uses = compute-last-use(b)
;   val next-uses = compute-uses(b)
;
;   ;Kill and Birth
;   var n:Int = 0
;   val live = HashTable<Symbol,True|False>(symbol-hash)
;   defn kill (x:Ref) :
;      if live[name(x)] :         
;         live[name(x)] = false
;         n = n - 1
;   defn birth (x:Ref) :
;      if get?(live, name(x), false) :
;         live[name(x)] = true
;         n = n + 1
;
;   ;Spilling and Loading
;   val accum = Vector<Exp>()
;   defn spill (x:Ref) :
;      add(accum, Save(x))
;      kill(x)
;   defn load (x:Ref) :
;      add(accum, Load(x))
;      birth(x)
;         
;   defn spill (es:List<Exp>) :
;      for (e in es, killed in last-uses, uses in next-uses) do :         
;         ;Marking and Ensuring Live
;         defn reserve-reg () :
;            if n >= N :
;               val uses* = reverse(find-next-uses(uses))
;               val v = for v in uses* find :
;                  get?(live, v, false)
;               spill(Var(v as Symbol))
;         defn mark-live (x:Ref) :
;            reserve-reg()
;            birth(x)
;         defn ensure-live (x:Ref) :
;            if not live[name(x)] :
;               reserve-reg()
;               load(x)
;               
;         match(e) :
;            (e:Args) :
;               do(mark-live{Var(_)}, xs(e))
;               add(accum, e)
;            (e:Set) :
;               ensure-live(y(e))
;               do(kill, killed)
;               mark-live(x(e))
;               add(accum, e)
;            (e:Op) :
;               do(ensure-live, ys(e))
;               do(kill, killed)
;               do(mark-live, xs(e))
;               add(accum, e)               
;;            (e:Do) :
;;               do(
;;
;;
;;               do(mark-use, ys(e)) ;;asdfasdf
;            (e:Save) :
;               kill(x(e))
;               add(accum, e)
;            (e:Load) :
;               mark-live(x(e))
;               add(accum, e)
;      
;
;defn compute-last-use (p:Program) :
;   for b in blocks(p) as List<LBlock> do :
;      println("Block ~:" << [name(b)])
;      val lu = compute-last-use(b)
;      val us = compute-uses(b)
;      for (e in exps(b), u in lu, us in us) do :
;         if empty?(u): println("   ~ USES(~@)" << [e, cms(us)])
;         else : println("   ~  KILLED(~@) USES(~@)" << [e, cms(u), cms(us)])
               



;========= Driver ======================
defn main () :
   val filename = commandline-arguments()[1]
   val prog = parse-regir(filename)
   println(prog)

   println("liveness analysis")
   val lp = liveness-analysis(prog)
   println(lp)

   println("emit save load")
   val ap = emit-save-load(lp)
   println(ap)

   ;do(finite-register-allocation, blocks(ap) as List<LBlock>)
   
   ;val ap = emit-saves(lp)
   ;println(ap)
   ;
   ;val ap2 = emit-loads(ap)
   ;println(ap2)
   ;
   ;println("\n\n")
   ;compute-last-use(ap2)

main()