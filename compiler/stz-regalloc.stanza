#include<"core/stringeater.stanza">
#include<"compiler/stz-algorithms.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">

defpackage regalloc :
   import core
   import verse
   import stz/lexer
   import stz/parser
   import stz/algorithms

;============ Input IR =======================
definterface Ref
defmulti name (r:Ref) -> Symbol
defstruct Var <: Ref :
   name: Symbol with : (as-method => true)

definterface Exp
defstruct Args <: Exp :
   xs: List<Ref>
defstruct Set <: Exp :
   x: Ref
   y: Ref
defstruct Op <: Exp :
   xs: List<Ref>
   ys: List<Ref>
defstruct Do <: Exp :
   xs: List<Ref>
   ys: List<Ref>

definterface Block
defmulti name (b:Block) -> Symbol
defmulti exps (b:Block) -> List<Exp>
defmulti next (b:Block) -> List<Symbol>

defstruct SBlock <: Block :
   name: Symbol with : (as-method => true)
   exps: List<Exp> with : (as-method => true)
   next: List<Symbol> with : (as-method => true)

defstruct Program :
   blocks: List<Block>

;========== Parser =====================
defsyntax regir :
   val ut = unwrap-token

   defrule :
      sym = (?x) when ut(x) typeof Symbol : ut(x)

      exp = ((?xs:#sym ...) = args) :
         Args(map(Var,xs))
      exp = (?x:#sym = ?y:#sym) :
         Set(Var(x), Var(y))
      exp = ((?xs:#sym ...) = op(?ys:#sym ...)) :
         Op(map(Var, xs), map(Var, ys))
      exp = ((?xs:#sym ...) = f(?ys:#sym ...)) :
         Do(map(Var, xs), map(Var, ys))

      block = (block ?name:#sym :
                  ?es:#exp ...
                  goto (?ns:#sym ...)) :
         SBlock(name, es, ns)

      prog = (?bs:#block ...) :
         Program(bs)

defn parse-regir (filename:String) -> List<Program> :
   val lexed = lex-file(filename)
   with-syntax(regir) :
      match-syntax(lexed) :
         ((test : (?ps:#prog)) @...) : ps

;========== Working IR ==================
definterface Loc
defstruct Stack <: Loc
defstruct Reg <: Loc
defstruct Dead <: Loc
defstruct Unknown <: Loc

defstruct Status :
   saved?: True|False
   loaded?: True|False

;defstruct LVar <: Ref :
;   name: Symbol with : (as-method => true)
;   loc: Loc

defstruct GetArgs <: Exp :
   xs: List<Ref>
   locs: List<Loc>
defstruct SetArgs <: Exp :
   xs: List<Ref>
defstruct Call <: Exp :
   live: List<Ref>
defstruct Save <: Exp :
   x: Ref
defstruct Load <: Exp :
   x: Ref

defstruct LBlock <: Block :
   name: Symbol with: (as-method => true)
   exps: List<Exp> with: (as-method => true)
   next: List<Symbol> with: (as-method => true)
   live-in: List<Ref>
   status-in: List<Status>
   live-out: List<Ref>
   status-out: List<Status>
   dist-out: List<Int>

;=========== Printing =====================
defn cms (xs) : join(xs, ", ")

defmethod print (o:OutputStream, p:Program) :
   for b in join(blocks(p), "\n") do :
      print(o, b)

defmethod print (o:OutputStream, b:SBlock) :
   print(o, "block ~ :" << [name(b)])
   for e in exps(b) do :
      print(o, "\n   ~" << [e])
   print(o, "\n   goto (~@)" << [cms(next(b))])

defmethod print (o:OutputStream, s:Status) :
   print{o, _} $ match(saved?(s), loaded?(s)) :
      (s:True, l:True) : "SL"
      (s:True, l:False) : "S"
      (s:False, l:True) : "L"
      (s:False, l:False) : "?"

defmethod print (o:OutputStream, b:LBlock) :
   defn ps (x:Ref, s:Status) : "~:~" << [x, s]
   defn ps (xs:List<Ref>, ss:List<Status>) : stream(ps, xs, ss)
   print(o, "lblock ~ :" << [name(b)])
   for e in exps(b) do :
      print(o, "\n   ~" << [e])
   print(o, "\n   goto (~@)" << [cms(next(b))])
   print(o, "\n   live-in: (~@)" << [cms(ps(live-in(b), status-in(b)))])
   print(o, "\n   live-out: (~@)" << [cms(ps(live-out(b), status-out(b)))])
   print(o, "\n   dist-out: (~@)" << [cms(dist-out(b))])

defmethod print (o:OutputStream, e:Exp) :
   defn ploc (x:Ref, l:Loc) : "~:~" << [x, l]
   defn plocs (xs:List<Ref>, ls:List<Loc>) : stream(ploc, xs, ls)
   print{o, _} $ match(e) :
      (e:Args) : "(~@) = args" << [cms(xs(e))]
      (e:Set) : "~ = ~" << [x(e), y(e)]
      (e:Op) : "(~@) = op(~@)" << [cms(xs(e)), cms(ys(e))]
      (e:Do) : "(~@) = f(~@)" << [cms(xs(e)), cms(ys(e))]
      (e:GetArgs) : "(~@) = Args" << [cms(plocs(xs(e), locs(e)))]
      (e:SetArgs) : "Args = (~@)" << [cms(xs(e))]
      (e:Call) : "Call with live: (~@)" << [cms(live(e))]
      (e:Save) : "save ~" << [x(e)]
      (e:Load) : "load ~" << [x(e)]

defmethod print (o:OutputStream, r:Ref) :
   print{o, _} $ match(r) :
      (r:Var) : name(r)
;      (r:LVar) : "~:~" << [name(r), loc(r)]

defmethod print (o:OutputStream, l:Loc) :
   print{o, _} $ match(l) :
      (l:Stack) : "stk"
      (l:Reg) : "reg"
      (l:Dead) : "X"
      (l:Unknown) : "?"

;====== Working Form ======
defn working-form (b:Block) :
   val exp-list = Vector<Exp>()
   defn #uk (xs:List) : map(Unknown{}, xs)
   defn #get-args (xs:List<Ref>) : GetArgs(xs, #uk(xs))
   defn #call () : Call(List())
   defn #lblock (es:List<Exp>) :
      val el = List()
      LBlock(name(b), es, next(b), el, el, el, el, el)
   defn #emit (e:Exp) : add(exp-list, e)

   for e in exps(b) do :
      match(e) :
         (e:Args) :
            #emit(#get-args(xs(e)))
         (e:Do) :
            #emit(SetArgs(ys(e)))
            #emit(#call())
            #emit(#get-args(xs(e)))
         (e) :
            #emit(e)
   #lblock(to-list(exp-list))

defn working-form (p:Program) :
   Program(map(working-form, blocks(p)))

;======== Liveness Analysis ============
defn liveness-analysis (p:Program) :
   ;====== State ======
   defn bhash ([b,x]:[Symbol,Symbol]) : 7 * symbol-hash(b) + symbol-hash(x)
   val lengths = HashTable<Symbol,Int>(symbol-hash)
   val live-in-table = HashTable<[Symbol,Symbol], Int>(bhash)
   val live-out-table = HashTable<[Symbol,Symbol], Int>(bhash)
   val defs = HashTable<[Symbol,Symbol], True>(bhash)
   val pred-table = HashTable<Symbol,List<Symbol>>(symbol-hash)
   var changed: () -> False = {false}

   ;====== Utilities ======
   defn #def? (b:Symbol, x:Symbol) : key?(defs, [b, x])
   defn #def? (b:Block, x:Symbol) : #def?(name(b), x)
   defn #def? (b:Block, x:Ref) : #def?(b, name(x))
   defn #def (b:Block, x:Ref) : #def(b, name(x))
   defn #def (b:Block, xs:List<Ref|Symbol>) : do(#def{b, _}, xs)
   defn #use (b:Block, xs:List<Ref>, i:Int) : do(#use{b, _, i}, xs)
   defn #add-live-in (b:Block, x:Ref, i:Int) : #add-live-in(name(b), name(x), i)
   defn #add-pred (b:Symbol, p:Symbol) : pred-table[b] = List(p, get?(pred-table, b, List()))
   defn #add-pred (b:Symbol, p:Block) : #add-pred(b, name(p))
   defn #set-length (b:Block, n:Int) : lengths[name(b)] = n
   defn #length (b:Symbol) : lengths[b]
   defn #pred (b:Symbol) : get?(pred-table, b, List())

   ;====== Computing the Block Liveness ======
   defn #def (b:Block, x:Symbol) :
      defs[[name(b), x]] = true

   defn #use (b:Block, x:Ref, i:Int) :
      #add-live-in(b, x, i) when not #def?(b, x)
   
   defn #add-live-in (b:Symbol, x:Symbol, i:Int) :
      val k = [b, x]
      defn update () :
         live-in-table[k] = i
         changed()
      match(get?(live-in-table, k, false)) :
         (i2:Int) : update() when i < i2
         (i2:False) : update()
         
   defn #add-live-out (b:Symbol, x:Symbol, i:Int) :
      val k = [b, x]
      defn update () :
         live-out-table[k] = i
         changed()
      match(get?(live-out-table, k, false)) :
         (i2:Int) : update() when i < i2
         (i2:False) : update()

   defn compute-block-liveness (b:Block) :
      ;Analyze defs and uses
      for (e in exps(b), i in 0 to false) do :
         match(e) :
            (e:GetArgs) : #def(b, xs(e))
            (e:SetArgs) : #use(b, xs(e), i)
            (e:Set) : (#use(b, y(e), i), #def(b, x(e)))
            (e:Op) : (#use(b, ys(e), i), #def(b, xs(e)))
            (e:Call) : false
            
      ;Record length of block      
      #set-length(b, length(exps(b)))
      
      ;Record predecessors of block
      do(#add-pred{_, b}, next(b))

   ;====== Propagating Liveness ======
   ;Propagation analysis of a block
   defn propagate-block-liveness () :
      fixpoint $ fn (progress) :
         let-var changed = progress :
            ;Propagate live-ins to live-outs
            for e in live-in-table do :
               val [b, x] = key(e)
               val d = value(e)
               for p in #pred(b) do :
                  #add-live-out(p, x, d)
            ;Propagate live-outs to live-ins
            for e in live-out-table do :
               val [b, x] = key(e)
               val d = value(e)
               if not #def?(b, x) :
                  #add-live-in(b, x, d + #length(b))

   ;====== Accumulate Live-in and Live-out Tables ======
   defn accumulate (t:HashTable<[Symbol,Symbol],?>) :
      val accum = HashTable<Symbol,List<Symbol>>(symbol-hash)
      for [k v] in keys(t) do :
         accum[k] = List(v, get?(accum, k, List()))
      accum

   do(compute-block-liveness, blocks(p))
   propagate-block-liveness()
   val live-in-lists = accumulate(live-in-table)
   val live-out-lists = accumulate(live-out-table)

   defn wrap-live (b:Block) :
      defn #var (xs:List<Symbol>) : map(Var, xs)
      defn #any (xs:List) : map(Status{false, false}, xs)
      defn #dist (xs:List<Symbol>) : map({live-out-table[[name(b), _]]}, xs)
      defn #live-in () : get?(live-in-lists, name(b), List())
      defn #live-out () : get?(live-out-lists, name(b), List())
      LBlock(name(b),
             exps(b),
             next(b),
             #var(#live-in())
             #any(#live-in())
             #var(#live-out())
             #any(#live-out())
             #dist(#live-out()))

   Program(map(wrap-live, blocks(p)))             

;   ;====== Intrablock Liveness ======
;   ;Finegrained liveness calculation within block
;   defn compute-intrablock-liveness (b:Block) :
;      ;State
;      val live = HashTable<Symbol,True|False>(symbol-hash)
;      val exp-list = Vector<Exp>()
;   
;      ;Utilities
;      defn #live? (x:Ref) : get?(live, name(x), false)
;      defn #live-in () : get?(live-in-lists, name(b), List())
;      defn #live-out () : get?(live-out-lists, name(b), List())
;      defn #set-live (x:Symbol, l:True|False) : live[x] = l
;      defn #set-live (x:Ref, l:True|False) : #set-live(name(x), l)
;      defn #set-live (xs:List<Symbol|Ref>, l:True|False) : do(#set-live{_, l}, xs)
;      defn #locs (xs:List<Ref>) : map(#loc, xs)
;      defn #emit (e:Exp) : add(exp-list, e)
;      defn #var (xs:List<Symbol>) : map(Var, xs)
;      defn #status (xs:List) : map(Status{false, false}, xs)
;      defn #f (xs:List) : map({false}, xs)
;      defn #dist (x:Symbol) : live-out-table[[name(b), x]]
;      defn #dist (xs:List<Symbol>) : map(#dist, xs)      
;   
;      ;Algorithm
;      defn #loc (x:Ref) :
;         Unknown() when #live?(x) else Dead()
;
;      defn #live () :
;         to-list $
;         stream(Var{key(_)}, filter(value, live))
;
;      defn #with-live (e:Exp) :
;         match(e) :
;            (e:Call) : Call(#live())
;            (e:GetArgs) : GetArgs(xs(e), #locs(xs(e)))
;            (e) : e
;
;      defn #exps () :
;         to-list $
;         for i in (length(exp-list) - 1) through 0 by -1 stream :
;            exp-list[i]
;
;      #set-live(#live-out(), true)
;      for e in reverse(exps(b)) do :
;         #emit(#with-live(e))
;         match(e) :
;            (e:GetArgs) : #set-live(xs(e), false)
;            (e:SetArgs) : #set-live(xs(e), true)
;            (e:Set) : (#set-live(x(e), false), #set-live(y(e), true))
;            (e:Op) : (#set-live(xs(e), false), #set-live(ys(e), true))
;            (e:Call) : false
;
;      LBlock(name(b),
;             #exps(),
;             next(b),
;             #var(#live-in())
;             #status(#live-in())
;             #var(#live-out())
;             #status(#live-out())
;             #dist(#live-out()))
;
;   Program(map(compute-intrablock-liveness, blocks(p)))


;;====== Save/Load Emission ======
;defn emit-save-load (b:LBlock) :
;   ;Utilities
;   defn #live-in () : live-in(b)
;
;   ;====== Implementation ======
;   ;Save live values onto the stack.
;   defn emit-saves (es:List<Exp>) :
;      ;State
;      val save-req = HashTable<Symbol,True|False>(symbol-hash)
;      val exp-list = Vector<Exp>()
;
;      ;Utilities
;      defn #req-save? (x:Ref) : get?(save-req, name(x), false)
;      defn #req-save? (xs:List<Ref>) : map(#req-save?, xs)
;      defn #req-save (x:Ref, v:True|False) : save-req[name(x)] = v
;      defn #req-save (xs:List<Ref>, v:True|False) : do(#req-save{_, v}, xs)
;      defn #emit (e:Exp) : add(exp-list, e)
;      defn #save (xs:List<Ref>) : do(#save, xs)
;      defn #reverse (es:Vector<Exp>) :
;         for i in (length(es) - 1) through 0 by -1 stream :
;            es[i]
;
;      ;Algorithm
;      defn #save (x:Ref) :
;         #emit(Save(x)) when #req-save?(x)
;         #req-save(x, false)
;
;      defn #save-loc (x:Ref, l:Loc) :
;         l when l typeof Dead else
;         Stack() when #req-save?(x) else
;         Reg()
;
;      for e in reverse(es) do :
;         ;Save defined values if required
;         match(e) :
;            (e:GetArgs) :
;               val locs* = map(#save-loc, xs(e), locs(e))
;               #emit(GetArgs(xs(e), locs*))
;            (e:SetArgs) :
;               #emit(e)
;            (e:Set) :
;               #save(x(e))
;               #emit(e)
;            (e:Op) :
;               #save(xs(e))
;               #emit(e)
;            (e:Call) :
;               #emit(e)
;               #req-save(live(e), true)
;
;      ;Results
;      val es* = #reverse(exp-list)
;      val save-in = #req-save?(#live-in())
;      [es*, save-in]
;
;   ;Load arguments into registers before operating.
;   defn emit-loads (es:Streamable<Exp>) :
;      ;State
;      val loaded = HashTable<Symbol,True|False>(symbol-hash)
;      val load-in-table = HashTable<Symbol,True|False>(symbol-hash)
;      val exp-list = Vector<Exp>()
;
;      ;Utilities
;      defn #emit (e:Exp) : add(exp-list, e)
;      defn #set-load-in (x:Ref, v:True|False) : load-in-table[name(x)] = v
;      defn #set-loaded (x:Ref, v:True|False) : loaded[name(x)] = v
;      defn #set-loaded (xs:List<Ref>, v:True|False) : do(#set-loaded{_, v}, xs)
;      defn #set-loaded (xs:List<Ref>, vs:List<True|False>) : do(#set-loaded, xs, vs)
;      defn #load-in? (x:Ref) : get?(load-in-table, name(x), false)
;      defn #load-in? (xs:List<Ref>) : map(#load-in?, xs)
;      defn #reg? (l:Loc) : l typeof Reg
;      defn #reg? (ls:List<Loc>) : map(#reg?, ls)
;      defn #load (xs:List<Ref>) : do(#load, xs)
;
;      ;Algorithm
;      defn #load (x:Ref) :
;         match(get?(loaded, name(x), `any)) :
;            (l:Symbol) : #set-load-in(x, true)
;            (l:True) : false
;            (l:False) : #emit(Load(x))
;         #set-loaded(x, true)
;         
;      for e in es do :
;         ;Load operands if required
;         match(e) :
;            (e:GetArgs) : false
;            (e:SetArgs) : false
;            (e:Set) : #load(y(e))
;            (e:Op) : #load(ys(e))
;            (e:Call) : false
;            (e:Save) : false
;         ;Emit the expression
;         #emit(e)
;         ;Determine if load is required
;         match(e) :
;            (e:GetArgs) : #set-loaded(xs(e), #reg?(locs(e)))
;            (e:SetArgs) : false
;            (e:Set) : #set-loaded(x(e), true)
;            (e:Op) : #set-loaded(xs(e), true)
;            (e:Call) : #set-loaded(live(e), false)
;            (e:Save) : false
;
;      val load-in = #load-in?(#live-in())
;      [exp-list, load-in]
;
;   ;====== Driver ======
;   val [saved, save-in] = emit-saves(exps(b))
;   val [loaded, load-in] = emit-loads(saved)
;   LBlock(name(b),
;          to-list(loaded),
;          next(b),
;          live-in(b),
;          save-in,
;          load-in,
;          live-out(b),
;          save-out(b),
;          load-out(b)
;          dist-out(b))
;
;defn emit-save-load (p:Program) :
;   val bs = blocks(p) as List<LBlock>
;   Program(map(emit-save-load, bs))
;
;
;;====== Release ======
;defn compute-release (b:LBlock) :
;   ;====== State ======
;   val exps = to-array(exps(b))
;   val n = length(exps)
;   val live = HashTable<Symbol,True|False>(symbol-hash)
;   val last-use-list = Array<List<Symbol>>(n, List())
;   val no-use-list = Array<List<Symbol>>(n, List())
;
;   ;====== Utilities ======
;   defn #set-live (x:Ref, v:True|False) : live[name(x)] = v
;   defn #set-live (xs:Streamable<Ref>, v:True|False) : do(#set-live{_, v}, xs)
;   defn #live? (x:Ref) : get?(live, name(x), false)
;   defn #live? (x:Ref, l:Loc) : l not-typeof Dead
;
;   #set-live(live-out(b), true)
;   for i in (n - 1) through 0 by -1 do :
;      ;====== State ======
;      var last-uses:List<Symbol> = List()
;      var no-uses:List<Symbol> = List()
;
;      ;====== Utilities ======
;      defn #add-no-use (x:Ref) : no-uses = List(name(x), no-uses)
;      defn #add-last-use (x:Ref) : last-uses = List(name(x), last-uses)
;      defn #def (xs:Streamable<Ref>) : do(#def, xs)
;      defn #use (xs:Streamable<Ref>) : do(#use, xs)
;
;      ;====== Algorithm ======
;      defn #def (x:Ref) :
;         #add-no-use(x) when not #live?(x)
;         #set-live(x, false)
;         
;      defn #use (x:Ref) :
;         #add-last-use(x) when not #live?(x)
;         #set-live(x, true)
;
;      match(exps[i]) :
;         (e:GetArgs) : #def(filter(#live?, xs(e), locs(e)))
;         (e:SetArgs) : #use(xs(e))
;         (e:Set) : (#def(x(e)), #use(y(e)))
;         (e:Op) : (#def(xs(e)), #use(ys(e)))
;         (e:Call) : false
;         (e:Save) : (#use(x(e)))
;         (e:Load) : (#def(x(e)))
;
;      last-use-list[i] = last-uses
;      no-use-list[i] = no-uses
;
;   val release-list = Array<List<Symbol>>(n)
;   for i in 0 to n do :
;      release-list[i] = unique $
;         if i > 0 : concat(last-use-list[i], no-use-list[i - 1])
;         else : last-use-list[i]
;   release-list
;   
;

;;====== Time to Use ======
defstruct Pos :
   i: Int
   mid?: True|False

defclass UsageTable <: Gettable<Pos, List<KeyValue<Symbol, Int>>>

defn hash (p:Pos) :
   match(mid?(p)) :
      (m:True) : i(p) * 2 + 1
      (m:False) : i(p) * 2

defn compute-usage-table (b:LBlock) :
   ;====== State ======
   val exps = to-array(exps(b))
   val n = length(exps)
   val dist-table = HashTable<Symbol,Int|False>(symbol-hash)
   val usages = Array<List<KeyValue<Symbol,Int>>>(n * 2 + 1)

   ;====== Utilities ======   
   defn #n-out () : map({_ + n}, dist-out(b))
   defn #set-usages (p:Pos, xs:List<KeyValue<Symbol,Int>>) : usages[hash(p)] = xs
   defn #set-dist (x:Ref, d:Int|False) : dist-table[name(x)] = d
   defn #set-dist (xs:List<Ref>, d:Int|False) : do(#set-dist{_, d}, xs)
   defn #set-dist (xs:List<Ref>, ds:List<Int|False>) : do(#set-dist, xs, ds)
   defn #live () :
      val live-e = filter({value(_) typeof Int}, dist-table)
      to-list(live-e) as List<KeyValue<Symbol,Int>>

   ;====== Algorithm ======         
   #set-dist(live-out(b), #n-out())
   #set-usages(Pos(n, false), #live())
   for i in (n - 1) through 0 by -1 do :
      ;Effect of defs
      match(exps[i]) :
         (e:GetArgs) : #set-dist(xs(e), false)
         (e:SetArgs) : false
         (e:Set) : #set-dist(x(e), false)
         (e:Op) : #set-dist(xs(e), false)
         (e:Call) : false
      #set-usages(Pos(i, true), #live())
      ;Effect of uses
      match(exps[i]) :
         (e:GetArgs) : false
         (e:SetArgs) : #set-dist(xs(e), i)
         (e:Set) : #set-dist(y(e), i)
         (e:Op) : #set-dist(ys(e), i)
         (e:Call) : false
      #set-usages(Pos(i, false), #live())

   new UsageTable :
      defmethod get (this, p:Pos) : usages[hash(p)]

defn compute-usage-table (p:Program) :
   for b in blocks(p) do :
      println("For block: ~" << [name(b)])
      val t = compute-usage-table(b as LBlock)
      val n = length(exps(b))
      for (e in exps(b), i in 0 to false) do :
         println("   ~" << [e])
         println("      entry: ~@" << [cms(t[Pos(i,false)])])
         println("      mid: ~@" << [cms(t[Pos(i,true)])])
      println("      out: ~@" << [cms(t[Pos(n, false)])])  




;;====== Finite Register Allocation ======
;;defstruct Use
;;defstruct Def
;
;defn finite-allocation (b:LBlock) :
;   ;====== State ======
;   var num-reg = 0
;   val N = 8
;   val loaded = HashTable<Symbol,True|False>(symbol-hash)
;   val exp-list = Vector<Exp>()
;   val times = compute-time-to-use(b)
;   val releases = compute-release(b)
;   val exps = to-array(exps(b))
;
;   ;====== Utilities ======
;   defn #emit (e:Exp) : add(exp-list, e)
;   defn #loaded () : stream(key, filter(value, loaded))
;   defn #loaded? (x:Symbol) : get?(loaded, x, false)
;   defn #loaded? (x:Ref) : #loaded?(name(x))
;   defn #load-in? (x:Ref, l:True|False) : l
;   defn #reg? (x:Ref, l:Loc) : l typeof Reg
;   defn #mark-loaded (ys:Streamable<Ref>) : do(#mark-loaded, ys)
;   defn #release (xs:List<Symbol>) : do(#release, xs)
;   defn #release (x:Ref) : #release(name(x))
;
;   ;====== Algorithm ======
;   defn #mark-loaded (y:Ref) :
;      loaded[name(y)] = true
;      num-reg = num-reg + 1
;
;   defn #mark-unloaded (y:Symbol) :
;      loaded[y] = false
;      num-reg = num-reg - 1
;      
;   defn #release (x:Symbol) :
;      #mark-unloaded(x) when #loaded?(x)         
;
;   defn #release-all () :
;      clear(loaded)
;      num-reg = 0
;         
;   #mark-loaded(filter(#load-in?, live-in(b), load-in(b)))
;   for i in 0 through length(exps) do :
;   
;      ;Basic Operations
;      defn #load (ys:Streamable<Ref>) :
;         do(#load, ys)
;      
;      defn #time-to-use (v:Symbol) :
;         lookup!(times[i], v)
;         
;      defn #spill () :
;         val v = maximum-by-key(#loaded(), #time-to-use)
;         #emit(Save(Var(v)))
;         #mark-unloaded(v)
;         
;      defn #load (y:Ref) :
;         if not #loaded?(y) :
;            #alloc(1)
;            #emit(Load(y))
;            #mark-loaded(y)
;
;      defn #alloc (n:Int) :
;         while num-reg + n > N :
;            #spill()
;
;      #alloc(0)
;      if i < length(exps) :
;      
;         ;For each operation
;         ;1. Load arguments when necessary
;         ;2. Release all registers that are no longer live.
;         ;3. Allocate space for all defined registers.
;         ;4. Emit the operation
;         ;5. Mark the defined registers as now live.
;
;         match(exps[i]) :
;            (e:GetArgs) :
;               #release(releases[i])
;               #emit(e)
;               #mark-loaded(filter(#reg?, xs(e), locs(e)))
;            (e:SetArgs) :
;               #release(releases[i])
;               #emit(e)
;            (e:Set) :
;               #load(y(e))
;               #release(releases[i])
;               #alloc(1)
;               #emit(e)
;               #mark-loaded(x(e))
;            (e:Op) :
;               #load(ys(e))
;               #release(releases[i])
;               #alloc(length(xs(e)))
;               #emit(e)
;               #mark-loaded(xs(e))
;            (e:Call) :
;               #release-all()
;               #emit(e)
;            (e:Save) :
;               #release(releases[i])
;               #emit(e)
;            (e:Load) :
;               #release(releases[i])
;               #load(x(e))
;
;   println("For block ~:" << [name(b)])
;   do(println, exp-list)
;
;
;;====== Save Elimination ======
;defstruct NotSaved
;defstruct Saved
;defstruct Floating
;
;defn assumption-propagation (b:LBlock) :
;   defn get-assumptions (es:List<Exp>, assume:Vector<Exp>) -> List<Exp> :
;      match(e) :
;         (e:GetArgs) :
;            for (x in xs(e), l in locs(e)) do :
;               match(l) :
;                  (l:Dead) :
;                     false
;                  (l:Stack) :
;                     #mark-saved(x, true)
;                     #mark-loaded(x, false)
;                  (l:Reg) :
;                     #mark-saved(x, false)
;                     #mark-loaded(x, true)
;            List(e, get-assumptions(rest, assume))
;         (e:SetArgs) :
;            List(e, get-assumptions(rest, assume))
;         (e:Set) :
;            #mark-loaded(x(e), true)
;            #mark-saved(x(e), false)
;            List(e, get-assumptions(rest, assume))
;         (e:Op) :           
;            #mark-loaded(xs(e), true)
;            #mark-saved(xs(e), false)
;            List(e, get-assumptions(rest, assume))
;         (e:Call) :
;            #mark-loaded(live(e), false)
;            List(e, get-assumptions(rest, assume))
;         (e:Save) :
;            match(#saved?(x(e))) :
;               (s:True) :
;                  get-assumptions(rest, assume)
;               (s:False) :
;                  #mark-saved(x(e), true)
;                  List(e, get-assumptions(rest, assume))
;               (s:Any) :
;                  add(assume, e)
;                  get-assumptions(rest, assume)
;         (e:Load) :
;            match(#loaded?(x(e))) :
;               (l:True) :
;                  get-assumptions(rest, assume)
;               (l:False) :
;                  #mark-loaded(x(e), true)
;                  List(e, get-assumptions(rest, assume))
;               (l:Any) :
;                  add(assume, e)
;                  get-assumptions(rest, assume)
;
;   defn compute-assumptions (xs:List<Symbol>, assume:Vector<Exp>) :
;      val loaded = HashTable<Symbol,True|False>(symbol-hash)
;      val saved = HashTable<Symbol,True|False>(symbol-hash)
;      for e in assume do :
;         match(e) :
;            (e:Save) : saved[name(x(e))] = true
;            (e:Load) : loaded[name(x(e))] = true
;      val save-in = for x in xs map : get?(saved, x, false)
;      val load-in = for x in xs map : get?(loaded, x, false)
;      [save-in, load-in]
;
;   val assumptions = Vector<Exp>()
;   val exps* = get-assumptions(exps(b), assumptions)
;   val [save-in, load-in] = compute-assumptions(live-in(b), assumptions)
;   val save-out = for x in live-out(b) map : #saved(x) typeof True
;   val 
;
;
;   for e in exps(b) do :
;      match(e) :
;         (e:GetArgs) : asdf
;         (e:Save) :
;            #save(x(e))
;            #emit-rest()
;         (e:SetArgs) :
;            #emit(e)
;            #emit-rest()
;         (e:Set) :
;            #emit(e)
;            #mark-saved(x(e), false)
;            #emit-rest()
;         (e:Op) :
;            #emit(e)
;            #mark-saved(xs(e), false)
;            #emit-rest()
;         (e:Call) :
;            #emit(e)            
;            ???
;            #emit-rest()
;         (e:Load) :
;            #mark-saved(x(e), false)
;            
;
;
;         (e:SetArgs) :
;            #emit(e)
;         (e:Set) :
;            #emit(e)
;            mark-not-saved(x(e))
;         (e:Op) : mark-not-saved(xs(e))
;         (e:Call) : mark-all-not-saved()
;         (e:Load) : mark-not-saved(x(e))
;
;
;   defn elide (es:List<Exp>) -> List<Exp> :
;      if empty?(es) :
;         es
;      else :
;         match(head(es)) :
;            (e:GetArgs)
;            (e:Save) : save(x(e))
;            (e:SetArgs) : false
;            (e:Set) : mark-not-saved(x(e))
;            (e:Op) : mark-not-saved(xs(e))
;            (e:Call) : mark-all-not-saved()
;            (e:Load) : mark-not-saved(x(e))
;   
;   for e in exps(b) do :
;      ;For each operation
;      ;1. If it is a save, check whether:
;      ;   i. The value is floating: Mark the value as saved
;      ;   ii. The value is saved already: Elide the save
;      ;   iii. The value is not saved: Keep the save
         




;;========== Spill Registers =============
;defn spill-registers (b:LBlock, N:Int) :
;   val last-uses = compute-last-use(b)
;   val next-uses = compute-uses(b)
;
;   ;Kill and Birth
;   var n:Int = 0
;   val live = HashTable<Symbol,True|False>(symbol-hash)
;   defn kill (x:Ref) :
;      if live[name(x)] :
;         live[name(x)] = false
;         n = n - 1
;   defn birth (x:Ref) :
;      if get?(live, name(x), false) :
;         live[name(x)] = true
;         n = n + 1
;
;   ;Spilling and Loading
;   val accum = Vector<Exp>()
;   defn spill (x:Ref) :
;      add(accum, Save(x))
;      kill(x)
;   defn load (x:Ref) :
;      add(accum, Load(x))
;      birth(x)
;
;   defn spill (es:List<Exp>) :
;      for (e in es, killed in last-uses, uses in next-uses) do :
;         ;Marking and Ensuring Live
;         defn reserve-reg () :
;            if n >= N :
;               val uses* = reverse(find-next-uses(uses))
;               val v = for v in uses* find :
;                  get?(live, v, false)
;               spill(Var(v as Symbol))
;         defn mark-live (x:Ref) :
;            reserve-reg()
;            birth(x)
;         defn ensure-live (x:Ref) :
;            if not live[name(x)] :
;               reserve-reg()
;               load(x)
;
;         match(e) :
;            (e:Args) :
;               do(mark-live{Var(_)}, xs(e))
;               add(accum, e)
;            (e:Set) :
;               ensure-live(y(e))
;               do(kill, killed)
;               mark-live(x(e))
;               add(accum, e)
;            (e:Op) :
;               do(ensure-live, ys(e))
;               do(kill, killed)
;               do(mark-live, xs(e))
;               add(accum, e)
;;            (e:Do) :
;;               do(
;;
;;
;;               do(mark-use, ys(e)) ;;asdfasdf
;            (e:Save) :
;               kill(x(e))
;               add(accum, e)
;            (e:Load) :
;               mark-live(x(e))
;               add(accum, e)
;
;
;defn compute-last-use (p:Program) :
;   for b in blocks(p) as List<LBlock> do :
;      println("Block ~:" << [name(b)])
;      val lu = compute-last-use(b)
;      val us = compute-uses(b)
;      for (e in exps(b), u in lu, us in us) do :
;         if empty?(u): println("   ~ USES(~@)" << [e, cms(us)])
;         else : println("   ~  KILLED(~@) USES(~@)" << [e, cms(u), cms(us)])




;========= Driver ======================
defn test (p:Program) :
   println("====== Test ======")
   println(p)
   println("====== Working Form ======")
   val p1 = working-form(p)
   println(p1)
   println("====== Liveness Analysis ======")
   val p2 = liveness-analysis(p1)
   println(p2)
   println("====== Usage Table ======")
   compute-usage-table(p2)
;   println("====== Emit Save/Load ======")
;   val p3 = emit-save-load(p2)
;   println(p3)
;   println("====== Release/Time to Use ======")
;   for b in blocks(p3) as List<LBlock> do :      
;      val rs = compute-release(b)
;      val ts = compute-time-to-use(b)
;      for (e in exps(b), i in 0 to false) do :
;         println("~: ~, release ~@, time ~@" << [i, e, cms(rs[i]), cms(ts[i])])
;   println("====== Finite Allocation ======")
;   for b in blocks(p3) as List<LBlock> do :
;      finite-allocation(b)
   println("==================\n\n\n")

defn main () :
   val filename = commandline-arguments()[1]
   val progs = parse-regir(filename)   
   do(test, progs)

main()