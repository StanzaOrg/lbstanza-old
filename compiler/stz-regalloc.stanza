#include<"core/stringeater.stanza">
#include<"compiler/stz-algorithms.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">

defpackage regalloc :
   import core
   import verse
   import stz/lexer
   import stz/parser
   import stz/algorithms

;=============================================
;============== Input IR =====================
;=============================================
defstruct Var :
   name: Symbol
   loc: Loc

definterface Type
defstruct ByteType <: Type
defstruct IntType <: Type
defstruct LongType <: Type
defstruct RefType <: Type
defstruct FloatType <: Type
defstruct DoubleType <: Type

definterface Loc
defstruct NoLoc <: Loc
defstruct Reg <: Loc :
   n: Int
defstruct Stack <: Loc :
   n: Int

definterface Exp
defstruct Args <: Exp :
   xs: List<Var>
defstruct Set <: Exp :
   x: Var
   y: Var
defstruct Op <: Exp :
   xs: List<Var>
   ys: List<Var>
defstruct Do <: Exp :
   f: False|Var
   xs: List<Var>
   ys: List<Var>
defstruct Goto <: Exp :
   name: Symbol

definterface Block
defmulti name (b:Block) -> Symbol
defmulti exps (b:Block) -> List<Exp>
defmulti next (b:Block) -> List<Symbol>

defstruct SBlock <: Block :
   name: Symbol with : (as-method => true)
   exps: List<Exp> with : (as-method => true)
   next: List<Symbol> with : (as-method => true)
with :
   constructor => Block

defstruct Def :
   name: Symbol
   type: Type
   sloc: Loc

defstruct Unit :
   defs: List<Def>
   blocks: List<Block>

;============================================================
;===================== Parser ===============================
;============================================================
defsyntax regir :
   val ut = unwrap-token

   defrule :
      sym = (?x) when ut(x) typeof Symbol : ut(x)
      int = (?x) when ut(x) typeof Int : ut(x)

      loc = (Reg(?n:#int)) : Reg(n)
      loc = (Stack(?n:#int)) : Stack(n)
      var = (?x:#sym) : Var(x, NoLoc())

      exp = ((?xs:#var ...) = Args) :
         Args(xs)
      exp = (?x:#var = ?y:#var) :
         Set(x, y)
      exp = ((?xs:#var ...) = op(?ys:#var ...)) :
         Op(xs, ys)
      exp = ((?xs:#var ...) = f(?ys:#var ...)) :
         Do(false, xs, ys)
      exp = ((?xs:#var ...) = [?f:#var](?ys:#var ...)) :
         Do(f, xs, ys)

      block = (block ?name:#sym :
                  ?es:#exp ...
                  goto (?ns:#sym ...)) :
         Block(name, es, ns)

      type = (byte) : ByteType()
      type = (int) : IntType()
      type = (long) : LongType()
      type = (ref) : RefType()
      type = (float) : FloatType()
      type = (double) : DoubleType()
      def = (def ?x:#sym : ?t:#type at ?l:#loc) : Def(x, t, l)
      def = (def ?x:#sym : ?t:#type) : Def(x, t, NoLoc())

      unit = (unit : (?ds:#def ... ?bs:#block ...)) :
         Unit(ds, bs)

defn parse-regir (filename:String) -> List<Unit> :
   val lexed = lex-file(filename)
   with-syntax(regir) :
      match-syntax(lexed) :
         (?us:#unit ...) : us

;============================================================
;==================== Printing ==============================
;============================================================
defn cms (xs) : join(xs, ", ")

defmethod print (o:OutputStream, p:Unit) :
   print(o, "unit : ")
   for d in defs(p) do :
      print(o, "\n   ~" << [d])
   for b in blocks(p) do :
      print(o, "\n   ~" << [b])

defmethod print (o:OutputStream, d:Def) :
   print(o, "def ~:~ at ~" << [
      name(d),
      type(d),
      sloc(d)])

defmethod print (o:OutputStream, b:SBlock) :
   print(o, "block ~ :" << [name(b)])
   for e in exps(b) do :
      print(o, "\n      ~" << [e])
   print(o, "\n      goto (~@)" << [cms(next(b))])

defmethod print (o:OutputStream, t:Type) :
   print{o, _} $ match(t) :
      (t:ByteType) : "byte"
      (t:IntType) : "int"
      (t:LongType) : "long"
      (t:RefType) : "ref"
      (t:FloatType) : "float"
      (t:DoubleType) : "double"

defmethod print (o:OutputStream, l:Loc) :
   print{o, _} $ match(l) :
      (l:NoLoc) : "NoLoc"
      (l:Reg) : "Reg(~)" << [n(l)]
      (l:Stack) : "Stack(~)" << [n(l)]

defmethod print (o:OutputStream, v:Var) :
   match(loc(v)) :
      (l:NoLoc) : print(o, name(v))
      (l) : print(o, "~:~" << [name(v), l])

defmethod print (o:OutputStream, e:Exp) :
   print{o, _} $ match(e) :
      (e:Args) : "(~@) = Args" << [cms(xs(e))]
      (e:Set) : "~ = ~" << [x(e), y(e)]
      (e:Op) : "(~@) = op(~@)" << [cms(xs(e)), cms(ys(e))]
      (e:Do) :
         match(f(e)) :
            (f:False) : "(~@) = f(~@)" << [cms(xs(e)), cms(ys(e))]
            (f:Var) : "(~@) = [~](~@)" << [f, cms(xs(e)), cms(ys(e))]
      (e:Goto) : "goto ~" << [name(e)]

;============================================================
;==================== Working IR ============================
;============================================================

definterface Working

defstruct WArgs <: Exp&Working :
   xs: List<Port>

defstruct WDo <: Exp&Working :
   f: False|Var
   xs: List<Port>
   ys: List<Var>

defstruct Save <: Exp&Working :
   x: Var
   
defstruct Load <: Exp&Working :
   x: Var

defstruct Unload <: Exp&Working :
   x: Var

defmethod print (o:OutputStream, e:Exp&Working) :
   print{o, _} $ match(e) :
      (e:WArgs) : "(~@) = Args" << [cms(xs(e))]
      (e:WDo) : 
         match(f(e)) :
            (f:False) : "(~@) = f(~@)" << [cms(xs(e)), cms(ys(e))]
            (f:Var) : "(~@) = [~](~@)" << [f, cms(xs(e)), cms(ys(e))]
      (e:Save) : "save ~" << [x(e)]
      (e:Load) : "load ~" << [x(e)]
      (e:Unload) : "unload ~" << [x(e)]

defstruct Any
defmethod print (o:OutputStream, x:Any) :
   print(o, "any")

defstruct WBlock <: Block :
   name: Symbol with : (as-method => true)
   exps: List<Exp> with : (as-method => true)
   next: List<Symbol> with : (as-method => true)
   in: List<LivePort>
   out: List<LivePort>
   dist: List<Int>

definterface Port
defstruct LivePort <: Port :
   name: Symbol
   saved?: True|False|Any
   loaded?: True|False|Any
   loc: Loc
defstruct DeadPort <: Port

defmethod print (o:OutputStream, p:Port) :
   print{o, _} $ match(p) :
      (p:LivePort) : "~ (s:~, l:~, at:~)" << [name(p), saved?(p), loaded?(p), loc(p)]
      (p:DeadPort) : "dead"

defmethod print (o:OutputStream, b:WBlock) :
   print(o, "block ~ :" << [name(b)])
   print(o, "\n      in: ~@" << [cms(in(b))])
   for e in exps(b) do :
      print(o, "\n      ~" << [e])
   print(o, "\n      goto (~@)" << [cms(next(b))])
   print(o, "\n      out: ~@" << [cms(out(b))])
   print(o, "\n      dist: ~@" << [cms(dist(b))])

;============================================================
;================== Block Liveness ==========================
;============================================================

defn liveness-analysis (u:Unit) :
   defn assoc-blocks (u:Unit, bs:List<Block>) : Unit(defs(u), bs)
   defn bhash ([b,x]:[Symbol,Symbol]) : 7 * symbol-hash(b) + symbol-hash(x)
   val defs = HashTable<[Symbol,Symbol],True>(bhash)
   val ins = HashTable<[Symbol,Symbol],False|Int>(bhash)

   ;Find all immediate defs and live-ins
   do(find-defs-uses, blocks(u)) where :
      defn find-defs-uses (b:Block) :
         defn key (x:Var) : [name(b), name(x)]
         defn #def (x:Var) :
            defs[key(x)] = true
            ins[key(x)] = false
         defn #use (x:Var, i:Int) : ins[key(x)] = i
         defn #use (x:False, i:Int) : false
         defn #def (xs:List<Var>) : do(#def, xs)
         defn #use (xs:List<Var>, i:Int) : do(#use{_, i}, xs)
         
         val n = length(exps(b))
         for (e in reverse(exps(b)), i in (n - 1) through 0 by -1) do :
            match(e) :
               (e:Op) : (#def(xs(e)), #use(ys(e), i))
               (e:Do) : (#def(xs(e)), #use(f(e), i), #use(ys(e), i))
               (e:Args) : (#def(xs(e)))
               (e) : error("Block liveness must be updated to handle other constructs.")

   ;Find all block predecessors and block lengths
   val preds = HashTable<Symbol,List<Symbol>>(symbol-hash)
   val lengths = HashTable<Symbol,Int>(symbol-hash)
   for b in blocks(u) do :
      preds[name(b)] = List()
      lengths[name(b)] = length(exps(b))
   for b in blocks(u) do :
      for n in next(b) do :
         preds[n] = List(name(b), preds[n])

   ;Iterate through a table of live vars
   defn do-for-live (f: [Symbol,Symbol,Int] -> False,
                     es: HashTable<[Symbol,Symbol],False|Int>) :
      for entry in es do :
         if value(entry) != false :
            val [b,x] = key(entry)
            f([b, x, value(entry) as Int])

   ;Propagate block liveness results
   val outs = HashTable<[Symbol,Symbol],Int>(bhash)
   fixpoint $ fn (progress) :
      defn add-live (live:HashTable<[Symbol,Symbol],False|Int>,
                     b:Symbol, x:Symbol, d:Int) :
         match(get?(live, [b,x], false)) :
            (d2:Int) :
               if d < d2 :
                  live[[b,x]] = d
                  progress()
            (d2:False) :
               live[[b,x]] = d
               progress()

      for [b,x,d] in ins do-for-live :
         for p in preds[b] do : add-live(outs, p, x, d)
      for [b,x,d] in outs do-for-live :
         if not key?(defs, [b,x]) :
            add-live(ins, b, x, d + lengths[b])

   ;Create results table
   defn to-port (x:Symbol) : LivePort(x, Any(), Any(), NoLoc())
   val in-lists = HashTable<Symbol,List<Symbol>>(symbol-hash)
   val out-lists = HashTable<Symbol,List<Symbol>>(symbol-hash)
   val dist-lists = HashTable<Symbol,List<Int>>(symbol-hash)
   for [b,x,d] in ins do-for-live :
      in-lists[b] = List(x, get?(in-lists, b, List()))
   for [b,x,d] in outs do-for-live :
      out-lists[b] = List(x, get?(out-lists, b, List()))
      dist-lists[b] = List(d, get?(dist-lists, b, List()))
      
   assoc-blocks{u, _} $
      for b in blocks(u) map :
         WBlock(name(b),
                exps(b),
                next(b),
                map(to-port, get?(in-lists, name(b), List()))
                map(to-port, get?(out-lists, name(b), List()))
                get?(dist-lists, name(b), List()))


;============================================================
;==================== Save Emission =========================
;============================================================

defn save-semantics (b:WBlock) :
   ;State of the future
   val requires-saved = HashTable<Symbol,True|False>(symbol-hash)
   val is-live = HashTable<Symbol,True|False>(symbol-hash)
   val prefer-loaded = HashTable<Symbol,True|False>(symbol-hash)

   ;Output
   val exp-list = Vector<Exp>()

   ;Initialize state
   for x in out(b) do :
      is-live[name(x)] = true
      prefer-loaded[name(x)] = true
      requires-saved[name(x)] = false

   ;Summarize current variable statistics as port
   defn as-port (x:Symbol) :
      val lv = get?(is-live, x, false)
      val sv = get?(requires-saved, x, false)
      val ld = get?(prefer-loaded, x, true)
      match(lv, sv, ld) :
         (lv:False, sv, ld) : DeadPort()
         (lv:True, sv:False, ld:False) : LivePort(x, Any(), false, NoLoc())
         (lv:True, sv:False, ld:True) : LivePort(x, Any(), Any(), NoLoc())
         (lv:True, sv:True, ld:False) : LivePort(x, true, false, NoLoc())
         (lv:True, sv:True, ld:True) : LivePort(x, true, Any(), NoLoc())

   defn as-port (x:Var) :
      as-port(name(x))

   ;Insert saves to expressions
   for e in reverse(exps(b)) do :

      defn defd (x:Var) :
         is-live[name(x)] = false
         requires-saved[name(x)] = false
         prefer-loaded[name(x)] = false

      defn used (x:Var) :
         is-live[name(x)] = true
         prefer-loaded[name(x)] = true

      defn lived (x:Symbol) :
         requires-saved[x] = true
         prefer-loaded[x] = false

      defn currently-live () :
         stream(key, filter(value, is-live))
         
      match(e) :
         (e:Op) :
            for x in xs(e) do :
               if get?(requires-saved, name(x), false) :
                  add(exp-list, Save(x))
            add(exp-list, e)
            do(defd, xs(e))
            do(used, ys(e))
            
         (e:Do) :
            val xp = map(as-port, xs(e))
            add(exp-list, WDo(f(e), xp, ys(e)))
            do(defd, xs(e))
            do(lived, currently-live())
            do(used, ys(e))
            used(f(e) as Var) when f(e) != false
            
         (e:Args) :
            val xp = map(as-port, xs(e))
            add(exp-list, WArgs(xp))
            do(defd, xs(e))

         (e) :
            error("Save semantics: Handle other constructs.")

   val in* = for x in in(b) map :
      as-port(name(x)) as LivePort

   ;Return results
   defn in-reverse<?T> (xs:Vector<?T>) :
      for i in (length(xs) - 1) through 0 by -1 stream :
         xs[i]
   
   WBlock(name(b),
          to-list(in-reverse(exp-list)),
          next(b),
          in*,
          out(b),
          dist(b))
          
;============================================================
;==================== Usage Table ===========================
;============================================================

defclass UsageTable <: Gettable<Pos,List<KeyValue<Symbol,Int>>>

defstruct Pos :
   index: Int
   mid?: True|False

defn less-eq? (a:Pos, b:Pos) :
   if index(a) < index(b) :
      true
   else if index(a) == index(b) :
      match(mid?(a)) :
         (x:False) : true
         (x:True) : mid?(b)

defmethod print (o:OutputStream, p:Pos) :
   print(o, "~~" << [
      index(p),
      ".5" when mid?(p) else ""])

defn hash (p:Pos) :
   match(mid?(p)) :
      (m:True) : index(p) * 2 + 1
      (m:False) : index(p) * 2

defn usage-table (b:WBlock) :
   val dsts = HashTable<Symbol,False|Int>(symbol-hash)
   val n = length(exps(b))
   val len = hash(Pos(n, false)) + 1
   val uses = Array<List<KeyValue<Symbol,Int>>>(len, List())

   defn set-dist (x:Symbol, i:False|Int) :
      dsts[x] = i
   defn set-dist (x:Var, i:False|Int) :
      set-dist(name(x), i)
   defn set-dist (x:Port, i:False|Int) :
      match(x) :
         (x:LivePort) : set-dist(name(x), i)
         (x) : false
   defn set-dist (x:False, i:False|Int) :
      false
   defn set-dist (xs:List<Symbol>, i:False|Int) :
      do(set-dist{_, i}, xs)   
   defn set-dist (xs:List<Var>, i:False|Int) :
      do(set-dist{_, i}, xs)
   defn set-dist (xs:List<Port>, i:False|Int) :
      do(set-dist{_, i}, xs)

   defn set-uses (p:Pos, us:List<KeyValue<Symbol,Int>>) :
      uses[hash(p)] = us
      
   defn current-uses (i:Int) :
      var es = for e in dsts stream :
         match(value(e)) :
            (v:Int) : key(e) => v - i
            (v:False) : false
      es = for e in es filter :
         e != false
      to-list(es) as List<KeyValue<Symbol,Int>>

   do(set-dist{_, _ + n}, out(b), dist(b))
   set-uses(Pos(n,false), current-uses(n))
   for (e in reverse(exps(b)), i in (n - 1) through 0 by -1) do :
      match(e) :
         (e:Op) :
            set-dist(xs(e), false)
            set-uses(Pos(i,true), current-uses(i))
            set-dist(ys(e), i)
            set-uses(Pos(i,false), current-uses(i))
         (e:Save) :
            set-uses(Pos(i,true), current-uses(i))
            set-uses(Pos(i,false), current-uses(i))
         (e:Load) :
            set-dist(x(e), false)
            set-uses(Pos(i,true), current-uses(i))
            set-uses(Pos(i,false), current-uses(i))
         (e:WDo) :
            set-dist(xs(e), false)
            set-uses(Pos(i,true), current-uses(i))
            set-dist(ys(e), i)
            set-dist(f(e), i)
            set-uses(Pos(i,false), current-uses(i))
         (e:WArgs) :
            set-dist(xs(e), false)
            set-uses(Pos(i,true), current-uses(i))
            set-uses(Pos(i,false), current-uses(i))
         (e) :
            error("Usage Table: Handle other constructs")

   new UsageTable :
      defmethod get (this, p:Pos) :
         uses[hash(p)]
      defmethod print (o:OutputStream, this) :
         for i in 0 to n do :
            if i > 0 : print(o, "\n")
            print(o, "~ => (~@)" << [
               Pos(i, false), cms(this[Pos(i, false)])])
            print(o, "\n~ => (~@)" << [
               Pos(i, true), cms(this[Pos(i, true)])])
         print(o, "\n~ => (~@)" << [
            Pos(n, false), cms(this[Pos(n, false)])])


;============================================================
;================== Release Table ===========================
;============================================================

defn release-table (b:WBlock) -> Array<KeyValue<Pos,Symbol>> :
   val live-table = HashTable<Symbol,True|False>(symbol-hash)
   val release-list = Vector<KeyValue<Pos,Symbol>>()

   ;Utilities
   defn clear-live () :
      clear(live-table)
   defn mark-live (x:Symbol, v:True|False) :
      live-table[x] = v
   defn mark-live (x:Var, v:True|False) :
      mark-live(name(x), v)
   defn mark-live (x:Port, v:True|False) :
      match(x) :
         (x:LivePort) : mark-live(name(x), v)
         (x) : false
   defn mark-live (x:False, v:True|False) :
      false
   defn mark-live (xs:List<Var|Port>, v:True|False) :
      do(mark-live{_, v}, xs)
      
   defn release-if-not-live (p:Pos, x:Symbol) :
      if not get?(live-table, x, false) :
         add(release-list, p => x)
   defn release-if-not-live (p:Pos, x:Var) :
      release-if-not-live(p, name(x))
   defn release-if-not-live (p:Pos, x:False) :
      false
   defn release-if-not-live (p:Pos, x:Port) :
      match(x) :
         (x:LivePort) : release-if-not-live(p, name(x))
         (x) : false
   defn release-if-not-live (p:Pos, xs:List<Var|Port>) :
      do(release-if-not-live{p, _}, xs)

   ;Initialize live-out as live
   mark-live(out(b), true)
      
   ;Analyze expression list
   val num-exps = length(exps(b))
   for (e in reverse(exps(b)), i in (num-exps - 1) through 0 by -1) do :
      match(e) :
         (e:Op) :
            release-if-not-live(Pos(i + 1, false), xs(e))
            mark-live(xs(e), false)
            release-if-not-live(Pos(i, true), ys(e))
            mark-live(ys(e), true)
         (e:Save) :
            release-if-not-live(Pos(i, true), x(e))
            mark-live(x(e), true)
         (e:Load) :
            release-if-not-live(Pos(i + 1, false), x(e))
            mark-live(x(e), false)
         (e:WArgs) :
            release-if-not-live(Pos(i + 1, false), xs(e))
            mark-live(xs(e), false)
         (e:WDo) :
            release-if-not-live(Pos(i + 1, false), xs(e))
            clear-live()
            release-if-not-live(Pos(i, true), f(e))
            release-if-not-live(Pos(i, true), ys(e))
            mark-live(f(e), true)
            mark-live(ys(e), true)
         (e) :
            error("Release Table: Handle other constructs")

   ;Return reversed array
   val n = length(release-list)
   val release-array = Array<KeyValue<Pos,Symbol>>(n)
   for (r in release-list, i in 0 to false) do :
      release-array[n - 1 - i] = r
   release-array   


;============================================================
;=================== Class Allocation =======================
;============================================================

;Make a Var just from its name
defn Var (x:Symbol) -> Var :
   Var(x, NoLoc())

defn class-allocation (b:WBlock) :
   ;The resulting expression list
   val exp-list = Vector<Exp>()
   defn emit (e:Exp) :
      add(exp-list, e)

   ;Tracks the number of free registers
   var num-free-reg = 8

   ;Spill function
   var spill-next: () -> ? = error{"No Spill function."}

   ;Save/Load Status
   val saved = HashTable<Symbol,True|False|Any|None>(symbol-hash)
   val loaded = HashTable<Symbol,True|False|Any|None>(symbol-hash)

   defn save (x:Symbol) :
      match(get?(saved, x, None())) :
         (s:True) : false
         (s:False) : emit(Save(Var(x)))
         (s:Any) : emit(Save(Var(x)))
         (s:None) : error("~ not live." % [x])
      saved[x] = true

   defn load (x:Symbol) :
      match(get?(loaded, x, None())) :
         (l:True) :
            false
         (l:False) :
            spill-next() when num-free-reg <= 0
            emit(Load(Var(x)))
            num-free-reg = num-free-reg - 1
         (l:Any) :
            emit(Load(Var(x)))
         (l:None) :
            error("~ not live." % [x])
      loaded[x] = true

   defn unload (x:Symbol) :
      match(get?(loaded, x, None())) :
         (l:True) :
            emit(Unload(Var(x)))
            num-free-reg = num-free-reg + 1
         (l:False) :
            false
         (l:Any) :
            emit(Unload(Var(x)))
            num-free-reg = num-free-reg + 1
         (l:None) :
            error("~ is not live." % [x])
      loaded[x] = false

   defn die (x:Symbol) :
      match(get?(loaded, x, None())) :
         (l:True) : num-free-reg = num-free-reg + 1
         (l:False) : false
         (l:Any) : error("~ should not be loaded." % [x])
         (l:None) : error("~ is not live." % [x])
      loaded[x] = None()

   defn def (x:Var) :
      match(get?(loaded, name(x), None())) :
         (l:True) : error("~ has not been released." % [name(x)])
         (l:False) : num-free-reg = num-free-reg - 1
         (l:Any) : error("~ has not been released." % [name(x)])
         (l:None) : num-free-reg = num-free-reg - 1
      loaded[name(x)] = true
      saved[name(x)] = false

   defn def (x:Port) :
      match(x) :
         (x:LivePort) :
            if get?(loaded, name(x), None()) not-typeof None :
               error("~ should not be live." % [name(x)])
            match(loaded?(x)) :
               (l:True) : error("~ cannot be loaded." % [name(x)])
               (l:False) :
                  loaded[name(x)] = false
               (l:Any) :
                  loaded[name(x)] = Any()
                  num-free-reg = num-free-reg - 1
            match(saved?(x)) :
               (l:True) : saved[name(x)] = true
               (l:Any) : saved[name(x)] = Any()
               (l:False) : error("~ cannot be not saved." % [name(x)])
         (x:DeadPort) :
            false

   ;Spilling Calculations
   val ut = usage-table(b)
   val use-cache = HashTable<Symbol,Int>(symbol-hash)
   val spill-cache = Vector<Symbol>()
   defn spill-at (p:Pos, f: () -> ?) :
      var cached = false
      defn spill () :
         if not cached :
            ;Reload the use cache
            clear(use-cache)
            for use in ut[p] do :
               use-cache[key(use)] = value(use)
            ;Reload the spill cache
            clear(spill-cache)
            for e in loaded do :
               add(spill-cache, key(e)) when value(e) typeof True|Any
            sort-by-key!(spill-cache, {use-cache[_]})
            ;Mark as cached
            cached = true
         
         val x = pop(spill-cache)
         save(x)
         unload(x)         
      let-var spill-next = spill :
         f()
         
   ;Tracks the release of variables
   val rt = release-table(b)
   var release-n = 0
   defn* release-up-to (p:Pos) :
      if release-n < length(rt) :
         val r = rt[release-n]
         if key(r) <= p :
            die(value(r))
            release-n = release-n + 1
            release-up-to(p)

   ;Ensure variable's xs are loaded for position p
   defn ensure-loaded (p:Pos, xs:List<Var>) :
      spill-at{p, _} $ fn () :
         do(load{name(_)}, xs)

   ;Ensure enough registers are free for defining xs at position p
   defn defined (p:Pos, xs:List<Var>) :
      spill-at{p, _} $ fn () :
         while num-free-reg < length(xs) :
            spill-next()
      do(def, xs)      

   ;Reserve registers for as many live-in variables as possible
   defn defined (p:Pos, xs:List<Port>) :
      do(def, xs)
      spill-at{p, _} $ fn () :
         while num-free-reg < 0 :
            spill-next()
         
   ;Allocate location classes for expressions
   defn allocate () :
      for (e in exps(b), i in 0 to false) do :
         release-up-to(Pos(i,false))
         match(e) :
            (e:Op) :
               ensure-loaded(Pos(i,false), ys(e))
               release-up-to(Pos(i,true))
               defined(Pos(i,true),xs(e))
               emit(e)
            (e:Save) :
               save(name(x(e)))
            (e:Load) :
               error("Unreachable")
            (e:WArgs) :
               emit(e)
               defined(Pos(i + 1, false), xs(e))
            (e:WDo) :
               emit(e)
               for e in loaded do :
                  if value(e) typeof True|Any :
                     error("~ should have been released." % [key(e)])
               defined(Pos(i + 1, false), xs(e))
            (e) :
               error("Class Allocation: Handle other constructs.")

   ;Driver
   defined(Pos(0,false), in(b))
   allocate()
   WBlock(name(b), to-list(exp-list), next(b),
          in(b), out(b), dist(b))


;============================================================
;================ Assumption Propagation ====================
;============================================================

defn propagate-assumptions (b:WBlock) :
   ;Utilities
   defn mark-port (x:Port,
                   saved:HashTable<Symbol,True|False>,
                   loaded:HashTable<Symbol,True|False>) :
      match(x) :
         (x:LivePort) :
            if loaded?(x) not-typeof Any :
               loaded[name(x)] = loaded?(x) as True|False
            if saved?(x) not-typeof Any :
               saved[name(x)] = saved?(x) as True|False
         (x:DeadPort) : false

   defn read-port (x:Port,
                   saved:HashTable<Symbol,True|False>,
                   loaded:HashTable<Symbol,True|False>) :
      match(x) :
         (x:LivePort) :
            LivePort(name(x),
                     get?(saved, name(x), Any())
                     get?(loaded, name(x), Any())
                     loc(x))
         (x:DeadPort) :
            x

   ;Save/Load Status
   val saved = HashTable<Symbol,True|False>(symbol-hash)
   val loaded = HashTable<Symbol,True|False>(symbol-hash)

   ;Output Expression List
   val exp-list = Vector<Exp>()
   defn emit (e:Exp) :
      add(exp-list, e)
   
   defn propagate<?T> (ports:List<Port>, es:List<Exp>,
                       return:List<Port> -> ?T) -> T :
      ;Port status               
      val port-saved = HashTable<Symbol,True|False>(symbol-hash)
      val port-loaded = HashTable<Symbol,True|False>(symbol-hash)
      defn save (x:Var) :
         if key?(port-saved, name(x)) : emit(Save(x))            
         else : port-saved[name(x)] = true
         saved[name(x)] = true   
      defn load (x:Var) :
         if key?(port-loaded, name(x)) : emit(Load(x))            
         else : port-loaded[name(x)] = true
         loaded[name(x)] = true   
      defn unload (x:Var) :
         if not key?(port-loaded, name(x)) :
            port-loaded[name(x)] = false
         loaded[name(x)] = false   
      defn defined (x:Var) :
         saved[name(x)] = false
         loaded[name(x)] = true
               
      ;Initialize Ports
      for x in ports do :
         mark-port(x, saved, loaded)
         mark-port(x, port-saved, port-loaded)         

      ;Propagate
      defn* loop (es:List<Exp>) :
         if not empty?(es) :
            match(head(es)) :
               (e:Op) :
                  emit(e)
                  do(defined,xs(e))
                  loop(tail(es))
               (e:Save) :
                  save(x(e))
                  loop(tail(es))               
               (e:Load) :
                  load(x(e))
                  loop(tail(es))
               (e:Unload) :
                  unload(x(e))
                  loop(tail(es))
               (e:WArgs) :
                  val i = length(exp-list)
                  emit(e)
                  propagate{xs(e), tail(es), _} $ fn* (xs*) :
                     exp-list[i] = WArgs(xs*)
               (e:WDo) :
                  val i = length(exp-list)
                  emit(e)
                  clear(loaded)
                  propagate{xs(e), tail(es), _} $ fn* (xs*) :
                     exp-list[i] = WDo(f(e), xs*, ys(e))               
               (e) :
                  error("Propagation: Handle other constructs.")

      loop(es)
      return $ for x in ports map :
         read-port(x, port-saved, port-loaded)


   propagate{in(b), exps(b), _} $ fn* (in*) :
      val out* = for x in out(b) map :
         read-port(x, saved, loaded)
      WBlock(name(b),
             to-list(exp-list),
             next(b),
             in* as List<LivePort>,
             out* as List<LivePort>,
             dist(b))
      
   


   



;============================================================
;================ Register Assignment =======================
;============================================================

;defn register-assignment (b:Block, bl:BlockLive, locs-in:List<Loc>) :
;   val locs = HashTable<Symbol,Loc>(symbol-hash)
;   val reg-slots = Array<False|Symbol>(8, false)
;
;   ;Release a variable
;   defn free (x:Symbol) :
;      match(locs[x]) :
;         (x:Reg) :
;            locs[x] = Stack(0)
;            reg-slots[n(x)] = false
;         (x) : error("~ is not in a register." % [x])
;
;   ;Assign a variable to a register
;   defn assign (x:Symbol, r:Reg) :
;      if reg-slots[n(r)] != false :
;         error("Register ~ is already holding ~." % [n(r), reg-slots[n(r)]])         
;      locs[x] = r
;      reg-slots[n(r)] = x         
;
;   ;Tracks the release of variables
;   val rt = release-table(b, bl)
;   var release-n = 0
;   defn* release-up-to (p:Pos) :
;      if release-n < length(rt) :
;         val r = rt[release-n]
;         if key(r) <= p :
;            free(value(r))
;            release-n = release-n + 1
;            release-up-to(p)
;
;   ;Tracks whether a variable has been saved
;   val saved = HashTable<Symbol,True|False>(symbol-hash)
;   defn saved? (x:Symbol) :
;      get?(saved, x, false)
;   defn save (x:Symbol) :
;      saved[x] = true
;   defn unsave (x:Symbol) :
;      saved[x] = false
;
;   ;Next free register
;   defn next-free () :
;      val i = {_ as Int} $
;         for i in 0 to length(reg-slots) find :
;            reg-slots[i] == false
;      Reg(i)
;
;   ;Note incoming assignments
;   for (x in in(bl), l in locs-in) do :
;      match(l) :
;         (l:Reg) : assign(x, l)
;         (l:Stack) : locs[x] = l
;         (l) : error("Incorrect live-in location.")
;
;   ;Assign registers
;   for (e in exps(b), i in 0 to false) do :
;      match(e) :
;         (e:Op) :
;            release-up-to(Pos(i,false))
;            
;         (e) :
;            error("Register Assignment: Handle other constructs.")
         


   
   

;============================================================
;============== Register Class Allocation ===================
;============================================================

;;Utilities
;;First n items from a list
;defn first-n<?T> (n, xs:List<?T>) :
;   if length(xs) < n : xs
;   else : to-list(take-n(n, xs))
;
;;Sort a list by a given key
;defn sort-by-key<?V> (xs:List<?V>, key: V -> Int) -> List<V> :
;   val v = Vector<V>()
;   for x in xs do : add(v, x)
;   sort-by-key!(v, key)
;   to-list(v)
;
;;Make a Var just from its name
;defn Var (x:Symbol) -> Var :
;   Var(x, NoLoc(), NoLoc(), NoLoc())
;
;defn class-allocation (b:Block, bl:BlockLive) :
;   ;Compute usage table
;   val usage-table = usage-table(b, bl)
;
;   ;Number of registers
;   val max-reg = 15
;   var num-reg = 0
;
;   ;Loaded table
;   val load-table = HashTable<Symbol,True|False>(symbol-hash)
;
;   ;New expression list
;   val exp-list = Vector<Exp>()
;
;   ;Distance table
;   defn dist-table = HashTable<Symbol,Int>(symbol-hash)
;   val loaded-vec = Vector<Symbol>()
;   defn fill-dist-table (p:Pos) :
;      clear(dist-table)
;      for e in usage-table[p] do :
;         dist-table[key(e)] = value(e)
;   defn fill-loaded-vec () :
;      clear(loaded-vec)
;      for e in filter(value, load-table) do :
;         add(loaded-vec, key(e))
;         
;
;   defn loaded? (x:Symbol) :
;      get?(load-table, x, false)
;      
;   defn mark-loaded (x:Symbol, v:True|False) :
;      match(loaded?(x), v) :
;         (l:False, v:True) :
;            load-table[x] = v
;            num-reg = num-reg + 1
;         (l:True, v:False) :
;            load-table[x] = v
;            num-reg = num-reg - 1
;         (l, v) :
;            false
;
;   defn mark-loaded (xs:List<Var>, v:True|False) :
;      for x in xs do : mark-loaded(name(x), v)
;
;   ;Release all non-live values.
;   defn release (p:Pos) :
;      val xs = stream(key, filter(value, load-table))
;      val ys = map(key, usage-table[p])
;      for x in xs do :
;         mark-loaded(x, false) when not contains?(ys, x)            
;
;   ;Spill values according to liveness at position p, to reserve n registers.
;   defn spill (n:Int, p:Pos) :
;      release(p)
;      if num-reg + n > max-reg :
;         val es = reverse $
;            sort-by-key(usage-table[p], value)
;         for e in es do :
;            if num-reg + n > max-reg :
;               if loaded?(key(e)) :
;                  add(exp-list, Save(Var(key(e))))
;                  mark-loaded(key(e), false)
;
;   ;Ensure that x is loaded at position p
;   defn ensure-loaded (x:Var, p:Pos) :
;      if not loaded?(name(x)) :
;         spill(1, p) ;Spill enough space for it
;         mark-loaded(name(x), true)
;      add(exp-list, Load(Var(name(x))))
;         
;   defn ensure-loaded (xs:List<Var>, p:Pos) :
;      for x in xs do : ensure-loaded(x, p)
;
;   ;Load as many live-in registers as possible
;   defn load-live-in () :
;      for x in in(bl) do : mark-loaded(x, true)
;      spill(0, Pos(0,false))
;
;   ;Allocate registers and emit save and loads         
;   defn allocate () :
;      for (e in exps(b), i in 0 to false) do :
;         match(e) :
;            (e:Op) :
;               ensure-loaded(ys(e), Pos(i,false))
;               spill(length(xs(e)), Pos(i, true))
;               add(exp-list, e)
;               mark-loaded(xs(e), true)
;            (e) :
;               error("Allocation: Handle other constructs.")
;
;   ;Driver
;   load-live-in()
;   allocate()
;   Block(name(b), to-list(exp-list), next(b))

   

;;========== Working IR ==================
;definterface Loc
;defstruct Stack <: Loc
;defstruct Reg <: Loc
;defstruct RegN <: Loc :
;   n: Int
;
;defstruct Status :
;   saved?: True|False
;   loaded?: True|False
;
;defstruct Dead <: Ref
;defstruct LVar <: Ref :
;   name: Symbol with : (as-method => true)
;   loc: Loc
;
;defstruct Save <: Exp :
;   x: Ref
;defstruct Load <: Exp :
;   x: Ref
;defstruct Release <: Exp :
;   x: Ref
;defstruct ParSet <: Exp :
;   xs: List<Ref>
;   ys: List<Ref>
;
;defstruct LBlock <: Block :
;   name: Symbol with: (as-method => true)
;   exps: List<Exp> with: (as-method => true)
;   next: List<Symbol> with: (as-method => true)
;   live-in: List<Ref>
;   status-in: List<Status>
;   live-out: List<Ref>
;   status-out: List<Status>
;   dist-out: List<Int>
;
;============================================================
;==================== Printing ==============================
;============================================================

;defmethod print (o:OutputStream, e:Exp) :
;      (e:Save) : "save ~" << [x(e)]
;      (e:Load) : "load ~" << [x(e)]
;      (e:Release) : "release ~" << [x(e)]
;      (e:ParSet) : "(~@) = (~@)" << [cms(xs(e)), cms(ys(e))]
      

;defmethod print (o:OutputStream, s:Status) :
;   print{o, _} $ match(saved?(s), loaded?(s)) :
;      (s:True, l:True) : "SL"
;      (s:True, l:False) : "S"
;      (s:False, l:True) : "L"
;      (s:False, l:False) : "?"

;defmethod print (o:OutputStream, b:LBlock) :
;   defn ps (x:Ref, s:Status) : "~:~" << [x, s]
;   defn ps (xs:List<Ref>, ss:List<Status>) : stream(ps, xs, ss)
;   print(o, "lblock ~ :" << [name(b)])
;   for e in exps(b) do :
;      print(o, "\n   ~" << [e])
;   print(o, "\n   goto (~@)" << [cms(next(b))])
;   print(o, "\n   live-in: (~@)" << [cms(ps(live-in(b), status-in(b)))])
;   print(o, "\n   live-out: (~@)" << [cms(ps(live-out(b), status-out(b)))])
;   print(o, "\n   dist-out: (~@)" << [cms(dist-out(b))])

;defmethod print (o:OutputStream, r:Ref) :
;   print{o, _} $ match(r) :
;      (r:Var) : name(r)
;      (r:Dead) : "dead"
;      (r:LVar) : "~:~" << [name(r), loc(r)]

;defmethod print (o:OutputStream, l:Loc) :
;   print{o, _} $ match(l) :
;      (l:Stack) : "stk"
;      (l:Reg) : "reg"
;      (l:RegN) : "reg~" << [n(l)]


;;======== Critical Edge Removal ==========
;defn remove-critical-edges (p:Program) :
;   val pred-table = HashTable<Symbol,Int>(symbol-hash)
;   val block-list = Vector<SBlock>()
;   
;   defn num-pred (b:Symbol) :
;      get?(pred-table, b, 0)
;
;   defn inc-pred (b:Symbol) :
;      pred-table[b] = num-pred(b) + 1
;
;   defn update-next (b:Block, n:List<Symbol>) :
;      SBlock(name(b), exps(b), n)
;
;   ;Count predecessors
;   for b in blocks(p) do :
;      for n in next(b) do :
;         inc-pred(n)
;
;   ;Create safe block
;   defn safe-block (a:Block, b:Symbol) :
;      val name = gensym(`safe)
;      add(block-list, SBlock(name, List(), list(b)))
;      name
;
;   ;Insert safe blocks
;   val blocks* = for b in blocks(p) map :
;      if length(next(b)) > 1 :
;         val next* = for n in next(b) map :
;            if num-pred(n) > 1 : safe-block(b, n)
;            else : n
;         update-next(b, next*)
;      else :
;         b
;
;   Program(to-list(concat(blocks*, block-list)))
;            
;
;

;;====== Finite Register Allocation ======
;defn finite-allocation (b:LBlock) :
;   var num-reg = 0
;   val N = 8
;   val loaded = HashTable<Symbol,True|False>(symbol-hash)
;   val exp-list = Vector<Exp>()
;   val usage-table = compute-usage-table(b)
;
;   defn emit (e:Exp) :
;      add(exp-list, e)
;
;   defn release (x:Symbol) :
;      emit(Release(Var(x)))
;
;   defn release (xs:Streamable<Symbol>) :
;      do(release, xs)
;   
;   defn save (x:Symbol) :
;      emit(Save(Var(x)))
;
;   defn save (xs:Streamable<Symbol>) :
;      do(save, xs)
;
;   defn unload-all () :
;      clear(loaded)
;      num-reg = 0
;
;   defn loaded? (x:Symbol) :
;      get?(loaded, x, false)
;      
;   defn loaded? (x:Ref) :
;      loaded?(name(x))
;
;   defn loaded-vars () :
;      filter(loaded?, keys(loaded))
;
;   defn set-loaded (x:Symbol, v:True|False) :
;      match(get?(loaded, x, false), v) :
;         (l:False, v:True) :
;            loaded[x] = v
;            num-reg = num-reg + 1
;         (l:True, v:False) :
;            loaded[x] = v
;            num-reg = num-reg - 1
;         (l, v) :
;            false            
;
;   defn set-loaded (x:Ref, v:True|False) :
;      if x not-typeof Dead :
;         set-loaded(name(x), v)
;
;   defn set-loaded (xs:List<Ref|Symbol>, v:True|False) :
;      do(set-loaded{_, v}, xs)
;
;   ;Find the variables used farthest from position p
;   defn farthest-var (p:Pos) -> [List<Symbol>, Int|False] :
;      val es = to-list $
;         for v in loaded-vars() stream :
;            v => lookup(usage-table[p], v)
;      val dead = to-list $
;         for e in es filter :
;            value(e) == false
;      if empty?(dead) :
;         val e = maximum-by-key(es, value)
;         [list(key(e)), value(e)]
;      else :
;         [map(key,dead), false]
;
;   ;Ensure n registers are free, spilling if necessary.
;   defn alloc-reg (p:Pos, n:Int) :
;      while num-reg + n > N :
;         val [vs, d] = farthest-var(p)
;         save(vs) when d != false
;         release(vs)
;         set-loaded(vs, false)
;
;   ;Load as many of xs as possible. Keep nearest used values in registers.
;   defn load-nearest (p:Pos, xs:List<Ref>) :
;      set-loaded(xs, true)
;      alloc-reg(p, 0)
;
;   ;Ensure that x is loaded at position p
;   defn load (p:Pos, x:Ref) :
;      alloc-reg(p, 1) when not loaded?(x)         
;      emit(Load(x))
;      set-loaded(x, true)
;
;   defn load (p:Pos, xs:List<Ref>) :
;      do(load{p, _}, xs)
;
;   ;Get all live variables at position p
;   defn live-vars (p:Pos) :
;      stream(key, usage-table[p])
;
;   defn keep-live (p:Pos, xs:List<Ref>) :
;      val live = to-list(live-vars(p))
;      for x in xs map :
;         if contains?(live, name(x)) : x
;         else : Dead()
;
;   load-nearest(Pos(0, false), live-in(b))
;   for (e in exps(b), i in 0 to false) do :
;      match(e) :
;         (e:Args) :
;            val xs* = keep-live(Pos(i + 1, false), xs(e))
;            emit(Args(xs*))
;            load-nearest(Pos(i + 1, false), xs*)
;         (e:Set) :
;            load(Pos(i,false), y(e))
;            alloc-reg(Pos(i,true), 1)
;            emit(e)
;            set-loaded(x(e), true)
;         (e:Op) :
;            load(Pos(i,false), ys(e))
;            alloc-reg(Pos(i,true), length(xs(e)))
;            emit(e)
;            set-loaded(xs(e), true)
;         (e:Do) :
;            save(live-vars(Pos(i,true)))
;            val xs* = keep-live(Pos(i + 1, false), xs(e))
;            emit(Do(xs*, ys(e)))
;            unload-all()
;            load-nearest(Pos(i + 1, false), xs*)
;
;   LBlock(name(b),
;          to-list(exp-list),
;          next(b),
;          live-in(b),
;          status-in(b),
;          live-out(b),
;          status-out(b),
;          dist-out(b))
;
;
;
;;====== Save/Load Elision ======
;defstruct Any
;defn save-load-elision (b:LBlock) :
;   val saved = HashTable<Symbol,True|False|Any>(symbol-hash)
;   val loaded = HashTable<Symbol,True|False|Any>(symbol-hash)
;   var assumptions = Vector<Exp>()
;
;   val save-buffer = HashTable<Symbol,True|False>(symbol-hash)
;   val load-buffer = HashTable<Symbol,True|False>(symbol-hash)
;   defn status (assumptions:Vector<Exp>, xs:List<Ref>) :
;      clear(save-buffer)
;      clear(load-buffer)
;      for e in assumptions do :
;         match(e) :
;            (e:Save) : save-buffer[name(x(e))] = true
;            (e:Load) : load-buffer[name(x(e))] = true
;      for x in xs map :
;         match(x) :
;            (x:Dead) :
;               Status(false, false)
;            (x) :
;               Status(get?(save-buffer, name(x), false)
;                      get?(load-buffer, name(x), false))
;
;   defn mark-loaded (x:Ref, v:True|False|Any) :
;      if x not-typeof Dead :
;         loaded[name(x)] = v
;
;   defn mark-loaded (xs:List<Ref>, v:True|False|Any) :
;      do(mark-loaded{_, v}, xs)
;      
;   defn mark-saved (x:Ref, v:True|False|Any) :
;      if x not-typeof Dead :
;         saved[name(x)] = v
;
;   defn mark-saved (xs:List<Ref>, v:True|False|Any) :
;      do(mark-saved{_, v}, xs)
;
;   defn assume (e:Exp) :
;      add(assumptions, e)
;
;   defn saved-ref? (x:Ref) :
;      get?(saved, name(x), false)
;      
;   defn loaded-ref? (x:Ref) :
;      get?(loaded, name(x), false)
;
;   defn elide (es:List<Exp>) -> List<Exp> :
;      defn elide-and-gather (xs:List<Ref>, es:List<Exp>) :
;         let-var assumptions = Vector<Exp>() :
;            clear(loaded)
;            mark-saved(xs, Any())
;            mark-loaded(xs, Any())
;            var body = elide(es)
;            val ss = status(assumptions, xs)
;            val xs* = for (x in xs, s in ss) map :
;               match(x, saved?(s), loaded?(s)) :
;                  (x:Dead, s, l) : x
;                  (x, s:True, l:False) :
;                     LVar(name(x), Stack())
;                  (x, s:False, l:True) :
;                     LVar(name(x), Reg())
;                  (x, s:False, l:False) :
;                     mark-loaded(x, true)
;                     LVar(name(x), Reg())
;                  (x, s:True, l:True) :
;                     body = List(Save(x), body)
;                     LVar(name(x), Reg())
;            [xs*, body]
;
;      if empty?(es) :
;         List()
;      else :   
;         val e = head(es)
;         val rest = tail(es)
;         match(e) :
;            (e:Args) :
;               val [xs*, rest*] = elide-and-gather(xs(e), rest)
;               List(Args(xs*), rest*)
;            (e:Set) :
;               mark-loaded(x(e), true)
;               mark-saved(x(e), false)
;               List(e, elide(rest))
;            (e:Op) :           
;               mark-loaded(xs(e), true)
;               mark-saved(xs(e), false)
;               List(e, elide(rest))
;            (e:Do) :
;               val [xs*, rest*] = elide-and-gather(xs(e), rest)
;               List(Do(xs*, ys(e)), rest*)
;            (e:Save) :
;               match(saved-ref?(x(e))) :
;                  (s:True) : elide(rest)
;                  (s:False) : (mark-saved(x(e), true), List(e, elide(rest)))
;                  (s:Any) : (assume(e), mark-saved(x(e), true), elide(rest))
;            (e:Load) :
;               match(loaded-ref?(x(e))) :
;                  (l:True) : elide(rest)
;                  (l:False) : (mark-loaded(x(e), true), List(e, elide(rest)))
;                  (l:Any) : (assume(e), mark-loaded(x(e), true), elide(rest))
;            (e:Release) :
;               match(loaded-ref?(x(e))) :
;                  (l:Any) : elide(rest)
;                  (l) : List(e, elide(rest))
;
;   mark-saved(live-in(b), Any())
;   mark-loaded(live-in(b), Any())
;   val exps* = elide(exps(b))
;   val status-in* = status(assumptions, live-in(b))
;   val status-out* = for x in live-out(b) map :
;      val s = get?(saved, name(x), false) typeof True
;      val l = get?(loaded, name(x), false) typeof True
;      Status(s, l)
;      
;   LBlock(name(b),
;          exps*,
;          next(b),
;          live-in(b),
;          status-in*,
;          live-out(b),
;          status-out*,
;          dist-out(b))
;
;defn save-load-elision (p:Program) :
;   Program(
;      map(save-load-elision, blocks(p) as List<LBlock>))
;
;
;;======== Register Assignment ========
;defstruct Free
;defn assign-registers (b:LBlock, locs-in:List<Loc>) :
;   val N = 8
;   val locations = HashTable<Symbol,Loc>(symbol-hash)
;   val reg-free = Array<True|False>(N, true)
;   val reg-values = Array<False|Symbol>(N, false)
;   val exp-list = Vector<Exp>()
;   val #free = Free()
;
;   ;Basic Operations
;   defn free-reg () :
;      RegN(index-of(reg-free, true) as Int)
;      
;   defn free-reg (loc:Loc) :
;      match(loc) :
;         (loc:RegN) :
;            if reg-free[n(loc)] : loc
;            else : free-reg()
;         (loc:Stack) : free-reg()
;
;   defn assign-loc (ref:Ref, loc:Loc) :
;      if loc typeof RegN :
;         val loc = loc as RegN
;         reg-free[n(loc)] = false
;         val x = reg-values[n(loc)]
;         if x typeof Symbol :
;            locations[x as Symbol] = Stack()
;         reg-values[n(loc)] = name(ref)
;      locations[name(ref)] = loc   
;      match(ref) :
;         (ref:Var) : LVar(name(ref), loc)
;         (ref:LVar) : LVar(name(ref), loc)
;
;   defn assign-loc (refs:List<Ref>, f:Free) :
;      for r in refs map :
;         assign-loc(r, free-reg())
;
;   defn update-loc (ref:Ref) :
;      match(ref) :
;         (ref:Var) : LVar(name(ref), locations[name(ref)])
;         (ref:LVar) : LVar(name(ref), locations[name(ref)])
;         (ref:Dead) : ref
;
;   defn update-loc (refs:List<Ref>) :
;      map(update-loc, refs)
;
;   defn emit (e:Exp) :
;      add(exp-list, e)
;
;   ;Initial State
;   val live-in* = for (x in live-in(b), s in status-in(b), l in locs-in) map :
;      match(saved?(s), loaded?(s)) :
;         (sv, ld:True) : assign-loc(x, free-reg(l))
;         (sv:True, ld:False) : assign-loc(x, Stack())
;         (sv:False, ld:False) : assign-loc(x, l)
;
;   ;Assigning locations to expressions
;   for e in exps(b) do :
;      defn assign-arg-locs (xs:List<Ref>) :
;         val arg-regs = map(RegN, to-array([2 3 4 5 6 7]))
;         defn preferred (i:Int) :
;            if i < length(arg-regs) : arg-regs[i]
;            else : free-reg()
;         for (x in xs, i in 0 to false) map :
;            match(x) :
;               (x:Dead) : x
;               (x:LVar) :
;                  match(loc(x)) :
;                     (loc:Stack) : assign-loc(x, loc)
;                     (loc:Reg) : assign-loc(x, preferred(i))
;
;      match(e) :
;         (e:Args) :
;            val xs* = assign-arg-locs(xs(e))
;            emit(Args(xs*))
;         (e:Set) :
;            val y* = update-loc(y(e))
;            val x* = assign-loc(x(e), free-reg(loc(y* as LVar)))
;            emit(Set(x*, y*))
;         (e:Op) :         
;            val ys* = update-loc(ys(e))
;            val xs* = assign-loc(xs(e), #free)
;            emit(Op(xs*, ys*))
;         (e:Save) :
;            val x* = update-loc(x(e))
;            emit(Save(x*))
;         (e:Load) :
;            val x* = assign-loc(x(e), free-reg())
;            emit(Load(x*))
;         (e:Release) :
;            val loc = locations[name(x(e))] as RegN
;            reg-free[n(loc)] = true
;         (e:Do) :
;            val ys* = update-loc(ys(e))
;            for v in keys(locations) do :
;               locations[v] = Stack()
;            do({reg-free[_] = true}, 0 to N)
;            val xs* = assign-arg-locs(xs(e))
;            emit(Do(xs*, ys*))
;
;   ;Assign locations to live-out
;   val live-out* = update-loc(live-out(b))
;
;   ;Return filled block
;   LBlock(name(b),
;          to-list(exp-list),
;          next(b),
;          live-in*,
;          status-in(b),
;          live-out*,
;          status-out(b),
;          dist-out(b))
;          
;defn assign (p:Program) :
;   ;Initialize Blocks
;   val block-table = HashTable<Symbol,LBlock>(symbol-hash)
;   val block-assigned? = HashTable<Symbol,True|False>(symbol-hash)
;   for b in blocks(p) do :
;      block-table[name(b)] = b as LBlock
;      block-assigned?[name(b)] = false
;
;   ;Rearrange locations: Rearrange locations of a to match against b
;   defn rearrange (a:List<Ref>, b:List<Ref>, ls:List<Loc>) :
;      val table = HashTable<Symbol,Loc>(symbol-hash)
;      for (r in a, l in ls) do : table[name(r)] = l
;      for r in b map : table[name(r)]
;
;   defn get-loc (x:Ref) :
;      loc(x as LVar)
;      
;   defn get-loc (xs:List<Ref>) :
;      map(get-loc, xs)      
;
;   defn loop (b:LBlock, locs-in:List<Loc>) :
;      if length(locs-in) != length(live-in(b)) :
;         error("Number of locs-in does not match number of live-in.")
;      val b* = assign-registers(b, locs-in)
;      block-table[name(b)] = b*
;      block-assigned?[name(b)] = true
;      for n in next(b*) do :
;         if not block-assigned?[n] :
;            val nb = block-table[n]
;            val locs = rearrange(live-out(b*),
;                                 live-in(nb),
;                                 get-loc(live-out(b*)))
;            loop(nb, locs)
;
;   val entry = head(blocks(p)) as LBlock
;   loop(entry, List())
;
;   ;Return new program
;   Program(map({block-table[name(_)]}, blocks(p)))
;      
;;======== Stack Interval Calculation ==========
;defn calculate-stack-intervals (p:Program) :
;   val block-table = HashTable<Symbol,LBlock>(symbol-hash)
;   val block-start = HashTable<Symbol,Int>(symbol-hash)
;   val block-end = HashTable<Symbol,Int>(symbol-hash)
;   val block-preds = HashTable<Symbol,List<Symbol>>(symbol-hash)
;   val min-table = HashTable<Symbol,Int>(symbol-hash)
;   val max-table = HashTable<Symbol,Int>(symbol-hash)
;   val scanned = HashTable<Symbol,True>(symbol-hash)
;   val scan-queue = Queue<LBlock>()
;   var index = 0
;
;   defn on-stack? (x:Ref) :
;      match(x) :
;         (x:LVar) : loc(x) typeof Stack
;         (x) : false
;
;   defn on-stack (xs:List<Ref>) :
;      filter(on-stack?, xs)
;
;   defn used (x:Ref, index:Int) :
;      val nx = name(x)
;      if key?(min-table, name(x)) :
;         min-table[nx] = min(index, min-table[nx])
;         max-table[nx] = max(index, max-table[nx])
;      else :
;         min-table[nx] = index
;         max-table[nx] = index
;
;   defn used (xs:Streamable<Ref>, index:Int) :
;      do(used{_, index}, xs)
;
;   defn step () :
;      index = index + 1
;
;   defn get-preds (n:Symbol) :
;      get?(block-preds, n, List())
;
;   ;Register blocks
;   for b in blocks(p) do :
;      block-table[name(b)] = b as LBlock
;      
;   ;Process blocks   
;   add(scan-queue, head(blocks(p)) as LBlock)
;   while not empty?(scan-queue) :
;      val b = pop(scan-queue)
;      if not key?(scanned, name(b)) :
;         ;Note Start Index
;         block-start[name(b)] = index
;         ;Note Expressions
;         for e in exps(b) do :
;            match(e) :
;               (e:Args) : used(on-stack(xs(e)), index)
;               (e:Op) : false
;               (e:Save) : used(x(e), index)
;               (e:Load) : used(x(e), index)
;               (e:Do) :
;                  used(on-stack(ys(e)), index)
;                  step()
;                  used(on-stack(xs(e)), index)
;            step()
;         ;Note End Index
;         block-end[name(b)] = index
;         step()
;         ;Register Next Blocks
;         for n in next(b) do :
;            add(scan-queue, block-table[n])
;            block-preds[n] = List(name(b), get-preds(n))
;
;   ;Process Live in
;   for b in values(block-table) do :
;      defn saved (xs:List<Ref>, ss:List<Status>) :
;         for (x in xs, s in ss) filter :
;            saved?(s) or on-stack?(x)
;         
;      for x in saved(live-in(b), status-in(b)) do :
;         used(x, block-start[name(b)])
;         for p in get-preds(name(b)) do :
;            used(x, block-end[p])
;
;   ;Accumulate Results
;   val interval-starts = Array<List<Symbol>>(index, List())
;   val interval-ends = Array<List<Symbol>>(index, List())
;   for v in keys(min-table) do :
;      val i = min-table[v]
;      val j = max-table[v]
;      interval-starts[i] = List(v, interval-starts[i])
;      interval-ends[j] = List(v, interval-ends[j])
;   val r = [interval-starts, interval-ends]
;
;   ;Print Result
;   for i in 0 to length(interval-starts) do :
;      println("~: START(~@) END(~@)" << [i, interval-starts[i], interval-ends[i]])
;
;   r
;
;
;;====== Stack Location Calculation ======
;defn calculate-stack-locations (p:Program) :
;   val location-table = HashTable<Symbol,Int>(symbol-hash)
;   val [starts, ends] = calculate-stack-intervals(p)
;   val location-free = Vector<True|False>()
;   val N = length(starts)
;
;   defn get-free-location () :
;      match(index-of(location-free, true)) :
;         (i:Int) : i
;         (i:False) :
;            add(location-free, true)
;            length(location-free) - 1
;
;   defn assign-free-location (x:Symbol) :
;      val i = get-free-location()
;      location-table[x] = i
;      location-free[i] = false
;
;   defn release-location (x:Symbol) :
;      val i = location-table[x]
;      location-free[i] = true
;
;   defn assign-free-location (xs:List<Symbol>) :
;      do(assign-free-location, xs)
;
;   defn release-location (xs:List<Symbol>) :
;      do(release-location, xs)
;
;   for i in 0 to N do :
;      assign-free-location(starts[i])
;      release-location(ends[i])
;
;   ;Print Result
;   println("Location Table")
;   do(println, location-table)
;
;   location-table
;
;
;;========= Glue Blocks ========
;defn glue-blocks (p:Program) :
;   ;Parallel Move
;   defn par-move (src:List<Ref>, src-status:List<Status>,
;                  dst:List<Ref>, dst-status:List<Status>) :
;      val src-loc-table = HashTable<Symbol,Loc>(symbol-hash)
;      val dst-loc-table = HashTable<Symbol,Loc>(symbol-hash)
;      val src-status-table = HashTable<Symbol,Status>(symbol-hash)
;      val dst-status-table = HashTable<Symbol,Status>(symbol-hash)
;      val RS-moves = Vector<Save>()
;      val RR-srcs = Vector<Ref>()
;      val RR-dsts = Vector<Ref>()
;      val SR-moves = Vector<Load>()
;      
;      ;Initialize Tables
;      for (x in src, s in src-status) do :
;         src-loc-table[name(x)] = loc(x as LVar)
;         src-status-table[name(x)] = s
;      for (x in dst, s in dst-status) do :
;         dst-loc-table[name(x)] = loc(x as LVar)
;         dst-status-table[name(x)] = s
;
;      defn stack-dst? (x:Ref) :
;         dst-loc-table[name(x)] typeof Stack
;      defn reg-dst? (x:Ref) :
;         dst-loc-table[name(x)] typeof RegN
;      defn stack-src? (x:Ref) :
;         src-loc-table[name(x)] typeof Stack
;      defn reg-src? (x:Ref) :
;         src-loc-table[name(x)] typeof RegN
;      defn save-dst? (x:Ref) :
;         saved?(dst-status-table[name(x)])
;      defn save-src? (x:Ref) :
;         saved?(src-status-table[name(x)])
;      defn get-src (x:Ref) :
;         LVar(name(x), src-loc-table[name(x)])
;      defn get-dst (x:Ref) :
;         LVar(name(x), dst-loc-table[name(x)])
;                  
;      for x in dst do :
;         if (stack-dst?(x) or save-dst?(x)) and not
;            (stack-src?(x) or save-src?(x)) :
;            add(RS-moves, Save(get-src(x)))
;         else if reg-dst?(x) and reg-src?(x) :
;            add(RR-srcs, get-src(x))
;            add(RR-dsts, get-dst(x))
;         else if reg-dst?(x) and stack-src?(x) :
;            add(SR-moves, Load(get-dst(x)))
;
;      concat-all $ [
;         RS-moves
;         [ParSet(to-list(RR-dsts), to-list(RR-srcs))]
;         SR-moves]
;
;   ;Glue Blocks
;   val block-table = HashTable<Symbol,LBlock>(symbol-hash)
;   for b in blocks(p) do :
;      block-table[name(b)] = b as LBlock
;
;   defn update-exps (b:LBlock, exps:List<Exp>) :
;      LBlock(name(b),
;             exps,
;             next(b),
;             live-in(b),
;             status-in(b),
;             live-out(b)
;             status-out(b),
;             dist-out(b))
;
;   for b in values(block-table) do :
;      if length(next(b)) == 1 :
;         val b2 = block-table[head(next(b))] as LBlock
;         val exps* = to-list $ concat(exps(b),
;            par-move(live-out(b), status-out(b),
;                     live-in(b2), status-in(b2)))
;         block-table[name(b)] = update-exps(b, exps*)
;      else :
;         for n in next(b) do :
;            val b2 = block-table[n] as LBlock
;            val exps* = to-list $ concat(
;               par-move(live-out(b), status-out(b),
;                        live-in(b2), status-in(b2))
;               exps(b2))
;            block-table[name(b2)] = update-exps(b2, exps*)   
;
;   Program(map({block-table[name(_)]}, blocks(p)))
;
;;========= Driver ========
;defn allocate (p:Program) :
;   val bs* = for b in blocks(p) map :
;      save-load-elision $
;      finite-allocation $      
;      b as LBlock
;   Program(bs*)
;

;============================================================
;==================== Driver ================================
;============================================================
defn test (p:Unit) :
   println("====== Test ======")
   println(p)
;   println("====== Remove critical edges ======")
;   val p1 = remove-critical-edges(p)
;   println(p1)
   println("====== Liveness Analysis ======")
   val p2 = liveness-analysis(p)
   println(p2)
   for b in blocks(p2) do :
      println("==== Block ~ ====" << [name(b)])
      println("Save Semantics:")
      var b* = save-semantics(b as WBlock)
      println(b*)
      b* = class-allocation(b*)
      println("Class Allocation:")
      println(b*)
      b* = propagate-assumptions(b*)
      println("Assumption Propagation:")
      println(b*)
      

      

   
;   println("====== Allocation ======")
;   val p3 = allocate(p2)
;   println(p3)
;   println("====== Assignment ======")
;   val p4 = assign(p3)
;   println(p4)
;   println("====== Calculate Stack Locations ======")
;   calculate-stack-locations(p4)
;   println("====== Glue Blocks ======")
;   val p5 = glue-blocks(p4)
;   println(p5)
;   println("==================\n\n\n")


defn main () :
   val filename = commandline-arguments()[1]
   val units = parse-regir(filename)   
   do(test, units)

main()