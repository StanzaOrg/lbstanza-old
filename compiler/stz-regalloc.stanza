#include<"core/stringeater.stanza">
#include<"compiler/stz-algorithms.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">

defpackage regalloc :
   import core
   import verse
   import stz/lexer
   import stz/parser
   import stz/algorithms

;============ Input IR =======================
definterface Ref
defmulti name (r:Ref) -> Symbol
defstruct Var <: Ref :
   name: Symbol with : (as-method => true)   

definterface Exp
defstruct Args <: Exp :
   xs: List<Ref>
defstruct Set <: Exp :
   x: Ref
   y: Ref
defstruct Op <: Exp :
   xs: List<Ref>
   ys: List<Ref>
defstruct Do <: Exp :
   xs: List<Ref>
   ys: List<Ref>

definterface Block
defmulti name (b:Block) -> Symbol
defmulti exps (b:Block) -> List<Exp>
defmulti next (b:Block) -> List<Symbol>

defstruct SBlock <: Block :
   name: Symbol with : (as-method => true)
   exps: List<Exp> with : (as-method => true)
   next: List<Symbol> with : (as-method => true)

defstruct Program :
   blocks: List<Block>

;========== Parser =====================
defsyntax regir :
   val ut = unwrap-token

   defrule :
      sym = (?x) when ut(x) typeof Symbol : ut(x)

      exp = ((?xs:#sym ...) = args) :
         Args(map(Var,xs))
      exp = (?x:#sym = ?y:#sym) :
         Set(Var(x), Var(y))
      exp = ((?xs:#sym ...) = op(?ys:#sym ...)) :
         Op(map(Var, xs), map(Var, ys))
      exp = ((?xs:#sym ...) = f(?ys:#sym ...)) :
         Do(map(Var, xs), map(Var, ys))

      block = (block ?name:#sym :
                  ?es:#exp ...
                  goto (?ns:#sym ...)) :
         SBlock(name, es, ns)

      prog = (?bs:#block ...) :
         Program(bs)

defn parse-regir (filename:String) -> List<Program> :
   val lexed = lex-file(filename)
   with-syntax(regir) :
      match-syntax(lexed) :
         ((test : (?ps:#prog)) @...) : ps

;========== Working IR ==================
definterface Loc
defstruct Stack <: Loc
defstruct Reg <: Loc
defstruct RegN <: Loc :
   n: Int

defstruct Status :
   saved?: True|False
   loaded?: True|False

defstruct Dead <: Ref
defstruct LVar <: Ref :
   name: Symbol with : (as-method => true)
   loc: Loc

defstruct Save <: Exp :
   x: Ref
defstruct Load <: Exp :
   x: Ref
defstruct Release <: Exp :
   x: Ref
defstruct ParSet <: Exp :
   xs: List<Ref>
   ys: List<Ref>

defstruct LBlock <: Block :
   name: Symbol with: (as-method => true)
   exps: List<Exp> with: (as-method => true)
   next: List<Symbol> with: (as-method => true)
   live-in: List<Ref>
   status-in: List<Status>
   live-out: List<Ref>
   status-out: List<Status>
   dist-out: List<Int>

;=========== Printing =====================
defn cms (xs) : join(xs, ", ")

defmethod print (o:OutputStream, p:Program) :
   for b in join(blocks(p), "\n") do :
      print(o, b)

defmethod print (o:OutputStream, b:SBlock) :
   print(o, "block ~ :" << [name(b)])
   for e in exps(b) do :
      print(o, "\n   ~" << [e])
   print(o, "\n   goto (~@)" << [cms(next(b))])

defmethod print (o:OutputStream, s:Status) :
   print{o, _} $ match(saved?(s), loaded?(s)) :
      (s:True, l:True) : "SL"
      (s:True, l:False) : "S"
      (s:False, l:True) : "L"
      (s:False, l:False) : "?"

defmethod print (o:OutputStream, b:LBlock) :
   defn ps (x:Ref, s:Status) : "~:~" << [x, s]
   defn ps (xs:List<Ref>, ss:List<Status>) : stream(ps, xs, ss)
   print(o, "lblock ~ :" << [name(b)])
   for e in exps(b) do :
      print(o, "\n   ~" << [e])
   print(o, "\n   goto (~@)" << [cms(next(b))])
   print(o, "\n   live-in: (~@)" << [cms(ps(live-in(b), status-in(b)))])
   print(o, "\n   live-out: (~@)" << [cms(ps(live-out(b), status-out(b)))])
   print(o, "\n   dist-out: (~@)" << [cms(dist-out(b))])

defmethod print (o:OutputStream, e:Exp) :
   defn ploc (x:Ref, l:Loc) : "~:~" << [x, l]
   defn plocs (xs:List<Ref>, ls:List<Loc>) : stream(ploc, xs, ls)
   print{o, _} $ match(e) :
      (e:Args) : "(~@) = args" << [cms(xs(e))]
      (e:Set) : "~ = ~" << [x(e), y(e)]
      (e:Op) : "(~@) = op(~@)" << [cms(xs(e)), cms(ys(e))]
      (e:Do) : "(~@) = f(~@)" << [cms(xs(e)), cms(ys(e))]
      (e:Save) : "save ~" << [x(e)]
      (e:Load) : "load ~" << [x(e)]
      (e:Release) : "release ~" << [x(e)]
      (e:ParSet) : "(~@) = (~@)" << [cms(xs(e)), cms(ys(e))]

defmethod print (o:OutputStream, r:Ref) :
   print{o, _} $ match(r) :
      (r:Var) : name(r)
      (r:Dead) : "dead"
      (r:LVar) : "~:~" << [name(r), loc(r)]

defmethod print (o:OutputStream, l:Loc) :
   print{o, _} $ match(l) :
      (l:Stack) : "stk"
      (l:Reg) : "reg"
      (l:RegN) : "reg~" << [n(l)]


;======== Critical Edge Removal ==========
defn remove-critical-edges (p:Program) :
   val pred-table = HashTable<Symbol,Int>(symbol-hash)
   val block-list = Vector<SBlock>()
   
   defn num-pred (b:Symbol) :
      get?(pred-table, b, 0)

   defn inc-pred (b:Symbol) :
      pred-table[b] = num-pred(b) + 1

   defn update-next (b:Block, n:List<Symbol>) :
      SBlock(name(b), exps(b), n)

   ;Count predecessors
   for b in blocks(p) do :
      for n in next(b) do :
         inc-pred(n)

   ;Create safe block
   defn safe-block (a:Block, b:Symbol) :
      val name = gensym(`safe)
      add(block-list, SBlock(name, List(), list(b)))
      name

   ;Insert safe blocks
   val blocks* = for b in blocks(p) map :
      if length(next(b)) > 1 :
         val next* = for n in next(b) map :
            if num-pred(n) > 1 : safe-block(b, n)
            else : n
         update-next(b, next*)
      else :
         b

   Program(to-list(concat(blocks*, block-list)))
            


;======== Liveness Analysis ============
defn liveness-analysis (p:Program) :
   ;====== State ======
   defn bhash ([b,x]:[Symbol,Symbol]) : 7 * symbol-hash(b) + symbol-hash(x)
   val lengths = HashTable<Symbol,Int>(symbol-hash)
   val live-in-table = HashTable<[Symbol,Symbol], Int>(bhash)
   val live-out-table = HashTable<[Symbol,Symbol], Int>(bhash)
   val defs = HashTable<[Symbol,Symbol], True>(bhash)
   val pred-table = HashTable<Symbol,List<Symbol>>(symbol-hash)
   var changed: () -> False = {false}

   ;====== Utilities ======
   defn #def? (b:Symbol, x:Symbol) : key?(defs, [b, x])
   defn #def? (b:Block, x:Symbol) : #def?(name(b), x)
   defn #def? (b:Block, x:Ref) : #def?(b, name(x))
   defn #def (b:Block, x:Ref) : #def(b, name(x))
   defn #def (b:Block, xs:List<Ref|Symbol>) : do(#def{b, _}, xs)
   defn #use (b:Block, xs:List<Ref>, i:Int) : do(#use{b, _, i}, xs)
   defn #add-live-in (b:Block, x:Ref, i:Int) : #add-live-in(name(b), name(x), i)
   defn #add-pred (b:Symbol, p:Symbol) : pred-table[b] = List(p, get?(pred-table, b, List()))
   defn #add-pred (b:Symbol, p:Block) : #add-pred(b, name(p))
   defn #set-length (b:Block, n:Int) : lengths[name(b)] = n
   defn #length (b:Symbol) : lengths[b]
   defn #pred (b:Symbol) : get?(pred-table, b, List())

   ;====== Computing the Block Liveness ======
   defn #def (b:Block, x:Symbol) :
      defs[[name(b), x]] = true

   defn #use (b:Block, x:Ref, i:Int) :
      #add-live-in(b, x, i) when not #def?(b, x)
   
   defn #add-live-in (b:Symbol, x:Symbol, i:Int) :
      val k = [b, x]
      defn update () :
         live-in-table[k] = i
         changed()
      match(get?(live-in-table, k, false)) :
         (i2:Int) : update() when i < i2
         (i2:False) : update()
         
   defn #add-live-out (b:Symbol, x:Symbol, i:Int) :
      val k = [b, x]
      defn update () :
         live-out-table[k] = i
         changed()
      match(get?(live-out-table, k, false)) :
         (i2:Int) : update() when i < i2
         (i2:False) : update()

   defn compute-block-liveness (b:Block) :
      ;Analyze defs and uses
      for (e in exps(b), i in 0 to false) do :
         match(e) :
            ;(e:GetArgs) : #def(b, xs(e))
            ;(e:SetArgs) : #use(b, xs(e), i)
            (e:Set) : (#use(b, y(e), i), #def(b, x(e)))
            (e:Op) : (#use(b, ys(e), i), #def(b, xs(e)))
            ;(e:Call) : false
            (e:Args) : #def(b, xs(e))
            (e:Do) : (#use(b, ys(e), i), #def(b, xs(e)))
            
      ;Record length of block      
      #set-length(b, length(exps(b)))
      
      ;Record predecessors of block
      do(#add-pred{_, b}, next(b))

   ;====== Propagating Liveness ======
   ;Propagation analysis of a block
   defn propagate-block-liveness () :
      fixpoint $ fn (progress) :
         let-var changed = progress :
            ;Propagate live-ins to live-outs
            for e in live-in-table do :
               val [b, x] = key(e)
               val d = value(e)
               for p in #pred(b) do :
                  #add-live-out(p, x, d)
            ;Propagate live-outs to live-ins
            for e in live-out-table do :
               val [b, x] = key(e)
               val d = value(e)
               if not #def?(b, x) :
                  #add-live-in(b, x, d + #length(b))

   ;====== Accumulate Live-in and Live-out Tables ======
   defn accumulate (t:HashTable<[Symbol,Symbol],?>) :
      val accum = HashTable<Symbol,List<Symbol>>(symbol-hash)
      for [k v] in keys(t) do :
         accum[k] = List(v, get?(accum, k, List()))
      accum

   do(compute-block-liveness, blocks(p))
   propagate-block-liveness()
   val live-in-lists = accumulate(live-in-table)
   val live-out-lists = accumulate(live-out-table)

   defn wrap-live (b:Block) :
      defn #var (xs:List<Symbol>) : map(Var, xs)
      defn #any (xs:List) : map(Status{false, false}, xs)
      defn #dist (xs:List<Symbol>) : map({live-out-table[[name(b), _]]}, xs)
      defn #live-in () : get?(live-in-lists, name(b), List())
      defn #live-out () : get?(live-out-lists, name(b), List())
      LBlock(name(b),
             exps(b),
             next(b),
             #var(#live-in())
             #any(#live-in())
             #var(#live-out())
             #any(#live-out())
             #dist(#live-out()))

   Program(map(wrap-live, blocks(p)))             


;====== Usage Table ======
defstruct Pos :
   i: Int
   mid?: True|False

defclass UsageTable <: Gettable<Pos, List<KeyValue<Symbol, Int>>>

defn hash (p:Pos) :
   match(mid?(p)) :
      (m:True) : i(p) * 2 + 1
      (m:False) : i(p) * 2

defn compute-usage-table (b:LBlock) :
   ;====== State ======
   val exps = to-array(exps(b))
   val n = length(exps)
   val dist-table = HashTable<Symbol,Int|False>(symbol-hash)
   val usages = Array<List<KeyValue<Symbol,Int>>>(n * 2 + 1)

   ;====== Utilities ======   
   defn set-usages (p:Pos, xs:List<KeyValue<Symbol,Int>>) : usages[hash(p)] = xs
   defn set-dist (x:Ref, d:Int|False) : dist-table[name(x)] = d
   defn set-dist (xs:List<Ref>, d:Int|False) : do(set-dist{_, d}, xs)
   defn set-dist (xs:List<Ref>, ds:List<Int|False>) : do(set-dist, xs, ds)
   defn live-vars () :
      val live-e = filter({value(_) typeof Int}, dist-table)
      to-list(live-e) as List<KeyValue<Symbol,Int>>

   ;====== Algorithm ======         
   set-dist(live-out(b), map({_ + n}, dist-out(b)))
   set-usages(Pos(n, false), live-vars())
   for i in (n - 1) through 0 by -1 do :
      ;Effect of defs
      match(exps[i]) :
         (e:Set) : set-dist(x(e), false)
         (e:Op) : set-dist(xs(e), false)
         (e:Args) : set-dist(xs(e), false)
         (e:Do) : set-dist(xs(e), false)
      set-usages(Pos(i, true), live-vars())
      ;Effect of uses
      match(exps[i]) :
         (e:Set) : set-dist(y(e), i)
         (e:Op) : set-dist(ys(e), i)
         (e:Args) : false
         (e:Do) : set-dist(ys(e), i)
      set-usages(Pos(i, false), live-vars())

   new UsageTable :
      defmethod get (this, p:Pos) : usages[hash(p)]
      


;====== Finite Register Allocation ======
defn finite-allocation (b:LBlock) :
   var num-reg = 0
   val N = 8
   val loaded = HashTable<Symbol,True|False>(symbol-hash)
   val exp-list = Vector<Exp>()
   val usage-table = compute-usage-table(b)

   defn emit (e:Exp) :
      add(exp-list, e)

   defn release (x:Symbol) :
      emit(Release(Var(x)))

   defn release (xs:Streamable<Symbol>) :
      do(release, xs)
   
   defn save (x:Symbol) :
      emit(Save(Var(x)))

   defn save (xs:Streamable<Symbol>) :
      do(save, xs)

   defn unload-all () :
      clear(loaded)
      num-reg = 0

   defn loaded? (x:Symbol) :
      get?(loaded, x, false)
      
   defn loaded? (x:Ref) :
      loaded?(name(x))

   defn loaded-vars () :
      filter(loaded?, keys(loaded))

   defn set-loaded (x:Symbol, v:True|False) :
      match(get?(loaded, x, false), v) :
         (l:False, v:True) :
            loaded[x] = v
            num-reg = num-reg + 1
         (l:True, v:False) :
            loaded[x] = v
            num-reg = num-reg - 1
         (l, v) :
            false            

   defn set-loaded (x:Ref, v:True|False) :
      if x not-typeof Dead :
         set-loaded(name(x), v)

   defn set-loaded (xs:List<Ref|Symbol>, v:True|False) :
      do(set-loaded{_, v}, xs)

   ;Find the variables used farthest from position p
   defn farthest-var (p:Pos) -> [List<Symbol>, Int|False] :
      val es = to-list $
         for v in loaded-vars() stream :
            v => lookup(usage-table[p], v)
      val dead = to-list $
         for e in es filter :
            value(e) == false
      if empty?(dead) :
         val e = maximum-by-key(es, value)
         [list(key(e)), value(e)]
      else :
         [map(key,dead), false]

   ;Ensure n registers are free, spilling if necessary.
   defn alloc-reg (p:Pos, n:Int) :
      while num-reg + n > N :
         val [vs, d] = farthest-var(p)
         save(vs) when d != false
         release(vs)
         set-loaded(vs, false)

   ;Load as many of xs as possible. Keep nearest used values in registers.
   defn load-nearest (p:Pos, xs:List<Ref>) :
      set-loaded(xs, true)
      alloc-reg(p, 0)

   ;Ensure that x is loaded at position p
   defn load (p:Pos, x:Ref) :
      alloc-reg(p, 1) when not loaded?(x)         
      emit(Load(x))
      set-loaded(x, true)

   defn load (p:Pos, xs:List<Ref>) :
      do(load{p, _}, xs)

   ;Get all live variables at position p
   defn live-vars (p:Pos) :
      stream(key, usage-table[p])

   defn keep-live (p:Pos, xs:List<Ref>) :
      val live = to-list(live-vars(p))
      for x in xs map :
         if contains?(live, name(x)) : x
         else : Dead()

   load-nearest(Pos(0, false), live-in(b))
   for (e in exps(b), i in 0 to false) do :
      match(e) :
         (e:Args) :
            val xs* = keep-live(Pos(i + 1, false), xs(e))
            emit(Args(xs*))
            load-nearest(Pos(i + 1, false), xs*)
         (e:Set) :
            load(Pos(i,false), y(e))
            alloc-reg(Pos(i,true), 1)
            emit(e)
            set-loaded(x(e), true)
         (e:Op) :
            load(Pos(i,false), ys(e))
            alloc-reg(Pos(i,true), length(xs(e)))
            emit(e)
            set-loaded(xs(e), true)
         (e:Do) :
            save(live-vars(Pos(i,true)))
            val xs* = keep-live(Pos(i + 1, false), xs(e))
            emit(Do(xs*, ys(e)))
            unload-all()
            load-nearest(Pos(i + 1, false), xs*)

   LBlock(name(b),
          to-list(exp-list),
          next(b),
          live-in(b),
          status-in(b),
          live-out(b),
          status-out(b),
          dist-out(b))



;====== Save/Load Elision ======
defstruct Any
defn save-load-elision (b:LBlock) :
   val saved = HashTable<Symbol,True|False|Any>(symbol-hash)
   val loaded = HashTable<Symbol,True|False|Any>(symbol-hash)
   var assumptions = Vector<Exp>()

   val save-buffer = HashTable<Symbol,True|False>(symbol-hash)
   val load-buffer = HashTable<Symbol,True|False>(symbol-hash)
   defn status (assumptions:Vector<Exp>, xs:List<Ref>) :
      clear(save-buffer)
      clear(load-buffer)
      for e in assumptions do :
         match(e) :
            (e:Save) : save-buffer[name(x(e))] = true
            (e:Load) : load-buffer[name(x(e))] = true
      for x in xs map :
         match(x) :
            (x:Dead) :
               Status(false, false)
            (x) :
               Status(get?(save-buffer, name(x), false)
                      get?(load-buffer, name(x), false))

   defn mark-loaded (x:Ref, v:True|False|Any) :
      if x not-typeof Dead :
         loaded[name(x)] = v

   defn mark-loaded (xs:List<Ref>, v:True|False|Any) :
      do(mark-loaded{_, v}, xs)
      
   defn mark-saved (x:Ref, v:True|False|Any) :
      if x not-typeof Dead :
         saved[name(x)] = v

   defn mark-saved (xs:List<Ref>, v:True|False|Any) :
      do(mark-saved{_, v}, xs)

   defn assume (e:Exp) :
      add(assumptions, e)

   defn saved-ref? (x:Ref) :
      get?(saved, name(x), false)
      
   defn loaded-ref? (x:Ref) :
      get?(loaded, name(x), false)

   defn elide (es:List<Exp>) -> List<Exp> :
      defn elide-and-gather (xs:List<Ref>, es:List<Exp>) :
         let-var assumptions = Vector<Exp>() :
            clear(loaded)
            mark-saved(xs, Any())
            mark-loaded(xs, Any())
            var body = elide(es)
            val ss = status(assumptions, xs)
            val xs* = for (x in xs, s in ss) map :
               match(x, saved?(s), loaded?(s)) :
                  (x:Dead, s, l) : x
                  (x, s:True, l:False) :
                     LVar(name(x), Stack())
                  (x, s:False, l:True) :
                     LVar(name(x), Reg())
                  (x, s:False, l:False) :
                     mark-loaded(x, true)
                     LVar(name(x), Reg())
                  (x, s:True, l:True) :
                     body = List(Save(x), body)
                     LVar(name(x), Reg())
            [xs*, body]

      if empty?(es) :
         List()
      else :   
         val e = head(es)
         val rest = tail(es)
         match(e) :
            (e:Args) :
               val [xs*, rest*] = elide-and-gather(xs(e), rest)
               List(Args(xs*), rest*)
            (e:Set) :
               mark-loaded(x(e), true)
               mark-saved(x(e), false)
               List(e, elide(rest))
            (e:Op) :           
               mark-loaded(xs(e), true)
               mark-saved(xs(e), false)
               List(e, elide(rest))
            (e:Do) :
               val [xs*, rest*] = elide-and-gather(xs(e), rest)
               List(Do(xs*, ys(e)), rest*)
            (e:Save) :
               match(saved-ref?(x(e))) :
                  (s:True) : elide(rest)
                  (s:False) : (mark-saved(x(e), true), List(e, elide(rest)))
                  (s:Any) : (assume(e), mark-saved(x(e), true), elide(rest))
            (e:Load) :
               match(loaded-ref?(x(e))) :
                  (l:True) : elide(rest)
                  (l:False) : (mark-loaded(x(e), true), List(e, elide(rest)))
                  (l:Any) : (assume(e), mark-loaded(x(e), true), elide(rest))
            (e:Release) :
               match(loaded-ref?(x(e))) :
                  (l:Any) : elide(rest)
                  (l) : List(e, elide(rest))

   mark-saved(live-in(b), Any())
   mark-loaded(live-in(b), Any())
   val exps* = elide(exps(b))
   val status-in* = status(assumptions, live-in(b))
   val status-out* = for x in live-out(b) map :
      val s = get?(saved, name(x), false) typeof True
      val l = get?(loaded, name(x), false) typeof True
      Status(s, l)
      
   LBlock(name(b),
          exps*,
          next(b),
          live-in(b),
          status-in*,
          live-out(b),
          status-out*,
          dist-out(b))

defn save-load-elision (p:Program) :
   Program(
      map(save-load-elision, blocks(p) as List<LBlock>))


;======== Register Assignment ========
defstruct Free
defn assign-registers (b:LBlock, locs-in:List<Loc>) :
   val N = 8
   val locations = HashTable<Symbol,Loc>(symbol-hash)
   val reg-free = Array<True|False>(N, true)
   val reg-values = Array<False|Symbol>(N, false)
   val exp-list = Vector<Exp>()
   val #free = Free()

   ;Basic Operations
   defn free-reg () :
      RegN(index-of(reg-free, true) as Int)
      
   defn free-reg (loc:Loc) :
      match(loc) :
         (loc:RegN) :
            if reg-free[n(loc)] : loc
            else : free-reg()
         (loc:Stack) : free-reg()

   defn assign-loc (ref:Ref, loc:Loc) :
      if loc typeof RegN :
         val loc = loc as RegN
         reg-free[n(loc)] = false
         val x = reg-values[n(loc)]
         if x typeof Symbol :
            locations[x as Symbol] = Stack()
         reg-values[n(loc)] = name(ref)
      locations[name(ref)] = loc   
      match(ref) :
         (ref:Var) : LVar(name(ref), loc)
         (ref:LVar) : LVar(name(ref), loc)

   defn assign-loc (refs:List<Ref>, f:Free) :
      for r in refs map :
         assign-loc(r, free-reg())

   defn update-loc (ref:Ref) :
      match(ref) :
         (ref:Var) : LVar(name(ref), locations[name(ref)])
         (ref:LVar) : LVar(name(ref), locations[name(ref)])
         (ref:Dead) : ref

   defn update-loc (refs:List<Ref>) :
      map(update-loc, refs)

   defn emit (e:Exp) :
      add(exp-list, e)

   ;Initial State
   val live-in* = for (x in live-in(b), s in status-in(b), l in locs-in) map :
      match(saved?(s), loaded?(s)) :
         (sv, ld:True) : assign-loc(x, free-reg(l))
         (sv:True, ld:False) : assign-loc(x, Stack())
         (sv:False, ld:False) : assign-loc(x, l)

   ;Assigning locations to expressions
   for e in exps(b) do :
      defn assign-arg-locs (xs:List<Ref>) :
         val arg-regs = map(RegN, to-array([2 3 4 5 6 7]))
         defn preferred (i:Int) :
            if i < length(arg-regs) : arg-regs[i]
            else : free-reg()
         for (x in xs, i in 0 to false) map :
            match(x) :
               (x:Dead) : x
               (x:LVar) :
                  match(loc(x)) :
                     (loc:Stack) : assign-loc(x, loc)
                     (loc:Reg) : assign-loc(x, preferred(i))

      match(e) :
         (e:Args) :
            val xs* = assign-arg-locs(xs(e))
            emit(Args(xs*))
         (e:Set) :
            val y* = update-loc(y(e))
            val x* = assign-loc(x(e), free-reg(loc(y* as LVar)))
            emit(Set(x*, y*))
         (e:Op) :         
            val ys* = update-loc(ys(e))
            val xs* = assign-loc(xs(e), #free)
            emit(Op(xs*, ys*))
         (e:Save) :
            val x* = update-loc(x(e))
            emit(Save(x*))
         (e:Load) :
            val x* = assign-loc(x(e), free-reg())
            emit(Load(x*))
         (e:Release) :
            val loc = locations[name(x(e))] as RegN
            reg-free[n(loc)] = true
         (e:Do) :
            val ys* = update-loc(ys(e))
            for v in keys(locations) do :
               locations[v] = Stack()
            do({reg-free[_] = true}, 0 to N)
            val xs* = assign-arg-locs(xs(e))
            emit(Do(xs*, ys*))

   ;Assign locations to live-out
   val live-out* = update-loc(live-out(b))

   ;Return filled block
   LBlock(name(b),
          to-list(exp-list),
          next(b),
          live-in*,
          status-in(b),
          live-out*,
          status-out(b),
          dist-out(b))
          
defn assign (p:Program) :
   ;Initialize Blocks
   val block-table = HashTable<Symbol,LBlock>(symbol-hash)
   val block-assigned? = HashTable<Symbol,True|False>(symbol-hash)
   for b in blocks(p) do :
      block-table[name(b)] = b as LBlock
      block-assigned?[name(b)] = false

   ;Rearrange locations: Rearrange locations of a to match against b
   defn rearrange (a:List<Ref>, b:List<Ref>, ls:List<Loc>) :
      val table = HashTable<Symbol,Loc>(symbol-hash)
      for (r in a, l in ls) do : table[name(r)] = l
      for r in b map : table[name(r)]

   defn get-loc (x:Ref) :
      loc(x as LVar)
      
   defn get-loc (xs:List<Ref>) :
      map(get-loc, xs)      

   defn loop (b:LBlock, locs-in:List<Loc>) :
      if length(locs-in) != length(live-in(b)) :
         error("Number of locs-in does not match number of live-in.")
      val b* = assign-registers(b, locs-in)
      block-table[name(b)] = b*
      block-assigned?[name(b)] = true
      for n in next(b*) do :
         if not block-assigned?[n] :
            val nb = block-table[n]
            val locs = rearrange(live-out(b*),
                                 live-in(nb),
                                 get-loc(live-out(b*)))
            loop(nb, locs)

   val entry = head(blocks(p)) as LBlock
   loop(entry, List())

   ;Return new program
   Program(map({block-table[name(_)]}, blocks(p)))
      
;======== Stack Interval Calculation ==========
defn calculate-stack-intervals (p:Program) :
   val block-table = HashTable<Symbol,LBlock>(symbol-hash)
   val block-start = HashTable<Symbol,Int>(symbol-hash)
   val block-end = HashTable<Symbol,Int>(symbol-hash)
   val block-preds = HashTable<Symbol,List<Symbol>>(symbol-hash)
   val min-table = HashTable<Symbol,Int>(symbol-hash)
   val max-table = HashTable<Symbol,Int>(symbol-hash)
   val scanned = HashTable<Symbol,True>(symbol-hash)
   val scan-queue = Queue<LBlock>()
   var index = 0

   defn on-stack? (x:Ref) :
      match(x) :
         (x:LVar) : loc(x) typeof Stack
         (x) : false

   defn on-stack (xs:List<Ref>) :
      filter(on-stack?, xs)

   defn used (x:Ref, index:Int) :
      val nx = name(x)
      if key?(min-table, name(x)) :
         min-table[nx] = min(index, min-table[nx])
         max-table[nx] = max(index, max-table[nx])
      else :
         min-table[nx] = index
         max-table[nx] = index

   defn used (xs:Streamable<Ref>, index:Int) :
      do(used{_, index}, xs)

   defn step () :
      index = index + 1

   defn get-preds (n:Symbol) :
      get?(block-preds, n, List())

   ;Register blocks
   for b in blocks(p) do :
      block-table[name(b)] = b as LBlock
      
   ;Process blocks   
   add(scan-queue, head(blocks(p)) as LBlock)
   while not empty?(scan-queue) :
      val b = pop(scan-queue)
      if not key?(scanned, name(b)) :
         ;Note Start Index
         block-start[name(b)] = index
         ;Note Expressions
         for e in exps(b) do :
            match(e) :
               (e:Args) : used(on-stack(xs(e)), index)
               (e:Op) : false
               (e:Save) : used(x(e), index)
               (e:Load) : used(x(e), index)
               (e:Do) :
                  used(on-stack(ys(e)), index)
                  step()
                  used(on-stack(xs(e)), index)
            step()
         ;Note End Index
         block-end[name(b)] = index
         step()
         ;Register Next Blocks
         for n in next(b) do :
            add(scan-queue, block-table[n])
            block-preds[n] = List(name(b), get-preds(n))

   ;Process Live in
   for b in values(block-table) do :
      defn saved (xs:List<Ref>, ss:List<Status>) :
         for (x in xs, s in ss) filter :
            saved?(s) or on-stack?(x)
         
      for x in saved(live-in(b), status-in(b)) do :
         used(x, block-start[name(b)])
         for p in get-preds(name(b)) do :
            used(x, block-end[p])

   ;Accumulate Results
   val interval-starts = Array<List<Symbol>>(index, List())
   val interval-ends = Array<List<Symbol>>(index, List())
   for v in keys(min-table) do :
      val i = min-table[v]
      val j = max-table[v]
      interval-starts[i] = List(v, interval-starts[i])
      interval-ends[j] = List(v, interval-ends[j])
   val r = [interval-starts, interval-ends]

   ;Print Result
   for i in 0 to length(interval-starts) do :
      println("~: START(~@) END(~@)" << [i, interval-starts[i], interval-ends[i]])

   r


;====== Stack Location Calculation ======
defn calculate-stack-locations (p:Program) :
   val location-table = HashTable<Symbol,Int>(symbol-hash)
   val [starts, ends] = calculate-stack-intervals(p)
   val location-free = Vector<True|False>()
   val N = length(starts)

   defn get-free-location () :
      match(index-of(location-free, true)) :
         (i:Int) : i
         (i:False) :
            add(location-free, true)
            length(location-free) - 1

   defn assign-free-location (x:Symbol) :
      val i = get-free-location()
      location-table[x] = i
      location-free[i] = false

   defn release-location (x:Symbol) :
      val i = location-table[x]
      location-free[i] = true

   defn assign-free-location (xs:List<Symbol>) :
      do(assign-free-location, xs)

   defn release-location (xs:List<Symbol>) :
      do(release-location, xs)

   for i in 0 to N do :
      assign-free-location(starts[i])
      release-location(ends[i])

   ;Print Result
   println("Location Table")
   do(println, location-table)

   location-table


;========= Glue Blocks ========
defn glue-blocks (p:Program) :
   ;Parallel Move
   defn par-move (src:List<Ref>, src-status:List<Status>,
                  dst:List<Ref>, dst-status:List<Status>) :
      val src-loc-table = HashTable<Symbol,Loc>(symbol-hash)
      val dst-loc-table = HashTable<Symbol,Loc>(symbol-hash)
      val src-status-table = HashTable<Symbol,Status>(symbol-hash)
      val dst-status-table = HashTable<Symbol,Status>(symbol-hash)
      val RS-moves = Vector<Save>()
      val RR-srcs = Vector<Ref>()
      val RR-dsts = Vector<Ref>()
      val SR-moves = Vector<Load>()
      
      ;Initialize Tables
      for (x in src, s in src-status) do :
         src-loc-table[name(x)] = loc(x as LVar)
         src-status-table[name(x)] = s
      for (x in dst, s in dst-status) do :
         dst-loc-table[name(x)] = loc(x as LVar)
         dst-status-table[name(x)] = s

      defn stack-dst? (x:Ref) :
         dst-loc-table[name(x)] typeof Stack
      defn reg-dst? (x:Ref) :
         dst-loc-table[name(x)] typeof RegN
      defn stack-src? (x:Ref) :
         src-loc-table[name(x)] typeof Stack
      defn reg-src? (x:Ref) :
         src-loc-table[name(x)] typeof RegN
      defn save-dst? (x:Ref) :
         saved?(dst-status-table[name(x)])
      defn save-src? (x:Ref) :
         saved?(src-status-table[name(x)])
      defn get-src (x:Ref) :
         LVar(name(x), src-loc-table[name(x)])
      defn get-dst (x:Ref) :
         LVar(name(x), dst-loc-table[name(x)])
                  
      for x in dst do :
         if (stack-dst?(x) or save-dst?(x)) and not
            (stack-src?(x) or save-src?(x)) :
            add(RS-moves, Save(get-src(x)))
         else if reg-dst?(x) and reg-src?(x) :
            add(RR-srcs, get-src(x))
            add(RR-dsts, get-dst(x))
         else if reg-dst?(x) and stack-src?(x) :
            add(SR-moves, Load(get-dst(x)))

      concat-all $ [
         RS-moves
         [ParSet(to-list(RR-dsts), to-list(RR-srcs))]
         SR-moves]

   ;Glue Blocks
   val block-table = HashTable<Symbol,LBlock>(symbol-hash)
   for b in blocks(p) do :
      block-table[name(b)] = b as LBlock

   defn update-exps (b:LBlock, exps:List<Exp>) :
      LBlock(name(b),
             exps,
             next(b),
             live-in(b),
             status-in(b),
             live-out(b)
             status-out(b),
             dist-out(b))

   for b in values(block-table) do :
      if length(next(b)) == 1 :
         val b2 = block-table[head(next(b))] as LBlock
         val exps* = to-list $ concat(exps(b),
            par-move(live-out(b), status-out(b),
                     live-in(b2), status-in(b2)))
         block-table[name(b)] = update-exps(b, exps*)
      else :
         for n in next(b) do :
            val b2 = block-table[n] as LBlock
            val exps* = to-list $ concat(
               par-move(live-out(b), status-out(b),
                        live-in(b2), status-in(b2))
               exps(b2))
            block-table[name(b2)] = update-exps(b2, exps*)   

   Program(map({block-table[name(_)]}, blocks(p)))

;========= Driver ========
defn allocate (p:Program) :
   val bs* = for b in blocks(p) map :
      save-load-elision $
      finite-allocation $      
      b as LBlock
   Program(bs*)

;========= Driver ======================
defn test (p:Program) :
   println("====== Test ======")
   println(p)
   println("====== Remove critical edges ======")
   val p1 = remove-critical-edges(p)
   println(p1)
   println("====== Liveness Analysis ======")
   val p2 = liveness-analysis(p1)
   println(p2)
   println("====== Allocation ======")
   val p3 = allocate(p2)
   println(p3)
   println("====== Assignment ======")
   val p4 = assign(p3)
   println(p4)
   println("====== Calculate Stack Locations ======")
   calculate-stack-locations(p4)
   println("====== Glue Blocks ======")
   val p5 = glue-blocks(p4)
   println(p5)
   println("==================\n\n\n")

defn main () :
   val filename = commandline-arguments()[1]
   val progs = parse-regir(filename)   
   do(test, progs)

main()