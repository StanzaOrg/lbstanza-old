#include<"core/stringeater.stanza">
#include<"compiler/stz-algorithms.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">

defpackage regalloc :
   import core
   import verse
   import stz/lexer
   import stz/parser
   import stz/algorithms

;=============================================
;============== Input IR =====================
;=============================================
defstruct Var :
   name: Symbol
   loc: Loc

definterface Type
defstruct ByteType <: Type
defstruct IntType <: Type
defstruct LongType <: Type
defstruct RefType <: Type
defstruct FloatType <: Type
defstruct DoubleType <: Type

definterface OpClass
defstruct ComOp <: OpClass
defstruct BinDivOp <: OpClass

definterface Loc
defstruct NoLoc <: Loc
defstruct Reg <: Loc :
   n: Int
defstruct Stack <: Loc :
   n: Int

definterface Exp
defstruct Args <: Exp :
   xs: List<Var>
defstruct Set <: Exp :
   x: Var
   y: Var
defstruct Op <: Exp :
   op: OpClass
   xs: List<Var>
   ys: List<Var>
defstruct Do <: Exp :
   f: False|Var
   xs: List<Var>
   ys: List<Var>
defstruct Goto <: Exp :
   name: Symbol

definterface Block
defmulti name (b:Block) -> Symbol
defmulti exps (b:Block) -> List<Exp>
defmulti next (b:Block) -> List<Symbol>

defstruct SBlock <: Block :
   name: Symbol with : (as-method => true)
   exps: List<Exp> with : (as-method => true)
   next: List<Symbol> with : (as-method => true)
with :
   constructor => Block

defstruct Def :
   name: Symbol
   type: Type
   sloc: Loc

defstruct Unit :
   defs: List<Def>
   blocks: List<Block>

;============================================================
;===================== Parser ===============================
;============================================================
defsyntax regir :
   val ut = unwrap-token

   defrule :
      sym = (?x) when ut(x) typeof Symbol : ut(x)
      int = (?x) when ut(x) typeof Int : ut(x)

      loc = (Reg(?n:#int)) : Reg(n)
      loc = (Stack(?n:#int)) : Stack(n)
      var = (?x:#sym) : Var(x, NoLoc())

      exp = ((?xs:#var ...) = Args) :
         Args(xs)
      exp = (?x:#var = ?y:#var) :
         Set(x, y)
      exp = ((?xs:#var ...) = com(?ys:#var ...)) :
         Op(ComOp(), xs, ys)
      exp = ((?xs:#var ...) = bindiv(?ys:#var ...)) :
         Op(BinDivOp(), xs, ys)
      exp = ((?xs:#var ...) = f(?ys:#var ...)) :
         Do(false, xs, ys)
      exp = ((?xs:#var ...) = [?f:#var](?ys:#var ...)) :
         Do(f, xs, ys)

      block = (block ?name:#sym :
                  ?es:#exp ...
                  goto (?ns:#sym ...)) :
         Block(name, es, ns)

      type = (byte) : ByteType()
      type = (int) : IntType()
      type = (long) : LongType()
      type = (ref) : RefType()
      type = (float) : FloatType()
      type = (double) : DoubleType()
      def = (def ?x:#sym : ?t:#type at ?l:#loc) : Def(x, t, l)
      def = (def ?x:#sym : ?t:#type) : Def(x, t, NoLoc())

      unit = (unit : (?ds:#def ... ?bs:#block ...)) :
         Unit(ds, bs)

defn parse-regir (filename:String) -> List<Unit> :
   val lexed = lex-file(filename)
   with-syntax(regir) :
      match-syntax(lexed) :
         (?us:#unit ...) : us

;============================================================
;==================== Printing ==============================
;============================================================
defn cms (xs) : join(xs, ", ")

defmethod print (o:OutputStream, p:Unit) :
   print(o, "unit : ")
   for d in defs(p) do :
      print(o, "\n   ~" << [d])
   for b in blocks(p) do :
      print(o, "\n   ~" << [b])

defmethod print (o:OutputStream, d:Def) :
   print(o, "def ~:~ at ~" << [
      name(d),
      type(d),
      sloc(d)])

defmethod print (o:OutputStream, b:SBlock) :
   print(o, "block ~ :" << [name(b)])
   for e in exps(b) do :
      print(o, "\n      ~" << [e])
   print(o, "\n      goto (~@)" << [cms(next(b))])

defmethod print (o:OutputStream, t:Type) :
   print{o, _} $ match(t) :
      (t:ByteType) : "byte"
      (t:IntType) : "int"
      (t:LongType) : "long"
      (t:RefType) : "ref"
      (t:FloatType) : "float"
      (t:DoubleType) : "double"

defmethod print (o:OutputStream, c:OpClass) :
   print{o, _} $ match(c) :
      (c:ComOp) : "com"
      (c:BinDivOp) : "bindiv"

defmethod print (o:OutputStream, l:Loc) :
   print{o, _} $ match(l) :
      (l:NoLoc) : "NoLoc"
      (l:Reg) : "Reg(~)" << [n(l)]
      (l:Stack) : "Stack(~)" << [n(l)]

defmethod print (o:OutputStream, v:Var) :
   match(loc(v)) :
      (l:NoLoc) : print(o, name(v))
      (l) : print(o, "~:~" << [name(v), l])

defmethod print (o:OutputStream, e:Exp) :
   print{o, _} $ match(e) :
      (e:Args) : "(~@) = Args" << [cms(xs(e))]
      (e:Set) : "~ = ~" << [x(e), y(e)]
      (e:Op) : "(~@) = ~(~@)" << [cms(xs(e)), op(e), cms(ys(e))]
      (e:Do) :
         match(f(e)) :
            (f:False) : "(~@) = f(~@)" << [cms(xs(e)), cms(ys(e))]
            (f:Var) : "(~@) = [~](~@)" << [f, cms(xs(e)), cms(ys(e))]
      (e:Goto) : "goto ~" << [name(e)]

;============================================================
;==================== Working IR ============================
;============================================================

definterface Working

defstruct WArgs <: Exp&Working :
   xs: List<Port>

defstruct WDo <: Exp&Working :
   f: False|Var
   xs: List<Port>
   ys: List<Var>

defstruct Save <: Exp&Working :
   x: Var
   
defstruct Load <: Exp&Working :
   x: Var

defstruct Unload <: Exp&Working :
   x: Var

defstruct Xchg <: Exp&Working :
   x: Var
   y: Var
   swap: Reg|False

defmethod print (o:OutputStream, e:Exp&Working) :
   print{o, _} $ match(e) :
      (e:WArgs) : "(~@) = Args" << [cms(xs(e))]
      (e:WDo) : 
         match(f(e)) :
            (f:False) : "(~@) = f(~@)" << [cms(xs(e)), cms(ys(e))]
            (f:Var) : "(~@) = [~](~@)" << [f, cms(xs(e)), cms(ys(e))]
      (e:Save) : "save ~" << [x(e)]
      (e:Load) : "load ~" << [x(e)]
      (e:Unload) : "unload ~" << [x(e)]
      (e:Xchg) : "xchg ~ ~ through ~" << [x(e), y(e), swap(e)]

defstruct Any
defmethod print (o:OutputStream, x:Any) :
   print(o, "any")

defstruct WBlock <: Block :
   name: Symbol with : (as-method => true)
   exps: List<Exp> with : (as-method => true)
   next: List<Symbol> with : (as-method => true)
   in: List<LivePort>
   out: List<LivePort>
   dist: List<Int>

definterface Port
defstruct LivePort <: Port :
   name: Symbol
   saved?: True|False|Any
   loaded?: True|False|Any
   loc: Loc
defstruct DeadPort <: Port

defmethod print (o:OutputStream, p:Port) :
   print{o, _} $ match(p) :
      (p:LivePort) : "~ (s:~, l:~, at:~)" << [name(p), saved?(p), loaded?(p), loc(p)]
      (p:DeadPort) : "dead"

defmethod print (o:OutputStream, b:WBlock) :
   print(o, "block ~ :" << [name(b)])
   print(o, "\n      in: ~@" << [cms(in(b))])
   for e in exps(b) do :
      print(o, "\n      ~" << [e])
   print(o, "\n      goto (~@)" << [cms(next(b))])
   print(o, "\n      out: ~@" << [cms(out(b))])
   print(o, "\n      dist: ~@" << [cms(dist(b))])

;============================================================
;================== Block Liveness ==========================
;============================================================

defn liveness-analysis (u:Unit) :
   defn assoc-blocks (u:Unit, bs:List<Block>) : Unit(defs(u), bs)
   defn bhash ([b,x]:[Symbol,Symbol]) : 7 * symbol-hash(b) + symbol-hash(x)
   val defs = HashTable<[Symbol,Symbol],True>(bhash)
   val ins = HashTable<[Symbol,Symbol],False|Int>(bhash)

   ;Find all immediate defs and live-ins
   do(find-defs-uses, blocks(u)) where :
      defn find-defs-uses (b:Block) :
         defn key (x:Var) : [name(b), name(x)]
         defn #def (x:Var) :
            defs[key(x)] = true
            ins[key(x)] = false
         defn #use (x:Var, i:Int) : ins[key(x)] = i
         defn #use (x:False, i:Int) : false
         defn #def (xs:List<Var>) : do(#def, xs)
         defn #use (xs:List<Var>, i:Int) : do(#use{_, i}, xs)
         
         val n = length(exps(b))
         for (e in reverse(exps(b)), i in (n - 1) through 0 by -1) do :
            match(e) :
               (e:Op) : (#def(xs(e)), #use(ys(e), i))
               (e:Do) : (#def(xs(e)), #use(f(e), i), #use(ys(e), i))
               (e:Args) : (#def(xs(e)))
               (e) : error("Block liveness must be updated to handle other constructs.")

   ;Find all block predecessors and block lengths
   val preds = HashTable<Symbol,List<Symbol>>(symbol-hash)
   val lengths = HashTable<Symbol,Int>(symbol-hash)
   for b in blocks(u) do :
      preds[name(b)] = List()
      lengths[name(b)] = length(exps(b))
   for b in blocks(u) do :
      for n in next(b) do :
         preds[n] = List(name(b), preds[n])

   ;Iterate through a table of live vars
   defn do-for-live (f: [Symbol,Symbol,Int] -> False,
                     es: HashTable<[Symbol,Symbol],False|Int>) :
      for entry in es do :
         if value(entry) != false :
            val [b,x] = key(entry)
            f([b, x, value(entry) as Int])

   ;Propagate block liveness results
   val outs = HashTable<[Symbol,Symbol],Int>(bhash)
   fixpoint $ fn (progress) :
      defn add-live (live:HashTable<[Symbol,Symbol],False|Int>,
                     b:Symbol, x:Symbol, d:Int) :
         match(get?(live, [b,x], false)) :
            (d2:Int) :
               if d < d2 :
                  live[[b,x]] = d
                  progress()
            (d2:False) :
               live[[b,x]] = d
               progress()

      for [b,x,d] in ins do-for-live :
         for p in preds[b] do : add-live(outs, p, x, d)
      for [b,x,d] in outs do-for-live :
         if not key?(defs, [b,x]) :
            add-live(ins, b, x, d + lengths[b])

   ;Create results table
   defn to-port (x:Symbol) : LivePort(x, Any(), Any(), NoLoc())
   val in-lists = HashTable<Symbol,List<Symbol>>(symbol-hash)
   val out-lists = HashTable<Symbol,List<Symbol>>(symbol-hash)
   val dist-lists = HashTable<Symbol,List<Int>>(symbol-hash)
   for [b,x,d] in ins do-for-live :
      in-lists[b] = List(x, get?(in-lists, b, List()))
   for [b,x,d] in outs do-for-live :
      out-lists[b] = List(x, get?(out-lists, b, List()))
      dist-lists[b] = List(d, get?(dist-lists, b, List()))
      
   assoc-blocks{u, _} $
      for b in blocks(u) map :
         WBlock(name(b),
                exps(b),
                next(b),
                map(to-port, get?(in-lists, name(b), List()))
                map(to-port, get?(out-lists, name(b), List()))
                get?(dist-lists, name(b), List()))
          
;============================================================
;==================== Usage Table ===========================
;============================================================

defclass UsageTable <: Gettable<Pos,List<KeyValue<Symbol,Int>>>

defstruct Pos :
   index: Int
   mid?: True|False

defn less-eq? (a:Pos, b:Pos) :
   if index(a) < index(b) :
      true
   else if index(a) == index(b) :
      match(mid?(a)) :
         (x:False) : true
         (x:True) : mid?(b)

defmethod print (o:OutputStream, p:Pos) :
   print(o, "~~" << [
      index(p),
      ".5" when mid?(p) else ""])

defn hash (p:Pos) :
   match(mid?(p)) :
      (m:True) : index(p) * 2 + 1
      (m:False) : index(p) * 2

defn usage-table (b:WBlock) :
   val dsts = HashTable<Symbol,False|Int>(symbol-hash)
   val n = length(exps(b))
   val len = hash(Pos(n, false)) + 1
   val uses = Array<List<KeyValue<Symbol,Int>>>(len, List())

   defn set-dist (x:Symbol, i:False|Int) :
      dsts[x] = i
   defn set-dist (x:Var, i:False|Int) :
      set-dist(name(x), i)
   defn set-dist (x:Port, i:False|Int) :
      match(x) :
         (x:LivePort) : set-dist(name(x), i)
         (x) : false
   defn set-dist (x:False, i:False|Int) :
      false
   defn set-dist (xs:List<Symbol>, i:False|Int) :
      do(set-dist{_, i}, xs)   
   defn set-dist (xs:List<Var>, i:False|Int) :
      do(set-dist{_, i}, xs)
   defn set-dist (xs:List<Port>, i:False|Int) :
      do(set-dist{_, i}, xs)

   defn set-uses (p:Pos, us:List<KeyValue<Symbol,Int>>) :
      uses[hash(p)] = us
      
   defn current-uses (i:Int) :
      var es = for e in dsts stream :
         match(value(e)) :
            (v:Int) : key(e) => v - i
            (v:False) : false
      es = for e in es filter :
         e != false
      to-list(es) as List<KeyValue<Symbol,Int>>

   do(set-dist{_, _ + n}, out(b), dist(b))
   set-uses(Pos(n,false), current-uses(n))
   for (e in reverse(exps(b)), i in (n - 1) through 0 by -1) do :
      match(e) :
         (e:Op) :
            set-dist(xs(e), false)
            set-uses(Pos(i,true), current-uses(i))
            set-dist(ys(e), i)
            set-uses(Pos(i,false), current-uses(i))
         (e:Save) :
            set-uses(Pos(i,true), current-uses(i))
            set-uses(Pos(i,false), current-uses(i))
         (e:Load) :
            set-dist(x(e), false)
            set-uses(Pos(i,true), current-uses(i))
            set-uses(Pos(i,false), current-uses(i))
         (e:WDo) :
            set-dist(xs(e), false)
            set-uses(Pos(i,true), current-uses(i))
            set-dist(ys(e), i)
            set-dist(f(e), i)
            set-uses(Pos(i,false), current-uses(i))
         (e:WArgs) :
            set-dist(xs(e), false)
            set-uses(Pos(i,true), current-uses(i))
            set-uses(Pos(i,false), current-uses(i))
         (e) :
            error("Usage Table: Handle other constructs")

   new UsageTable :
      defmethod get (this, p:Pos) :
         uses[hash(p)]
      defmethod print (o:OutputStream, this) :
         for i in 0 to n do :
            if i > 0 : print(o, "\n")
            print(o, "~ => (~@)" << [
               Pos(i, false), cms(this[Pos(i, false)])])
            print(o, "\n~ => (~@)" << [
               Pos(i, true), cms(this[Pos(i, true)])])
         print(o, "\n~ => (~@)" << [
            Pos(n, false), cms(this[Pos(n, false)])])


;============================================================
;================== Release Table ===========================
;============================================================

defclass ReleaseTable
defmulti releases-up-to (r:ReleaseTable, p:Pos) -> Stream<Symbol>

defn release-table (b:WBlock) :
   val live-table = HashTable<Symbol,True|False>(symbol-hash)
   val release-list = Vector<KeyValue<Pos,Symbol>>()

   ;Utilities
   ;Clear the live-table. No variables are live.
   defn clear-live () :
      clear(live-table)

   ;Mark a variable as live or not.
   ;Mark a port as live only if it is loaded.
   defn mark-live (x:Symbol, v:True|False) :
      live-table[x] = v
   defn mark-live (x:Var, v:True|False) :
      mark-live(name(x), v)
   defn mark-live (x:Port, v:True|False) :
      match(x) :
         (x:LivePort) :
            if loaded?(x) not-typeof False :
               mark-live(name(x), v)
         (x) : false
   defn mark-live (x:False, v:True|False) :
      false
   defn mark-live (xs:List<Var|Port>, v:True|False) :
      do(mark-live{_, v}, xs)

   ;Record variable x as being released at position p
   defn release-if-not-live (p:Pos, x:Symbol) :
      if not get?(live-table, x, false) :
         add(release-list, p => x)
   defn release-if-not-live (p:Pos, x:Var) :
      release-if-not-live(p, name(x))
   defn release-if-not-live (p:Pos, x:False) :
      false
   defn release-if-not-live (p:Pos, x:Port) :
      match(x) :
         (x:LivePort) : release-if-not-live(p, name(x))
         (x) : false
   defn release-if-not-live (p:Pos, xs:List<Var|Port>) :
      do(release-if-not-live{p, _}, xs)

   ;Initialize live-out as live
   mark-live(out(b), true)
      
   ;Analyze expression list
   val num-exps = length(exps(b))
   for (e in reverse(exps(b)), i in (num-exps - 1) through 0 by -1) do :
      match(e) :
         (e:Op) :
            release-if-not-live(Pos(i + 1, false), xs(e))
            mark-live(xs(e), false)
            release-if-not-live(Pos(i, true), ys(e))
            mark-live(ys(e), true)
         (e:Save) :
            release-if-not-live(Pos(i, true), x(e))
            mark-live(x(e), true)
         (e:Load) :
            release-if-not-live(Pos(i + 1, false), x(e))
            mark-live(x(e), false)            
         (e:WArgs) :
            release-if-not-live(Pos(i + 1, false), xs(e))
            mark-live(xs(e), false)
         (e:WDo) :
            release-if-not-live(Pos(i + 1, false), xs(e))
            clear-live()
            release-if-not-live(Pos(i, true), f(e))
            release-if-not-live(Pos(i, true), ys(e))
            mark-live(f(e), true)
            mark-live(ys(e), true)
         (e) :
            error("Release Table: Handle other constructs")

   ;Return release table
   new ReleaseTable :
      defmethod releases-up-to (this, p:Pos) :
         generate<Symbol> :
            defn* loop () :
               if not empty?(release-list) :
                  val r = peek(release-list)
                  if key(r) <= p :
                     yield(value(r))
                     pop(release-list)
                     loop()
            loop()         


;============================================================
;==================== Save Emission =========================
;============================================================

defn save-semantics (b:WBlock) :
   ;State of the future
   val requires-saved = HashTable<Symbol,True|False>(symbol-hash)
   val is-live = HashTable<Symbol,True|False>(symbol-hash)
   val prefer-loaded = HashTable<Symbol,True|False>(symbol-hash)

   ;Output
   val exp-list = Vector<Exp>()

   ;Initialize state
   for x in out(b) do :
      is-live[name(x)] = true
      prefer-loaded[name(x)] = true
      requires-saved[name(x)] = false

   ;Summarize current variable statistics as port
   defn as-port (x:Symbol) :
      val lv = get?(is-live, x, false)
      val sv = get?(requires-saved, x, false)
      val ld = get?(prefer-loaded, x, true)
      match(lv, sv, ld) :
         (lv:False, sv, ld) : DeadPort()
         (lv:True, sv:False, ld:False) : LivePort(x, Any(), false, NoLoc())
         (lv:True, sv:False, ld:True) : LivePort(x, Any(), Any(), NoLoc())
         (lv:True, sv:True, ld:False) : LivePort(x, true, false, NoLoc())
         (lv:True, sv:True, ld:True) : LivePort(x, true, Any(), NoLoc())

   defn as-port (x:Var) :
      as-port(name(x))

   ;Insert saves to expressions
   for e in reverse(exps(b)) do :

      defn defd (x:Var) :
         is-live[name(x)] = false
         requires-saved[name(x)] = false
         prefer-loaded[name(x)] = false

      defn used (x:Var) :
         is-live[name(x)] = true
         prefer-loaded[name(x)] = true

      defn lived (x:Symbol) :
         requires-saved[x] = true
         prefer-loaded[x] = false

      defn currently-live () :
         stream(key, filter(value, is-live))
         
      match(e) :
         (e:Op) :
            for x in xs(e) do :
               if get?(requires-saved, name(x), false) :
                  add(exp-list, Save(x))
            add(exp-list, e)
            do(defd, xs(e))
            do(used, ys(e))
            
         (e:Do) :
            val xp = map(as-port, xs(e))
            add(exp-list, WDo(f(e), xp, ys(e)))
            do(defd, xs(e))
            do(lived, currently-live())
            do(used, ys(e))
            used(f(e) as Var) when f(e) != false
            
         (e:Args) :
            val xp = map(as-port, xs(e))
            add(exp-list, WArgs(xp))
            do(defd, xs(e))

         (e) :
            error("Save semantics: Handle other constructs.")

   val in* = for x in in(b) map :
      as-port(name(x)) as LivePort

   ;Return results
   defn in-reverse<?T> (xs:Vector<?T>) :
      for i in (length(xs) - 1) through 0 by -1 stream :
         xs[i]
   
   WBlock(name(b),
          to-list(in-reverse(exp-list)),
          next(b),
          in*,
          out(b),
          dist(b))

;============================================================
;=================== Class Allocation =======================
;============================================================

;Make a Var just from its name
defn Var (x:Symbol) -> Var :
   Var(x, NoLoc())

defn class-allocation (b:WBlock) :
   ;The resulting expression list
   val exp-list = Vector<Exp>()
   defn emit (e:Exp) :
      add(exp-list, e)

   ;Tracks the number of free registers
   var num-free-reg = 8

   ;Spill function
   var spill-next: () -> ? = error{"No Spill function."}

   ;Save/Load Status
   val saved = HashTable<Symbol,True|False|Any|None>(symbol-hash)
   val loaded = HashTable<Symbol,True|False|Any|None>(symbol-hash)

   defn save (x:Symbol) :
      match(get?(saved, x, None())) :
         (s:True) : false
         (s:False) : emit(Save(Var(x)))
         (s:Any) : emit(Save(Var(x)))
         (s:None) : error("~ not live." % [x])
      saved[x] = true

   defn load (x:Symbol) :
      match(get?(loaded, x, None())) :
         (l:True) :
            false
         (l:False) :
            spill-next() when num-free-reg <= 0
            emit(Load(Var(x)))
            num-free-reg = num-free-reg - 1
         (l:Any) :
            emit(Load(Var(x)))
         (l:None) :
            error("~ not live." % [x])
      loaded[x] = true

   defn unload (x:Symbol) :
      match(get?(loaded, x, None())) :
         (l:True) :
            emit(Unload(Var(x)))
            num-free-reg = num-free-reg + 1
         (l:False) :
            false
         (l:Any) :
            emit(Unload(Var(x)))
            num-free-reg = num-free-reg + 1
         (l:None) :
            error("~ is not live." % [x])
      loaded[x] = false

   defn die (x:Symbol) :
      match(get?(loaded, x, None())) :
         (l:True) : num-free-reg = num-free-reg + 1
         (l:Any) : error("~ should not be loaded." % [x])
         (l:False) : false
         (l:None) : false
      loaded[x] = None()

   defn def (x:Var) :
      match(get?(loaded, name(x), None())) :
         (l:True) : error("~ has not been released." % [name(x)])
         (l:False) : num-free-reg = num-free-reg - 1
         (l:Any) : error("~ has not been released." % [name(x)])
         (l:None) : num-free-reg = num-free-reg - 1
      loaded[name(x)] = true
      saved[name(x)] = false

   defn def (x:Port) :
      match(x) :
         (x:LivePort) :
            if get?(loaded, name(x), None()) not-typeof None :
               error("~ should not be live." % [name(x)])
            match(loaded?(x)) :
               (l:True) : error("~ cannot be loaded." % [name(x)])
               (l:False) :
                  loaded[name(x)] = false
               (l:Any) :
                  loaded[name(x)] = Any()
                  num-free-reg = num-free-reg - 1
            match(saved?(x)) :
               (l:True) : saved[name(x)] = true
               (l:Any) : saved[name(x)] = Any()
               (l:False) : error("~ cannot be not saved." % [name(x)])
         (x:DeadPort) :
            false

   ;Spilling Calculations
   val ut = usage-table(b)
   val use-cache = HashTable<Symbol,Int>(symbol-hash)
   val spill-cache = Vector<Symbol>()
   defn spill-at (p:Pos, f: () -> ?) :
      var cached = false
      defn spill () :
         if not cached :
            ;Reload the use cache
            clear(use-cache)
            for use in ut[p] do :
               use-cache[key(use)] = value(use)
            ;Reload the spill cache
            clear(spill-cache)
            for e in loaded do :
               add(spill-cache, key(e)) when value(e) typeof True|Any
            sort-by-key!(spill-cache, {use-cache[_]})
            ;Mark as cached
            cached = true
         
         val x = pop(spill-cache)
         save(x)
         unload(x)         
      let-var spill-next = spill :
         f()
         
   ;Tracks the release of variables
   val rt = release-table(b)
   defn* release-up-to (p:Pos) :
      do(die, releases-up-to(rt, p))

   ;Ensure variable's xs are loaded for position p
   defn ensure-loaded (p:Pos, xs:List<Var>) :
      spill-at{p, _} $ fn () :
         do(load{name(_)}, xs)

   ;Ensure enough registers are free for defining xs at position p
   defn defined (p:Pos, xs:List<Var>) :
      spill-at{p, _} $ fn () :
         while num-free-reg < length(xs) :
            spill-next()
      do(def, xs)      

   ;Reserve registers for as many live-in variables as possible
   defn defined (p:Pos, xs:List<Port>) :
      do(def, xs)
      spill-at{p, _} $ fn () :
         while num-free-reg < 0 :
            spill-next()
         
   ;Allocate location classes for expressions
   defn allocate () :
      for (e in exps(b), i in 0 to false) do :
         release-up-to(Pos(i,false))
         match(e) :
            (e:Op) :
               ensure-loaded(Pos(i,false), ys(e))
               release-up-to(Pos(i,true))
               defined(Pos(i,true),xs(e))
               emit(e)
            (e:Save) :
               save(name(x(e)))
            (e:WArgs) :
               emit(e)
               defined(Pos(i + 1, false), xs(e))
            (e:WDo) :
               emit(e)
               release-up-to(Pos(i,true))
               defined(Pos(i + 1, false), xs(e))
            (e) :
               error("Class Allocation: Handle other constructs.")

   ;Driver
   defined(Pos(0,false), in(b))
   allocate()
   WBlock(name(b), to-list(exp-list), next(b),
          in(b), out(b), dist(b))


;============================================================
;================ Assumption Propagation ====================
;============================================================

defn propagate-assumptions (b:WBlock) :
   ;Utilities
   defn mark-port (x:Port,
                   saved:HashTable<Symbol,True|False|Any>,
                   loaded:HashTable<Symbol,True|False|Any>) :
      match(x) :
         (x:LivePort) :
            loaded[name(x)] = loaded?(x)
            saved[name(x)] = saved?(x)
         (x:DeadPort) :
            false

   defn read-port (x:Port,
                   saved:HashTable<Symbol,True|False|Any>,
                   loaded:HashTable<Symbol,True|False|Any>) :
      match(x) :
         (x:LivePort) :
            LivePort(name(x),
                     saved[name(x)]
                     get?(loaded, name(x), false)
                     loc(x))
         (x:DeadPort) :
            x

   ;Save/Load Status
   val saved = HashTable<Symbol,True|False|Any>(symbol-hash)
   val loaded = HashTable<Symbol,True|False|Any>(symbol-hash)

   ;Output Expression List
   val exp-list = Vector<Exp>()
   defn emit (e:Exp) :
      add(exp-list, e)
   
   defn propagate<?T> (ports:List<Port>, es:List<Exp>,
                       return:List<Port> -> ?T) -> T :
      ;Port status               
      val port-saved = HashTable<Symbol,True|False|Any>(symbol-hash)
      val port-loaded = HashTable<Symbol,True|False|Any>(symbol-hash)
      defn save (x:Var) :
         match(get?(port-saved, name(x), None())) :
            (s:Any) : port-saved[name(x)] = true
            (s:False) : emit(Save(x))
            (s:None) : emit(Save(x))
         saved[name(x)] = true   
      defn load (x:Var) :
         match(get?(port-loaded, name(x), None())) :
            (l:Any) : port-loaded[name(x)] = true
            (l:False) : emit(Load(x))
            (l:None) : emit(Load(x))
         loaded[name(x)] = true   
      defn unload (x:Var) :
         match(get?(port-loaded, name(x), None())) :
            (l:Any) : port-loaded[name(x)] = false
            (l:True) : false
            (l:None) : false
         loaded[name(x)] = false         
      defn defined (x:Var) :
         saved[name(x)] = false
         loaded[name(x)] = true
               
      ;Initialize Ports
      for x in ports do :
         mark-port(x, saved, loaded)
         mark-port(x, port-saved, port-loaded)         

      ;Propagate
      defn* loop (es:List<Exp>) :
         if not empty?(es) :
            match(head(es)) :
               (e:Op) :
                  emit(e)
                  do(defined,xs(e))
                  loop(tail(es))
               (e:Save) :
                  save(x(e))
                  loop(tail(es))               
               (e:Load) :
                  load(x(e))
                  loop(tail(es))
               (e:Unload) :
                  unload(x(e))
                  loop(tail(es))
               (e:WArgs) :
                  val i = length(exp-list)
                  emit(e)
                  propagate{xs(e), tail(es), _} $ fn* (xs*) :
                     exp-list[i] = WArgs(xs*)
               (e:WDo) :
                  val i = length(exp-list)
                  emit(e)
                  clear(loaded)
                  propagate{xs(e), tail(es), _} $ fn* (xs*) :
                     exp-list[i] = WDo(f(e), xs*, ys(e))               
               (e) :
                  error("Propagation: Handle other constructs.")

      loop(es)
      return $ for x in ports map :
         read-port(x, port-saved, port-loaded)


   propagate{in(b), exps(b), _} $ fn* (in*) :
      val out* = for x in out(b) map :
         read-port(x, saved, loaded)
      WBlock(name(b),
             to-list(exp-list),
             next(b),
             in* as List<LivePort>,
             out* as List<LivePort>,
             dist(b))   


;============================================================
;================ Register Assignment =======================
;============================================================

defn to-array<?T> (n:Int, xs:Streamable<?T>) -> Array<T> :
   val ys = Array<T>(n)
   val strx = to-stream(xs)
   for i in 0 to n do :
      ys[i] = next(strx)
   ys   

defn to-array<?T> (n:Int, f: Int -> ?T) -> Array<T> :
   val xs = Array<T>(n)
   for i in 0 to n do :
      xs[i] = f(i)
   xs   

defn find!<?T> (f: T -> True|False, xs:Streamable<?T>) -> T :
   find(f, xs) as T

defn register-assignment (b:WBlock, ports-in: List<LivePort>) :
   val locs = HashTable<Symbol,Loc>(symbol-hash)
   val reg-slots = Array<False|Symbol>(8, false)

   ;What is in register i after releases
   defn reg-slot (i:Int, rs:List<Symbol>) :
      match(reg-slots[i]) :
         (r:False) : r
         (r:Symbol) : r when not contains?(rs, r)

   ;What register is free after releases
   defn free-reg (rs:List<Symbol>) :
      Reg{_ as Int} $
         for i in 0 to length(reg-slots) find :
            contains?(rs, reg-slots[i]) or
            (reg-slots[i] typeof False)

   defn free-reg-without (rs:Tuple<Int>) :
      val i = for i in 0 to length(reg-slots) find :
         (not contains?(rs, i)) and
         (reg-slots[i] == false)
      match(i) :
         (i:Int) : Reg(i)
         (i:False) : false

   defn free-reg-prefer (rs:List<Reg>) :
      val r = for r in rs find :
         reg-slots[n(r)] == false
      match(r) :
         (r:Reg) : r
         (r:False) : free-reg()

   defn free-reg () :
      free-reg(List())

   ;Output expression list
   val exp-list = Vector<Exp>()
   defn emit (e:Exp) :
      add(exp-list, e)

   ;Assign variable to a location
   defn assign (x:Symbol, l:Loc) :
      match(l) :
         (l:Reg) :
            if reg-slots[n(l)] != false :
               error("~ occupied with ~." % [l, reg-slots[n(l)]])
            locs[x] = l
            reg-slots[n(l)] = x
         (l:Stack) :
            locs[x] = l      

   ;Free the variable from the register
   defn free (x:Symbol) :
      match(locs[x]) :
         (l:Reg) :
            locs[x] = Stack(0)
            reg-slots[n(l)] = false
         (l:Stack) : false

   defn free (xs:Streamable<Symbol>) :
      do(free, xs)

   ;Retrieve a variable/Port with its location
   defn assoc-loc (x:Var) :
      Var(name(x), locs[name(x)])

   defn assoc-loc (x:Port) :
      match(x) :
         (x:LivePort) : LivePort(name(x), saved?(x), loaded?(x), locs[name(x)])
         (x:DeadPort) : x

   defn assoc-loc (xs:List<Var>) :
      map(assoc-loc, xs)

   defn assoc-loc (xs:List<Port>) :
      map(assoc-loc, xs)

   defn assoc-loc (f:False) :
      false

   ;Assign a port to a register if possible
   defn assign-port-reg (x:Port) :
      match(x) :
         (x:LivePort) :
            match(loaded?(x)) :
               (ld:True|Any) : assign(name(x), free-reg())
               (ld:False) : assign(name(x), Stack(0))
         (x:DeadPort) : false

   ;Ensure that given registers are free after release
   defn ensure-free-after-release (regs:List<Int>, rels:List<Symbol>) :
      defn occupied-after-release (rels:List<Symbol>) :      
         val n = length(reg-slots)
         to-array(n, {reg-slot(_, rels) != false})
         
      defn pick-free (occupied:Array<False|True>, pref:List<Int>) :
         val prefs* = for p in pref map :
            if not occupied[p] :
               occupied[p] = true
               p
         for p in prefs* map :
            match(p) :
               (p:False) :
                  val i = for i in 0 to length(occupied) find! :
                     not occupied[i]
                  occupied[i] = true      
                  i
               (p:Int) :
                  p

      defn swap-reg-contents (old-reg:Int, new-reg:Int) :
         if old-reg != new-reg :
            if reg-slots[new-reg] == false :
               val v = reg-slots[old-reg] as Symbol
               emit(Set(new-var, old-var)) where :
                  val new-var = Var(v, Reg(new-reg))
                  val old-var = Var(v, Reg(old-reg))
               free(v)
               assign(v, Reg(new-reg))
            else :
               val v1 = reg-slots[old-reg] as Symbol
               val v2 = reg-slots[new-reg] as Symbol
               emit(Xchg(var1, var2, swap)) where :
                  val var1 = Var(v1, Reg(old-reg))
                  val var2 = Var(v2, Reg(new-reg))
                  val swap = free-reg-without([old-reg, new-reg])
               free(v1)
               free(v2)
               assign(v1, Reg(new-reg))
               assign(v2, Reg(old-reg))
   
      val free? = for r in regs all? :
         reg-slot(r, rels) == false
      if not free? :
         val regs* = pick-free(occupied-after-release(rels), regs)
         do(swap-reg-contents, regs, regs*)

   ;Ensure that the given value is assigned to a register
   defn ensure-assignment (x:Symbol, r:Reg) :
      val oldr = locs[x] as Reg
      if oldr != r :
         val v = reg-slots[n(r)]
         match(v) :
            (v:False) :
               emit(Set(old-var, new-var)) where :
                  val old-var = Var(x, oldr)
                  val new-var = Var(x, r)
               free(x)
               assign(x, r)
            (v:Symbol) :
               emit(Xchg(var1, var2, swap)) where :
                  val var1 = Var(x, oldr)
                  val var2 = Var(v, r)
                  val swap = free-reg-without([n(r), n(oldr)])
               free(x)
               free(v)
               assign(x, r)
               assign(v, oldr)

   ;Initial locations
   defn port-loc (x:Symbol) :
      {_ as Loc} $
      for p in ports-in search :
         loc(p) when name(p) == x
   let :
      val regs = Vector<Symbol>()
      for x in in(b) do :
         match(loaded?(x), port-loc(name(x))) :
            (ld:True, loc:Reg) : assign(name(x), loc)
            (ld:True, loc:Stack) : add(regs, name(x))
            (ld:False, loc) : assign(name(x), Stack(0))
            (ld:Any, loc) : assign(name(x), loc)
      for x in regs do :
         assign(x, free-reg())                  
   val in* = assoc-loc(in(b))      

   ;Compute release table
   val rt = release-table(b)

   ;Assign concrete locations
   for (e in exps(b), i in 0 to false) do :
      free(releases-up-to(rt, Pos(i,false)))
      match(e) :
         (e:Save) :
            emit(Save(assoc-loc(x(e))))
         (e:Load) :
            assign(name(x(e)), free-reg())
            emit(Load(assoc-loc(x(e))))
         (e:Op) :
            match(op(e)) :
               (op:BinDivOp) :
                  val rs = to-list(releases-up-to(rt, Pos(i, true)))
                  ensure-free-after-release(list(0), rs)
                  val ys* = assoc-loc(ys(e))
                  free(rs)
                  assign(name(xs(e)[0]), Reg(0))
                  val xs* = assoc-loc(xs(e))
                  emit(Op(op, xs*, ys*))
               (op:ComOp) :
                  val ys* = assoc-loc(ys(e))
                  free(releases-up-to(rt, Pos(i,true)))
                  val pref-x = map({loc(_) as Reg}, ys*)
                  assign(name(head(xs(e))), free-reg-prefer(pref-x))
                  val xs* = assoc-loc(xs(e))
                  emit(Op(op, xs*, ys*))
         (e:WArgs) :
            do(assign-port-reg, xs(e))
            val xs* = assoc-loc(xs(e))
            emit(WArgs(xs*))
         (e:WDo) :
            val f* = assoc-loc(f(e))
            val ys* = assoc-loc(ys(e))
            free(releases-up-to(rt, Pos(i, true)))
            do(assign-port-reg, xs(e))
            val xs* = assoc-loc(xs(e))
            emit(WDo(f*, xs*, ys*))
         (e) :
            error("Assignment: Handle other constructs.")

   ;Return results
   val out* = assoc-loc(out(b))
   WBlock(name(b),
          to-list(exp-list),
          next(b),
          in* as List<LivePort>
          out* as List<LivePort>
          dist(b))



defn register-assignment (p:Unit) :
   ;Table of blocks
   val block-table = HashTable<Symbol,WBlock>(symbol-hash)
   for b in blocks(p) do : block-table[name(b)] = b as WBlock

   ;Table of new blocks
   val block-table* = HashTable<Symbol, WBlock>(symbol-hash)
   defn assign-successors (b:WBlock) :
      for n in next(b) do :
         if not key?(block-table*, n) :
            val b* = register-assignment(block-table[n], out(b))
            block-table*[n] = b*
            assign-successors(b*)

   ;Process in depth-first order
   let :
      val b = head(blocks(p)) as WBlock
      val b* = register-assignment(b, List())
      block-table*[name(b)] = b*
      assign-successors(b*)

   ;Return results
   val bs = for b in blocks(p) map : block-table*[name(b)]
   Unit(defs(p), bs)


;============================================================
;============== Calculate Stack Locations ===================
;============================================================

definterface Interval
defstruct StartInterval <: Interval :
   name: Symbol
defstruct EndInterval <: Interval :
   name: Symbol

defmethod print (o:OutputStream, i:Interval) :
   print{o, _} $ match(i) :
      (i:StartInterval) : "Start(~)" << [name(i)]
      (i:EndInterval) : "End(~)" << [name(i)]

defn in-reverse<?T> (xs:Vector<?T>) -> Stream<T> :
   val n = length(xs)
   for i in (n - 1) through 0 by -1 stream :
      xs[i]

defn post-order (bs:List<WBlock>) -> Vector<WBlock> :
   ;Block Table
   val block = HashTable<Symbol,WBlock>(symbol-hash)
   for b in bs do : block[name(b)] = b
   
   ;Mark Table
   val mark-table = HashTable<Symbol,True>(symbol-hash)
   defn marked? (b:WBlock) : key?(mark-table, name(b))
   defn mark (b:WBlock) : mark-table[name(b)] = true

   ;Add blocks to ys
   val ys = Vector<WBlock>()
   defn* loop (b:WBlock) :
      if not marked?(b) :
         do(loop{block[_]}, next(b))
         add(ys, b)            
         mark(b)
   loop(head(bs))

   ;Return blocks
   ys

defn reverse-post-order (bs:List<WBlock>) :
   in-reverse(post-order(bs))

defn calculate-stack-locations (p:Unit) :
   val var-start = HashTable<Symbol,Int>(symbol-hash)
   val var-end = HashTable<Symbol,Int>(symbol-hash)

   defn note-usage (x:Symbol, i:Int) :
      if key?(var-start, x) :
         var-start[x] = min(i, var-start[x])
         var-end[x] = max(i, var-end[x])
      else :
         var-start[x] = i
         var-end[x] = i
         
   defn note-usage (p:Port, i:Int) :
      match(p) :
         (p:LivePort) : note-usage(name(p), i) when saved?(p) == true
         (p:DeadPort) : false

   defn note-usage (x:False, i:Int) :
      false

   defn note-usage (x:Var, i:Int) :
      match(loc(x)) :
         (l:Stack) : note-usage(name(x), i)
         (l) : false

   defn note-usage (xs:List<Port>, i:Int) :
      do(note-usage{_, i}, xs)
      
   defn note-usage (xs:List<Var>, i:Int) :
      do(note-usage{_, i}, xs)
      
   defn find-usages (b:WBlock, i:Int) -> Int :
      note-usage(in(b), i)
      defn* loop (es:List<Exp>, i:Int) :
         if empty?(es) :
            note-usage(out(b), i)
            i + 1   
         else :
            match(head(es)) :
               (e:Op) : false
               (e:WArgs) : note-usage(xs(e), i)
               (e:WDo) :
                  note-usage(ys(e), i)
                  note-usage(f(e), i)
                  note-usage(xs(e), i)
               (e:Save) : note-usage(name(x(e)), i)
               (e:Load) : note-usage(name(x(e)), i)
               (e:Xchg) : false
               (e) : error("Stack locations: Handle other constructs.")
            loop(tail(es), i + 1)   
      loop(exps(b), i + 1)      

   ;Find-usages for blocks in reverse post order
   val bs = reverse-post-order(blocks(p) as List<WBlock>)
   defn* loop (i:Int) :
      if more?(bs) :
         loop(find-usages(next(bs), i))
      else : i
   val num-pos = loop(0)

   ;Iterate through and order intervals
   val intervals = Array<List<Interval>>(num-pos, List())
   for e in var-end do :
      val v = key(e)
      val i = value(e)
      intervals[i] = List(EndInterval(v), intervals[i])
   for e in var-start do :
      val v = key(e)
      val i = value(e)
      intervals[i] = List(StartInterval(v), intervals[i])

   ;Return single stream of intervals
   concat-all(intervals)
      
         
   
   



;;======== Critical Edge Removal ==========
;defn remove-critical-edges (p:Program) :
;   val pred-table = HashTable<Symbol,Int>(symbol-hash)
;   val block-list = Vector<SBlock>()
;   
;   defn num-pred (b:Symbol) :
;      get?(pred-table, b, 0)
;
;   defn inc-pred (b:Symbol) :
;      pred-table[b] = num-pred(b) + 1
;
;   defn update-next (b:Block, n:List<Symbol>) :
;      SBlock(name(b), exps(b), n)
;
;   ;Count predecessors
;   for b in blocks(p) do :
;      for n in next(b) do :
;         inc-pred(n)
;
;   ;Create safe block
;   defn safe-block (a:Block, b:Symbol) :
;      val name = gensym(`safe)
;      add(block-list, SBlock(name, List(), list(b)))
;      name
;
;   ;Insert safe blocks
;   val blocks* = for b in blocks(p) map :
;      if length(next(b)) > 1 :
;         val next* = for n in next(b) map :
;            if num-pred(n) > 1 : safe-block(b, n)
;            else : n
;         update-next(b, next*)
;      else :
;         b
;
;   Program(to-list(concat(blocks*, block-list)))
;            
;
;

;;======== Stack Interval Calculation ==========
;defn calculate-stack-intervals (p:Program) :
;   val block-table = HashTable<Symbol,LBlock>(symbol-hash)
;   val block-start = HashTable<Symbol,Int>(symbol-hash)
;   val block-end = HashTable<Symbol,Int>(symbol-hash)
;   val block-preds = HashTable<Symbol,List<Symbol>>(symbol-hash)
;   val min-table = HashTable<Symbol,Int>(symbol-hash)
;   val max-table = HashTable<Symbol,Int>(symbol-hash)
;   val scanned = HashTable<Symbol,True>(symbol-hash)
;   val scan-queue = Queue<LBlock>()
;   var index = 0
;
;   defn on-stack? (x:Ref) :
;      match(x) :
;         (x:LVar) : loc(x) typeof Stack
;         (x) : false
;
;   defn on-stack (xs:List<Ref>) :
;      filter(on-stack?, xs)
;
;   defn used (x:Ref, index:Int) :
;      val nx = name(x)
;      if key?(min-table, name(x)) :
;         min-table[nx] = min(index, min-table[nx])
;         max-table[nx] = max(index, max-table[nx])
;      else :
;         min-table[nx] = index
;         max-table[nx] = index
;
;   defn used (xs:Streamable<Ref>, index:Int) :
;      do(used{_, index}, xs)
;
;   defn step () :
;      index = index + 1
;
;   defn get-preds (n:Symbol) :
;      get?(block-preds, n, List())
;
;   ;Register blocks
;   for b in blocks(p) do :
;      block-table[name(b)] = b as LBlock
;      
;   ;Process blocks   
;   add(scan-queue, head(blocks(p)) as LBlock)
;   while not empty?(scan-queue) :
;      val b = pop(scan-queue)
;      if not key?(scanned, name(b)) :
;         ;Note Start Index
;         block-start[name(b)] = index
;         ;Note Expressions
;         for e in exps(b) do :
;            match(e) :
;               (e:Args) : used(on-stack(xs(e)), index)
;               (e:Op) : false
;               (e:Save) : used(x(e), index)
;               (e:Load) : used(x(e), index)
;               (e:Do) :
;                  used(on-stack(ys(e)), index)
;                  step()
;                  used(on-stack(xs(e)), index)
;            step()
;         ;Note End Index
;         block-end[name(b)] = index
;         step()
;         ;Register Next Blocks
;         for n in next(b) do :
;            add(scan-queue, block-table[n])
;            block-preds[n] = List(name(b), get-preds(n))
;
;   ;Process Live in
;   for b in values(block-table) do :
;      defn saved (xs:List<Ref>, ss:List<Status>) :
;         for (x in xs, s in ss) filter :
;            saved?(s) or on-stack?(x)
;         
;      for x in saved(live-in(b), status-in(b)) do :
;         used(x, block-start[name(b)])
;         for p in get-preds(name(b)) do :
;            used(x, block-end[p])
;
;   ;Accumulate Results
;   val interval-starts = Array<List<Symbol>>(index, List())
;   val interval-ends = Array<List<Symbol>>(index, List())
;   for v in keys(min-table) do :
;      val i = min-table[v]
;      val j = max-table[v]
;      interval-starts[i] = List(v, interval-starts[i])
;      interval-ends[j] = List(v, interval-ends[j])
;   val r = [interval-starts, interval-ends]
;
;   ;Print Result
;   for i in 0 to length(interval-starts) do :
;      println("~: START(~@) END(~@)" << [i, interval-starts[i], interval-ends[i]])
;
;   r
;
;
;;====== Stack Location Calculation ======
;defn calculate-stack-locations (p:Program) :
;   val location-table = HashTable<Symbol,Int>(symbol-hash)
;   val [starts, ends] = calculate-stack-intervals(p)
;   val location-free = Vector<True|False>()
;   val N = length(starts)
;
;   defn get-free-location () :
;      match(index-of(location-free, true)) :
;         (i:Int) : i
;         (i:False) :
;            add(location-free, true)
;            length(location-free) - 1
;
;   defn assign-free-location (x:Symbol) :
;      val i = get-free-location()
;      location-table[x] = i
;      location-free[i] = false
;
;   defn release-location (x:Symbol) :
;      val i = location-table[x]
;      location-free[i] = true
;
;   defn assign-free-location (xs:List<Symbol>) :
;      do(assign-free-location, xs)
;
;   defn release-location (xs:List<Symbol>) :
;      do(release-location, xs)
;
;   for i in 0 to N do :
;      assign-free-location(starts[i])
;      release-location(ends[i])
;
;   ;Print Result
;   println("Location Table")
;   do(println, location-table)
;
;   location-table
;
;
;;========= Glue Blocks ========
;defn glue-blocks (p:Program) :
;   ;Parallel Move
;   defn par-move (src:List<Ref>, src-status:List<Status>,
;                  dst:List<Ref>, dst-status:List<Status>) :
;      val src-loc-table = HashTable<Symbol,Loc>(symbol-hash)
;      val dst-loc-table = HashTable<Symbol,Loc>(symbol-hash)
;      val src-status-table = HashTable<Symbol,Status>(symbol-hash)
;      val dst-status-table = HashTable<Symbol,Status>(symbol-hash)
;      val RS-moves = Vector<Save>()
;      val RR-srcs = Vector<Ref>()
;      val RR-dsts = Vector<Ref>()
;      val SR-moves = Vector<Load>()
;      
;      ;Initialize Tables
;      for (x in src, s in src-status) do :
;         src-loc-table[name(x)] = loc(x as LVar)
;         src-status-table[name(x)] = s
;      for (x in dst, s in dst-status) do :
;         dst-loc-table[name(x)] = loc(x as LVar)
;         dst-status-table[name(x)] = s
;
;      defn stack-dst? (x:Ref) :
;         dst-loc-table[name(x)] typeof Stack
;      defn reg-dst? (x:Ref) :
;         dst-loc-table[name(x)] typeof RegN
;      defn stack-src? (x:Ref) :
;         src-loc-table[name(x)] typeof Stack
;      defn reg-src? (x:Ref) :
;         src-loc-table[name(x)] typeof RegN
;      defn save-dst? (x:Ref) :
;         saved?(dst-status-table[name(x)])
;      defn save-src? (x:Ref) :
;         saved?(src-status-table[name(x)])
;      defn get-src (x:Ref) :
;         LVar(name(x), src-loc-table[name(x)])
;      defn get-dst (x:Ref) :
;         LVar(name(x), dst-loc-table[name(x)])
;                  
;      for x in dst do :
;         if (stack-dst?(x) or save-dst?(x)) and not
;            (stack-src?(x) or save-src?(x)) :
;            add(RS-moves, Save(get-src(x)))
;         else if reg-dst?(x) and reg-src?(x) :
;            add(RR-srcs, get-src(x))
;            add(RR-dsts, get-dst(x))
;         else if reg-dst?(x) and stack-src?(x) :
;            add(SR-moves, Load(get-dst(x)))
;
;      concat-all $ [
;         RS-moves
;         [ParSet(to-list(RR-dsts), to-list(RR-srcs))]
;         SR-moves]
;
;   ;Glue Blocks
;   val block-table = HashTable<Symbol,LBlock>(symbol-hash)
;   for b in blocks(p) do :
;      block-table[name(b)] = b as LBlock
;
;   defn update-exps (b:LBlock, exps:List<Exp>) :
;      LBlock(name(b),
;             exps,
;             next(b),
;             live-in(b),
;             status-in(b),
;             live-out(b)
;             status-out(b),
;             dist-out(b))
;
;   for b in values(block-table) do :
;      if length(next(b)) == 1 :
;         val b2 = block-table[head(next(b))] as LBlock
;         val exps* = to-list $ concat(exps(b),
;            par-move(live-out(b), status-out(b),
;                     live-in(b2), status-in(b2)))
;         block-table[name(b)] = update-exps(b, exps*)
;      else :
;         for n in next(b) do :
;            val b2 = block-table[n] as LBlock
;            val exps* = to-list $ concat(
;               par-move(live-out(b), status-out(b),
;                        live-in(b2), status-in(b2))
;               exps(b2))
;            block-table[name(b2)] = update-exps(b2, exps*)   
;
;   Program(map({block-table[name(_)]}, blocks(p)))
;
;;========= Driver ========
;defn allocate (p:Program) :
;   val bs* = for b in blocks(p) map :
;      save-load-elision $
;      finite-allocation $      
;      b as LBlock
;   Program(bs*)
;

;============================================================
;==================== Driver ================================
;============================================================
defn test (p:Unit) :
   println("====== Test ======")
   println(p)

   println("====== Class Allocation ======")
   val p2 = liveness-analysis(p)
   val bs = for b in blocks(p2) map :
      propagate-assumptions $
      class-allocation $
      save-semantics $
      b as WBlock
   val p3 = Unit(defs(p2), bs)
   println(p3)

   println("====== Register Assignment ======")
   val p4 = register-assignment(p3)
   println(p4)

;   println("====== Remove critical edges ======")
;   val p1 = remove-critical-edges(p)
;   println(p1)
;   println("====== Liveness Analysis ======")
;   val p2 = liveness-analysis(p)
;   println(p2)
;   for b in blocks(p2) do :
;      println("==== Block ~ ====" << [name(b)])
;      println("Save Semantics:")
;      var b* = save-semantics(b as WBlock)
;      println(b*)
;      b* = class-allocation(b*)
;      println("Class Allocation:")
;      println(b*)
;      b* = propagate-assumptions(b*)
;      println("Assumption Propagation:")
;      println(b*)
      

      

   
;   println("====== Allocation ======")
;   val p3 = allocate(p2)
;   println(p3)
;   println("====== Assignment ======")
;   val p4 = assign(p3)
;   println(p4)
;   println("====== Calculate Stack Locations ======")
;   calculate-stack-locations(p4)
;   println("====== Glue Blocks ======")
;   val p5 = glue-blocks(p4)
;   println(p5)
;   println("==================\n\n\n")


defn main () :
   val filename = commandline-arguments()[1]
   val units = parse-regir(filename)   
   do(test, units)

main()