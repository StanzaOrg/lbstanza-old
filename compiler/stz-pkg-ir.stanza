;============================================================
;==================== Pkg Language ==========================
;============================================================

defpackage stz/pkg-ir :
   import core
   import collections
   import stz/namemap
   import stz/tl-ir with :
      prefix(Field, Child) => T
   import stz/params
   import stz/ids

#use-overlay(stz/ast-lang, stz/printer-lang)

public defast :
   deftype PkgComm
   defnodes PkgComm :
      DefInfo :
         n: Int
         name: Symbol
         package: Symbol
         visibility: Vis
         category: EType
         info: FileInfo
      DefVal :
         n: Int
         type: False|Type
         ls-type: False|LSType
      DefType :
         n: Int
         args: List<Int>
         parent: False|Type
         children: List<Child>
      DefLSType :
         n: Int
         args: List<Int>
         parent: False|Type
         fields: List<Field>

public defstruct Child :
   n: Int
   args: List<Int>
   parent: Type

public defstruct Field :
   n: Int
   name: Symbol
   type: LSType

public defstruct Pkg :
   name: Symbol
   comms: List<PkgComm>

;============================================================
;==================== Printers ==============================
;============================================================

defprinter (c:PkgComm) :
   DefInfo :
      ($definfo n name package visibility category info)
   DefVal :
      ($defval n type ls-type)
   DefType :
      ($deftype n args parent)
   DefLSType :
      ($deflstype n args parent fields ...)

defprinter (f:Field) :
   Field :
      ($field n name type)

defprinter (c:Child) :
   Child :
      ($child n (args ...) parent)

defprinter (p:Pkg) :
   Pkg :
      ($pkg name comms ...)


;============================================================
;=================== Serialization ==========================
;============================================================

defn serialize (filename:String, p:Pkg) :
   val f = FileOutputStream(filename)
   try : serialize(f, p)
   finally : close(f)

defn deserialize-pkg (filename:String) :
   val f = FileInputStream(filename)
   try : deserialize-pkg(f)
   finally : close(f)

((defn serialize (out : FileOutputStream x6 : Pkg) : ((defn write-pkg (x7 : Pkg) : (match (@do x7) : ((x8 : Pkg) : (core/put (@do out 0Y) write-symbol (@do name (@do x8)) (write-list (@do-afn write-pkgcomm _)) (@do comms (@do x8)))))) (defn write-type (x9 : Type) : (match (@do x9) : ((x10 : TMixed) : (core/put (@do out 0Y) (write-slist (@do-afn write-arrow _)) (@do types (@do x10))) (x11 : TPoly) : (core/put (@do out 1Y) (write-slist (@do-afn write-int _)) (@do targs (@do x11)) (write-slist (@do-afn write-int _)) (@do cargs (@do x11)) write-arrow (@do func (@do x11))) (x12 : TCap) : (core/put (@do out 2Y) write-int (@do n (@do x12))) (x13 : TOf) : (core/put (@do out 3Y) write-int (@do n (@do x13)) write-type (@do type (@do x13))) (x14 : TTuple) : (core/put (@do out 4Y) (write-slist (@do-afn write-type _)) (@do types (@do x14))) (x15 : TOr) : (core/put (@do out 5Y) write-type (@do a (@do x15)) write-type (@do b (@do x15))) (x16 : TAnd) : (core/put (@do out 6Y) write-type (@do a (@do x16)) write-type (@do b (@do x16))) (x17 : TVar) : (core/put (@do out 7Y) write-int (@do n (@do x17))) (x18 : TArrow) : (core/put (@do out 8Y) write-type (@do a (@do x18)) write-type (@do b (@do x18))) (x19 : TGradual) : (core/put (@do out 9Y)) (x20 : TBot) : (core/put (@do out 10Y))))) (defn write-lstype (x21 : LSType) : (match (@do x21) : ((x22 : ByteT) : (core/put (@do out 0Y)) (x23 : IntT) : (core/put (@do out 1Y)) (x24 : LongT) : (core/put (@do out 2Y)) (x25 : FloatT) : (core/put (@do out 3Y)) (x26 : DoubleT) : (core/put (@do out 4Y)) (x27 : UnknownT) : (core/put (@do out 5Y)) (x28 : PolyT) : (core/put (@do out 6Y) (write-slist (@do-afn write-int _)) (@do targs (@do x28)) (write-slist (@do-afn write-int _)) (@do cargs (@do x28)) write-fnt (@do func (@do x28))) (x29 : RestT) : (core/put (@do out 7Y) write-lstype (@do type (@do x29))) (x30 : PtrT) : (core/put (@do out 8Y) write-lstype (@do type (@do x30))) (x31 : RefT) : (core/put (@do out 9Y) write-type (@do type (@do x31))) (x32 : FnT) : (core/put (@do out 10Y) (write-slist (@do-afn write-lstype _)) (@do a (@do x32)) (write-opt (@of LSType) (@do-afn write-lstype _)) (@do r (@do x32)) write-lstype (@do b (@do x32))) (x33 : StructT) : (core/put (@do out 11Y) write-int (@do n (@do x33)) write-type (@do type (@do x33)))))) (defn write-pkgcomm (x34 : PkgComm) : (match (@do x34) : ((x35 : DefInfo) : (core/put (@do out 0Y) write-int (@do n (@do x35)) write-symbol (@do name (@do x35)) write-symbol (@do package (@do x35)) write-vis (@do visibility (@do x35)) write-category (@do category (@do x35)) write-info (@do info (@do x35))) (x36 : DefVal) : (core/put (@do out 1Y) write-int (@do n (@do x36)) (write-opt (@of Type) (@do-afn write-type _)) (@do type (@do x36)) (write-opt (@of LSType) (@do-afn write-lstype _)) (@do ls-type (@do x36))) (x37 : DefType) : (core/put (@do out 2Y) write-int (@do n (@do x37)) (write-slist (@do-afn write-int _)) (@do args (@do x37)) (write-opt (@of Type) (@do-afn write-type _)) (@do parent (@do x37)) (write-slist (@do-afn write-child _)) (@do children (@do x37))) (x38 : DefLSType) : (core/put (@do out 3Y) write-int (@do n (@do x38)) (write-slist (@do-afn write-int _)) (@do args (@do x38)) (write-opt (@of Type) (@do-afn write-type _)) (@do parent (@do x38)) (write-slist (@do-afn write-field _)) (@do fields (@do x38)))))) (defn write-vis (x39 : Vis) : (match (@do x39) : ((x40 : Private) : (core/put (@do out 0Y)) (x41 : Protected) : (core/put (@do out 1Y)) (x42 : Public) : (core/put (@do out 2Y)) (x43 : Local) : (core/put (@do out 3Y))))) (defn write-category (x44 : EType) : (match (@do x44) : ((x45 : ValE) : (core/put (@do out 0Y)) (x46 : VarE) : (core/put (@do out 1Y)) (x47 : TVarE) : (core/put (@do out 2Y)) (x48 : CapVarE) : (core/put (@do out 3Y)) (x49 : TypeE) : (core/put (@do out 4Y)) (x50 : MultiE) : (core/put (@do out 5Y)) (x51 : FnE) : (core/put (@do out 6Y)) (x52 : LValE) : (core/put (@do out 7Y)) (x53 : LVarE) : (core/put (@do out 8Y)) (x54 : LFnE) : (core/put (@do out 9Y)) (x55 : LTypeE) : (core/put (@do out 10Y)) (x56 : FieldE) : (core/put (@do out 11Y)) (x57 : LabelE) : (core/put (@do out 12Y))))) (defn write-field (x58 : Field) : (match (@do x58) : ((x59 : Field) : (core/put (@do out 0Y) write-int (@do n (@do x59)) write-symbol (@do name (@do x59)) write-lstype (@do type (@do x59)))))) (defn write-child (x60 : Child) : (match (@do x60) : ((x61 : Child) : (core/put (@do out 0Y) write-int (@do n (@do x61)) (write-slist (@do-afn write-int _)) (@do args (@do x61)) write-type (@do parent (@do x61)))))) (defn write-info (x62 : FileInfo) : (match (@do x62) : ((x63 : FileInfo) : (core/put (@do out 0Y) write-string (@do filename (@do x63)) write-int (@do line (@do x63)) write-int (@do column (@do x63)))))) (defn write-arrow (t : TArrow) : ($do write-type t)) (defn write-fnt (t : FnT) : ($do write-lstype t)) () ($defn ($of write-slist ($cap T)) (f xs) (($-> (T) False) ($of List ($cap T))) ($none) ($begin ($do write-byte ($do to-byte ($do length xs))) ($do do f xs))) () ($defn ($of write-list ($cap T)) (f xs) (($-> (T) False) ($of List ($cap T))) ($none) ($begin ($do write-int ($do length xs)) ($do do f xs))) () ($defn ($of write-opt T) (f x) (($-> (T) False) ($or T False)) ($none) ($match (($as? ($match (x) ($branch (x) (False) true) ($branch (x) (($none)) false)) ($or core/True core/False))) ($branch (x4) (core/True) ($do write-byte 0Y)) ($branch (x4) (core/False) ($begin ($do write-byte 1Y) ($do f ($as x T)))))) (defn write-int (x : Int) : ($do put out x)) (defn write-byte (x : Byte) : ($do put out x)) (defn write-char (x : Char) : ($do print out x)) (defn write-string (x : String) : ($begin ($do write-int ($do length x)) ($do print out x))) (defn write-symbol (x : Symbol) : ($do write-string ($do to-string x))) ($defn ($of ensure T) (f x) (($-> (($?)) ($or True False)) ($none)) ($none) ($match (($as? ($do f x) ($or core/True core/False))) ($branch (x5) (core/True) ($as x T)) ($branch (x5) (core/False) ($do throw ($do FileReadException))))) write-pkg (@do x6))) (defn deserialize-pkg (in : FileInputStream) -> Pkg : (defn read-tag64 () : (match (@do core/get-byte (@do in)) : ((b : Byte) : b (b : False) : core/throw (@do core/FileReadException (@do)))) (defn read-pkg () -> Pkg : (val tag65 = read-tag64 (@do) switch (@afn tag65 == _) : (0Y : Pkg (@do read-symbol (@do) (read-list (@do-afn read-pkgcomm)) (@do)) else : core/throw (@do core/FileReadException (@do))))) (defn read-type () -> Type : (val tag66 = read-tag64 (@do) switch (@afn tag66 == _) : (0Y : TMixed (@do (read-slist (@do-afn read-arrow)) (@do)) 1Y : TPoly (@do (read-slist (@do-afn read-int)) (@do) (read-slist (@do-afn read-int)) (@do) read-arrow (@do)) 2Y : TCap (@do read-int (@do)) 3Y : TOf (@do read-int (@do) read-type (@do)) 4Y : TTuple (@do (read-slist (@do-afn read-type)) (@do)) 5Y : TOr (@do read-type (@do) read-type (@do)) 6Y : TAnd (@do read-type (@do) read-type (@do)) 7Y : TVar (@do read-int (@do)) 8Y : TArrow (@do read-type (@do) read-type (@do)) 9Y : TGradual (@do) 10Y : TBot (@do) else : core/throw (@do core/FileReadException (@do))))) (defn read-lstype () -> LSType : (val tag67 = read-tag64 (@do) switch (@afn tag67 == _) : (0Y : ByteT (@do) 1Y : IntT (@do) 2Y : LongT (@do) 3Y : FloatT (@do) 4Y : DoubleT (@do) 5Y : UnknownT (@do) 6Y : PolyT (@do (read-slist (@do-afn read-int)) (@do) (read-slist (@do-afn read-int)) (@do) read-fnt (@do)) 7Y : RestT (@do read-lstype (@do)) 8Y : PtrT (@do read-lstype (@do)) 9Y : RefT (@do read-type (@do)) 10Y : FnT (@do (read-slist (@do-afn read-lstype)) (@do) (read-opt (@of LSType) (@do-afn read-lstype)) (@do) read-lstype (@do)) 11Y : StructT (@do read-int (@do) read-type (@do)) else : core/throw (@do core/FileReadException (@do))))) (defn read-pkgcomm () -> PkgComm : (val tag68 = read-tag64 (@do) switch (@afn tag68 == _) : (0Y : DefInfo (@do read-int (@do) read-symbol (@do) read-symbol (@do) read-vis (@do) read-category (@do) read-info (@do)) 1Y : DefVal (@do read-int (@do) (read-opt (@of Type) (@do-afn read-type)) (@do) (read-opt (@of LSType) (@do-afn read-lstype)) (@do)) 2Y : DefType (@do read-int (@do) (read-slist (@do-afn read-int)) (@do) (read-opt (@of Type) (@do-afn read-type)) (@do) (read-slist (@do-afn read-child)) (@do)) 3Y : DefLSType (@do read-int (@do) (read-slist (@do-afn read-int)) (@do) (read-opt (@of Type) (@do-afn read-type)) (@do) (read-slist (@do-afn read-field)) (@do)) else : core/throw (@do core/FileReadException (@do))))) (defn read-vis () -> Vis : (val tag69 = read-tag64 (@do) switch (@afn tag69 == _) : (0Y : Private (@do) 1Y : Protected (@do) 2Y : Public (@do) 3Y : Local (@do) else : core/throw (@do core/FileReadException (@do))))) (defn read-category () -> EType : (val tag70 = read-tag64 (@do) switch (@afn tag70 == _) : (0Y : ValE (@do) 1Y : VarE (@do) 2Y : TVarE (@do) 3Y : CapVarE (@do) 4Y : TypeE (@do) 5Y : MultiE (@do) 6Y : FnE (@do) 7Y : LValE (@do) 8Y : LVarE (@do) 9Y : LFnE (@do) 10Y : LTypeE (@do) 11Y : FieldE (@do) 12Y : LabelE (@do) else : core/throw (@do core/FileReadException (@do))))) (defn read-field () -> Field : (val tag71 = read-tag64 (@do) switch (@afn tag71 == _) : (0Y : Field (@do read-int (@do) read-symbol (@do) read-lstype (@do)) else : core/throw (@do core/FileReadException (@do))))) (defn read-child () -> Child : (val tag72 = read-tag64 (@do) switch (@afn tag72 == _) : (0Y : Child (@do read-int (@do) (read-slist (@do-afn read-int)) (@do) read-type (@do)) else : core/throw (@do core/FileReadException (@do))))) (defn read-info () -> FileInfo : (val tag73 = read-tag64 (@do) switch (@afn tag73 == _) : (0Y : FileInfo (@do read-string (@do) read-int (@do) read-int (@do)) else : core/throw (@do core/FileReadException (@do))))) (defn read-arrow () -> TArrow : ($do ($of ensure TArrow) ($fn (arg1) (($none)) ($none) ($match (arg1) ($branch (x) (TArrow) true) ($branch (x) (($none)) false))) ($do read-type))) (defn read-fnt () -> FnT : ($do ($of ensure FnT) ($fn (arg2) (($none)) ($none) ($match (arg2) ($branch (x) (FnT) true) ($branch (x) (($none)) false))) ($do read-lstype))) ($defn ($of read-slist ($cap T)) (f) (($-> () ($cap T))) ($none) ($begin ($def n ($none) ($do read-byte)) ($do to-list ($do repeatedly f ($do to-int n))))) () ($defn ($of read-list ($cap T)) (f) (($-> () ($cap T))) ($none) ($begin ($def n ($none) ($do read-int)) ($do to-list ($do repeatedly f n)))) () ($defn ($of read-opt T) (f) (($-> () T)) ($none) ($begin ($def n ($none) ($do read-byte)) ($match (($as? ($do equal? n 1Y) ($or core/True core/False))) ($branch (x3) (core/True) ($do f)) ($branch (x3) (core/False) false)))) () (defn read-int () -> Int : ($match (($do get-int in)) ($branch (x) (Int) x) ($branch (x) (False) ($do throw ($do FileReadException))))) (defn read-byte () -> Byte : ($match (($do get-byte in)) ($branch (x) (Byte) x) ($branch (x) (False) ($do throw ($do FileReadException))))) (defn read-char () -> Char : ($match (($do get-char in)) ($branch (x) (Char) x) ($branch (x) (False) ($do throw ($do FileReadException))))) (defn read-string () -> String : ($begin ($def n ($none) ($do read-int)) ($do String ($do repeatedly read-char n)))) (defn read-symbol () -> Symbol : ($do to-symbol ($do read-string))) ($defn ($of ensure T) (f x) (($-> (($?)) ($or True False)) ($none)) ($none) ($match (($as? ($do f x) ($or core/True core/False))) ($branch (x5) (core/True) ($as x T)) ($branch (x5) (core/False) ($do throw ($do FileReadException))))) read-pkg (@do))))

;;============================================================
;;=================== Serialization ==========================
;;============================================================
;
;;                  Serialiation Tags
;;                  =================
;
;var TAG-COUNTER:Seq<Int>
;defn next-tag () : to-byte(next(TAG-COUNTER))
;defn reset-tag-counter () : TAG-COUNTER = to-seq(1 to false)
;
;;Type Tags
;reset-tag-counter()
;val TPOLY-TAG = next-tag()
;val TCAP-TAG = next-tag()
;val TOF-TAG = next-tag()
;val TTUPLE-TAG = next-tag()
;val TOR-TAG = next-tag()
;val TAND-TAG = next-tag()
;val TVAR-TAG = next-tag()
;val TARROW-TAG = next-tag()
;val TGRADUAL-TAG = next-tag()
;val TBOT-TAG = next-tag()
;;LoStanza Type Tags
;val BYTET-TAG = next-tag()
;val INTT-TAG = next-tag()
;val LONGT-TAG = next-tag()
;val FLOATT-TAG = next-tag()
;val DOUBLET-TAG = next-tag()
;val UNKNOWNT-TAG = next-tag()
;val POLYT-TAG = next-tag()
;val RESTT-TAG = next-tag()
;val PTRT-TAG = next-tag()
;val REFT-TAG = next-tag()
;val FNT-TAG = next-tag()
;val STRUCTT-TAG = next-tag()
;
;;Category Tags
;reset-tag-counter()
;val VALE-TAG = next-tag()
;val VARE-TAG = next-tag()
;val TVARE-TAG = next-tag()
;val CAPVARE-TAG = next-tag()
;val TYPEE-TAG = next-tag()
;val MULTIE-TAG = next-tag()
;val FNE-TAG = next-tag()
;val LVALE-TAG = next-tag()
;val LVARE-TAG = next-tag()
;val LFNE-TAG = next-tag()
;val LTYPEE-TAG = next-tag()
;val FIELDE-TAG = next-tag()
;val LABELE-TAG = next-tag()
;
;;Visibility Tags
;reset-tag-counter()
;val LOCAL-TAG = next-tag()
;val PRIVATE-TAG = next-tag()
;val PROTECTED-TAG = next-tag()
;val PUBLIC-TAG = next-tag()
;
;;Comm Tags
;reset-tag-counter()
;val DEFINFO-TAG = next-tag()
;val DEFVAL-TAG = next-tag()
;val DEFTYPE-TAG = next-tag()
;val DEFLSTYPE-TAG = next-tag()
;
;;KType Tags
;reset-tag-counter()
;val KOF-TAG = next-tag()
;val KTVAR-TAG = next-tag()
;val KAND-TAG = next-tag()
;val KOR-TAG = next-tag()
;val KTOP-TAG = next-tag()
;val KBOT-TAG = next-tag()
;
;;KComm Tags
;reset-tag-counter()
;val KDEF-TAG = next-tag()
;val KDEFVAR-TAG = next-tag()
;val KDEFN-TAG = next-tag()
;val KDEFMULTI-TAG = next-tag()
;val KDEFMETHOD-TAG = next-tag()
;val KDEFTYPE-TAG = next-tag()
;val KINIT-TAG = next-tag()
;val KLSDEF-TAG = next-tag()
;val KLSDEFVAR-TAG = next-tag()
;val KLSDEFN-TAG = next-tag()
;val KLSEXTERNFN-TAG = next-tag()
;val KLSDEFMETHOD-TAG = next-tag()
;val KLSDEFTYPE-TAG = next-tag()
;val KEXTERN-TAG = next-tag()
;val KLSINIT-TAG = next-tag()
;
;;KExp Tags
;reset-tag-counter()
;val KSET-TAG = next-tag()
;val KCAST-TAG = next-tag()
;val KCHECKLENGTH-TAG = next-tag()
;val KLET-TAG = next-tag()
;val KLETREC-TAG = next-tag()
;val KSEQ-TAG = next-tag()
;val KDISPATCH-TAG = next-tag()
;val KMATCH-TAG = next-tag()
;val KNEW-TAG = next-tag()
;val KDO-TAG = next-tag()
;val KVAR-TAG = next-tag()
;val KPRIM-TAG = next-tag()
;val KLITERAL-TAG = next-tag()
;val KTUPLE-TAG = next-tag()
;val KTUPLEGET-TAG = next-tag()
;val KMIX-TAG = next-tag()
;val KCURRY-TAG = next-tag()
;
;;KLSType Tags
;reset-tag-counter()
;val KBYTET-TAG = next-tag()
;val KINTT-TAG = next-tag()
;val KLONGT-TAG = next-tag()
;val KFLOATT-TAG = next-tag()
;val KDOUBLET-TAG = next-tag()
;val KUNKNOWNT-TAG = next-tag()
;val KPTRT-TAG = next-tag()
;val KREFT-TAG = next-tag()
;val KFNT-TAG = next-tag()
;val KSTRUCTT-TAG = next-tag()
;
;;KLoc Tags
;reset-tag-counter()
;val LOC-VALUE-TAG = next-tag()
;val LOC-DEREF-TAG = next-tag()
;val LOC-DEPTR-TAG = next-tag()
;val LOC-SLOT-TAG = next-tag()
;val LOC-FIELD-TAG = next-tag()
;
;;KLSComm Tags
;reset-tag-counter()
;val KLSIGNORECOMM-TAG = next-tag()
;val KLSSET-TAG = next-tag()
;val KLSLABELS-TAG = next-tag()
;val KLSLABEL-TAG = next-tag()
;val KLSLABELEDBLOCK-TAG = next-tag()
;val KLSGOTO-TAG = next-tag()
;val KLSRETURN-TAG = next-tag()
;val KLSDEFLOCAL-TAG = next-tag()
;val KLSDEFLOCALVAR-TAG = next-tag()
;val KLSSEQ-TAG = next-tag()
;val KLSIF-TAG = next-tag()
;val KLSMATCH-TAG = next-tag()
;val KLSDISPATCH-TAG = next-tag()
;val KLSSKIP-TAG = next-tag()
;val KLSBRANCHERROR-TAG = next-tag()
;
;;KLSExp Tags
;reset-tag-counter()
;val KLSLET-TAG = next-tag()
;val KLSVAR-TAG = next-tag()
;val KLSREF-TAG = next-tag()
;val KLSREFARRAY-TAG = next-tag()
;val KLSSTRUCT-TAG = next-tag()
;val KLSPTR-TAG = next-tag()
;val KLSREAD-TAG = next-tag()
;val KLSPRIM-TAG = next-tag()
;val KLSCALL-TAG = next-tag()
;val KLSSWITCHSTACK-TAG = next-tag()
;val KLSCALLC-TAG = next-tag()
;val KLSSIZEOF-TAG = next-tag()
;val KLSTAGOF-TAG = next-tag()
;val KLSCONV-TAG = next-tag()
;val KLSINTERPRET-TAG = next-tag()
;val KLSLITBYTE-TAG = next-tag()
;val KLSLITINT-TAG = next-tag()
;val KLSLITLONG-TAG = next-tag()
;val KLSLITFLOAT-TAG = next-tag()
;val KLSLITDOUBLE-TAG = next-tag()
;val KLSLITSTRING-TAG = next-tag()
;val KLSMIX-TAG = next-tag()
;val KLSCURRY-TAG = next-tag()
;val KLSFN-TAG = next-tag()
;
;defn put-short-list (o:FileOutputStream, xs:List<Int>) :
;   put(o, to-byte(length(xs)))
;   for x in xs do : put(o, x)
;
;defn put (o:FileOutputStream, s:String) :
;   put(o, length(s))
;   print(o, s)
;
;defn put (o:FileOutputStream, s:Symbol) :
;   put(o, to-string(s))
;
;defn serialize (o:FileOutputStream, ts:List<Type>) :
;   put(o, to-byte(length(ts)))
;   for t in ts do : serialize(o, t)
;
;defn serialize (o:FileOutputStream, ts:List<LSType>) :
;   put(o, to-byte(length(ts)))
;   for t in ts do : serialize(o, t)
;
;defn serialize (o:FileOutputStream, f:False) :
;   put(o, 0Y)
;
;defn serialize (o:FileOutputStream, t:True) :
;   put(o, 1Y)
;
;defn serialize (o:FileOutputStream, t:Type) :
;   defn puto (b:Byte) : put(o, b)
;   defn puto (i:Int) : put(o, i)
;
;   match(t) :
;      (t:TPoly) :
;         puto(TPOLY-TAG)
;         put-short-list(o, targs(t))
;         put-short-list(o, cargs(t))
;         serialize(o, func(t))
;      (t:TCap) :
;         puto(TCAP-TAG)
;         puto(n(t))
;      (t:TOf) :
;         puto(TOF-TAG)
;         puto(n(t))
;         serialize(o, type(t))
;      (t:TTuple) :
;         puto(TTUPLE-TAG)
;         serialize(o, types(t))
;      (t:TOr) :
;         puto(TOR-TAG)
;         serialize(o, a(t))
;         serialize(o, b(t))
;      (t:TAnd) :
;         puto(TAND-TAG)
;         serialize(o, a(t))
;         serialize(o, b(t))
;      (t:TVar) :
;         puto(TVAR-TAG)
;         puto(n(t))
;      (t:TArrow) :
;         puto(TARROW-TAG)
;         serialize(o, a(t))
;         serialize(o, b(t))
;      (t:TGradual) :
;         puto(TGRADUAL-TAG)
;      (t:TBot) :
;         puto(TBOT-TAG)
;      (t) :
;         fatal("Cannot serialize: %_" % [t])
;
;defn serialize (o:FileOutputStream, t:LSType) :
;   defn puto (b:Byte) : put(o, b)
;   defn puto (i:Int) : put(o, i)
;
;   match(t) :
;      (t:ByteT) : puto(BYTET-TAG)
;      (t:IntT) : puto(INTT-TAG)
;      (t:LongT) : puto(LONGT-TAG)
;      (t:FloatT) : puto(FLOATT-TAG)
;      (t:DoubleT) : puto(DOUBLET-TAG)
;      (t:UnknownT) : puto(UNKNOWNT-TAG)
;      (t:PolyT) :
;         puto(POLYT-TAG)
;         put-short-list(o, targs(t))
;         put-short-list(o, cargs(t))
;         serialize(o, func(t))
;      (t:RestT) :
;         puto(RESTT-TAG)
;         serialize(o, type(t))
;      (t:PtrT) :
;         puto(PTRT-TAG)
;         serialize(o, type(t))
;      (t:RefT) :
;         puto(REFT-TAG)
;         serialize(o, type(t))
;      (t:FnT) :
;         puto(FNT-TAG)
;         serialize(o, a(t))
;         serialize(o, r(t))
;         serialize(o, b(t))
;      (t:StructT) :
;         puto(STRUCTT-TAG)
;         puto(n(t))
;         serialize(o, type(t))
;      (t) :
;         fatal("Cannot serialize: %_" % [t])
;
;defn serialize (o:FileOutputStream, v:Vis) :
;   defn puto (b:Byte) : put(o, b)
;
;   match(v) :
;      (v:Local) : puto(LOCAL-TAG)
;      (v:Private) : puto(PRIVATE-TAG)
;      (v:Protected) : puto(PROTECTED-TAG)
;      (v:Public) : puto(PUBLIC-TAG)
;
;defn serialize (o:FileOutputStream, e:EType) :
;   defn puto (b:Byte) : put(o, b)
;
;   match(e) :
;      (e:ValE) : puto(VALE-TAG)
;      (e:VarE) : puto(VARE-TAG)
;      (e:TVarE) : puto(TVARE-TAG)
;      (e:CapVarE) : puto(CAPVARE-TAG)
;      (e:TypeE) : puto(TYPEE-TAG)
;      (e:MultiE) : puto(MULTIE-TAG)
;      (e:FnE) : puto(FNE-TAG)
;      (e:LValE) : puto(LVALE-TAG)
;      (e:LVarE) : puto(LVARE-TAG)
;      (e:LFnE) : puto(LFNE-TAG)
;      (e:LTypeE) : puto(LTYPEE-TAG)
;      (e:FieldE) : puto(FIELDE-TAG)
;      (e:LabelE) : puto(LABELE-TAG)
;
;defn serialize (o:FileOutputStream, i:FileInfo) :
;   put(o, filename(i))
;   put(o, line(i))
;   put(o, column(i))
;
;defn serialize (o:FileOutputStream, f:Field) :
;   put(o, n(f))
;   put(o, name(f))
;   serialize(o, type(f))
;
;defn serialize (o:FileOutputStream, c:Child) :
;   put(o, n(c))
;   put-short-list(o, args(c))
;   serialize(o, parent(c))
;
;defn serialize (o:FileOutputStream, cs:List<Child>) :
;   put(o, to-byte(length(cs)))
;   for c in cs do : serialize(o, c)
;
;defn serialize (o:FileOutputStream, fs:List<Field>) :
;   put(o, to-byte(length(fs)))
;   for f in fs do : serialize(o, f)
;
;defn serialize (o:FileOutputStream, c:PkgComm) :
;   defn puto (x:Byte) : put(o, x)
;   defn puto (x:Int) : put(o, x)
;   defn puto (x:Symbol) : put(o, x)
;   defn puto (x:List<Int>) : put-short-list(o, x)
;
;   match(c) :
;      (c:DefInfo) :
;         puto(DEFINFO-TAG)
;         puto(n(c))
;         puto(name(c))
;         puto(package(c))
;         serialize(o, visibility(c))
;         serialize(o, category(c))
;         serialize(o, info(c))
;      (c:DefVal) :
;         puto(DEFVAL-TAG)
;         puto(n(c))
;         serialize(o, type(c))
;         serialize(o, ls-type(c))
;      (c:DefType) :
;         puto(DEFTYPE-TAG)
;         puto(n(c))
;         puto(args(c))
;         serialize(o, parent(c))
;         serialize(o, children(c))
;      (c:DefLSType) :
;         puto(DEFLSTYPE-TAG)
;         puto(n(c))
;         puto(args(c))
;         serialize(o, parent(c))
;         serialize(o, fields(c))
;
;defn serialize (o:FileOutputStream, p:Pkg) :
;   put(o, name(p))
;   put(o, length(comms(p)))
;   for c in comms(p) do :
;      serialize(o, c)
;
;
;
;;============================================================
;;=================== Deserialization ========================
;;============================================================
;
;
;
;defn deserialize-pkg (i:FileInputStream) -> Pkg :
;   val name = get-symbol!(i)
;   val n = get-int!(i)
;   val comms = get-list(n, deserialize-pkg-comm, i)
;   Pkg(name, comms)
;
;defn deserialize-pkg-comm (i:FileInputStream) -> PkgComm :
;   val tag = get-tag!("PkgComm", i)
;   switch {tag == _} :
;      DEFINFO-TAG :
;         DefInfo(
;            get-int!(i)
;            get-symbol!(i)
;            get-symbol!(i)
;            deserialize-vis(i)
;            deserialize-category(i)
;            deserialize-file-info(i))
;      DEFVAL-TAG :
;         DefVal(
;            get-int!(i),
;            get-optional(deserialize-type, i)
;            get-optional(deserialize-ls-type, i))
;      DEFTYPE-TAG :
;         DefType(
;            get-int!(i)
;            get-short-list(get-int!, i)
;            get-optional(deserialize-type,i)
;            get-short-list(deserialize-child, i))
;      DEFLSTYPE-TAG :
;         DefLSType(
;            get-int!(i),
;            get-short-list(get-int!, i)
;            get-optional(deserialize-type,i)
;            get-short-list(deserialize-field, i))
;      else :
;         throw(InvalidTag(tag))
;
;defn deserialize-child (i:FileInputStream) -> Child :
;   Child(
;      get-int!(i)
;      get-short-list(get-int!, i)
;      deserialize-type(i))
;
;defn deserialize-field (i:FileInputStream) -> Field :
;   Field(
;      get-int!(i)
;      get-symbol!(i)
;      deserialize-ls-type(i))
;
;defn deserialize-file-info (i:FileInputStream) -> FileInfo :
;   FileInfo(
;      get-string!(i)
;      get-int!(i)
;      get-int!(i))
;
;defn deserialize-category (i:FileInputStream) -> EType :
;   val tag = get-tag!("Category", i)
;   switch {tag == _} :
;      VALE-TAG : ValE()
;      VARE-TAG : VarE()
;      TVARE-TAG : TVarE()
;      CAPVARE-TAG : CapVarE()
;      TYPEE-TAG : TypeE()
;      MULTIE-TAG : MultiE()
;      FNE-TAG : FnE()
;      LVALE-TAG : LValE()
;      LVARE-TAG : LVarE()
;      LFNE-TAG : LFnE()
;      LTYPEE-TAG : LTypeE()
;      FIELDE-TAG : FieldE()
;      LABELE-TAG : LabelE()
;      else : throw(InvalidTag(tag))
;
;defn deserialize-vis (i:FileInputStream) -> Vis :
;   val tag = get-tag!("Vis", i)
;   switch {tag == _} :
;      LOCAL-TAG : Local()
;      PRIVATE-TAG : Private()
;      PROTECTED-TAG : Protected()
;      PUBLIC-TAG : Public()
;      else : throw(InvalidTag(tag))
;
;defn deserialize-type (i:FileInputStream) -> Type :
;   deserialize-type(get-tag!("Type", i), i)
;
;defn deserialize-type (tag:Byte, i:FileInputStream) -> Type :
;   defn deserialize-arrow (i:FileInputStream) :
;      match(deserialize-type(i)) :
;         (t:TArrow) : t
;         (t) : throw(NotArrow())
;   switch {tag == _} :
;      TPOLY-TAG :
;         TPoly(
;            get-short-list(get-int!, i)
;            get-short-list(get-int!, i)
;            deserialize-arrow(i))
;      TCAP-TAG :
;         TCap(get-int!(i))
;      TOF-TAG :
;         TOf(
;            get-int!(i)
;            deserialize-type(i))
;      TTUPLE-TAG :
;         TTuple(
;            get-short-list(deserialize-type, i))
;      TOR-TAG :
;         TOr(
;            deserialize-type(i)
;            deserialize-type(i))
;      TAND-TAG :
;         TAnd(
;            deserialize-type(i)
;            deserialize-type(i))
;      TVAR-TAG :
;         TVar(get-int!(i))
;      TARROW-TAG :
;         TArrow(
;            deserialize-type(i)
;            deserialize-type(i))
;      TGRADUAL-TAG : TGradual()
;      TBOT-TAG : TBot()
;      else : throw(InvalidTag(tag))
;
;defn deserialize-ls-type (i:FileInputStream) -> LSType :
;   deserialize-ls-type(get-tag!("LSType", i), i)
;
;defn deserialize-ls-type (tag:Byte, i:FileInputStream) -> LSType :
;   defn deserialize-fn (i:FileInputStream) :
;      match(deserialize-ls-type(i)) :
;         (t:FnT) : t
;         (t) : throw(NotFn())
;   switch {tag == _} :
;      BYTET-TAG : ByteT()
;      INTT-TAG : IntT()
;      LONGT-TAG : LongT()
;      FLOATT-TAG : FloatT()
;      DOUBLET-TAG : DoubleT()
;      UNKNOWNT-TAG : UnknownT()
;      POLYT-TAG :
;         PolyT(
;            get-short-list(get-int!, i)
;            get-short-list(get-int!, i)
;            deserialize-fn(i))
;      RESTT-TAG :
;         RestT(deserialize-ls-type(i))
;      PTRT-TAG :
;         PtrT(deserialize-ls-type(i))
;      REFT-TAG :
;         RefT(deserialize-type(i))
;      FNT-TAG :
;         FnT(
;            get-short-list(deserialize-ls-type, i)
;            get-optional(deserialize-ls-type, i)
;            deserialize-ls-type(i))
;      STRUCTT-TAG :
;         StructT(
;            get-int!(i)
;            deserialize-type(i))
;      else : throw(InvalidTag(tag))
;
;defn get-int! (i:FileInputStream) :
;   match(get-int(i)) :
;      (i:Int) : i
;      (f:False) : throw(EOFException())
;
;defn get-char! (i:FileInputStream) :
;   match(get-char(i)) :
;      (x:Char) : x
;      (f:False) : throw(EOFException())
;
;defn get-byte! (i:FileInputStream) :
;   match(get-byte(i)) :
;      (x:Byte) : x
;      (f:False) : throw(EOFException())
;
;defn get-tag! (purpose:String, i:FileInputStream) :
;   get-byte!(i)
;
;defn get-bool! (i:FileInputStream) :
;   val b = get-byte!(i)
;   b == 1Y
;
;defn get-string! (i:FileInputStream) -> String :
;   val n = get-int!(i)
;   String(repeatedly(get-char!{i}, n))
;
;defn get-symbol! (i:FileInputStream) -> Symbol :
;   to-symbol(get-string!(i))
;
;defn get-short-list<?T> (f: FileInputStream -> ?T, i:FileInputStream) -> List<T> :
;   val n = to-int(get-byte!(i))
;   get-list(n, f, i)
;
;defn get-list<?T> (n:Int, f: FileInputStream -> ?T, i:FileInputStream) -> List<T> :
;   to-list(repeatedly(f{i}, n))
;
;defn get-optional<?T> (f: (Byte, FileInputStream) -> ?T, i:FileInputStream) -> False|T :
;   val tag = get-byte!(i)
;   if tag != 0Y :
;      f(tag, i)
;
;defn InvalidTag (tag:Byte) :
;   Exception("Invalid tag %_ during pkg deserialization." % [tag])
;defn EOFException () :
;   Exception("Reached end of file during pkg deserialiation.")
;defn NotArrow () :
;   Exception("Expected an arrow type during pkg deserialization.")
;defn NotFn () :
;   Exception("Expected a LoStanza function type during pkg deserialization.")


;============================================================
;=================== ID Renaming ============================
;============================================================

;Track renamed ids
val ID-TABLE = HashTable<Int,Int>()
defn rename-id (n:Int) :
   if stable-id?(n) :
      n
   else :
      if not key?(ID-TABLE, n) :
         ID-TABLE[n] = fresh-id()
      ID-TABLE[n]

defn rename-pkg (pkg:Pkg) :
   defn rename-comm (c:PkgComm) :
      match(c) :
         (c:DefInfo) :
            DefInfo(
               rename-id(n(c))
               name(c)
               package(c)
               visibility(c)
               category(c)
               info(c))
         (c:DefVal) :
            DefVal(
               rename-id(n(c))
               rename-type(type(c))
               rename-type(ls-type(c)))
         (c:DefType) :
            DefType(
               rename-id(n(c))
               map(rename-id, args(c))
               rename-type(parent(c))
               map(rename-child, children(c)))
         (c:DefLSType) :
            DefLSType(
               rename-id(n(c))
               map(rename-id, args(c))
               rename-type(parent(c))
               map(rename-field, fields(c)))

   defn rename-type (t:Type) :
      match(map(rename-type, t)) :
         (t:TPoly) : TPoly(map(rename-id, targs(t)), map(rename-id, cargs(t)), func(t))
         (t:TCap) : TCap(rename-id(n(t)))
         (t:TOf) : TOf(rename-id(n(t)), type(t))
         (t:TVar) : TVar(rename-id(n(t)))
         (t) : t

   defn rename-type (t:LSType) :
      val t* = map(rename-type{_:LSType}, map(rename-type{_:Type}, t))
      match(t*) :
         (t:PolyT) : PolyT(map(rename-id,targs(t)), map(rename-id,cargs(t)), func(t))
         (t:StructT): StructT(rename-id(n(t)), type(t))
         (t) : t

   defn rename-type (f:False) :
      false

   defn rename-child (c:Child) :
      Child(
         rename-id(n(c))
         map(rename-id, args(c))
         rename-type(parent(c)))

   defn rename-field (f:Field) :
      Field(
         rename-id(n(f))
         name(f)
         rename-type(type(f)))

   val comms* = map(rename-comm, comms(pkg))
   Pkg(name(pkg), comms*)

;============================================================
;================ Name Mangling =============================
;============================================================

lostanza deftype BitMap :
   words: long
   length: long
   bits: long ...

lostanza defn CharMap () -> ref<BitMap> :
   val length = 256
   val words = length >>> 6
   val map = new BitMap{words, length}
   for (var i:long = 0, i < words, i = i + 1) :
      map.bits[i] = 0
   return map

lostanza defn get (m:ref<BitMap>, i:ref<Int>) -> ref<True|False> :
   val bit = i.value
   val bit-div-64 = bit >>> 6
   val bit-mod-64 = bit & 63
   val word = m.bits[bit-div-64]
   val v = (word >> bit-mod-64) & 1
   if v : return true
   else : return false

lostanza defn set (m:ref<BitMap>, i:ref<Int>, v:ref<True|False>) -> ref<False> :
   val bit = i.value
   val bit-div-64 = bit >>> 6
   val bit-mod-64 = bit & 63
   val word = m.bits[bit-div-64]
   if v == true :
      m.bits[bit-div-64] = word | (1L << (bit-mod-64 as long))
   else :
      m.bits[bit-div-64] = word & (~ 1L << (bit-mod-64 as long))
   return false

val VALID-FILENAME-CHARS = let :
   val m = CharMap()
   defn add-range (a:Char, b:Char) :
      for i in to-int(a) through to-int(b) do :
         m[i] = true
   defn add-chars (str:String) :
      for c in str do :
         m[to-int(c)] = true
   add-range('0', '9')
   add-range('a', 'z')
   add-range('A', 'Z')
   add-chars("-.")
   m

defn package-filename (name:Symbol) :
   val buffer = StringBuffer()
   for c in to-string(name) do :
      if VALID-FILENAME-CHARS[to-int(c)] :
         add(buffer, c)
      else if c == '/' :
         add(buffer, '$')
      else :
         print(buffer, "_%_" % [to-int(c)])
   print(buffer, ".pkg")
   to-string(buffer)

defn package-filepath (name:Symbol) :
   to-string("%_/pkgs/%_" % [STANZA-INSTALL-DIR, package-filename(name)])

;============================================================
;=================== Drivers ================================
;============================================================

public defn save-pkg (pkg:Pkg) :
   serialize(package-filepath(name(pkg)), pkg)

public defn load-pkg (name:Symbol) :
   val pkg = deserialize-pkg(package-filepath(name))
   rename-pkg(pkg)
      
