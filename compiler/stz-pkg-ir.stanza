;============================================================
;==================== Pkg Language ==========================
;============================================================

defpackage stz/pkg-ir :
   import core
   import collections
   import stz/namemap
   import stz/tl-ir with :
      prefix(Field, Child) => T
   import stz/params
   import stz/ids
   import stz/kl-ir with :
      prefix(Child) => K

#use-overlay(stz/ast-lang, stz/printer-lang)

public defast :
   deftype PkgComm
   defnodes PkgComm :
      DefInfo :
         n: Int
         name: Symbol
         package: Symbol
         visibility: Vis
         category: EType
         info: FileInfo
      DefVal :
         n: Int
         type: False|Type
         ls-type: False|LSType
      DefType :
         n: Int
         args: List<Int>
         parent: False|Type
         children: List<Child>
      DefLSType :
         n: Int
         args: List<Int>
         parent: False|Type
         fields: List<Field>

public defstruct Child :
   n: Int
   args: List<Int>
   parent: Type

public defstruct Field :
   n: Int
   name: Symbol
   type: LSType

public defstruct Pkg :
   name: Symbol
   comms: List<PkgComm>

;============================================================
;==================== Printers ==============================
;============================================================

defprinter (c:PkgComm) :
   DefInfo :
      ($definfo n name package visibility category info)
   DefVal :
      ($defval n type ls-type)
   DefType :
      ($deftype n args parent)
   DefLSType :
      ($deflstype n args parent fields ...)

defprinter (f:Field) :
   Field :
      ($field n name type)

defprinter (c:Child) :
   Child :
      ($child n (args ...) parent)

defprinter (p:Pkg) :
   Pkg :
      ($pkg name comms ...)


;============================================================
;=================== Serialization ==========================
;============================================================

defn serialize (filename:String, p:Pkg) :
   val f = FileOutputStream(filename)
   try : serialize(f, p)
   finally : close(f)

defn deserialize-pkg (filename:String) :
   val f = FileInputStream(filename)
   try : deserialize-pkg(f)
   finally : close(f)

#with-syntax(core, stz/serializer-lang) :
   defserializer (out:FileOutputStream, in:FileInputStream) :
      defunion pkg (Pkg) :
         Pkg: (name:symbol, comms:list(pkgcomm))
         
      defunion type (Type) :
         TMixed: (types:slist(type as TArrow))
         TPoly: (targs:slist(int), cargs:slist(int), func:type as TArrow)
         TCap: (n:int)
         TOf: (n:int, type:type)
         TTuple: (types:slist(type))
         TOr: (a:type, b:type)
         TAnd: (a:type, b:type)
         TVar: (n:int)
         TArrow: (a:type, b:type)
         TGradual: ()
         TBot: ()

      defunion lstype (LSType) :
         ByteT: ()
         IntT: ()
         LongT: ()
         FloatT: ()
         DoubleT: ()
         UnknownT: ()
         PolyT: (targs:slist(int), cargs:slist(int), func:lstype as FnT)
         RestT: (type:lstype)
         PtrT: (type:lstype)
         RefT: (type:type)
         FnT: (a:slist(lstype), r:opt<LSType>(lstype), b:lstype)
         StructT: (n:int, type:type)

      defunion pkgcomm (PkgComm) :
         DefInfo : (n:int, name:symbol, package:symbol, visibility:vis, category:category, info:info)
         DefVal : (n:int, type:opt<Type>(type), ls-type:opt<LSType>(lstype))
         DefType : (n:int, args:slist(int), parent:opt<Type>(type), children:slist(child))
         DefLSType : (n:int, args:slist(int), parent:opt<Type>(type), fields:slist(field))

      defunion vis (Vis) :
         Private: ()
         Protected: ()
         Public: ()
         Local: ()

      defunion category (EType) :
         ValE: ()
         VarE: ()
         TVarE: ()
         CapVarE: ()
         TypeE: ()
         MultiE: ()
         FnE: ()
         LValE: ()
         LVarE: ()
         LFnE: ()
         LTypeE: ()
         FieldE: ()
         LabelE: ()

      defunion field (Field) :
         Field: (n:int, name:symbol, type:lstype)

      defunion child (Child) :
         Child: (n:int, args:slist(int), parent:type)

      defunion info (FileInfo) :
         FileInfo: (filename:string, line:int, column:int)

      defunion ktype (KType) :
         KOf: (n:int)
         KTVar: (n:int)
         KAnd: (a:ktype, b:ktype)
         KOr: (a:ktype, b:ktype)
         KTop: ()
         KBot: ()
      
      defunion klstype (KLSType) :
         KByteT: ()
         KIntT: ()
         KLongT: ()
         KFloatT: ()
         KDoubleT: ()
         KUnknownT: ()
         KPtrT: (type:klstype)
         KRefT: (type:ktype)
         KFnT: (a:slist(klstype), r:opt<KLSType>(klstype), b:klstype)
         KStructT: (n:int)
      
      defunion kloc (KLoc) :
         Value: (exp:klsexp)
         Deref: (exp:klsexp, type:klstype)
         Deptr: (exp:klsexp, type:klstype)
         Slot: (exp:klsexp, type:klstype, index:klsexp)
         Field: (base:kloc, n:int)

      defunion kcomm (KComm) :
         KDef :
            n: int
            value: kexp
         KDefVar :
            n: int
            type: ktype
            value: opt<KExp>(kexp)
         KDefn :
            n: int
            value: kfunc
         KDefmulti :
            n: int
            targs: slist(int)
            a1: slist(ktype)
            a2: ktype
            info: opt<FileInfo>(info)
         KDefmethod :
            n: int
            multi: int
            targs: slist(ktype)
            thisn: opt<Int>(int)
            func: kfunc as KFn
         KDefType :
            n: int
            parent: opt<KType>(ktype)
            children: slist(kchild)
         KInit :
            exp: kexp

         KLSDef :
            n: int
            type: klstype
            value: klsexp
         KLSDefVar :
            n: int
            type: klstype
            value: opt<KLSExp>(klsexp)
         KLSDefn :
            tail?: lit as True|False
            n: int
            targs: slist(int)
            a1: slist(klstype)
            a2: klstype
            args: slist(int)
            body: klscomm
            info: opt<FileInfo>(info)
         KLSExternFn :
            n: int
            lbl: symbol
            a1: slist(klstype)
            a2: klstype
            args: slist(int)
            body: klscomm
            info: opt<FileInfo>(info)
         KLSDefmethod :
            tail?: lit as True|False
            n: int
            multi: int
            multi-targs: slist(ktype)
            targs: slist(int)
            a1: slist(klstype)
            a2: klstype
            args: slist(int)
            body: klscomm
            info: opt<FileInfo>(info)
         KLSDefType :
            n: int
            parent: opt<KType>(ktype)
            fields: slist(kfield)
            rfield: opt<StructField>(kfield)
         KExtern :
            n: int
            type: klstype
            lbl: symbol
         KLSInit :
            comm: klscomm

      ;TODO: kop
      defunion kexp (KExp) :
         KSet: (n:int, value:kexp)
         KCast: (exp:kexp, targ:ktype, info:opt<FileInfo>(info))
         KCheckLength: (exp:kexp, length:int, info:opt<FileInfo>(info))
         KLet: (def:kcomm as KDef|KDefVar|KDefn, body:kexp)
         KLetRec: (defs:slist(kcomm as KDefn|KDef), body:kexp, info:opt<FileInfo>(info))
         KSeq: (a:kexp, b:kexp)
         KDispatch: (args:slist(kexp), branches:slist(kbranch), info:opt<FileInfo>(info))
         KMatch: (args:slist(kexp), branches:slist(kbranch), info:opt<FileInfo>(info))
         KNew: (class:ktype, methods:slist(kcomm as KDefmethod), info:opt<FileInfo>(info))
         KDo: (func:kexp, args:slist(kexp), a1:slist(ktype), a2:ktype, info:opt<FileInfo>(info))
         KVar: (n:int, info:opt<FileInfo>(info))
         KPrim: (op:kop, args:slist(kexp))
         KLiteral: (value:lit)
         KTuple: (exps:slist(kexp), info:opt<FileInfo>(info))
         KTupleGet: (exp:kexp, index:int, info:opt<FileInfo>(info))
         KMix: (exps:slist(kexp as KCurry), info:opt<FileInfo>(info))
         KCurry: (n:int, targs:slist(ktype), a1:slist(ktype), a2:ktype, info:opt<FileInfo>(info))

      ;TODO: klsop
      defunion klsexp (KLSExp) :
         KLSLet: (comm:klscomm, exp:klsexp)
         KLSVar: (n:int) 
         KLSRef: (n:int, args:slist(klsexp), info:opt<FileInfo>(info)) 
         KLSRefArray: (n:int, args:slist(klsexp), info:opt<FileInfo>(info)) 
         KLSStruct: (n:int, args:slist(klsexp)) 
         KLSPtr: (exp:kloc) 
         KLSRead: (exp:kloc) 
         KLSPrim: (op:klsop, args:slist(klsexp), type:klstype) 
         KLSCall: (func:klsexp, args:slist(klsexp), type:klstype, new-stack?:lit as True|False, info:opt<FileInfo>(info)) 
         KLSSwitchStack: (func:klsexp, arg:klsexp, type:klstype, info:opt<FileInfo>(info)) 
         KLSCallC: (func:klsexp, args:slist(klsexp), type:klstype, info:opt<FileInfo>(info)) 
         KLSSizeof: (type:klstype) 
         KLSTagof: (n:int) 
         KLSConv: (exp:klsexp, type:klstype, info:opt<FileInfo>(info)) 
         KLSInterpret: (exp:klsexp, type:klstype) 
         KLSLitByte: (value:byte) 
         KLSLitInt: (value:int) 
         KLSLitLong: (value:long) 
         KLSLitFloat: (value:float) 
         KLSLitDouble: (value:double) 
         KLSLitString: (value:string) 
         KLSMix: (exps:slist(klsexp as KLSCurry)) 
         KLSCurry: (n:int, targs:slist(ktype), a1:slist(klstype), a2:klstype) 
         KLSFn: (ref:kexp) 

      defunion klscomm (KLSComm) :
         KLSIgnoreComm: (exp:klsexp) 
         KLSSet: (exp:kloc, value:klsexp) 
         KLSLabels: (blocks:slist(klscomm as KLSLabeledBlock)) 
         KLSLabel: (n:int) 
         KLSLabeledBlock: (n:int, args:slist(int), types:slist(klstype), body:klscomm) 
         KLSGoto: (n:int, args:slist(klsexp)) 
         KLSReturn: (exp:klsexp) 
         KLSDefLocal: (n:int, value:klsexp) 
         KLSDefLocalVar: (n:int, type:klstype, value:opt<KLSExp>(klsexp)) 
         KLSSeq: (a:klscomm, b:klscomm) 
         KLSIf: (pred:klsexp, conseq:klscomm, alt:klscomm) 
         KLSMatch: (args:slist(klsexp), branches:slist(klsbranch), info:opt<FileInfo>(info)) 
         KLSDispatch: (args:slist(klsexp), branches:slist(klsbranch), info:opt<FileInfo>(info)) 
         KLSSkip: ()
         KLSBranchError: (amb?:lit as True|False, info:opt<FileInfo>(info))

      defatom lit (x:?) :
         writer :
            match(x) :
               (x:Byte) :
                  write-byte(0Y)
                  write-byte(x)
               (x:Char) :
                  write-byte(1Y)
                  write-char(x)
               (x:Int) :
                  write-byte(2Y)
                  write-int(x)
               (x:Long) :
                  write-byte(3Y)
                  write-long(x)
               (x:Float) :
                  write-byte(4Y)
                  write-float(x)
               (x:Double) :
                  write-byte(5Y)
                  write-double(x)
               (x:String) :
                  write-byte(6Y)
                  write-string(x)
               (x:Symbol) :
                  write-byte(7Y)
                  write-symbol(x)
               (x:List) :
                  write-byte(8Y)
                  write-list(write-lit, x)
               (x:True) :
                  write-byte(9Y)                  
               (x:False) :
                  write-byte(10Y)
         reader :
            val tag = read-byte()
            switch {tag == _} :
               0Y : read-byte()
               1Y : read-char()
               2Y : read-int()
               3Y : read-long()
               4Y : read-float()
               5Y : read-double()
               6Y : read-string()
               7Y : read-symbol()
               8Y : read-list(read-lit)
               9Y : true
               10Y : false

      defunion KLSBranch (KLSBranch) :
         KLSBranch: (args:slist(int), types:slist(ktype), body:klscomm)

      defunion KBranch (KBranch) :
         KBranch: (args:slist(int), types:slist(ktype), body:kexp, info:opt<FileInfo>(info))

      defunion kfunc (Func) :
         KFn: (n:int, tail?:lit as True|False, targs:slist(int), a1:slist(ktype),
               a2:ktype, closure:opt<Int>(int), args:slist(int), body:kexp, info:opt<FileInfo>(fileinfo))
         KMultifn: (n:int, funcs:slist(kfunc as KFn), info:opt<FileInfo>(fileinfo))

      defunion kchild (KChild) :
         KChild: (n:int, parent:ktype)

      defunion kfield (StructField) :
         StructField: (n:int, type:klstype)

      reader defn read-slist<?T> (f: () -> ?T) :
         val n = read-byte()
         to-list(repeatedly(f, to-int(n)))
         
      writer defn write-slist<?T> (f: T -> False, xs:List<?T>) :
         write-byte(to-byte(length(xs)))
         do(f, xs)

      reader defn read-list<?T> (f: () -> ?T) :
         val n = read-int()
         to-list(repeatedly(f, n))
         
      writer defn write-list<?T> (f: T -> False, xs:List<?T>) :
         write-int(length(xs))
         do(f, xs)

      reader defn read-opt<T> (f: () -> T) :
         val n = read-byte()
         f() when n == 1Y

      writer defn write-opt<T> (f: T -> False, x:T|False) :
         if x is False :
            write-byte(0Y)
         else :
            write-byte(1Y)
            f(x as T)

      defatom int (x:Int) :
         writer :
            put(out, x)
         reader :
            match(get-int(in)) :
               (x:Int) : x
               (x:False) : throw(FileReadException())

      defatom long (x:Long) :
         writer :
            put(out, x)
         reader :
            match(get-long(in)) :
               (x:Long) : x
               (x:False) : throw(FileReadException())

      defatom float (x:Float) :
         writer :
            put(out, x)
         reader :
            match(get-float(in)) :
               (x:Float) : x
               (x:False) : throw(FileReadException())

      defatom double (x:Double) :
         writer :
            put(out, x)
         reader :
            match(get-double(in)) :
               (x:Double) : x
               (x:False) : throw(FileReadException())

      defatom byte (x:Byte) :
         writer :
            put(out, x)
         reader :
            match(get-byte(in)) :
               (x:Byte) : x
               (x:False) : throw(FileReadException())

      defatom char (x:Char) :
         writer :
            print(out, x)
         reader :
            match(get-char(in)) :
               (x:Char) : x
               (x:False) : throw(FileReadException())

      defatom string (x:String) :
         writer :
            write-int(length(x))
            print(out, x)
         reader :
            val n = read-int()
            String(repeatedly(read-char, n))

      defatom symbol (x:Symbol) :
         writer : write-string(to-string(x))
         reader : to-symbol(read-string())

      defn ensure<T> (f: ? -> True|False, x) :
         if f(x) : x as T
         else : throw(FileReadException())

;============================================================
;=================== ID Renaming ============================
;============================================================

;Track renamed ids
val ID-TABLE = HashTable<Int,Int>()
defn rename-id (n:Int) :
   if stable-id?(n) :
      n
   else :
      if not key?(ID-TABLE, n) :
         ID-TABLE[n] = fresh-id()
      ID-TABLE[n]

defn rename-pkg (pkg:Pkg) :
   defn rename-comm (c:PkgComm) :
      match(c) :
         (c:DefInfo) :
            DefInfo(
               rename-id(n(c))
               name(c)
               package(c)
               visibility(c)
               category(c)
               info(c))
         (c:DefVal) :
            DefVal(
               rename-id(n(c))
               rename-type(type(c))
               rename-type(ls-type(c)))
         (c:DefType) :
            DefType(
               rename-id(n(c))
               map(rename-id, args(c))
               rename-type(parent(c))
               map(rename-child, children(c)))
         (c:DefLSType) :
            DefLSType(
               rename-id(n(c))
               map(rename-id, args(c))
               rename-type(parent(c))
               map(rename-field, fields(c)))

   defn rename-type (t:Type) :
      match(map(rename-type, t)) :
         (t:TPoly) : TPoly(map(rename-id, targs(t)), map(rename-id, cargs(t)), func(t))
         (t:TCap) : TCap(rename-id(n(t)))
         (t:TOf) : TOf(rename-id(n(t)), type(t))
         (t:TVar) : TVar(rename-id(n(t)))
         (t) : t

   defn rename-type (t:LSType) :
      val t* = map(rename-type{_:LSType}, map(rename-type{_:Type}, t))
      match(t*) :
         (t:PolyT) : PolyT(map(rename-id,targs(t)), map(rename-id,cargs(t)), func(t))
         (t:StructT): StructT(rename-id(n(t)), type(t))
         (t) : t

   defn rename-type (f:False) :
      false

   defn rename-child (c:Child) :
      Child(
         rename-id(n(c))
         map(rename-id, args(c))
         rename-type(parent(c)))

   defn rename-field (f:Field) :
      Field(
         rename-id(n(f))
         name(f)
         rename-type(type(f)))

   val comms* = map(rename-comm, comms(pkg))
   Pkg(name(pkg), comms*)

;============================================================
;================ Name Mangling =============================
;============================================================

lostanza deftype BitMap :
   words: long
   length: long
   bits: long ...

lostanza defn CharMap () -> ref<BitMap> :
   val length = 256
   val words = length >>> 6
   val map = new BitMap{words, length}
   for (var i:long = 0, i < words, i = i + 1) :
      map.bits[i] = 0
   return map

lostanza defn get (m:ref<BitMap>, i:ref<Int>) -> ref<True|False> :
   val bit = i.value
   val bit-div-64 = bit >>> 6
   val bit-mod-64 = bit & 63
   val word = m.bits[bit-div-64]
   val v = (word >> bit-mod-64) & 1
   if v : return true
   else : return false

lostanza defn set (m:ref<BitMap>, i:ref<Int>, v:ref<True|False>) -> ref<False> :
   val bit = i.value
   val bit-div-64 = bit >>> 6
   val bit-mod-64 = bit & 63
   val word = m.bits[bit-div-64]
   if v == true :
      m.bits[bit-div-64] = word | (1L << (bit-mod-64 as long))
   else :
      m.bits[bit-div-64] = word & (~ 1L << (bit-mod-64 as long))
   return false

val VALID-FILENAME-CHARS = let :
   val m = CharMap()
   defn add-range (a:Char, b:Char) :
      for i in to-int(a) through to-int(b) do :
         m[i] = true
   defn add-chars (str:String) :
      for c in str do :
         m[to-int(c)] = true
   add-range('0', '9')
   add-range('a', 'z')
   add-range('A', 'Z')
   add-chars("-.")
   m

defn package-filename (name:Symbol) :
   val buffer = StringBuffer()
   for c in to-string(name) do :
      if VALID-FILENAME-CHARS[to-int(c)] :
         add(buffer, c)
      else if c == '/' :
         add(buffer, '$')
      else :
         print(buffer, "_%_" % [to-int(c)])
   print(buffer, ".pkg")
   to-string(buffer)

defn package-filepath (name:Symbol) :
   to-string("%_/pkgs/%_" % [STANZA-INSTALL-DIR, package-filename(name)])

;============================================================
;=================== Drivers ================================
;============================================================

public defn save-pkg (pkg:Pkg) :
   serialize(package-filepath(name(pkg)), pkg)

public defn load-pkg (name:Symbol) :
   val pkg = deserialize-pkg(package-filepath(name))
   rename-pkg(pkg)
      
