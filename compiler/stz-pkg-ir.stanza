;============================================================
;==================== Pkg Language ==========================
;============================================================

defpackage stz/pkg-ir :
   import core
   import collections
   import stz/namemap
   import stz/tl-ir with :
      prefix(Field) => T
   import stz/params
   import stz/ids

#use-overlay(stz/ast-lang, stz/printer-lang)

public defast :
   deftype PkgComm
   defnodes PkgComm :
      DefInfo :
         n: Int
         name: Symbol
         package: Symbol
         visibility: Vis
         category: EType
         info: FileInfo
      DefVal :
         n: Int
         type: False|Type
         ls-type: False|LSType
      DefType :
         n: Int
         args: List<Int>
         parent: False|Type
      DefLSType :
         n: Int
         args: List<Int>
         parent: False|Type
         fields: List<Field>
         
public defstruct Field :
   n: Int
   name: Symbol
   type: LSType

public defstruct Pkg :
   name: Symbol
   comms: List<PkgComm>

;============================================================
;==================== Printers ==============================
;============================================================

defprinter (c:PkgComm) :
   DefInfo :
      ($definfo n name package visibility category info)
   DefVal :
      ($defval n type ls-type)
   DefType :
      ($deftype n args parent)
   DefLSType :
      ($deflstype n args parent fields ...)

defprinter (f:Field) :
   Field :
      ($field n name type)

defprinter (p:Pkg) :
   Pkg :
      ($pkg name comms ...)
   
;============================================================
;=================== Serialization ==========================
;============================================================

;                  Serialiation Tags
;                  =================

var TAG-COUNTER:Seq<Int>
defn next-tag () : to-byte(next(TAG-COUNTER))
defn reset-tag-counter () : TAG-COUNTER = to-seq(1 to false)

;Type Tags
reset-tag-counter()
val TPOLY-TAG = next-tag()
val TCAP-TAG = next-tag()
val TOF-TAG = next-tag()
val TTUPLE-TAG = next-tag()
val TOR-TAG = next-tag()
val TAND-TAG = next-tag()
val TVAR-TAG = next-tag()
val TARROW-TAG = next-tag()
val TGRADUAL-TAG = next-tag()
val TBOT-TAG = next-tag()
;LoStanza Type Tags
val BYTET-TAG = next-tag()
val INTT-TAG = next-tag()
val LONGT-TAG = next-tag()
val FLOATT-TAG = next-tag()
val DOUBLET-TAG = next-tag()
val UNKNOWNT-TAG = next-tag()
val POLYT-TAG = next-tag()
val RESTT-TAG = next-tag()
val PTRT-TAG = next-tag()
val REFT-TAG = next-tag()
val FNT-TAG = next-tag()
val STRUCTT-TAG = next-tag()

;Category Tags
reset-tag-counter()
val VALE-TAG = next-tag()
val VARE-TAG = next-tag()
val TVARE-TAG = next-tag()
val CAPVARE-TAG = next-tag()
val TYPEE-TAG = next-tag()
val MULTIE-TAG = next-tag()
val FNE-TAG = next-tag()
val LVALE-TAG = next-tag()
val LVARE-TAG = next-tag()
val LFNE-TAG = next-tag()
val LTYPEE-TAG = next-tag()
val FIELDE-TAG = next-tag()
val LABELE-TAG = next-tag()

;Visibility Tags
reset-tag-counter()
val LOCAL-TAG = next-tag()
val PROTECTED-TAG = next-tag()
val PUBLIC-TAG = next-tag()

;Comm Tags
reset-tag-counter()
val DEFINFO-TAG = next-tag()
val DEFVAL-TAG = next-tag()
val DEFTYPE-TAG = next-tag()
val DEFLSTYPE-TAG = next-tag()

defn put-short-list (o:FileOutputStream, xs:List<Int>) :
   put(o, to-byte(length(xs)))
   for x in xs do : put(o, x)

defn put (o:FileOutputStream, s:String) :
   put(o, length(s))
   print(o, s)

defn put (o:FileOutputStream, s:Symbol) :
   put(o, to-string(s))

defn serialize (o:FileOutputStream, ts:List<Type>) :
   put(o, to-byte(length(ts)))
   for t in ts do : serialize(o, t)

defn serialize (o:FileOutputStream, ts:List<LSType>) :
   put(o, to-byte(length(ts)))
   for t in ts do : serialize(o, t)

defn serialize (o:FileOutputStream, f:False) :
   put(o, 0Y)

defn serialize (o:FileOutputStream, t:True) :
   put(o, 1Y)

defn serialize (o:FileOutputStream, t:Type) :
   defn puto (b:Byte) : put(o, b)
   defn puto (i:Int) : put(o, i)
   
   match(t) :
      (t:TPoly) :
         puto(TPOLY-TAG)
         put-short-list(o, targs(t))
         put-short-list(o, cargs(t))
         serialize(o, func(t))
      (t:TCap) :
         puto(TCAP-TAG)
         puto(n(t))
      (t:TOf) :
         puto(TOF-TAG)
         puto(n(t))
         serialize(o, type(t))
      (t:TTuple) :
         puto(TTUPLE-TAG)
         serialize(o, types(t))
      (t:TOr) :
         puto(TOR-TAG)
         serialize(o, a(t))
         serialize(o, b(t))
      (t:TAnd) :
         puto(TAND-TAG)
         serialize(o, a(t))
         serialize(o, b(t))
      (t:TVar) :
         puto(TVAR-TAG)
         puto(n(t))
      (t:TArrow) :
         puto(TARROW-TAG)
         serialize(o, a(t))
         serialize(o, b(t))
      (t:TGradual) :
         puto(TGRADUAL-TAG)
      (t:TBot) :
         puto(TBOT-TAG)
      (t) :
         fatal("Cannot serialize: %_" % [t])

defn serialize (o:FileOutputStream, t:LSType) :
   defn puto (b:Byte) : put(o, b)
   defn puto (i:Int) : put(o, i)
   
   match(t) :
      (t:ByteT) : puto(BYTET-TAG)
      (t:IntT) : puto(INTT-TAG)
      (t:LongT) : puto(LONGT-TAG)
      (t:FloatT) : puto(FLOATT-TAG)
      (t:DoubleT) : puto(DOUBLET-TAG)
      (t:UnknownT) : puto(UNKNOWNT-TAG)
      (t:PolyT) :
         puto(POLYT-TAG)
         put-short-list(o, targs(t))
         put-short-list(o, cargs(t))
         serialize(o, func(t))
      (t:RestT) :
         puto(RESTT-TAG)
         serialize(o, type(t))
      (t:PtrT) :
         puto(PTRT-TAG)
         serialize(o, type(t))
      (t:RefT) :
         puto(REFT-TAG)
         serialize(o, type(t))
      (t:FnT) :
         puto(FNT-TAG)
         serialize(o, a(t))
         serialize(o, r(t))
         serialize(o, b(t))
      (t:StructT) :
         puto(STRUCTT-TAG)
         puto(n(t))
         serialize(o, type(t))
      (t) :
         fatal("Cannot serialize: %_" % [t])

defn serialize (o:FileOutputStream, v:Vis) :
   defn puto (b:Byte) : put(o, b)
   
   match(v) :
      (v:Local) : puto(LOCAL-TAG)
      (v:Protected) : puto(PROTECTED-TAG)
      (v:Public) : puto(PUBLIC-TAG)

defn serialize (o:FileOutputStream, e:EType) :
   defn puto (b:Byte) : put(o, b)
   
   match(e) :
      (e:ValE) : puto(VALE-TAG)
      (e:VarE) : puto(VARE-TAG)
      (e:TVarE) : puto(TVARE-TAG)
      (e:CapVarE) : puto(CAPVARE-TAG)
      (e:TypeE) : puto(TYPEE-TAG)
      (e:MultiE) : puto(MULTIE-TAG)
      (e:FnE) : puto(FNE-TAG)
      (e:LValE) : puto(LVALE-TAG)
      (e:LVarE) : puto(LVARE-TAG)
      (e:LFnE) : puto(LFNE-TAG)
      (e:LTypeE) : puto(LTYPEE-TAG)
      (e:FieldE) : puto(FIELDE-TAG)
      (e:LabelE) : puto(LABELE-TAG)

defn serialize (o:FileOutputStream, i:FileInfo) :
   put(o, filename(i))
   put(o, line(i))
   put(o, column(i))

defn serialize (o:FileOutputStream, f:Field) :
   put(o, n(f))
   put(o, name(f))
   serialize(o, type(f))

defn serialize (o:FileOutputStream, fs:List<Field>) :
   put(o, to-byte(length(fs)))
   for f in fs do : serialize(o, f)

defn serialize (o:FileOutputStream, c:PkgComm) :
   defn puto (x:Byte) : put(o, x)
   defn puto (x:Int) : put(o, x)
   defn puto (x:Symbol) : put(o, x)
   defn puto (x:List<Int>) : put-short-list(o, x)

   match(c) :
      (c:DefInfo) :
         puto(DEFINFO-TAG)
         puto(n(c))
         puto(name(c))
         puto(package(c))
         serialize(o, visibility(c))
         serialize(o, category(c))
         serialize(o, info(c))
      (c:DefVal) :
         puto(DEFVAL-TAG)
         puto(n(c))
         serialize(o, type(c))
         serialize(o, ls-type(c))
      (c:DefType) :
         puto(DEFTYPE-TAG)
         puto(n(c))
         puto(args(c))
         serialize(o, parent(c))
      (c:DefLSType) :
         puto(DEFLSTYPE-TAG)
         puto(n(c))
         puto(args(c))
         serialize(o, parent(c))
         serialize(o, fields(c))

defn serialize (o:FileOutputStream, p:Pkg) :
   put(o, name(p))
   put(o, length(comms(p)))
   for c in comms(p) do :
      serialize(o, c)

defn serialize (filename:String, p:Pkg) :
   val f = FileOutputStream(filename)
   try : serialize(f, p)
   finally : close(f)

;============================================================
;=================== Deserialization ========================
;============================================================

defn deserialize-pkg (filename:String) :
   val f = FileInputStream(filename)
   try : deserialize-pkg(f)
   finally : close(f)

defn deserialize-pkg (i:FileInputStream) -> Pkg :
   val name = get-symbol!(i)
   val n = get-int!(i)
   val comms = get-list(n, deserialize-pkg-comm, i)
   Pkg(name, comms)

defn deserialize-pkg-comm (i:FileInputStream) -> PkgComm :
   val tag = get-tag!("PkgComm", i)
   switch {tag == _} :
      DEFINFO-TAG :
         DefInfo(
            get-int!(i)
            get-symbol!(i)
            get-symbol!(i)
            deserialize-vis(i)
            deserialize-category(i)
            deserialize-file-info(i))
      DEFVAL-TAG :
         DefVal(
            get-int!(i),
            get-optional(deserialize-type, i)
            get-optional(deserialize-ls-type, i))
      DEFTYPE-TAG :
         DefType(
            get-int!(i)
            get-short-list(get-int!, i)
            get-optional(deserialize-type,i))
      DEFLSTYPE-TAG :
         DefLSType(
            get-int!(i),
            get-short-list(get-int!, i)
            get-optional(deserialize-type,i)
            get-short-list(deserialize-field, i))
      else :
         throw(InvalidTag(tag))

defn deserialize-field (i:FileInputStream) -> Field :
   Field(
      get-int!(i)
      get-symbol!(i)
      deserialize-ls-type(i))

defn deserialize-file-info (i:FileInputStream) -> FileInfo :
   FileInfo(
      get-string!(i)
      get-int!(i)
      get-int!(i))

defn deserialize-category (i:FileInputStream) -> EType :
   val tag = get-tag!("Category", i)
   switch {tag == _} :
      VALE-TAG : ValE()
      VARE-TAG : VarE()
      TVARE-TAG : TVarE()
      CAPVARE-TAG : CapVarE()
      TYPEE-TAG : TypeE()
      MULTIE-TAG : MultiE()
      FNE-TAG : FnE()
      LVALE-TAG : LValE()
      LVARE-TAG : LVarE()
      LFNE-TAG : LFnE()
      LTYPEE-TAG : LTypeE()
      FIELDE-TAG : FieldE()
      LABELE-TAG : LabelE()
      else : throw(InvalidTag(tag))

defn deserialize-vis (i:FileInputStream) -> Vis :
   val tag = get-tag!("Vis", i)
   switch {tag == _} :
      LOCAL-TAG : Local()
      PROTECTED-TAG : Protected()
      PUBLIC-TAG : Public()
      else : throw(InvalidTag(tag))

defn deserialize-type (i:FileInputStream) -> Type :
   deserialize-type(get-tag!("Type", i), i)

defn deserialize-type (tag:Byte, i:FileInputStream) -> Type :
   defn deserialize-arrow (i:FileInputStream) :
      match(deserialize-type(i)) :
         (t:TArrow) : t
         (t) : throw(NotArrow())
   switch {tag == _} :
      TPOLY-TAG :
         TPoly(
            get-short-list(get-int!, i)
            get-short-list(get-int!, i)
            deserialize-arrow(i))
      TCAP-TAG :
         TCap(get-int!(i))
      TOF-TAG :
         TOf(
            get-int!(i)
            deserialize-type(i))
      TTUPLE-TAG :
         TTuple(
            get-short-list(deserialize-type, i))
      TOR-TAG :
         TOr(
            deserialize-type(i)
            deserialize-type(i))
      TAND-TAG :
         TAnd(
            deserialize-type(i)
            deserialize-type(i))
      TVAR-TAG :
         TVar(get-int!(i))
      TARROW-TAG :
         TArrow(
            deserialize-type(i)
            deserialize-type(i))
      TGRADUAL-TAG : TGradual()
      TBOT-TAG : TBot()         
      else : throw(InvalidTag(tag))

defn deserialize-ls-type (i:FileInputStream) -> LSType :
   deserialize-ls-type(get-tag!("LSType", i), i)

defn deserialize-ls-type (tag:Byte, i:FileInputStream) -> LSType :
   defn deserialize-fn (i:FileInputStream) :
      match(deserialize-ls-type(i)) :
         (t:FnT) : t
         (t) : throw(NotFn())
   switch {tag == _} :
      BYTET-TAG : ByteT()
      INTT-TAG : IntT()
      LONGT-TAG : LongT()
      FLOATT-TAG : FloatT()
      DOUBLET-TAG : DoubleT()
      UNKNOWNT-TAG : UnknownT()
      POLYT-TAG :
         PolyT(
            get-short-list(get-int!, i)
            get-short-list(get-int!, i)
            deserialize-fn(i))
      RESTT-TAG :
         RestT(deserialize-ls-type(i))
      PTRT-TAG :
         PtrT(deserialize-ls-type(i))
      REFT-TAG :
         RefT(deserialize-type(i))
      FNT-TAG :
         FnT(
            get-short-list(deserialize-ls-type, i)
            get-optional(deserialize-ls-type, i)
            deserialize-ls-type(i))
      STRUCTT-TAG :
         StructT(
            get-int!(i)
            deserialize-type(i))
      else : throw(InvalidTag(tag))

defn get-int! (i:FileInputStream) :
   match(get-int(i)) :
      (i:Int) : i
      (f:False) : throw(EOFException())

defn get-char! (i:FileInputStream) :
   match(get-char(i)) :
      (x:Char) : x
      (f:False) : throw(EOFException())

defn get-byte! (i:FileInputStream) :
   match(get-byte(i)) :
      (x:Byte) : x
      (f:False) : throw(EOFException())

defn get-tag! (purpose:String, i:FileInputStream) :
   get-byte!(i)

defn get-bool! (i:FileInputStream) :
   val b = get-byte!(i)
   b == 1Y

defn get-string! (i:FileInputStream) -> String :
   val n = get-int!(i)
   String(repeatedly(get-char!{i}, n))   

defn get-symbol! (i:FileInputStream) -> Symbol :
   to-symbol(get-string!(i))

defn get-short-list<?T> (f: FileInputStream -> ?T, i:FileInputStream) -> List<T> :
   val n = to-int(get-byte!(i))
   get-list(n, f, i)

defn get-list<?T> (n:Int, f: FileInputStream -> ?T, i:FileInputStream) -> List<T> :
   to-list(repeatedly(f{i}, n))

defn get-optional<?T> (f: (Byte, FileInputStream) -> ?T, i:FileInputStream) -> False|T :
   val tag = get-byte!(i)
   if tag != 0Y :
      f(tag, i)

defn InvalidTag (tag:Byte) :
   Exception("Invalid tag %_ during pkg deserialization." % [tag])
defn EOFException () :
   Exception("Reached end of file during pkg deserialiation.")
defn NotArrow () :
   Exception("Expected an arrow type during pkg deserialization.")
defn NotFn () :
   Exception("Expected a LoStanza function type during pkg deserialization.")


;============================================================
;=================== ID Renaming ============================
;============================================================

defn rename-pkg (pkg:Pkg) :
   ;Track renamed ids
   val id-table = HashTable<Int,Int>()
   defn rename-id (n:Int) :
      if stable-id?(n) :
         n
      else :
         if not key?(id-table, n) :
            id-table[n] = fresh-id()
         id-table[n]   

   defn rename-comm (c:PkgComm) :
      match(c) :
         (c:DefInfo) :
            DefInfo(
               rename-id(n(c))
               name(c)
               package(c)
               visibility(c)
               category(c)
               info(c))
         (c:DefVal) :
            DefVal(
               rename-id(n(c))
               rename-type(type(c))
               rename-type(ls-type(c)))
         (c:DefType) :
            DefType(
               rename-id(n(c))
               map(rename-id, args(c))
               rename-type(parent(c)))
         (c:DefLSType) :
            DefLSType(
               rename-id(n(c))
               map(rename-id, args(c))
               rename-type(parent(c))
               map(rename-field, fields(c)))
               
   defn rename-type (t:Type) :
      match(map(rename-type, t)) :
         (t:TPoly) : TPoly(map(rename-id, targs(t)), map(rename-id, cargs(t)), func(t))
         (t:TCap) : TCap(rename-id(n(t)))
         (t:TOf) : TOf(rename-id(n(t)), type(t))
         (t:TVar) : TVar(rename-id(n(t)))
         (t) : t

   defn rename-type (t:LSType) :
      val t* = map(rename-type{_:LSType}, map(rename-type{_:Type}, t))
      match(t*) :
         (t:PolyT) : PolyT(map(rename-id,targs(t)), map(rename-id,cargs(t)), func(t))
         (t:StructT): StructT(rename-id(n(t)), type(t))
         (t) : t

   defn rename-type (f:False) :
      false

   defn rename-field (f:Field) :
      Field(
         rename-id(n(f))
         name(f)
         rename-type(type(f)))

   val comms* = map(rename-comm, comms(pkg))
   Pkg(name(pkg), comms*)

;============================================================
;================ Name Mangling =============================
;============================================================

lostanza deftype BitMap :
   words: long
   length: long
   bits: long ...

lostanza defn CharMap () -> ref<BitMap> :
   val length = 256
   val words = length >>> 6
   val map = new BitMap{words, length}
   for (var i:long = 0, i < words, i = i + 1) :
      map.bits[i] = 0
   return map   

lostanza defn get (m:ref<BitMap>, i:ref<Int>) -> ref<True|False> :
   val bit = i.value
   val bit-div-64 = bit >>> 6
   val bit-mod-64 = bit & 63
   val word = m.bits[bit-div-64]
   val v = (word >> bit-mod-64) & 1
   if v : return true
   else : return false

lostanza defn set (m:ref<BitMap>, i:ref<Int>, v:ref<True|False>) -> ref<False> :
   val bit = i.value
   val bit-div-64 = bit >>> 6
   val bit-mod-64 = bit & 63   
   val word = m.bits[bit-div-64]
   if v == true :
      m.bits[bit-div-64] = word | (1L << (bit-mod-64 as long))
   else :
      m.bits[bit-div-64] = word & (~ 1L << (bit-mod-64 as long))
   return false   
   
val VALID-FILENAME-CHARS = let :
   val m = CharMap()
   defn add-range (a:Char, b:Char) :
      for i in to-int(a) through to-int(b) do :
         m[i] = true
   defn add-chars (str:String) :
      for c in str do :
         m[to-int(c)] = true
   add-range('0', '9')
   add-range('a', 'z')
   add-range('A', 'Z')
   add-chars("-.")
   m

defn package-filename (name:Symbol) :
   val buffer = StringBuffer()
   for c in to-string(name) do :
      if VALID-FILENAME-CHARS[to-int(c)] :
         add(buffer, c)
      else if c == '/' :
         add(buffer, '$')
      else :
         print(buffer, "_%_" % [to-int(c)])
   print(buffer, ".pkg")
   to-string(buffer)

defn package-filepath (name:Symbol) :
   to-string("%_/pkgs/%_" % [STANZA-INSTALL-DIR, package-filename(name)])

;============================================================
;=================== Drivers ================================
;============================================================

public defn save-pkg (pkg:Pkg) :
   serialize(package-filepath(name(pkg)), pkg)
   
public defn load-pkg (name:Symbol) :
   rename-pkg $
      deserialize-pkg(package-filepath(name))
