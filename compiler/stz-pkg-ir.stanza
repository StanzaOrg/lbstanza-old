;See License.txt for details about licensing.

;============================================================
;==================== Pkg Language ==========================
;============================================================

defpackage stz/pkg-ir :
   import core
   import collections
   import stz/namemap
   import stz/tl-ir with :
      prefix(Field, Child) => T
   import stz/params
   import stz/ids
   import stz/kl-ir with :
      prefix(Field, Child) => K
      prefix(name, comms) => kl-
   import stz/pkg-node with :
      prefix(map) => pkg-

#use-overlay(stz/ast-lang, stz/printer-lang)

public defast :
   deftype PkgComm
   defnodes PkgComm :
      DefInfo :
         n: Int
         name: Symbol
         package: Symbol
         visibility: Vis
         category: EType
         info: FileInfo
      DefVal :
         n: Int
         type: False|Type
         ls-type: False|LSType
      DefType :
         n: Int
         args: List<Int>
         parent: False|Type
         children: List<Child>
      DefLSType :
         n: Int
         args: List<Int>
         parent: False|Type
         fields: List<Field>

public defstruct Child :
   n: Int
   args: List<Int>
   parent: Type

public defstruct Field :
   n: Int
   name: Symbol
   type: LSType

public defstruct Import :
   name: Symbol
   timestamp: Long
   bindings: List<KeyValue<Int,Int>>

public defstruct Pkg :
   name: Symbol
   timestamp: Long
   imports: List<Import>
   comms: List<PkgComm>
   kcomms: List<KComm>

;============================================================
;==================== Printers ==============================
;============================================================

defprinter (c:PkgComm) :
   DefInfo :
      ($definfo n name package visibility category info)
   DefVal :
      ($defval n type ls-type)
   DefType :
      ($deftype n args parent)
   DefLSType :
      ($deflstype n args parent fields ...)

defprinter (f:Field) :
   Field :
      ($field n name type)

defprinter (c:Child) :
   Child :
      ($child n (args ...) parent)

defprinter (i:Import) :
   Import :
      ($import name bindings ...)

defprinter (p:Pkg) :
   Pkg :
      ($pkg name (imports ...) (comms ...) kcomms ...)



;============================================================
;=================== ID Renaming ============================
;============================================================

;val GLOBAL-IDS = HashTable<Int,[Symbol, Int]>()
;val ID-TABLES = HashTable<Symbol,IdTable>()
;
;deftype IdTable
;defmulti timestamp (t:IdTable) -> Long
;defmulti global-id (t:IdTable, internal-id:Int) -> Int
;defmulti set (t:IdTable, iid:Int, gid:Int) -> False
;defmulti make-global-id (t:IdTable, internal-id:Int) -> False
;
;defn IdTable (name:Symbol, timestamp:Long) :
;   val int-to-global = HashTable<Int,Int>()
;      
;   new IdTable :
;      defmethod timestamp (this) :
;         timestamp
;      defmethod global-id (this, internal-id:Int) :
;         int-to-global[internal-id]
;      defmethod set (this, internal-id:Int, global-id:Int) :
;         int-to-global[internal-id] = global-id
;      defmethod make-global-id (this, internal-id:Int) :
;         if key?(int-to-global, internal-id) :
;            fatal("Id %_ already exists." % [internal-id])         
;         val gid = internal-id when stable-id?(internal-id) else fresh-id()
;         GLOBAL-IDS[gid] = [name, internal-id]
;         this[internal-id] = gid
;
;defn defined-ids (pkg:Pkg) :
;   unique $ generate<Int> :
;      for node in cat(comms(pkg), kcomms(pkg)) do :
;         dor-defined(yield, node)
;
;defn used-ids (pkg:Pkg) :
;   unique $ generate<Int> :
;      for node in cat(comms(pkg), kcomms(pkg)) do :
;         dor-used(yield, node)
;
;defn rename-pkgs (pkgs:List<Pkg>) :
;   ;Define ids
;   for pkg in pkgs do :
;      ;Create id table
;      val table = IdTable(name(pkg), timestamp(pkg))
;      ID-TABLES[name(pkg)] = table
;      ;Define ids
;      for id in defined-ids(pkg) do :
;         make-global-id(table, id)      
;   ;Rename ids
;   for pkg in pkgs map :
;      ;Import definitions
;      val table = ID-TABLES[name(pkg)]
;      for i in imports(pkg) do :
;         val itable = ID-TABLES[name(i)]
;         for e in bindings(i) do :
;            val [pid, iid] = [key(e), value(e)]
;            table[iid] = global-id(itable, pid)
;      ;Rename commands
;      defn rename (node:PkgNode) :
;         mapr-id(global-id{table, _}, global-id{table, _}, node)
;      val comms* = map(rename, comms(pkg)) as List<PkgComm>
;      val kcomms* = map(rename, kcomms(pkg)) as List<KComm>
;      Pkg(name(pkg), timestamp(pkg), imports(pkg), comms*, kcomms*)
;
;defn import-ids (pkgs:List<Pkg>) :
;   ;Retrieve the imported timestamp
;   val current-timestamp = current-time-ms()
;   defn pkg-timestamp (pkg-name:Symbol) -> Long :
;      if key?(ID-TABLES, pkg-name) : timestamp(ID-TABLES[pkg-name])
;      else : current-timestamp
;         
;   ;Register all ids
;   for pkg in pkgs do :
;      for id in defined-ids(pkg) do :
;         GLOBAL-IDS[id] = [name(pkg), id]
;   ;Fill Imports
;   for pkg in pkgs map :
;      ;Accumulate all imported bindings
;      val import-table = HashTable<Symbol, List<KeyValue<Int,Int>>>(List())
;      for id in used-ids(pkg) do :
;         val [pkg-name, pkg-id] = GLOBAL-IDS[id]
;         if pkg-name != name(pkg) :
;            import-table[pkg-name] = cons(pkg-id => id, import-table[pkg-name])
;
;      ;Fill imports
;      val imports* = append(imports, remaining) where :
;         val imports = for i in imports(pkg) map :
;            Import(name(i), pkg-timestamp(name(i)), import-table[name(i)])
;         do(remove{import-table, name(_)}, imports)
;         val remaining = to-list $ for e in import-table seq :
;            Import(key(e), pkg-timestamp(key(e)), value(e))
;                  
;      ;Return filled package
;      Pkg(name(pkg), current-timestamp, imports*, comms(pkg), kcomms(pkg))

;;============================================================
;;================ Name Mangling =============================
;;============================================================
;
;lostanza deftype BitMap :
;   words: long
;   length: long
;   bits: long ...
;
;lostanza defn CharMap () -> ref<BitMap> :
;   val length = 256
;   val words = length >>> 6
;   val map = new BitMap{words, length}
;   for (var i:long = 0, i < words, i = i + 1) :
;      map.bits[i] = 0
;   return map
;
;lostanza defn get (m:ref<BitMap>, i:ref<Int>) -> ref<True|False> :
;   val bit = i.value
;   val bit-div-64 = bit >>> 6
;   val bit-mod-64 = bit & 63
;   val word = m.bits[bit-div-64]
;   val v = (word >> bit-mod-64) & 1
;   if v : return true
;   else : return false
;
;lostanza defn set (m:ref<BitMap>, i:ref<Int>, v:ref<True|False>) -> ref<False> :
;   val bit = i.value
;   val bit-div-64 = bit >>> 6
;   val bit-mod-64 = bit & 63
;   val word = m.bits[bit-div-64]
;   if v == true :
;      m.bits[bit-div-64] = word | (1L << (bit-mod-64 as long))
;   else :
;      m.bits[bit-div-64] = word & (~ 1L << (bit-mod-64 as long))
;   return false
;
;val VALID-FILENAME-CHARS = let :
;   val m = CharMap()
;   defn add-range (a:Char, b:Char) :
;      for i in to-int(a) through to-int(b) do :
;         m[i] = true
;   defn add-chars (str:String) :
;      for c in str do :
;         m[to-int(c)] = true
;   add-range('0', '9')
;   add-range('a', 'z')
;   add-range('A', 'Z')
;   add-chars("-.")
;   m
;
;defn package-filename (name:Symbol) :
;   val buffer = StringBuffer()
;   for c in to-string(name) do :
;      if VALID-FILENAME-CHARS[to-int(c)] :
;         add(buffer, c)
;      else if c == '/' :
;         add(buffer, '$')
;      else :
;         print(buffer, "_%_" % [to-int(c)])
;   print(buffer, ".pkg")
;   to-string(buffer)
;
;public defn package-filepaths (name:Symbol) -> Seq<String> :
;   val filename = package-filename(name)
;   if flag-defined?(`OPTIMIZE) :
;      val p1 = for dir in in-reverse(STANZA-FAST-PKG-DIRS) seq :
;         "%_/%_" % [dir, filename]
;      val p2 = "%_/fast-pkgs/%_" % [STANZA-INSTALL-DIR, filename]
;      val p3 = for dir in in-reverse(STANZA-PKG-DIRS) seq :
;         "%_/%_" % [dir, filename]
;      val p4 = "%_/pkgs/%_" % [STANZA-INSTALL-DIR, filename]
;      seq(to-string, cat-all([p1, [p2], p3, [p4]]))      
;   else :
;      val p1 = for dir in in-reverse(STANZA-PKG-DIRS) seq :
;         "%_/%_" % [dir, filename]
;      val p2 = "%_/pkgs/%_" % [STANZA-INSTALL-DIR, filename]
;      seq(to-string, cat(p1, [p2]))
;
;public defn package-output-path (name:Symbol) -> String :
;   to-string("%_/%_" % [PKG-OUTPUT-DIR, package-filename(name)])
;
;;============================================================
;;=================== Drivers ================================
;;============================================================
;
;public defn save-pkgs (pkgs:List<Pkg>) :
;   for pkg in import-ids(pkgs) do :
;      val path = package-output-path(name(pkg))
;      serialize(path, pkg)
;
;val LOADED-PACKAGES = HashTable<Symbol, Pkg>()
;
;public defn load-pkg (pkg-name:Symbol, new-packages:List<Symbol>) -> Pkg :
;   ;Debugging
;   defn print-pkg (phase:String, pkg:Pkg) :
;      if flag-defined?(`VERBOSE) :
;         println("[%_ %_]" % [phase, name(pkg)])
;         println(pkg)
;   ;Loading packages
;   defn load (pkg-name:Symbol, pkg-timestamp:False|Long) -> List<Pkg> :
;      ;Ensure timestamp
;      defn ensure-timestamp (pkg:Pkg) :
;         if pkg-timestamp is Long :
;            if timestamp(pkg) != pkg-timestamp :
;               throw(PackageTimestampException(name(pkg)))
;            
;      ;Ensure package is not new
;      if contains?(new-packages, pkg-name) :
;         throw(PackageTimestampException(pkg-name))
;      
;      ;Find package
;      val filepath = let :
;         val path = for path in package-filepaths(pkg-name) find :
;            file-exists?(path)
;         throw(NoPackageException(pkg-name)) when path is False   
;         path as String
;      
;      if key?(LOADED-PACKAGES, pkg-name) :
;         ensure-timestamp(LOADED-PACKAGES[pkg-name])
;         List()
;      else :
;         val pkg = deserialize-pkg(pkg-name, filepath)
;         print-pkg("Loaded", pkg)
;         ensure-timestamp(pkg)
;         LOADED-PACKAGES[pkg-name] = pkg
;         cons{pkg, _} $
;            for import in imports(pkg) seq-append :
;               load(name(import), timestamp(import))
;   ;Renaming packages
;   for pkg in rename-pkgs(load(pkg-name, false)) do :
;      print-pkg("Renamed", pkg)
;      LOADED-PACKAGES[name(pkg)] = pkg
;   ;Return loaded package
;   LOADED-PACKAGES[pkg-name]      
