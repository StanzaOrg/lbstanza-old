defpackage stz/kl-ir :
   import core
   import verse
   import stz/ids

;Use utilities for defining ASTs quickly.
#use-overlay(stz/ast-lang, stz/printer-lang)

;All expressions have a type field for internal use.
public defmulti type (e:KExp) -> False|KType

public defast :
   ;     KType Nodes
   ;     -----------
   deftype KType
   defnodes KType :
      KOf: (n:Int)
      KTVar: (n:Int)
      KAnd: (a:KType, b:KType)
      KOr: (a:KType, b:KType)
      KTop
      KBot

      ;     Working IR
      ;     ----------
      KTags: (tags:List<Int>)

   ;     KLevel Top Level Commands
   ;     -------------------------
   deftype KComm
   defnodes KComm :
      KDef :
         n: Int
         value: KExp
      KDefVar :
         n: Int
         value: False|KExp
      KDefn :
         n: Int
         value: Func
      KDefmulti :
         n: Int
         targs: List<Int>
         a1: List<KType>
         a2: KType
      KDefmethod :
         n: Int
         multi: Int
         targs: List<KType>
         thisn: False|Int
         func: KFn
      KDefType :
         n: Int
         parent: False|KType
      KInit :
         exp: KExp

      KLSDef :
         n: Int
         type: KLSType
         value: KLSExp
      KLSDefVar :
         n: Int
         type: KLSType
         value: False|KLSExp
      KLSDefn :
         tail?: True|False
         n: Int
         targs: List<Int>
         a1: List<KLSType>
         a2: KLSType
         args: List<Int>
         body: KLSComm
      KLSDefType :
         n: Int
         parent: False|KType
         fields: List<StructField>
         rfield: False|StructField
      KExtern :
         n: Int
         type: KLSType
         lbl: Symbol
      KLSInit :
         comm: KLSComm

      ;     Working IR
      ;     ----------
      KDefConst :
         n: Int
         value: ?
      KDefTypeObject :
         n: Int
         args: List<Int>
         type: KType
      KLSDefCode :
         n: Int
         arity: Int
         args: List<Int>
         types: List<KLSType>
         body: KLSComm
      

   ;     Kform Expressions
   ;     -----------------
   deftype KExp :
      type: False|KType with: (as-method => true)
   defnodes KExp :
      KSet :
         n: Int
         value: KExp
      KCast :
         exp: KExp
         targ: KType
      KCheckLength :
         exp: KExp
         length: Int
      KLet :
         def: KDef|KDefVar|KDefn
         body: KExp
      KLetRec :
         defs: List<KDefn|KDef>
         body: KExp
      KSeq :
         a: KExp
         b: KExp
      KDispatch :
         args: List<KExp>
         branches: List<KBranch>
      KMatch :
         args: List<KExp>
         branches: List<KBranch>
      KNew :
         class: KType
         methods: List<KDefmethod>
      KDo :
         func: KExp
         targs: List<KType>
         args: List<KExp>
         a1: List<KType>
         a2: KType
      KVar :
         n: Int
      KPrim :
         op: KOp
         args: List<KExp>
      KLiteral :
         value: ?
      KTuple :
         exps: List<KExp>
      KTupleGet :
         exp: KExp
         index: Int
      KMix :
         exps: List<KCurry>
      KCurry :
         n: Int
         targs: List<KType>

      ;     Working IR
      ;     ----------
      KCheckVoid :
         exp: KExp
      KObject :
         n: Int
         args: List<KExp>
      KObjectGet :
         object: KExp
         index: Int
      KTypeObject :
         n: Int
         args: List<KExp>
      KClosure :
         n: Int
         args: List<KExp>
      KClosureGet :
         exp: KExp
         index: Int
      KCall :
         tail?: True|False
         arity: Int
         func: Int|KExp
         args: List<KExp>
      KBox :
         value: False|KExp
      KBoxGet :
         box: KExp
      KBoxSet :
         box: KExp
         value: KExp
      KBranchError


   ;     KForm LoStanza Types
   ;     --------------------
   deftype KLSType
   defnodes KLSType :
      KByteT
      KIntT
      KLongT
      KFloatT
      KDoubleT
      KUnknownT
      KPtrT: (type:KLSType)
      KRefT: (type:KType)
      KFnT: (a:List<KLSType>, r:False|KLSType, b:KLSType)
      KStructT: (n:Int)


   ;     KForm Location
   ;     --------------
   deftype KLoc
   defnodes KLoc :
      Value: (exp:KLSExp)
      Deref: (exp:KLSExp, type:KLSType)
      Deptr: (exp:KLSExp, type:KLSType)
      Slot: (exp:KLSExp, type:KLSType, index:KLSExp)
      Field: (base:KLoc, n:Int)


   ;     KForm LoStanza Commands
   ;     -----------------------
   deftype KLSComm
   defnodes KLSComm :
      KLSCallComm :
         exp: KLSExp
      KLSSet :
         exp: KLoc
         value: KLSExp
      KLSLabel :
         n: Int
      KLSGoto :
         n: Int
      KLSReturn :
         exp: KLSExp
      KLSDefLocal :
         n: Int
         value: KLSExp
      KLSDefLocalVar :
         n: Int
         type: KLSType
         value: False|KLSExp
      KLSSeq :
         a: KLSComm
         b: KLSComm
      KLSIf :
         pred: KLSExp
         conseq: KLSComm
         alt: KLSComm
      KLSMatch :
         args: List<KLSExp>
         branches: List<KLSBranch>
      KLSDispatch :
         args: List<KLSExp>
         branches: List<KLSBranch>
      KLSSkip


   ;     KForm LoStanza Expressions
   ;     --------------------------
   deftype KLSExp
   defnodes KLSExp :
      KLSLet :
         comm: KLSComm
         exp: KLSExp
      KLSVar :
         n: Int
      KLSRef :
         n: Int
         args: List<KLSExp>
      KLSRefArray :
         n: Int
         length: KLSExp
         args: List<KLSExp>
      KLSStruct :
         n: Int
         args: List<KLSExp>
      KLSPtr :
         exp: KLoc
      KLSRead :
         exp: KLoc
      KLSPrim :
         op: KLSOp
         args: List<KLSExp>
         type: KLSType
      KLSCall :
         func: Int|KLSExp
         targs: List<KType>
         args: List<KLSExp>
         type: KLSType
      KLSCallC :
         func: Int|KLSExp
         args: List<KLSExp>
         type: KLSType
      KLSCallClosure :
         func: KLSExp
         targs: List<KType>
         args: List<KLSExp>
         type: KLSType
      KLSSizeof :
         type: KLSType
      KLSTagof :
         n: Int
      KLSConv :
         exp: KLSExp
         type: KLSType
      KLSLitByte :
         value: Int
      KLSLitInt :
         value: Int
      KLSLitLong :
         value: Int
      KLSLitFloat :
         value: Float
      KLSLitDouble :
         value: Float
      KLSLitString :
         value: String
      KLSMix :
         exps: List<KLSCurry>
      KLSCurry :
         n: Int
         targs: List<KType>

      ;     Working IR
      ;     ----------
      KLSCast :
         exp: KLSExp
         type: KType
      KLSTypeObject :
         n: Int
         args: List<KLSExp>
      FuncExp :
         func: Func
      KLSClosure :
         n: Int
         args: List<KLSExp>
      KLSWCall :
         tail?: True|False
         arity: Int
         func: Int|KLSExp
         args: List<KLSExp>
         type: KLSType
      KLSWCallClosure :
         tail?: True|False
         arity: Int
         func: KLSExp
         args: List<KLSExp>
         type: KLSType
      

   ;     KForm Mappers/Doers
   ;     -------------------
   make-mapper(f:KLSExp -> KLSExp, e:KLSExp)
   make-mapper(f:KLSComm -> KLSComm, e:KLSExp)
   make-mapper(f:KLoc -> KLoc, e:KLSExp)
   make-doer(f:KLSExp -> ?, e:KLSExp)
   make-doer(f:KLSComm -> ?, e:KLSExp)   

   make-mapper(f:KLSExp -> KLSExp, c:KLSComm)
   make-mapper(f:KLSComm -> KLSComm, c:KLSComm)
   make-mapper(f:KLoc -> KLoc, c:KLSComm)
   make-doer(f:KLSExp -> ?, c:KLSComm)
   make-doer(f:KLSComm -> ?, c:KLSComm)
   
   make-mapper(f:KLSExp -> KLSExp, l:KLoc)
   make-mapper(f:KLoc -> KLoc, l:KLoc)
   make-doer(f:KLSExp -> ?, l:KLoc)
   make-doer(f:KLoc -> ?, l:KLoc)

   make-mapper(f:KExp -> KExp, e:KExp)
   make-mapper(f:KComm -> KComm, e:KExp)
   make-mapper(f:KType -> KType, e:KExp)
   make-doer(f:KExp -> ?, e:KExp)
   make-doer(f:KComm -> ?, e:KExp)

   make-mapper(f:KExp -> KExp, c:KComm)
   make-mapper(f:KLSComm -> KLSComm, c:KComm)
   make-mapper(f:KLSExp -> KLSExp, c:KComm)
   make-mapper(f:KType -> KType, c:KComm)
   make-doer(f:KExp -> ?, c:KComm)
   make-doer(f:KLSComm -> ?, c:KComm)
   make-doer(f:KLSExp -> ?, c:KComm)

   make-mapper(f:KType -> KType, t:KType)
   make-doer(f:KType -> ?, t:KType)
   
   defmapper (f:KLSExp -> KLSExp) :
      (x:List<KLSExp>) : map(f, x)
      (x:KLSExp) : f(x)
      (x:False|KLSExp) : f(x as KLSExp) when x != false
      (x:KLoc) : mapr(f, x)
      (x:Int|KLSExp) : f(x as KLSExp) when x typeof KLSExp else x
      (x:List<KLSCurry>) : map({f(_) as KLSCurry}, x)
   defdoer (f:KLSExp -> ?) :
      (x:List<KLSExp>) : do(f, x)
      (x:KLSExp) : f(x)
      (x:False|KLSExp) : f(x as KLSExp) when x != false
      (x:KLoc) : dor(f, x)
      (x:Int|KLSExp) : f(x as KLSExp) when x typeof KLSExp
      (x:List<KLSCurry>) : do(f, x)
      
   defmapper (f:KLSComm -> KLSComm) :
      (x:List<KLSBranch>) : for b in x map : map(f, b)
      (x:KLSComm) : f(x)      
   defdoer (f:KLSComm -> ?) :
      (x:List<KLSBranch>) : for b in x do : do(f, b)
      (x:KLSComm) : f(x)
      
   defmapper (f:KLoc -> KLoc) :
      (x:KLoc) : f(x)
   defdoer (f:KLoc -> ?) :
      (x:KLoc) : f(x)
      
   defmapper (f:KExp -> KExp) :
      (x:KExp) : f(x)
      (x:False|KExp) : f(x as KExp) when x typeof KExp
      (x:Func) : map(f, x)
      (x:KFn) : map(f, x) as KFn
      (x:List<KExp>) : map(f, x)
      (x:List<KBranch>) : for b in x map : map(f, b)
      (x:Int|KExp) : f(x as KExp) when x typeof KExp else x
      (x:List<KCurry>) : map({f(_) as KCurry}, x)
   defdoer (f:KExp -> ?) :
      (x:KExp) : f(x)
      (x:False|KExp) : f(x as KExp) when x typeof KExp
      (x:Func) : do(f, x)
      (x:KFn) : do(f, x)
      (x:List<KExp>) : do(f, x)
      (x:List<KBranch>) : for b in x do : do(f, b)
      (x:Int|KExp) : f(x as KExp) when x typeof KExp
      (x:List<KCurry>) : do(f, x)     

   defmapper (f:KComm -> KComm) :
      (x:KDef|KDefVar|KDefn) : f(x) as KDef|KDefVar|KDefn
      (x:List<KDefn|KDef>) : map({f(_) as KDefn|KDef}, x)
      (x:List<KDefmethod>) : map({f(_) as KDefmethod}, x)            
   defdoer (f:KComm -> ?) :
      (x:KDef|KDefVar|KDefn) : f(x)
      (x:List<KDefn|KDef>) : do(f, x)
      (x:List<KDefmethod>) : do(f, x)
      
   defmapper (f:KType -> KType) :
      (x:Func) : map(f, x)
      (x:KFn) : map(f, x) as KFn
      (x:KType) : f(x)
      (xs:List<KType>): map(f, xs)
      (x:False|KType) : f(x as KType) when x != false
      (xs:List<KBranch>) : for b in xs map : map(f, b)
   defdoer (f:KType -> ?) :
      (x:Func) : do(f, x)
      (x:KFn) : do(f, x)
      (x:KType) : f(x)
      (xs:List<KType>): do(f, xs)
      (x:False|KType) : f(x as KType) when x != false
      (xs:List<KBranch>) : for b in xs do : do(f, b)

   defmapper (f:KLSType -> KLSType) :
      (x:KLSType) : f(x)
      (x:List<KLSType>) : map(f, x)
      (x:StructField) : StructField(n(x), f(type(x)))
      (xs:List<StructField>) : for x in xs map : map(f, x)
      (x:False|StructField) : map(f, x as StructField) when x != false
   defdoer (f:KLSType -> ?) :
      (x:KLSType) : f(x)
      (x:List<KLSType>) : do(f, x)
      (x:StructField) : f(type(x))
      (xs:List<StructField>) : for x in xs do : f(type(x))
      (x:False|StructField) : f(type(x as StructField)) when x != false

   ignore :
      Int
      Float
      String
      Symbol
      True|False
      ?
      List<Int>
      False|Int
      KOp
      KLSOp



;                      AST Values
;                      ==========

public defstruct KProg :
   comms: List<KComm>

public definterface Func
public defmulti n (f:Func) -> Int

public defstruct KFn <: Func :
   n: Int with: (as-method => true)
   tail?: True|False
   targs: List<Int>
   a1: List<KType>
   a2: KType
   closure: False|Int
   args: List<Int>
   body: KExp

public defstruct KMultifn <: Func :
   n: Int with: (as-method => true)
   funcs: List<KFn|KCode>

public defstruct StructField :
   n: Int
   type: KLSType

public defstruct KBranch :
   args: List<Int>
   types: List<KType>
   body: KExp

public defstruct KLSBranch :
   args: List<Int>
   types: List<KType>
   body: KLSComm

public defstruct KOp :
   name: Symbol
   id: Int

public val INT-ADD-OP = KOp(`int-add, fresh-id())
public val INT-SUB-OP = KOp(`int-sub, fresh-id())
public val INT-MUL-OP = KOp(`int-mul, fresh-id())
public val INT-DIV-OP = KOp(`int-div, fresh-id())
public val INT-MOD-OP = KOp(`int-mod, fresh-id())
public val INT-AND-OP = KOp(`int-and, fresh-id())
public val INT-OR-OP = KOp(`int-or, fresh-id())
public val INT-XOR-OP = KOp(`int-xor, fresh-id())
public val INT-SHL-OP = KOp(`int-shl, fresh-id())
public val INT-SHR-OP = KOp(`int-shr, fresh-id())
public val INT-ASHR-OP = KOp(`int-ashr, fresh-id())
public val INT-EQ-OP = KOp(`int-eq, fresh-id())
public val INT-NE-OP = KOp(`int-ne, fresh-id())
public val INT-LE-OP = KOp(`int-le, fresh-id())
public val INT-LT-OP = KOp(`int-lt, fresh-id())
public val INT-GT-OP = KOp(`int-gt, fresh-id())
public val INT-GE-OP = KOp(`int-ge, fresh-id())


public defstruct KLSOp :
   name: Symbol
   id: Int

public val ADD-OP = KLSOp(`add, fresh-id())
public val SUB-OP = KLSOp(`sub, fresh-id())
public val MUL-OP = KLSOp(`mul, fresh-id())
public val DIV-OP = KLSOp(`div, fresh-id())
public val MOD-OP = KLSOp(`mod, fresh-id())
public val AND-OP = KLSOp(`and, fresh-id())
public val OR-OP = KLSOp(`or, fresh-id())
public val XOR-OP = KLSOp(`xor, fresh-id())
public val SHL-OP = KLSOp(`shl, fresh-id())
public val SHR-OP = KLSOp(`shr, fresh-id())
public val ASHR-OP = KLSOp(`ashr, fresh-id())
public val EQ-OP = KLSOp(`eq, fresh-id())
public val NE-OP = KLSOp(`ne, fresh-id())
public val LT-OP = KLSOp(`lt, fresh-id())
public val GT-OP = KLSOp(`gt, fresh-id())
public val LE-OP = KLSOp(`le, fresh-id())
public val GE-OP = KLSOp(`ge, fresh-id())
public val ULT-OP = KLSOp(`ult, fresh-id())
public val UGT-OP = KLSOp(`ugt, fresh-id())
public val ULE-OP = KLSOp(`ule, fresh-id())
public val UGE-OP = KLSOp(`uge, fresh-id())

public val SET-HEAP-LIM = KLSOp(`set-heap-lim, fresh-id())
public val SET-HEAP-PTR = KLSOp(`set-heap-ptr, fresh-id())
public val GET-HEAP-LIM = KLSOp(`get-heap-lim, fresh-id())
public val GET-HEAP-PTR = KLSOp(`get-heap-ptr, fresh-id())

;                     Constructors
;                     ============

public defn KVar (x:Int) : KVar(x, false)

public defn KLSSeq (xs:Streamable<KLSComm>) :
   val str = to-stream(xs)
   defn loop (x:KLSComm) :
      if more?(str) : KLSSeq(x, loop(next(str)))
      else : x
   loop(next(str))

;                   Working IR Values
;                   =================

public defstruct KCode <: Func :
   n: Int with: (as-method => true)
   arity: Int
   args: List<Int>
   body: KExp


;                       Equality
;                       ========

defmethod equal? (a:KLSOp, b:KLSOp) :
   id(a) == id(b)
   
defmethod equal? (a:KOp, b:KOp) :
   id(a) == id(b)

defmethod equal? (x:KType, y:KType) :
   match(x, y) :
      (x:KOf, y:KOf) : n(x) == n(y)
      (x:KTVar, y:KTVar) : n(x) == n(y)
      (x:KAnd, y:KAnd) : (a(x) == a(y)) and (b(x) == b(y))
      (x:KOr, y:KOr) : (a(x) == a(y)) and (b(x) == b(y))
      (x:KTop, y:KTop) : true
      (x:KBot, y:KBot) : true
      (x, y) : false

;                       Mappers
;                       =======

public defn map (f:KLSComm -> KLSComm, b:KLSBranch) :
   KLSBranch(args(b), types(b), f(body(b)))
public defn do (f:KLSComm -> ?, b:KLSBranch) :
   f(body(b))

public defn map (f:KExp -> KExp, b:KBranch) :
   KBranch(args(b), types(b), f(body(b)))
public defn do (f:KExp -> ?, b:KBranch) :
   f(body(b))

public defn map<?T> (f:KExp -> KExp, x:?T&Func) -> T :
   {_ as T&Func} $ match(x) :
      (x:KFn) :
         KFn(n(x), tail?(x), targs(x), a1(x), a2(x), closure(x), args(x), f(body(x)))
      (x:KMultifn) :
         KMultifn{n(x), _} $
         for func in funcs(x) map :
            map(f, func) as KFn|KCode
      (x:KCode) :
         KCode(n(x), arity(x), args(x), f(body(x)))
public defn do (f:KExp -> ?, x:Func) :
   match(x) :
      (x:KFn) : f(body(x))
      (x:KMultifn) : for func in funcs(x) do : do(f, func)
      (x:KCode) : f(body(x))

public defn map (f:KType -> KType, b:KBranch) :
   KBranch(args(b), map(f, types(b)), body(b))

public defn do (f:KType -> KType, b:KBranch) :
   do(f, types(b))

public defn map (f:KType -> KType, x:Func) :
   match(x) :
      (x:KFn) :
         val a1* = map(f, a1(x))
         val a2* = f(a2(x))
         KFn(n(x), tail?(x), targs(x), a1*, a2*, closure(x), args(x), body(x))
      (x:KMultifn) :
         KMultifn{n(x), _} $
         for func in funcs(x) map :
            map(f, func) as KFn|KCode
      (x:KCode) : x

public defn do (f:KType -> KType, x:Func) :
   match(x) :
      (x:KFn) :
         do(f, a1(x))
         f(a2(x))
      (x:KMultifn) :
         for func in funcs(x) do :
            do(f, func)
      (x:KCode) :
         false

public defn map (f:KLSType -> KLSType, s:StructField) :
   StructField(n(s), f(type(s)))


;                   Recursive Mappers
;                   =================

public defn mapr (f:KLSExp -> KLSExp, l:KLoc) :
   defn fl (l:KLoc) : mapr(f, l)
   map(fl, map(f, l))

public defn dor (f:KLSExp -> ?, l:KLoc) :
   defn fl (l:KLoc) : dor(f, l)
   do(f, l)
   do(fl, l)

public defn mapr (f:KExp -> KExp, e:KExp) :
   defn fc (c:KComm) : map(f, c)
   map(fc, map(f, e))

public defn mapr (f:KType -> KType, e:KExp) :
   defn fc (c:KComm) : mapr(f, c)
   defn fe (e:KExp) : mapr(f, e)
   map(fc, map(fe, map(f, e)))

public defn mapr (f:KType -> KType, c:KComm) :
   defn fe (e:KExp) : mapr(f, e)
   map(fe, map(f, c))

public defn mapr (f:KLSExp -> KLSExp, c:KLSComm) :
   defn fc (c:KLSComm) : mapr(f, c)
   map(fc, map(f, c))

public defn mapr (f:KLSExp -> KLSExp, e:KLSExp) :
   defn fc (c:KLSComm) : mapr(f, c)
   map(fc, map(f, e))

public defn mapr (f:KLSComm -> KLSComm, c:KLSComm) :
   defn fe (e:KLSExp) : mapr(f, e)
   map(fe, map(f, c))

public defn mapr (f:KLSComm -> KLSComm, e:KLSExp) :
   defn fe (e:KLSExp) : mapr(f, e)
   map(fe, map(f, e))

public defn dor (f:KLSExp -> ?, c:KLSComm) -> False :
   defn fc (c:KLSComm) : dor(f, c)
   do(f, c)
   do(fc, c)

public defn dor (f:KLSExp -> ?, e:KLSExp) -> False :
   defn fc (c:KLSComm) : dor(f, c)
   do(f, e)
   do(fc, e)

;                       Printers
;                       ========

defprinter (p:KProg) :
   KProg :
      ($prog comms ...)

defprinter (f:Func) :
   KFn :
      if tail?(f) : ($fn* (targs ...) (a1 ...) a2 closure (args ...) body)
      else : ($fn (targs ...) (a1 ...) a2 closure (args ...) body)
   KMultifn :
      ($multi funcs ...)

   ;Working IR
   ;----------
   KCode :
      ($code arity (args ...) body)


defprinter (b:KBranch) :
   KBranch :
      ($branch (args ...) (types ...) body)


defprinter (b:KLSBranch) :
   KLSBranch :
      ($branch (args ...) (types ...) body)


defprinter (t:KType) :
   KOf :
      custom{"$T~" << [n(t)]}
   KTVar :
      custom{"$V~" << [n(t)]}
   KAnd :
      ($and a b)
   KOr :
      ($or a b)
   KTop :
      custom{"$top"}
   KBot :
      custom{"$bot"}

   ;     Working IR
   ;     ----------
   KTags :
      ($tags tags ...)


defprinter (c:KComm) :
   KDef :
      ($def n value)
   KDefVar :
      if value(c) == false : ($defvar n)
      else : ($defvar n value)
   KDefn :
      ($def n value)
   KDefmulti :
      ($defmulti n (targs ...) (a1 ...) a2)
   KDefmethod :
      ($defmethod n multi thisn func)
   KDefType :
      ($deftype n parent)
   KInit :
      custom{exp(c)}

   KLSDef :
      ($lsdef n type value)
   KLSDefVar :
      ($lsdefvar n type value)
   KLSDefn :
      ($lsdefn n (targs ...) (a1 ...) a2 (args ...) body)
   KLSDefType :
      ($lsdeftype n parent (fields ...) rfield)
   KExtern :
      ($extern n type lbl)
   KLSInit :
      ($lsinit comm)

   ;     Working IR
   ;     ----------
   KDefConst :
      ($defconst n value)
   KDefTypeObject :
      ($deftypeobject n (args ...) type)
   KLSDefCode :
      ($lsdefcode n arity (args ...) (types ...) body)


defprinter (e:KExp) :
   KSet :
      ($set n value)
   KCast :
      ($cast exp targ)
   KCheckVoid :
      ($check-void exp)
   KCheckLength :
      ($check-length exp length)      
   KLet :
      ($let def body)
   KLetRec :
      ($letrec (defs ...) body)
   KSeq :
      ($seq a b)
   KDispatch :
      ($dispatch (args ...) branches ...)
   KMatch :
      ($match (args ...) branches ...)
   KNew :
      ($new class methods ...)
   KDo :
      ($do (a1 ...) a2 func (targs ...) args ...)
   KVar :
      custom{"$v~" << [n(e)]}
   KPrim :
      ($prim op args ...)
   KLiteral :
      ($value value)
   KTuple :
      ($tuple exps ...)
   KTupleGet :
      ($tuple-get exp index)
   KMix :
      ($mix exps ...)
   KCurry :
      ($curry n targs ...)

   ;Working IR
   ;----------
   KObject :
      ($object n args ...)
   KObjectGet :
      ($object-get object index)
   KTypeObject :
      ($type-object n args ...)
   KClosure :
      ($closure n args ...)
   KClosureGet :
      ($closure-get exp index)
   KCall :
      ($call tail? arity func args ...)
   KBox :
      ($box value)
   KBoxGet :
      ($box-get box)
   KBoxSet :
      ($box-set box value)
   KBranchError :
      ($branch-error)


defprinter (t:KLSType) :
   KByteT :
      custom{"$byte"}
   KIntT :
      custom{"$int"}
   KLongT :
      custom{"$long"}
   KFloatT :
      custom{"$float"}
   KDoubleT :
      custom{"$double"}
   KUnknownT :
      custom{"$?"}
   KPtrT :
      ($ptr type)
   KRefT :
      ($ref type)
   KFnT :
      ($fn a r b)
   KStructT :
      custom{"$T~" << [n(t)]}


defprinter (l:KLoc) :
   Value :
      custom{exp(l)}
   Deref :
      ($deref exp)
   Deptr :
      ($deptr exp)
   Slot :
      ($slot exp type index)
   Field :
      ($field base n)
      

defprinter (c:KLSComm) :
   KLSCallComm :
      custom{exp(c)}
   KLSSet :
      ($set exp value)
   KLSLabel :
      ($label n)
   KLSGoto :
      ($goto n)
   KLSReturn :
      ($return exp)
   KLSDefLocal :
      ($deflocal n value)
   KLSDefLocalVar :
      ($deflocalvar n type value)
   KLSSeq :
      ($seq a b)
   KLSIf :
      ($if pred conseq alt)
   KLSMatch :
      ($match (args ...) branches ...)
   KLSSkip :
      custom{"$skip"}


defprinter (e:KLSExp) :
   KLSLet :
      ($let comm exp)
   KLSVar :
      custom{"$v~" << [n(e)]}
   KLSRef :
      ($ref n args ...)
   KLSRefArray :
      ($refarray n length args ...)
   KLSStruct :
      ($struct n args ...)
   KLSPtr :
      ($ptr exp)
   KLSRead :
      ($read exp)
   KLSCall :
      ($call type func (targs ...) args ...)
   KLSCallC :
      ($call-c type func args ...)
   KLSCallClosure :
      ($call-closure type func (targs ...) args ...)
   KLSSizeof :
      ($sizeof type)
   KLSTagof :
      ($tagof n)
   KLSConv :
      ($conv exp type)
   KLSCast :
      ($cast exp type)
   KLSTypeObject :
      ($typeobj n args ...)
   KLSPrim :
      ($prim type op args ...)
   KLSLitByte :
      ($lit-byte value)
   KLSLitInt :
      ($lit-int value)
   KLSLitLong :
      ($lit-long value)
   KLSLitFloat :
      ($lit-float value)
   KLSLitDouble :
      ($lit-double value)
   KLSLitString :
      ($lit-string value)
   KLSMix :
      ($mix exps ...)
   KLSCurry :
      ($curry n targs ...)

   ;     Working IR
   ;     ----------
   FuncExp :
      ($func func)
   KLSClosure :
      ($closure n args ...)
   KLSWCall :
      ($wcall arity func (args ...) type)
   KLSWCallClosure :
      ($wcall-closure arity func (args ...) type)


defmethod print (o:OutputStream, op:KLSOp) :
   print(o, name(op))

defmethod print (o:OutputStream, f:StructField) :
   print(o, "(~, ~)" << [n(f), type(f)])