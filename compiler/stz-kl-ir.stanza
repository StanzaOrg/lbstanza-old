defpackage stz/kl-ir :
   import core
   import verse
   import stz/tl-ir

#use-overlay(stz/ast-lang, stz/printer-lang)

public defmulti type (e:KExp) -> False|KType

public defstruct KProg :
   hier: THierarchy
   consts: Vector<?>
   classes: Vector<KClass>
   codes: Vector<KCode>
   comms: List<KComm>

public defstruct KClass :
   class: Int
   parent: KType
   num-targs: Int
   num-args: Int

public defstruct KCode :
   n: Int
   free-targs: List<Int>
   free-args: List<Int>
   func: Func

public defast :
   defmap (f:KType -> KType, t:KType) -> KType :
      (x:KType) : f(x)
      ignore(Int)

   defdo (f:KType -> ?, t:KType) -> False :
      (x:KType) : f(x)
      ignore(Int)

   deftype KType
   defnodes KType :
      KOf: (n:Int)
      KTVar: (n:Int)
      KAnd: (a:KType, b:KType)
      KOr: (a:KType, b:KType)
      KFnT
      KTop
      KBot

   defmap (f:KType -> KType, c:KComm) -> KComm :
      (x:Func) : map(f, x)
      (x:KFn) : map(f, x)
      (x:List<KType>) : map(f, x)
      (x:False|KType) : do?(f, x)
      ignore(Int)
      ignore(KExp)
      ignore(False|KExp)
      ignore(False|Int)
      ignore(KVar)
      ignore(List<KVar>)
      ignore(List<Int>)

   defmap (f:KExp -> KExp, c:KComm) -> KComm :
      (x:KVar) : f(x) as KVar
      (x:List<KVar>) : map(f,x) as List<KVar>
      (x:KExp) : f(x)
      (x:False|KExp) : do?(f, x)
      ignore(Int)
      ignore(False|Int)
      ignore(Func)
      ignore(KFn)
      ignore(List<KType>)
      ignore(False|KType)
      ignore(List<Int>)

   defdo (f:KExp -> ?, c:KComm) -> False :
      (x:KVar) : f(x)
      (x:List<KVar>) : do(f, x)
      (x:KExp) : f(x)
      (x:False|KExp) : (do?(f, x), false)
      ignore(Int)
      ignore(False|Int)
      ignore(Func)
      ignore(KFn)
      ignore(List<KType>)
      ignore(False|KType)
      ignore(List<Int>)

   defmap (f:KType -> KType, c:KExp) -> KExp :      
      (x:List<KBranch>) : map(map{f, _}, x)
      (x:KType) : f(x)
      (x:List<KType>) : map(f, x)
      (x:False|KType) : do?(f, x)
      ignore(Int)
      ignore(True|False)
      ignore(KVar)
      ignore(KDef|KDefVar|KDefn|KGetObjectType)
      ignore(KExp)
      ignore(List<KDefn>)
      ignore(List<KDefmethod>)
      ignore(List<KVar>)
      ignore(False|KVar)
      ignore(?)

   defmap (f:KExp -> KExp, c:KExp) -> KExp :      
      (x:KVar) : f(x) as KVar
      (x:KExp) : f(x)
      (x:List<KBranch>) : map(map{f, _}, x)
      (x:List<KVar>) : map(f, x) as List<KVar>
      (x:False|KVar) : do?(f, x) as False|KVar
      ignore(Int)
      ignore(True|False)
      ignore(KDef|KDefVar|KDefn|KGetObjectType)
      ignore(List<KDefn>)
      ignore(List<KDefmethod>)
      ignore(KType)
      ignore(List<KType>)
      ignore(?)
      ignore(False|KType)

   defmap (f:KComm -> KComm, c:KExp) -> KExp :      
      (x:List<KDefmethod>) : map(f, x) as List<KDefmethod>
      (x:List<KDefn>) : map(f, x) as List<KDefn>
      (x:KDef|KDefVar|KDefn|KGetObjectType) : f(x) as KDef|KDefVar|KDefn|KGetObjectType
      ignore(Int)
      ignore(True|False)
      ignore(KVar)
      ignore(KExp)
      ignore(List<KBranch>)
      ignore(KType)
      ignore(List<KType>)
      ignore(List<KVar>)
      ignore(False|KVar)
      ignore(?)
      ignore(False|KType)

   defdo (f:KExp -> ?, c:KExp) -> False :      
      (x:KVar) : f(x)
      (x:KExp) : f(x)
      (x:List<KBranch>) : do(do{f, _}, x)
      (x:List<KVar>) : do(f, x)
      (x:False|KVar) : (do?(f, x), false)
      ignore(Int)
      ignore(True|False)
      ignore(KDef|KDefVar|KDefn|KGetObjectType)
      ignore(List<KDefn>)
      ignore(List<KDefmethod>)
      ignore(KType)
      ignore(List<KType>)
      ignore(?)
      ignore(False|KType)

   defdo (f:KComm -> ?, c:KExp) -> False :      
      (x:List<KDefmethod>) : do(f, x)
      (x:List<KDefn>) : do(f, x)
      (x:KDef|KDefVar|KDefn|KGetObjectType) : f(x)
      ignore(Int)
      ignore(True|False)
      ignore(KVar)
      ignore(KExp)
      ignore(List<KBranch>)
      ignore(KType)
      ignore(List<KType>)
      ignore(List<KVar>)
      ignore(False|KVar)
      ignore(?)
      ignore(False|KType)

   deftype KComm
   defnodes KComm :
      KDef :
         n: Int
         value: KExp
      KDefVar :
         n: Int
         value: False|KExp
      KDefn :
         n: Int
         value: Func
      KDefmulti :
         n: Int
         targs: List<Int>
         a1: List<KType>
         a2: False|KType
      KDefmethod :
         n: Int
         multi: Int
         thisn: False|Int
         func: KFn
      KExpComm :
         exp: KExp

      ;Object Lifting
      KGetObjectType :
         n: Int
         object: KVar
         class: Int
         index: Int

      ;Closure Lifting
      KDefClosure :
         n: Int
         code: Int
         targs: List<KType>
         args: List<KVar>         
         
   deftype KExp :
      type: False|KType with: (as-method => true)
   defnodes KExp :
      KRead :
         n: Int
      KCast :
         exp: KVar
         targ: KType
      KCheckLength :
         exp: KVar
         length: Int
      KCheckVoid :
         exp: KVar
      KLet :
         def: KDef|KDefVar|KDefn|KGetObjectType
         body: KExp
      KLetRec :
         defns: List<KDefn>
         body: KExp
      KSet :
         n: Int
         value: KVar
      KSeq :
         a: KExp
         b: KExp
      KDispatch :
         args: List<KVar>
         branches: List<KBranch>
      KMatch :
         args: List<KVar>
         branches: List<KBranch>
      KNew :
         class: KType
         methods: List<KDefmethod>
      KDo :
         func: KVar
         targs: List<KType>
         args: List<KVar>
      KDoLS :
         func: Int
         targs: List<KType>
         args: List<KVar>
      KVar :
         n: Int
      ;KBinop :
      ;   op: Op
      ;   a: KVar
      ;   b: KVar
      KLiteral :
         value:?
      KTuple :
         exps: List<KVar>
      KTupleGet :
         exp: KVar
         index: Int

      ;Constant Lifting
      KConst :
         n: Int

      ;Mutable Boxing
      KBox :
         value: False|KVar
      KBoxGet :
         box: KVar         
      KBoxSet :
         box: KVar
         value: KVar

      ;Object Lifting
      KObject :
         n: Int
         targs: List<KType>
         args: List<KVar>
      KObjectGet :
         object: KVar
         class: Int
         index: Int

      ;Multi Conversion
      KNoMethodError
         
      
public definterface Func
public defstruct KFn <: Func :
   tail?: True|False
   targs: List<Int>
   a1: List<KType>
   a2: False|KType
   args: List<Int>
   body: KExp

public defstruct KMultifn <: Func :
   funcs: List<KFn>

defn do?<?T> (f:T -> ?T, x:T|False) :
   match(x) :
      (x:False) : false
      (x:T) : f(x)

public defn map<?T> (f:KType -> KType, func:?T&Func) -> T :
   {_ as T&Func} $ match(func) :
      (func:KFn) :
         KFn(tail?(func), targs(func), a1*, a2*, args(func), body(func)) where :
            val a1* = map(f, a1(func))
            val a2* = f(a2(func) as KType) when a2(func) != false         
      (func:KMultifn) :
         KMultifn $ for func in funcs(func) map :
            map(f, func)

public defn map<?T> (f:KExp -> KExp, func:?T&Func) -> T :
   {_ as T&Func} $ match(func) :
      (func:KFn) :
         KFn(tail?(func), targs(func), a1(func), a2(func), args(func), body*) where :
            val body* = f(body(func))
      (func:KMultifn) :
         KMultifn $ for func in funcs(func) map :
            map(f, func)

public defn do<?T> (f:KExp -> ?, func:?T&Func) -> False :
   match(func) :
      (func:KFn) : f(body(func))
      (func:KMultifn) : do(do{f, _}, funcs(func))

public defn mapr (f:KType -> KType, c:KComm) :
   defn fe (e:KExp) : mapr(f, e)
   map{fe, _} $
   map{f, _} $
   c

public defn mapr (f:KComm -> KComm, c:KComm) :
   defn fe (e:KExp) : map(f, e)
   map(fe, c)
    
public defn mapr (f:KType -> KType, e:KExp) :
   defn fe (e:KExp) : mapr(f, e)
   defn fc (c:KComm) : mapr(f, c)
   map{fe, _} $
   map{fc, _} $
   map{f, _} $
   e

public defn mapr (f:KExp -> KExp, e:KExp) :
   defn fc (c:KComm) : map(f, c)
   map{fc, _} $
   map{f, _} $
   e

public defn dor (f:KExp -> ?, e:KExp) :
   defn fc (c:KComm) : do(f, c)
   do(fc, e)
   do(f, e)

public defstruct KBranch :
   args: List<Int>
   types: List<KType>
   body: KExp

public defn map (f:KExp -> KExp, b:KBranch) :
   KBranch(args(b), types(b), f(body(b)))

public defn do (f:KExp -> ?, b:KBranch) :
   f(body(b))

public defn map (f:KType -> KType, b:KBranch) :
   KBranch(args(b), map(f, types(b)), body(b))

defprinter (f:Func) :
   KFn :
      if tail?(f) : ($fn* (targs ...) (a1 ...) a2 (args ...) body)
      else : ($fn (targs ...) (a1 ...) a2 (args ...) body)
   KMultifn :
      ($multi funcs ...)

defprinter (b:KBranch) :
   KBranch :
      ($branch (args ...) (types ...) body)

defprinter (e:KExp) :
   KRead :
      ($read n)
   KCast :
      ($cast exp targ)
   KCheckLength :
      ($checklength exp length)
   KCheckVoid :
      ($checkvoid exp)
   KLet :
      ($let def body)
   KLetRec :
      ($letrec (defns ...) body)
   KSet :
      ($set n value)
   KSeq :
      ($seq a b)
   KDispatch :
      ($dispatch (args ...) branches ...)
   KMatch :
      ($match (args ...) branches ...)
   KNew :
      ($new class methods ...)
   KDo :
      ($do func (targs ...) args ...)
   KDoLS :
      ($dols func (targs ...) args ...)
   KVar :
      custom{"$v~" << [n(e)]}
   ;KBinop :
   ;   op: Op
   ;   a: KVar
   ;   b: KVar
   KLiteral :
      custom{value(e)}
   KTuple :
      ($tuple exps ...)
   KTupleGet :
      ($tuple-get exp index)
   KConst :
      ($const n)
   KBox :
      ($box value)
   KBoxGet :
      ($boxget box)
   KBoxSet :
      ($boxset box value)
   KObject :
      ($object n (targs ...) args ...)
   KObjectGet :
      ($object-get object class index)