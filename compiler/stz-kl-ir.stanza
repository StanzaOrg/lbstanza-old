defpackage stz/kl-ir :
   import core
   import verse
   import stz/utils

;Use utilities for defining ASTs quickly.
#use-overlay(stz/ast-lang, stz/printer-lang)

;All expressions have a type field for internal use.
public defmulti type (e:KExp) -> False|KType

;public defstruct KClass :
;   class: Int
;   parent: KType
;   num-targs: Int
;   num-args: Int

;public defstruct KCode :
;   n: Int
;   free-targs: List<Int>
;   free-args: List<Int>
;   func: Func

public defast :
   ;     KType Nodes
   ;     -----------
   deftype KType
   defnodes KType :
      KOf: (n:Int)
      KTVar: (n:Int)
      KAnd: (a:KType, b:KType)
      KOr: (a:KType, b:KType)
      KTop
      KBot

   ;     KLevel Top Level Commands
   ;     -------------------------
   deftype KComm
   defnodes KComm :
      KDef :
         n: Int
         value: KExp
      KDefVar :
         n: Int
         value: False|KExp
      KDefn :
         n: Int
         value: Func
      KDefmulti :
         n: Int
         targs: List<Int>
         a1: List<KType>
         a2: False|KType
      KDefmethod :
         n: Int
         multi: Int
         thisn: False|Int
         func: KFn
      KDefType :
         n: Int
         parent: False|KType
      KExpComm :
         exp: KExp

      KLSDef :
         n: Int
         type: KLSType
      KLSDefn :
         n: Int
         targs: List<Int>
         a1: List<KLSType>
         a2: KLSType
         args: List<Int>
         body: KLSComm
      KLSDefType :
         n: Int
         parent: False|KType
         fields: List<StructField>
         rfield: False|StructField
      KExtern :
         n: Int
         type: KLSType
         name: Symbol
      KExternFn :
         n: Int
         type: KLSType
         name: Symbol
      KLSInit :
         comm: KLSComm

      ;Object Lifting
      ;KGetObjectType :
      ;   n: Int
      ;   object: KVar
      ;   class: Int
      ;   index: Int

      ;Closure Lifting
      ;KDefClosure :
      ;   n: Int
      ;   code: Int
      ;   targs: List<KType>
      ;   args: List<KVar>         

   ;     Kform Expressions
   ;     -----------------
   deftype KExp :
      type: False|KType with: (as-method => true)
   defnodes KExp :
      KSet :
         n: Int
         value: KVar
      KCast :
         exp: KVar
         targ: KType
      KCheckVoid :
         exp: KVar
      KCheckLength :
         exp: KVar
         length: Int
      KLet :
         def: KDef|KDefVar|KDefn ;|KGetObjectType
         body: KExp
      KLetRec :
         defns: List<KDefn>
         body: KExp
      KSeq :
         a: KExp
         b: KExp
      KDispatch :
         args: List<KVar>
         branches: List<KBranch>
      KMatch :
         args: List<KVar>
         branches: List<KBranch>
      KNew :
         class: KType
         methods: List<KDefmethod>
      KDo :
         func: KVar
         targs: List<KType>
         args: List<KVar>
      KVar :
         n: Int
      KPrim :
         op: KOp
         args: List<KVar>
      KLiteral :
         value:?
      KTuple :
         exps: List<KVar>
      KTupleGet :
         exp: KVar
         index: Int

      ;Constant Lifting
      ;KConst :
      ;   n: Int
      ;
      ;;Mutable Boxing
      ;KBox :
      ;   value: False|KVar
      ;KBoxGet :
      ;   box: KVar         
      ;KBoxSet :
      ;   box: KVar
      ;   value: KVar
      ;
      ;;Object Lifting
      ;KObject :
      ;   n: Int
      ;   targs: List<KType>
      ;   args: List<KVar>
      ;KObjectGet :
      ;   object: KVar
      ;   class: Int
      ;   index: Int
      ;
      ;;Multi Conversion
      ;KNoMethodError   

   ;     KForm LoStanza Types
   ;     --------------------
   deftype KLSType
   defnodes KLSType :
      KByteT
      KIntT
      KLongT
      KFloatT
      KDoubleT
      KUnknownT
      KPtrT: (type:KLSType)
      KRefT: (type:KType)
      KFnT: (a:List<KLSType>, r:False|KLSType, b:KLSType)
      KStructT: (n:Int)


   ;     KForm Location
   ;     --------------
   deftype KLoc
   defnodes KLoc :
      Value: (exp:KLSExp)
      Deref: (exp:KLSExp, type:KLSType)
      Deptr: (exp:KLSExp, type:KLSType)
      Slot: (exp:KLSExp, type:KLSType, index:KLSExp)
      Field: (base:KLoc, n:Int)


   ;     KForm LoStanza Commands
   ;     -----------------------
   deftype KLSComm
   defnodes KLSComm :
      KLSCall :
         exp: KLSExp
      KLSTCall :
         exp: KLSExp
      KLSSet :
         exp: KLoc
         value: KLSExp
      KLSLabel :
         n: Int
      KLSGoto :
         n: Int
      KLSReturn :
         exp: KLSExp
      KLSLet :
         n: Int
         value: KLSExp
         body: KLSComm
      KLSLetVar :
         n: Int
         type: KLSType
         body: KLSComm
      KLSSeq :
         a: KLSComm
         b: KLSComm
      KLSIf :
         pred: KLSExp
         conseq: KLSComm
         alt: KLSComm
      KLSMatch :
         args: List<KLSExp>
         branches: List<KLSBranch>
      KLSSkip


   ;     KForm LoStanza Expressions
   ;     --------------------------
   deftype KLSExp
   defnodes KLSExp :
      KLSVar :
         n: Int
      KLSRef :
         n: Int
         args: List<KLSExp>
      KLSRefArray :
         n: Int
         length: KLSExp
         args: List<KLSExp>
      KLSStruct :
         n: Int
         args: List<KLSExp>
      KLSPtr :
         exp: KLoc
      KLSRead :
         exp: KLoc
      KLSPrim :
         op: KLSOp
         args: List<KLSExp>
         type: KLSType
      KLSDo :
         func: KLSExp
         targs: List<KType>
         args: List<KLSExp>
         type: KLSType
      KLSCallC :
         func: KLSExp
         args: List<KLSExp>
         type: KLSType
      KLSCallS :
         func: KLSExp
         targs: List<KType>
         args: List<KLSExp>
         type: KLSType
      KLSSizeof :
         type: KLSType
      KLSTagof :
         n: Int
      KLSConv :
         exp: KLSExp
         type: KLSType
      KLSLitByte :
         value: Int
      KLSLitInt :
         value: Int
      KLSLitLong :
         value: Int
      KLSLitFloat :
         value: Float
      KLSLitDouble :
         value: Float
      KLSLitString :
         value: String

      ;     Working IR
      ;     ----------
      KLSWDo :
         arity: Int
         func: Int|KLSExp
         args: List<KLSExp>
         type: KLSType
      KLSWCallC :
         func: Int|KLSExp
         args: List<KLSExp>
         type: KLSType
      KLSWCallClosure :
         arity: Int
         func: KLSExp
         args: List<KLSExp>
         type: KLSType
      

   ;     KForm Mappers
   ;     -------------
   defmap (f:KLSExp -> KLSExp, e:KLSExp) -> KLSExp :
      ignore(Int)
      (x:List<KLSExp>) : map(f, x)
      (x:KLSExp) : f(x)
      (x:KLoc) : map(f, x)
      (x:Int|KLSExp) : f(x as KLSExp) when x typeof KLSExp else x
      ignore(KLSType)
      ignore(List<KType>)
      ignore(Float)
      ignore(String)
      ignore(KLSOp)

   defmap (f:KLSExp -> KLSExp, l:KLoc) -> KLoc :
      (x:KLSExp) : f(x)
      ignore(KLSType)
      ignore(KLoc)
      ignore(Int)

   defmap (f:KLSExp -> KLSExp, c:KLSComm) -> KLSComm :
      (x:KLSExp) : f(x)
      (x:KLoc) : map(f, x)
      ignore(Int)
      ignore(KLSComm)
      ignore(List<KLSBranch>)
      ignore(KLSType)
      (x:List<KLSExp>) : map(f, x)

   defmap (f:KLSComm -> KLSComm, c:KLSComm) -> KLSComm :
      ignore(KLSExp)
      ignore(KLoc)
      ignore(Int)
      (x:KLSComm) : f(x)
      ignore(KLSType)
      (x:List<KLSBranch>) : map(map{f, _}, x)
      ignore(List<KLSExp>)



   ;defmap (f:KType -> KType, t:KType) -> KType :
   ;   (x:KType) : f(x)
   ;   ignore(Int)
   ;
   ;defdo (f:KType -> ?, t:KType) -> False :
   ;   (x:KType) : f(x)
   ;   ignore(Int)
   ;
   ;
   ;
   ;defmap (f:KType -> KType, c:KComm) -> KComm :
   ;   (x:Func) : map(f, x)
   ;   (x:KFn) : map(f, x)
   ;   (x:List<KType>) : map(f, x)
   ;   (x:False|KType) : do?(f, x)
   ;   ignore(Int)
   ;   ignore(KExp)
   ;   ignore(False|KExp)
   ;   ignore(False|Int)
   ;   ignore(KVar)
   ;   ignore(List<KVar>)
   ;   ignore(List<Int>)
   ;
   ;defmap (f:KExp -> KExp, c:KComm) -> KComm :
   ;   (x:KVar) : f(x) as KVar
   ;   (x:List<KVar>) : map(f,x) as List<KVar>
   ;   (x:KExp) : f(x)
   ;   (x:False|KExp) : do?(f, x)
   ;   ignore(Int)
   ;   ignore(False|Int)
   ;   ignore(Func)
   ;   ignore(KFn)
   ;   ignore(List<KType>)
   ;   ignore(False|KType)
   ;   ignore(List<Int>)
   ;
   ;defdo (f:KExp -> ?, c:KComm) -> False :
   ;   (x:KVar) : f(x)
   ;   (x:List<KVar>) : do(f, x)
   ;   (x:KExp) : f(x)
   ;   (x:False|KExp) : (do?(f, x), false)
   ;   ignore(Int)
   ;   ignore(False|Int)
   ;   ignore(Func)
   ;   ignore(KFn)
   ;   ignore(List<KType>)
   ;   ignore(False|KType)
   ;   ignore(List<Int>)
   ;
   ;defmap (f:KType -> KType, c:KExp) -> KExp :      
   ;   (x:List<KBranch>) : map(map{f, _}, x)
   ;   (x:KType) : f(x)
   ;   (x:List<KType>) : map(f, x)
   ;   (x:False|KType) : do?(f, x)
   ;   ignore(Int)
   ;   ignore(True|False)
   ;   ignore(KVar)
   ;   ignore(KDef|KDefVar|KDefn|KGetObjectType)
   ;   ignore(KExp)
   ;   ignore(List<KDefn>)
   ;   ignore(List<KDefmethod>)
   ;   ignore(List<KVar>)
   ;   ignore(False|KVar)
   ;   ignore(?)
   ;
   ;defmap (f:KExp -> KExp, c:KExp) -> KExp :      
   ;   (x:KVar) : f(x) as KVar
   ;   (x:KExp) : f(x)
   ;   (x:List<KBranch>) : map(map{f, _}, x)
   ;   (x:List<KVar>) : map(f, x) as List<KVar>
   ;   (x:False|KVar) : do?(f, x) as False|KVar
   ;   ignore(Int)
   ;   ignore(True|False)
   ;   ignore(KDef|KDefVar|KDefn|KGetObjectType)
   ;   ignore(List<KDefn>)
   ;   ignore(List<KDefmethod>)
   ;   ignore(KType)
   ;   ignore(List<KType>)
   ;   ignore(?)
   ;   ignore(False|KType)
   ;
   ;defmap (f:KComm -> KComm, c:KExp) -> KExp :      
   ;   (x:List<KDefmethod>) : map(f, x) as List<KDefmethod>
   ;   (x:List<KDefn>) : map(f, x) as List<KDefn>
   ;   (x:KDef|KDefVar|KDefn|KGetObjectType) : f(x) as KDef|KDefVar|KDefn|KGetObjectType
   ;   ignore(Int)
   ;   ignore(True|False)
   ;   ignore(KVar)
   ;   ignore(KExp)
   ;   ignore(List<KBranch>)
   ;   ignore(KType)
   ;   ignore(List<KType>)
   ;   ignore(List<KVar>)
   ;   ignore(False|KVar)
   ;   ignore(?)
   ;   ignore(False|KType)
   ;
   ;defdo (f:KExp -> ?, c:KExp) -> False :      
   ;   (x:KVar) : f(x)
   ;   (x:KExp) : f(x)
   ;   (x:List<KBranch>) : do(do{f, _}, x)
   ;   (x:List<KVar>) : do(f, x)
   ;   (x:False|KVar) : (do?(f, x), false)
   ;   ignore(Int)
   ;   ignore(True|False)
   ;   ignore(KDef|KDefVar|KDefn|KGetObjectType)
   ;   ignore(List<KDefn>)
   ;   ignore(List<KDefmethod>)
   ;   ignore(KType)
   ;   ignore(List<KType>)
   ;   ignore(?)
   ;   ignore(False|KType)
   ;
   ;defdo (f:KComm -> ?, c:KExp) -> False :      
   ;   (x:List<KDefmethod>) : do(f, x)
   ;   (x:List<KDefn>) : do(f, x)
   ;   (x:KDef|KDefVar|KDefn|KGetObjectType) : f(x)
   ;   ignore(Int)
   ;   ignore(True|False)
   ;   ignore(KVar)
   ;   ignore(KExp)
   ;   ignore(List<KBranch>)
   ;   ignore(KType)
   ;   ignore(List<KType>)
   ;   ignore(List<KVar>)
   ;   ignore(False|KVar)
   ;   ignore(?)
   ;   ignore(False|KType)         


;                      AST Values
;                      ==========

public defstruct KProg :
   comms: List<KComm>

public definterface Func
public defstruct KFn <: Func :
   tail?: True|False
   targs: List<Int>
   a1: List<KType>
   a2: False|KType
   args: List<Int>
   body: KExp

public defstruct KMultifn <: Func :
   funcs: List<KFn>

public defstruct StructField :
   n: Int
   type: KLSType

public defstruct KBranch :
   args: List<Int>
   types: List<KType>
   body: KExp

public defstruct KLSBranch :
   args: List<Int>
   types: List<KType>
   body: KLSComm

public defstruct KOp :
   name: Symbol
   id: Int

public defstruct KLSOp :
   name: Symbol
   id: Int

public val ADD-OP = KLSOp(`add, fresh-id())
public val MUL-OP = KLSOp(`mul, fresh-id())
public val DIV-OP = KLSOp(`div, fresh-id())
public val MOD-OP = KLSOp(`mod, fresh-id())
public val AND-OP = KLSOp(`and, fresh-id())
public val OR-OP = KLSOp(`or, fresh-id())
public val XOR-OP = KLSOp(`xor, fresh-id())
public val SHL-OP = KLSOp(`shl, fresh-id())
public val SHR-OP = KLSOp(`shr, fresh-id())
public val ASHR-OP = KLSOp(`ashr, fresh-id())
public val EQ-OP = KLSOp(`eq, fresh-id())
public val NE-OP = KLSOp(`ne, fresh-id())
public val LT-OP = KLSOp(`lt, fresh-id())
public val GT-OP = KLSOp(`gt, fresh-id())
public val LE-OP = KLSOp(`le, fresh-id())
public val GE-OP = KLSOp(`ge, fresh-id())
public val ULT-OP = KLSOp(`ult, fresh-id())
public val UGT-OP = KLSOp(`ugt, fresh-id())
public val ULE-OP = KLSOp(`ule, fresh-id())
public val UGE-OP = KLSOp(`uge, fresh-id())

;                     Constructors
;                     ============

public defn KFn (tail?:True|False, targs:List<Int>, a1:List<KType>,
                 args:List<Int>, body:KExp) :
   KFn(tail?, targs, a1, false, args, body)

public defn KDefmulti (n:Int, targs:List<Int>, a1:List<KType>) :
   KDefmulti(n, targs, a1, false)

;                       Equality
;                       ========

defmethod equal? (a:KLSOp, b:KLSOp) :
   id(a) == id(b)
   
defmethod equal? (a:KOp, b:KOp) :
   id(a) == id(b)

;                       Mappers
;                       =======

public defn map (f:KLSComm -> KLSComm, b:KLSBranch) :
   KLSBranch(args(b), types(b), f(body(b)))


;                Getters for Normalized IR
;                =========================

;For locations
public defn exp-var (l:Value) : exp(l) as KLSVar
public defn exp-var (l:Deref) : exp(l) as KLSVar
public defn exp-var (l:Deptr) : exp(l) as KLSVar
public defn exp-var (l:Slot) : exp(l) as KLSVar
public defn index-var (l:Slot) : index(l) as KLSVar

;For commands
public defn value-var (c:KLSSet) : value(c) as KLSVar
public defn exp-var (c:KLSReturn) : exp(c) as KLSVar
public defn pred-var (c:KLSIf) : pred(c) as KLSVar
public defn arg-vars (c:KLSMatch) : args(c) as List<KLSVar>

;For expressions
public defn arg-vars (e:KLSRef) : args(e) as List<KLSVar>
public defn length-var (e:KLSRefArray) : length(e) as KLSVar
public defn arg-vars (e:KLSRefArray) : args(e) as List<KLSVar>
public defn arg-vars (e:KLSStruct) : args(e) as List<KLSVar>
public defn func-var (e:KLSDo) : func(e) as KLSVar
public defn arg-vars (e:KLSDo) : args(e) as List<KLSVar>
public defn func-var (e:KLSCallC) : func(e) as KLSVar
public defn arg-vars (e:KLSCallS) : args(e) as List<KLSVar>
public defn exp-var (e:KLSConv) : exp(e) as KLSVar
public defn func-var (e:KLSWDo) : func(e) as Int|KLSVar
public defn arg-vars (e:KLSWDo) : args(e) as List<KLSVar>
public defn func-var (e:KLSWCallC) : func(e) as Int|KLSVar
public defn arg-vars (e:KLSWCallC) : args(e) as List<KLSVar>
public defn func-var (e:KLSWCallClosure) : func(e) as KLSVar
public defn arg-vars (e:KLSWCallClosure) : args(e) as List<KLSVar>
public defn arg-vars (e:KLSPrim) : args(e) as List<KLSVar>

;                       Printers
;                       ========

defprinter (p:KProg) :
   KProg :
      ($prog comms ...)

defprinter (f:Func) :
   KFn :
      if tail?(f) : ($fn* (targs ...) (a1 ...) a2 (args ...) body)
      else : ($fn (targs ...) (a1 ...) a2 (args ...) body)
   KMultifn :
      ($multi funcs ...)


defprinter (b:KBranch) :
   KBranch :
      ($branch (args ...) (types ...) body)


defprinter (b:KLSBranch) :
   KLSBranch :
      ($branch (args ...) (types ...) body)


defprinter (t:KType) :
   KOf :
      custom{"$T~" << [n(t)]}
   KTVar :
      custom{"$V~" << [n(t)]}
   KAnd :
      ($and a b)
   KOr :
      ($or a b)
   KTop :
      custom{"$top"}
   KBot :
      custom{"$bot"}


defprinter (c:KComm) :
   KDef :
      ($def n value)
   KDefVar :
      if value(c) == false : ($defvar n)
      else : ($defvar n value)
   KDefn :
      ($def n value)
   KDefmulti :
      ($defmulti n (targs ...) (a1 ...) a2)
   KDefmethod :
      ($defmethod n multi thisn func)
   KDefType :
      ($deftype n parent)
   KExpComm :
      custom{exp(c)}

   KLSDef :
      ($lsdef n type)
   KLSDefn :
      ($lsdefn n (targs ...) (a1 ...) a2 (args ...) body)
   KLSDefType :
      ($lsdeftype n parent (fields ...) rfield)
   KExtern :
      ($extern n type name)
   KExternFn :
      ($externfn n type name)
   KLSInit :
      ($lsinit comm)


defprinter (e:KExp) :
   KSet :
      ($set n value)
   KCast :
      ($cast exp targ)
   KCheckVoid :
      ($check-void exp)
   KCheckLength :
      ($check-length exp length)      
   KLet :
      ($let def body)
   KLetRec :
      ($letrec (defns ...) body)
   KSeq :
      ($seq a b)
   KDispatch :
      ($dispatch (args ...) branches ...)
   KMatch :
      ($match (args ...) branches ...)
   KNew :
      ($new class methods ...)
   KDo :
      ($do func (targs ...) args ...)
   KVar :
      custom{"$v~" << [n(e)]}
   KPrim :
      ($prim op args ...)
   KLiteral :
      custom{value(e)}
   KTuple :
      ($tuple exps ...)
   KTupleGet :
      ($tuple-get exp index)
      
   ;KConst :
   ;   ($const n)
   ;KBox :
   ;   ($box value)
   ;KBoxGet :
   ;   ($boxget box)
   ;KBoxSet :
   ;   ($boxset box value)
   ;KObject :
   ;   ($object n (targs ...) args ...)
   ;KObjectGet :
   ;   ($object-get object class index)


defprinter (t:KLSType) :
   KByteT :
      custom{"$byte"}
   KIntT :
      custom{"$int"}
   KLongT :
      custom{"$long"}
   KFloatT :
      custom{"$float"}
   KDoubleT :
      custom{"$double"}
   KUnknownT :
      custom{"$?"}
   KPtrT :
      ($ptr type)
   KRefT :
      ($ref type)
   KFnT :
      ($fn a r b)
   KStructT :
      custom{"$T~" << [n(t)]}


defprinter (l:KLoc) :
   Value :
      custom{exp(l)}
   Deref :
      ($deref exp)
   Deptr :
      ($deptr exp)
   Slot :
      ($slot exp type index)
   Field :
      ($field base n)


defprinter (c:KLSComm) :
   KLSCall :
      custom{exp(c)}
   KLSTCall :
      ($jump exp)
   KLSSet :
      ($set exp value)
   KLSLabel :
      ($label n)
   KLSGoto :
      ($goto n)
   KLSReturn :
      ($return exp)
   KLSLet :
      ($let n value body)
   KLSLetVar :
      ($letvar n type body)
   KLSSeq :
      ($seq a b)
   KLSIf :
      ($if pred conseq alt)
   KLSMatch :
      ($match (args ...) branches ...)
   KLSSkip :
      custom{"$skip"}


defprinter (e:KLSExp) :
   KLSVar :
      custom{"$v~" << [n(e)]}
   KLSRef :
      ($ref n args ...)
   KLSRefArray :
      ($refarray n length args ...)
   KLSStruct :
      ($struct n args ...)
   KLSPtr :
      ($ptr exp)
   KLSRead :
      ($read exp)
   KLSDo :
      ($do type func (targs ...) args ...)
   KLSCallC :
      ($call-c type func args ...)
   KLSCallS :
      ($call-s type func (targs ...) args ...)
   KLSSizeof :
      ($sizeof type)
   KLSTagof :
      ($tagof n)
   KLSConv :
      ($conv exp type)
   KLSPrim :
      ($prim type op args ...)
   KLSLitByte :
      ($lit-byte value)
   KLSLitInt :
      ($lit-int value)
   KLSLitLong :
      ($lit-long value)
   KLSLitFloat :
      ($lit-float value)
   KLSLitDouble :
      ($lit-double value)
   KLSLitString :
      ($lit-string value)

   ;     Working IR
   ;     ----------
   KLSWDo :
      ($wdo func (args ...) type)
   KLSWCallC :
      ($wcall-c func (args ...) type)
   KLSWCallClosure :
      ($wcall-closure func (args ...) type)

defmethod print (o:OutputStream, op:KLSOp) :
   print(o, name(op))
   

;
;
;defn do?<?T> (f:T -> ?T, x:T|False) :
;   match(x) :
;      (x:False) : false
;      (x:T) : f(x)
;
;public defn map<?T> (f:KType -> KType, func:?T&Func) -> T :
;   {_ as T&Func} $ match(func) :
;      (func:KFn) :
;         KFn(tail?(func), targs(func), a1*, a2*, args(func), body(func)) where :
;            val a1* = map(f, a1(func))
;            val a2* = f(a2(func) as KType) when a2(func) != false         
;      (func:KMultifn) :
;         KMultifn $ for func in funcs(func) map :
;            map(f, func)
;
;public defn map<?T> (f:KExp -> KExp, func:?T&Func) -> T :
;   {_ as T&Func} $ match(func) :
;      (func:KFn) :
;         KFn(tail?(func), targs(func), a1(func), a2(func), args(func), body*) where :
;            val body* = f(body(func))
;      (func:KMultifn) :
;         KMultifn $ for func in funcs(func) map :
;            map(f, func)
;
;public defn do<?T> (f:KExp -> ?, func:?T&Func) -> False :
;   match(func) :
;      (func:KFn) : f(body(func))
;      (func:KMultifn) : do(do{f, _}, funcs(func))
;
;public defn mapr (f:KType -> KType, c:KComm) :
;   defn fe (e:KExp) : mapr(f, e)
;   map{fe, _} $
;   map{f, _} $
;   c
;
;public defn mapr (f:KComm -> KComm, c:KComm) :
;   defn fe (e:KExp) : map(f, e)
;   map(fe, c)
;    
;public defn mapr (f:KType -> KType, e:KExp) :
;   defn fe (e:KExp) : mapr(f, e)
;   defn fc (c:KComm) : mapr(f, c)
;   map{fe, _} $
;   map{fc, _} $
;   map{f, _} $
;   e
;
;public defn mapr (f:KExp -> KExp, e:KExp) :
;   defn fc (c:KComm) : map(f, c)
;   map{fc, _} $
;   map{f, _} $
;   e
;
;public defn dor (f:KExp -> ?, e:KExp) :
;   defn fc (c:KComm) : do(f, c)
;   do(fc, e)
;   do(f, e)
;
;public defn map (f:KExp -> KExp, b:KBranch) :
;   KBranch(args(b), types(b), f(body(b)))
;
;public defn do (f:KExp -> ?, b:KBranch) :
;   f(body(b))
;
;public defn map (f:KType -> KType, b:KBranch) :
;   KBranch(args(b), map(f, types(b)), body(b))

