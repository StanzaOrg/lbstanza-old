defpackage stz/il-to-tl :
  import core
  import collections
  import stz/il-ir
  import stz/dl-ir with:
    prefix(Child) => DL
  import stz/tl-ir2
  import stz/types
  import stz/namemap
  import stz/ids

;============================================================
;===================== Driver ===============================
;============================================================

public defn to-tl (ipackages:Tuple<IPackage>) -> TProg :
  fatal("Not yet implemented")

;============================================================
;================= Conversion Functions =====================
;============================================================

;Convert an IPackage to a TPackage.
defn to-tpackage (ipackage:IPackage) -> TPackage :
  val tcomms = Vector<TComm>()
  for e in exps(ipackage) do :
    for comm in e to-tcomm :
      add(tcomms, comm)
  TPackage(fatal("PackageIO()"), to-tuple(tcomms))

;Convert an expression into multiple TComms.
defn to-tcomm (return:TComm -> ?, e:IExp) -> False :
  match(e) :
    ;Iteratively scan through each begin.
    (e:IBegin) :
      for e in exps(e) do :
        to-tcomm(return, e)
    ;Discard visibility. Already used during resolution.
    (e:IVisibility) :
      to-tcomm(return, exp(e))
    ;Create a TDefType.
    (e:IDefType) :
      return $ TDefType(
        info(e)
        n!(class(e))
        ns!(args(e))
        to-type(parent(e))
        to-tuple(seq(to-child, children(e))))
    ;Destructure any nested tuples in IDef.
    (e:IDef) :
      destructure-def(return, e)
    ;Create a TDefVar.
    (e:IDefVar) :
      return $ TDefVar(
        info(e),
        n!(name(e)),
        to-type(type(e)),
        to-exp(value(e)) when value(e) is-not INone)
    ;Create a TDefn.
    (e:IDefn) :
      val [targs, cargs] = split-targs(targs(e))
      val tbody = to-exp(body(e))
      val [new-args, new-body] = destructure-args(args(e), tbody)
      return $ TDefn(
        info(e),
        tail?(e),
        n!(name(e)),
        targs, cargs,
        to-types(a1(e)),
        to-type(a2(e)),
        new-args
        new-body)
    ;Create a TDefmulti
    (e:IDefmulti) :
      val [targs, cargs] = split-targs(targs(e))
      return $ TDefmulti(
        info(e),
        n!(name(e)),
        targs, cargs,
        to-types(a1(e)),
        to-type(a2(e)))
    ;Create a TDefmethod
    (e:IDefmethod) :
      val [targs, cargs] = split-targs(targs(e))
      val tbody = to-exp(body(e))
      val [new-args, new-body] = destructure-args(args(e), tbody)
      return $ TDefmethod(
        info(e),
        tail?(e),
        fresh-id(),
        to-exp(multi(e)),
        thisn(e),
        targs,
        cargs,
        to-types(a1(e)),
        to-type(a2(e)),
        new-args,
        new-body)
    ;HiStanza expression.
    (e:IFn|IMulti|IBegin|IMatch|INew|
       VarN|ICast|IUpCast|ISet|IDo|IPrim|ILiteral|ITuple|ILet) :
      return $ TInit(info(e), to-exp(e))
    ;LoStanza definition
    (e:ILSDef) :
      return $ TLDef(
        info(e),
        n!(name(e)),
        to-lstype!(type(e)),
        to-lsexp(exp(e)))
    (e:ILSDefVar) :
      return $ TLDefVar(
        info(e),
        n!(name(e)),
        to-lstype!(type(e)),
        to-lsexp(exp(e)) when exp(e) is-not INone)
    (e:ILSDefType) :
      ;Convert all the fields, including the RField at
      ;the end.
      val field-list = Vector<Field>()
      for f in fields(e) do :
        add(field-list, to-field(f as ILSDefField))
      if rfield(e) is-not INone :
        add(field-list, to-field(rfield(e) as ILSDefField))
        
      return $ TLDefType(
        info(e),
        n!(name(e)),
        ns!(args(e)),
        to-type(parent(e)),
        to-tuple(field-list))

;============================================================
;<comment>
    (e:ILSExtern) :
      val t = #lstype(type(e)) as LSType
      val n = n!(name(e))
      val lbl = name(nm[n])
      add-comm(TExtern(n, t, lbl, info(e)))
    (e:ILSDefn) :
      val [targs, cargs] = split-targs(targs(e))
      val a1* = #lstype(a1(e)) as List<LSType>
      val a2* = #lstype(a2(e)) as LSType
      val body* = #lscomm(body(e))
      val inf = info(e)
      add-comm(TLDefn(tail?(e), n!(name(e)), targs, cargs, a1*, a2*, n!(args(e)), body*, inf))
    (e:ILSExternFn) :
      val a1* = #lstype(a1(e)) as List<LSType>
      val a2* = #lstype(a2(e)) as LSType
      val body* = #lscomm(body(e))
      val n = n!(name(e))
      val lbl = name(nm[n])
      add-comm(TLExternFn(n, a1*, a2*, n!(args(e)), body*, lbl, info(e)))
    (e:ILSDefmethod) :
      val [targs, cargs] = split-targs(targs(e))
      val m = #exp(multi(e))
      val a1* = #lstype(a1(e)) as List<LSType>
      val a2* = #lstype(a2(e)) as LSType
      val body* = #lscomm(body(e))
      val inf = info(e)
      add-comm(TLDefmethod(tail?(e), fresh-id(), m, targs, cargs, a1*, a2*, n!(args(e)), body*, inf))
    (e:ILSSet|ILSLabels|ILSLet|
      ILSIf|ILSMatch|ILSBranch|ILSDef|ILSDefVar|
      ILSDo|ILSPrim|ILSCallC) :
      add-comm(TLInit(#lscomm(e), info(e)))
    (e:IDoc) :
      val str = value(string(e) as ILiteral) as String
      add-comm(TDoc(str, info(e)))
    (e) :
      fatal("Unsupported form: %~" % [e])
;<comment>

;Helper: Create a child specifier.
defn to-child (e:IExp) -> Child :
  fatal("Not yet implemented")

;Create a Type.
;Returns false if e is INone.
defn to-type (e:IExp) -> Type|False :
  fatal("Not yet implemented")

;Create a LoStanza type.
defn to-lstype (e:IExp) -> LSType|False :
  fatal("Not yet implemented.")

;Create a LoStanza type forcifully.
defn to-lstype! (e:IExp) -> LSType :
  val t = to-lstype(e)
  if t is False : fatal("Unexpected absent type.")
  t as LSType

;Create a tuple of types.
defn to-types (es:Seqable<IExp>) -> Tuple<Type|False> :
  to-tuple(seq(to-type,es))

;Create an expression.
defn to-exp (e:IExp) -> TExp :
  fatal("Not yet implemented")

;Create a LoStanza expression.
defn to-lsexp (e:IExp) -> LSExp :
  fatal("Not yet implemented")

;Convert a Lostanza struct field.
defn to-field (e:ILSDefField) -> Field :
  fatal("Not yet implemented")

;Helper: Extract the type and captured arguments.
defn split-targs (es:List<IExp>) -> [Tuple<Int>, Tuple<Int>] :
  val targs = Vector<Int>()
  val cargs = Vector<Int>()
  for e in es do :
    match(e) :
      (e:VarN) : add(targs, n(e))
      (e:ICap) : add(cargs, n!(name(e)))
  [to-tuple(targs), to-tuple(cargs)]

;============================================================
;====================== Destructuring =======================
;============================================================

;Given: [e1,e2]:type = v,
;Destructure the tuple into:
;  [tmp1,tmp2]:type = v
;  [x,y] = tmp1
;  [w,z] = tmp2
defn destructure-nested-tuple (
       return:(Tuple<Int>, VarN) -> ?
       name:ITuple,
       value:VarN) -> False :
  val tuple-vars = Vector<Int>()
  val kont = Vector<KeyValue<ITuple,VarN>>()
  for exp in exps(name) do :
    match(exp) :
      (exp:VarN) :
        add(tuple-vars, n!(exp))
      (exp:ITuple) :
        val v = VarN(fresh-id(),false)
        add(tuple-vars, n!(v))
        add(kont, exp => v)
  return(to-tuple(tuple-vars), value)
  for entry in kont do :
    destructure-nested-tuple(return, key(entry), /value(entry))

;Destructure an IDef into multiple TDef and TDefTuple.
;Input cases:
;  v = f()
;  [a,b,c]:type = f()
;  [a,b,c]:type = v
defn destructure-def (return:TDef|TDefTuple -> ?, def:IDef) -> False :
  match(name(def), type(def), value(def)) :
    ;Case: [a,b,c] = v
    (name:ITuple, type:INone, v:VarN) :
      within (tuple-vars, v) = destructure-nested-tuple(name, v) :
        val tuple-type = map({false}, tuple-vars)
        return $ TDefTuple(info(def), tuple-vars, tuple-type, to-exp(v))
    ;Case: [a,b,c]:type = f()
    (name:ITuple, type, v) :
      ;First assign to tmp.
      val tmp = fresh-id()
      return $ TDef(info(def), tmp, to-type(type), to-exp(v))
      ;Then destructure tmp.
      within (tuple-vars, v) = destructure-nested-tuple(name, VarN(tmp,false)) :
        val tuple-type = map({false}, tuple-vars)
        return $ TDefTuple(info(def), tuple-vars, tuple-type, to-exp(v))
    ;Case: v = f()
    (name:VarN, type, v) :
      return $ TDef(info(def), n!(name), to-type(type), to-exp(v))

;Handle nested tuples in the argument list by pushing destructuring
;statements into the body.
defn destructure-args (args:List<IExp>, input-body:TExp) -> [Tuple<Int>, TExp] :
  ;Compute the new arguments to use.
  ;Introduce temporary variables as necessary for destructuring.
  val new-args = Vector<Int>()
  val entries = Vector<[FileInfo|False,Tuple<Int>,VarN]>()
  for arg in args do :
    match(arg:ITuple) :
      val tmp = VarN(fresh-id(),false)
      within (tuple-vars, v) = destructure-nested-tuple(arg, tmp) :
        add(entries, [info(arg), tuple-vars, v])
      add(new-args, n!(tmp))
    else :
      add(new-args, n!(arg))

  ;Compute the new body.
  var body:TExp = input-body
  for [info, tvars, value] in in-reverse(entries) do :
    val tuple-type = map({false}, tvars)
    body = TLetTuple(info,
                     false,
                     tvars,
                     tuple-type,
                     to-exp(value)
                     body)

  ;Return the new arguments and new body.
  [to-tuple(new-args), body]

;============================================================
;====================== Utilities ===========================
;============================================================

;Assume IExp is VarN (from resolution) and retrieve id.
defn n! (e:IExp) : n(e as VarN)
defn ns! (es:List<IExp>) : to-tuple(seq(n!,es))
