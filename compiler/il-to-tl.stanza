defpackage stz/il-to-tl :
  import core
  import collections
  import stz/il-ir
  import stz/dl-ir with:
    prefix(Child) => DL
  import stz/tl-ir2
  import stz/types
  import stz/namemap
  import stz/ids
  import stz/primitives

;============================================================
;===================== Driver ===============================
;============================================================

public defn to-tl (ipackages:Tuple<IPackage>) -> TProg :
  fatal("Not yet implemented")

;============================================================
;================= Conversion Functions =====================
;============================================================

;Convert an IPackage to a TPackage.
defn to-tpackage (ipackage:IPackage) -> TPackage :
  val tcomms = Vector<TComm>()
  val namemap:NameMap = fatal("Namemap")
  for e in exps(ipackage) do :
    within comm = to-tcomm(e) :
      add(tcomms, comm)
  TPackage(fatal("PackageIO()"), to-tuple(tcomms))

;============================================================
;=============== Conversion Functions =======================
;============================================================

;Convert an expression into multiple TComms.
;Namemap is required for retrieving labels of externs.
defn to-tcomm (return:TComm -> ?,
               e:IExp) -> False :
  match(e) :
    ;Iteratively scan through each begin.
    (e:IBegin) :
      for e in exps(e) do :
        to-tcomm(return, e)
    ;Discard visibility. Already used during resolution.
    (e:IVisibility) :
      to-tcomm(return, exp(e))
    ;Create a TDefType.
    (e:IDefType) :
      return $ TDefType(
        info(e)
        n!(class(e))
        ns!(args(e))
        to-type(parent(e))
        to-tuple(seq(to-child{_ as IDefChild}, children(e))))
    ;Destructure any nested tuples in IDef.
    (e:IDef) :
      destructure-def(return, e)
    ;Create a TDefVar.
    (e:IDefVar) :
      return $ TDefVar(
        info(e),
        n!(name(e)),
        to-type(type(e)),
        to-exp(value(e)) when value(e) is-not INone)
    ;Create a TDefn.
    (e:IDefn) :
      val [targs, cargs] = split-targs(targs(e))
      val tbody = to-exp(body(e))
      val [new-args, new-body] = destructure-args(args(e), tbody)
      return $ TDefn(
        info(e),
        tail?(e),
        n!(name(e)),
        targs, cargs,
        to-types(a1(e)),
        to-type(a2(e)),
        new-args
        new-body)
    ;Create a TDefmulti
    (e:IDefmulti) :
      val [targs, cargs] = split-targs(targs(e))
      return $ TDefmulti(
        info(e),
        n!(name(e)),
        targs, cargs,
        to-types(a1(e)),
        to-type(a2(e)))
    ;Create a TDefmethod
    (e:IDefmethod) :
      val [targs, cargs] = split-targs(targs(e))
      val tbody = to-exp(body(e))
      val [new-args, new-body] = destructure-args(args(e), tbody)
      return $ TDefmethod(
        info(e),
        tail?(e),
        fresh-id(),
        to-exp(multi(e)),
        thisn(e),
        targs,
        cargs,
        to-types(a1(e)),
        to-type(a2(e)),
        new-args,
        new-body)
    ;HiStanza expression.
    (e:IFn|IMulti|IBegin|IMatch|INew|
       VarN|ICast|IUpCast|ISet|IDo|IPrim|ILiteral|ITuple|ILet) :
      return $ TInit(info(e), to-exp(e))
    ;LoStanza definition
    (e:ILSDef) :
      return $ TLDef(
        info(e),
        n!(name(e)),
        to-lstype!(type(e)),
        to-lsexp(exp(e)))
    ;LoStanza variable
    (e:ILSDefVar) :
      return $ TLDefVar(
        info(e),
        n!(name(e)),
        to-lstype!(type(e)),
        to-lsexp(exp(e)) when exp(e) is-not INone)
    ;LoStanza type definition.
    (e:ILSDefType) :
      ;Convert all the fields, including the RField at
      ;the end.
      val field-list = Vector<Field>()
      for f in fields(e) do :
        add(field-list, to-field(f as ILSDefField))
      if rfield(e) is-not INone :
        add(field-list, to-rfield(rfield(e) as ILSDefField))

      return $ TLDefType(
        info(e),
        n!(name(e)),
        ns!(args(e)),
        to-type(parent(e)),
        to-tuple(field-list))
    ;Extern definition.
    (e:ILSExtern) :
      val n = n!(name(e))
      return $ TExtern(
        info(e),
        n,
        to-lstype!(type(e)),
        get-defined-name(n))
    ;LoStanza function.
    (e:ILSDefn) :
      val [targs, cargs] = split-targs(targs(e))
      return $ TLDefn(
        info(e),
        tail?(e),
        n!(name(e)),
        targs,
        cargs,
        to-lstypes!(a1(e)),
        to-lstype!(a2(e)),
        ns!(args(e)),
        to-lscomm(body(e)))
    ;LoStanza extern function.
    (e:ILSExternFn) :
      val n = n!(name(e))
      return $ TLExternFn(
        info(e),
        n,
        to-lstypes!(a1(e)),
        to-lstype!(a2(e)),
        ns!(args(e)),
        to-lscomm(body(e)),
        get-defined-name(n))
    ;LoStanza method.
    (e:ILSDefmethod) :
      val [targs, cargs] = split-targs(targs(e))
      return $ TLDefmethod(
        info(e),
        tail?(e),
        fresh-id(),
        to-exp(multi(e)),
        targs,
        cargs,
        to-lstypes!(a1(e)),
        to-lstype!(a2(e)),
        ns!(args(e)),
        to-lscomm(body(e)))
    ;LoStanza commands.
    (e:ILSSet|ILSLabels|ILSLet|
       ILSIf|ILSMatch|
       ILSDo|ILSPrim|ILSCallC) :
      return $ TLInit(
        info(e)
        to-lscomm(e))
    ;Documentation
    (e:IDoc) :
      val str = value(string(e) as ILiteral) as String
      return $ TDoc(info(e), str)
    ;Errors.
    (e) :
      fatal("%_ is not a valid top-level command." % [object-type(e)])

;Convert the given expression into a single TComm.
defn to-single-tcomm (e:IExp) -> TComm :
  var comm:TComm|False = false
  within c = to-tcomm(e) :
    if comm is-not False :
      fatal("Unexpected more than one command.")
    comm = c
  match(comm) :
    (comm:TComm) : comm
    (f:False) : fatal("Missing top-level command.")

;Helper: Create a child specifier.
defn to-child (e:IDefChild) -> Child :
  val arg-ns = ns!(args(e))
  add-assertion $ CorrectTArity(
                    info(e),
                    n!(name(e)),
                    map(TVar,arg-ns))
  Child(
    n!(name(e)),
    arg-ns,
    to-type!(parent(e)))

;Create a Type.
;Returns false if e is INone.
defn to-type (e:IExp) -> Type|False :
  match(e) :
    (e:IOf) :
      val n = n!(class(e))
      val targs = to-types!(args(e))
      add-assertion $ CorrectTArity(info(e), n, targs)
      TOf(n, targs)
    (e:ITuple) : TTuple(to-types!(exps(e)))
    (e:IAnd) : TAnd(to-type!(a(e)), to-type!(b(e)))
    (e:IOr) : TOr(to-type!(a(e)), to-type!(b(e)))
    (e:IArrow) : TArrow(to-types!(a1(e)), to-type!(a2(e)))
    (e:ICap) : TCap(n!(name(e)), false)
    (e:IGradual) : TGradual()
    (e:IVoid) : TBot()
    (e:VarN) : TVar(n(e))
    (e:Raw) : TRaw(n!(class(e)))
    (e:INone) : false

;Forcifully create a type.
defn to-type! (e:IExp) -> Type :
  val t = to-type(e)
  fatal("Unexpected absent type.") when t is False
  t as Type

;Forcifully create a tuple of types.
defn to-types! (es:Seqable<IExp>) -> Tuple<Type> :
  to-tuple(seq(to-type!, es))

;Create a LoStanza type.
defn to-lstype (e:IExp) -> LSType|False :
  match(e) :
    (e:ILSOfT) :
      val n = n!(class(e))
      val targs = to-types!(args(e))
      add-assertion(CorrectTArity(info(e), n, targs))
      StructT(n, targs)
    (e:ILSByteT) : ByteT()
    (e:ILSIntT) : IntT()
    (e:ILSLongT) : LongT()
    (e:ILSFloatT) : FloatT()
    (e:ILSDoubleT) : DoubleT()
    (e:ILSUnknownT) : UnknownT()
    (e:ILSPtrT) : PtrT(to-lstype!(type(e)))
    (e:ILSRefT) : RefT(to-type!(type(e)))
    (e:ILSFnT) : FnT(to-lstypes!(a1(e)), to-lstype(ar(e)), to-lstype!(a2(e)))
    (e:Raw) : TRawStruct(n!(class(e)))
    (e:INone) : false
    (e) : fatal("%_ is not a supported LoStanza type." % [object-type(e)])

;Create a LoStanza type forcifully.
defn to-lstype! (e:IExp) -> LSType :
  match(to-lstype(e)) :
    (t:LSType) : t
    (f:False) : fatal("Unexpected absent type.")

;Create a tuple of LoStanza types.
defn to-lstypes! (es:Seqable<IExp>) -> Tuple<LSType> :
  to-tuple(seq(to-lstype!, es))

;Create a tuple of types.
defn to-types (es:Seqable<IExp>) -> Tuple<Type|False> :
  to-tuple(seq(to-type,es))

;Create an expression.
defn to-exp (e:IExp) -> TExp :
  match(e) :
    ;Create a HiStanza function.
    (e:IFn) :
      val tbody = to-exp(body(e))
      val [new-args, new-body] = destructure-args(args(e), tbody)
      TFn(
        info(e),
        false,
        tail?(e),
        to-types(a1(e)),
        to-type(a2(e)),
        new-args,
        new-body)
    ;Multiple-arity function.
    (e:IMulti) :
      TMulti(info(e),
             false,
             to-exps(funcs(e)) as Tuple<TFn>)
    ;Sequence of expressions.
    (e:IBegin) :
      fatal("Empty begin") when empty?(exps(e))
      if empty?(tail(exps(e))) :
        to-exp(head(exps(e)))
      else :
        val rest = IBegin(tail(exps(e)),
                          info(exps(e)[1]))
        TSeq(info(e),
             false,
             to-exp(head(exps(e))),
             to-exp(rest))
    ;Match expression.
    (e:IMatch) :
      TMatch(info(e),
             false,
             to-exps(args(e)),
             to-exps(branches(e)) as Tuple<TBranch>)
    ;IBranch within IMatch.
    (e:IBranch) :
      val tbody = to-exp(body(e))
      val [new-args, new-body] = destructure-args(args(e), tbody)
      TBranch(info(e),
              false,
              new-args,
              to-types(types(e)),
              new-body)
    ;New object.
    (e:INew) :
      val methods = to-tuple $
        for m in methods(e) seq :
          to-single-tcomm(m as IDefmethod) as TDefmethod
      TNew(info(e),
           false,
           to-type!(class(e)),
           methods)
    ;Cast expression.
    (e:ICast) :
      TCast(info(e),
            false,
            to-exp(exp(e)),
            to-type!(type(e)))
    ;Upcast expression.
    (e:IUpCast) :
      TUpCast(info(e),
              false,
              to-exp(exp(e)),
              to-type!(type(e)))
    ;Set a variable.
    (e:ISet) :
      TSet(info(e),
           false,
           to-exp(name(e)) as TRef
           to-exp(value(e)))
    ;Calling a function.
    (e:IDo) :
      TDo(info(e),
          false,
          to-func-exp(func(e)),
          to-exps(args(e)))
    ;Calling a primitive.
    (e:IPrim) :
      TPrim(info(e),
            false,
            primitive!(name!(op(e))),
            to-exps(args(e)))
    ;Creating a literal.
    (e:ILiteral) :
      TLiteral(info(e), false, value(e))
    ;Creating a tuple.
    (e:ITuple) :
      TTupleExp(info(e), false, to-exps(exps(e)))
    ;Scoping is handled by now during resolution.
    (e:ILet) :
      to-exp(exp(e))
    ;Reference to variable.
    (e:VarN) :
      TRef(info(e), false, n(e))
    ;Reference to overloaded function.
    (e:Mix) :
      TMix(info(e), false, false, to-exps(exps(e)))
    ;Local variable definition.
    (e:Let) :
      destructure-let(e)
    ;(e:LetRec) :
    ;  TLetRec(defns*, body*, false, false, false, inf) where :
    ;    val defns* = #defn(defns(e) as List<IDefn>)
    ;    val body* = #exp(body(e))
    ;    val inf = info(e)
    ;(e:ISet) :
    ;  TSet(#exp(name(e)) as TRef, #exp(value(e)), false, false, false, info(e))
    (e) :
      fatal("%_ is not a supported HiStanza expression." % [object-type(e)])

;Convert an expression in the function calling position.
;IOf is converted to TCurry.
defn to-func-exp (e:IExp) -> TExp :
  ;Cases:
  ;  1. f<t1,t2>
  ;  2. {f1,f2}<t1,t2>
  ;  3. {f1,f2}
  ;  4. exp
  match(e) :
    (e:IOf) :
      defn mix (e:IExp, args:List<IExp>) -> TCurry|TMix :
        match(e) :
          ;Case 1: f<t1,t2>
          (e:VarN) :
            val ref = TRef(info(e), false, n(e))
            TCurry(info(e), false, ref, to-types!(args), [])
          ;Case 2: {f1,f2}<t1,t2>
          (e:Mix) :
            val options = to-tuple $ for e in exps(e) seq :
              mix(e as VarN, args) as TCurry
            TMix(info(e), false, false, options)
      mix(class(e), args(e))
    ;Case 3 and 4.
    (e) :
      to-exp(e)

;Create a tuple of expressions.
defn to-exps (es:Seqable<IExp>) -> Tuple<TExp> :
  to-tuple(seq(to-exp,es))

;Create a LoStanza expression.
defn to-lsexp (e:IExp) -> LSExp :
  fatal("Not yet implemented")

;Create a LoStanza command.
defn to-lscomm (e:IExp) -> LSComm :
  fatal("Not yet implemented")

;Convert a Lostanza struct field.
defn to-field (e:ILSDefField) -> Field :
  val mutable? = value(mut(e) as ILiteral) as True|False
  Field(name!(name(e)),
        to-lstype!(type(e)),
        mutable?)

;Convert a LoStanza struct rest field.
defn to-rfield (e:ILSDefField) -> Field :
  val mutable? = value(mut(e) as ILiteral) as True|False
  Field(name!(name(e)),
        RestT(to-lstype!(type(e))),
        mutable?)

;Helper: Extract the type and captured arguments.
defn split-targs (es:List<IExp>) -> [Tuple<Int>, Tuple<Int>] :
  val targs = Vector<Int>()
  val cargs = Vector<Int>()
  for e in es do :
    match(e) :
      (e:VarN) : add(targs, n(e))
      (e:ICap) : add(cargs, n!(name(e)))
  [to-tuple(targs), to-tuple(cargs)]

;============================================================
;================== Temporary Structures ====================
;============================================================

;Raw reference to a type.
;Will be filled in with the appropriate number of TGradual
;when type hierarchy is known.
defstruct TRaw <: Type :
  n:Int
with:
  printer => true

;Raw reference to a type.
;Will be filled in with the appropriate number of TGradual
;when type hierarchy is known.
defstruct TRawStruct <: LSType :
  n:Int
with:
  printer => true

;============================================================
;====================== Namemap =============================
;============================================================

;Hold the currently active namemap.
var CURRENT-NAMEMAP:NameMap|False = false

;Retrieve the defined name for the given identifier.
defn get-defined-name (n:Int) -> Symbol :
  match(CURRENT-NAMEMAP) :
    (nm:NameMap) : name(nm[n])
    (f:False) : fatal("No namemap is set.")

;============================================================
;====================== Assertions ==========================
;============================================================
;Assertions arise during the conversion process, and then
;are checked afterwards, after the type hierarchy has been
;created.
deftype Assert

;The given type 'n' has been parameterized with the given
;type arguments. Ensure that the type arity is actually
;correct.
defstruct CorrectTArity <: Assert:
  info:False|FileInfo
  n:Int,
  targs:Tuple<Type>

;Collect assertions here.
var ASSERTIONS:Vector<Assert>|False = false

;Add a new assertion to be checked.
defn add-assertion (a:Assert) -> False :
  add(ASSERTIONS as Vector<Assert>, a)

;Collect all the assertions in the body.
defn collect-assertions<?T> (body:() -> ?T) -> T :
  val asserts = Vector<Assert>()
  let-var ASSERTIONS = asserts :
    body()

;============================================================
;====================== Destructuring =======================
;============================================================

;Given: [e1,e2]:type = v,
;Destructure the tuple into:
;  [tmp1,tmp2]:type = v
;  [x,y] = tmp1
;  [w,z] = tmp2
defn destructure-nested-tuple (
       return:(Tuple<Int>, VarN) -> ?
       name:ITuple,
       value:VarN) -> False :
  val tuple-vars = Vector<Int>()
  val kont = Vector<KeyValue<ITuple,VarN>>()
  for exp in exps(name) do :
    match(exp) :
      (exp:VarN) :
        add(tuple-vars, n!(exp))
      (exp:ITuple) :
        val v = VarN(fresh-id(),false)
        add(tuple-vars, n!(v))
        add(kont, exp => v)
  return(to-tuple(tuple-vars), value)
  for entry in kont do :
    destructure-nested-tuple(return, key(entry), /value(entry))

;Destructure an IDef into multiple TDef and TDefTuple.
;Input cases:
;  v = f()
;  [a,b,c]:type = f()
;  [a,b,c]:type = v
defn destructure-def (return:TDef|TDefTuple -> ?, def:IDef) -> False :
  match(name(def), type(def), value(def)) :
    ;Case: [a,b,c] = v
    (name:ITuple, type:INone, v:VarN) :
      within (tuple-vars, v) = destructure-nested-tuple(name, v) :
        val tuple-type = map({false}, tuple-vars)
        return $ TDefTuple(info(def), tuple-vars, tuple-type, to-exp(v))
    ;Case: [a,b,c]:type = f()
    (name:ITuple, type, v) :
      ;First assign to tmp.
      val tmp = fresh-id()
      return $ TDef(info(def), tmp, to-type(type), to-exp(v))
      ;Then destructure tmp.
      within (tuple-vars, v) = destructure-nested-tuple(name, VarN(tmp,false)) :
        val tuple-type = map({false}, tuple-vars)
        return $ TDefTuple(info(def), tuple-vars, tuple-type, to-exp(v))
    ;Case: v = f()
    (name:VarN, type, v) :
      return $ TDef(info(def), n!(name), to-type(type), to-exp(v))

;Destructure a Let into multiple lets and let tuples.
;Same input cases as for IDef.
;Input cases:
;  v = f()
;  [a,b,c]:type = f()
;  [a,b,c]:type = v
defn destructure-let (lete:Let) -> TExp :
  match(def(lete)) :
    (def:IDefVar) :
      TLetVar(info(def),
              false,
              n!(name(def)),
              to-type(type(def)),
              to-exp(value(def)) when value(def) is-not INone,
              to-exp(body(lete)))
    (def:IDef) :
      ;Destructure the definitions as if they were at top-level.
      val tdefs = Vector<TDef|TDefTuple>()
      destructure-def(add{tdefs, _}, def)
      ;Convert top-level definitions into local let expressions.
      var body:TExp = to-exp(body(lete))
      for def in in-reverse(tdefs) do :
        match(def) :
          (e:TDef) :
            body = TLet(info(e), false, n(e), type(e), value(e), body)
          (e:TDefTuple) :
            body = TLetTuple(info(e), false, ns(e), types(e), value(e), body)
      ;Return the new body
      body      

;Handle nested tuples in the argument list by pushing destructuring
;statements into the body.
defn destructure-args (args:List<IExp>, input-body:TExp) -> [Tuple<Int>, TExp] :
  ;Compute the new arguments to use.
  ;Introduce temporary variables as necessary for destructuring.
  val new-args = Vector<Int>()
  val entries = Vector<[FileInfo|False,Tuple<Int>,VarN]>()
  for arg in args do :
    match(arg:ITuple) :
      val tmp = VarN(fresh-id(),false)
      within (tuple-vars, v) = destructure-nested-tuple(arg, tmp) :
        add(entries, [info(arg), tuple-vars, v])
      add(new-args, n!(tmp))
    else :
      add(new-args, n!(arg))

  ;Compute the new body.
  var body:TExp = input-body
  for [info, tvars, value] in in-reverse(entries) do :
    val tuple-type = map({false}, tvars)
    body = TLetTuple(info,
                     false,
                     tvars,
                     tuple-type,
                     to-exp(value)
                     body)

  ;Return the new arguments and new body.
  [to-tuple(new-args), body]

;============================================================
;====================== Utilities ===========================
;============================================================

;Assume IExp is VarN (from resolution) and retrieve id.
defn n! (e:IExp) : n(e as VarN)
defn ns! (es:List<IExp>) : to-tuple(seq(n!,es))
