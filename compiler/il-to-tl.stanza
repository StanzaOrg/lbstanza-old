defpackage stz/il-to-tl :
  import core
  import collections
  import stz/il-ir
  import stz/dl-ir with:
    prefix(Child) => DL
  import stz/tl-ir2
  import stz/types
  import stz/namemap
  import stz/ids

;============================================================
;===================== Driver ===============================
;============================================================

public defn to-tl (ipackages:Tuple<IPackage>) -> TProg :
  fatal("Not yet implemented")

;============================================================
;================= Conversion Functions =====================
;============================================================

;Convert an IPackage to a TPackage.
defn to-tpackage (ipackage:IPackage) -> TPackage :
  val tcomms = Vector<TComm>()
  val namemap:NameMap = fatal("Namemap")
  for e in exps(ipackage) do :
    within comm = to-tcomm(e, namemap) :
      add(tcomms, comm)
  TPackage(fatal("PackageIO()"), to-tuple(tcomms))

;============================================================
;=============== Conversion Functions =======================
;============================================================

;Convert an expression into multiple TComms.
;Namemap is required for retrieving labels of externs.
defn to-tcomm (return:TComm -> ?,
               e:IExp,
               namemap:NameMap) -> False :
  match(e) :
    ;Iteratively scan through each begin.
    (e:IBegin) :
      for e in exps(e) do :
        to-tcomm(return, e, namemap)
    ;Discard visibility. Already used during resolution.
    (e:IVisibility) :
      to-tcomm(return, exp(e), namemap)
    ;Create a TDefType.
    (e:IDefType) :
      return $ TDefType(
        info(e)
        n!(class(e))
        ns!(args(e))
        to-type(parent(e))
        to-tuple(seq(to-child{_ as IDefChild}, children(e))))
    ;Destructure any nested tuples in IDef.
    (e:IDef) :
      destructure-def(return, e)
    ;Create a TDefVar.
    (e:IDefVar) :
      return $ TDefVar(
        info(e),
        n!(name(e)),
        to-type(type(e)),
        to-exp(value(e)) when value(e) is-not INone)
    ;Create a TDefn.
    (e:IDefn) :
      val [targs, cargs] = split-targs(targs(e))
      val tbody = to-exp(body(e))
      val [new-args, new-body] = destructure-args(args(e), tbody)
      return $ TDefn(
        info(e),
        tail?(e),
        n!(name(e)),
        targs, cargs,
        to-types(a1(e)),
        to-type(a2(e)),
        new-args
        new-body)
    ;Create a TDefmulti
    (e:IDefmulti) :
      val [targs, cargs] = split-targs(targs(e))
      return $ TDefmulti(
        info(e),
        n!(name(e)),
        targs, cargs,
        to-types(a1(e)),
        to-type(a2(e)))
    ;Create a TDefmethod
    (e:IDefmethod) :
      val [targs, cargs] = split-targs(targs(e))
      val tbody = to-exp(body(e))
      val [new-args, new-body] = destructure-args(args(e), tbody)
      return $ TDefmethod(
        info(e),
        tail?(e),
        fresh-id(),
        to-exp(multi(e)),
        thisn(e),
        targs,
        cargs,
        to-types(a1(e)),
        to-type(a2(e)),
        new-args,
        new-body)
    ;HiStanza expression.
    (e:IFn|IMulti|IBegin|IMatch|INew|
       VarN|ICast|IUpCast|ISet|IDo|IPrim|ILiteral|ITuple|ILet) :
      return $ TInit(info(e), to-exp(e))
    ;LoStanza definition
    (e:ILSDef) :
      return $ TLDef(
        info(e),
        n!(name(e)),
        to-lstype!(type(e)),
        to-lsexp(exp(e)))
    ;LoStanza variable
    (e:ILSDefVar) :
      return $ TLDefVar(
        info(e),
        n!(name(e)),
        to-lstype!(type(e)),
        to-lsexp(exp(e)) when exp(e) is-not INone)
    ;LoStanza type definition.
    (e:ILSDefType) :
      ;Convert all the fields, including the RField at
      ;the end.
      val field-list = Vector<Field>()
      for f in fields(e) do :
        add(field-list, to-field(f as ILSDefField))
      if rfield(e) is-not INone :
        add(field-list, to-rfield(rfield(e) as ILSDefField))
        
      return $ TLDefType(
        info(e),
        n!(name(e)),
        ns!(args(e)),
        to-type(parent(e)),
        to-tuple(field-list))
    ;Extern definition.
    (e:ILSExtern) :
      val n = n!(name(e))
      return $ TExtern(
        info(e),
        n,
        to-lstype!(type(e)),
        name(namemap[n]))
    ;LoStanza function.
    (e:ILSDefn) :
      val [targs, cargs] = split-targs(targs(e))
      return $ TLDefn(
        info(e),
        tail?(e),
        n!(name(e)),
        targs,
        cargs,
        to-lstypes!(a1(e)),
        to-lstype!(a2(e)),
        ns!(args(e)),
        to-lscomm(body(e)))
    ;LoStanza extern function.
    (e:ILSExternFn) :
      val n = n!(name(e))
      return $ TLExternFn(
        info(e),
        n,
        to-lstypes!(a1(e)),
        to-lstype!(a2(e)),
        ns!(args(e)),
        to-lscomm(body(e)),
        name(namemap[n]))
    ;LoStanza method.
    (e:ILSDefmethod) :
      val [targs, cargs] = split-targs(targs(e))
      return $ TLDefmethod(
        info(e),
        tail?(e),
        fresh-id(),
        to-exp(multi(e)),
        targs,
        cargs,
        to-lstypes!(a1(e)),
        to-lstype!(a2(e)),
        ns!(args(e)),
        to-lscomm(body(e)))
    ;LoStanza commands.
    (e:ILSSet|ILSLabels|ILSLet|
       ILSIf|ILSMatch|
       ILSDo|ILSPrim|ILSCallC) :
      return $ TLInit(
        info(e)
        to-lscomm(e))
    ;Documentation
    (e:IDoc) :
      val str = value(string(e) as ILiteral) as String
      return $ TDoc(info(e), str)
    ;Errors.
    (e) :
      fatal("%_ is not a valid top-level command." % [object-type(e)])

;Helper: Create a child specifier.
defn to-child (e:IDefChild) -> Child :
  val arg-ns = ns!(args(e))
  add-assertion $ CorrectTArity(
                    info(e),
                    n!(name(e)),
                    map(TVar,arg-ns))
  Child(
    n!(name(e)),
    arg-ns,
    to-type!(parent(e)))

;Create a Type.
;Returns false if e is INone.
defn to-type (e:IExp) -> Type|False :
  match(e) :
    (e:IOf) :
      val n = n!(class(e))
      val targs = to-types!(args(e))
      add-assertion $ CorrectTArity(info(e), n, targs)
      TOf(n, targs)
    (e:ITuple) : TTuple(to-types!(exps(e)))
    (e:IAnd) : TAnd(to-type!(a(e)), to-type!(b(e)))
    (e:IOr) : TOr(to-type!(a(e)), to-type!(b(e)))
    (e:IArrow) : TArrow(to-types!(a1(e)), to-type!(a2(e)))
    (e:ICap) : TCap(n!(name(e)), false)
    (e:IGradual) : TGradual()
    (e:IVoid) : TBot()
    (e:VarN) : TVar(n(e))
    (e:Raw) : TRaw(n!(class(e)))
    (e:INone) : false

;Forcifully create a type.
defn to-type! (e:IExp) -> Type :
  val t = to-type(e)
  fatal("Unexpected absent type.") when t is False
  t as Type

;Forcifully create a tuple of types.
defn to-types! (es:Seqable<IExp>) -> Tuple<Type> :
  to-tuple(seq(to-type!, es))

;Create a LoStanza type.
defn to-lstype (e:IExp) -> LSType|False :
  match(e) :
    (e:ILSOfT) :
      val n = n!(class(e))
      val targs = to-types!(args(e))
      add-assertion(CorrectTArity(info(e), n, targs))
      StructT(n, targs)
    (e:ILSByteT) : ByteT()
    (e:ILSIntT) : IntT()
    (e:ILSLongT) : LongT()
    (e:ILSFloatT) : FloatT()
    (e:ILSDoubleT) : DoubleT()
    (e:ILSUnknownT) : UnknownT()
    (e:ILSPtrT) : PtrT(to-lstype!(type(e)))
    (e:ILSRefT) : RefT(to-type!(type(e)))
    (e:ILSFnT) : FnT(to-lstypes!(a1(e)), to-lstype(ar(e)), to-lstype!(a2(e)))
    (e:Raw) : TRawStruct(n!(class(e)))
    (e:INone) : false
    (e) : fatal("%_ is not a supported LoStanza type." % [object-type(e)])

;Create a LoStanza type forcifully.
defn to-lstype! (e:IExp) -> LSType :
  match(to-lstype(e)) :
    (t:LSType) : t
    (f:False) : fatal("Unexpected absent type.")

;Create a tuple of LoStanza types.
defn to-lstypes! (es:Seqable<IExp>) -> Tuple<LSType> :
  to-tuple(seq(to-lstype!, es))

;Create a tuple of types.
defn to-types (es:Seqable<IExp>) -> Tuple<Type|False> :
  to-tuple(seq(to-type,es))

;Create an expression.
defn to-exp (e:IExp) -> TExp :
  fatal("Not yet implemented")

;Create a LoStanza expression.
defn to-lsexp (e:IExp) -> LSExp :
  fatal("Not yet implemented")

;Create a LoStanza command.
defn to-lscomm (e:IExp) -> LSComm :
  fatal("Not yet implemented")

;Convert a Lostanza struct field.
defn to-field (e:ILSDefField) -> Field :
  fatal("Not yet implemented")

;Convert a LoStanza struct rest field.
defn to-rfield (e:ILSDefField) -> Field :
  fatal("Not yet implemented")

;Helper: Extract the type and captured arguments.
defn split-targs (es:List<IExp>) -> [Tuple<Int>, Tuple<Int>] :
  val targs = Vector<Int>()
  val cargs = Vector<Int>()
  for e in es do :
    match(e) :
      (e:VarN) : add(targs, n(e))
      (e:ICap) : add(cargs, n!(name(e)))
  [to-tuple(targs), to-tuple(cargs)]

;============================================================
;================== Temporary Structures ====================
;============================================================

;Raw reference to a type.
;Will be filled in with the appropriate number of TGradual
;when type hierarchy is known.
defstruct TRaw <: Type :
  n:Int
with:
  printer => true

;Raw reference to a type.
;Will be filled in with the appropriate number of TGradual
;when type hierarchy is known.
defstruct TRawStruct <: LSType :
  n:Int
with:
  printer => true

;============================================================
;====================== Assertions ==========================
;============================================================
;Assertions arise during the conversion process, and then
;are checked afterwards, after the type hierarchy has been
;created.
deftype Assert

;The given type 'n' has been parameterized with the given
;type arguments. Ensure that the type arity is actually
;correct.
defstruct CorrectTArity <: Assert:
  info:False|FileInfo
  n:Int,
  targs:Tuple<Type>

;Collect assertions here.
var ASSERTIONS:Vector<Assert>|False = false

;Add a new assertion to be checked.
defn add-assertion (a:Assert) -> False :
  add(ASSERTIONS as Vector<Assert>, a)

;Collect all the assertions in the body.
defn collect-assertions<?T> (body:() -> ?T) -> T :
  val asserts = Vector<Assert>()
  let-var ASSERTIONS = asserts :
    body()

;============================================================
;====================== Destructuring =======================
;============================================================

;Given: [e1,e2]:type = v,
;Destructure the tuple into:
;  [tmp1,tmp2]:type = v
;  [x,y] = tmp1
;  [w,z] = tmp2
defn destructure-nested-tuple (
       return:(Tuple<Int>, VarN) -> ?
       name:ITuple,
       value:VarN) -> False :
  val tuple-vars = Vector<Int>()
  val kont = Vector<KeyValue<ITuple,VarN>>()
  for exp in exps(name) do :
    match(exp) :
      (exp:VarN) :
        add(tuple-vars, n!(exp))
      (exp:ITuple) :
        val v = VarN(fresh-id(),false)
        add(tuple-vars, n!(v))
        add(kont, exp => v)
  return(to-tuple(tuple-vars), value)
  for entry in kont do :
    destructure-nested-tuple(return, key(entry), /value(entry))

;Destructure an IDef into multiple TDef and TDefTuple.
;Input cases:
;  v = f()
;  [a,b,c]:type = f()
;  [a,b,c]:type = v
defn destructure-def (return:TDef|TDefTuple -> ?, def:IDef) -> False :
  match(name(def), type(def), value(def)) :
    ;Case: [a,b,c] = v
    (name:ITuple, type:INone, v:VarN) :
      within (tuple-vars, v) = destructure-nested-tuple(name, v) :
        val tuple-type = map({false}, tuple-vars)
        return $ TDefTuple(info(def), tuple-vars, tuple-type, to-exp(v))
    ;Case: [a,b,c]:type = f()
    (name:ITuple, type, v) :
      ;First assign to tmp.
      val tmp = fresh-id()
      return $ TDef(info(def), tmp, to-type(type), to-exp(v))
      ;Then destructure tmp.
      within (tuple-vars, v) = destructure-nested-tuple(name, VarN(tmp,false)) :
        val tuple-type = map({false}, tuple-vars)
        return $ TDefTuple(info(def), tuple-vars, tuple-type, to-exp(v))
    ;Case: v = f()
    (name:VarN, type, v) :
      return $ TDef(info(def), n!(name), to-type(type), to-exp(v))

;Handle nested tuples in the argument list by pushing destructuring
;statements into the body.
defn destructure-args (args:List<IExp>, input-body:TExp) -> [Tuple<Int>, TExp] :
  ;Compute the new arguments to use.
  ;Introduce temporary variables as necessary for destructuring.
  val new-args = Vector<Int>()
  val entries = Vector<[FileInfo|False,Tuple<Int>,VarN]>()
  for arg in args do :
    match(arg:ITuple) :
      val tmp = VarN(fresh-id(),false)
      within (tuple-vars, v) = destructure-nested-tuple(arg, tmp) :
        add(entries, [info(arg), tuple-vars, v])
      add(new-args, n!(tmp))
    else :
      add(new-args, n!(arg))

  ;Compute the new body.
  var body:TExp = input-body
  for [info, tvars, value] in in-reverse(entries) do :
    val tuple-type = map({false}, tvars)
    body = TLetTuple(info,
                     false,
                     tvars,
                     tuple-type,
                     to-exp(value)
                     body)

  ;Return the new arguments and new body.
  [to-tuple(new-args), body]

;============================================================
;====================== Utilities ===========================
;============================================================

;Assume IExp is VarN (from resolution) and retrieve id.
defn n! (e:IExp) : n(e as VarN)
defn ns! (es:List<IExp>) : to-tuple(seq(n!,es))
