defpackage stz/il-to-tl :
  import core
  import collections
  import stz/il-ir
  import stz/dl-ir with:
    prefix(Child) => DL
  import stz/tl-ir2
  import stz/types
  import stz/namemap
  import stz/ids
  import stz/primitives
  import stz/type-hierarchy with:
    prefix(Field) => H
  import stz/tl-to-dl2

;============================================================
;===================== Driver ===============================
;============================================================

;Convert all IPackages to TL-IR.
public defn to-tl (ipackages:Tuple<IPackage>,
                   exports:Tuple<Export>) -> TProg :

  ;Create consolidated namemap.
  val namemap = NameMap(seq(namemap, ipackages),
                        exports)
  
  ;Translate each package, and collect any assertions.
  val asserts = Vector<Assert>()
  val tpackages = let-var CURRENT-NAMEMAP = namemap :
    within collect-assertions(asserts) :
      map(to-tpackage, ipackages)

  ;Compute the type hierarchy.
  val hier = within set-id-env(TypeIDEnv(namemap)) :
    compute-type-hierarchy(tpackages, exports)

  ;Return bundled packages and consolidated namemap.
  TProg(tpackages, namemap)

;============================================================
;================= Namemap Consolidation ====================
;============================================================

;Create a single NameMap containing all the given namemaps,
;and exports.
defn NameMap (nms:Seqable<NameMap>, exports:Tuple<Export>) -> NameMap :
  val namemap = NameMap()
  for nm in nms do :
    do(add{namemap, _}, nm)
  for e in exports do :
    add(namemap, VEntry(e))
  namemap

;Extract DL identifier environment from NameMap.
;Used for to-deftype function.
defn TypeIDEnv (namemap:NameMap) -> IDEnv :
  val table = to-hashtable<TypeId,Int> $
    for e in toplevel(namemap) seq? :
      if type(e) is TypeE|LTypeE :
        One(TypeId(package(e), name(e)) => n(e))
      else :
        None()
  new IDEnv :
    defmethod get (this, id:TypeId) : table[id]

;============================================================
;================= Conversion Functions =====================
;============================================================

;Convert an IPackage to a TPackage.
defn to-tpackage (ipackage:IPackage) -> TPackage :
  val tcomms = Vector<TComm>()
  for e in exps(ipackage) do :
    within comm = to-tcomm(e) :
      add(tcomms, comm)  
  TPackage(to-packageio(ipackage), to-tuple(tcomms))

;Create a blank PackageIO.
;The imported/exported entries will be populated
;after type inference.
defn to-packageio (ipackage:IPackage) -> PackageIO :
  val imports = to-tuple(seq(package, imports(ipackage)))
  val doc? = match(documentation?(ipackage)) :
    (d:IDoc) : value(string(d) as ILiteral) as String
    (f:False) : false  
  PackageIO(name(ipackage), imports, [], [], doc?)

;============================================================
;=============== Conversion Functions =======================
;============================================================

;Convert an expression into multiple TComms.
;Namemap is required for retrieving labels of externs.
defn to-tcomm (return:TComm -> ?,
               e:IExp) -> False :
  match(e) :
    ;Iteratively scan through each begin.
    (e:IBegin) :
      for e in exps(e) do :
        to-tcomm(return, e)
    ;Discard visibility. Already used during resolution.
    (e:IVisibility) :
      to-tcomm(return, exp(e))
    ;Create a TDefType.
    (e:IDefType) :
      return $ TDefType(
        info(e)
        n!(class(e))
        ns!(args(e))
        to-type(parent(e))
        to-tuple(seq(to-child{_ as IDefChild}, children(e))))
    ;Destructure any nested tuples in IDef.
    (e:IDef) :
      destructure-def(return, e)
    ;Create a TDefVar.
    (e:IDefVar) :
      return $ TDefVar(
        info(e),
        n!(name(e)),
        to-type(type(e)),
        to-exp(value(e)) when value(e) is-not INone)
    ;Create a TDefn.
    (e:IDefn) :
      val [targs, cargs] = split-targs(targs(e))
      val tbody = to-exp(body(e))
      val [new-args, new-body] = destructure-args(args(e), tbody)
      return $ TDefn(
        info(e),
        tail?(e),
        n!(name(e)),
        targs, cargs,
        to-types(a1(e)),
        to-type(a2(e)),
        new-args
        new-body)
    ;Create a TDefmulti
    (e:IDefmulti) :
      val [targs, cargs] = split-targs(targs(e))
      return $ TDefmulti(
        info(e),
        n!(name(e)),
        targs, cargs,
        to-types(a1(e)),
        to-type(a2(e)))
    ;Create a TDefmethod
    (e:IDefmethod) :
      val [targs, cargs] = split-targs(targs(e))
      val tbody = to-exp(body(e))
      val [new-args, new-body] = destructure-args(args(e), tbody)
      return $ TDefmethod(
        info(e),
        tail?(e),
        fresh-id(),
        to-exp(multi(e)),
        thisn(e),
        targs,
        cargs,
        to-types(a1(e)),
        to-type(a2(e)),
        new-args,
        new-body)
    ;HiStanza expression.
    (e:IFn|IMulti|IBegin|IMatch|INew|
       VarN|ICast|IUpCast|ISet|IDo|IPrim|ILiteral|ITuple|ILet) :
      return $ TInit(info(e), to-exp(e))
    ;LoStanza definition
    (e:ILSDef) :
      return $ TLDef(
        info(e),
        n!(name(e)),
        to-lstype!(type(e)),
        to-lsexp(exp(e)))
    ;LoStanza variable
    (e:ILSDefVar) :
      return $ TLDefVar(
        info(e),
        n!(name(e)),
        to-lstype!(type(e)),
        to-lsexp(exp(e)) when exp(e) is-not INone)
    ;LoStanza type definition.
    (e:ILSDefType) :
      ;Convert all the fields, including the RField at
      ;the end.
      val field-list = Vector<Field>()
      for f in fields(e) do :
        add(field-list, to-field(f as ILSDefField))
      if rfield(e) is-not INone :
        add(field-list, to-rfield(rfield(e) as ILSDefField))

      return $ TLDefType(
        info(e),
        n!(name(e)),
        ns!(args(e)),
        to-type(parent(e)),
        to-tuple(field-list))
    ;Extern definition.
    (e:ILSExtern) :
      val n = n!(name(e))
      return $ TExtern(
        info(e),
        n,
        to-lstype!(type(e)),
        get-defined-name(n))
    ;LoStanza function.
    (e:ILSDefn) :
      val [targs, cargs] = split-targs(targs(e))
      return $ TLDefn(
        info(e),
        tail?(e),
        n!(name(e)),
        targs,
        cargs,
        to-lstypes!(a1(e)),
        to-lstype!(a2(e)),
        ns!(args(e)),
        to-lscomm(body(e)))
    ;LoStanza extern function.
    (e:ILSExternFn) :
      val n = n!(name(e))
      return $ TLExternFn(
        info(e),
        n,
        to-lstypes!(a1(e)),
        to-lstype!(a2(e)),
        ns!(args(e)),
        to-lscomm(body(e)),
        get-defined-name(n))
    ;LoStanza method.
    (e:ILSDefmethod) :
      val [targs, cargs] = split-targs(targs(e))
      return $ TLDefmethod(
        info(e),
        tail?(e),
        fresh-id(),
        to-exp(multi(e)),
        targs,
        cargs,
        to-lstypes!(a1(e)),
        to-lstype!(a2(e)),
        ns!(args(e)),
        to-lscomm(body(e)))
    ;LoStanza commands.
    (e:ILSSet|ILSLabels|ILSLet|
       ILSIf|ILSMatch|
       ILSDo|ILSPrim|ILSCallC) :
      return $ TLInit(
        info(e)
        to-lscomm(e))
    ;Documentation
    (e:IDoc) :
      val str = value(string(e) as ILiteral) as String
      return $ TDoc(info(e), str)
    ;Errors.
    (e) :
      fatal("%_ is not a valid top-level command." % [object-type(e)])

;Helper: Create a child specifier.
defn to-child (e:IDefChild) -> Child :
  val arg-ns = ns!(args(e))
  add-assertion $ CorrectTArity(
                    info(e),
                    n!(name(e)),
                    map(TVar,arg-ns))
  Child(
    n!(name(e)),
    arg-ns,
    to-type!(parent(e)))

;Create a Type.
;Returns false if e is INone.
defn to-type (e:IExp) -> Type|False :
  match(e) :
    (e:IOf) :
      val n = n!(class(e))
      val targs = to-types!(args(e))
      add-assertion $ CorrectTArity(info(e), n, targs)
      TOf(n, targs)
    (e:ITuple) : TTuple(to-types!(exps(e)))
    (e:IAnd) : TAnd(to-type!(a(e)), to-type!(b(e)))
    (e:IOr) : TOr(to-type!(a(e)), to-type!(b(e)))
    (e:IArrow) : TArrow(to-types!(a1(e)), to-type!(a2(e)))
    (e:ICap) : TCap(n!(name(e)), false)
    (e:IGradual) : TGradual()
    (e:IVoid) : TBot()
    (e:VarN) : TVar(n(e))
    (e:Raw) : TRaw(n!(class(e)))
    (e:INone) : false

;Create a LoStanza type.
defn to-lstype (e:IExp) -> LSType|False :
  match(e) :
    (e:ILSOfT) :
      val n = n!(class(e))
      val targs = to-types!(args(e))
      add-assertion(CorrectTArity(info(e), n, targs))
      StructT(n, targs)
    (e:ILSByteT) : ByteT()
    (e:ILSIntT) : IntT()
    (e:ILSLongT) : LongT()
    (e:ILSFloatT) : FloatT()
    (e:ILSDoubleT) : DoubleT()
    (e:ILSUnknownT) : UnknownT()
    (e:ILSPtrT) : PtrT(to-lstype!(type(e)))
    (e:ILSRefT) : RefT(to-type!(type(e)))
    (e:ILSFnT) : FnT(to-lstypes!(a1(e)), to-lstype(ar(e)), to-lstype!(a2(e)))
    (e:Raw) : TRawStruct(n!(class(e)))
    (e:INone) : false
    (e) : fatal("%_ is not a supported LoStanza type." % [object-type(e)])

;Create an expression.
defn to-exp (e:IExp) -> TExp :
  match(e) :
    ;Create a HiStanza function.
    (e:IFn) :
      val tbody = to-exp(body(e))
      val [new-args, new-body] = destructure-args(args(e), tbody)
      TFn(
        info(e),
        false,
        tail?(e),
        to-types(a1(e)),
        to-type(a2(e)),
        new-args,
        new-body)
    ;Multiple-arity function.
    (e:IMulti) :
      TMulti(info(e),
             false,
             to-exps(funcs(e)) as Tuple<TFn>)
    ;Sequence of expressions.
    (e:IBegin) :
      fatal("Empty begin") when empty?(exps(e))
      if empty?(tail(exps(e))) :
        to-exp(head(exps(e)))
      else :
        val rest = IBegin(tail(exps(e)),
                          info(exps(e)[1]))
        TSeq(info(e),
             false,
             to-exp(head(exps(e))),
             to-exp(rest))
    ;Match expression.
    (e:IMatch) :
      TMatch(info(e),
             false,
             to-exps(args(e)),
             to-exps(branches(e)) as Tuple<TBranch>)
    ;IBranch within IMatch.
    (e:IBranch) :
      val tbody = to-exp(body(e))
      val [new-args, new-body] = destructure-args(args(e), tbody)
      TBranch(info(e),
              false,
              new-args,
              to-types(types(e)),
              new-body)
    ;New object.
    (e:INew) :
      val methods = to-tuple $
        for m in methods(e) seq :
          to-single-tcomm(m as IDefmethod) as TDefmethod
      TNew(info(e),
           false,
           to-type!(class(e)),
           methods)
    ;Cast expression.
    (e:ICast) :
      TCast(info(e),
            false,
            to-exp(exp(e)),
            to-type!(type(e)))
    ;Upcast expression.
    (e:IUpCast) :
      TUpCast(info(e),
              false,
              to-exp(exp(e)),
              to-type!(type(e)))
    ;Set a variable.
    (e:ISet) :
      TSet(info(e),
           false,
           to-exp(name(e)) as TRef
           to-exp(value(e)))
    ;Calling a function.
    (e:IDo) :
      TDo(info(e),
          false,
          to-func-exp(func(e)),
          to-exps(args(e)))
    ;Calling a primitive.
    (e:IPrim) :
      TPrim(info(e),
            false,
            primitive!(name!(op(e))),
            to-exps(args(e)))
    ;Creating a literal.
    (e:ILiteral) :
      TLiteral(info(e), false, value(e))
    ;Creating a tuple.
    (e:ITuple) :
      TTupleExp(info(e), false, to-exps(exps(e)))
    ;Scoping is handled by now during resolution.
    (e:ILet) :
      to-exp(exp(e))
    ;Reference to variable.
    (e:VarN) :
      TRef(info(e), false, n(e))
    ;Reference to overloaded function.
    (e:Mix) :
      TMix(info(e), false, false, to-exps(exps(e)))
    ;Local variable definition.
    (e:Let) :
      destructure-let(e)
    ;Local function definitions.
    (e:LetRec) :
      val defns = to-tuple $
        for e in defns(e) seq :
          to-single-tcomm(e as IDefn) as TDefn
      TLetRec(info(e),
              false,
              defns,
              to-exp(body(e)))
    ;Set variable.
    (e:ISet) :
      TSet(info(e),
           false,
           to-exp(name(e)) as TRef,
           to-exp(value(e)))
    ;Unsupported expression.
    (e) :
      fatal("%_ is not a supported HiStanza expression." % [object-type(e)])

;Convert an expression in the function calling position.
;IOf is converted to TCurry.
defn to-func-exp (e:IExp) -> TExp :
  ;Cases:
  ;  1. f<t1,t2>
  ;  2. {f1,f2}<t1,t2>
  ;  3. {f1,f2}
  ;  4. exp
  match(e) :
    (e:IOf) :
      defn mix (e:IExp, args:List<IExp>) -> TCurry|TMix :
        match(e) :
          ;Case 1: f<t1,t2>
          (e:VarN) :
            val ref = TRef(info(e), false, n(e))
            TCurry(info(e), false, ref, to-types!(args), [])
          ;Case 2: {f1,f2}<t1,t2>
          (e:Mix) :
            val options = to-tuple $ for e in exps(e) seq :
              mix(e as VarN, args) as TCurry
            TMix(info(e), false, false, options)
      mix(class(e), args(e))
    ;Case 3 and 4.
    (e) :
      to-exp(e)

;Convert an expression in the function calling position.
;IOf is converted to LSCurry.
defn to-lsfunc-exp (e:IExp) -> LSExp :
  ;Cases:
  ;  1. f<t1,t2>
  ;  2. {f1,f2}<t1,t2>
  ;  3. {f1,f2}
  ;  4. exp
  match(e) :
    (e:IOf) :
      defn mix (e:IExp, args:List<IExp>) -> LSCurry|LSMix :
        match(e) :
          ;Case 1: f<t1,t2>
          (e:VarN) :
            val ref = LSVar(info(e), false, n(e))
            LSCurry(info(e), false, ref, to-types!(args), [])
          ;Case 2: {f1,f2}<t1,t2>
          (e:Mix) :
            val options = to-tuple $ for e in exps(e) seq :
              mix(e as VarN, args) as LSCurry
            LSMix(info(e), false, false, options)
      mix(class(e), args(e))
    ;Case 3 and 4.
    (e) :
      to-lsexp(e)

;Create a LoStanza expression.
defn to-lsexp (e:IExp) -> LSExp :
  match(e) :
    (e:ILSNew) :
      val [n, targs] = to-lsclass+targs(type(e))
      if empty?(targs) :
        LSNewRaw(info(e), n, to-lsexps(args(e)))
      else :
        add-assertion(CorrectTArity(info(e), n, value!(targs)))
        LSNew(info(e), false, n, value!(targs), to-lsexps(args(e)))
    (e:ILSStruct) :
      val [n, targs] = to-lsclass+targs(type(e))
      if empty?(targs) :
        LSStructRaw(info(e), n, to-lsexps(args(e)))
      else :
        add-assertion(CorrectTArity(info(e), n, value!(targs)))
        LSStruct(info(e), false, n, value!(targs), to-lsexps(args(e)))
    (e:ILSAddr) :
      LSAddr(info(e), false, to-lsexp(exp(e)), unstable?(e))
    (e:ILSDeref) :
      LSDeref(info(e), false, to-lsexp(exp(e)))
    (e:ILSSlot) :
      LSSlot(info(e), false, to-lsexp(exp(e)), to-lsexp(index(e)))
    (e:ILSField) :
      LSField(info(e), false, to-lsexp(exp(e)), name!(name(e)))
    (e:ILSDo) :
      LSDo(info(e), false, to-lsfunc-exp(func(e)), to-lsexps(args(e)))
    (e:ILSCallC) :
      LSCallC(info(e), false, to-lsfunc-exp(func(e)), to-lsexps(args(e)))
    (e:ILSPrim) :
      LSPrim(info(e),
             false,
             ls-primitive!(name!(op(e))),
             to-lsexps(args(e)))
    (e:ILSSizeof) :
      LSSizeof(info(e), false, to-lstype!(type(e)))
    (e:ILSTagof) :
      LSTagof(info(e), false, n!(name(e)))
    (e:ILSAs) :
      LSCast(info(e), false, to-lsexp(exp(e)), to-lstype!(type(e)))
    (e:ILSAnd) :
      LSAnd(info(e), false, to-lsexp(a(e)), to-lsexp(b(e)))
    (e:ILSOr) :
      LSOr(info(e), false, to-lsexp(a(e)), to-lsexp(b(e)))
    (e:ILSLetExp) :
      LSLetExp(info(e), false, to-lscomm(comm(e)), to-lsexp(exp(e)))
    (e:ILSFn) :
      LSFn(info(e), false, to-exp(ref(e)))
    (e:VarN) :
      LSVar(info(e), false, n!(e))
    (e:ILiteral) :
      LSLiteral(info(e), false, value(e))
    (e:Mix) :
      LSMix(info(e), false, false, to-lsexps(exps(e)))
    (e) :
      fatal("%_ is an unsupported LoStanza expression." % [object-type(e)])

;Helper: Extract the class identifier and type arguments
;from the given expression.
defn to-lsclass+targs (e:IExp) -> [Int, Maybe<Tuple<Type>>] :
  match(e) :
    (e:ILSOfT) : [n!(class(e)), One(to-types!(args(e)))]
    (e:Raw) : [n!(class(e)), None()]

;Create a LoStanza command.
defn to-lscomm (e:IExp) -> LSComm :
  match(e) :
    (e:IBegin) :
      if empty?(exps(e)) :
        LSSkip(info(e))
      else if empty?(tail(exps(e))) :
        to-lscomm(head(exps(e)))
      else :
        val rest = IBegin(tail(exps(e)),
                          info(exps(e)[1]))
        LSSeq(
          info(e)
          to-lscomm(head(exps(e)))
          to-lscomm(rest))
    (e:ILSSet) :
      LSSet(info(e), to-lsexp(exp(e)), to-lsexp(value(e)))
    (e:ILSLabels) :
      val blocks = to-tuple $
        for b in blocks(e) seq :
          to-lscomm(b as ILSLabeledBlock) as LSLabeledBlock
      LSLabels(info(e), blocks)
    (e:ILSLabeledBlock) :
      LSLabeledBlock(info(e),
                     n!(name(e)),
                     ns!(args(e)),
                     to-lstypes!(types(e)),
                     to-lscomm(body(e)))
    (e:ILSGoto) :
      LSGoto(info(e),
             n!(name(e)),
             to-lsexps(args(e)))
    (e:ILSReturn) :
      LSReturn(info(e),
               to-lsexp(exp(e)))
    (e:ILSLet) :
      to-lscomm(comm(e))
    (e:ILSIf) :
      LSIf(info(e),
           to-lsexp(pred(e)),
           to-lscomm(conseq(e)),
           to-lscomm(alt(e)))
    (e:ILSMatch) :
      val branches = to-tuple $ for b in branches(e) seq :
        to-lscomm(b as ILSBranch) as LSBranch
      LSMatch(info(e), to-lsexps(args(e)), branches)
    (e:ILSBranch) :
      LSBranch(info(e),
               ns!(args(e)),
               to-lstypes(types(e)),
               to-lscomm(body(e)))
    (e:ILSDef) :
      LSDef(info(e),
            n!(name(e)),
            to-lstype(type(e)),
            to-lsexp(exp(e)))
    (e:ILSDefVar) :
      LSDefVar(info(e),
               n!(name(e)),
               to-lstype!(type(e)),
               to-lsexp(exp(e)) when exp(e) is-not INone)
    (e:ILSDo|ILSPrim|ILSCallC) :
      LSCall(info(e), to-lsexp(e))
    (e) :
      fatal("%_ is not a supported LoStanza command." % [object-type(e)])

;Convert a Lostanza struct field.
defn to-field (e:ILSDefField) -> Field :
  val mutable? = value(mut(e) as ILiteral) as True|False
  Field(name!(name(e)),
        to-lstype!(type(e)),
        mutable?)

;Convert a LoStanza struct rest field.
defn to-rfield (e:ILSDefField) -> Field :
  val mutable? = value(mut(e) as ILiteral) as True|False
  Field(name!(name(e)),
        RestT(to-lstype!(type(e))),
        mutable?)

;Helper: Extract the type and captured arguments.
defn split-targs (es:List<IExp>) -> [Tuple<Int>, Tuple<Int>] :
  val targs = Vector<Int>()
  val cargs = Vector<Int>()
  for e in es do :
    match(e) :
      (e:VarN) : add(targs, n(e))
      (e:ICap) : add(cargs, n!(name(e)))
  [to-tuple(targs), to-tuple(cargs)]

;============================================================
;================== Convenience Conversions =================
;============================================================

;Convert the given expression into a single TComm.
defn to-single-tcomm (e:IExp) -> TComm :
  var comm:TComm|False = false
  within c = to-tcomm(e) :
    if comm is-not False :
      fatal("Unexpected more than one command.")
    comm = c
  match(comm) :
    (comm:TComm) : comm
    (f:False) : fatal("Missing top-level command.")

;Forcifully create a type.
defn to-type! (e:IExp) -> Type :
  val t = to-type(e)
  fatal("Unexpected absent type.") when t is False
  t as Type

;Forcifully create a tuple of types.
defn to-types! (es:Seqable<IExp>) -> Tuple<Type> :
  to-tuple(seq(to-type!, es))

;Create a tuple of LoStanza types.
defn to-lstypes! (es:Seqable<IExp>) -> Tuple<LSType> :
  to-tuple(seq(to-lstype!, es))

;Create a LoStanza type forcifully.
defn to-lstype! (e:IExp) -> LSType :
  match(to-lstype(e)) :
    (t:LSType) : t
    (f:False) : fatal("Unexpected absent type.")

;Create a tuple of LoStanza types.
defn to-lstypes (es:Seqable<IExp>) -> Tuple<LSType|False> :
  to-tuple(seq(to-lstype, es))

;Create a tuple of types.
defn to-types (es:Seqable<IExp>) -> Tuple<Type|False> :
  to-tuple(seq(to-type,es))

;Create a tuple of expressions.
defn to-exps (es:Seqable<IExp>) -> Tuple<TExp> :
  to-tuple(seq(to-exp,es))

;Create a tuple of LoStanza expressions.
defn to-lsexps (es:Seqable<IExp>) -> Tuple<LSExp> :
  to-tuple(seq(to-lsexp, es))

;============================================================
;================== Temporary Structures ====================
;============================================================

;Raw reference to a type.
;Will be filled in with the appropriate number of TGradual
;when type hierarchy is known.
defstruct TRaw <: Type :
  n:Int
with:
  printer => true

;Raw reference to a type.
;Will be filled in with the appropriate number of TGradual
;when type hierarchy is known.
defstruct TRawStruct <: LSType :
  n:Int
with:
  printer => true

;Raw reference to the creation of a new heap reference.
;Will be filled in with the appropriate number of TGradual
;when type hierarchy is known.
defstruct LSNewRaw <: LSExp :
  info:FileInfo|False with: (as-method => true)
  n:Int
  args:Tuple<LSExp>

;Raw reference to a new stack declared structure.
;Will be filled in with the appropriate number of TGradual
;when type hierarchy is known.
defstruct LSStructRaw <: LSExp :
  info:FileInfo|False with: (as-method => true)
  n:Int
  args:Tuple<LSExp>

;============================================================
;====================== Namemap =============================
;============================================================

;Hold the currently active namemap.
var CURRENT-NAMEMAP:NameMap|False = false

;Retrieve the defined name for the given identifier.
defn get-defined-name (n:Int) -> Symbol :
  match(CURRENT-NAMEMAP) :
    (nm:NameMap) : name(nm[n])
    (f:False) : fatal("No namemap is set.")

;============================================================
;====================== Assertions ==========================
;============================================================
;Assertions arise during the conversion process, and then
;are checked afterwards, after the type hierarchy has been
;created.
deftype Assert

;The given type 'n' has been parameterized with the given
;type arguments. Ensure that the type arity is actually
;correct.
defstruct CorrectTArity <: Assert:
  info:False|FileInfo
  n:Int,
  targs:Tuple<Type>

;Collect assertions here.
var ASSERTIONS:Vector<Assert>|False = false

;Add a new assertion to be checked.
defn add-assertion (a:Assert) -> False :
  add(ASSERTIONS as Vector<Assert>, a)

;Collect all the assertions in the body.
defn collect-assertions<?T> (body:() -> ?T, asserts:Vector<Assert>) -> T :
  let-var ASSERTIONS = asserts :
    body()

;============================================================
;====================== Destructuring =======================
;============================================================

;Given: [e1,e2]:type = v,
;Destructure the tuple into:
;  [tmp1,tmp2]:type = v
;  [x,y] = tmp1
;  [w,z] = tmp2
defn destructure-nested-tuple (
       return:(Tuple<Int>, VarN) -> ?
       name:ITuple,
       value:VarN) -> False :
  val tuple-vars = Vector<Int>()
  val kont = Vector<KeyValue<ITuple,VarN>>()
  for exp in exps(name) do :
    match(exp) :
      (exp:VarN) :
        add(tuple-vars, n!(exp))
      (exp:ITuple) :
        val v = VarN(fresh-id(),false)
        add(tuple-vars, n!(v))
        add(kont, exp => v)
  return(to-tuple(tuple-vars), value)
  for entry in kont do :
    destructure-nested-tuple(return, key(entry), /value(entry))

;Destructure an IDef into multiple TDef and TDefTuple.
;Input cases:
;  v = f()
;  [a,b,c]:type = f()
;  [a,b,c]:type = v
defn destructure-def (return:TDef|TDefTuple -> ?, def:IDef) -> False :
  match(name(def), type(def), value(def)) :
    ;Case: [a,b,c] = v
    (name:ITuple, type:INone, v:VarN) :
      within (tuple-vars, v) = destructure-nested-tuple(name, v) :
        val tuple-type = map({false}, tuple-vars)
        return $ TDefTuple(info(def), tuple-vars, tuple-type, to-exp(v))
    ;Case: [a,b,c]:type = f()
    (name:ITuple, type, v) :
      ;First assign to tmp.
      val tmp = fresh-id()
      return $ TDef(info(def), tmp, to-type(type), to-exp(v))
      ;Then destructure tmp.
      within (tuple-vars, v) = destructure-nested-tuple(name, VarN(tmp,false)) :
        val tuple-type = map({false}, tuple-vars)
        return $ TDefTuple(info(def), tuple-vars, tuple-type, to-exp(v))
    ;Case: v = f()
    (name:VarN, type, v) :
      return $ TDef(info(def), n!(name), to-type(type), to-exp(v))

;Destructure a Let into multiple lets and let tuples.
;Same input cases as for IDef.
;Input cases:
;  v = f()
;  [a,b,c]:type = f()
;  [a,b,c]:type = v
defn destructure-let (lete:Let) -> TExp :
  match(def(lete)) :
    (def:IDefVar) :
      TLetVar(info(def),
              false,
              n!(name(def)),
              to-type(type(def)),
              to-exp(value(def)) when value(def) is-not INone,
              to-exp(body(lete)))
    (def:IDef) :
      ;Destructure the definitions as if they were at top-level.
      val tdefs = Vector<TDef|TDefTuple>()
      destructure-def(add{tdefs, _}, def)
      ;Convert top-level definitions into local let expressions.
      var body:TExp = to-exp(body(lete))
      for def in in-reverse(tdefs) do :
        match(def) :
          (e:TDef) :
            body = TLet(info(e), false, n(e), type(e), value(e), body)
          (e:TDefTuple) :
            body = TLetTuple(info(e), false, ns(e), types(e), value(e), body)
      ;Return the new body
      body      

;Handle nested tuples in the argument list by pushing destructuring
;statements into the body.
defn destructure-args (args:List<IExp>, input-body:TExp) -> [Tuple<Int>, TExp] :
  ;Compute the new arguments to use.
  ;Introduce temporary variables as necessary for destructuring.
  val new-args = Vector<Int>()
  val entries = Vector<[FileInfo|False,Tuple<Int>,VarN]>()
  for arg in args do :
    match(arg:ITuple) :
      val tmp = VarN(fresh-id(),false)
      within (tuple-vars, v) = destructure-nested-tuple(arg, tmp) :
        add(entries, [info(arg), tuple-vars, v])
      add(new-args, n!(tmp))
    else :
      add(new-args, n!(arg))

  ;Compute the new body.
  var body:TExp = input-body
  for [info, tvars, value] in in-reverse(entries) do :
    val tuple-type = map({false}, tvars)
    body = TLetTuple(info,
                     false,
                     tvars,
                     tuple-type,
                     to-exp(value)
                     body)

  ;Return the new arguments and new body.
  [to-tuple(new-args), body]

;============================================================
;=================== Hierarchy Creation =====================
;============================================================

;Extract the type hierarchy from the given converted packages
;and exports.
defn compute-type-hierarchy (tpackages:Collection<TPackage>,
                             environment:Tuple<Export>) -> TypeHierarchy :
  ;Collect all type commands in packages and environment.
  val type-comms = Vector<TDefType|TLDefType>()
  for tpackage in tpackages do :
    add-all(type-comms, filter-by<TDefType|TLDefType>(comms(tpackage)))
  add-all(type-comms, seq(to-deftype, type-recs)) where :
    val type-recs = filter-by<StructRec|TypeRec>(seq(rec, environment))

  ;Each entry, C => P, means that P is the parent type of class C.
  ;If P is false, then C has no parent.
  val parents = IntTable<False|Type>()

  ;Each entry, C => [T,S] means that T,S are the type arguments for
  ;the class C.
  val type-args = IntTable<Tuple<Int>>()

  ;Each entry, C => ST, means that C corresponds to the special type
  ;ST.
  val special-types = IntTable<SpecialType>()

  ;Populate 'parents' and 'type-args' using the direct deftype
  ;relationship.
  defn calc-direct-parents () -> False :
    for c in type-comms do :
      parents[n(c)] = parent(c)
      type-args[n(c)] = args(c)

  ;Helper: Add 't' as another parent under class n.
  defn add-parent (n:Int, t:Type) -> False :
    val new-parent = match(parents[n]) :
      (p:Type) : TAnd(p,t)
      (p:False) : t
    parents[n] = new-parent

  ;Modify 'parents' table such that child relationships are
  ;included.
  defn calc-child-parents () -> False :
    for c in filter-by<TDefType>(type-comms) do :
      for c in children(c) do :
        ;Re-express the parent using the type variables used
        ;at definition time.
        val env = to-tuple $
          seq({_ => TVar(_)}, args(c), type-args[n(c)])
        add-parent(n(c), sub(parent(c), env))

  ;Populate the 'special-types' table. 
  defn calc-special-types () -> False :
    special-types[env-id(CORE-TUPLE-ID)] = CoreTuple

  ;Helper: Translate to hierarchy fields.
  defn to-hfield (f:Field) -> HField :
    HField(name(f), type(f), mutable?(f))

  ;Calculate the hierarchy relations.
  defn calc-relations () -> Tuple<TypeRelation> :
    to-tuple $ for c in type-comms seq :
      val special = get?(special-types, n(c))
      val parent = parents[n(c)]
      val fields = match(c:TLDefType) : map(to-hfield, fields(c))
                   else : []
      TypeRelation(n(c), special, args(c), parent, fields)
 
  ;Launch!
  calc-direct-parents()
  calc-child-parents()
  calc-special-types()
  TypeHierarchy(calc-relations())

;============================================================
;====================== Utilities ===========================
;============================================================

;Assume IExp is VarN (from resolution) and retrieve id.
defn n! (e:IExp) : n(e as VarN)
defn ns! (es:List<IExp>) : to-tuple(seq(n!,es))
