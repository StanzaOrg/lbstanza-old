defpackage stz/earley-grammar-analysis :
  import core
  import collections
  import stz/earley-grammar
  import stz/earley-sexp-stream
  import stz/earley-eval-result
  import stz/utils
  import stz/earley-eitems

;============================================================
;===================== Grammar Creation =====================
;============================================================

public defn Grammar (input-rules:GRules) -> Grammar :
  val [grules, matchers] = create-matcher-tokens $
                           ;convert-negation-rules(input-rules)
                           remove-left-right-recursive-rules $
                           order-rules $
                           input-rules
  val production-table = ProductionTable<GDefProduction|False>(num-productions(grules), false)
  for def in productions(grules) do :
    production-table[id(def)] = def
  val grammar-properties = analyze-grammar-properties(grules)
  val null-prods = nullable-productions(grammar-properties)
  val forward-dispatch-sets = analyze-dispatch-sets(grules, grammar-properties, first-sets)
  val backward-dispatch-sets = analyze-dispatch-sets(grules, grammar-properties, last-sets)

  defn dispatch-rules (production:Int, dispatch-sets:DispatchSet, next-input:SExpToken) :
    match(next-input) :
      (input:SExpWildcard) :
        all-rules(dispatch-sets)[production]
      (input:SExpForm) :
        val x = unwrap-token(form(input))
        val obj-rules = match(x) :
          (x:Symbol) : keyword-rules(dispatch-sets)[[production, x]]
          (x) : List()
        val type-rules = match(x) :
          (x:Char) : prim-rules(dispatch-sets)[to-int(GCharType)][production]
          (x:Byte) : prim-rules(dispatch-sets)[to-int(GByteType)][production]
          (x:Int) : prim-rules(dispatch-sets)[to-int(GIntType)][production]
          (x:Long) : prim-rules(dispatch-sets)[to-int(GLongType)][production]
          (x:Float) : prim-rules(dispatch-sets)[to-int(GFloatType)][production]
          (x:Double) : prim-rules(dispatch-sets)[to-int(GDoubleType)][production]
          (x:String) : prim-rules(dispatch-sets)[to-int(GStringType)][production]
          (x:Symbol) : prim-rules(dispatch-sets)[to-int(GSymbolType)][production]
          (x:True) : prim-rules(dispatch-sets)[to-int(GTrueType)][production]
          (x:False) : prim-rules(dispatch-sets)[to-int(GFalseType)][production]
          (x:List) : list-rules(dispatch-sets)[production]
          (x) : List()
        cat-all $ [
          obj-rules,
          type-rules,
          any-rules(dispatch-sets)[production]
          null-rules(dispatch-sets)[production]]
      (input:SExpListEnd) :
        cat(
          list-end-rules(dispatch-sets)[production]
          null-rules(dispatch-sets)[production])

  new Grammar :
    defmethod production (this, id:Int) :
      production-table[id] as GDefProduction
    defmethod get (this, i:Int) :
      rules(grules)[i] as GTokenRule
    defmethod nullable? (this, production:Int) :
      null-prods[production]
    defmethod to-seq (this) :
      to-seq(rules(grules) as Tuple<GTokenRule>)
    defmethod rules (this, production:Int) :
      all-rules(forward-dispatch-sets)[production]
    defmethod rules-with-prefix (this, production:Int, next-input:SExpToken) :
      dispatch-rules(production, forward-dispatch-sets, next-input)
    defmethod rules-with-suffix (this, production:Int, next-input:SExpToken) :
      dispatch-rules(production, backward-dispatch-sets, next-input)
    defmethod match? (this, matcher-id:Int, form) :
      matchers[matcher-id](form)
    defmethod num-productions (this) :
      num-productions(grules)

;============================================================
;================== Grammar Properties ======================
;============================================================

defstruct GrammarProperties:
  nullable-productions: IntSet
  nullable-rules: IntSet
  first-sets: Tuple<Tuple<GTerminal>>
  last-sets: Tuple<Tuple<GTerminal>>

defn analyze-grammar-properties (grammar:GRules) :
  ;Compute parent rules that contain each production.
  val parent-table = ProductionTable<List<Int>>(num-productions(grammar), List())
  for (rule in rules(grammar), rule-index in 0 to false) do :
    for prod in filter-by<GProduction>(tokens(rule as GTokenRule)) do :
      add(parent-table, id(prod), rule-index)      

  ;Production worklist algorithm
  defn worklist (f:(Int, GTokenRule, () -> False) -> ?) :
    val queue = Queue<Int>()
    add-all(queue, 0 to length(rules(grammar)))
    while not empty?(queue) :
      val rule-index = pop(queue)
      val rule = rules(grammar)[rule-index] as GTokenRule
      var progress?:True|False = false
      defn progress () : progress? = true
      f(rule-index, rule, progress)
      if progress? :
        add-all(queue, parent-table[id(rule)])

  ;Compute nullable productions and rules
  val null-prods = IntSet()
  val null-rules = IntSet()
  defn nullable? (t:GToken) :
    match(t:GProduction) :
      null-prods[id(t)]

  defn nullable? (rule:GTokenRule) :
    all?(nullable?, tokens(rule))
  within (rule-index, rule, progress) = worklist() :
    if nullable?(rule) :
      add(null-rules, rule-index)
      progress() when add(null-prods, id(rule))

  ;Compute firstsets
  val first-set-entries = HashSet<KeyValue<Int,GTerminal>>()
  val first-set-table = ProductionTable<List<GTerminal>>(num-productions(grammar), List())
  defn first-set (t:GToken) :
    match(t) :
      (t:GMatcherToken) : [terminal(t)]
      (t:GTerminal) : [t]
      (t:GProduction) : first-set-table[id(t)]
  defn first-set (rule:GTokenRule) :
    generate<GTerminal> :
      let loop (i:Int = 0) :
        if i < length(tokens(rule)) :
          val t = tokens(rule)[i]
          do(yield, first-set(t))
          loop(i + 1) when nullable?(t)
  within (rule-index, rule, progress) = worklist() :
    for t in first-set(rule) do :
      if add(first-set-entries, id(rule) => t) :
        add(first-set-table, id(rule), t)
        progress()
  val first-sets = for rule in rules(grammar) map :
    to-tuple $ unique $ first-set(rule as GTokenRule)

  ;Compute last sets
  val last-set-entries = HashSet<KeyValue<Int,GTerminal>>()
  val last-set-table = ProductionTable<List<GTerminal>>(num-productions(grammar), List())
  defn last-set (t:GToken) :
    match(t) :
      (t:GMatcherToken) : [terminal(t)]
      (t:GTerminal) : [t]
      (t:GProduction) : last-set-table[id(t)]
  defn last-set (rule:GTokenRule) :
    generate<GTerminal> :
      val n = length(tokens(rule))
      let loop (i:Int = n - 1) :
        if i >= 0 :
          val t = tokens(rule)[i]
          do(yield, last-set(t))
          loop(i - 1) when nullable?(t)
  within (rule-index, rule, progress) = worklist() :
    for t in last-set(rule) do :
      if add(last-set-entries, id(rule) => t) :
        add(last-set-table, id(rule), t)
        progress()
  val last-sets = for rule in rules(grammar) map :
    to-tuple $ unique $ last-set(rule as GTokenRule)

  ;Return all properties
  GrammarProperties(
    null-prods,
    null-rules,
    first-sets,
    last-sets)

;============================================================
;================== Dispatch Sets ===========================
;============================================================

defstruct DispatchSet :
  all-rules:ProductionTable<List<Int>>
  null-rules:ProductionTable<List<Int>>
  any-rules:ProductionTable<List<Int>>
  list-end-rules:ProductionTable<List<Int>>
  prim-rules:Array<ProductionTable<List<Int>>>
  list-rules:ProductionTable<List<Int>>
  keyword-rules:HashTable<[Int,Symbol],List<Int>>

defn analyze-dispatch-sets (grammar:GRules,
                            props:GrammarProperties,
                            prediction-set:GrammarProperties -> Tuple<Tuple<GTerminal>>) :
  ;Create rule sets
  val nprods = num-productions(grammar)
  val all-rules = ProductionTable<List<Int>>(nprods, List())
  val null-rules = ProductionTable<List<Int>>(nprods, List())
  val any-rules = ProductionTable<List<Int>>(nprods, List())
  val list-end-rules = ProductionTable<List<Int>>(nprods, List())
  val prim-rules = Array<ProductionTable<List<Int>>>(GPrimType-length)
  for i in 0 to length(prim-rules) do :
    prim-rules[i] = ProductionTable<List<Int>>(nprods, List())
  val list-rules = ProductionTable<List<Int>>(nprods, List())
  val keyword-rules = HashTable<[Int,Symbol],List<Int>>(List())

  ;Add to rule sets
  for (rule in rules(grammar), rule-index in 0 to false, pset in prediction-set(props)) do :
    defn add-to-set (table:ProductionTable<List<Int>>) :
      add(table, id(rule), rule-index)
    add-to-set(all-rules)
    if nullable-rules(props)[rule-index] :
      add-to-set(null-rules)
    for token in pset do :
      let loop (token:GTerminal = token) :
        match(token) :
          (token:GAny|GListRest) : add-to-set(any-rules)
          (token:GListEnd) : add-to-set(list-end-rules)
          (token:GPrimToken) : add-to-set(prim-rules[to-int(type(token))])
          (token:GListStart) : add-to-set(list-rules)
          (token:GKeyword) : add(keyword-rules, [id(rule), item(token)], rule-index)
          (token:GMatcherToken) : loop(terminal(token))

  ;Ensure subtraction relationships of sets
  val set-buffer = IntSet()
  defn minus (a:Seqable<Int>, b:Seqable<Int>) :
    add-all(set-buffer, b)
    val result = to-list $ filter({not set-buffer[_]}, a)
    clear(set-buffer)
    result
  defn subtract-map! (atable:ProductionTable<List<Int>>,
                      btables:Collection<ProductionTable<List<Int>>>) :
    for entry in atable map! :
      val prod = key(entry)
      val bset = seq-cat({_[prod]}, btables)
      value(entry) - bset
  defn subtract-map! (atable:HashTable<[Int,Symbol],List<Int>>,
                      btables:Collection<ProductionTable<List<Int>>>) :
    for entry in atable map! :
      val [prod, _] = key(entry)
      val bset = seq-cat({_[prod]}, btables)
      value(entry) - bset
  subtract-map!(keyword-rules, [prim-rules[to-int(GSymbolType)], any-rules, null-rules])
  for prim-i-rules in prim-rules do :
    subtract-map!(prim-i-rules, [any-rules, null-rules])
  subtract-map!(list-rules, [any-rules, null-rules])
  subtract-map!(list-end-rules, [null-rules])
  subtract-map!(any-rules, [null-rules])

  ;Return computed dispatch sets
  DispatchSet(
    all-rules
    null-rules
    any-rules
    list-end-rules
    prim-rules
    list-rules
    keyword-rules)

;============================================================
;================- Negation Set Analysis ====================
;============================================================

deftype KSet
defstruct KeywordSet <: KSet :
  keywords: Tuple<Symbol>
with:
  printer => true

defstruct ProdSet <: KSet :
  name: Symbol
with:
  printer => true

defstruct UnionSet <: KSet :
  sets: Tuple<KSet>
with:
  printer => true

defstruct MinusSet <: KSet :
  a: KSet
  b: KSet
with:
  printer => true

;<comment>
defn convert-negation-rules (rules:Tuple<GRule>) -> Tuple<GMatcherRule|GTokenRule> :
  ;Gather positive and negative tokens
  val negative-table = HashTable<Symbol,List<GToken>>(List())
  val positive-table = HashTable<Symbol,List<GToken>>(List())
  for rule in rules do :
    match(rule) :
      (rule:GNegationRule) :
        add(negative-table, name(rule), token(rule))
      (rule:GTokenRule) :
        if length(tokens(rule)) == 1 :
          val t = tokens(rule)[0]
          add(positive-table, name(rule), t)
      (rule:GMatcherRule) :
        false

  ;Create initial kset table
  val kset-table = HashTable<Symbol,KSet>()
  defn to-kset (name:Symbol) :
    set?(kset-table, name, fn () :
      val psets = to-tuple $ seq(to-kset, positive-table[name])
      val nsets = to-tuple $ seq(to-kset, negative-table[name])
      MinusSet(UnionSet(psets), UnionSet(nsets)))
  defn to-kset (t:GToken) :
    match(t) :
      (t:GProduction) : to-kset(name(t))
      (t:GKeyword) : KeywordSet([item(t)])

  ;Simplify kset
  val simplified-kset-table = HashTable<Symbol,KeywordSet>()
  defn simplify (name:Symbol) :
    set?(simplified-kset-table, name, fn () :
      simplify(to-kset(name)))
  defn simplify (kset:KSet) -> KeywordSet :
    match(kset) :
      (kset:UnionSet) :
        val keywords = seq-cat(keywords{simplify(_)}, sets(kset))
        KeywordSet $ to-tuple $ to-hashset<Symbol>(keywords)
      (kset:MinusSet) :
        val symbols = to-hashset<Symbol>(keywords(simplify(a(kset))))
        do(remove{symbols, _}, keywords(simplify(b(kset))))
        KeywordSet $ to-tuple $ symbols
      (kset:KeywordSet) :
        kset
      (kset:ProdSet) :
        simplify(name(kset))

  ;Compute keywords to subtract from each production
  val subtract-keyword-table = HashTable<Symbol,HashSet<Symbol>>()
  defn subtract-keywords (prod:Symbol) :
    set?(subtract-keyword-table, prod, fn () :
      to-hashset<Symbol> $
        for t in negative-table[prod] seq-cat :
          keywords(simplify(to-kset(t))))

  ;Update matcher rules
  defn update-rule (r:GRule) :
    if key?(negative-table, name(r)) :
      match(r) :
        (r:GMatcherRule) :
        (r:GTokenRule) :
          fatal("Illegal rule with negation.") when length(tokens(r)) != 1
          fatal("Illegal rule with negation.") when lazy-action?(r)
          val terminal = tokens(r)[0] as GTerminal
          GMatcherRule(name(r), terminal, matcher, action(r))
    else : r

  ;Create matcher rule
  defn to-matcher-rules (prod:Symbol) :
    val neg-tokens = negative-table[prod]
    val keywords = seq-cat(keywords{simplify(to-kset(_))}, neg-tokens)
    val keyword-set = to-hashset<Symbol>(keywords)
    defn match? (form) :
      match(unwrap-token(form)) :
        (s:Symbol) : not keyword-set[s]
        (s) : true
    val new-rules = Vector<GRule>()
    val old-prod = gensym(prod)
    add(new-rules, GMatcherRule(prod, [GProduction(old-prod)], match?, fn (result) : result[0]))
    for r in rules do :
      if name(r) == prod and r is-not GNegationRule :
        add(new-rules, sub-name(r, old-prod))
    new-rules

  ;Create matcher rules
  val matcher-rules = seq-cat(to-matcher-rules, keys(negative-table))
  defn standard-rule? (r:GRule) : not key?(negative-table, name(r))
  val remaining-rules = filter(standard-rule?, rules[1 to false])
  val new-rules = to-tuple $ cat-all $ [
    [rules[0]]
     matcher-rules
     remaining-rules]
  new-rules as Tuple<GMatcherRule|GTokenRule>
;<comment>

;============================================================
;============= Remove Left-Right-Recursive Rules ============
;============================================================

defn remove-left-right-recursive-rules (grules:GRules) -> GRules :
  ;Retrieve the first/last token in the given rule.
  defn first-token (r:GTokenRule) -> GToken|False :
    if not empty?(tokens(r)) :
      tokens(r)[0]
  defn last-token (r:GTokenRule) -> GToken|False :
    val ts = tokens(r)
    if not empty?(ts) :
      ts[length(ts) - 1]

  ;Return true if the given rule is left-right recursive.
  defn left-right-recursive? (r:GRule) -> True|False :
    match(r:GTokenRule) :
      defn matches-prod? (t:GToken|False) :
        match(t:GProduction) : id(t) == id(r)
      length(tokens(r)) > 1 and 
      matches-prod?(first-token(r)) and
      matches-prod?(last-token(r))

  ;Retrieve the PriorityKey for a rule.
  defn priority-key! (r:GRule) -> PriorityKey :
    val params = params(r as GTokenRule) as TokenRuleParams
    PriorityKey(priority(params), associativity(params))

  ;Assume that given rules are all of the same production,
  ;Rewrite rules to remove ambiguous left-right-recursive rules.
  ;clone-production is used whenever a new production is required during
  ;the rewrite.
  defn transform (clone-production:Int -> Int, rs:Tuple<GRule>) -> Tuple<GRule> :
    ;Returns the indices corresponding to left-right recursive rules.
    ;Each returned entry has form key => i, where
    ;- key is the priority key of the rule.
    ;- i is the index of the rule in the ruple.
    defn left-right-indices () -> Tuple<KeyValue<PriorityKey,Int>> :
      to-tuple $
        for (r in rs, i in 0 to false) seq? :
          if left-right-recursive?(r) : One(priority-key!(r) => i)
          else : None()
    ;Returns the group of rules with minimum priority key,
    ;and remainder rules.
    defn left-right-group (entries:Tuple<KeyValue<PriorityKey,Int>>) -> [Tuple<GTokenRule>, Tuple<GRule>] :
      val min-key = minimum(seq(key,entries))
      val entries* = filter({key(_) == min-key}, entries)
      select(rs, seq(value, entries*)) as [Tuple<GTokenRule>, Tuple<GRule>]
    ;Transforms the given left-right-recursive rule.
    ;Assume that rule has form E = E + E (left-associative), and that new-prod is EA
    ;Then returns [E = E + EA, E = EA].
    defn transform-lr-rule (r:GTokenRule, new-prod:Int) -> Tuple<GTokenRule> :
      val params = params(r) as TokenRuleParams
      val replace-index = match(associativity(params)) :
        (a:RightAssociative) : 0
        (a:LeftAssociative|NonAssociative) : length(tokens(r)) - 1
      val tokens* = to-tuple $
        for (t in tokens(r), i in 0 to false) seq :
          if i == replace-index : GProduction(new-prod)
          else : t
      [GTokenRule(id(r), tokens*, params, order(r))
       GTokenRule(id(r), [GProduction(new-prod)], InheritParams(), order(r))]
    ;Transforms the given remaining rule.
    ;Assume that rule has form E = E x E, and that new-prod is EA.
    ;Then returns EA = EA x EA
    defn transform-remainder (r:GRule, new-prod:Int) -> GRule :
      match(r:GTokenRule) :
        ;Returns true if token t at index i should be replaced by new-prod.
        defn replace? (t:GToken, i:Int) -> True|False :
          match(t:GProduction) :
            if id(t) == id(r) :
              i == 0 or i == length(tokens(r)) - 1
        ;Perform replacement
        val tokens* = to-tuple $
          for (t in tokens(r), i in 0 to false) seq :
            GProduction(new-prod) when replace?(t,i) else t
        GTokenRule(new-prod, tokens*, params(r), order(r))            
      else :
        r
    ;Main algorithm
    defn main () :
      val entries = left-right-indices()
      if empty?(entries) :
        rs
      else :
        val [lr-rules, remainder] = left-right-group(entries)
        val prod* = clone-production(id(lr-rules[0]))
        val lr-rules* = to-tuple $ seq-cat(transform-lr-rule{_, prod*}, lr-rules)
        val remainder* = map(transform-remainder{_, prod*}, remainder)
        val transformed-remainder* = transform(clone-production, remainder*)
        to-tuple(cat(lr-rules*, transformed-remainder*))
    ;Launch
    main()
    
  ;Group all rules by production, and transform each.
  defn transform-all (grules:GRules) -> GRules :
    ;Gather productions
    val prod-table = IntTable<GDefProduction>()
    for p in productions(grules) do :
      prod-table[id(p)] = p      
    ;Gather all rules
    val rule-table = ProductionTable<List<GRule>>(num-productions(grules), List())
    for r in rules(grules) do :
      add(rule-table, id(r), r)
    ;Production cloning
    val production-counter = to-seq(num-productions(grules) to false)
    defn clone-production (id:Int) -> Int :
      val id* = next(production-counter)
      val old-prod = prod-table[id] as GDefProduction
      prod-table[id*] = GDefProduction(id*, name(old-prod))
      id*
    ;Transform each group
    val rules* = to-tuple $
      for entry in rule-table seq-cat :
        val rules = to-tuple(value(entry))
        transform(clone-production, rules)
    ;Return all transformed groups
    val prods* = to-tuple(values(prod-table))
    GRules(prods*, rules*)

  ;Launch transformation if necessary.
  if any?(left-right-recursive?, rules(grules)) :
    println("Before Transformation:")
    println(grules)
    val result = transform-all(grules)
    println("After Transformation:")
    println(result)
    result
  else : grules

defstruct PriorityKey <: Comparable<PriorityKey> & Equalable :
  priority: Int
  associativity: Associativity

defmethod equal? (a:PriorityKey, b:PriorityKey) :
  priority(a) == priority(b) and
  associativity(a) == associativity(b)

defmethod compare (a:PriorityKey, b:PriorityKey) :
  val c = compare(priority(b), priority(a))
  if c == 0 : compare(associativity(a), associativity(b))    
  else : c

defn select<?T> (xs:Tuple<?T>, indices:Seqable<Int>) -> [Tuple<T>, Tuple<T>] :
  val mask = Array<True|False>(length(xs), false)
  for i in indices do : mask[i] = true
  val selected = to-tuple $ for (x in xs, i in 0 to false) filter : mask[i]
  val not-selected = to-tuple $ for (x in xs, i in 0 to false) filter : not mask[i]
  [selected, not-selected]

;============================================================
;================= Create Matcher Tokens ====================
;============================================================

defn create-matcher-tokens (grules:GRules) -> [GRules, Tuple<(? -> True|False)>] :
  val matchers = Vector<(? -> True|False)>()
  defn get-id (m:? -> True|False) :
    add(matchers, m)
    length(matchers) - 1
  val rules* = for r in rules(grules) map :
    match(r) :
      (r:GMatcherRule) :
        val token = GMatcherToken(token(r), get-id(matcher(r)))
        GTokenRule(id(r), [token], TokenRuleParams(action(r), false), order(r))
      (r:GTokenRule) :
        r
  val grules* = GRules(productions(grules), rules*)
  [grules*, to-tuple(matchers)]

;============================================================
;==================== Order Rules ===========================
;============================================================
defn order-rules (grules:GRules) -> GRules :
  val rules* = to-tuple(seq(sub-order, rules(grules), 0 to false))
  GRules(productions(grules), rules*)

;============================================================
;======================== Utilities =========================
;============================================================

defn add-all<?T> (q:Queue<?T>, xs:Seqable<T>) :
  do(add{q, _}, xs)

defn add<?K,?V> (table:Table<?K,List<?V>>, k:K, v:V) :
  update(table, cons{v, _,}, k)