defpackage stz/earley-grammar-analysis :
  import core
  import collections
  import stz/earley-grammar
  import stz/earley-sexp-stream
  import stz/earley-eval-result
  import stz/utils
  import stz/earley-eitems
  import stz/algorithms

;============================================================
;===================== Grammar Creation =====================
;============================================================

public defn Grammar (input-rules:GRules) -> Grammar :
  var grules = input-rules
  val matchers = let :
    val [grules*, matchers] = create-matcher-tokens $
                              ;convert-negation-rules(input-rules)
                              order-rules $
                              input-rules                              
    grules = grules*
    matchers
  ;grules = remove-left-right-recursion(grules)

  val production-table = ProductionTable<GDefProduction|False>(num-productions(grules), false)
  for def in productions(grules) do :
    production-table[id(def)] = def
  val grammar-properties = analyze-grammar-properties(grules,false)
  val null-prods = nullable-productions(grammar-properties)
  val forward-dispatch-sets = analyze-dispatch-sets(grules, grammar-properties, first-sets)
  val backward-dispatch-sets = analyze-dispatch-sets(grules, grammar-properties, last-sets)

  defn dispatch-rules (production:Int, dispatch-sets:DispatchSet, next-input:SExpToken) :
    match(next-input) :
      (input:SExpWildcard) :
        all-rules(dispatch-sets)[production]
      (input:SExpForm) :
        val x = unwrap-token(form(input))
        val obj-rules = match(x) :
          (x:Symbol) : keyword-rules(dispatch-sets)[[production, x]]
          (x) : List()
        val type-rules = match(x) :
          (x:Char) : prim-rules(dispatch-sets)[to-int(GCharType)][production]
          (x:Byte) : prim-rules(dispatch-sets)[to-int(GByteType)][production]
          (x:Int) : prim-rules(dispatch-sets)[to-int(GIntType)][production]
          (x:Long) : prim-rules(dispatch-sets)[to-int(GLongType)][production]
          (x:Float) : prim-rules(dispatch-sets)[to-int(GFloatType)][production]
          (x:Double) : prim-rules(dispatch-sets)[to-int(GDoubleType)][production]
          (x:String) : prim-rules(dispatch-sets)[to-int(GStringType)][production]
          (x:Symbol) : prim-rules(dispatch-sets)[to-int(GSymbolType)][production]
          (x:True) : prim-rules(dispatch-sets)[to-int(GTrueType)][production]
          (x:False) : prim-rules(dispatch-sets)[to-int(GFalseType)][production]
          (x:List) : list-rules(dispatch-sets)[production]
          (x) : List()
        cat-all $ [
          obj-rules,
          type-rules,
          any-rules(dispatch-sets)[production]
          null-rules(dispatch-sets)[production]]
      (input:SExpListEnd) :
        cat(
          list-end-rules(dispatch-sets)[production]
          null-rules(dispatch-sets)[production])

  new Grammar :
    defmethod production (this, id:Int) :
      production-table[id] as GDefProduction
    defmethod get (this, i:Int) :
      rules(grules)[i] as GTokenRule
    defmethod nullable? (this, production:Int) :
      null-prods[production]
    defmethod to-seq (this) :
      to-seq(rules(grules) as Tuple<GTokenRule>)
    defmethod rules (this, production:Int) :
      all-rules(forward-dispatch-sets)[production]
    defmethod rules-with-prefix (this, production:Int, next-input:SExpToken) :
      dispatch-rules(production, forward-dispatch-sets, next-input)
    defmethod match? (this, matcher-id:Int, form) :
      matchers[matcher-id](form)
    defmethod num-productions (this) :
      num-productions(grules)

;============================================================
;================== Grammar Properties ======================
;============================================================

defstruct GrammarProperties:
  nullable-productions: IntSet
  nullable-rules: IntSet
  ;components: ProductionTable<List<GProduction>>
  left-sets: ProductionTable<List<GToken>>
  right-sets: ProductionTable<List<GToken>>
  first-sets: Tuple<Tuple<GTerminal>>
  last-sets: Tuple<Tuple<GTerminal>>
  first-tokens: Tuple<Tuple<GToken>>
  last-tokens: Tuple<Tuple<GToken>>

defn analyze-grammar-properties (grammar:GRules, block:GProduction|False) :
  ;Compute parent rules that contain each production.
  ;Each entry P => (i, j, k) means that production P exists in rule i, j, and k.
  val parent-table = ProductionTable<List<Int>>(num-productions(grammar), List())
  for (rule in rules(grammar), rule-index in 0 to false) do :
    for prod in filter-by<GProduction>(tokens(rule as GTokenRule)) do :
      add(parent-table, id(prod), rule-index)      

  ;Production worklist algorithm
  ;The given function is called repeatedly on all rules in the grammar.
  ;The function is given:
  ;- The rule index.
  ;- The rule
  ;- A progress function to report that progress has been made.
  ;If progress is made on one rule, then all rules that use that
  ;production are processed again.
  defn worklist (process:(Int, GTokenRule, () -> False) -> ?) :
    val queue = Queue<Int>()
    add-all(queue, 0 to length(rules(grammar)))
    while not empty?(queue) :
      val rule-index = pop(queue)
      val rule = rules(grammar)[rule-index] as GTokenRule
      var progress?:True|False = false
      defn progress () : progress? = true
      process(rule-index, rule, progress)
      if progress? :
        add-all(queue, parent-table[prod(rule)])

  ;Compute nullable productions and rules
  ;- null-prods holds all nullable productions.
  ;- null-rules holds indices of all nullable rules.
  val null-prods = IntSet()
  val null-rules = IntSet()
  defn nullable? (t:GToken) :
    match(t:GProduction) :
      null-prods[id(t)]
  defn nullable? (rule:GTokenRule) :
    all?(nullable?, tokens(rule))
  within (rule-index, rule, progress) = worklist() :
    if nullable?(rule) :
      add(null-rules, rule-index)
      progress() when add(null-prods, prod(rule))

  ;Compute firstsets.
  ;Every entry P => (A B C) in first-set-table means that
  ;production P has first set equal to tokens (A B C).
  ;Furthermore, the entries P => A, P => B, P => C exist in
  ;first-set-entries.
  val first-set-entries = HashSet<KeyValue<Int,GToken>>()
  val first-set-table = ProductionTable<List<GToken>>(num-productions(grammar), List())
  val first-terminals = Vector<Tuple<GTerminal>>()
  val first-tokens = Vector<Tuple<GToken>>()
  defn first-set (t:GToken) -> List<GToken> :
    match(t) :
      (t:GMatcherToken) : List(terminal(t))
      (t:GTerminal) : List(t)
      (t:GProduction) :
        if t == block : List(t)
        else : cons(t, first-set-table[id(t)])
  defn first-set (rule:GTokenRule) -> List<GToken> :
    val ts = tokens(rule)
    let loop (i:Int = 0) :
      if i < length(ts) :
        val xs = first-set(ts[i])
        if nullable?(ts[i]) : append(xs, loop(i + 1))
        else : xs
      else : List()  
  within (rule-index, rule, progress) = worklist() :
    for t in first-set(rule) do :
      if add(first-set-entries, prod(rule) => t) :
        add(first-set-table, prod(rule), t)
        progress()
  for rule in rules(grammar) do :
    val ts = unique(first-set(rule as GTokenRule))
    add(first-terminals, to-tuple(filter-by<GTerminal>(ts)))
    add(first-tokens, to-tuple(ts))

  ;Compute lastsets.
  ;Every entry P => (A B C) in last-set-table means that
  ;production P has last set equal to tokens (A B C).
  ;Furthermore, the entries P => A, P => B, P => C exist in
  ;last-set-entries.
  val last-set-entries = HashSet<KeyValue<Int,GToken>>()
  val last-set-table = ProductionTable<List<GToken>>(num-productions(grammar), List())
  val last-terminals = Vector<Tuple<GTerminal>>()
  val last-tokens = Vector<Tuple<GToken>>()
  defn last-set (t:GToken) -> List<GToken> :
    match(t) :
      (t:GMatcherToken) : List(terminal(t))
      (t:GTerminal) : List(t)
      (t:GProduction) : 
        if t == block : List(t)
        else : cons(t, last-set-table[id(t)])
  defn last-set (rule:GTokenRule) -> List<GToken> :
    val ts = tokens(rule)
    val n = length(ts)
    let loop (i:Int = n - 1) :
      if i >= 0 :
        val xs = last-set(ts[i])
        if nullable?(ts[i]) : append(xs, loop(i - 1))
        else : xs
      else : List()  
  within (rule-index, rule, progress) = worklist() :
    for t in last-set(rule) do :
      if add(last-set-entries, prod(rule) => t) :
        add(last-set-table, prod(rule), t)
        progress()
  for rule in rules(grammar) do :
    val ts = unique(last-set(rule as GTokenRule))
    add(last-terminals, to-tuple(filter-by<GTerminal>(ts)))
    add(last-tokens, to-tuple(ts))      

  println("First Set Table")
  do(println, first-set-table)
  println("Last Set Table")
  do(println, last-set-table)

  ;;Component Table
  ;val component-table = child-components(grammar, block)
  ;println("Component Table")
  ;do(println, component-table)

  ;Return all properties
  GrammarProperties(
    null-prods,
    null-rules,
    ;component-table,
    first-set-table,
    last-set-table,
    to-tuple(first-terminals),
    to-tuple(last-terminals),
    to-tuple(first-tokens),
    to-tuple(last-tokens))

;;Compute strongly connected components for all productions.
;;Assuming that 'block' is the current left-right-recursive production
;;to block edges.
;;Each entry a => (a b c) means that production 'a' is strongly connected
;;to 'a', 'b', and 'c'.
;defn child-components (grammar:GRules, block:GProduction|False) -> ProductionTable<List<GProduction>> :
;  ;Compute all children
;  val children-table = ProductionTable<List<GProduction>>(num-productions(grammar), List())
;  for r in rules(grammar) do :
;    val children = filter-by<GProduction>(tokens(r as GTokenRule))
;    children-table[id(r)] = append(children, children-table[id(r)])
;  ;Compute components
;  val components = strong-components $ 
;    for entry in children-table seq :
;      val children = unique(value(entry))
;      val not-blocked = filter({_ != block}, children)
;      GProduction(key(entry)) => to-list(not-blocked)
;  ;Return components as table
;  val component-table = ProductionTable<List<GProduction>>(num-productions(grammar), List())
;  for c in components do :
;    match(c:List<GProduction>) :
;      for ci in c do :
;        component-table[id(ci)] = c
;  component-table

;============================================================
;=================== Cache Utility ==========================
;============================================================

deftype Cache<T>
defmulti value<?T> (cache:Cache<?T>) -> T
defmulti invalidate (cache:Cache) -> False

defn Cache<?T> (f:() -> ?T) :
  var value:Maybe<T> = None()
  new Cache<T> :
    defmethod invalidate (this) :
      value = None()
    defmethod value (this) :
      if empty?(value) :
        value = One(f())
      value!(value)

;============================================================
;=================== Grammar Transformer ====================
;============================================================

deftype GrammarTransformer
defmulti fresh-production (t:GrammarTransformer) -> GProduction
defmulti immediate-right-sets (t:GrammarTransformer, prod:GProduction) -> List<GToken>
defmulti modify (t:GrammarTransformer, mod:GrammarModification) -> False
defmulti rules (t:GrammarTransformer, prod:GProduction) -> Tuple<RuleEntry>
defmulti num-productions (t:GrammarTransformer) -> Int
defmulti grammar (t:GrammarTransformer) -> GRules

defstruct RuleEntry :
  id: Int
  rule: GTokenRule

deftype GrammarMod
defstruct CloneProduction <: GrammarMod :
  prod: GProduction
  old: GProduction
defstruct SubstituteRule <: GrammarMod :
  id: Int
  rule: GTokenRule
defstruct DeleteRule <: GrammarMod :
  id: Int
defstruct AddRule <: GrammarMod :
  rule: GTokenRule
  
defstruct GrammarModification :
  mods: Tuple<GrammarMod>

;defn GrammarTransformer (grammar:GRules) -> GrammarTransformer :
;  ;Table of productions
;  val prod-table = to-inttable(id, productions(grammar))
;
;  ;Counter to use to generate fresh productions
;  val prod-counter = to-seq(num-productions(grammar) to false)
;
;  ;Counter for rule identifiers
;  val rule-counter = to-seq(0 to false)
;
;  ;List of current rules
;  val rule-list = to-vector<RuleEntry> $
;    for r in rules(grammar) seq :
;      RuleEntry(next(rule-counter), r as GTokenRule)
;
;  ;Compute immediate right sets
;  val immediate-right-sets = Cache(compute-immediate-right-sets) where :
;    defn compute-immediate-right-sets () -> ProductionTable<List<GToken>> :
;      val table = ProductionTable<List<GToken>>(peek(prod-counter), List())
;      for entry in rule-list do :
;        val rule = rule(entry)
;        if not empty?(tokens(rule)) :
;          val n = length(tokens(rule))
;          val tn = tokens(rule)[n - 1]
;          add(table, id(rule), tn)
;      table
;      
;  ;Create GrammarTransformer feature.
;  new GrammarTransformer :
;    defmethod rules (this, prod:GProduction) :
;      to-tuple $ for r in rule-list filter :
;        id(rule(r)) == id(prod)
;    defmethod fresh-production (this) :
;      GProduction(next(prod-counter))
;    defmethod modify (this, gmod:GrammarModification) :
;      ;Invalidate cache
;      invalidate(immediate-right-sets)
;      ;Perform production cloning, and additions.
;      ;Gather deletions and substitutions.
;      val delete-set = IntSet()
;      val sub-table = IntTable<GTokenRule>()
;      for mod in mods(gmod) do :
;        match(mod) :
;          (mod:CloneProduction) :
;            val old-def = prod-table[id(old(mod))]
;            val name* = symbol-join $ [name(old-def), id(prod(mod))]
;            val new-def = GDefProduction(id(prod(mod)), name*)
;            prod-table[id(prod(mod))] = new-def
;          (mod:SubstituteRule) :
;            sub-table[id(mod)] = rule(mod)
;          (mod:DeleteRule) :
;            add(delete-set, id(mod))
;          (mod:AddRule) :
;            add(rule-list, RuleEntry(next(rule-counter), rule(mod)))
;      ;Perform deletions and substitutions
;      for rule in rule-list update :
;        if delete-set[id(rule)] :
;          None()
;        else if key?(sub-table, id(rule)) :
;          One(RuleEntry(id(rule), sub-table[id(rule)]))
;        else :
;          One(rule)
;    defmethod immediate-right-sets (this, prod:GProduction) :
;      value(immediate-right-sets)[id(prod)]
;    defmethod num-productions (this) :
;      peek(prod-counter)
;    defmethod grammar (this) :
;      GRules(to-tuple(values(prod-table)),
;             to-tuple(seq(rule, rule-list)))

;<doc>=======================================================
;=============== Left-Right-Recursive Transform =============
;============================================================

Operations needed for manipulating rules:
- Create a new production with the same name as another.
- Create a new production with the same name and rules as another.
- Retrieve all rules for a given production.
- Change the definition of an existing rule.
- Delete an existing rule.
- Add a new rule.
- Retrieve immediate right sets.

;============================================================
;=======================================================<doc>

;defn remove-left-recursion (grammar:GRules, lprod:GProduction, atom:GProduction) -> GRules :
;  ;Compute grammar properties
;  val props = analyze-grammar-properties(grammar, lprod)
;
;  ;Create transformer
;  val gt = GrammarTransformer(grammar)
;
;  ;Collect all modifications
;  val mods = Vector<GrammarMod>()
;  defn modify (m:GrammarMod) :
;    add(mods, m)
;
;  ;Table holding left-recursive versions of productions.
;  val left-replacement-table = IntTable<GProduction>()
;  ;Returns the version of p where left-occurrences of lprod has been replaced
;  ;with atom.
;  defn left-replaced (p:GProduction) -> GProduction :
;    set?(left-replacement-table, id(p), fn () :
;      fresh-production(gt))
;
;  ;Operation: Return the given rule with left-occurrences of lprod replaced
;  ;with atom.
;  defn replace-left-occurrence (rule-index:Int, rule:GTokenRule) -> GTokenRule :
;    val left-tokens = first-tokens(props)[rule-index]
;    if contains?(left-tokens, lprod) :
;      val p0 = tokens(rule)[0] as GProduction
;      val tokens* = sub-item(tokens(rule), 0, left-replaced(p0))
;      sub-tokens(rule, tokens*)
;    else : rule
;
;  fatal("Not yet implemented")
  

;;Process the grammar such that the left-right-recursive prod
;;is eliminated.
;defn remove-left-right-recursion (gt:GrammarTransformer, prod:GProduction) :
;  ;Grammar properties
;  val props = analyze-grammar-properties(grammar(gt), prod)
;  
;  ;Collect all modifications
;  val mods = Vector<GrammarMod>()
;  defn modify (m:GrammarMod) :
;    add(mods, m)
;  defn commit-modification () :
;    val mod = GrammarModification(to-tuple(mods))
;    clear(mods)
;    /modify(gt,mod)
;
;  ;Create atom production
;  val atom = fresh-production(gt)
;  modify $ CloneProduction(atom, prod)
;
;  ;Retrieve the operator type of the rule.
;  defn optype (r:GTokenRule) -> OperatorType|False :
;    val params = params(r) as TokenRuleParams
;    operator-type(params)
;
;  ;Substitute the operator type in the given rule.
;  defn sub-optype (r:GTokenRule, optype:OperatorType|False) -> GTokenRule :
;    val params = params(r) as TokenRuleParams
;    val params* = sub-operator-type(params, optype)
;    sub-params(r, params*) as GTokenRule
;
;  ;Combine an existing optype (either Postfix or false) with a Prefix.
;  defn combine (a:OperatorType|False, b:Prefix) -> OperatorType :
;    match(a) :
;      (a:Postfix) : Binary(id(a), id(b))
;      (a:False) : b
;
;  ;Main Pass: Replace left occurrences with atom.
;  defn replace-left-occurrences-with-atom () :
;    ;Table holding left-recursive versions of productions.
;    val left-replacement-table = IntTable<GProduction>()
;    defn left-replaced (p:GProduction) -> GProduction :
;      set?(left-replacement-table, id(p), fn () :
;        fresh-production(gt))
;
;    ;Operation: Replace left occurrence of prod with atom in the given rule.
;    ;Returns false if rule is unchanged from before.
;    defn replace-left-occurrence (rule:GTokenRule) -> GTokenRule|False :
;      val t0 =
;        if tokens(rule)[0] == prod :
;          atom
;        else if tokens(rule)[0] is GProduction :
;          replaced-left-occurrence(tokens(rule)[0] as GProduction)
;      match(t0:GProduction) :
;        val tokens* = sub-item(tokens(rule), 0, t0)
;        sub-tokens(rule, tokens*)
;        
;    ;Operation: Perform modifications to grammar to replace
;    ;left occurrences of prod with atom in all rules for the given
;    ;production.
;    defn replace-left-occurrence! (p:GProduction) -> False :
;      for entry in rules(gt, p) do :
;        val rule* = replace-left-occurrence(rule(entry))
;        match(rule*:GTokenRule) :
;          modify $ SubstituteRule(id(entry), rule*)
;          
;    ;Operation: Return the version of prod where prod has been replaced with atom.
;    ;Returns false if production is unchanged.
;    defn replaced-left-occurrence (p:GProduction) -> GProduction|False :
;      val left-set = left-sets(props)[id(p)]
;      if contains?(left-set, prod) :
;        ;Retrieve production representing replaced version.
;        val [p*, new?] =
;          if key?(left-replacement-table, id(p)) :
;            [left-replacement-table[id(p)] as GProduction, false]
;          else :
;            [fresh-production(gt), true]
;        ;Save in table.
;        left-replacement-table[id(p)] = p*
;        ;Create replaced rules if required.
;        if new? :
;          modify $ CloneProduction(p* as GProduction, p)
;          for entry in rules(gt, p) do :
;            val rule* = match(replace-left-occurrence(rule(entry))) :
;              (rule*:GTokenRule) : rule*
;              (f:False) : rule(entry)
;            modify $ AddRule(sub-id(rule*, id(p*)) as GTokenRule)
;        ;Return replaced version
;        p*
;
;    ;Launch!
;    for entry in rules(gt, prod) do :
;      match(replace-left-occurrence(rule(entry))) :
;       (rule*:GTokenRule) :
;         val optype* = Postfix(id(atom))
;         val rule** = sub-optype(rule*, optype*)
;         modify $ SubstituteRule(id(entry), rule**)
;       (f:False) :
;         false
;
;  ;Main Pass: Move non-right-recursive rules to the atom production.
;  defn move-non-right-recursive-rules-to-atom () :
;    ;Tables for keeping track of whether a production has been duplicated.
;    ;An rr-table entry, P => P*, means that P* is the version of production P stripped
;    ;to only contain right-recursive rules.
;    ;An nr-table entry, P => P*, means that P* is the version of production P stripped
;    ;to not contain any right-recursive rules.
;    val rr-table = IntTable<GProduction>()
;    val nr-table = IntTable<GProduction>()
;
;    ;Helper: Request a clone of the given production p using the given table.
;    defn clone (table:IntTable<GProduction>, p:GProduction) -> GProduction :
;      set?(table, id(p), fresh-production{gt})
;
;    ;Operation: Classify the right-recursion status of the given production.
;    defn rr-status (p:GProduction) -> RRStatus :
;      if p == prod :
;        RR
;      else :
;        val right-set = right-sets(props)[id(p)]
;        if contains?(right-set, prod) :
;          if any?({_ is GTerminal}, right-set) : RR+NR
;          else : RR
;        else : NR
;
;    ;Operation: Classify the right-recursion status of the given rule.
;    defn rr-status (r:GTokenRule) -> RRStatus :
;      match(last-token(r)) :
;        (tn:GTerminal) : NR
;        (tn:GProduction) : rr-status(tn)
;
;    ;Operation: Replace all the productions in the same strongly-connected component
;    ;in the given rule with the substitutions in the given table.
;    defn replace-components (rule:GTokenRule, table:IntTable<GProduction>) -> GTokenRule :
;      ;Create substitution table.
;      val subtable = IntTable<GProduction>()
;      defn add-sub (p:Int) : subtable[p] = table[p]
;      add-sub(id(rule))
;      for p in components(props)[id(rule)] do :
;        add-sub(id(p))
;      ;Compute substituted tokens and identifier
;      val tokens* = for t in tokens(rule) map :
;        match(t:GProduction) : get?(subtable, id(t), t)
;        else : t
;      val id* = id(subtable[id(rule)])
;      ;Replace tokens and identifier
;      sub-id(sub-tokens(rule, tokens*), id*) as GTokenRule
;
;    ;Returns true if progress has been made.
;    defn fill-rr (entry:KeyValue<Int, GProduction>) -> False :
;      ;Retrieve previous and new productions.
;      val p = GProduction(key(entry))
;      val p* = value(entry)
;      ;Clone the production
;      modify(CloneProduction(p*, p))
;      ;Ensure all productions in the same component are cloned.
;      do(clone{rr-table, _}, components(props)[id(p)])
;      ;Add the right-recursive rules        
;      for rule in seq(rule,rules(gt,p)) do :
;        switch(rr-status(rule)) :
;          ;Rule is not right-recursive. Do not copy over.
;          NR :
;            false
;          ;Rule is only right-recursive. Copy over after
;          ;replacing components.
;          RR :
;            modify(AddRule(replace-components(rule, rr-table)))
;          ;Rule is both right-recursive and not right-recursive.
;          ;Replace components, and process the last token
;          ;as well.
;          RR+NR :
;            val last-t* = clone(rr-table, last-token(rule) as GProduction)
;            val rule* = sub-last-token(replace-components(rule, rr-table), last-t*)
;            modify(AddRule(rule*))
;
;    ;Returns true if progress has been made.
;    defn fill-nr (entry:KeyValue<Int, GProduction>) -> False :
;      ;Retrieve previous and new productions.
;      val p = GProduction(key(entry))
;      val p* = value(entry)
;      ;Clone the production
;      modify(CloneProduction(p*, p))
;      ;Ensure all productions in the same component are cloned.
;      do(clone{nr-table, _}, components(props)[id(p)])
;      ;Add the right-recursive rules        
;      for rule in seq(rule,rules(gt,p)) do :
;        switch(rr-status(rule)) :
;          ;Rule is only right-recursive. Do not copy over.
;          RR :
;            false
;          ;Rule is not right-recursive. Copy over.
;          NR :
;            modify(AddRule(replace-components(rule, nr-table)))
;          ;Rule is both right-recursive and not right-recursive.
;          ;Replace components, and process the last token
;          ;as well.
;          RR+NR :
;            val last-t* = clone(nr-table, last-token(rule) as GProduction)
;            val rule* = sub-last-token(replace-components(rule, nr-table), last-t*)
;            modify(AddRule(rule*))
;
;    ;Call f on the entries in the table until no more
;    ;progress can be made.
;    defn fill (f:KeyValue<Int, GProduction> -> False,
;               table:IntTable<GProduction>) :
;      val processed = IntSet()         
;      let loop () :
;        var progress = false
;        for entry in to-tuple(table) do :
;          if add(processed, key(entry)) :
;            f(entry)
;            progress = true          
;        loop() when progress
;
;    ;Helper: Retrieve the last token in the rule.
;    defn last-token (rule:GTokenRule) -> GToken :
;      val n = length(tokens(rule))
;      tokens(rule)[n - 1]
;
;    ;Helper: Substitute the last token in the given rule.
;    defn sub-last-token (rule:GTokenRule, t:GToken) -> GTokenRule :
;      val n = length(tokens(rule))
;      val tokens* = sub-item(tokens(rule), n - 1, t)
;      sub-tokens(rule, tokens*) as GTokenRule
;
;    ;Helper: Return a new rule with the identifier and last token replaced. 
;    defn sub-id+last-token (rule:GTokenRule, id:Int, last-t:GToken) -> GTokenRule :
;      sub-id(sub-last-token(rule, last-t), id) as GTokenRule
;
;    ;Operation: Split a rule into separate right-recursive portion and non-right-recursive rules.
;    ;Keep 'prod' as the production for the right-recursive rule.
;    ;Use 'atom' as the production for the non-right-recursive rule.
;    defn move-right-recursive! (entry:RuleEntry) -> False :
;      switch(rr-status(rule(entry))) :
;        RR :
;          false
;        NR :
;          val nr-rule = sub-id(rule(entry), id(atom))
;          modify(DeleteRule(id(entry)))
;          modify(AddRule(nr-rule as GTokenRule))
;        RR+NR :
;          val tokens = tokens(rule(entry))
;          val num-tokens = length(tokens)
;          val last-t = tokens[num-tokens - 1] as GProduction
;          val rr-rule = sub-last-token(rule(entry), clone(rr-table, last-t))
;          val nr-rule = sub-id+last-token(rule(entry), id(atom), clone(nr-table, last-t))
;          modify(SubstituteRule(id(entry), rr-rule))
;          modify(AddRule(nr-rule))
;
;    ;Launch!
;    do(move-right-recursive!, rules(gt,prod))
;    fill(fill-rr, rr-table)
;    fill(fill-nr, nr-table)
;
;  ;Main Pass: Add inherit atom rule
;  defn add-inherit-atom-rule () :
;    modify(AddRule(GTokenRule(id(prod), [atom], InheritParams())))
;
;  fatal("Not yet implemented")
;  ;println("Remove Left-Right-Recursive Production: %_" % [prod])
;  ;println("Use atom %_" % [atom])
;  ;replace-left-occurrences-with-atom()
;  ;commit-modification()
;  ;println("Replaced Left Occurrences:")
;  ;println(grammar(gt))
;  ;;recalculate-grammar-properties()
;  ;move-non-right-recursive-rules-to-atom()
;  ;add-inherit-atom-rule()
;  ;commit-modification()
;  ;println("Moved Non Right Recursive Rules:")
;  ;println(grammar(gt))
;
;defn remove-left-right-recursion (grammar:GRules) -> GRules :
;  ;Create grammar transformer
;  val gt = GrammarTransformer(grammar)
;
;  ;Remove all left-right-recursive productions one-at-a-time.
;  let loop (grammar:GRules = grammar) :
;    ;Get properties
;    val props = analyze-grammar-properties(grammar, false)
;
;    ;Discover all left-right-recursive-rules
;    defn left-recursive? (prod:GProduction) -> True|False :
;      contains?(left-sets(props)[id(prod)], prod)
;    defn right-recursive? (prod:GProduction) -> True|False :
;      contains?(right-sets(props)[id(prod)], prod)
;    defn left-right-recursive? (prod:GProduction) -> True|False :
;      left-recursive?(prod) and right-recursive?(prod)
;
;    ;Find a left-right-recursive production and eliminate it.
;    val prods = seq(GProduction{id(_)}, productions(grammar))
;    val lrprod = find(left-right-recursive?, prods)
;
;    ;If there is a left-right-recursive production
;    ;then remove it, and do another iteration.
;    ;Otherwise return the final grammar.
;    match(lrprod:GProduction) :
;      remove-left-right-recursion(gt, lrprod)
;      loop(/grammar(gt))
;    else :
;      grammar  

;Represents the right-recursion status of a production.
;Productions can be:
;- Only right recursive (RR). All rules for production end with 'lr-prod'.
;- Not right recursive (NR). No rules for production end with 'lr-prod'.
;- Both right recursive and not right recursive (RR+NR). Some rules
;  for production end with 'lr-prod'.
defenum RRStatus :
  RR
  NR
  RR+NR

;Substitute entry in tuple
defn sub-item<?T> (xs:Tuple<?T>, index:Int, item:T) :
  to-tuple $ for (x in xs, i in 0 to false) seq :
    if i == index : item
    else : x

;============================================================
;================== Dispatch Sets ===========================
;============================================================

defstruct DispatchSet :
  all-rules:ProductionTable<List<Int>>
  null-rules:ProductionTable<List<Int>>
  any-rules:ProductionTable<List<Int>>
  list-end-rules:ProductionTable<List<Int>>
  prim-rules:Array<ProductionTable<List<Int>>>
  list-rules:ProductionTable<List<Int>>
  keyword-rules:HashTable<[Int,Symbol],List<Int>>

defn analyze-dispatch-sets (grammar:GRules,
                            props:GrammarProperties,
                            prediction-set:GrammarProperties -> Tuple<Tuple<GTerminal>>) :
  ;Create rule sets
  val nprods = num-productions(grammar)
  val all-rules = ProductionTable<List<Int>>(nprods, List())
  val null-rules = ProductionTable<List<Int>>(nprods, List())
  val any-rules = ProductionTable<List<Int>>(nprods, List())
  val list-end-rules = ProductionTable<List<Int>>(nprods, List())
  val prim-rules = Array<ProductionTable<List<Int>>>(GPrimType-length)
  for i in 0 to length(prim-rules) do :
    prim-rules[i] = ProductionTable<List<Int>>(nprods, List())
  val list-rules = ProductionTable<List<Int>>(nprods, List())
  val keyword-rules = HashTable<[Int,Symbol],List<Int>>(List())

  ;Add to rule sets
  for (rule in rules(grammar), rule-index in 0 to false, pset in prediction-set(props)) do :
    defn add-to-set (table:ProductionTable<List<Int>>) :
      add(table, prod(rule), rule-index)
    add-to-set(all-rules)
    if nullable-rules(props)[rule-index] :
      add-to-set(null-rules)
    for token in pset do :
      let loop (token:GTerminal = token) :
        match(token) :
          (token:GAny|GListRest) : add-to-set(any-rules)
          (token:GListEnd) : add-to-set(list-end-rules)
          (token:GPrimToken) : add-to-set(prim-rules[to-int(type(token))])
          (token:GListStart) : add-to-set(list-rules)
          (token:GKeyword) : add(keyword-rules, [prod(rule), item(token)], rule-index)
          (token:GMatcherToken) : loop(terminal(token))

  ;Ensure subtraction relationships of sets
  val set-buffer = IntSet()
  defn minus (a:Seqable<Int>, b:Seqable<Int>) :
    add-all(set-buffer, b)
    val result = to-list $ filter({not set-buffer[_]}, a)
    clear(set-buffer)
    result
  defn subtract-map! (atable:ProductionTable<List<Int>>,
                      btables:Collection<ProductionTable<List<Int>>>) :
    for entry in atable map! :
      val prod = key(entry)
      val bset = seq-cat({_[prod]}, btables)
      value(entry) - bset
  defn subtract-map! (atable:HashTable<[Int,Symbol],List<Int>>,
                      btables:Collection<ProductionTable<List<Int>>>) :
    for entry in atable map! :
      val [prod, _] = key(entry)
      val bset = seq-cat({_[prod]}, btables)
      value(entry) - bset
  subtract-map!(keyword-rules, [prim-rules[to-int(GSymbolType)], any-rules, null-rules])
  for prim-i-rules in prim-rules do :
    subtract-map!(prim-i-rules, [any-rules, null-rules])
  subtract-map!(list-rules, [any-rules, null-rules])
  subtract-map!(list-end-rules, [null-rules])
  subtract-map!(any-rules, [null-rules])

  ;Return computed dispatch sets
  DispatchSet(
    all-rules
    null-rules
    any-rules
    list-end-rules
    prim-rules
    list-rules
    keyword-rules)

;============================================================
;================- Negation Set Analysis ====================
;============================================================

deftype KSet
defstruct KeywordSet <: KSet :
  keywords: Tuple<Symbol>
with:
  printer => true

defstruct ProdSet <: KSet :
  name: Symbol
with:
  printer => true

defstruct UnionSet <: KSet :
  sets: Tuple<KSet>
with:
  printer => true

defstruct MinusSet <: KSet :
  a: KSet
  b: KSet
with:
  printer => true

;<comment>
defn convert-negation-rules (rules:Tuple<GRule>) -> Tuple<GMatcherRule|GTokenRule> :
  ;Gather positive and negative tokens
  val negative-table = HashTable<Symbol,List<GToken>>(List())
  val positive-table = HashTable<Symbol,List<GToken>>(List())
  for rule in rules do :
    match(rule) :
      (rule:GNegationRule) :
        add(negative-table, name(rule), token(rule))
      (rule:GTokenRule) :
        if length(tokens(rule)) == 1 :
          val t = tokens(rule)[0]
          add(positive-table, name(rule), t)
      (rule:GMatcherRule) :
        false

  ;Create initial kset table
  val kset-table = HashTable<Symbol,KSet>()
  defn to-kset (name:Symbol) :
    set?(kset-table, name, fn () :
      val psets = to-tuple $ seq(to-kset, positive-table[name])
      val nsets = to-tuple $ seq(to-kset, negative-table[name])
      MinusSet(UnionSet(psets), UnionSet(nsets)))
  defn to-kset (t:GToken) :
    match(t) :
      (t:GProduction) : to-kset(name(t))
      (t:GKeyword) : KeywordSet([item(t)])

  ;Simplify kset
  val simplified-kset-table = HashTable<Symbol,KeywordSet>()
  defn simplify (name:Symbol) :
    set?(simplified-kset-table, name, fn () :
      simplify(to-kset(name)))
  defn simplify (kset:KSet) -> KeywordSet :
    match(kset) :
      (kset:UnionSet) :
        val keywords = seq-cat(keywords{simplify(_)}, sets(kset))
        KeywordSet $ to-tuple $ to-hashset<Symbol>(keywords)
      (kset:MinusSet) :
        val symbols = to-hashset<Symbol>(keywords(simplify(a(kset))))
        do(remove{symbols, _}, keywords(simplify(b(kset))))
        KeywordSet $ to-tuple $ symbols
      (kset:KeywordSet) :
        kset
      (kset:ProdSet) :
        simplify(name(kset))

  ;Compute keywords to subtract from each production
  val subtract-keyword-table = HashTable<Symbol,HashSet<Symbol>>()
  defn subtract-keywords (prod:Symbol) :
    set?(subtract-keyword-table, prod, fn () :
      to-hashset<Symbol> $
        for t in negative-table[prod] seq-cat :
          keywords(simplify(to-kset(t))))

  ;Update matcher rules
  defn update-rule (r:GRule) :
    if key?(negative-table, name(r)) :
      match(r) :
        (r:GMatcherRule) :
        (r:GTokenRule) :
          fatal("Illegal rule with negation.") when length(tokens(r)) != 1
          fatal("Illegal rule with negation.") when lazy-action?(r)
          val terminal = tokens(r)[0] as GTerminal
          GMatcherRule(name(r), terminal, matcher, action(r))
    else : r

  ;Create matcher rule
  defn to-matcher-rules (prod:Symbol) :
    val neg-tokens = negative-table[prod]
    val keywords = seq-cat(keywords{simplify(to-kset(_))}, neg-tokens)
    val keyword-set = to-hashset<Symbol>(keywords)
    defn match? (form) :
      match(unwrap-token(form)) :
        (s:Symbol) : not keyword-set[s]
        (s) : true
    val new-rules = Vector<GRule>()
    val old-prod = gensym(prod)
    add(new-rules, GMatcherRule(prod, [GProduction(old-prod)], match?, fn (result) : result[0]))
    for r in rules do :
      if name(r) == prod and r is-not GNegationRule :
        add(new-rules, sub-name(r, old-prod))
    new-rules

  ;Create matcher rules
  val matcher-rules = seq-cat(to-matcher-rules, keys(negative-table))
  defn standard-rule? (r:GRule) : not key?(negative-table, name(r))
  val remaining-rules = filter(standard-rule?, rules[1 to false])
  val new-rules = to-tuple $ cat-all $ [
    [rules[0]]
     matcher-rules
     remaining-rules]
  new-rules as Tuple<GMatcherRule|GTokenRule>
;<comment>

;============================================================
;================= Create Matcher Tokens ====================
;============================================================

defn create-matcher-tokens (grules:GRules) -> [GRules, Tuple<(? -> True|False)>] :
  val matchers = Vector<(? -> True|False)>()
  defn get-id (m:? -> True|False) :
    add(matchers, m)
    length(matchers) - 1
  val rules* = for r in rules(grules) map :
    match(r) :
      (r:GMatcherRule) :
        val token = GMatcherToken(token(r), get-id(matcher(r)))
        GTokenRule(prod(r), [token], TokenRuleParams(action(r), false), order(r))
      (r:GTokenRule) :
        r
  val grules* = GRules(productions(grules), rules*)
  [grules*, to-tuple(matchers)]

;============================================================
;==================== Order Rules ===========================
;============================================================
defn order-rules (grules:GRules) -> GRules :
  val rules* = to-tuple(seq(sub-order, rules(grules), 0 to false))
  GRules(productions(grules), rules*)

;============================================================
;======================== Utilities =========================
;============================================================

defn add-all<?T> (q:Queue<?T>, xs:Seqable<T>) :
  do(add{q, _}, xs)

defn add<?K,?V> (table:Table<?K,List<?V>>, k:K, v:V) :
  update(table, cons{v, _,}, k)