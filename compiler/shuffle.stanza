defpackage stz/shuffle :
  import core
  import collections
  import stz/utils
  import stz/cycles

;<doc>=======================================================
;================ Register Shuffling ========================
;============================================================

# Interesting Properties about the Problem #

- All Regs have maximum one incoming arrow.
  Otherwise, it means that it needs to take on multiple
  values.

- A Reg *can* have more than one outgoing arrow.
  This means that the register should send its value
  to multiple places.

- A Reg can have a single arrow pointing to itself.
  This means that its value should stay put, and
  it is not okay to overwrite it.

- A Reg can have no incoming arrows.
  This means that there is no restriction on what
  it contains after the shuffling is completed.

- A Reg with no outgoing arrows means that
  it doesn't need to send its value anywhere.
  Therefore, it can be used as a scratch register
  in the beginning.

# Strategy #

1) First perform all Reg to Mem moves.

   These don't consume any registers, and may free up
   some registers so that they can be used as swap.

2) Now either find or create a swap register.

   If there are any Regs without outgoing arrows, then
   they are free to be a swap register.

   Otherwise, save an arbitrary register. Then use that
   register as the swap.

3) Now use the swap register to perform all
   Mem to Mem moves, just to get them out of the way.

4) Next, perform all the Reg to Reg moves.

   First handle all the cycles. These cycles are guaranteed
   not to contain the swap register.

   Next handle all the chains.

   Finally handle the swap register.

;============================================================
;=======================================================<doc>

;============================================================
;====================== API =================================
;============================================================

;Represents the location where a value is stored.
public deftype Loc

;Represents a register.
public defstruct Reg <: Loc :
  index:Int

;Represents some arbitrary memory (or non-register) location.
public defstruct Mem <: Loc

;Represents an action handled by the shuffling engine.
public deftype Ins

;Represents a move from a src to a dst location.
;The id identifies which move this is.
;If id is false, it means that it is an additional move
;generated by the shuffling engine and does not correspond
;to one of the original moves.
public defstruct Move <: Ins :
  id
  src: Loc
  dst: Loc

;Represents storing a register in a safe place because
;we don't have any appropriate swap registers and one is
;needed.
public defstruct SaveSwap <: Ins :
  reg: Reg

;Represents restoring a previously-saved register value
;into the given register. Note that the given register
;may not be the same as the register that was saved.
public defstruct RestoreSwap <: Ins :
  reg: Reg

;Represents performing one of the original Mem to Mem
;moves using the given temporary register.
public defstruct MoveUsingTmp <: Ins :
  id
  reg: Reg

;Represents the complete shuffling problem.
public defstruct ShuffleProblem :
  all-regs: Tuple<Reg>
  moves: Tuple<Move>

;============================================================
;======================== Printer ===========================
;============================================================

defmethod print (o:OutputStream, m:Move) :
  val id-str = "" when id(m) is False
          else " (%_)" % [id(m)]
  print(o, "mov %_ to %_%_" % [src(m), dst(m), id-str])

defmethod print (o:OutputStream, s:SaveSwap) :
  print(o, "save %_ to swap" % [reg(s)])

defmethod print (o:OutputStream, r:RestoreSwap) :
  print(o, "restore swap to %_" % [reg(r)])

defmethod print (o:OutputStream, m:MoveUsingTmp) :
  print(o, "mov using swap %_ (%_)" % [reg(m), id(m)])

defmethod print (o:OutputStream, r:Reg) :
  print(o, "R%_" % [index(r)])

defmethod print (o:OutputStream, m:Mem) :
  print(o, "M")

defmethod print (o:OutputStream, p:ShuffleProblem) :
  val o2 = IndentedStream(o)
  print(o, "ShuffleProblem :")
  lnprint(o2, "regs: %," % [all-regs(p)])
  do(lnprint{o2, _}, moves(p))

;============================================================
;================== Internal Structures =====================
;============================================================

defstruct IndexedMove : (index:Int, move:Move)  
defn id (m:IndexedMove) : id(move(m))
defn src (m:IndexedMove) : src(move(m))
defn dst (m:IndexedMove) : dst(move(m))

;============================================================
;====================== Algorithm ===========================
;============================================================

public defn shuffle (prob:ShuffleProblem) -> Vector<Ins> :
  ;Track all the movements to make.
  val accum = Vector<Ins>()

  ;Track all the outgoing reg-to-reg moves.
  ;Each entry, index => moves, means that moves is the list
  ;of all outgoing reg-to-reg moves for register 'index'.
  val outgoing-arrows-table = IntListTable<IndexedMove>()

  ;Return all the outgoing moves for the given register.
  defn outgoing-arrows (r:Reg) -> List<IndexedMove> :
    outgoing-arrows-table[index(r)]

  ;Perform all the reg-to-mem moves in the problem.
  defn perform-reg-to-mem-moves () -> False :
    for m in moves(prob) do :
      match(src(m):Reg, dst(m):Mem) :
        add(accum, m)

  ;Compute the entries of 'outgoing-arrows'.
  defn compute-arrows () -> False :
    for (m in moves(prob), i in 0 to false) do :
      match(src(m):Reg, dst(m):Reg) :
        val src-index = index(src(m) as Reg)
        add(outgoing-arrows-table, src-index, IndexedMove(i,m))

  ;Find an appropriate swap register.
  defn find-swap-register () -> Reg :
    ;Try to find a register with no outgoing arrows.
    val swap = find(empty?{outgoing-arrows(_)}, all-regs(prob))
    ;If there is one, then we're done
    match(swap:Reg) :
      swap
    ;If there isn't one, then we need to
    ;save an arbitrary register and use it as the
    ;swap.
    else :
      val swap = all-regs(prob)[0]
      add(accum, SaveSwap(swap))
      swap

  ;Perform all the mem-to-mem moves with the given
  ;swap register.
  defn perform-mem-to-mem-moves (swap:Reg) -> False :
    for m in moves(prob) do :
      match(src(m):Mem, dst(m):Mem) :
        add(accum, MoveUsingTmp(id(m), swap))

  ;Find all the reg cycles that need to be implemented
  ;using the swap register.
  ;Note that the swap register is needed because
  ;it needs to be saved/restored specially and doesn't
  ;contribute to any cycles.
  defn find-cycles (swap:Reg) -> Seqable<Tuple<IndexedMove>> :
    ;Use detect-cycles algorithm to find the reg-reg cycles.
    val cycles = detect-cycles(vertices, get-edges) where :
      val vertices = map(index, all-regs(prob))
      defn get-edges (v:Int) -> Seqable<Edge> :
        if v == index(swap) :
          []
        else :
          for mov in outgoing-arrows-table[v] seq :
            val src-index = index(src(mov) as Reg)
            val dst-index = index(dst(mov) as Reg)
            Edge(mov, src-index, dst-index)
    ;Return the cycles.
    to-tuple $ for cycle in cycles seq :
      map({id(_) as IndexedMove}, cycle)

  ;Perform all the reg-to-reg moves.
  ;The swap register is needed because it is handled specially.
  ;We use Restore to handle moves involving the swap register.
  defn perform-reg-to-reg-moves (swap:Reg) -> False :
    ;Track which moves have been handled.
    val handled = IntSet()
    defn mark-as-handled (m:IndexedMove) :
      add(handled, index(m))
    defn handled? (m:IndexedMove) -> True|False :
      handled[index(m)]

    ;Track where registers are put.
    ;This is used to track new positions of registers in
    ;cycles only.
    val new-pos = IntTable<Reg>()
    defn set-new-pos (r:Reg, r2:Reg) :
      new-pos[index(r)] = r2
    defn get-new-pos (r:Reg) -> Reg :
      match(get?(new-pos, index(r))) :
        (r:Reg) : r
        (f:False) : r      

    ;Emit moves to implement cycle.
    ;Example for cycle: AB, BC, CD, DA
    ;  save A in X
    ;  mov D to A
    ;  mov C to D
    ;  mov B to C
    ;  mov X to B
    defn handle-cycle (cycle:Tuple<IndexedMove>) :
      ;Emit the moves to shuffle the cycle.
      val mov0 = cycle[0]
      add(accum, Move(false, src(mov0), swap))
      for i in reverse(1 to length(cycle)) do :
        add(accum, move(cycle[i]))
      add(accum, Move(id(mov0), swap, dst(mov0)))
      do(mark-as-handled, cycle)
      
      ;Track the new positions of these registers.
      for mov in cycle do :
        set-new-pos(src(mov) as Reg, dst(mov) as Reg)

    ;Emit moves to implement moving the
    ;given reg to all the destinations it
    ;should go to.
    defn handle-moves-from-reg (r:Reg) :
      if index(r) != index(swap) :
        for mov in outgoing-arrows(r) do :
          if not handled?(mov) :
            handle-moves-from-reg(dst(mov) as Reg)
            add(accum, Move(id(mov), get-new-pos(src(mov) as Reg), dst(mov)))
            mark-as-handled(mov)

    ;Emit moves from the swap register specifically.
    defn handle-moves-from-swap () :
      for mov in outgoing-arrows(swap) do :
        add(accum, RestoreSwap(dst(mov) as Reg))
        add(accum, Move(id(mov), dst(mov), dst(mov)))
        mark-as-handled(mov)

    ;Launch!
    do(handle-cycle, find-cycles(swap))
    do(handle-moves-from-reg, all-regs(prob))
    handle-moves-from-swap()
    false

  ;Perform all the mem-to-reg moves.
  defn perform-mem-to-reg-moves () -> False :
    for m in moves(prob) do :
      match(src(m):Mem, dst(m):Reg) :
        add(accum, m)

  ;Driver of overall algorithm.
  defn driver () :
    compute-arrows()
    perform-reg-to-mem-moves()
    val swap = find-swap-register()
    perform-mem-to-mem-moves(swap)
    perform-reg-to-reg-moves(swap)
    perform-mem-to-reg-moves()
    accum
    
  ;Launch!
  driver()