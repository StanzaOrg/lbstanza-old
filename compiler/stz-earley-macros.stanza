defpackage stz/earley-macros :
  import core
  import collections
  import parser with:
    prefix(parse-pattern) => parse-
  import macro-utils
  import stz/core-macros
  import stz/earley-lang
  import stz/earley-syntax-package-rules

;============================================================
;===================== User Syntax ==========================
;============================================================

public defstruct SPUPackage :
  name
  exps: List<SPUExp>
with:
  printer => true

public deftype SPUExp

public defstruct SPUDefProduction <: SPUExp :
  info: FileInfo|False
  name
  public?: True|False
with:
  printer => true

public defstruct SPUDefKeywords <: SPUExp :
  info: FileInfo|False
  name
  public?: True|False
with:
  printer => true

public defstruct SPUDefClones <: SPUExp :
  info: FileInfo|False
  clones: List<SPUDefClone>
with:
  printer => true

public defstruct SPUDefClone <: SPUExp :
  info: FileInfo|False
  name
  clone-name
  public?: True|False
with:
  printer => true

public defstruct SPUNotRule <: SPUExp :
  info: FileInfo|False
  production
  pattern: List
with:
  printer => true

public defstruct SPUImport <: SPUExp :
  info: FileInfo|False
  names: List
  package
with:
  printer => true

public defstruct SPURuleExp <: SPUExp :
  info: FileInfo|False
  production
  pattern: List
  guard: Maybe
  body: Maybe
  options: Maybe<List<KeyValue>>
with:
  printer => true

public defstruct SPUStanzaExp <: SPUExp :
  form
with:
  printer => true

public defstruct MatchSyntax :
  base:Symbol
  overlays:List<Symbol>
  form
  clauses:List<MatchSyntaxClause>
with:
  printer => true
  
public defstruct MatchSyntaxClause :
  pattern:List
  body
with:
  printer => true

public defstruct ParseSyntax :
  base: Symbol
  overlays: List<Symbol>
  form
with:
  printer => true

;============================================================
;====================== Syntax ==============================
;============================================================

defsyntax stanza-earley :
  public defproduction syntax-package: SPUPackage
  public defproduction match-syntax-exp: MatchSyntax
  public defproduction parse-syntax-exp: ParseSyntax
  defproduction spuexp: SPUExp  
  import (exp!, id, id!, id$, :!, exp$) from core

  ;Match syntax declaration
  defrule match-syntax-exp = (match-syntax[?base:#id! ?overlays:#overlays!](?form:#exp$) #:! (
                                ?clauses:#match-clause! ...)) :
    MatchSyntax(unwrap-token(base), overlays, form, clauses)    

  defproduction match-clause!: MatchSyntaxClause
  defrule match-clause! = ((?pat ...) #:! ?e:#exp!) :
    MatchSyntaxClause(pat, e)
  fail-if match-clause! = () :
    EarleySyntaxError(closest-info(), "Invalix syntax for match-syntax clause.")

  ;Parse syntax declaration
  defrule parse-syntax-exp = (parse-syntax[?base:#id! ?overlays:#overlays ?pat:#slash-pattern!](?form:#exp$)) :
    ParseSyntax(unwrap-token(base), overlays, form)

  ;Overlays
  defproduction overlays:List<Symbol>
  defrule overlays = (+ (! /) ?names:#id ...) : map(unwrap-token, names)
  defrule overlays = () : List()

  ;Overlays!
  defproduction overlays!:List<Symbol>
  defrule overlays! = (+ ?names:#id! ...) : map(unwrap-token, names)
  defrule overlays! = () : List()

  ;Slash-Pattern
  defproduction slash-pattern!:List
  defrule slash-pattern! = (/ ?pat ...) : pat
  fail-if slash-pattern! = () : EarleySyntaxError(closest-info(), "Expected a slash here.")

  ;Syntax package declaration
  defrule syntax-package = (defsyntax ?name:#id! #:! (?exps:#spuexp ...)) :
    SPUPackage(name, exps)

  ;defproduction sexp = clone(exp)
  defrule spuexp = (?e:#defclone) :
    e

  defproduction defclone:SPUDefClone
  defrule defclone = (?public?:#public? defproduction ?name:#id! = clone(?clone-name:#id$)) :
    SPUDefClone(closest-info(), name, clone-name, public?)

  ;public defproduction myrule
  defrule spuexp = (?public?:#public? defproduction ?name:#id!) :
    SPUDefProduction(closest-info(), name, public?)

  ;defproductions :
  ;  defproduction sexp = clone(exp)
  defrule spuexp = (defproductions #:! (?clones:#defclone! ...)) :
    SPUDefClones(closest-info(), clones)

  ;public defkeywords stanza-keywords
  defrule spuexp = (?public?:#public? defkeywords ?name:#id!) :
    SPUDefKeywords(closest-info(), name, public?)

  ;defrule exp = (a b c) when symbol?(a) : body with: (associativity => left)
  defrule spuexp = (defrule ?name:#id! = ?pat:#pattern! ?guard:#guard? ?body:#body? ?options:#options?) :
    SPURuleExp(closest-info(), name, pat, guard, body, options)

  ;defrule stanza-keywords != (for)
  defrule spuexp = (defrule ?name:#id! != ?pat:#pattern!) :
    SPUNotRule(closest-info(), name, pat)

  ;import (exp) from core
  defrule spuexp = (import (?names:#id! ...) from ?package:#id!) :
    SPUImport(closest-info(), names, package)
  defrule spuexp = (import ?name:#id! from ?package:#id!) :
    SPUImport(closest-info(), List(name), package)

  ;Ordinary stanza expression
  defrule spuexp = (?e:#exp!) :
    SPUStanzaExp(e)

  ;Errors
  defproduction defclone!: SPUDefClone
  defrule defclone! = (?e:#defclone) : e
  fail-if defclone! = () : EarleySyntaxError(closest-info(), "Expected a clone production here.")

  ;Patterns
  defproduction pattern!: List
  defrule pattern! = (?x:(_ ...)) : x
  fail-if pattern! = () : EarleySyntaxError(closest-info(), "Expected a pattern here.")

  ;Guards
  defproduction guard?: Maybe
  defrule guard? = (when ?e:#exp!) : One(e)
  defrule guard? = () : None()

  ;Body
  defproduction body?: Maybe
  defrule body? = (: ?e:#exp!): One(e)
  defrule body? = () : None()

  ;Options
  defproduction options?: Maybe<List<KeyValue>>
  defrule options? = (with #:! (?es:#option! ...)) : One(es)
  defrule options? = () : None()

  ;Option
  defproduction option!: KeyValue
  defrule option! = (?x:associativity => ?y:left) : x => y
  defrule option! = (?x:associativity => ?y:right) : x => y
  fail-if option! = (associativity =>) : EarleySyntaxError(closest-info(), "Invalid associativity option.")
  defrule option! = (?x:priority => ?y:#int!) : x => y
  defrule option! = (?x:lazy => ?y:#bool!) : x => y

  ;Public or not
  defproduction public?: True|False
  defrule public? = (public) : true
  defrule public? = () : false

  ;Integers
  defproduction int!: Int|Token
  defrule int! = (?x) when unwrap-token(x) is Int : x
  fail-if int! = () : EarleySyntaxError(closest-info(), "Expected an integer here.")

  ;Booleans
  defproduction bool!: True|False|Token
  defrule bool! = (?x) when unwrap-token(x) is True|False : x
  fail-if bool! = () : EarleySyntaxError(closest-info(), "Expected a boolean here.")

defstruct EarleySyntaxError <: Exception :
  info: FileInfo|False
  msg: String

defmethod print (o:OutputStream, e:EarleySyntaxError) :
  val info-str = "" when info(e) is False
            else "%_: " % [info(e)]
  print(o, "%_%_" % [info-str, msg(e)])

;============================================================
;================= Qualified Definitions ====================
;============================================================

defn substitute-qualified (item) :
  val qualified-names = `(
    collections/add
    collections/Vector
    core/to-tuple
    core/FileInfo
    core/None
    core/One
    core/True
    core/False
    stz/earley-grammar/LeftAssociative
    stz/earley-grammar/RightAssociative
    stz/earley-grammar/NonAssociative
    stz/earley-lang/register-syntax-package
    stz/earley-lang/SyntaxPackage
    stz/earley-lang/SyntaxExp
    stz/earley-lang/ParsedBinders
    stz/earley-lang/DefProductionExp
    stz/earley-lang/DefKeywordsExp
    stz/earley-lang/DefProductionsExp
    stz/earley-lang/DefNotRuleExp
    stz/earley-lang/ImportExp
    stz/earley-lang/DefKeywordRuleExp
    stz/earley-lang/DefRuleExp
    stz/earley-lang/DefCloneExp
    stz/earley-lang/parse-pattern
    stz/earley-lang/syntax-match)
  val entries = Vector<KeyValue<Symbol,?>>()
  add(entries, `item => item)
  for full-name in qualified-names do :
    val [package, name] = qualifier(full-name)
    add(entries, name => deep(full-name))
  substitute(`item, entries)

;============================================================
;============= Compilation of Syntax Package ================
;============================================================

public defn compile (p:SPUPackage, core-form?:True|False) -> ? :
  val template = `(register-syntax-package(SyntaxPackage(`name, to-tuple(PACKAGE-EXPS))) where :
                     val PACKAGE-EXPS = Vector<SyntaxExp>()
                     exps)
  val filled = fill-template $ substitute-qualified $
    substitute(template, [
      `name => name(p)
      `exps => splice(map(compile, exps(p)))
      `PACKAGE-EXPS => deep(gensym(`PACKAGE-EXPS))])
  if core-form? : parse-syntax[core / #exp](filled)
  else : filled

defn compile (e:SPUExp) -> ? :
  match(e) :
    (e:SPUDefProduction) :
      val template = `(add(PACKAGE-EXPS, DefProductionExp(info, `name, public?)))
      substitute(template, [
        `info => fileinfo-object(info(e)),
        `name => name(e),
        `public? => public?(e)])
    (e:SPUDefKeywords) :
      val template = `(add(PACKAGE-EXPS, DefKeywordsExp(info, `name, public?)))
      substitute(template, [
        `info => fileinfo-object(info(e)),
        `name => name(e),
        `public? => public?(e)])
    (e:SPUDefClones) :
      val template = `(add(PACKAGE-EXPS, DefProductionsExp(info, [clones])))
      substitute(template, [
        `info => fileinfo-object(info(e))
        `clones => splice(map(compile-clone,clones(e)))])
    (e:SPUDefClone) :
      val template = `(add(PACKAGE-EXPS, clone))
      substitute(template, [
        `clone => compile-clone(e)])
    (e:SPUNotRule) :
      val template = `(add(PACKAGE-EXPS, DefNotRuleExp(info, `production, parse-pattern(`pattern))))
      substitute(template, [
        `info => fileinfo-object(info(e))
        `production => production(e)
        `pattern => pattern(e)])
    (e:SPUImport) :
      val template = `(names{add(PACKAGE-EXPS, ImportExp(info, `name, `package))})
      substitute(template, [
        `names => repeated $ [
          `name => names(e)]
        `info => info(e),
        `package => package(e)])
    (e:SPURuleExp) :
      if empty?(body(e)) :
        val template = `(add(PACKAGE-EXPS, DefKeywordRuleExp(info, `production, parse-pattern(`pattern))))
        substitute(template, [
          `info => fileinfo-object(info(e))
          `production => production(e),
          `pattern => pattern(e)])
      else :
        val [priority, associativity, lazy?] = compile-options(options(e))
        val template = `(add(PACKAGE-EXPS, DefRuleExp(info, `production, parse-pattern(`pattern),
                                                      guard, action, priority, associativity, lazy?)))
        substitute(template, [
          `info => fileinfo-object(info(e))
          `production => production(e)
          `pattern => pattern(e)
          `guard => compile-guard(pattern(e), guard(e))
          `action => compile-action(pattern(e), value!(body(e)), lazy?)
          `priority => priority,
          `associativity => associativity,
          `lazy? => lazy?])
    (e:SPUStanzaExp) :
      form(e)

defn compile-clone (e:SPUDefClone) :
  val template = `(DefCloneExp(info, `name, `prod, public?))
  substitute(template, [
    `info => fileinfo-object(info(e))
    `name => name(e)
    `prod => clone-name(e)
    `public? => public?(e)])

;Returns [priority, associativity, lazy?]
defn compile-options (opt:Maybe<List<KeyValue>>) -> [Int, ?, True|False] :
  var priority:Int = 100
  var associativity:? = substitute(`NonAssociative, [])
  var lazy?:True|False = false
  if not empty?(opt) :
    for entry in value!(opt) do :
      switch(unwrap-token(key(entry))) :
        `priority :
          priority = unwrap-token(value(entry))
        `associativity :
          switch(unwrap-token(value(entry))) :
            `left : associativity = substitute(`LeftAssociative, [])
            `right : associativity = substitute(`RightAssociative, [])
        `lazy? :
          lazy? = unwrap-token(value(entry))
  [priority, associativity, lazy?]

defn compile-guard (pattern:List, guard:Maybe) :
  if empty?(guard) :
    substitute(`(None()), [])
  else :
    val template = `(
      One(fn (binder:?) -> True|False : guard-body))
    substitute(template, [
      `binder => guard-binder(pattern)
      `guard-body => value!(guard)])

defn compile-action (pattern:List, body, lazy?:True|False) :
  val template = `(
    fn (parsed-binders:ParsedBinders) :
      binders{
        lazy?{
          defn binder () : stz/earley-lang/get(parsed-binders, `binder)
        }{
          val binder = stz/earley-lang/get(parsed-binders, `binder)
        }}
      body)
  substitute(template, [
    `parsed-binders => gensym(`parsed-binders)
    `lazy? => choice(lazy?)
    `binders => repeated $ [
      `binder => pattern-binders(pattern)]
    `body => body])

defn fileinfo-object (info:FileInfo|False) :
  match(info:FileInfo) :
    substitute(`(FileInfo(filename, line, column)), [
      `filename => filename(info)
      `line => line(info)
      `column => column(info)])

defn guard-binder (pattern:List) -> Symbol :
  match(parse-pattern(pattern)) :
    (b:Binder) : name(b)
    (p) : gensym(`binder)

defn pattern-binders (pattern:List) -> List<Symbol> :
  val binders = analyze-binders(parse-pattern(pattern))
  to-list(seq(name, binders))

;============================================================
;============ Compilation of Match Syntax ===================
;============================================================

public defn compile (e:MatchSyntax, core-form?:True|False) :
  val template = `(syntax-match(`base, `overlays,
                                [patterns{`pattern}],
                                [patterns{action}]))
  val filled = fill-template $ substitute-qualified $
    substitute(template, [
      `base => base(e),
      `overlays => overlays(e),
      `patterns => compile(clauses(e))])
  if core-form? : parse-syntax[core / #exp](filled)
  else : filled

defn compile (clauses:List<MatchSyntaxClause>) -> Nested :
  nested $ for e in clauses map :
    [`pattern => pattern(e),
     `action => compile-action(pattern(e), body(e), false)]

;============================================================
;================ Qualify Utility ===========================
;============================================================

