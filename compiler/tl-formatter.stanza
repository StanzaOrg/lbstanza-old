defpackage stz/tl-formatter :
  import core
  import collections
  import stz/types
  import stz/type-formatter
  import stz/tl-ir2
  import stz/printing-utils
  import stz/namemap

;============================================================
;======================= API ================================
;============================================================

;A type for formatting TL programs.
public deftype TLFormatter

;Format the given item in a human-readable way.
public defmulti format (f:TLFormatter, item:TLItem) -> ?

;============================================================
;=================== Convenience ============================
;============================================================

;Convenience: Create the formatter from the namemap in the program.
public defn TLFormatter (prog:TProg) :
  defn get-name (n:Int) -> Symbol :
    name(namemap(prog)[n])
  TLFormatter(get-name)

;Directly instantiate a formatter and format a prog.
public defn format (prog:TProg) :
  format(TLFormatter(prog), prog)

;============================================================
;====================== Constructor =========================
;============================================================

;Create the formatter given a way to retrieve a name.
public defn TLFormatter (get-name:Int -> Symbol) :

  ;Type formatter
  val type-formatter = TypeFormatter(get-name)

  ;Format a type
  defn ftype (t:Type) :
    format(type-formatter, t)

  ;Format a child declaration.
  defn fchild (c:Child) :
    val arg-str = "" when empty?(args(c))
             else "<%,>" % [seq(get-name,args(c))]
    "%_%_ <: %_" % [get-name(n(c)), arg-str, ftype(parent(c))]

  ;Format a command
  defn fcomm (c:TComm) :
    match(c) :
      ;Format a type declaration.
      (c:TDefType) :
        val name = get-name(n(c))
        val arg-str = "" when empty?(args(c))
                 else "<%,>" % [seq(get-name,args(c))]
        val parent-str = "" when parent(c) is False
                    else " <: %_" % [ftype(parent(c) as Type)]
        val child-str =
          if empty?(children(c)) :
            ""
          else :
            "%*" % for c in children(c) seq :
              Indented("\n_" % [fchild(c)])
        "deftype %_%_%_%_" % [name, arg-str, parent-str, child-str]
        
      ;Format a function definition.
      (c:TDefn) :
        val star? = "*" when tail?(c) else ""
        val name = get-name(n(c))
        val targ-parts = Vector<?>()
        for v in targs(c) do : add(targ-parts, get-name(v))
        for v in cargs(c) do : add(targ-parts, "?%_" % [get-name(v)])
        val targ-str = "" when empty?(targ-parts) else to-string("<%,>" % [targ-parts])
        defn arg-str (v:Int, t:Type|False) :
          match(t:Type) : "%_:%_" % [get-name(v), ftype(t)]
          else : "%_" % [get-name(v)]
        val arg-strs = seq(arg-str, args(c), a1(c))
        val ret-str = "" when a2(c) is False
                 else " -> %_" % [ftype(a2(c) as Type)]
        "defn%_ %_%_ (%,)%_ :\n%_" % [star?, name, targ-str, arg-strs,
                                      ret-str, Indented(fexp(body(c)))]

      (c) :
        c

  ;Format an expression.
  defn fexp (e:TExp) :
    e
        
  ;Return the formatter.
  new TLFormatter :
    defmethod format (this, item:TLItem) :
      match(item) :
        (item:TComm) : fcomm(item)
        (item) : item

;============================================================
;====================== Other Formatting ====================
;============================================================

public defn format (f:TLFormatter, p:TPackage) :
  val fcomms = seq(format{f, _}, comms(p))
  val items = [
    packageio(p)
    inline-fields(fcomms)]
  "TPackage%_" % [colon-field-list(items)]

public defn format (f:TLFormatter, p:TProg) :
  val fpackages = seq(format{f, _}, packages(p))
  val items = [
    hierarchy(p)
    inline-fields(fpackages)
    namemap(p)]
  "TProg%_" % [colon-field-list(items)]