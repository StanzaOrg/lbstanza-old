defpackage lang/check :
   import core
   import verse
   import stz/il-ir

public defstruct SymType :
   check: IExp -> False
public defstruct RestType :
   check: IExp -> False
public defstruct ListType :
   form:IExp
   pos:String
   types: Tuple<SymType|RestType>

val check-errors = Vector<?>()

public defn error! (info:FileInfo, msg) :
   add(check-errors, "~: ~" << [info, msg])

public defn check (es:List<IExp>, t:ListType) :
   defn ensure-arity (xs:List, n:Int) :
      if length(xs) != n :
         error!(info(form(t)), "Form ~ requires ~ expressions in the ~ position, but received ~." << [
            form(t), n, pos(t), length(xs)])

   defn ensure-min-arity (xs:List, n:Int) :
      if n > 0 and length(xs) < n :
         error!(info(form(t)), "Form ~ requires minimum ~ expressions in the ~ position, but received ~." << [
            form(t), n, pos(t), length(xs)])

   defn sublists (xs:List) :
      generate<List> :
         defn* loop (xs:List) :
            yield(xs)
            loop(tail(xs)) when not empty?(xs)
         loop(xs)   

   val n = length(types(t))
   if any?({_ typeof RestType}, types(t)) :
      ensure-min-arity(es, n - 1)
   else :
      ensure-arity(es, n)

   for (t in types(t), es in sublists(es)) do :
      match(t) :
         (t:SymType) : check(t)(head(es))         
         (t:RestType) : do(check(t), es)

public defn check (e:IExp, t:SymType) :
   check(t)(e)

public defn invalid-form (description:String, form:IExp) :
   error!(info(form), "Invalid syntax. Expected a ~ in this position but received ~." << [
      description, form])

public defn run-check (f: IExp -> False, e:IExp) :
   clear(check-errors)
   f(e)
   if not empty?(check-errors) :
      do(println, check-errors)
      throw(CheckError())
  
defstruct CheckError <: Exception