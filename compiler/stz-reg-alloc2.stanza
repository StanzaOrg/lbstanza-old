;See License.txt for details about licensing.

defpackage stz/reg-alloc :
  import core
  import collections with :
    prefix(Set) => collections-
  import stz/algorithms
  import stz/backend
  import stz/padder
  import stz/vm-ir
  import stz/basic-ops
  import stz/typeset
  import stz/asm-ir with :
    prefix => asm-
  import stz/vm-normalize with :
    prefix(CallType, StanzaCall, StanzaTCall, CCall, YieldCall) => vm-
  import stz/utils
  import stz/codegen

;============================================================
;===================== Driver ===============================
;============================================================

public defn allocate-registers (ins:VMFunction, emitter:CodeEmitter, backend:Backend, stubs:AsmStubs) -> False :
  println("Allocating")
  println(ins)
  take-ids(ins)

  val print? = true
  
  ;if flag-defined?(`PRINT-REG-ALLOC) :
  ;  println("==== Input ====")
  ;  do(println, ins)

  load-instructions(ins as VMFunc)
  if print? :
    println("==== Load Instructions ====")
    print-prog()
  ;
  ;normalize(backend)
  ;if flag-defined?(`PRINT-REG-ALLOC):
  ;  println("==== Normalize ====")
  ;  print-prog()
  ;
  remove-critical-edges()
  ;if print? :
  ;  println("==== Remove Critical Edges ====")
  ;  print-prog() 
  
  reverse-post-order()
  ;if print? :
  ;  println("==== Reverse Post Order ====")
  ;  print-prog()
  
  compute-predecessors()
  liveness-analysis()
  add-annotations()
  ;if print? :
  ;  println("==== Added Annotations ====")
  ;  print-prog()
  
  allocate-classes(backend)
  ;if print? :
  ;  println("==== Allocated Classes ====")
  ;  print-prog()

  register-assignment(backend)
  ;if print? :
  ;  println("==== Assigned Registers ====")
  ;  print-prog()
  
  val smap = stack-map()
  ;if print? :
  ;  println("==== Stack Map ====")
  ;  println(smap)
  
  collapse-blocks()
  if print? :
    println("==== Collapse Blocks ====")
    print-prog()

  assemble(emitter, smap, stubs)
  clear-working-set()

;============================================================
;========================== IR ==============================
;============================================================

;==============================
;==== Variable Definitions ====
;==============================

public deftype Imm
public defstruct Var <: Imm :
  n: Int
  reg? : False|Reg|FReg with: (default => false)
public defstruct Val <: Imm :
  value: VMImm

public deftype Loc
public defstruct Reg <: Loc&Equalable :
  n: Int
public defstruct FReg <: Loc&Equalable :
  n: Int

;======================
;==== Constructors ====
;======================
defn XReg (t:VMType, n:Int) :
  match(t:VMByte|VMInt|VMLong) : Reg(n)
  else : FReg(n)

;==================
;==== Equality ====
;==================

defmethod equal? (a:Reg, b:Reg) :
  n(a) == n(b)

defmethod equal? (a:FReg, b:FReg) :
  n(a) == n(b)
  
;=================================
;==== Instruction Definitions ====
;=================================
public deftype Ins
defmulti killed? (i:Ins) -> False|List<Int>

public defstruct Def <: Ins :
  x: Var
  killed?: False|List<Int> with: (default => false, as-method => true)

public defstruct Set <: Ins :
  x: Var
  y: Imm
  killed?: False|List<Int> with: (default => false, as-method => true)

public defstruct Args <: Ins :
  xs: List<Var>
  ctxt: FnContext
  killed?: False|List<Int> with: (default => false, as-method => true)

public defstruct Return <: Ins :
  xs: List<Imm>
  ctxt: FnContext
  killed?: False|List<Int> with: (default => false, as-method => true)

public defstruct Call <: Ins :
  xs: List<Var> with: (updater => sub-xs)
  f: Imm with: (updater => sub-f)
  ys: List<Imm> with: (updater => sub-ys)
  type: CallType with: (updater => sub-type)
  killed?: False|List<Int> with: (default => false, as-method => true)

public defstruct Op <: Ins :
  op: VMOp with: (updater => sub-op)
  xs: List<Var> with: (updater => sub-xs)
  ys: List<Imm> with: (updater => sub-ys)
  killed?: False|List<Int> with: (default => false, as-method => true) 

public defstruct Branch <: Ins :
  op: VMOp
  xs: List<Imm>
  killed?: False|List<Int> with: (default => false, as-method => true)

public defstruct Match <: Ins :
  dispatch?: True|False
  type-lists: List<List<TypeSet>>
  xs: List<Imm>
  locs: List<Loc>
  killed?: False|List<Int> with: (default => false, as-method => true)
  ns?: False|List<Int> with: (default => false)

public defstruct MethodDispatch <: Ins :
  multi: Int
  default: Int
  amb: Int
  killed?: False|List<Int> with: (default => false, as-method => true)

public defstruct Save <: Ins :
  x: Var

public defstruct Load <: Ins :
  x: Var

public defstruct Unload <: Ins :
  n: Int

public defstruct NextUsed <: Ins :
  n: Int
  pos: Int

public defstruct Xchg <: Ins :
  x: Var
  y: Var
  swap: False|Reg|FReg
  
public defstruct ShuffleReg <: Ins :
  xs: List<Int>
  ys: List<Int>

public defstruct ShuffleFReg <: Ins :
  xs: List<Int>
  ys: List<Int>

public defstruct Label <: Ins :
  n: Int

public defstruct Goto <: Ins :
  n: Int

public defstruct Break <: Ins :
  n: Int
  op: VMOp
  xs: List<Imm>

defmethod killed? (i:Save|Load|Unload|NextUsed|Xchg|
                     ShuffleReg|ShuffleFReg|Label|Goto|Break) :
  false

;==========================
;==== Function Context ====
;==========================

public deftype FnContext
public defmulti regs (c:FnContext) -> List<Loc>
public defstruct StanzaContext <: FnContext :
  regs: List<Loc> with: (as-method => true)
public defstruct CContext <: FnContext :
  regs: List<Loc> with: (as-method => true)

;===================
;==== Call Type ====
;===================

public deftype CallType
public defmulti func-reg (t:CallType) -> False|Loc
public defmulti arg-regs (t:CallType) -> List<Loc>
public defmulti ret-regs (t:CallType) -> List<Loc>

public defstruct StanzaCall <: CallType :
  info: False|FileInfo
  func-reg: False|Loc with: (as-method => true)
  arg-regs: List<Loc> with: (as-method => true)
  ret-regs: List<Loc> with: (as-method => true)
  
public defstruct StanzaTCall <: CallType :
  func-reg: False|Loc with: (as-method => true)
  arg-regs: List<Loc> with: (as-method => true)
defmethod ret-regs (c:StanzaTCall) : List()

public defstruct CCall <: CallType :
  num-mem-args: Int
  func-reg: False|Loc with: (as-method => true)
  arg-regs: List<Loc> with: (as-method => true)
  ret-regs: List<Loc> with: (as-method => true)
  
public defstruct YieldCall <: CallType :
  enter?: True|False
  info: False|FileInfo
  func-reg: Loc with: (as-method => true)
  arg-regs: List<Loc> with: (as-method => true)
  ret-regs: List<Loc> with: (as-method => true)

public defstruct ExtendHeap <: CallType :
  info: False|FileInfo
defmethod arg-regs (t:ExtendHeap) : List()
defmethod ret-regs (t:ExtendHeap) : List()
  
public defstruct ExtendStack <: CallType
defmethod arg-regs (t:ExtendStack) : List()
defmethod ret-regs (t:ExtendStack) : List()

;==========================
;==== Block Definition ====
;==========================
public defstruct Block :
  ins: Vector<Ins>
  next: List<Int>

;========================
;=== Port Definition ====
;========================
defstruct Port :
  n: Int
  saved?: True|False
  loaded?: True|False
  reg: False|Reg|FReg
  dist: Int

;=============================
;==== Convenience Getters ====
;=============================
defn killed (i:Ins) : killed?(i) as List<Int>
defn ns (m:Match) : ns?(m) as List<Int>
defn reg (v:Var) : reg?(v) as Reg|FReg

;=====================
;==== Special Ops ====
;=====================
public defstruct NoOp <: VMOp
defmethod print (o:OutputStream, op:NoOp) :
  print(o, "nop")

public defstruct RecordLiveOp <: VMOp :
  live-vars: Tuple<Var>
defmethod print (o:OutputStream, op:RecordLiveOp) :
  print(o, "live(%,)" % [live-vars(op)])

public defstruct LoadOp <: VMOp : (offset:Int)
defmethod print (o:OutputStream, op:LoadOp) :
  print(o, "load/%_" % [offset(op)])

public defstruct StoreOp <: VMOp : (offset:Int) ;[4]
defmethod print (o:OutputStream, op:StoreOp) :
  print(o, "store/%_" % [offset(op)])

public defstruct StoreArgOp <: VMOp : (index:Int)
defmethod print (o:OutputStream, op:StoreArgOp) :
  print(o, "storearg/%_" % [index(op)])
  
public defstruct LoadArgOp <: VMOp : (index:Int)
defmethod print (o:OutputStream, op:LoadArgOp) :
  print(o, "loadarg/%_" % [index(op)])

public defstruct AllocOp <: VMOp
defmethod print (o:OutputStream, op:AllocOp) :
  print(o, "alloc")
  
;public defstruct SaveCContextOp <: VMOp
;defmethod print (o:OutputStream, op:SaveCContextOp) :
;  print(o, "save-c-ctxt")
;

public defstruct FlipOp <: VMOp : (op:VMOp)
defmethod print (o:OutputStream, x:FlipOp) :
  print(o, "flip(%_)" % [op(x)])

;============================================================
;===================== Working Set ==========================
;============================================================

val BLOCKS = Vector<Block>()
val VAR-TYPES = Vector<VMType>()
val IN-PORTS = Vector<List<Port>>()
val OUT-PORTS = Vector<List<Port>>()
val PREDECESSORS = Vector<List<Int>>()

defn nblocks () : length(BLOCKS)
defn nvars () : length(VAR-TYPES)

defn clear-working-set () :
  clear(BLOCKS)
  clear(VAR-TYPES)

defn type (i:Imm) :
  match(i) :
    (i:Var) : VAR-TYPES[n(i)]
    (i:Val) : type(value(i))

defn make-var (t:VMType) :
  val n = length(VAR-TYPES)
  add(VAR-TYPES, t)
  Var(n)

;============================================================
;====================== Printing ============================
;============================================================

defn print-prog () :
  for i in 0 to nvars() do :
    println("val %_ : %_" % [i, VAR-TYPES[i]])
  for i in 0 to nblocks() do :
    println("block %_ :" % [i])
    indented $ fn () :
      if length(IN-PORTS) == nblocks() :
        println("input ports:")
        indented $ fn () :
          do(println, IN-PORTS[i])
      println("instructions:")
      indented $ fn () :
        if length(PREDECESSORS) == nblocks() :
          println("prev: %," % [PREDECESSORS[i]])
        println(BLOCKS[i])
      if length(OUT-PORTS) == nblocks() :
        println("output ports:")
        indented $ fn () :
          do(println, OUT-PORTS[i])

defmethod print (o:OutputStream, v:Imm) :
  print{o, _} $ match(v) :
    (v:Var) :
      val reg = match(reg?(v)) :
        (r:False) : ""
        (r) : ":%_" % [r]
      "V%_%_" % [n(v), reg]
    (v:Val) :
      value(v)

defmethod print (o:OutputStream, r:Reg) :
  print(o, "R%_" % [n(r)])

defmethod print (o:OutputStream, r:FReg) :
  print(o, "F%_" % [n(r)])

defmethod print (o:OutputStream, i:Ins) :
  val ks = match(killed?(i)) :
             (ks:False) : ""
             (ks:List<Int>) : " killed: %," % [ks]
  print{o, _} $ match(i) :
    (i:Def) : "def %_" % [x(i)]
    (i:Set) : "%_ = %_%_" % [x(i), y(i), ks]
    (i:Args) : "(%,) = Args%_" % [xs(i), ks]
    (i:Call) : "(%,) = %_(%,) %_%_" % [xs(i), f(i), ys(i), type(i), ks]
    (i:Return) : "return (%,)%_" % [xs(i), ks]
    (i:Op) : "(%,) = %_(%,)%_" % [xs(i), op(i), ys(i), ks]
    (i:Branch) : "branch when %_(%,)%_" % [op(i), xs(i), ks]
    (i:Save) : "save %_" % [x(i)]
    (i:Load) : "load %_" % [x(i)]
    (i:Unload) : "unload V%_" % [n(i)]
    (i:NextUsed) : "next used %_ at %_" % [n(i), pos(i)]
    (i:Xchg) : "xchg %_ with %_ through %_" % [x(i), y(i), swap(i)]
    (i:Match) :
      val op = "dispatch" when dispatch?(i) else "match"
      "%_(%, : %,)[%,]%_" % [op, xs(i), locs(i), type-lists(i), ks]
    (i:MethodDispatch) :
      "method-dispatch(%_)%_" % [multi(i), ks]
    (i:ShuffleReg) : "shuffle (%,) = (%,)" % [xs(i), ys(i)]
    (i:ShuffleFReg) : "fshuffle (%,) = (%,)" % [xs(i), ys(i)]
    (i:Label) : "label %_" % [n(i)]
    (i:Goto) : "goto %_" % [n(i)]
    (i:Break) : "break %_ when %_(%,)" % [n(i), op(i), xs(i)]

defmethod print (o:OutputStream, c:FnContext) :
  print{o, _} $ match(c) :
    (c:StanzaContext) : "ST(%_)" % [regs(c)]
    (c:CContext) : "C(%_)" % [regs(c)]

defmethod print (o:OutputStream, c:CallType) :
  print{o, _} $ match(c) :
    (c:StanzaCall) : "S(%_, %_, %_)" % [func-reg(c), arg-regs(c), ret-regs(c)]
    (c:StanzaTCall) : "ST(%_, %_)" % [func-reg(c), arg-regs(c)]
    (c:CCall) : "C(%_, %_, %_, %_)" % [num-mem-args(c), func-reg(c), arg-regs(c), ret-regs(c)]
    (c:YieldCall) : "Y(%_, %_, %_, %_)" % [enter?(c), func-reg(c), arg-regs(c), ret-regs(c)]
    (c:ExtendHeap) : "ExtendHeap"
    (c:ExtendStack) : "ExtendStack"

defmethod print (o:OutputStream, b:Block) :
  do(println{o, _}, ins(b))
  print(o, "next: %," % [next(b)])

defmethod print (o:OutputStream, p:Port) :
   print(o, "%~ (s:%~, l:%~, at:%~, dist:%~)" % [n(p), saved?(p), loaded?(p), reg(p), dist(p)])

;============================================================
;=================== Working Functions ======================
;============================================================

defn do-defined (f: Var -> ?, e:Ins) :
  match(e) :
    (e:Def) : f(x(e))
    (e:Set) : f(x(e))
    (e:Args) : do(f, xs(e))
    (e:Call) : do(f, xs(e))
    (e:Return) : false
    (e:Op) : do(f, xs(e))
    (e:Branch) : false
    (e:Save) : false
    (e:Load) : f(x(e))
    (e:Match) : false
    (e:MethodDispatch) : false
  false

defn do-used (gv: Var -> ?, e:Ins) :
  defn g (i:Imm) : match(i:Var) : gv(i)
  match(e) :
    (e:Def) : false
    (e:Set) : g(y(e))
    (e:Args) : false
    (e:Call) : (g(f(e)), do(g, ys(e)))
    (e:Return) : do(g, xs(e))
    (e:Op) : do(g, ys(e))
    (e:Branch) : do(g, xs(e))
    (e:Save) : g(x(e))
    (e:Load) : false
    (e:Match) : do(g, xs(e))
    (e:MethodDispatch) : false
  false

defn used-vars (e:Ins) :
  generate<Int> :
    do-used(yield{n(_)}, e)

defn do-vars (f: Var -> ?, e:Ins) :
  do-defined(f, e)
  do-used(f, e)

defn reverse-sweep (e:Ins, define:Var -> ?, emit:Ins -> ?, use-var:Var -> ?) :
  defn use (x:Imm) :
    match(x:Var) :
      use-var(x)
  match(e) :
    (e:Def) :
      define(x(e))
      emit(e)
    (e:Set) :
      define(x(e))
      emit(e)
      use(y(e))
    (e:Args) :
      do(define, xs(e))
      emit(e)
    (e:Call) :
      do(define, xs(e))
      emit(e)
      use(f(e))
      do(use, ys(e))
    (e:Return) :
      emit(e)
      do(use, xs(e))
    (e:Op) :
      do(define, xs(e))
      emit(e)
      do(use, ys(e))
    (e:Branch) :
      emit(e)
      do(use, xs(e))
    (e:Match) :
      emit(e)
      do(use, xs(e))
    (e:MethodDispatch) :
      emit(e)

defn attach-killed (e:Ins, ks:List<Int>) :
  match(e) :
    (e:Def) : Def(x(e), ks)
    (e:Set) : Set(x(e), y(e), ks)
    (e:Args) : Args(xs(e), ctxt(e), ks)
    (e:Return) : Return(xs(e), ctxt(e), ks)
    (e:Call) : Call(xs(e), f(e), ys(e), type(e), ks)
    (e:Op) : Op(op(e), xs(e), ys(e), ks)
    (e:Branch) : Branch(op(e), xs(e), ks)
    (e:Match) : Match(dispatch?(e), type-lists(e), xs(e), locs(e), ks, ns?(e))
    (e:MethodDispatch) : MethodDispatch(multi(e), default(e), amb(e), ks)

;============================================================
;=================== Unique Labels ==========================
;============================================================
val TAKEN-IDS = IntSet()
var ID-COUNTER:Seq<Int>

defn take-ids (f:VMFunction) :
  clear(TAKEN-IDS)
  ID-COUNTER = to-seq(0 to false)
  
  defn take-ids (f:VMFunc) :
    add-all(TAKEN-IDS, seq(id, defs(f)))
    add-all(TAKEN-IDS, seq(n,filter-by<LabelIns>(ins(f))))
    
  match(f) :
    (f:VMFunc) :
      take-ids(f)
    (f:VMMultifn) :
      do(take-ids{value(_)}, funcs(f))
      take-ids(default(f))

defn unique-id () :
  let loop () :
    val i = next(ID-COUNTER)
    if TAKEN-IDS[i] : loop()
    else : i

;============================================================
;================= Load into Working Set ====================
;============================================================
  
defn load-instructions (function:VMFunc) :
  ;========================
  ;==== Variable Table ====
  ;========================
  val var-table = IntTable<Int>()
  defn make-var (n:Int, t:VMType) :
    fatal("Variable %_ already exists." % [n]) when key?(var-table,n)
    var-table[n] = length(VAR-TYPES)
    add(VAR-TYPES, t)
;    if flag-defined?(`PRINT-REG-ALLOC) :
;      println("V%_ = $v%_" % [var-table[n], n])
  defn make-var (t:VMType) :
    val n = length(VAR-TYPES)
    add(VAR-TYPES, t)
    Var(n)
  defn get-var (v:Int) :
    Var(var-table[v])
  defn get-var (v:Local) :
    get-var(index(v))
  defn get-imm (v:VMImm) :
    match(v:Local) : get-var(v)
    else : Val(v)
  defn get-vars (vs:Seqable<Local>) :
    to-list(seq(get-var, vs))
  defn get-imms (vs:Seqable<VMImm>) :
    to-list(seq(get-imm, vs))

  ;=====================
  ;==== Block Table ====
  ;=====================
  val block-table = IntTable<Int>()
  var active-block : False|Block = false
  var active-block-index : False|Int = false

  defn open-block (lbl:Int) -> Int :
    val i = set?{block-table, lbl, _} $ fn () :
      add(BLOCKS, Block(Vector<Ins>(), List()))
      length(BLOCKS) - 1
;    if flag-defined?(`PRINT-REG-ALLOC) :
;      println("Label %_ = Block %_" % [lbl, i])
    active-block-index = i
    active-block = BLOCKS[i]
    i

  defn close-block (next-lbls:List<Int>) :
    val b = active-block
    match(b:Block) :
      val i = active-block-index as Int
      BLOCKS[i] = Block(ins(b), map(open-block, next-lbls))
      active-block = false
      active-block-index = false

  defn push (e:Ins) :
    println("Push: %_" % [e])
    match(active-block:False) :
      open-block(unique-id())
    val b = active-block as Block
    add(ins(b), e)

  ;=========================
  ;====== Convenience ======
  ;=========================
  defn locals (r:RetRecords) :
    seq(x, records(r))
  defn to-reg (r:CallReg|CallFReg) :
    match(r) :
      (r:CallReg) : Reg(index(r))
      (r:CallFReg) : FReg(index(r))          
  defn regs (r:RetRecords) :
    to-list $ for r in records(r) seq :
      to-reg(loc(r) as CallReg|CallFReg)
  defn imms (r:CallRecords) :
    for r in records(r) seq :
      arg(r) as VMImm
  defn regs (r:CallRecords) :
    to-list $ for r in records(r) seq :
      to-reg(loc(r) as CallReg|CallFReg)
  defn func-reg? (f:VMImm, i:Int) :
    match(f:Local) : Reg(i)

  ;=========================
  ;===== Def Table =========
  ;=========================
  ;val def-table = IntTable<VMDef>()
  ;defn load-defs (f:VMFunction) :
  ;  defn load-defs (f:VMFunc) :
  ;    for d in defs(f) do : def-table[id(d)] = d
  ;  match(f) :
  ;    (f:VMFunc) :
  ;      load-defs(f)
  ;    (f:VMMultifn) :
  ;      do(load-defs, seq(value,funcs(f)))
  ;      load-defs(default(f))
  ;defn imm-type (x:VMImm) :
  ;  match(x:Local) : type(def-table[index(x)])
  ;  else : type(x)

  ;=====================================
  ;======= Create Dummy Variables ======
  ;=====================================
  defn get-var? (v:Local|False) :
    match(v:Local) :
      get-var(v)
    else :
      val v = make-var(VMLong())
      push(Def(v))
      v
  defn get-vars? (vs:Seqable<Local|False>) :
    to-list(seq(get-var?,vs))

  ;=================
  ;==== Loading ====
  ;=================
  ;defn emit-function (f:VMFunction) :
  ;  match(f) :
  ;    (f:VMFunc) :
  ;      open-block(unique-id())
  ;      emit-instructions(f)
  ;    (f:VMMultifn) :        
  ;      open-block(unique-id())
  ;      for entry in funcs(f) do :
  ;        val pass-lbl = unique-id()
  ;        val fail-lbl = unique-id()
  ;        push(Branch(RegEqOp(1,key(entry)), List()))
  ;        close-block(List(pass-lbl, fail-lbl))
  ;        open-block(pass-lbl)
  ;        emit-instructions(value(entry))
  ;        open-block(fail-lbl)
  ;      emit-instructions(default(f))

  ;defn emit-instructions (f:VMFunc) :
  ;  ;Clear the var-table for this particular function
  ;  clear(var-table)
  ;
  ;  ;Define all the local variables in the function
  ;  for d in defs(f) do :
  ;    make-var(id(d), type(d))
  ;
  ;  ;Check whether there is space for the function. Go to either
  ;  ;has-stack-lbl or no-stack-lbl depending.
  ;  val has-stack-lbl = unique-id()
  ;  val no-stack-lbl = unique-id()
  ;  push(Branch(HasStackSpaceOp(), List()))
  ;  close-block(List(has-stack-lbl, no-stack-lbl))
  ;  
  ;  ;If there is no stack space then call the stack extender,
  ;  ;and then go to the has-stack-lbl.    
  ;  open-block(no-stack-lbl)
  ;  push(Call(List(), Val(VoidMarker()), List(), ExtendStack()))
  ;  close-block(List(has-stack-lbl))
  ;
  ;  ;If there is stack space, then continue the function as normal.
  ;  open-block(has-stack-lbl)
  ;  for d in defs(f) do :
  ;    push(Def(get-var(id(d))))
  ;  val arg-vars = get-vars?(args(f))
  ;  push(Args(arg-vars, StanzaContext()))
  ;  emit-instructions(ins(f))   

  ;Make vars for defs
  for d in defs(function) do :
    make-var(id(d), type(d))
    push(Def(get-var(id(d))))
    
  ;Process each instruction
  for e in ins(function) do :
    println("Processing %_" % [e])
    match(e) : ;[3]
      (e:ArgIns) :
        val r = ret(e)
        val xs = get-vars(locals(r))
        val ctxt = StanzaContext(regs(r))
        push(Args(xs, ctxt))
      (e:CallRecordIns) :
        val r = ret(e)
        val a = args(e)
        val calltype = match(type(e)) :
          (t:vm-StanzaCall) : StanzaCall(info(e), func-reg?(f(e), 0), regs(a), regs(r))
          (t:vm-StanzaTCall) : StanzaTCall(func-reg?(f(e), 0), regs(a))
          (t:vm-CCall) : CCall(num-mem-args(t), func-reg?(f(e),9), regs(a), regs(r))
          (t:vm-YieldCall) : YieldCall(enter?(t), info(e), Reg(0), regs(a), regs(r))
        push(Call(get-vars(locals(r)), get-imm(f(e)), get-imms(imms(a)), calltype))
        close-block(List()) when type(e) is vm-StanzaTCall          
      (e:ReturnRecordIns) :
        val r = args(e)
        val xs = get-imms(imms(r))
        val ctxt = match(type(e)) :
          (t:vm-StanzaCall) : StanzaContext(regs(r))
          (t:vm-CCall) : fatal("Not yet implemented")
        push(Return(xs, ctxt))
        close-block(List())          
      (e:MatchRecordIns) :
        val type-lists = to-list(seq(to-list{types(_)}, branches(e)))
        val branch-ns = to-list(seq(n, branches(e)))
        val ns = match(amb(e)) :
                   (amb:Int) : cons(default(e), amb, branch-ns)
                   (amb:False) : cons(default(e), branch-ns)                   
        val r = args(e)
        push(Match(dispatch?(e), type-lists, get-imms(imms(r)), regs(r)))
        close-block(ns)        
      (e:ExtendStackIns) :
        push(Call(List(), Val(VoidMarker()), List(), ExtendStack()))
      (e:ExtendHeapIns) :
        val size = get-imm(size(e))
        push(Call(List(), Val(VoidMarker()), List(size), ExtendHeap(info(e))))
      (e:AllocOnHeap) :
        val size = get-imm(size(e))
        push(Op(AllocOp(), List(get-var(x(e))), List(size)))
      (e:SetIns) :
        push(Set(get-var(x(e)), get-imm(y(e))))
      (e:Op0Ins) :
        push(Op(op(e), List(get-var(x(e))), List()))
      (e:Op1Ins) :
        push(Op(op(e), List(get-var(x(e))), List(get-imm(y(e)))))
      (e:Op2Ins) :
        push(Op(op(e), List(get-var(x(e))), List(get-imm(y(e)), get-imm(z(e)))))
      (e:DualOp2Ins) :
        push(Op(op(e), List(get-var(x(e)), get-var(y(e))), List(get-imm(z(e)), get-imm(w(e)))))
      (e:LoadArgIns) :
        push(Op(LoadArgOp(index(e)), List(get-var(x(e))), List()))      
      (e:StoreArgIns) :
        push(Op(StoreArgOp(index(e)), List(), List(get-imm(y(e)))))      
      (e:LabelIns) :
        close-block(List(n(e)))
        open-block(n(e))
      (e:GotoIns) :
        close-block(List(n(e)))
      (e:Branch0Ins) :
        push(Branch(op(e), List()))
        close-block(List(n1(e), n2(e)))        
      (e:Branch1Ins) :
        val op* = op(e) as VMOp
        push(Branch(op*, List(get-imm(x(e)))))
        close-block(List(n1(e), n2(e)))
      (e:Branch2Ins) :
        push(Branch(op(e), List(get-imm(x(e)), get-imm(y(e)))))
        close-block(List(n1(e), n2(e)))
      (e:MethodDispatchIns) :
        push(MethodDispatch(multi(e), default(e), amb(e)))
        close-block(List(default(e), amb(e)))
      (e:StoreIns) :      
        push(Op(StoreOp(offset(e)), List(), List(get-imm(x(e)), get-imm(z(e)))))
      (e:LoadIns) :
        push(Op(LoadOp(offset(e)), List(get-var(x(e))), List(get-imm(y(e)))))
      (e:DumpIns) :
        false
      (e:LiveIns) :
        push(Op(NoOp(), List(), get-imms(xs(e))))
      (e:RecordLiveIns) :
        val op = RecordLiveOp(map(get-var,live(e)))
        push(Op(op, List(), List()))
      (e:CommentIns) :
        false
      (e:UnreachableIns) :
        close-block(List())

;============================================================
;================== Backend Properties ======================
;============================================================
defn frame-size (t:CCall, backend:Backend) :
  match(backend) :
    (backend:W64Backend) :
      8 * ((num-mem-args(t) + 4) | 1)
    (backend) :
      8 * ((num-mem-args(t)) | 1)

defn mem-arg-offsets (t:CCall, backend:Backend) :
  match(backend) :
    (backend:W64Backend) :
      val offset = (- frame-size(t, backend))
      seq({offset + _}, 32 to false by 8)
    (backend) :
      val offset = (- frame-size(t, backend))
      seq({offset + _}, 0 to false by 8)

;============================================================
;=================== Normalization ==========================
;============================================================
;<normalize>
defn normalize (backend:Backend) :
  ;===============================================
  ;==== If a value is needed for saving C Rsp ====
  ;===============================================
  ;val cached-var-table = HashTable-init<Symbol,Var>(make-var{TGLongT()})
  ;defn cached-var (name:Symbol) : cached-var-table[name]
    
  ;Normalize each block
  for (blk in BLOCKS, b in 0 to false) do :
    normalize(blk, b, backend)

defn normalize (blk:Block, b:Int, backend:Backend) :
  ;============================
  ;==== Instruction Buffer ====
  ;============================
  val instructions = Vector<Ins>()
  defn emit (e:Ins) : add(instructions, e)

  ;======================
  ;==== Instructions ====
  ;======================
  val #c-rsp = Val(TGMem(C-RSP-LBL))
  val #rsp = Val(TGMem(STACK-PTR-LBL))
  defn #load (x:Var, y:Imm, offset:Int) :
    emit(Op(LoadOp(offset), List(x), List(y)))
  defn #store (x:Imm, y:Imm, offset:Int) :
    emit(Op(StoreOp(offset), List(), List(x, y)))
  defn #conv (x:Var, y:Imm) :
    emit(Op(ConvOp(), List(x), List(y)))

  ;=============================
  ;==== Variable Operations ====
  ;=============================
  defn force-new-var (x:Imm) :
    val x* = make-var(type(x))
    emit(Set(x*, x))
    x*

  defn force-var (x:Imm) :
    match(x:Var) : x
    else : force-new-var(x)

  defn force-operand (x:Imm) :
    val max = 1 << 16
    val min = -1 << 16
    defn large? (v:Int) : (v < min) or (v > max)
    defn large? (v:Long) : (v < to-long(min)) or (v > to-long(max))
    match(x) :
      (x:Var) :
        x
      (x:Val) :
        match(value(x)) :
         (v:TGInt|TGLong) :
           if large?(value(v)) : force-var(x)
           else : x
         (v:TGMem|TGExMem) : force-var(x)
         (v) : x
 
  ;===============================
  ;==== Position Independence ====
  ;===============================
  
  ;Does i refer to an external memory location?
  defn exmem? (i:Imm) :
    match(i:Val) : 
      value(i) is TGExMem
      
  ;Does i refer to an external memory location with non-zero offset?    
  defn exmem-non-zero-offset? (i:Imm) :
    match(i:Val) :
      val v = value(i)
      match(v:TGExMem) :
        offset(v) != 0      

  ;Remove the external memory location from necessary instructions, if
  ;backend requires a global offset table.
  defn remove-exmem (i:Ins) :
    if use-global-offset-table?(backend) :
      match(i) :
        (i:Op) :
          match(op(i)) :
            (op:LoadOp) :
              val y = head(ys(i))
              if exmem?(y) : sub-ys(i, List(force-var(y)))
              else : i
            (op:StoreOp) :
              val x = head(ys(i))
              if exmem?(x) :
                val ys* = List(force-var(x), ys(i)[1])
                sub-ys(i, ys*)
              else : i
            (op) : i
        (i:Call) :
          if exmem-non-zero-offset?(f(i)) :
            sub-f(i, force-var(f(i)))
          else : i
        (i) : i
    else : i

  ;============================
  ;==== Call Normalization ====
  ;============================
  defn norm-stanza-call (e:Call) :
    val ys* = split-call-locs(map(force-new-var,ys(e)),
                call-regs(backend), call-fregs(backend))
    val xs* = split-call-locs(xs(e), call-regs(backend), call-fregs(backend))
    for (y in mems(ys*), o in 0 to false by 8) do :
      #store(#argspace, y, o)
    val type* = match(type(e)) :
      (t:StanzaCall) : StanzaCall(arity(t), info(t),
                         Reg(1), locs(ys*), locs(xs*))
      (t:StanzaTCall) : StanzaTCall(arity(t), Reg(1), locs(ys*), locs(xs*))
    emit(Call(regs(xs*) as List<Var>, f(e), regs(ys*), type*))
    for (x in mems(xs*), o in 0 to false by 8) do :
      #load(x as Var, #argspace, o)

  ;defn norm-c-call (e:Call) :
  ;  val t = type(e) as CCall
  ;  ;Split up arguments
  ;  val ys* = match(backend) :
  ;    (backend:W64Backend) :
  ;      defn shadow (x:Imm) :
  ;        val x* = make-var(TGIntegerT(type(x)))
  ;        emit(Op(InterpretOp(), List(x*), List(force-var(x))))
  ;        x*
  ;      split-call-locs-shadow(map(force-new-var,ys(e)),
  ;                             arity(t),
  ;                             callc-regs(backend),
  ;                             callc-fregs(backend), shadow)
  ;    (backend:Backend) :
  ;      split-call-locs(map(force-new-var,ys(e)),
  ;        callc-regs(backend), callc-fregs(backend))
  ;  ;Return register
  ;  val ret-reg =
  ;    if empty?(xs(e)) : Reg(0)
  ;    else if type(head(xs(e))) is TGIntegerT : Reg(0)
  ;    else : FReg(0)
  ;  ;Annotated call type
  ;  val type* = CCall(arity(t), length(mems(ys*)), Reg(1), locs(ys*), ret-reg)
  ;  ;Store arguments
  ;  if not empty?(mems(ys*)) :
  ;    val csp = make-var(TGLongT())
  ;    #load(csp, #c-rsp, 0)
  ;    for (y in mems(ys*), o in mem-arg-offsets(type*,backend)) do :
  ;      #store(csp, y, o)
  ;  ;Emit call    
  ;  emit(Call(xs(e), f(e), regs(ys*), type*))

  defn norm-stack-call (e:Call) :
    val reg = Reg(head(call-regs(backend)))
    val type* = StackSwitch(Reg(1), reg)
    emit(Call(xs(e), force-var(f(e)), ys(e), type*))

  ;==============================
  ;==== Return Normalization ====
  ;==============================
  defn norm-stanza-return (e:Return) :
    val xs* = split-call-locs(map(force-new-var,xs(e)), call-regs(backend), call-fregs(backend))
    val argspace = TGMem(ARG-LBL)
    for (x in mems(xs*), o in 0 to false by 8) do :
      #store(#argspace, x, o)
    val ctxt* = StanzaContext(locs(xs*))
    emit(Return(regs(xs*), ctxt*))

  ;defn norm-c-return (e:Return) :
  ;  ;Load C pointer, and restore old one
  ;  val c-rsp = make-var(TGLongT())
  ;  #load(c-rsp, #c-rsp, 0)
  ;  #store(#c-rsp, cached-var(`saved-c-rsp), 0)
  ;  #store(#rsp, cached-var(`saved-rsp), 0)
  ;  ;Emit instruction
  ;  val xs* = cons(c-rsp, map(force-new-var,xs(e)))
  ;  val ret-reg =
  ;    if empty?(xs(e)) :
  ;      Reg(0)
  ;    else :
  ;      match(type(head(xs(e)))) :
  ;        (t:TGIntegerT) : Reg(0)
  ;        (t:TGRealT) : FReg(0)
  ;  val ctxt* = CContext(List(Reg(6), ret-reg))
  ;  emit(Return(xs*, ctxt*))

  ;===========================
  ;==== Arg Normalization ====
  ;===========================
  defn norm-stanza-args (e:Args) :
    val xs* = split-call-locs(xs(e), call-regs(backend), call-fregs(backend))
    val argspace = TGMem(ARG-LBL)
    val ctxt* = StanzaContext(locs(xs*))
    emit(Args(regs(xs*) as List<Var>, ctxt*))
    for (x in mems(xs*), o in 0 to false by 8) do :
      #load(x as Var, #argspace, o)

  ;defn norm-c-args (e:Args) :
  ;  ;Split up arguments
  ;  val arity = length(xs(e))
  ;  val xs* = match(backend) :
  ;    (backend:W64Backend) :
  ;      split-call-locs-shadow(xs(e), arity, callc-regs(backend),
  ;                             callc-fregs(backend), fatal{"No Shadow"})
  ;    (backend:Backend) :
  ;      split-call-locs(xs(e), callc-regs(backend), callc-fregs(backend))
  ;  ;Emit instruction
  ;  val c-rsp = make-var(TGLongT())
  ;  val ctxt* = CContext(cons(Reg(6), locs(xs*)))
  ;  emit(Args(cons(c-rsp, regs(xs*) as List<Var>), ctxt*))
  ;  ;Load arguments
  ;  for (x in mems(xs*), i in 0 to false) do :
  ;    #load(x as Var, c-rsp, 8 * (i + 1))
  ;  ;Save old C pointer and Set c-rsp as new C pointer
  ;  #load(cached-var(`saved-rsp), #rsp, 0)
  ;  #load(cached-var(`saved-c-rsp), #c-rsp, 0)
  ;  #store(#c-rsp, c-rsp, 0)

  ;=============================
  ;==== Match Normalization ====
  ;=============================
  defn norm-match (e:Match) :
    val [xs, mxs] = split-match-locs(xvars, nregs) where :
      val xvars = map(force-new-var, xs(e))
      val nregs = num-regs(backend)
    ;Store arguments
    val argspace = TGMem(ARG-LBL)
    for (x in mxs, o in 0 to false by 8) do :
      #store(#argspace, x, o)
    ;Emit instruction
    emit(Match(dispatch?(e), type-lists(e), xs))

  ;==============================
  ;==== Branch Normalization ====
  ;==============================
  defn norm-branch (e:Branch) :
    defn x1 () : force-operand(xs(e)[0])
    defn x2 () : force-operand(xs(e)[1])
    match(op(e)) :
      (op:TGOp&Comparison) :
        match(x1(), x2()) :
          (x1:Val, x2:Val) : emit(Branch(op, List(force-var(x1), x2)))
          (x1, x2) : emit(Branch(op, List(x1, x2)))
      (op:TGArityNeOp) :
        emit(Branch(op, List(x1())))
      (op) : emit(e)

  ;===============================
  ;==== Operand Normalization ====
  ;===============================
  defn cast-to-int (x:Imm) :
    val ix = make-var(TGIntT())
    #conv(ix, force-var(x))
    ix
      
  defn cast-to-int (x:Var, y1:Imm, y2:Imm,
                    f: (TGType, Var, Var, Var) -> False) :
    val ix = make-var(TGIntT())
    f(TGIntT(), ix, cast-to-int(y1), cast-to-int(y2))
    #conv(x, ix)
    
  defn cast-to-int (x:Var, y:Imm, 
                    f: (TGType, Var, Var) -> False) :
    val ix = make-var(TGIntT())
    f(TGIntT(), ix, cast-to-int(y))
    #conv(x, ix)

  defn norm-div-op (x:Var, y1:Imm, y2:Imm) :
    match(type(y1)) :    
      (t:TGByteT) :
        cast-to-int{x, y1, y2, _} $ fn (t, x, y1, y2) :
          emit(Op(DivModOp(), List(x, make-var(t)), List(y1, y2)))
          emit(Op(NoOp(), List(), List(y2)))
      (t:TGIntegerT) :
        val x2 = make-var(type(y1))
        val y1 = force-var(y1)
        val y2 = force-var(y2)
        emit(Op(DivModOp(), List(x,x2), List(y1, y2)))
        emit(Op(NoOp(), List(), List(y2)))
      (t:TGRealT) :
        emit(Op(TGDivOp(), List(x), List(y1, y2)))
        emit(Op(NoOp(), List(), List(y2)))        

  defn norm-mod-op (x:Var, y1:Imm, y2:Imm) :
    match(type(y1)) :
      (t:TGByteT) :
        cast-to-int{x, y1, y2, _} $ fn (t, x, y1, y2) :
          emit(Op(DivModOp(), List(make-var(t), x), List(y1, y2)))
          emit(Op(NoOp(), List(), List(y2)))
      (t:TGIntegerT) :
        val y1 = force-var(y1)
        val y2 = force-var(y2)
        emit(Op(DivModOp(), List(make-var(t), x), List(y1, y2)))
        emit(Op(NoOp(), List(), List(y2)))

  defn norm-mul-op (x:Var, y1:Imm, y2:Imm) :
    match(type(y1)) :
      (t:TGByteT) :
        cast-to-int{x, y1, y2, _} $ fn (t, x, y1, y2) :
          emit(Op(TGMulOp(), List(x), List(y1, y2)))
      (t) : emit(Op(TGMulOp(), List(x), List(y1, y2)))

  defn norm-noncomm-op (op:TGOp, x:Var, y1:Imm, y2:Imm) :
    emit(Op(op, List(x), List(y1, y2)))
    emit(Op(NoOp(), List(), List(y2)))

  defn norm-cmp-op (op:TGOp, x:Var, y1:Imm, y2:Imm) :
    match(y1, y2) :
      (y1:Val, y2:Val) : emit(Op(op, List(x), List(force-var(y1), y2)))
      (y1, y2) : emit(Op(op, List(x), List(y1, y2)))

  defn norm-neg-op (op:TGOp, x:Var, y:Imm) :
    match(type(x)) :
      (t:TGIntegerT) :
        norm-unary-op(op, x, y)
      (t:TGRealT) :
        val zero = make-var(t)
        #conv(zero, force-var(Val(TGInt(0))))
        emit(Op(TGSubOp(), List(x), List(zero, y)))

  defn norm-unary-op (op:TGOp, x:Var, y:Imm) :
    match(type(x)) :
      (t:TGByteT) :
        cast-to-int{x, y, _} $ fn (t, x, y) :
          emit(Op(op, List(x), List(y)))
      (t:TGIntegerT) :
        emit(Op(op, List(x), List(y)))

  defn norm-conv-op (x:Var, #y:Imm) :
    val y = force-var(#y)
    match(type(x), type(y)) :
      (xt:TGIntegerT, yt:TGIntegerT) :
        #conv(x, y)
      (xt:TGRealT, yt:TGRealT) :
        #conv(x, y)
      (xt:TGByteT, yt:TGRealT) :
        #conv(x, cast-to-int(y))
      (xt:TGIntegerT, yt:TGRealT) :
        #conv(x, y)
      (xt:TGRealT, yt:TGByteT) :        
        val iy = make-var(TGIntT())
        #conv(iy, y)
        #conv(x, iy)
      (xt:TGRealT, yt:TGIntegerT) :
        #conv(x, y)

  defn norm-interpret-op (x:Var, y:Imm) :
    emit(Op(InterpretOp(), List(x), List(force-var(y))))

  defn norm-store-op (op:TGOp, y1:Imm, y2:Imm) :
    emit(Op(op, List(), List(y1, y2)))

  ;===================
  ;==== Algorithm ====
  ;===================
  ;Sweep through instructions
  for e0 in ins(blk) do :
    match(remove-exmem(e0)) :
      (e:Call) :
        match(type(e)) :
          (type:StanzaCall|StanzaTCall) : norm-stanza-call(e)
          (type:CCall) : norm-c-call(e)
          (type:StackSwitch) : norm-stack-call(e)
      (e:Return) :
        match(ctxt(e)) :
          (type:StanzaContext) : norm-stanza-return(e)
          (type:CContext) : norm-c-return(e)
      (e:Args) :
        match(ctxt(e)) :
          (type:StanzaContext) : norm-stanza-args(e)
          (type:CContext) : norm-c-args(e)
      (e:Match) :
        norm-match(e)
      (e:Op) :
        defn x () : head(xs(e))
        defn m1 () : ys(e)[0]
        defn y1 () : force-operand(ys(e)[0])
        defn y2 () : force-operand(ys(e)[1])
        match(op(e)) :
          (op:TGDivOp) : norm-div-op(x(), y1(), y2())
          (op:TGModOp) : norm-mod-op(x(), y1(), y2())
          (op:TGMulOp) : norm-mul-op(x(), y1(), y2())
          (op:TGOp&Commutative) : emit(Op(op, xs(e), map(force-operand,ys(e))))
          (op:TGOp&NonCommutative) : norm-noncomm-op(op, x(), y1(), y2())
          (op:TGOp&Comparison) : norm-cmp-op(op, x(), y1(), y2())
          (op:TGNegOp) : norm-neg-op(op, x(), y1())
          (op:TGNotOp) : norm-unary-op(op, x(), y1())
          (op:InterpretOp) : norm-interpret-op(x(), y1())
          (op:ConvOp) : norm-conv-op(x(), y1())
          (op:StoreOp) : norm-store-op(op, m1(), y2())
          (op:LoadOp|NewStackOp|SaveCContextOp|ArityErrorOp) : emit(e)
          (op) : fatal("Not supported: %_" % [op])
      (e:Branch) :
        norm-branch(e)
      (e) :
        emit(e)

  ;Replace block
  BLOCKS[b] = Block(instructions, next(blk))

;===================================
;==== Determining Mem Arguments ====
;===================================
defstruct SplitLocs :
  regs: List<Imm>
  mems: List<Imm>
  locs: List<Loc>

defn split-call-locs (xs:List<Imm>, reg-ns:List<Int>, freg-ns:List<Int>) :
  val regs = seq(Reg, reg-ns)
  val fregs = seq(FReg, freg-ns)
  val reg-xs = Vector<Imm>()
  val mem-xs = Vector<Imm>()
  val xs-locs = Vector<Loc>()
  for x in xs do :
    add{_, x} $ match(type(x)) :
      (t:TGIntegerT) :
        if empty?(regs) : mem-xs
        else : (add(xs-locs,next(regs)), reg-xs)
      (t:TGRealT) :
        if empty?(fregs) : mem-xs
        else : (add(xs-locs,next(fregs)), reg-xs)
  SplitLocs(to-list(reg-xs), to-list(mem-xs), to-list(xs-locs))

defn split-call-locs-shadow (xs:List<Imm>, arity:Int, reg-ns:List<Int>, freg-ns:List<Int>,
                             shadow: Imm -> Var) :
  val regs = seq(Reg, reg-ns)
  val fregs = seq(FReg, freg-ns)
  val argcount = to-seq(0 to arity)
  val reg-xs = Vector<Imm>()
  val mem-xs = Vector<Imm>()
  val xs-locs = Vector<Loc>()
  for x in xs do :
    val vararg? = if empty?(argcount) : true
                  else : (next(argcount), false)
    match(type(x)) :
      (t:TGIntegerT) :
        if empty?(regs) :                          ;If no more integer registers
          add(mem-xs, x)                           ;  then mem argument
        else :                                     ;Otherwise
          add(xs-locs, next(regs))                 ;  place in integer register
          add(reg-xs, x)                           ;
          next(fregs)                              ;  eat real register
      (t:TGRealT) :                                ;
        if empty?(fregs) :                         ;If no more real registers
          add(mem-xs, x)                           ;  then mem argument
        else :                                     ;Otherwise
          add(xs-locs, next(fregs))                ;  place in real register
          add(reg-xs, x)                           ;
          if vararg? :                             ;  If vararg
            add(xs-locs, next(regs))               ;    place shadow in integer register
            add(reg-xs, shadow(x))                 ;
          else :                                   ;  Otherwise
            next(regs)                             ;    eat integer register
  SplitLocs(to-list(reg-xs), to-list(mem-xs), to-list(xs-locs))

defn split-match-locs (xs:List<Imm>, num-regs:Int) :
  val regs = to-seq(0 to num-regs - 2) ;R0,R1 are scratch
  val imm-xs = Vector<Imm>()
  val mem-xs = Vector<Imm>()
  for x in xs do :
    match(x:Var) :
      if empty?(regs) :
        add(mem-xs, x)
      else :
        add(imm-xs, x)
        next(regs)
    else :
      add(imm-xs, x)
  [to-list(imm-xs), to-list(mem-xs)]

;<normalize>

;============================================================
;================= Critical Edge Removal ====================
;============================================================

defn remove-critical-edges () :
  ;Count predecessors
  val num-preds-table = Array<Int>(nblocks(),0)
  for (b in BLOCKS, i in 0 to false) do :
    for n in next(b) do :
      num-preds-table[n] = 1 + num-preds-table[n]

  ;Create safe blocks
  defn safe-block (n:Int) :
    add(BLOCKS, Block(Vector<Ins>(), List(n)))
    length(BLOCKS) - 1

  ;Create safe blocks for critical edges
  for (blk in BLOCKS, b in 0 to false) do :
    if length(next(blk)) > 1 :
      val next* = for n in next(blk) map :
        if num-preds-table[n] > 1 : safe-block(n)
        else : n
      BLOCKS[b] = Block(ins(blk), next*)

;============================================================
;================== Reverse Post Ordering ===================
;============================================================
defn reverse-post-order () :
  ;Compute ordering
  val blocks = Vector<Block>()
  val mapping = IntTable<False|Int>()
  let order (n:Int = 0) :
    if not key?(mapping, n) :
      mapping[n] = false
      val blk = BLOCKS[n]
      do(order, next(blk))
      mapping[n] = length(blocks)
      add(blocks, blk)

  ;if flag-defined?(`PRINT-REG-ALLOC) :
  ;  println("Reverse post order mapping:")
  ;  do(println, mapping)

  ;New mapping
  val num-blocks = length(blocks)
  defn next* (b:Block) :
    for n in next(b) map :
      val i = mapping[n] as Int
      num-blocks - 1 - i

  ;Update block list
  clear(BLOCKS)
  for b in in-reverse(blocks) do :
    add(BLOCKS, Block(ins(b), next*(b)))

;============================================================
;================= Compute Predecessors =====================
;============================================================
defn compute-predecessors () :
  clear(PREDECESSORS, nblocks(), List())
  for (b in BLOCKS, i in 0 to false) do :
    for n in next(b) do :
      PREDECESSORS[n] = cons(i, PREDECESSORS[n])

;============================================================
;==================== Two Index Map =========================
;============================================================

deftype BitMatrix
defmulti get (m:BitMatrix, r:Int, c:Int) -> True|False
defmulti set (m:BitMatrix, r:Int, c:Int, v:True|False) -> False

public defn BitMatrix (rows:Int, cols:Int) :
  val n = rows * cols
  if n >= 0 and n < 8 * 1024 * 1024 :
    val array = BitArray(rows * cols, false)
    new BitMatrix :
      defmethod get (this, r:Int, c:Int) : array[r * cols + c]
      defmethod set (this, r:Int, c:Int, v:True|False) : array[r * cols + c] = v
  else :
    val hashset = HashSet<Long>()
    new BitMatrix :
      defmethod get (this, r:Int, c:Int) :
        hashset[cat-ints(r,c)]
      defmethod set (this, r:Int, c:Int, v:True|False) :
        if v : add(hashset, cat-ints(r,c))
        else : remove(hashset, cat-ints(r,c))
        false

lostanza defn cat-ints (a:ref<Int>, b:ref<Int>) -> ref<Long> :
  return new Long{(a.value << 32L) | b.value}

;============================================================
;================== Liveness Analysis =======================
;============================================================

defstruct VarUse :
  block: Int
  dist: Int

defn liveness-analysis () :
  ;Clear state
  val var-uses = Array<List<VarUse>>(nvars(), List())
  val block-defs = BitMatrix(nblocks(), nvars())

  ;Mark uses and defs
  for (blk in BLOCKS, i in 0 to false) do :
    ;Marking functions
    defn mark-defined (v:Var) : block-defs[i, n(v)] = true
    defn defined? (v:Var) : block-defs[i, n(v)]
    defn mark-used (v:Var, d:Int) :
      if not defined?(v) :
        val use = VarUse(i,d)
        var-uses[n(v)] = cons(use, var-uses[n(v)])
    ;Mark instructions
    for (e in ins(blk), i in 0 to false) do :
      do-used(mark-used{_, i}, e)
      do-defined(mark-defined, e)

  ;Propagate liveness
  clear(IN-PORTS, nblocks(), List())
  clear(OUT-PORTS, nblocks(), List())
  val in-dists = Array<Int>(nblocks(), INT-MAX)
  val out-dists = Array<Int>(nblocks(), INT-MAX)
  val in-dirty = Vector<Int>()
  val out-dirty = Vector<Int>()

  ;For each variable
  for (v in 0 to nvars(), uses in var-uses) do :
    if not empty?(uses) :
      ;Mark all usages of the variable
      clear(in-dirty)
      clear(out-dirty)
      for use in uses do :
        mark-live-in(block-defs, in-dists, out-dists, in-dirty, out-dirty,
                     block(use), v, dist(use))
      ;Record all live in ports
      for b in in-dirty do :
        val p = Port(v, false, false, false, in-dists[b])
        IN-PORTS[b] = cons(p, IN-PORTS[b])
        in-dists[b] = INT-MAX
      ;Record all live in ports
      for b in out-dirty do :
        val p = Port(v, false, false, false, out-dists[b])
        OUT-PORTS[b] = cons(p, OUT-PORTS[b])
        out-dists[b] = INT-MAX

;Mark that variable v is live-in to block b with distance d
lostanza defn mark-live-in (defs:ref<BitMatrix>,
                            in-dists:ref<Array<Int>>,
                            out-dists:ref<Array<Int>>,
                            in-dirty:ref<Vector<Int>>,
                            out-dirty:ref<Vector<Int>>,
                            b:ref<Int>,
                            v:ref<Int>,
                            d:ref<Int>) -> ref<False> :
  ;Only mark if distance is smaller
  val old-value = get(in-dists, b).value
  if d.value >= old-value : return false
  set(in-dists, b, d)

  ;Note that block b has been marked
  if old-value == INT-MAX.value :
    add(in-dirty, b)

  ;Loop through all predecessors of block
  ;and mark variable v as live-out from them
  labels :
    begin :
      goto loop(get(PREDECESSORS, b))
    loop (preds:ref<List<Int>>) :
      if empty?(preds) == false :
        mark-live-out(defs, in-dists, out-dists, in-dirty, out-dirty, head(preds), v, d)
        goto loop(tail(preds))

  ;Done
  return false


;Mark that variable v is live-out from block b with distance d
lostanza defn mark-live-out (defs:ref<BitMatrix>,
                             in-dists:ref<Array<Int>>,
                             out-dists:ref<Array<Int>>,
                             in-dirty:ref<Vector<Int>>,
                             out-dirty:ref<Vector<Int>>,
                             b:ref<Int>,
                             v:ref<Int>,
                             d:ref<Int>) -> ref<False> :
  ;Only mark if distance is smaller
  val old-value = get(out-dists, b).value
  if d.value >= old-value : return false
  set(out-dists, b, d)

  ;Note that block b has been marked
  if old-value == INT-MAX.value :
    add(out-dirty, b)

  ;Mark variable v as live-in to block if not defined in block
  if get(defs, b, v) == false :
    val d* = new Int{d.value + length(ins(get(BLOCKS, b))).value}
    mark-live-in(defs, in-dists, out-dists, in-dirty, out-dirty, b, v, d*)

  ;Done
  return false

;============================================================
;===================== Add Annotations ======================
;============================================================

defn add-annotations () :
  do(add-annotations, BLOCKS, 0 to false)
  
  ;Sanity check
  val p0 = IN-PORTS[0]  
  if not empty?(p0) :
    fatal("Variables %, are live upon entry." % [seq(n, p0)])  

defn add-annotations (blk:Block, b:Int) :
  ;===========================
  ;==== Liveness Tracking ====
  ;===========================
  val usages = Array<False|Int>(nvars(), false)
  val live-dirty = Vector<Int>()

  defn mark-used (n:Int, dist:Int) :
    add(live-dirty, n)
    usages[n] = dist

  defn mark-defined (n:Int) :
    usages[n] = false

  defn live? (n:Int) :
    usages[n] is Int

  defn do-live (f: Int -> ?) :
    for x in live-dirty remove-when :
      if live?(x) : (f(x), false)
      else : true

  ;=============================
  ;==== Preference Tracking ====
  ;=============================
  ;The remaining code prefers the variable to be loaded.
  val prefers-load = Array<True|False>(nvars(), true)

  ;The remaining code expects the variable to be saved.
  val requires-save = Array<True|False>(nvars(), false)

  ;============================
  ;==== Instruction Buffer ====
  ;============================
  val instructions = Vector<Ins>()
  defn emit (e:Ins) : add(instructions, e)

  ;==========================
  ;==== Port Information ====
  ;==========================
  defn annotate (p:Port) :
    val v = n(p)
    Port(v, requires-save[v], prefers-load[v], reg(p), dist(p))

  ;===================
  ;==== Algorithm ====
  ;===================
  ;Note usages of output ports
  val num-ins = length(ins(blk))
  for p in OUT-PORTS[b] do :
    mark-used(n(p), num-ins + dist(p))

  for (e in in-reverse(ins(blk)), i in (num-ins - 1) through 0 by -1) do :
    ;Return true if e is a dead Def instruction?
    defn dead-def? (e:Ins) :
      match(e:Def) :
        not live?(n(x(e)))
      
    ;Notate next usages of variables
    for x in e do-vars :
      if live?(n(x)) :
        emit(NextUsed(n(x), usages[n(x)] as Int))
        
    if not dead-def?(e) :    
      reverse-sweep(e
        ;Defined
        fn (x:Var):
          ;Unload the variable if it is never used
          if not live?(n(x)) :
            emit(Unload(n(x)))
          ;Otherwise unload the variable if it doesn't prefer to be loaded.
          else if not prefers-load[n(x)] :
            emit(Unload(n(x)))
          ;Save the variable if it needs to be saved
          if requires-save[n(x)] :
            emit(Save(x))
          ;Variable is no longer live
          mark-defined(n(x))
          requires-save[n(x)] = false
          prefers-load[n(x)] = false
        ;Emit
        fn (e:Ins) :
          val killed = to-list(filter({not live?(_)}, used-vars(e)))
          emit(attach-killed(e, to-list(killed)))
          ;Cross call boundary
          match(e:Call) :
            do-live $ fn (x) :
              requires-save[x] = true
              prefers-load[x] = false
        ;Used
        fn (x:Var) :
          mark-used(n(x), i)
          prefers-load[n(x)] = true)

  ;Update block/ports
  reverse!(instructions)
  BLOCKS[b] = Block(instructions, next(blk))
  IN-PORTS[b] = map(annotate, IN-PORTS[b])

;============================================================
;===================== Allocate Classes =====================
;============================================================

defn allocate-classes (backend:Backend) :
  for (blk in BLOCKS, b in 0 to false) do :
    allocate-classes(blk, b, backend)

defn allocate-classes (blk:Block, b:Int, backend:Backend) :
  ;================================
  ;==== Free Register Tracking ====
  ;================================
  ;Track number of registers used
  var num-free-reg = num-regs(backend)
  var num-free-freg = num-fregs(backend)
  defn inc-reg (n:Int, delta:Int) :
    match(VAR-TYPES[n]) :
      (t:VMType&IntegerT) : num-free-reg = num-free-reg + delta
      (t:VMType&RealT) : num-free-freg = num-free-freg + delta
  defn num-free (integer?:True|False) :
    if integer? : num-free-reg
    else : num-free-freg

  ;============================
  ;==== Load/Save Tracking ====
  ;============================
  ;Track whether a variable has been loaded/saved
  val loaded = BitArray(nvars())
  val saved = BitArray(nvars())
  val dirty-loaded = Vector<Int>()
  ;Mark variable n as loaded, returns true if the variable wasn't
  ;already loaded.
  defn mark-loaded (n:Int) -> True|False :
    if not loaded[n] :
      add(dirty-loaded, n)
      loaded[n] = true
      inc-reg(n, -1)
      true
  defn mark-unloaded (n:Int) -> True|False :
    if loaded[n] :
      loaded[n] = false
      inc-reg(n, 1)
      true
  defn mark-saved (n:Int) -> True|False :
    if not saved[n] :
      saved[n] = true
      true
  defn mark-defined (n:Int) -> False :
    mark-loaded(n)
    saved[n] = false
  ;Return all currently loaded variables
  defn loaded-vars () -> Seq<Int> :
    filter({loaded[_]}, dirty-loaded)
  ;Mark all variables as unloaded
  defn mark-all-unloaded () :
    do(mark-unloaded, loaded-vars())
    clear(dirty-loaded)

  ;========================
  ;==== Usage Tracking ====
  ;========================
  val usages = Array<Int|False>(nvars(), false)
  defn mark-next-use (n:Int, pos:Int) :
    usages[n] = pos
  defn next-use (n:Int) :
    usages[n]

  ;=================
  ;==== Actions ====
  ;=================
  defn add?<?T> (xs:False|Vector<?T>, x:T) :
    match(xs:Vector<T>) : add(xs, x)
  defn ensure-saved (n:Int, buffer:False|Vector<Ins>) :
    add?(buffer, Save(Var(n))) when mark-saved(n)
  defn ensure-loaded (n:Int, buffer:False|Vector<Ins>) :
    add?(buffer, Load(Var(n))) when mark-loaded(n)
  defn ensure-unloaded (n:Int, buffer:False|Vector<Ins>) :
    add?(buffer, Unload(n)) when mark-unloaded(n)

  ;==================
  ;==== Spilling ====
  ;==================
  ;Find next variable to spill
  defn next-spill-var (integer?:True|False) :
    defn right-type? (n:Int) :
      if integer? : VAR-TYPES[n] is VMType&IntegerT
      else : VAR-TYPES[n] is VMType&RealT
    argmax(next-use, filter(right-type?, loaded-vars()))
  ;Spill one register
  defn spill-reg (integer?:True|False, buffer:False|Vector<Ins>) :
    val v = next-spill-var(integer?)
    ensure-saved(v, buffer)
    ensure-unloaded(v, buffer)
  ;Ensure free register for var
  defn ensure-reg-for-var (n:Int, buffer:False|Vector<Ins>) :
    if not loaded[n] :
      val int? = VAR-TYPES[n] is VMType&IntegerT
      if num-free(int?) < 1 :
        spill-reg(int?, buffer)

  ;==========================
  ;==== Port Information ====
  ;==========================
  defn annotate (p:Port) :
    val v = n(p)
    Port(v, saved[v], loaded[v], reg(p), dist(p))

  ;===================
  ;==== Algorithm ====
  ;===================
  ;Load as many input ports into registers as possible
  for p in IN-PORTS[b] do :
    val v = n(p)
    mark-loaded(v) when loaded?(p)
    mark-saved(v) when saved?(p)
    mark-next-use(v, dist(p))
  ;Spill overcommitted registers
  while num-free-reg < 0 : spill-reg(true, false)
  while num-free-freg < 0 : spill-reg(false, false)
  ;Annotate input ports
  IN-PORTS[b] = map(annotate, IN-PORTS[b])

  ;Sweep through instructions
  val instructions = Vector<Ins>()
  val buffer = Vector<Ins>()
  for e in ins(blk) do :
    match(e) :
      (e:NextUsed) :
        mark-next-use(n(e), pos(e))
      (e:Unload) :
        ensure-unloaded(n(e), instructions)
      (e:Save) :
        ensure-saved(n(x(e)), instructions)
      (e:Match) :
        ;Load arguments
        for x in e do-used :
          ensure-reg-for-var(n(x), instructions)
          ensure-loaded(n(x), instructions)
        ;Reserve scratch registers
        while num-free-reg < 2 :
          spill-reg(true, instructions)
        ;Emit instruction
        add(instructions, e)        
      (e) :
        ;Load arguments
        for x in e do-used :
          ensure-reg-for-var(n(x), instructions)
          ensure-loaded(n(x), buffer)
        ;Emit instruction
        add(buffer, e)
        ;Unload registers
        match(e:Call) : mark-all-unloaded()
        else : do(mark-unloaded, killed(e))
        ;Define new variables
        for x in e do-defined :
          ensure-reg-for-var(n(x), instructions)
          mark-defined(n(x))
        ;Flush buffer instructions
        add-all(instructions, buffer)
        clear(buffer)

  ;Update block and output ports
  BLOCKS[b] = Block(instructions, next(blk))
  OUT-PORTS[b] = map(annotate, OUT-PORTS[b])

;Utility
defn argmax<?T> (f:T -> False|Int, xs:Seqable<?T>) -> T :
  var best-x
  var best-v = INT-MIN
  for x in xs do :
    val v = f(x)
    match(v:Int) :
      if v > best-v :
        best-x = x
        best-v = v
  best-x

;============================================================
;================== Register Assignment =====================
;============================================================

;=======================
;==== Free Register ====
;=======================
defstruct FreeReg <: Loc :
  prefer: List<Int>

defn FreeReg () :
  FreeReg(List())

defn PrefReg (xs:List<Imm>) :
  val regs = for x in xs seq? :
    match(x:Var) :
      match(reg?(x)) :
        (r:Reg|FReg) : One(n(r))
        (r:False) : None()
    else : None()
  FreeReg(to-list(regs))

defn PrefReg (x:Imm) :
  PrefReg(List(x))

defmethod print (o:OutputStream, r:FreeReg) :
  print(o, "FreeReg(%,)" % [prefer(r)])

;===================
;==== Algorithm ====
;===================
defn register-assignment (backend:Backend) :
  for (blk in BLOCKS, b in 0 to false) do :
    register-assignment(blk, b, backend)

defn register-assignment (blk:Block, b:Int, backend:Backend) :
  ;============================
  ;==== Instruction Buffer ====
  ;============================
  val instructions = Vector<Ins>()
  defn emit (e:Ins) : add(instructions ,e)

  ;===========================
  ;==== Register Tracking ====
  ;===========================
  val var-locs = Array<False|Reg|FReg>(nvars(), false)
  val reg-slots = Array<False|Int>(num-regs(backend), false)
  val freg-slots = Array<False|Int>(num-fregs(backend), false)
  val reg-list = FreeList(num-regs(backend))
  val freg-list = FreeList(num-fregs(backend))

  ;Set and retrieve variable occupying a register      
  defn free-slot (r:Reg|FReg) :
    match(r) :
      (r:Reg) : (reg-slots[n(r)] = false, remove(reg-list, n(r)))
      (r:FReg) : (freg-slots[n(r)] = false, remove(freg-list, n(r)))

  defn assign-slot (r:Reg|FReg, x:Int) :
    match(r) :
      (r:Reg) : (reg-slots[n(r)] = x, add(reg-list, n(r)))
      (r:FReg) : (freg-slots[n(r)] = x, add(freg-list, n(r)))

  defn slot (r:Reg|FReg) :
    match(r) :
      (r:Reg) : reg-slots[n(r)]
      (r:FReg) : freg-slots[n(r)]

  ;Retrieve register listing
  defn all-regs (t:VMType) :
    match(t:VMType&IntegerT) : seq(Reg, cat(free(reg-list), reg-list))
    else : seq(FReg, cat(free(freg-list), freg-list))

  ;Free the variable x from its register, if it is in one
  defn free-var (x:Int) :
    match(var-locs[x]) :
      (reg:Reg|FReg) :
        free-slot(reg)
        var-locs[x] = false
      (reg:False) :
        false

  ;Free the contents of a register
  defn free-reg (r:Reg|FReg) :
    match(slot(r)) :
      (v:Int) :
        free-slot(r)
        var-locs[v] = false
      (v:False) :
        false

  ;Free all registers
  defn free-all-regs () :
    for n in reg-list do :
      val v = reg-slots[n] as Int
      reg-slots[n] = false
      var-locs[v] = false
    for n in freg-list do :
      val v = freg-slots[n] as Int
      freg-slots[n] = false
      var-locs[v] = false
    clear(reg-list)
    clear(freg-list)

  ;Find an available register (assumes that one is available).
  defn free-reg? (t:VMType) :
    match(t) :
      (t:VMType&IntegerT) :
        val rs = free(reg-list)
        Reg(next(rs)) when not empty?(rs)
      (t:VMType&RealT) :
        val rs = free(freg-list)
        FReg(next(rs)) when not empty?(rs)    
  defn available-reg? (t:VMType, pref:List<Int>) :
    val pref-regs = seq(XReg{t, _}, pref)
    val r = find({slot(_) is False}, pref-regs)
    match(r:Reg|FReg) : r
    else : free-reg?(t)
  defn available-reg (t:VMType, pref:List<Int>) :
    available-reg?(t,pref) as Reg|FReg

  ;Assign a variable to a location
  defn assign (x:Int, r:Loc) :
    match(r) :
      (r:Reg|FReg) :
        fatal("Register %_ is occupied" % [r]) when slot(r) is-not False
        var-locs[x] = r
        assign-slot(r, x)
      (r:FreeReg) :
        assign(x, available-reg(VAR-TYPES[x], prefer(r)))

  ;Convenience
  defn assign (x:Var|Port, r:Loc) :
    assign(n(x), r)
  defn assign (xs:List<Var|Port>, r:Loc) :
    do(assign{_, r}, xs)

  ;Assign several locations
  defn assign (xs:List<Var|Port>, rs:List<Loc>) :
    for (x in xs, r in rs) do :
      assign(x, r) when r is-not FreeReg
    for (x in xs, r in rs) do :
      assign(x, r) when r is FreeReg

  ;==============================
  ;==== Port/Var Information ====
  ;==============================
  defn annotate (p:Port) :
    var reg = var-locs[n(p)]
    Port(n(p), saved?(p), reg is Reg|FReg, reg, dist(p))
  defn annotate<?T> (x:?T&Imm) -> T :
    match(x:Var) : Var(n(x), var-locs[n(x)]) as T&Imm
    else : x

  ;===========================
  ;==== Register Swapping ====
  ;===========================
  ;Move contents of src into dst.
  ;If dst is occupied, then swap the contents of the two registers.
  defn swap-reg (src:Reg|FReg, dst:Reg|FReg) :    
    val x = slot(src) as Int
    match(slot(dst)) :
      ;Dst is unoccupied: Emit move
      (y:False) :
        emit(Set(Var(x,dst), Var(x,src)))
        free-var(x)
        assign(x,dst)
      ;Dst is occupied: Emit swap
      (y:Int) :
        match(src:Reg) :
          emit(Xchg(Var(x,src), Var(y,dst), false))
        else :        
          val swap = available-reg?(VMFloat(), List())
          emit(Xchg(Var(x,src), Var(y,dst), swap))        
        free-var(x)
        free-var(y)
        assign(x,dst)
        assign(y,src)

  ;Ensure that regs will be available once xs are freed
  defn ensure-available (regs:List<Reg|FReg>, xs:List<Int>) :
    ;Will be available
    defn available? (r:Reg|FReg) :
      match(slot(r)) :
        (x:Int) : contains?(xs,x)
        (x:False) : true
    ;Swap candidates
    defn safe-swap? (r:Reg|FReg) :
      available?(r) and not contains?(regs, r)

    ;Compute swap registers
    val swaps = lazy(filter{safe-swap?, all-regs(VMInt())})
    val fswaps = lazy(filter{safe-swap?, all-regs(VMFloat())})
      
    ;Swap out registers
    for r in regs do :
      if not available?(r) :
        swap-reg{r, next(_)} $
          match(r:Reg) : swaps()
          else : fswaps()

  ;Ensure that value x is in register r
  defn ensure-location (x:Int, reg:Reg|FReg) :
    val src = var-locs[x] as Reg|FReg
    swap-reg(src, reg) when src != reg

  ;===================
  ;==== Shuffling ====
  ;===================
  defn par-mov (xs:List<Loc>, ys:List<Var>) :
    ;Categorize
    val shuffles = Vector<KeyValue<Int,Int>>() ;dst => src
    val fshuffles = Vector<KeyValue<Int,Int>>() ;dst => src
    for (x in xs, y in ys) do :
      match(x) :
        (x:Reg) : add(shuffles, n(x) => n(reg(y)))
        (x:FReg) : add(fshuffles, n(x) => n(reg(y)))
    ;Emit shuffles
    emit(ShuffleReg(keys(shuffles), values(shuffles)))
    emit(ShuffleFReg(keys(fshuffles), values(fshuffles)))
    ;Update table
    do(free-reg, xs as List<Reg|FReg>) ;Free all destination registers
    do(free-var{n(_)}, ys)             ;Free all source variables
    assign(ys, xs)                     ;Assign to destination registers

  ;===================
  ;==== Algorithm ====
  ;===================
  ;Assign input ports
  val in-ports = IN-PORTS[b]
  if not empty?(in-ports) :
    ;Retrieve output ports of predecessor block
    val pred = find!({_ < b}, PREDECESSORS[b])
    val port-table = Array<Port>(nvars())
    for p in OUT-PORTS[pred] do : port-table[n(p)] = p
    ;Calculate port locations
    val port-assigns = to-list $ for p in in-ports seq? :
      match(loaded?(p), reg(port-table[n(p)])) :
        (l1:True, r:Reg|FReg) : One(p => r)
        (l1:True, r:False) : One(p => FreeReg())
        (l1:False, r) : None()
    ;Assign ports
    assign(map(key, port-assigns), map(value, port-assigns))
    IN-PORTS[b] = map(annotate, in-ports)

  ;Constants
  val list-r0-r1 = List(Reg(0), Reg(1))

  ;Sweep through instructions
  for e in ins(blk) do :
    println("Allocating: %_" % [e])
    match(e) :
      (e:Def) :
        assign(x(e), FreeReg())
        emit(Def(annotate(x(e)), killed?(e)))
      (e:Set) :
        val y* = annotate(y(e))
        do(free-var, killed(e))
        assign(x(e), PrefReg(y*))
        emit(Set(annotate(x(e)), y*, killed?(e)))
      (e:Branch) :
        emit(Branch(op(e), map(annotate, xs(e)), killed?(e)))
        do(free-var, killed(e))
      (e:Return) :
        par-mov(regs(ctxt(e)), map(annotate,xs(e)) as List<Var>)
        val xs* = map(annotate, xs(e))
        emit(Return(xs*, ctxt(e), killed?(e)))
        do(free-var, killed(e))
      (e:Args) :
        do(free-var, killed(e))
        assign(xs(e), regs(ctxt(e)))
        emit(Args(map(annotate,xs(e)), ctxt(e), killed?(e)))
      (e:Call) :
        val f* = annotate(f(e))
        val ys* = map(annotate,ys(e)) as List<Var>
        ;Move arguments into place
        match(f*) :
          (f*:Var) :
            val freg = func-reg(type(e)) as Reg
            par-mov(cons(freg, arg-regs(type(e))), cons(f*,ys*))
          (f*:Val) :
            par-mov(arg-regs(type(e)), ys*)
        ;New shuffled arguments
        val f** = annotate(f(e))
        val ys** = map(annotate, ys(e))
        ;Free all registers
        free-all-regs()
        ;Move return values into place
        assign(xs(e), ret-regs(type(e)))
        ;Emit
        emit(Call(map(annotate,xs(e)), f**, ys**, type(e), killed?(e)))
      (e:Save) :
        emit(Save(annotate(x(e))))
      (e:Load) :
        assign(x(e), FreeReg())
        emit(Load(annotate(x(e))))
      (e:Unload) :
        free-var(n(e))
      (e:Match) :
        ensure-available(list-r0-r1, List())
        val xs* = map(annotate, xs(e))
        do(free-var, killed(e))
        emit(Match(dispatch?(e), type-lists(e), xs*, locs(e), killed?(e), ns?(e)))
      (e:MethodDispatch) :
        emit(e)
      (e:Op) :
        defn assign-prefs (pref:List<Imm> -> Loc|List<Loc>) :
          val ys* = map(annotate, ys(e))
          do(free-var, killed(e))
          assign(xs(e), pref(ys*))
          val xs* = map(annotate, xs(e))
          emit(Op(op(e), xs*, ys*, killed?(e)))
        defn assign-prefs (loc:Loc|List<Loc>) :
          assign-prefs({loc})

        match(op(e)) :
          ;Prefers first argument
          (op:SubOp|DivOp|ModOp) :
            assign-prefs(PrefReg{head(_)})
          ;Prefers any argument
          (op:LoadOp|AddOp|MulOp|AndOp|OrOp|XorOp|
              NotOp|NegOp|ConvOp|InterpretOp) :
            assign-prefs(PrefReg)
          ;Second argument in R2, prefer first argument
          (op:ShlOp|ShrOp|AshrOp) :
            val y = ys(e)[1]
            match(y:Var) : ensure-location(n(y), Reg(2))
            assign-prefs(PrefReg{head(_)})
          ;Requires R0,R3
          (op:DivModOp) :
            val rs = List(Reg(0), Reg(3))
            ensure-available(rs, killed(e))
            assign-prefs(rs)
          ;Noop
          (op:NoOp) :
            do(free-var, killed(e))
          ;Any register will do
          (op) :
            assign-prefs(FreeReg())
      (e) :
        fatal("%_ not supported." % [e])

  ;Update block/ports
  BLOCKS[b] = Block(instructions, next(blk))
  OUT-PORTS[b] = map(annotate, OUT-PORTS[b])

;============================================================
;==================== Stack Intervals =======================
;============================================================

;=======================
;==== Datastructure ====
;=======================

deftype Interval
defstruct StartInterval <: Interval : (n:Int)
defstruct EndInterval <: Interval : (n:Int)

defmethod print (o:OutputStream, i:Interval) :
  print{o, _} $ match(i) :
    (i:StartInterval) : "V%_ starts" % [n(i)]
    (i:EndInterval) : "V%_ ends" % [n(i)]

;===================
;==== Algorithm ====
;===================

defn stack-intervals () -> Seq<Interval> :
  ;========================
  ;==== Port Positions ====
  ;========================
  val in-port-pos = Array<Int>(nblocks())
  val out-port-pos = Array<Int>(nblocks())
  val num-pos = let :
    val pos-counter = Counter(0)
    for (blk in BLOCKS, b in 0 to false) do :
      in-port-pos[b] = next(pos-counter, 1 + length(ins(blk)))
      out-port-pos[b] = value(pos-counter)
    value(pos-counter) + 1

  ;===========================
  ;==== Interval Tracking ====
  ;===========================
  val var-start = Array<Int>(nvars(), INT-MAX)
  val var-end = Array<Int>(nvars(), INT-MIN)

  defn note-usage (v:Int, i:Int) :
    var-start[v] = min(i, var-start[v])
    var-end[v] = max(i, var-end[v])

  defn note-in-port-usage (b:Int, v:Int) :
    note-usage(v, in-port-pos[b])
    for b in PREDECESSORS[b] do :
      note-usage(v, out-port-pos[b])

  defn note-out-port-usage (b:Int, v:Int) :
    note-usage(v, out-port-pos[b])
    for b in next(BLOCKS[b]) do :
      note-usage(v, in-port-pos[b])

  defn sorted-intervals () :
    val ints = Array<List<Interval>>(num-pos, List())
    defn add-interval (i:Int, x:Interval) :
      ints[i] = cons(x, ints[i])
    for v in 0 to nvars() do :
      if var-start[v] <= var-end[v] :
        add-interval(var-end[v], EndInterval(v))
    for v in 0 to nvars() do :
      if var-start[v] <= var-end[v] :
        add-interval(var-start[v], StartInterval(v))
    cat-all(ints)

  ;===================
  ;==== Algorithm ====
  ;===================
  val pos-counter = Counter(0)
  for (blk in BLOCKS, b in 0 to false) do :
    ;In port usages
    for p in IN-PORTS[b] do :
      note-in-port-usage(b, n(p)) when saved?(p)
    next(pos-counter, 1)

    ;Instruction usages
    for e in ins(blk) do :
      val pos = next(pos-counter, 1)
      match(e) :
        (e:Save) : note-usage(n(x(e)), pos)
        (e:Load) : note-usage(n(x(e)), pos)
        (e:Op) :
          match(op(e)) :
            (op:RecordLiveOp) : do(note-usage{n(_), pos}, live-vars(op))
            (op) : false
        (e) : false

    ;Out port usages
    for p in OUT-PORTS[b] do :
      note-out-port-usage(b, n(p)) when saved?(p)

  ;Return intervals
  sorted-intervals()

;============================================================
;===================== Stack Map ============================
;============================================================

deftype StackMap
defmulti location (m:StackMap, n:Int) -> False|Int
defmulti offset (m:StackMap, n:Int) -> Int
defmulti locations (m:StackMap) -> Vector<VMType>
defmulti offsets (m:StackMap) -> Vector<Int>
defmulti size (m:StackMap) -> Int

defn int-type-matching-size (t:VMType) :
  match(t) :
    (t:VMFloat) : VMInt()
    (t:VMDouble) : VMLong()
    (t:VMType&IntegerT) : t

defn stack-map () :
  ;===========================
  ;==== Location Tracking ====
  ;===========================
  val occupied-locs = Vector<True|False>()
  val loc-types = Vector<VMType>()
  val var-locs = Array<False|Int>(nvars(), false)

  ;Get next available location
  defn available-loc (t:VMType) :
    val t* = int-type-matching-size(t)
    val n = length(occupied-locs)
    val i = for i in 0 to n find :
      (not occupied-locs[i]) and
      (loc-types[i] == t*)
    match(i) :
      (i:Int) :
        i
      (i:False) :
        add(occupied-locs, false)
        add(loc-types, t*)
        n

  ;Place variable v in location loc
  defn assign-var (v:Int, loc:Int) :
    var-locs[v] = loc
    occupied-locs[loc] = true

  ;Release variable v from its location
  defn release-var (v:Int) :
    val l = var-locs[v] as Int
    occupied-locs[l] = false

  ;===================
  ;==== Algorithm ====
  ;===================
  for int in stack-intervals() do :
    match(int) :
      (int:StartInterval) :
        val t = VAR-TYPES[n(int)]
        assign-var(n(int), available-loc(t))
      (int:EndInterval) :
        release-var(n(int))

  ;=====================================
  ;==== Size and Offset Computation ====
  ;=====================================
  val offsets = Vector<Int>()
  val stack-size = let :
    val [padded, alignment] = pad(size, size, loc-types, 8)
    val offset-counter = Counter(16) ;RET + STACK-MAP
    for x in padded do :
      match(x) :
        (x:Padding) : next(offset-counter, size(x))
        (x:VMType) : add(offsets, next(offset-counter, size(x)))
    value(offset-counter)

  ;Return Map
  new StackMap :
    defmethod location (this, n:Int) : var-locs[n]
    defmethod locations (this) : loc-types
    defmethod offsets (this) : offsets
    defmethod size (this) : stack-size
    defmethod offset (this, n:Int) : offsets[var-locs[n] as Int]

defmethod print (o:OutputStream, s:StackMap) :
  ;Discover vars per location
  val vars = Array<List<Int>>(length(locations(s)), List())
  for v in 0 to nvars() do :
    val loc = location(s, v)
    match(loc:Int) :
      vars[loc] = cons(v, vars[loc])
  ;Print
  print(o, "Stackmap:")
  for (t in locations(s), i in 0 to false) do :
    defn V# (i:Int) : "V%_" % [i]
    print(o, "\n  loc %_ : %_ (%,)" % [i, t, seq(V#, vars[i])])

defn num-locations (s:StackMap) :
  length(locations(s))

defn refmask (s:StackMap) :
  val mask = Array<True|False>(size(s) / 8, false)
  for (t in locations(s), offset in offsets(s)) do :
    match(t:VMRef) : mask[offset / 8] = true
  [length(mask), to-bitmask(mask)]

defn ref-offsets (s:StackMap) :
  for (offset in offsets(s), t in locations(s)) filter :
    t is VMRef
    


;============================================================
;==================== Shuffling Engine ======================
;============================================================

;=====================
;==== Root Finder ====
;=====================
defn roots (nreg:Int, xs:List<Int>, ys:List<Int>) :
  ;Compute all sources
  val srcs = Array<False|Int>(nreg, false)
  val dsts = Array<List<Int>>(nreg, List())
  for (x in xs, y in ys) do :
    srcs[x] = y
    dsts[y] = cons(x, dsts[y])

  ;Compute the source
  val visited = Array<True|False>(nreg, false)
  defn root (x:Int) :
    visit(x)
    match(srcs[x]) :
      (s:Int) :
        if visited[s] : x
        else : root(s)
      (s:False) : x
  defn visit (x:Int) :
    if not visited[x] :
      visited[x] = true
      do(visit, dsts[x])

  ;Return all roots
  for y in ys seq? :
    if visited[y] : None()
    else : One(root(y))

;=========================================
;==== Shuffling with Swap Instruction ====
;=========================================
defn shuffle (nreg:Int, xs:List<Int>, ys:List<Int>,
              emit-move: (Int, Int) -> False
              emit-swap: (Int, Int) -> False) :
  ;Compute all destinations
  val dsts = Array<List<Int>>(nreg, List())
  for (x in xs, y in ys) do :
    dsts[y] = cons(x, dsts[y])

  val visited = Array<False|True>(nreg, false)
  defn move (src:Int) -> True|False :
    ;Mark visited
    visited[src] = true
    ;Track swapped
    var swapped? = false
    ;Move all destinations
    for dst in dsts[src] do :
      if dst != src :
        if visited[dst] :
          swapped? = true
        else if move(dst) :
          emit-swap(src, dst)
          swapped? = true
        else :
          emit-move(src, dst)
    ;Return whether swapped?
    swapped?

  ;Start from roots
  do(move, roots(nreg, xs, ys))

;======================================
;==== Shuffling with Swap Register ====
;======================================
defn shuffle (nreg:Int, xs:List<Int>, ys:List<Int>, swap:Int
              emit-move: (Int, Int) -> False) :
  ;Compute destinations
  val dsts = Array<List<Int>>(nreg, List())
  for (x in xs, y in ys) do :
    dsts[y] = cons(x, dsts[y])

  val visited = Array<False|True>(nreg, false)
  defn move (src:Int) -> True|False :
    ;Mark visited
    visited[src] = true
    ;Track whether swap used
    var swapped? = false
    ;Move all destinations
    for dst in dsts[src] do :
      if dst != src :
        if visited[dst] :
          emit-move(src, swap)
          swapped? = true
        else :
          swapped? = move(dst) or swapped?
          emit-move(src, dst)
    ;Return whether swap used?
    swapped?

  ;Start from roots
  for y in roots(nreg, xs, ys) do :
    emit-move(swap, y) when move(y)

;=========================================
;==== Shuffling without Swap Register ====
;=========================================
defn shuffle (nreg:Int, xs:List<Int>, ys:List<Int>
              emit-move: (Int, Int) -> False,
              emit-save: Int -> False,
              emit-load: Int -> False) :
  ;Find a register with no destination
  defn free? (x:Int) : not contains?(cat(xs, ys), x)
  match(find(free?, 0 to nreg)) :
    (swap:Int) :
      shuffle(nreg, xs, ys, swap, emit-move)
    (swap:False) :
      shuffle(nreg, xs, ys, -1,
        fn (src:Int, dst:Int) :
          if dst == -1 : emit-save(src)
          else if src == -1 : emit-load(dst)
          else : emit-move(src, dst))

;============================================================
;=============== Flipped Comparison Operators ===============
;============================================================

defn flip (o:VMOp) -> VMOp :
  match(o) :
    (o:EqOp) : NeOp()
    (o:NeOp) : EqOp()
    (o:LtOp) : GeOp()
    (o:GtOp) : LeOp()
    (o:LeOp) : GtOp()
    (o:GeOp) : LtOp()
    (o:UleOp) : UgtOp()
    (o:UltOp) : UgeOp()
    (o:UgtOp) : UleOp()
    (o:UgeOp) : UltOp()
    (o:FlipOp) : op(o)
    (o) : FlipOp(o)

;============================================================
;=================== Block Collapsing =======================
;============================================================

defn collapse-blocks () :
  ;============================
  ;==== Instruction Buffer ====
  ;============================
  val instructions = Vector<Ins>()
  defn emit (e:Ins) : add(instructions, e)
  defn emit (es:Seqable<Ins>) : add-all(instructions, es)

  ;===================
  ;==== Port Glue ====
  ;===================
  ;Perform xs = ys in parallel
  defn glue-ports (xs:List<Port>, ys:List<Port>) :
    ;Instructions buffers
    val saves = Vector<Ins>()
    val loads = Vector<Ins>()
    val shuffles = Vector<KeyValue<Int,Int>>()
    val fshuffles = Vector<KeyValue<Int,Int>>()

    ;Populate port table
    val port-table = Array<Port>(nvars())
    for y in ys do : port-table[n(y)] = y

    ;Populate instruction buffers
    for x in xs do :
      ;Retrieve corresponding port
      val y = port-table[n(x)]
      val vx = Var(n(x), reg(x))
      val vy = Var(n(y), reg(y))
      ;Saves
      match(saved?(x), saved?(y)) :
        (sx:True, sy:False) : add(saves, Save(vy))
        (sx, sy) : false
      ;Loads
      match(loaded?(x), loaded?(y)) :
        (lx:True, ly:False) : add(loads, Load(vx))
        (lx, ly) : false
      ;Shuffles
      match(reg(x), reg(y)) :
        (rx:Reg, ry:Reg) : add(shuffles, n(ry) => n(rx))
        (rx:FReg, ry:FReg) : add(fshuffles, n(ry) => n(rx))
        (rx, ry) : false

    ;Output to main instruction buffer
    emit(saves)
    emit(ShuffleReg(values(shuffles), keys(shuffles)))
    emit(ShuffleFReg(values(fshuffles), keys(fshuffles)))
    emit(loads)

  ;=======================
  ;==== Glue Location ====
  ;=======================
  defn input-glue (b:Int) :
    if length(PREDECESSORS[b]) == 1 :
      val p = head(PREDECESSORS[b])
      OUT-PORTS[p]

  defn output-glue (blk:Block) :
    if length(next(blk)) == 1 :
      val n = head(next(blk))
      if length(PREDECESSORS[n]) > 1 :
        IN-PORTS[n]
        
  ;====================
  ;==== Goto Block ====
  ;====================
  defn ends-with-goto? (blk:Block) :
    ;A block ends with a goto if it has exactly 1 successor,
    ;and its last instruction is not a jumping instruction (Branch|Match|MethodDispatch).
    if length(next(blk)) == 1 :
      if empty?(ins(blk)) :
        true
      else :
        val e = ins(blk)[length(ins(blk)) - 1]
        e is-not Branch|Match|MethodDispatch

  ;======================
  ;==== Block Labels ====
  ;======================
  val lbls = Array<Int>(nblocks())
  lbls[0 to false] = repeatedly(unique-id{})

  ;===================
  ;==== Algorithm ====
  ;===================
  for (blk in BLOCKS, b in 0 to false) do :
    ;Is block i coming up next?
    defn upcoming? (i:Int) : i == b + 1

    ;Emit block label
    emit(Label(lbls[b]))

    ;Emit entry glue
    match(input-glue(b)) :
      (ps:List<Port>) : glue-ports(IN-PORTS[b], ps)
      (ps:False) : false

    ;Emit instructions
    for e in ins(blk) do :
      match(e) :
        (e:Branch) :
          val conseq = next(blk)[0]
          val alt = next(blk)[1]
          match(upcoming?(conseq), upcoming?(alt)) :
            (a:True, b:False) :
              emit(Break(lbls[alt], flip(op(e)), xs(e)))
            (a:False, b:True) :
              emit(Break(lbls[conseq], op(e), xs(e)))
            (a:False, b:False) :
              emit(Break(lbls[conseq], op(e), xs(e)))
              emit(Goto(lbls[alt]))
        (e:Match) :
          val ns = map({lbls[_]}, next(blk))
          emit(Match(dispatch?(e), type-lists(e), xs(e), locs(e), false, ns))
        (e:Def) :
          false
        (e) :
          emit(e)

    ;Emit exit glue
    match(output-glue(blk)) :
      (ps:List<Port>) : glue-ports(ps, OUT-PORTS[b])
      (ps:False) : false
      
    ;Goto next block
    if ends-with-goto?(blk) :
      val n = head(next(blk))
      emit(Goto(lbls[n])) when not upcoming?(n)

  ;Return instruction buffer
  clear(BLOCKS)
  add(BLOCKS, Block(instructions, List()))

;============================================================
;====================== Assemble ============================
;============================================================

defn assemble (emitter:CodeEmitter, stackmap:StackMap, stubs:AsmStubs) :
  ;============================
  ;==== Assembly Utilities ====
  ;============================
  defn E (i:asm-Ins) : emit(emitter, i)  
  defn T (x:Imm) : asm-type(x)
  defn I (x:Imm) : to-asm-imm(x)
  defn V (x:Var) : to-asm-loc(x)
;  defn OP (op:TGOp) : to-asm-op(op)
;  val #stack-sp = STACK-SP-OFFSET - REF-TAG-BITS
;  val #stack-size = STACK-SIZE - REF-TAG-BITS
;
;  ;==============
;  ;==== Data ====
;  ;==============
;  #data()
;  for entry in CONSTANTS do :
;    #label(n(entry))
;    match(value(entry)) :
;      (v:String) : #defstring(v)
;      (v:Double) : #defdouble(v)
;  #text()      
;
;  ;===================
;  ;==== Stack Map ====
;  ;===================
;  val stack-map-lbl = fresh-id()
;  let :
;    val [n, bits] = refmask(stackmap)
;    #data()
;    #label(stack-map-lbl)
;    #deflong(to-long(n))
;    do(#deflong, bits)
;    #text()
;

  ;====================
  ;==== Label Pool ====
  ;====================
  val label-counter = to-seq(0 to false)
  defn make-label () : next(label-counter)
  val label-table = IntTable-init<asm-LocalMem>(asm-LocalMem{make-label()})

  ;==============
  ;==== Body ====
  ;==============
  for e in ins(BLOCKS[0]) do :
    println("Assembling: %_" % [e])
    match(e) :
      (e:Set) :
        match(y(e)) :
          (v:Val) :
            match(value(v)) :
              (v:ConstId) : load-const(id(v))
              (v) : set-value(y(e))
          (v) : set-value(v)
        where :
          defn load-const (id:Int) :
            val x = V(x(e))
            E $ LoadL(x, asm-LinkId(id))
          defn set-value (v:Imm) :
            val t = T(x(e))
            val x = V(x(e))
            val y = I(v)
            E(asm-SetIns(t, x, y)) when x != y            
      (e:Return) :
        match(ctxt(e)) :
          (c:StanzaContext) :
            E $ asm-Return()
          (c:CContext) :
            fatal("Not yet implemented")
            ;val ns = c-preserved-regs(backend)
            ;#movl(RSP, R6)
            ;for (n in ns, o in -8 to false by -8) do :
            ;  #loadl(R(n), RSP, o)
            ;#return()
      (e:Args) :
        match(ctxt(e)) :
          (ctxt:StanzaContext) :
            ;Everything is set up already
            false
          (ctxt:CContext) :
            fatal("C context not yet supported")
      (e:Call) :
        match(type(e)) :
          (t:ExtendStack) :
            val return-lbl = unique-id(stubs)
            E $ SetL(R0, M(return-lbl))
            E $ asm-Goto(M(extend-stack(stubs)))
            E $ asm-Label(return-lbl)
          (t:ExtendHeap) :
            val return-lbl = unique-id(stubs)
            E $ SetL(R0, M(return-lbl))
            E $ asm-Goto(M(extend-heap(stubs)))
            E $ asm-Label(return-lbl)
          (t:StanzaCall) :
            E $ AddL(RSP, RSP, INT(size(stackmap) + 8))
            E $ asm-Call(I(f(e)))
            match(info(t):FileInfo) :
              E $ asm-Label(unique-id(stubs), info(t))
            E $ SubL(RSP, RSP, INT(size(stackmap) + 8))
          (t:StanzaTCall) :
            E $ asm-Goto(I(f(e)))
          (t:CCall) :
            ;Given: The arguments are in the proper C registers, and all memory
            ;arguments have been saved.
            ;Our goal is to call C with the right calling convention:
            ;We need to save the current context.
            ;  - Push the stack frame
            ;  - Save the stack pointer
            ;We need to restore the C context.
            ;  - Load all the c preserved registers
            ;  - Load the c stack register
            ;Call the C function with the right convention.
            ;  - Alter the C RSP to account for arguments
            ;  - Set the number of floating point arguments
            ;  - Call the function
            ;Return to our context.
            ;  - Return to our stack
            ;  - Pop the stack frame
            
            ;Save current context:
            E $ AddL(RSP, RSP, INT(size(stackmap)))
            E $ StoreL(M(stack-pointer(stubs)), RSP)

            ;Restore the C context:
            for (i in c-preserved-regs(backend(stubs)), n in saved-c-regs(stubs)) do :
              E $ LoadL(R(i), M(n))
            E $ LoadL(RSP, M(saved-c-rsp(stubs)))
              
            ;Call C function with right convention
            val num-float-args = for y in ys(e) count : reg?(y as Var) is FReg
            E $ SubL(RSP, RSP, INT(frame-size(t, backend(stubs))))
            E $ SetL(R0, INT(num-float-args))
            E $ asm-Call(I(f(e)))

            ;Return to our context:
            E $ LoadL(RSP, M(stack-pointer(stubs)))
            E $ SubL(RSP, RSP, INT(size(stackmap)))

          (t:YieldCall) :
            ;Given: Arguments are in the proper C registers, and all memory
            ;arguments have been saved.
            ;Our goal is to switch RSP to the given stack, and jump to
            ;the stack's saved PC pointer.
            
            ;Save the current stack progress.
            ;  - current-stack.pc = label following this yield
            ;  - current-stack.sp = RSP
            ;Load the given stack.
            ;  - current-stack = given stack.
            ;  - stack-pointer = given stack.sp
            ;  - stack-limit = given stack.stack-limit
            ;Go to the saved stack PC.
            ;  - goto given stack.pc
            
            val lbl = unique-id(stubs)
            val RX = R(14) ;Temporary register 0
            val RY = R(15) ;Temporary register 1
            val size-offset = -1 + 8 
            val frames-offset = -1 + 8 + 8
            val sp-offset = -1 + 8 + 8 + 8
            val pc-offset = -1 + 8 + 8 + 8 + 8
            E $ LoadL(RX, M(current-stack(stubs)))
            E $ SetL(RY, M(lbl))
            E $ StoreL(RX, RY, pc-offset)
            E $ StoreL(RX, RSP, sp-offset)
            E $ StoreL(M(current-stack(stubs)), R0)
            if enter?(t) : E $ LoadL(RSP, R0, frames-offset)
            else : E $ LoadL(RSP, R0, sp-offset)
            
            ;stack-limit = stack.frames(RX) + stack.size(RY)
            E $ LoadL(RX, R0, frames-offset)            
            E $ LoadL(RY, R0, size-offset)
            E $ AddL(RX, RX, RY)
            E $ StoreL(M(stack-limit(stubs)), RX)
            
            E $ LoadL(RY, R0, pc-offset)
            E $ asm-Goto(RY)            
            E $ asm-Label(lbl, info(t))
      (e:Op) : ;[2]
        match(op(e)) :
          (op:RecordLiveOp) :
            val indices = for v in live-vars(op) map :
              val o = offset(stackmap, n(v))
              fatal("Wrong alignment for ref on stack.") when o % 8 != 0
              o / 8              
            E $ StoreL(RSP, asm-StackMap(size(stackmap), indices), 8)
          (op:AllocOp) :
            val x = V(xs(e)[0])
            val size = I(ys(e)[0])
            E $ LoadL(R0, M(heap-top(stubs)))
            E $ AddL(x, R0, INT(1))
            E $ AddL(R0, R0, size)
            E $ StoreL(M(heap-top(stubs)), R0)
          ;(op:SaveCContextOp) :
          ;  val ns = c-preserved-regs(backend)
          ;  for (n in ns, o in -8 to false by -8) do :
          ;    #storel(RSP, R(n), o)
          ;  #movl(R6, RSP)
          ;  #loadl(RSP, M(STACK-PTR-LBL))
          (op:NoOp) :
            false
          (op:ConvOp) :
            val [x, y] = [head(xs(e)), head(ys(e))]
            E $ asm-ConvertIns(T(x), V(x), T(y), I(y))
          (op:InterpretOp) :
            val [x, y] = [head(xs(e)), head(ys(e))]
            E $ asm-InterpretIns(T(x), V(x), T(y), I(y))
          (op:LoadOp) :
            val [x, y, o] = [head(xs(e)), head(ys(e)), offset(op)]
            E $ asm-Load(T(x), V(x), I(y), o)
          (op:StoreOp) :
            val [x, y, o] = [ys(e)[0], ys(e)[1], offset(op)]
            E $ asm-Store(T(y), I(x), I(y), o)
          (op:VMOp&Binary) :
            val [x, y, z] = [head(xs(e)), ys(e)[0], ys(e)[1]]
            E $ asm-BinOp(T(y), V(x), to-asm-op(op), I(y), I(z))
          (op:VMOp&Unary) :
            val [x, y] = [head(xs(e)), head(ys(e))]
            E $ asm-UnaOp(T(x), V(x), to-asm-op(op), I(y))
          (op:DivModOp) :
            val [x1, x2, y, z] = [xs(e)[0], xs(e)[1], ys(e)[0], ys(e)[1]]
            E $ asm-DualOp(T(x1), V(x1), V(x2), to-asm-op(op), I(y), I(z))
          (op:InstanceofOp) :
            val [x, y] = [head(xs(e)), head(ys(e))]
            E $ asm-UnaOp(T(x), V(x), to-asm-op(op), I(y))
          (op:FlushVMOp) :
            val x = head(xs(e))
            val stack-pointer-offset = -1 + 8 + 16
            val lbl = unique-id(stubs)
            E $ LoadL(R0, M(current-stack(stubs)))
            E $ StoreL(R0, RSP, stack-pointer-offset)
            E $ SetL(V(x), M(vmstate(stubs)))
          (op) :
            fatal("Not yet implemented")

      (e:Save) :
        val x = x(e)
        val offset = offset(stackmap, n(x))
        E $ asm-Store(T(x), RSP, I(x), offset)
      (e:Load) :
        val x = x(e)
        val offset = offset(stackmap, n(x))
        E $ asm-Load(T(x), V(x), RSP, offset)
      (e:Xchg) :
        val [x, y] = [x(e), y(e)]
        match(swap(e)) :
          (s:FReg) :
            E $ SetD(F(n(s)), I(x))
            E $ SetD(V(x), I(y))
            E $ SetD(V(y), F(n(s)))
          (s:False) :
            E $ asm-XchgIns(V(x), V(y))
      (e:ShuffleReg) :
        if xs(e) != ys(e) :
          shuffle(num-regs(backend(stubs)), xs(e), ys(e),
            fn (src:Int, dst:Int) :
              E $ asm-SetIns(LT, R(dst), R(src))
            fn (src:Int, dst:Int) :
              E $ asm-XchgIns(R(dst), R(src)))
      (e:ShuffleFReg) :
        if xs(e) != ys(e) :
          shuffle(num-fregs(backend(stubs)), xs(e), ys(e),
            fn (src:Int, dst:Int) :
              E $ asm-SetIns(DT, F(dst), F(src))
            fn (n:Int) :
              E $ asm-Store(DT, M(swap-lbl(stubs)), F(n), 0)
            fn (n:Int) :
              E $ asm-Load(DT, F(n), M(swap-lbl(stubs)), 0))
      (e:Label) :
        val l = label-table[n(e)]
        E $ asm-Label(asm-n(l))
      (e:Goto) :
        E $ asm-Goto(label-table[n(e)])
      (e:Break) : ;[1]
        defn cmp-stack-limit (le-op:asm-Op) :
          E $ AddL(R0, RSP, INT(size(stackmap) + 8))
          E $ LoadL(R1, M(stack-limit(stubs)))
          E $ BreakL(label-table[n(e)], le-op, R0, R1)
        defn cmp-heap-limit (le-op:asm-Op) :
          val size = I(xs(e)[0])
          E $ LoadL(R0, M(heap-top(stubs)))
          E $ AddL(R0, R0, size)
          E $ LoadL(R1, M(heap-limit(stubs)))
          E $ BreakL(label-table[n(e)], le-op, R0, R1)
        defn cmp-arity (arg:Int, value:Int, eq-op:asm-Op) :
          val arg-reg = R(call-regs(backend(stubs))[arg])
          E $ BreakL(label-table[n(e)], eq-op, arg-reg, INT(value))

        match(op(e)) :
          (op:HasStackOp) :
            cmp-stack-limit(asm-UleOp())
          (op:HasHeapOp) :
            cmp-heap-limit(asm-UleOp())
          (op:ArgEqOp) :
            cmp-arity(arg(op), value(op), asm-EqOp())
          (fop:FlipOp) :
            match(op(fop)) :
              (op:HasStackOp) :
                cmp-stack-limit(asm-flip(asm-UleOp()))
              (op:HasHeapOp) :
                cmp-heap-limit(asm-flip(asm-UleOp()))
              (op:ArgEqOp) :
                cmp-arity(arg(op), value(op), asm-flip(asm-EqOp()))
          (op) :
            val [x, y] = [xs(e)[0], xs(e)[1]]
            E $ asm-Break(T(x), label-table[n(e)], to-asm-op(op), I(x), I(y))
      (e:Match) :
        if dispatch?(e) :
          val no-branch = label-table[ns(e)[0]]
          val amb-branch = label-table[ns(e)[1]]
          val branch-ns = tailn(ns(e), 2)          
          val bs = map(asm-Branch{_, label-table[_]}, type-lists(e), branch-ns)          
          val xs = map(I, xs(e))
          E $ asm-Dispatch(xs, bs, no-branch, amb-branch)
        else :
          val no-branch = label-table[head(ns(e))]
          val branch-ns = tail(ns(e))          
          val bs = map(asm-Branch{_, label-table[_]}, type-lists(e), branch-ns)          
          val xs = map(I, xs(e))
          E $ asm-Match(xs, bs, no-branch)
      (e:MethodDispatch) :
        val no-branch = label-table[default(e)]
        val amb-branch = label-table[amb(e)]
        E $ asm-MethodDispatch(multi(e), no-branch, amb-branch)        
      (e) : fatal("Not yet implemented: %_" % [e])

defn asm-type (x:Imm) :
  to-asm-type(type(x))

defn to-asm-type (t:VMType) -> asm-ASMType :
  match(t) :
    (t:VMByte) : asm-ByteT()
    (t:VMInt) : asm-IntT()
    (t:VMLong) : asm-LongT()
    (t:VMRef) : asm-LongT()
    (t:VMFloat) : asm-FloatT()
    (t:VMDouble) : asm-DoubleT()

defn to-asm-loc (x:Imm) :
  to-asm-imm(x) as asm-Loc

defn to-asm-imm (x:Imm) -> asm-Imm :
  match(x) :
    (x:Var) :
      match(reg(x)) :
        (r:Reg) : asm-Reg(n(r))
        (r:FReg) : asm-FReg(n(r))
    (x:Val) :
      to-asm-imm(value(x))

defn to-asm-imm (i:VMImm) -> asm-Imm :
  match(i) :
    (i:NumConst) :
      match(value(i)) :
        (v:Byte|Int|Long) : asm-IntImm(v)
        (v:Char) : asm-IntImm(to-byte(v))
        (v:Float|Double) : fatal("Not yet implemented: Need interpret instruction")
    (i:Marker) : asm-TagImm(typeid(i), true)
    (i:Tag) : asm-TagImm(typeid(i), false)
    (i:CodeId) : asm-LinkId(id(i))
    (i:ExternId) : asm-LinkId(id(i))
    (i:ExternDefnId) : asm-LinkId(id(i))
    (i:GlobalId) : asm-LinkId(id(i))
    (i:DataId) : asm-LinkId(id(i))
    (i:VoidMarker) : asm-IntImm(-8 + 2)
    (i:ConstId) : fatal("Constants must be loaded")

defn to-asm-op (op:VMOp) -> asm-Op :
  match(op) :
    (op:AddOp) : asm-AddOp()
    (op:SubOp) : asm-SubOp()
    (op:MulOp) : asm-MulOp()
    (op:DivOp) : asm-DivOp()
    (op:ModOp) : asm-ModOp()
    (op:AndOp) : asm-AndOp()
    (op:OrOp) : asm-OrOp()
    (op:XorOp) : asm-XorOp()
    (op:ShlOp) : asm-ShlOp()
    (op:ShrOp) : asm-ShrOp()
    (op:AshrOp) : asm-AshrOp()
    (op:EqOp) : asm-EqOp()
    (op:NeOp) : asm-NeOp()
    (op:LtOp) : asm-LtOp()
    (op:GtOp) : asm-GtOp()
    (op:LeOp) : asm-LeOp()
    (op:GeOp) : asm-GeOp()
    (op:UleOp) : asm-UleOp()
    (op:UltOp) : asm-UltOp()
    (op:UgtOp) : asm-UgtOp()
    (op:UgeOp) : asm-UgeOp()
    (op:NotOp) : asm-NotOp()
    (op:NegOp) : asm-NegOp()
    (op:DivModOp) : asm-DivModOp()
    (op:InstanceofOp) : asm-TypeofOp(type(op))

;============================================================
;===================== Utilities ============================
;============================================================

defn keys<?T> (xs:Vector<KeyValue<?T,?>>) : to-list(seq(key,xs))
defn values<?T> (xs:Vector<KeyValue<?,?T>>) : to-list(seq(value,xs))