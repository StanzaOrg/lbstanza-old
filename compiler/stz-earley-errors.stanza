defpackage stz/earley-errors :
  import core
  import collections
  import stz/earley-eitems
  import stz/earley-grammar
  import stz/earley-sexp-stream

;============================================================
;====================== Error Bundle ========================
;============================================================

public defstruct EarleySyntaxErrors <: Exception :
  errors: Tuple<EarleySyntaxError>

defmethod print (o:OutputStream, e:EarleySyntaxErrors) :
  print(o, "%n" % [errors(e)])

;============================================================
;==================== Types of Errors =======================
;============================================================

public deftype EarleySyntaxError <: Exception

public deftype EarleyParseError <: EarleySyntaxError

;============================================================
;================= Parse Evaluation Errors ==================
;============================================================

public defstruct ParseEvaluationErrors <: EarleySyntaxError :
  errors: Tuple<Exception>

defmethod print (o:OutputStream, e:ParseEvaluationErrors) :
  print(o, "%n" % [errors(e)])

;============================================================
;================= Missing Input Error  =====================
;============================================================

public defstruct MissingInputError <: EarleyParseError :
  input
  info: FileInfo|False
  productions: Tuple<Int>
  upcoming: Tuple<GToken>

defmethod print (o:OutputStream, e:MissingInputError) :
  ;Represent the file information for this error.
  defn info-str () :
    "" when info(e) is False else "%_: " % [info(e)]

  ;Describe the input item.
  defn input-str () :
    match(input(e)) :
      (x:EndOfInput) :
        "end of input"
      (x:SExpListEnd) :
        "end of list"
      (x:SExpForm) :
        match(unwrap-token(form(x))) :
          (f:Symbol) : "symbol '%~'" % [f]
          (f:List) : "list"
          (f) : "input '%~'" % [f]

  ;Describe the expected token.
  defn token-str (t:GToken) :
    match(t) :
      (t:GProduction) : "a '#%~' production" % [id(t)]
      (t:GKeyword) : "'%~'" % [item(t)]
      (t:GListStart) : "a list"
      (t:GListEnd) : "the end of the list"
      (t:GAny) : "a form"
      (t:GPrimToken) : prim-str(type(t))
      (t:GListRest) : "the rest of the list"
      (t:GMatcherToken) : token-str(terminal(t))

  ;Describe the expected primitive type.
  defn prim-str (t:GPrimType) :
    switch(t) :
      GCharType : "a character"
      GByteType : "a byte"
      GIntType : "an integer"
      GLongType : "a long"
      GFloatType : "a float"
      GDoubleType : "a double"
      GStringType : "a string"
      GSymbolType : "a symbol"
      GTrueType : "true"
      GFalseType : "false"

  ;Describe the tuple of tokens.
  defn tokens-str (ts:Tuple<GToken>) :
    if length(ts) == 1 :
      token-str(ts[0])
    else :
      val but-last-t = ts[0 to length(ts) - 1]
      val last-t = ts[length(ts) - 1]
      "either %,, or %_" % [seq(token-str,but-last-t), token-str(last-t)]

  ;Describe the current productions being parsed.
  defn productions-str (ids:Tuple<Int>) :
    tokens-str(map(GProduction,ids))

  ;Print all items.
  print(o, "%_Unexpected %_." % [info-str(), input-str()])
  if not empty?(productions(e)) :
    print(o, " Currently parsing %_ and %_ is expected next." % [
      productions-str(productions(e)), tokens-str(upcoming(e))])
