defpackage stz/earley-errors :
  import core
  import collections
  import stz/earley-eitems
  import stz/earley-grammar
  import stz/earley-sexp-stream

;============================================================
;====================== Error Bundle ========================
;============================================================

public defstruct EarleySyntaxErrors <: Exception :
  errors: Tuple<EarleySyntaxError>

defmethod print (o:OutputStream, e:EarleySyntaxErrors) :
  print(o, "%n" % [errors(e)])

;============================================================
;==================== Types of Errors =======================
;============================================================

public deftype EarleySyntaxError <: Exception
public deftype EarleyPatternResolutionError <: EarleySyntaxError
public deftype EarleyPackageFusionError <: EarleySyntaxError
public deftype EarleyParseError <: EarleySyntaxError

;============================================================
;================ Pattern Resolution Errors =================
;============================================================

public defstruct CannotResolveProduction <: EarleyPatternResolutionError :
  info: FileInfo|False
  production: Symbol

defmethod print (o:OutputStream, e:CannotResolveProduction) :
  print(o, "%_Cannot resolve production '%~'." % [
    info-str(info(e)), production(e)])

public defstruct CannotResolveImportedProduction <: EarleyPatternResolutionError :
  info: FileInfo|False
  package: Symbol
  production: Symbol

defmethod print (o:OutputStream, e:CannotResolveImportedProduction) :
  print(o, "%_Cannot resolve production '%~', imported from syntax package '%~'." % [
    info-str(info(e)), production(e), package(e)])

public defstruct CannotImportNonPublicProduction <: EarleyPatternResolutionError :
  info: FileInfo|False
  package: Symbol
  production: Symbol

defmethod print (o:OutputStream, e:CannotImportNonPublicProduction) :
  print(o, "%_Cannot import non-public production '%~' from syntax package '%~'." % [
    info-str(info(e)), production(e), package(e)])

public defstruct MissingImportedPackage <: EarleyPatternResolutionError :
  info: FileInfo|False
  package: Symbol

defmethod print (o:OutputStream, e:MissingImportedPackage) :
  print(o, "%_Cannot import from syntax package '%~'. There is no such package." % [
    info-str(info(e)), package(e)])  

public defstruct CannotDefineDuplicateProduction <: EarleyPatternResolutionError :
  info: FileInfo|False
  production: Symbol

defmethod print (o:OutputStream, e:CannotDefineDuplicateProduction) :
  print(o, "%_Duplicate definition of production '%~'." % [
    info-str(info(e)), production(e)])

;============================================================  
;================== EarleyPackageFusionErrors ===============
;============================================================  

public defstruct MutuallyCyclicClones <: EarleyPackageFusionError :
  defs: Tuple<CloneDef>

defmethod print (o:OutputStream, e:MutuallyCyclicClones) :
  print(o, "The following productions are mutually cyclic clones of each other:")
  val o2 = IndentedStream(o)
  do(lnprint{o2, _}, defs(e))

public defstruct CloneDef :
  info: FileInfo|False
  name: Symbol

defmethod print (o:OutputStream, d:CloneDef) :
  val info-str = "" when info(d) is False
            else " at %_" % [info(d)]
  print(o, "Production '%~'%_" % [name(d), info-str])

public defstruct MutuallyCyclicKeywords <: EarleyPackageFusionError :
  defs: Tuple<CloneDef>

defmethod print (o:OutputStream, e:MutuallyCyclicKeywords) :
  print(o, "The following keywords are cyclically dependent upon each other:")
  val o2 = IndentedStream(o)
  do(lnprint{o2, _}, defs(e))

;============================================================
;================= Parse Evaluation Errors ==================
;============================================================

public defstruct ParseEvaluationErrors <: EarleyParseError :
  errors: Tuple<Exception>

defmethod print (o:OutputStream, e:ParseEvaluationErrors) :
  print(o, "%n" % [errors(e)])

;============================================================
;================= Missing Input Error  =====================
;============================================================

public defstruct MissingInputError <: EarleyParseError :
  input
  info: FileInfo|False
  productions: Tuple<Int>
  upcoming: Tuple<GToken>

defmethod print (o:OutputStream, e:MissingInputError) :
  ;Describe the input item.
  defn input-str () :
    match(input(e)) :
      (x:EndOfInput) :
        "end of input"
      (x:SExpListEnd) :
        "end of list"
      (x:SExpForm) :
        match(unwrap-token(form(x))) :
          (f:Symbol) : "symbol '%~'" % [f]
          (f:List) : "list"
          (f) : "input '%~'" % [f]

  ;Describe the expected token.
  defn token-str (t:GToken) :
    match(t) :
      (t:GProduction) : "a '#%~' production" % [id(t)]
      (t:GKeyword) : "'%~'" % [item(t)]
      (t:GListStart) : "a list"
      (t:GListEnd) : "the end of the list"
      (t:GAny) : "a form"
      (t:GPrimToken) : prim-str(type(t))
      (t:GListRest) : "the rest of the list"
      (t:GMatcherToken) : token-str(terminal(t))

  ;Describe the expected primitive type.
  defn prim-str (t:GPrimType) :
    switch(t) :
      GCharType : "a character"
      GByteType : "a byte"
      GIntType : "an integer"
      GLongType : "a long"
      GFloatType : "a float"
      GDoubleType : "a double"
      GStringType : "a string"
      GSymbolType : "a symbol"
      GTrueType : "true"
      GFalseType : "false"

  ;Describe the tuple of tokens.
  defn tokens-str (ts:Tuple<GToken>) :
    if length(ts) == 1 :
      token-str(ts[0])
    else :
      val but-last-t = ts[0 to length(ts) - 1]
      val last-t = ts[length(ts) - 1]
      "either %,, or %_" % [seq(token-str,but-last-t), token-str(last-t)]

  ;Describe the current productions being parsed.
  defn productions-str (ids:Tuple<Int>) :
    tokens-str(map(GProduction,ids))

  ;Print all items.
  print(o, "%_Unexpected %_." % [info-str(info(e)), input-str()])
  if not empty?(productions(e)) :
    print(o, " Currently parsing %_ and %_ is expected next." % [
      productions-str(productions(e)), tokens-str(upcoming(e))])

;============================================================
;===================== Utilities ============================
;============================================================

defn info-str (info:FileInfo|False) :
  if info is False : ""
  else : "%_: " % [info]
