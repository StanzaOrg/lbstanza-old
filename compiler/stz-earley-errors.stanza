defpackage stz/earley-errors :
  import core
  import collections
  import stz/earley-eitems
  import stz/earley-grammar
  import stz/earley-sexp-stream

;============================================================
;=================== Datastructures =========================
;============================================================

public defstruct MissingInput :
  input
  set-index: Int
  info: FileInfo|False
  items: Tuple<EItem>

defstruct MissingInputError <: Exception :
  input
  info: FileInfo|False
  productions: Tuple<Int>
  upcoming: Tuple<GToken>

public defstruct ParsingErrors <: Exception :
  errors: Tuple<Exception>

;============================================================
;==================== Error Creation ========================
;============================================================

defn prune-nondescriptive-items (g:Grammar, items:Tuple<EItem>) -> Tuple<EItem> :
  ;For any completed productions, compute the
  ;earliest position that those productions began.
  val start-of-completed-productions = IntTable<Int>()
  defn compute-start-of-completed-productions () :
    defn completed? (item:EItem) :
      upcoming(item) is False
    for item in filter(completed?, items) do :
      val prod = production(item)
      start-of-completed-productions[prod] =
        match(get?(start-of-completed-productions, prod)) :
          (p:Int) : min(parent(item), p)
          (f:False) : parent(item)

  ;Classify an item as descriptive or not.
  defn descriptive? (item:EItem) -> True|False :
    defn wildcard? () :
      matched-wildcard?(item)
    defn completed? () :
      val prod = production(item)
      match(get?(start-of-completed-productions,prod)) :
        (p:Int) : p <= parent(item)
        (f:False) : false
    defn complete? () :
      upcoming(item) is False
    defn predicted? () :
      num-parsed(item) == 0
    not (wildcard?() or
         completed?() or
         complete?() or
         predicted?())

  ;Launch!
  compute-start-of-completed-productions()
  to-tuple(filter(descriptive?, items))

defn to-exception (g:Grammar, m:MissingInput) -> Maybe<MissingInputError> :
  val items* = prune-nondescriptive-items(g, items(m))
  ;Return None() if no items remaining.
  if empty?(items*) :
    None()
  else :
    defn get-production (item:EItem) : production(item)
    defn get-upcoming (item:EItem) : upcoming(item) as GToken
    val prods = to-intset(seq(get-production, items*))
    val tokens = to-hashset<GToken>(seq(get-upcoming, items*))
    One $ MissingInputError(
      input(m), info(m),
      to-tuple(prods), qsort(tokens))    

public defn to-exception (g:Grammar, input-ms:Collection<MissingInput>) :  
  ParsingErrors $ to-tuple $ seq?(to-exception{g, _}, input-ms)

;============================================================
;================= Error Formatting =========================
;============================================================

defmethod print (o:OutputStream, e:MissingInputError) :
  ;Represent the file information for this error.
  defn info-str () :
    "" when info(e) is False else "%_: " % [info(e)]

  ;Describe the input item.
  defn input-str () :
    match(input(e)) :
      (x:EndOfInput) :
        "end of input"
      (x:SExpListEnd) :
        "end of list"
      (x:SExpForm) :
        match(unwrap-token(form(x))) :
          (f:Symbol) : "symbol '%~'" % [f]
          (f:List) : "list"
          (f) : "input '%~'" % [f]

  ;Describe the expected token.
  defn token-str (t:GToken) :
    match(t) :
      (t:GProduction) : "a '#%~' production" % [id(t)]
      (t:GKeyword) : "'%~'" % [item(t)]
      (t:GListStart) : "a list"
      (t:GListEnd) : "the end of the list"
      (t:GAny) : "a form"
      (t:GPrimToken) : prim-str(type(t))
      (t:GListRest) : "the rest of the list"
      (t:GMatcherToken) : token-str(terminal(t))

  ;Describe the expected primitive type.
  defn prim-str (t:GPrimType) :
    switch(t) :
      GCharType : "a character"
      GByteType : "a byte"
      GIntType : "an integer"
      GLongType : "a long"
      GFloatType : "a float"
      GDoubleType : "a double"
      GStringType : "a string"
      GSymbolType : "a symbol"
      GTrueType : "true"
      GFalseType : "false"

  ;Describe the tuple of tokens.
  defn tokens-str (ts:Tuple<GToken>) :
    if length(ts) == 1 :
      token-str(ts[0])
    else :
      val but-last-t = ts[0 to length(ts) - 1]
      val last-t = ts[length(ts) - 1]
      "either %,, or %_" % [seq(token-str,but-last-t), token-str(last-t)]

  ;Describe the current productions being parsed.
  defn productions-str (ids:Tuple<Int>) :
    tokens-str(map(GProduction,ids))

  ;Print all items.
  print(o, "%_Unexpected %_." % [info-str(), input-str()])
  if not empty?(productions(e)) :
    print(o, " Currently parsing %_ and %_ is expected next." % [
      productions-str(productions(e)), tokens-str(upcoming(e))])

defmethod print (o:OutputStream, e:ParsingErrors) :
  print(o, "Could not parse the given input:")
  val o2 = IndentedStream(o)
  do(lnprint{o2, _}, errors(e))