defpackage stz/earley-errors :
  import core
  import collections
  import stz/earley-eitems
  import stz/earley-grammar

;============================================================
;=================== Datastructures =========================
;============================================================

public defstruct MissingInput :
  input
  info: FileInfo|False
  items: Tuple<EItem>

defstruct MissingInputError <: Exception :
  input
  info: FileInfo|False
  productions: Tuple<Symbol>
  upcoming: Tuple<GToken>

public defstruct ParsingErrors <: Exception :
  errors: Tuple<Exception>

;============================================================
;==================== Error Handling ========================
;============================================================


public defn to-exception (g:Grammar, m:MissingInput) :
  println("Form Exception from:")
  for item in items(m) do :
    println(format(g,item))
  println("input = %_" % [input(m)])
    
  ;Compute earliest completed productions
  defn completed? (item:EItem) :
    val tokens = tokens!(g[rule(item)])
    num-parsed(item) == length(tokens)
  val completed-productions = HashTable<Symbol,Int>(INT-MAX)
  for item in filter(completed?,items(m)) do :
    update(completed-productions, min{_, parent(item)}, production(g,item))

  ;Compute productions and upcoming
  val productions = HashSet<Symbol>()
  val upcoming-tokens = HashSet<GToken>()
  for item in items(m) do :
    val production = production(g,item)    
    val include? = match(upcoming(g,item)) :
      (t:GTerminal) :
        num-parsed(item) > 0 and
        completed-productions[production] > parent(item)
      (t:GProduction) :
        num-parsed(item) > 0 and 
        completed-productions[production] > parent(item)
      (t:False) :
        false
    if include? :
      add(productions, production)
      add(upcoming-tokens, upcoming(g, item) as GToken)

  ;Return error
  MissingInputError(input(m), info(m), to-tuple(productions), qsort(upcoming-tokens))

public defn to-exception (g:Grammar, input-ms:Collection<MissingInput>) :  
  val ms = to-tuple(input-ms)
  defn first-in-chain? (i:Int) : i == 0 or set-index(ms[i - 1]) < set-index(ms[i]) - 1
  ;val es = seq(to-exception{g, ms[_]}, filter(first-in-chain?, 0 to length(ms)))
  val es = seq(to-exception{g, ms[_]}, 0 to length(ms))
  ParsingErrors $ to-tuple $ es

defmethod print (o:OutputStream, e:MissingInputError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  val input-str = match(input(e)) :
    (x:EndOfInput) : "end of input"
    (x:SExpForm) :
      match(unwrap-token(form(x))) :
        (f:Symbol) : "symbol '%~'" % [f]
        (f:List) : "list"
        (f) : "input '%~'" % [f]
    (x:SExpListEnd) : "end of list"
  defn token-str (t:GToken) :
    match(t) :
      (t:GProduction) : "a '%~' production" % [name(t)]
      (t:GKeyword) : "'%~'" % [item(t)]
      (t:GListStart) : "a list"
      (t:GListEnd) : "the end of the list"
      (t:GAny) : "a form"
      (t) : t
  defn tokens-str (ts:Tuple<GToken>) :
    if length(ts) == 1 :
      token-str(ts[0])
    else :
      val but-last-t = ts[0 to length(ts) - 1]
      val last-t = ts[length(ts) - 1]
      "either %,, or %_" % [seq(token-str,but-last-t), token-str(last-t)]
  defn productions-str (names:Tuple<Symbol>) :
    tokens-str(map(GProduction,names))
  print(o, "%_Unexpected %_." % [info-str, input-str])
  if not empty?(productions(e)) :
    print(o, " Current parsing %_ and %_ is expected next." % [
      productions-str(productions(e)), tokens-str(upcoming(e))])

defmethod print (o:OutputStream, e:ParsingErrors) :
  print(o, "Could not parse the given input:")
  val o2 = IndentedStream(o)
  do(lnprint{o2, _}, errors(e))