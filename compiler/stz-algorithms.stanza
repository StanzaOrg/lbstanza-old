;See License.txt for details about licensing.

defpackage stz/algorithms :
   import core
   import verse

public defn* fixpoint<?T> (f: (() -> ?) -> ?T) -> T :
   var progress? = false
   val r = f({progress? = true})
   if progress? : fixpoint(f)
   else : r

public defn* worklist<?S> (f: (S, (S) -> ?) -> ?, xs:Streamable<?S>) -> False :
   val q = Queue<S>(4)
   defn add-x (x:S) : add(q, x)
   do(add-x, xs)
   while not empty?(q) :
      f(pop(q), add-x)

defn minus (xs:List<Symbol>, y:Symbol) -> List<Symbol> :
   if empty?(xs) : xs
   else if head(xs) == y : tail(xs) - y
   else : List(head(xs), tail(xs) - y)

public defn bipartite-closure (entries: Streamable<KeyValue<Symbol, List<Symbol>>>) ->
                               List<KeyValue<Symbol, List<Symbol>>> :
   val solns = HashTable<Symbol,List<Symbol>>(symbol-hash)
   defn fill (x:Symbol) -> List<Symbol> :
      match(get?(solns, x, false)) :
         (xs:List<Symbol>) : fill(xs)
         (f:False) : list(x)
   defn fill (xs:List<Symbol>) -> List<Symbol> :
      map-append(fill, xs)

   val solved = Vector<Symbol>()
   for e in entries do :
      val [x, vs] = [key(e), value(e)]
      solns[x] = fill(vs) - x
      add(solved, x)

   to-list $ generate<KeyValue<Symbol, List<Symbol>>> :
      for i in (length(solved) - 1) through 0 by -1 do :
         val x = solved[i]
         val vs = unique(fill(solns[x]))
         solns[x] = vs
         yield(x => vs)

public defn strong-components (graph: Streamable<KeyValue<Symbol, List<Symbol>>>) ->
                               List<List<Symbol>|Symbol> :
   ;Create Neighbour Table
   val vs = Vector<Symbol>()
   val neighbours = HashTable<Symbol, List<Symbol>>(symbol-hash)
   for entry in graph do :
      val v = key(entry)
      val ns = value(entry)
      add(vs, v)
      neighbours[v] = ns

   ;Active Table
   val active = HashTable<Symbol,True|False>(symbol-hash)
   for v in vs do :
      active[v] = true
   defn active? (x:Symbol) :
      get?(active, x, false)

   ;Stack
   val stack = Vector<Symbol>()
   defn pop-until-v (v:Symbol) :
      val x = pop(stack)
      active[x] = false
      if x == v : list(x)
      else : List(x, pop-until-v(v))

   ;State Tables
   val lowlink = HashTable<Symbol,Int>(symbol-hash)
   val index-counter = to-stream(0 to false)
   val components = Vector<List<Symbol>|Symbol>()
   defn get-lowlink (v:Symbol) -> Int :
      if not key?(lowlink, v) :
         val idx = next(index-counter)
         lowlink[v] = idx
         add(stack, v)

         var cycle? = false
         for n in neighbours[v] do :
            if active?(n) :
               val nl = get-lowlink(n)
               if nl <= lowlink[v] :
                  lowlink[v] = nl
                  cycle? = true

         if lowlink[v] == idx :
            val c = pop-until-v(v)
            add{components, _} $
               if cycle? : c
               else : head(c)
      lowlink[v]

   ;Run connection
   do(get-lowlink, vs)
   to-list(components)


public defn strong-components (graph: Streamable<KeyValue<Int, List<Int>>>) ->
                               List<List<Int>|Int> :
   ;Create Neighbour Table
   val vs = Vector<Int>()
   val neighbours = HashTable<Int, List<Int>>({_})
   for entry in graph do :
      val v = key(entry)
      val ns = value(entry)
      add(vs, v)
      neighbours[v] = ns

   ;Active Table
   val active = HashTable<Int,True|False>({_})
   for v in vs do :
      active[v] = true
   defn active? (x:Int) :
      get?(active, x, false)

   ;Stack
   val stack = Vector<Int>()
   defn pop-until-v (v:Int) :
      val x = pop(stack)
      active[x] = false
      if x == v : list(x)
      else : List(x, pop-until-v(v))

   ;State Tables
   val lowlink = HashTable<Int,Int>({_})
   val index-counter = to-stream(0 to false)
   val components = Vector<List<Int>|Int>()
   defn get-lowlink (v:Int) -> Int :
      if not key?(lowlink, v) :
         val idx = next(index-counter)
         lowlink[v] = idx
         add(stack, v)

         var cycle? = false
         for n in neighbours[v] do :
            if active?(n) :
               val nl = get-lowlink(n)
               if nl <= lowlink[v] :
                  lowlink[v] = nl
                  cycle? = true

         if lowlink[v] == idx :
            val c = pop-until-v(v)
            add{components, _} $
               if cycle? : c
               else : head(c)
      lowlink[v]

   ;Run connection
   do(get-lowlink, vs)
   to-list(components)


;============================================================
;================= Shuffling Engine =========================
;============================================================

public definterface ShuffleIns
public defstruct ShfMove <: ShuffleIns :
   dst:Int
   src:Int
public defstruct ShfSave <: ShuffleIns :
   n:Int
public defstruct ShfLoad <: ShuffleIns :
   n:Int

defmethod print (o:OutputStream, i:ShuffleIns) :
   print{o, _} $ match(i) :
      (i:ShfMove) : "~ = ~" << [dst(i), src(i)]
      (i:ShfSave) : "save ~" << [n(i)]
      (i:ShfLoad) : "load ~" << [n(i)]

;Buffers
val PRED = Vector<False|Int>()
val DONE = Vector<True|False>()
val LOADS = Vector<True|False>()
val SUCC? = Vector<True|False>()

public defn shuffle (xs:List<Int>, ys:List<Int>, nreg:Int, f: ShuffleIns -> ?) :
   ;Predecessor and Successor table
   clear(PRED)
   clear(DONE)
   clear(LOADS)
   clear(SUCC?)
   set-length(PRED, nreg, false)
   set-length(DONE, nreg, false)
   set-length(LOADS, nreg, false)
   set-length(SUCC?, nreg, false)

   ;Initialize Predecessors
   for (x in xs, y in ys) do :
      if x != y :
         PRED[x] = y
      else :
         DONE[x] = true

   ;Find a simple destination. 
   defn simple-dst () :
      for i in 0 to nreg do :
         SUCC?[i] = false
      for i in 0 to nreg do :
         match(PRED[i]) :
            (p:Int) : SUCC?[p] = true
            (p:False) : false
      for i in 0 to nreg find :
         PRED[i] != false and 
         SUCC?[i] == false

   ;Find a remaining destination.
   defn remaining-dst () :
      for i in 0 to nreg find :
         PRED[i] != false
         
   ;Find a swap register
   ;Assumes SUCC? is calculated
   defn swap-reg () :
      for i in 0 to nreg find :
         SUCC?[i] == false and
         DONE[i] == false

   ;Iterate until fixpoint
   fixpoint $ fn (progress) :
      
      ;Move src to dst and update pred table
      defn move (dst:Int, src:Int) :
         progress()
         f(ShfMove(dst, src))
         for i in 0 to nreg do :
            if PRED[i] == src :
               PRED[i] = dst

      ;Save register and update pred table
      defn save (r:Int) :
         progress()
         f(ShfSave(r))
         for i in 0 to nreg do :
            if PRED[i] == r :
               PRED[i] = false
               LOADS[i] = true               

      ;Fills the dst register with its final value
      defn* fill (r:Int) :
         match(PRED[r]) :
            (p:Int) :
               move(r, p)
               PRED[r] = false
               DONE[r] = true
               fill(p)
            (p:False) :
               false
               
      match(simple-dst()) :
         (r:Int) : fill(r)
         (r:False) :
            match(remaining-dst(), swap-reg()) :
               (r:Int, s:Int) : move(s, r)
               (r:Int, s:False) : save(r)
               (r, s) : false

   ;Load saved registers
   for i in 0 to nreg do :
      if LOADS[i] :
         f(ShfLoad(i))


;============================================================
;==================== Int Tables ============================
;============================================================

public defclass IntTable<V> <: Streamable<KeyValue<Int,V>> & Lengthable 
public defmulti set<?V> (t:IntTable<?V>, k:Int, v:V) -> False
public defmulti get?<?V,?D> (t:IntTable<?V> k:Int, d:?D) -> V|D
public defmulti get<?V> (t:IntTable<?V>, k:Int) -> V
public defmulti key? (t:IntTable, k:Int) -> True|False
public defmulti clear (t:IntTable) -> False
defmulti double-capacity (t:IntTable) -> False

public defn IntTable<V> () -> IntTable<V> :
   var cap
   var limit
   var keys
   var values
   var occupied
   var size

   defn init (c:Int) :
      cap = c
      limit = (c * 3) / 5
      keys = Array<Int>(cap)
      values = Array<V>(cap)
      occupied = Array<Int>(cap >> 5, 0)
      size = 0

   ;Initialize table
   init(32)

   defn set? (occupied:Array<Int>, i:Int) :
      val mask = occupied[i >> 5]
      val bit = (mask >> (i & 31)) & 1
      bit == 1

   defn occupied? (i:Int) :
      set?(occupied, i)

   defn set-occupied? (i:Int) :
      val mask = occupied[i >> 5]
      val bit = 1 << (i & 31)
      occupied[i >> 5] = mask | bit

   defn key-slot (k:Int, i:Int) -> Int :
      (k + i) & (cap - 1)
            
   defn key-index (k:Int) -> Int :
      defn* loop (i:Int) :
         val s = key-slot(k, i)
         if occupied?(s) :
            if keys[s] == k : s
            else : loop(i + 1)
         else : s
      loop(0)

   new IntTable<V> :
      defmethod double-capacity (this) :
         val entries = to-stream(this)
         init(cap * 2)
         for entry in entries do :
            this[key(entry)] = value(entry)
            
      defmethod clear (this) :
         for i in 0 to length(occupied) do :
            occupied[i] = 0
         size = 0
      
      defmethod set (this, k:Int, v:V) :         
         ;Get key index
         val i = key-index(k)
         
         ;Set key
         if occupied?(i) :
            values[i] = v
         else :
            keys[i] = k
            values[i] = v
            set-occupied?(i)
            size = size + 1

         ;Ensure capacity
         double-capacity(this) when size > limit
         
      defmethod get?<?D> (this, k:Int, d:?D) :
         val i = key-index(k)
         if occupied?(i) : values[i]
         else : d

      defmethod get (this, k:Int) :
         val i = key-index(k)
         if occupied?(i) : values[i]
         else : error("Key ~ does not exist in table." % [k])

      defmethod key? (this, k:Int) :
         val i = key-index(k)
         occupied?(i)

      defmethod length (this) :
         size
         
      defmethod to-stream (this) :
         val keys = keys
         val values = values
         val occupied = occupied
         generate<KeyValue<Int,V>> :
            for i in 0 to length(keys) do :
               if set?(occupied, i) :
                  yield(keys[i] => values[i])


;============================================================
;==================== DoubleInt Tables ======================
;============================================================

public defclass DualIntTable<V> <: Streamable<KeyValue<[Int,Int],V>> & Lengthable 
public defmulti set<?V> (t:DualIntTable<?V>, k1:Int, k2:Int, v:V) -> False
public defmulti get?<?V,?D> (t:DualIntTable<?V> k1:Int, k2:Int, d:?D) -> V|D
public defmulti get<?V> (t:DualIntTable<?V>, k1:Int, k2:Int) -> V
public defmulti key? (t:DualIntTable, k1:Int, k2:Int) -> True|False
public defmulti clear (t:DualIntTable) -> False
defmulti double-capacity (t:DualIntTable) -> False

public defn DualIntTable<V> () -> DualIntTable<V> :
   var cap
   var limit
   var keys1
   var keys2
   var values
   var occupied
   var size

   defn init (c:Int) :
      cap = c
      limit = (c * 3) / 5
      keys1 = Array<Int>(cap)
      keys2 = Array<Int>(cap)
      values = Array<V>(cap)
      occupied = Array<Int>(cap >> 5, 0)
      size = 0

   ;Initialize table
   init(32)

   defn set? (occupied:Array<Int>, i:Int) :
      val mask = occupied[i >> 5]
      val bit = (mask >> (i & 31)) & 1
      bit == 1

   defn occupied? (i:Int) :
      set?(occupied, i)

   defn set-occupied? (i:Int) :
      val mask = occupied[i >> 5]
      val bit = 1 << (i & 31)
      occupied[i >> 5] = mask | bit
   
   defn key-slot (k1:Int, k2:Int, i:Int) -> Int :
      ((k1 * 31 + k2) + i) & (cap - 1)
            
   defn key-index (k1:Int, k2:Int) -> Int :
      defn* loop (i:Int) :
         val s = key-slot(k1, k2, i)
         if occupied?(s) :
            if keys1[s] == k1 and keys2[s] == k2 : s
            else : loop(i + 1)
         else : s
      loop(0)

   new DualIntTable<V> :
      defmethod double-capacity (this) :
         val entries = to-stream(this)
         init(cap * 2)
         for entry in entries do :
            val [k1, k2] = key(entry)
            this[k1, k2] = value(entry)
            
      defmethod clear (this) :
         for i in 0 to length(occupied) do :
            occupied[i] = 0
         size = 0
      
      defmethod set (this, k1:Int, k2:Int, v:V) :         
         ;Get key index
         val i = key-index(k1, k2)
         
         ;Set key
         if occupied?(i) :
            values[i] = v
         else :
            keys1[i] = k1
            keys2[i] = k2
            values[i] = v
            set-occupied?(i)
            size = size + 1

         ;Ensure capacity
         double-capacity(this) when size > limit
         
      defmethod get?<?D> (this, k1:Int, k2:Int, d:?D) :
         val i = key-index(k1, k2)
         if occupied?(i) : values[i]
         else : d

      defmethod get (this, k1:Int, k2:Int) :
         val i = key-index(k1, k2)
         if occupied?(i) : values[i]
         else : error("Key [~, ~] does not exist in table." % [k1, k2])

      defmethod key? (this, k1:Int, k2:Int) :
         val i = key-index(k1, k2)
         occupied?(i)

      defmethod length (this) :
         size
         
      defmethod to-stream (this) :
         val keys1 = keys1
         val keys2 = keys2
         val values = values
         val occupied = occupied
         generate<KeyValue<[Int,Int],V>> :
            for i in 0 to length(keys1) do :
               if set?(occupied, i) :
                  yield([keys1[i], keys2[i]] => values[i])