;See License.txt for details about licensing.

defpackage stz/algorithms :
   import core
   import verse

public defn* fixpoint<?T> (f: (() -> ?) -> ?T) -> T :
   var progress? = false
   val r = f({progress? = true})
   if progress? : fixpoint(f)
   else : r

public defn* worklist<?S> (f: (S, (S) -> ?) -> ?, xs:Streamable<?S>) -> False :
   val q = Queue<S>(4)
   defn add-x (x:S) : add(q, x)
   do(add-x, xs)   
   while not empty?(q) :
      f(pop(q), add-x)  

defn minus (xs:List<Symbol>, y:Symbol) -> List<Symbol> :
   if empty?(xs) : xs
   else if head(xs) == y : tail(xs) - y
   else : List(head(xs), tail(xs) - y)
   
public defn bipartite-closure (entries: Streamable<KeyValue<Symbol, List<Symbol>>>) ->
                               List<KeyValue<Symbol, List<Symbol>>> :      
   val solns = HashTable<Symbol,List<Symbol>>(symbol-hash)
   defn fill (x:Symbol) -> List<Symbol> :
      match(get?(solns, x, false)) :
         (xs:List<Symbol>) : fill(xs)
         (f:False) : list(x)         
   defn fill (xs:List<Symbol>) -> List<Symbol> :
      map-append(fill, xs)
         
   val solved = Vector<Symbol>()
   for e in entries do :
      val [x, vs] = [key(e), value(e)]
      solns[x] = fill(vs) - x
      add(solved, x)
      
   to-list $ generate<KeyValue<Symbol, List<Symbol>>> :
      for i in (length(solved) - 1) through 0 by -1 do :
         val x = solved[i]
         val vs = unique(fill(solns[x]))
         solns[x] = vs
         yield(x => vs)   

public defn strong-components (graph: Streamable<KeyValue<Symbol, List<Symbol>>>) ->
                               List<List<Symbol>|Symbol> :
   ;Create Neighbour Table
   val vs = Vector<Symbol>()
   val neighbours = HashTable<Symbol, List<Symbol>>(symbol-hash)
   for entry in graph do :
      val v = key(entry)
      val ns = value(entry)
      add(vs, v)
      neighbours[v] = ns

   ;Active Table
   val active = HashTable<Symbol,True|False>(symbol-hash)
   for v in vs do :
      active[v] = true
   defn active? (x:Symbol) :
      get?(active, x, false)         

   ;Stack
   val stack = Vector<Symbol>()
   defn pop-until-v (v:Symbol) :
      val x = pop(stack)
      active[x] = false
      if x == v : list(x)
      else : List(x, pop-until-v(v))

   ;State Tables
   val lowlink = HashTable<Symbol,Int>(symbol-hash)
   val index-counter = to-stream(0 to false)
   val components = Vector<List<Symbol>|Symbol>()
   defn get-lowlink (v:Symbol) -> Int :
      if not key?(lowlink, v) :
         val idx = next(index-counter)
         lowlink[v] = idx
         add(stack, v)

         var cycle? = false
         for n in neighbours[v] do :
            if active?(n) :
               val nl = get-lowlink(n)
               if nl <= lowlink[v] :
                  lowlink[v] = nl
                  cycle? = true

         if lowlink[v] == idx :
            val c = pop-until-v(v)
            add{components, _} $
               if cycle? : c
               else : head(c)
      lowlink[v]

   ;Run connection
   do(get-lowlink, vs)
   to-list(components)


public defn strong-components (graph: Streamable<KeyValue<Int, List<Int>>>) ->
                               List<List<Int>|Int> :
   ;Create Neighbour Table
   val vs = Vector<Int>()
   val neighbours = HashTable<Int, List<Int>>({_})
   for entry in graph do :
      val v = key(entry)
      val ns = value(entry)
      add(vs, v)
      neighbours[v] = ns

   ;Active Table
   val active = HashTable<Int,True|False>({_})
   for v in vs do :
      active[v] = true
   defn active? (x:Int) :
      get?(active, x, false)   

   ;Stack
   val stack = Vector<Int>()
   defn pop-until-v (v:Int) :
      val x = pop(stack)
      active[x] = false
      if x == v : list(x)
      else : List(x, pop-until-v(v))

   ;State Tables
   val lowlink = HashTable<Int,Int>({_})
   val index-counter = to-stream(0 to false)
   val components = Vector<List<Int>|Int>()
   defn get-lowlink (v:Int) -> Int :
      if not key?(lowlink, v) :
         val idx = next(index-counter)
         lowlink[v] = idx
         add(stack, v)

         var cycle? = false
         for n in neighbours[v] do :
            if active?(n) :
               val nl = get-lowlink(n)
               if nl <= lowlink[v] :
                  lowlink[v] = nl
                  cycle? = true

         if lowlink[v] == idx :
            val c = pop-until-v(v)
            add{components, _} $
               if cycle? : c
               else : head(c)
      lowlink[v]

   ;Run connection
   do(get-lowlink, vs)
   to-list(components)
         
   

         
