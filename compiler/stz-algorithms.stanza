;See License.txt for details about licensing.

defpackage stz/algorithms :
   import core
   import collections

;============================================================
;================ Meta Algorithms ===========================
;============================================================

public defn* fixpoint<?T> (f: (() -> ?) -> ?T) -> T :
   var progress? = false
   val r = f({progress? = true})
   if progress? : fixpoint(f)
   else : r

public defn* worklist<?S> (f: (S, (S) -> ?) -> ?, xs:Seqable<?S>) -> False :
   val q = Queue<S>(4)
   defn add-x (x:S) : add(q, x)
   do(add-x, xs)   
   while not empty?(q) :
      f(pop(q), add-x)  

;============================================================
;============= Bipartite Closure ============================
;============================================================

val ENTRIES = Vector<KeyValue<Hashable&Equalable,List<Hashable&Equalable>>>()
val SOLNS-TABLE = HashTable<Hashable&Equalable, List<Hashable&Equalable>>()
public defn bipartite-closure<?T> (entries: Seqable<KeyValue<?T&Hashable&Equalable, List<T&Hashable&Equalable>>>) ->
                                   List<KeyValue<T, List<T>>> :
   ;Convert to vector
   clear(ENTRIES)
   add-all(ENTRIES, entries)
   
   ;Solution table
   clear(SOLNS-TABLE)
   defn cache (x:Hashable&Equalable, ys:List<Hashable&Equalable>) :
      SOLNS-TABLE[x] = ys
      ys

   ;Substitute all known solutions into xs
   defn sub-known (xs:List<Hashable&Equalable>) :
      for x in xs seq-append :
         match(get?(SOLNS-TABLE, x)) :
            (ys:List<Hashable&Equalable>) : cache(x, sub-known(ys))
            (f:False) : List(x)

   ;Compute remove(unique(xs), x)
   defn minus (xs:List<Hashable&Equalable>, x:Hashable&Equalable) :
      tail(to-list(unique(cons(x, xs))))

   ;Forward solve
   for e in ENTRIES do :
      val [x, ys] = [key(e), value(e)]
      cache(x, sub-known(ys) - x)

   ;Return solutions
   val result = for e in in-reverse(ENTRIES) seq :
      val x = key(e)
      x => sub-known(SOLNS-TABLE[x]) - x
   to-list(result) as List<KeyValue<T&Hashable&Equalable, List<T&Hashable&Equalable>>>   

;============================================================
;============= Transitive Closure ===========================
;============================================================

public defn transitive-closure<?T> (entries: Seqable<KeyValue<?T&Hashable&Equalable, List<T&Hashable&Equalable>>>) ->
                                    List<KeyValue<T, List<T>>> :
   ;Assign ids
   val id-map = Vector<T>()
   val obj-map = HashTable<Hashable&Equalable,Int>()
   val es = to-tuple(entries)
   for e in es do :
      val k = key(e)
      obj-map[k] = length(id-map)
      add(id-map, k)
      add(id-map, k)
   ;Map problem and compute bipartite-closure
   val result = bipartite-closure $
      for e in es seq :
         val x = obj-map[key(e)]
         val ys = for k in value(e) seq-append :
                     val i = obj-map[k]
                     List(i, i + 1)
         x => ys
   ;Map back
   val result* = for e in result map :
      id-map[key(e)] => map({id-map[_]}, value(e))
   result* as List<KeyValue<T&Hashable&Equalable, List<T&Hashable&Equalable>>>      

;============================================================
;============= Strongly Connected Components ================
;============================================================

public defn strong-components<?T> (graph: Seqable<KeyValue<?T&Hashable&Equalable, List<?T&Hashable&Equalable>>>) ->
                                   List<List<T>|T> :
   ;Create Neighbour Table
   val vs = Vector<T&Hashable&Equalable>()
   val neighbours = HashTable<T, List<T&Hashable&Equalable>>()
   for entry in graph do :
      val v = key(entry)
      val ns = value(entry)
      add(vs, v)
      neighbours[v] = ns

   ;Active Table
   val active = HashTable<T,True|False>()
   for v in vs do :
      active[v] = true
   defn active? (x:T&Hashable) :
      get?(active, x, false)         

   ;Stack
   val stack = Vector<T&Hashable&Equalable>()
   defn pop-until-v (v:T&Equalable) :
      val x = pop(stack)
      active[x] = false
      if x == v : List(x)
      else : cons(x, pop-until-v(v))

   ;State Tables
   val lowlink = HashTable<T,Int>()
   val index-counter = to-seq(0 to false)
   val components = Vector<List<T>|T>()
   defn get-lowlink (v:T&Hashable&Equalable) -> Int :
      if not key?(lowlink, v) :
         val idx = next(index-counter)
         lowlink[v] = idx
         add(stack, v)

         var cycle? = false
         for n in neighbours[v] do :
            if active?(n) :
               val nl = get-lowlink(n)
               if nl <= lowlink[v] :
                  lowlink[v] = nl
                  cycle? = true

         if lowlink[v] == idx :
            val c = pop-until-v(v)
            add{components, _} $
               if cycle? : c
               else : head(c)
      lowlink[v]

   ;Run connection
   do(get-lowlink, vs)
   to-list(components)

;============================================================
;================= Shuffling Engine =========================
;============================================================

public deftype ShuffleIns
public defstruct ShfMove <: ShuffleIns :
   dst:Int
   src:Int
public defstruct ShfSave <: ShuffleIns :
   n:Int
public defstruct ShfLoad <: ShuffleIns :
   n:Int

defmethod print (o:OutputStream, i:ShuffleIns) :
   print{o, _} $ match(i) :
      (i:ShfMove) : "%~ = %~" % [dst(i), src(i)]
      (i:ShfSave) : "save %~" % [n(i)]
      (i:ShfLoad) : "load %~" % [n(i)]

;Buffers
val PRED = Vector<False|Int>()
val DONE = Vector<True|False>()
val LOADS = Vector<True|False>()
val SUCC? = Vector<True|False>()

public defn shuffle (xs:List<Int>, ys:List<Int>, nreg:Int, f: ShuffleIns -> ?) :
   ;Predecessor and Successor table
   clear(PRED)
   clear(DONE)
   clear(LOADS)
   clear(SUCC?)
   set-length(PRED, nreg, false)
   set-length(DONE, nreg, false)
   set-length(LOADS, nreg, false)
   set-length(SUCC?, nreg, false)

   ;Initialize Predecessors
   for (x in xs, y in ys) do :
      if x != y :
         PRED[x] = y
      else :
         DONE[x] = true

   ;Find a simple destination. 
   defn simple-dst () :
      for i in 0 to nreg do :
         SUCC?[i] = false
      for i in 0 to nreg do :
         match(PRED[i]) :
            (p:Int) : SUCC?[p] = true
            (p:False) : false
      for i in 0 to nreg find :
         PRED[i] is-not False and 
         SUCC?[i] is False

   ;Find a remaining destination.
   defn remaining-dst () :
      for i in 0 to nreg find :
         PRED[i] is-not False
         
   ;Find a swap register
   ;Assumes SUCC? is calculated
   defn swap-reg () :
      for i in 0 to nreg find :
         SUCC?[i] is False and
         DONE[i] is False

   ;Iterate until fixpoint
   fixpoint $ fn (progress) :
      
      ;Move src to dst and update pred table
      defn move (dst:Int, src:Int) :
         progress()
         f(ShfMove(dst, src))
         for i in 0 to nreg do :
            if PRED[i] == src :
               PRED[i] = dst

      ;Save register and update pred table
      defn save (r:Int) :
         progress()
         f(ShfSave(r))
         for i in 0 to nreg do :
            if PRED[i] == r :
               PRED[i] = false
               LOADS[i] = true               

      ;Fills the dst register with its final value
      defn* fill (r:Int) :
         match(PRED[r]) :
            (p:Int) :
               move(r, p)
               PRED[r] = false
               DONE[r] = true
               fill(p)
            (p:False) :
               false
               
      match(simple-dst()) :
         (r:Int) : fill(r)
         (r:False) :
            match(remaining-dst(), swap-reg()) :
               (r:Int, s:Int) : move(s, r)
               (r:Int, s:False) : save(r)
               (r, s) : false

   ;Load saved registers
   for i in 0 to nreg do :
      if LOADS[i] :
         f(ShfLoad(i))


;============================================================
;==================== Int Tables ============================
;============================================================

public deftype IntTable<V> <: Seqable<KeyValue<Int,V>> & Lengthable 
public defmulti set<?V> (t:IntTable<?V>, k:Int, v:V) -> False
public defmulti get?<?V,?D> (t:IntTable<?V> k:Int, d:?D) -> V|D
public defmulti get<?V> (t:IntTable<?V>, k:Int) -> V
public defmulti key? (t:IntTable, k:Int) -> True|False
public defmulti clear (t:IntTable) -> False
defmulti double-capacity (t:IntTable) -> False

public defn IntTable<V> () -> IntTable<V> :
   ;              Table State
   ;              ===========
   var cap
   var limit
   var keys
   var values
   var occupied
   var size

   defn init (c:Int) :
      cap = c
      limit = cap >> 1
      keys = Array<Int>(cap)
      values = Array<V>(cap)
      occupied = Array<Int>(cap >> 5, 0)
      size = 0

   init(32)

   ;            Hashing Parameters
   ;            ==================
   defn hash (x:Int, i:Int) :
      val h1 = 3 * x + 5
      val h2 = (7 * x + 11) | 1
      val h = h1 + i * h2
      h & (cap - 1)

   ;            Table Helpers
   ;            =============
   defn set? (occupied:Array<Int>, i:Int) :
      val mask = occupied[i >> 5]
      val bit = (mask >> (i & 31)) & 1
      bit == 1

   defn occupied? (i:Int) :
      set?(occupied, i)

   defn set-occupied? (i:Int) :
      val mask = occupied[i >> 5]
      val bit = 1 << (i & 31)
      occupied[i >> 5] = mask | bit

   defn key-index (k:Int) -> Int :
      defn* loop (i:Int) :
         val s = hash(k, i)
         if occupied?(s) :
            if keys[s] == k : s
            else : loop(i + 1)
         else : s
      loop(0)

   new IntTable<V> :
      defmethod double-capacity (this) :
         val entries = to-seq(this)
         init(cap << 1)
         for entry in entries do :
            this[key(entry)] = value(entry)
            
      defmethod clear (this) :
         for i in 0 to length(occupied) do :
            occupied[i] = 0
         size = 0
      
      defmethod set (this, k:Int, v:V) :         
         ;Get key index
         val i = key-index(k)
         
         ;Set key
         if occupied?(i) :
            values[i] = v
         else :
            keys[i] = k
            values[i] = v
            set-occupied?(i)
            size = size + 1

         ;Ensure capacity
         double-capacity(this) when size >= limit
         
      defmethod get?<?D> (this, k:Int, d:?D) :
         val i = key-index(k)
         if occupied?(i) : values[i]
         else : d

      defmethod get (this, k:Int) :
         val i = key-index(k)
         if occupied?(i) : values[i]
         else : fatal("Key %~ does not exist in table." % [k])

      defmethod key? (this, k:Int) :
         val i = key-index(k)
         occupied?(i)

      defmethod length (this) :
         size
         
      defmethod to-seq (this) :
         val keys = keys
         val values = values
         val occupied = occupied
         generate<KeyValue<Int,V>> :
            for i in 0 to length(keys) do :
               if set?(occupied, i) :
                  yield(keys[i] => values[i])


;============================================================
;==================== DoubleInt Tables ======================
;============================================================

public deftype DualIntTable<V> <: Seqable<KeyValue<[Int,Int],V>> & Lengthable 
public defmulti set<?V> (t:DualIntTable<?V>, k1:Int, k2:Int, v:V) -> False
public defmulti get?<?V,?D> (t:DualIntTable<?V> k1:Int, k2:Int, d:?D) -> V|D
public defmulti get<?V> (t:DualIntTable<?V>, k1:Int, k2:Int) -> V
public defmulti key? (t:DualIntTable, k1:Int, k2:Int) -> True|False
public defmulti clear (t:DualIntTable) -> False
defmulti double-capacity (t:DualIntTable) -> False

public defn DualIntTable<V> () -> DualIntTable<V> :
   ;              Table State
   ;              ===========
   var cap
   var limit
   var keys1
   var keys2
   var values
   var occupied
   var size

   defn init (c:Int) :
      cap = c
      limit = cap >> 1
      keys1 = Array<Int>(cap)
      keys2 = Array<Int>(cap)
      values = Array<V>(cap)
      occupied = Array<Int>(cap >> 5, 0)
      size = 0

   init(32)

   ;            Hashing Parameters
   ;            ==================
   defn hash (x:Int, y:Int, i:Int) :
      val xy = x + 31 * y
      val h1 = 3 * xy + 5
      val h2 = (7 * xy + 11) | 1
      val h = h1 + i * h2
      h & (cap - 1)

   defn set? (occupied:Array<Int>, i:Int) :
      val mask = occupied[i >> 5]
      val bit = (mask >> (i & 31)) & 1
      bit == 1

   defn occupied? (i:Int) :
      set?(occupied, i)

   ;            Table Helpers
   ;            =============
   defn set-occupied? (i:Int) :
      val mask = occupied[i >> 5]
      val bit = 1 << (i & 31)
      occupied[i >> 5] = mask | bit
   
   defn* key-index (k1:Int, k2:Int) -> Int :
      defn* loop (i:Int) :
         val s = hash(k1, k2, i)
         if occupied?(s) :
            if keys1[s] == k1 and keys2[s] == k2 : s
            else : loop(i + 1)
         else : s
      loop(0)

   new DualIntTable<V> :
      defmethod double-capacity (this) :
         val entries = to-seq(this)
         init(cap * 2)
         for entry in entries do :
            val [k1, k2] = key(entry)
            this[k1, k2] = value(entry)
            
      defmethod clear (this) :
         for i in 0 to length(occupied) do :
            occupied[i] = 0
         size = 0
      
      defmethod set (this, k1:Int, k2:Int, v:V) :         
         ;Get key index
         val i = key-index(k1, k2)
         
         ;Set key
         if occupied?(i) :
            values[i] = v
         else :
            keys1[i] = k1
            keys2[i] = k2
            values[i] = v
            set-occupied?(i)
            size = size + 1

         ;Ensure capacity
         double-capacity(this) when size >= limit
         
      defmethod get?<?D> (this, k1:Int, k2:Int, d:?D) :
         val i = key-index(k1, k2)
         if occupied?(i) : values[i]
         else : d

      defmethod get (this, k1:Int, k2:Int) :
         val i = key-index(k1, k2)
         if occupied?(i) : values[i]
         else : fatal("Key [%~, %~] does not exist in table." % [k1, k2])

      defmethod key? (this, k1:Int, k2:Int) :
         val i = key-index(k1, k2)
         occupied?(i)

      defmethod length (this) :
         size
         
      defmethod to-seq (this) :
         val keys1 = keys1
         val keys2 = keys2
         val values = values
         val occupied = occupied
         generate<KeyValue<[Int,Int],V>> :
            for i in 0 to length(keys1) do :
               if set?(occupied, i) :
                  yield([keys1[i], keys2[i]] => values[i])


