;See License.txt for details about licensing.

defpackage stz/algorithms :
   import core
   import verse

public defn* fixpoint<?T> (f: (() -> ?) -> ?T) -> T :
   var progress? = false
   val r = f({progress? = true})
   if progress? : fixpoint(f)
   else : r

public defn* worklist<?S> (f: (S, (S) -> ?) -> ?, xs:Streamable<?S>) -> False :
   val q = Queue<S>(4)
   defn add-x (x:S) : add(q, x)
   do(add-x, xs)
   while not empty?(q) :
      f(pop(q), add-x)

defn minus (xs:List<Symbol>, y:Symbol) -> List<Symbol> :
   if empty?(xs) : xs
   else if head(xs) == y : tail(xs) - y
   else : List(head(xs), tail(xs) - y)

public defn bipartite-closure (entries: Streamable<KeyValue<Symbol, List<Symbol>>>) ->
                               List<KeyValue<Symbol, List<Symbol>>> :
   val solns = HashTable<Symbol,List<Symbol>>(symbol-hash)
   defn fill (x:Symbol) -> List<Symbol> :
      match(get?(solns, x, false)) :
         (xs:List<Symbol>) : fill(xs)
         (f:False) : list(x)
   defn fill (xs:List<Symbol>) -> List<Symbol> :
      map-append(fill, xs)

   val solved = Vector<Symbol>()
   for e in entries do :
      val [x, vs] = [key(e), value(e)]
      solns[x] = fill(vs) - x
      add(solved, x)

   to-list $ generate<KeyValue<Symbol, List<Symbol>>> :
      for i in (length(solved) - 1) through 0 by -1 do :
         val x = solved[i]
         val vs = unique(fill(solns[x]))
         solns[x] = vs
         yield(x => vs)

public defn strong-components (graph: Streamable<KeyValue<Symbol, List<Symbol>>>) ->
                               List<List<Symbol>|Symbol> :
   ;Create Neighbour Table
   val vs = Vector<Symbol>()
   val neighbours = HashTable<Symbol, List<Symbol>>(symbol-hash)
   for entry in graph do :
      val v = key(entry)
      val ns = value(entry)
      add(vs, v)
      neighbours[v] = ns

   ;Active Table
   val active = HashTable<Symbol,True|False>(symbol-hash)
   for v in vs do :
      active[v] = true
   defn active? (x:Symbol) :
      get?(active, x, false)

   ;Stack
   val stack = Vector<Symbol>()
   defn pop-until-v (v:Symbol) :
      val x = pop(stack)
      active[x] = false
      if x == v : list(x)
      else : List(x, pop-until-v(v))

   ;State Tables
   val lowlink = HashTable<Symbol,Int>(symbol-hash)
   val index-counter = to-stream(0 to false)
   val components = Vector<List<Symbol>|Symbol>()
   defn get-lowlink (v:Symbol) -> Int :
      if not key?(lowlink, v) :
         val idx = next(index-counter)
         lowlink[v] = idx
         add(stack, v)

         var cycle? = false
         for n in neighbours[v] do :
            if active?(n) :
               val nl = get-lowlink(n)
               if nl <= lowlink[v] :
                  lowlink[v] = nl
                  cycle? = true

         if lowlink[v] == idx :
            val c = pop-until-v(v)
            add{components, _} $
               if cycle? : c
               else : head(c)
      lowlink[v]

   ;Run connection
   do(get-lowlink, vs)
   to-list(components)


public defn strong-components (graph: Streamable<KeyValue<Int, List<Int>>>) ->
                               List<List<Int>|Int> :
   ;Create Neighbour Table
   val vs = Vector<Int>()
   val neighbours = HashTable<Int, List<Int>>({_})
   for entry in graph do :
      val v = key(entry)
      val ns = value(entry)
      add(vs, v)
      neighbours[v] = ns

   ;Active Table
   val active = HashTable<Int,True|False>({_})
   for v in vs do :
      active[v] = true
   defn active? (x:Int) :
      get?(active, x, false)

   ;Stack
   val stack = Vector<Int>()
   defn pop-until-v (v:Int) :
      val x = pop(stack)
      active[x] = false
      if x == v : list(x)
      else : List(x, pop-until-v(v))

   ;State Tables
   val lowlink = HashTable<Int,Int>({_})
   val index-counter = to-stream(0 to false)
   val components = Vector<List<Int>|Int>()
   defn get-lowlink (v:Int) -> Int :
      if not key?(lowlink, v) :
         val idx = next(index-counter)
         lowlink[v] = idx
         add(stack, v)

         var cycle? = false
         for n in neighbours[v] do :
            if active?(n) :
               val nl = get-lowlink(n)
               if nl <= lowlink[v] :
                  lowlink[v] = nl
                  cycle? = true

         if lowlink[v] == idx :
            val c = pop-until-v(v)
            add{components, _} $
               if cycle? : c
               else : head(c)
      lowlink[v]

   ;Run connection
   do(get-lowlink, vs)
   to-list(components)


;============================================================
;================= Shuffling Engine =========================
;============================================================

public definterface ShuffleIns
public defstruct ShfMove <: ShuffleIns :
   dst:Int
   src:Int
public defstruct ShfSave <: ShuffleIns :
   n:Int
public defstruct ShfLoad <: ShuffleIns :
   n:Int

defmethod print (o:OutputStream, i:ShuffleIns) :
   print{o, _} $ match(i) :
      (i:ShfMove) : "~ = ~" << [dst(i), src(i)]
      (i:ShfSave) : "save ~" << [n(i)]
      (i:ShfLoad) : "load ~" << [n(i)]

;Buffers
val PRED = Vector<False|Int>()
val DONE = Vector<True|False>()
val LOADS = Vector<True|False>()
val SUCC? = Vector<True|False>()

public defn shuffle (xs:List<Int>, ys:List<Int>, nreg:Int, f: ShuffleIns -> ?) :
   ;Predecessor and Successor table
   clear(PRED)
   clear(DONE)
   clear(LOADS)
   clear(SUCC?)
   set-length(PRED, nreg, false)
   set-length(DONE, nreg, false)
   set-length(LOADS, nreg, false)
   set-length(SUCC?, nreg, false)

   ;Initialize Predecessors
   for (x in xs, y in ys) do :
      if x != y :
         PRED[x] = y
      else :
         DONE[x] = true

   ;Find a simple destination. 
   defn simple-dst () :
      for i in 0 to nreg do :
         SUCC?[i] = false
      for i in 0 to nreg do :
         match(PRED[i]) :
            (p:Int) : SUCC?[p] = true
            (p:False) : false
      for i in 0 to nreg find :
         PRED[i] != false and 
         SUCC?[i] == false

   ;Find a remaining destination.
   defn remaining-dst () :
      for i in 0 to nreg find :
         PRED[i] != false
         
   ;Find a swap register
   ;Assumes SUCC? is calculated
   defn swap-reg () :
      for i in 0 to nreg find :
         SUCC?[i] == false and
         DONE[i] == false

   ;Iterate until fixpoint
   fixpoint $ fn (progress) :
      
      ;Move src to dst and update pred table
      defn move (dst:Int, src:Int) :
         progress()
         f(ShfMove(dst, src))
         for i in 0 to nreg do :
            if PRED[i] == src :
               PRED[i] = dst

      ;Save register and update pred table
      defn save (r:Int) :
         progress()
         f(ShfSave(r))
         for i in 0 to nreg do :
            if PRED[i] == r :
               PRED[i] = false
               LOADS[i] = true               

      ;Fills the dst register with its final value
      defn* fill (r:Int) :
         match(PRED[r]) :
            (p:Int) :
               move(r, p)
               PRED[r] = false
               DONE[r] = true
               fill(p)
            (p:False) :
               false
               
      match(simple-dst()) :
         (r:Int) : fill(r)
         (r:False) :
            match(remaining-dst(), swap-reg()) :
               (r:Int, s:Int) : move(s, r)
               (r:Int, s:False) : save(r)
               (r, s) : false

   ;Load saved registers
   for i in 0 to nreg do :
      if LOADS[i] :
         f(ShfLoad(i))