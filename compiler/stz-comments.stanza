defpackage stz/comments :
  import core
  import reader
  import collections
  import stz/parsed-path

;============================================================
;======================= TODOS ==============================
;============================================================
;- Backup documents before updating stamps.

;============================================================
;====================== Main Driver =========================
;============================================================

;Check the project document consistency.
;Returns true if documents are consistent, or false otherwise.
public defn check-project-doc-consistency (structure-file:String, accepts:Tuple<String>) -> True|False :
  ;Throw the given exception if given.
  defn throw? (e:CommentDocErrors) : throw(e)
  defn throw? (f:False) : false
  defn throw? (d:CommentDocs) : d
  defn throw? (d:CommentDoc) : d
  defn throw? (s:StructureFile) : s

  ;Read in the structure file and exit if not well formed.
  val sfile = throw? $
              check-structure-file{structure-file, _} $
              read-structure-file $
              structure-file

  ;Construct syntax table and ignore table
  val syntax-table = SyntaxTable(syntaxes(sfile))
  val ignore-table = IgnoreTable(ignores(sfile))

  ;Parse the root document and all linked files
  val root-doc = throw?(parse-comment-doc(full-path!(root(sfile)), syntax-table))
  val cdocs = throw?(read-linked-files(root-doc, syntax-table, ignore-table))

  ;Retrieve project directory listing
  val dir-files = list-dir-files(map(full-path!, files(sfile)))

  ;Check that all documents are well formed
  throw?(check-doc-wellformed(cdocs, dir-files, accepts, ignore-table))

  ;Update stamps on all documents, and collect any out-of-date errors.
  val [cdocs*, out-of-date-errors] = update-stamps(cdocs, accepts)

  ;Write back new stacks back to disk.
  write-back-to-disk(cdocs*)

  ;If there are any out-of-date errors, then report them.
  match(out-of-date-errors:CommentDocErrors) :
    ;Notify users of out-of-date errors, and return false
    ;to indicate that some documents are inconsistent.
    println(out-of-date-errors)
    false
  else :
    ;Return true to indicate all documents are consistent
    true

;<doc>=======================================================
;====================== IR Definition =======================
;============================================================
;++[Comment System Tags]

## Possible Tags and Their Examples ##

BlockTag:
  ;+[Ray Partition Box]<AFADE9901823>
  ;+[Ray Partition Box]<outdated:AFADE9901823>
  ;+[Ray Partition Box]

BlockEnd
  ;/[Ray Partition Box]

Reference
  ;@[Ray Partition Box]<AFADE9901823>
  ;@[Ray Partition Box]<outdated:AFADE9901823>
  ;@[Ray Partition Box]
  ;@[Ray Partition Box | Ray Graph]

FileReference
  ;@[file:myfile.txt]<outdated>
  ;@[file:myfile.txt]<binary>
  ;@[file:myfile.txt]

AnonymousBlock
  ;+<AFADE9901823>
  ;+<outdated:AFADE9901823>

Text
Indent
NewLine
Whitespace

;//[Comment System Tags]
;============================================================
;=======================================================<doc>

public deftype CommentItem

public defstruct CommentDocs :
  root-path: String
  docs: Tuple<CommentDoc> with: (updater => sub-docs)
  binary-files: Tuple<String>

public defstruct CommentDoc :
  path: String
  full-path: String
  params: DocParams
  items: Tuple<CommentItem> with: (updater => sub-items)
  outdated?: True|False with: (init => false, updater => sub-outdated?)

public defstruct DocParams :
  info: FileInfo|False
  block-tag-marker: String
  block-end-marker: String
  reference-marker: String

public defstruct BlockTag <: CommentItem :
  info: FileInfo
  name: String
  stamp: String|False
  outdated?: True|False
  indent: Int with: (init => 0, updater => sub-indent)
with:
  printer => true

public defstruct BlockEnd <: CommentItem :
  info: FileInfo
  name: String|Int
  implicit?: True|False with: (default => false)
with:
  printer => true

public defstruct Reference <: CommentItem :
  info: FileInfo
  names: Tuple<String>
  stamp: String|False
  outdated?: True|False
with:
  printer => true

public defstruct FileReference <: CommentItem :
  info: FileInfo
  file: String
  status: FileStatus
with:
  printer => true

public defenum FileStatus :
  StandardFile
  OutdatedFile
  BinaryFile

public defstruct AnonymousBlock <: CommentItem :
  info: FileInfo
  id: Int
  stamp: String|False
  outdated?: True|False
  indent: Int with: (init => 0, updater => sub-indent)
with:
  printer => true

public defstruct Text <: CommentItem :
  string: String
with:
  printer => true

public defstruct Whitespace <: CommentItem :
  info: FileInfo
  string: String
  preceding-block: String|Int|False with: (init => false, updater => sub-preceding-block)
  following-indent: Int|False with: (init => false, updater => sub-following-indent)
with:
  printer => true

public defstruct Indent <: CommentItem :
  info: FileInfo
  indent: Int
  following-block: String|Int|False with: (init => false, updater => sub-following-block)
with:
  printer => true

public defstruct NewLine <: CommentItem
with:
  printer => true

public defstruct EndOfFile <: CommentItem :
  info: FileInfo
with:
  printer => true

;============================================================
;======================= Printers ===========================
;============================================================

defmethod print (o:OutputStream, cdocs:CommentDocs) :
  val items = to-tuple $ cat-all $ [
    ["root-path = %~" % [root-path(cdocs)]]
    docs(cdocs)]  
  print(o, "CommentDocs(%_)" % [indented-list(items)])

defmethod print (o:OutputStream, doc:CommentDoc) :
  val items = [
    "path = %~" % [path(doc)]
    "full-path = %~" % [full-path(doc)]
    "outdated? = %~" % [outdated?(doc)]
    "items = [%_]" % [indented-list(items(doc))]]
  print(o, "CommentDoc(%_)" % [indented-list(items)])

defn indented-list (xs:Collection) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, xs)

;============================================================
;================== Check Structure File ====================
;============================================================
defn check-structure-file (structure-file:String, f:StructureFile) -> CommentDocErrors|StructureFile :
  val errors = Vector<CommentDocError>()

  ;Retrieve path representing directory containing .doc file.
  val docdir = 
    try :
      enclosing-dir(parse-path(structure-file))
    catch (e:UpPastRoot) :
      fatal("Unexpected error finding enclosing directory of rootfile.")

  ;Return full path relative to .doc file.
  defn relative-to-doc (filepath:String) -> String|False :
    try :
      val path = relative-to-dir(docdir, parse-path(filepath))
      resolve-path(to-string(path))
    catch (e:UpPastRoot) :      
      false

  ;Check that the given file represents a proper root file.
  defn check-root! (f:DocFile) -> DocFile :
    val full-path = relative-to-doc(file(f))
    match(full-path:String) :
      if file-type(full-path) is FileType :
        sub-full-path(f, full-path)
      else :
        add(errors, CouldNotReadRootFile(info(f), file(f)))
        f
    else :
      add(errors, CouldNotFindRootFile(info(f), file(f)))
      f

  ;Check the given doc file, and if it exists, then fills in its fullpath.
  defn check-file! (df:DocFile) -> DocFile :
    match(relative-to-doc(file(df))) :
      (full-path:String) :
        sub-full-path(df, full-path)
      (f:False) :
        add(errors, CouldNotFindDocFile(info(df), file(df)))
        df

  defn check-pattern! (fp:FilePattern) -> FilePattern :
    try :
      sub-pattern(fp, GlobPattern(docdir, file(fp)))
    catch (e:PathResolutionError|UpPastRoot) :
      add(errors, CouldNotFindDocFile(info(fp), file(fp)))
      fp
    catch (e:InvalidGlob) :
      add(errors, InvalidGlob(info(fp), file(fp)))
      fp

  defn check-params! (p:DocParams) :
    if empty?(block-tag-marker(p)) or
       empty?(block-end-marker(p)) or
       empty?(reference-marker(p)) :
      add(errors, EmptyTag(info(p)))

  defn check-syntax! (s:DocSyntax) -> DocSyntax :
    check-params!(params(s))
    sub-pattern(s, check-pattern!(pattern(s)))

  defn main () :
    val root* = check-root!(root(f))
    val files* = map(check-file!, files(f))
    val syntaxes* = map(check-syntax!, syntaxes(f))
    val ignores* = map(check-pattern!, ignores(f))

    ;Return errors
    if empty?(errors) : StructureFile(root*, files*, syntaxes*, ignores*)
    else : CommentDocErrors(to-tuple(errors))    

  main()

;============================================================
;======================= Glob Pattern =======================
;============================================================

deftype GlobPattern
defstruct SuffixPattern <: GlobPattern :
  suffix: String
defstruct PathPattern <: GlobPattern :
  path: String
  full-path: String

;Throws PathResolutionError|UpPastRoot if the file does not exist.
;Throws InvalidGlob if pattern is not wellformed.
defn GlobPattern (docdir:ParsedPath, string:String) -> GlobPattern :
  if prefix?(string, "*") :
    ;Ensure valid suffix pattern.
    defn invalid-glob! () :
      throw(InvalidGlob(string))
    try :
      val path = parse-path(string)
      invalid-glob!() when contains?(string[1 to false], '*')
      invalid-glob!() when length(entries(path)) != 1
      invalid-glob!() when entries(path)[0] is-not NamedPath
    catch (e:UpPastRoot) : invalid-glob!()
    ;Return suffix pattern.
    SuffixPattern(string[1 to false])
  else :
    val abs-path = relative-to-dir(docdir, parse-path(string))
    val full-path = resolve-path!(to-string(abs-path))
    PathPattern(string, full-path)

;Return true if the given glob pattern matches the path.
defn match? (p:GlobPattern, path:String) -> True|False :
  match(p) :
    (p:SuffixPattern) : suffix?(path, suffix(p))
    (p:PathPattern) : full-path(p) == path

;Table returns the DocParams to use for each
;given document.
deftype SyntaxTable
defmulti get (t:SyntaxTable, path:String) -> DocParams

defn SyntaxTable (syntaxes:Tuple<DocSyntax>) :
  val patterns = Vector<KeyValue<GlobPattern,DocParams>>()
  for syntax in syntaxes do :
    val pattern = pattern(pattern(syntax)) as GlobPattern
    add(patterns, pattern => params(syntax))
  val default-params = DocParams(false, "+", "/", "@")
  new SyntaxTable :
    defmethod get (this, path:String) :
      val p = for entry in patterns first :
        if match?(key(entry), path) : One(value(entry))
        else : None()
      if empty?(p) : default-params
      else : value!(p)    

;Table returns true if the given full path should be ignored.
deftype IgnoreTable
defmulti get (t:IgnoreTable, path:String) -> True|False

defn IgnoreTable (files:Tuple<FilePattern>) :
  val patterns = map({pattern(_) as GlobPattern}, files)
  new IgnoreTable :
    defmethod get (this, path:String) :
      any?(match?{_, path}, patterns)

;============================================================
;========================= Parsing ==========================
;============================================================

defn parse-comment-doc (path:String, syntax-table:SyntaxTable) -> CommentDoc|CommentDocErrors :
  parse-comment-doc(path, resolve-path!(path), syntax-table)

defn parse-comment-doc (path:String, full-path:String, syntax-table:SyntaxTable) -> CommentDoc|CommentDocErrors :
  val string = slurp(path)
  val stream = StringInputStream(string, path)
  val params = syntax-table[full-path]
  parse-comment-doc(stream, path, full-path, params)

public defn parse-comment-doc (stream:StringInputStream, path:String, full-path:String, params:DocParams) -> CommentDoc|CommentDocErrors :
  ;Compute statistics on markers
  val block-tag-marker-len = length(block-tag-marker(params))
  val block-end-marker-len = length(block-end-marker(params))
  val reference-marker-len = length(reference-marker(params))
  val outdated-str = "outdated:"
  val outdated-len = length(outdated-str)
  val fileref-str = "file:"
  val fileref-len = length(fileref-str)

  ;Accumulate errors
  val errors = Vector<CommentDocError>()

  ;Eat the given number of characters.
  defn eat-chars (n:Int) -> False :
    for i in 0 to n do : get-char(stream)

  ;Return true if the given character is a newline
  defn newline? (c:Char|False) -> True|False :
    c == '\n'

  ;Return true if the given character is a whitespace character
  defn whitespace? (c:Char|False) -> True|False:
    c == ' ' or c == '\t' or c == '\r'

  ;Return true if 'string' appears at position 'i' in the stream.
  defn upcoming-string? (i:Int, string:String) -> True|False :
    if empty?(string) :
      true
    else if peek?(stream,i) == string[0] :
      for j in 1 to length(string) all? :
        peek?(stream,i + j) == string[j]

  ;Return true if 'char' appears at position 'i' in the stream.
  defn upcoming-char? (i:Int, char:Char) -> True|False :
    peek?(stream,i) == char

  ;Return the index in the stream where 'char' appears, or
  ;false otherwise. Newlines mark the end of the searchable region.
  defn index-of-line-char? (start:Int, char:Char) -> Int|False :
    val n = length(stream)
    let loop (i:Int = start) :
      if i < n :
        val c = peek(stream,i)
        if newline?(c) : false
        else if c == char : i
        else : loop(i + 1)

  ;Return the index past the end of the line.
  defn index-of-line-end (start:Int) -> Int :
    val n = length(stream)
    let loop (i:Int = start) :
      if i < n :
        if newline?(peek?(stream,i)) : i
        else : loop(i + 1)
      else : n

  ;Return true if the upcoming character in the stream can be one
  ;of the special characters to handle. Otherwise it is just a simple
  ;character.
  val block-tag-char = block-tag-marker(params)[0]
  val block-end-char = block-end-marker(params)[0]
  val reference-char = reference-marker(params)[0]
  defn upcoming-special-char? () -> True|False :
    match(peek?(stream,0)) :
      (c:Char) : c == block-tag-char or c == block-end-char or c == reference-char or newline?(c)
      (c:False) : true

  ;Return true if there is an upcoming block tag:
  ;e.g. ;+[port definition]
  defn upcoming-block-tag? () -> True|False :
    upcoming-string?(0, block-tag-marker(params)) and
    upcoming-char?(block-tag-marker-len, '[')
  ;Return true if there is an upcoming block end:
  ;e.g. ;/[port definition]
  defn upcoming-block-end? () -> True|False :
    upcoming-string?(0, block-end-marker(params)) and
    upcoming-char?(block-end-marker-len, '[')
  ;Return true if there is an upcoming reference:
  ;e.g. ;@[port definition]
  defn upcoming-reference? () -> True|False :
    upcoming-string?(0, reference-marker(params)) and
    upcoming-char?(reference-marker-len, '[')
  ;Return true if there is an upcoming anonymous reference:
  ;e.g. ;+<AFAD1241F>
  defn upcoming-anonymous? () -> True|False :
    upcoming-string?(0, block-tag-marker(params)) and
    upcoming-char?(block-tag-marker-len, '<')
  ;Return true if there is a line with no characters
  ;except for whitespace.
  defn upcoming-whitespace? () -> True|False :
    val end = index-of-line-end(0)
    for i in 0 to end all? :
      whitespace?(peek(stream,i))
  ;Return true if the end of the file is upcoming.
  defn upcoming-eof? () -> True|False :
    peek?(stream,0) == false
  ;Return true if a new line is upcoming.
  defn upcoming-newline? () -> True|False :
    newline?(peek?(stream,0))

  ;Parse the [...] tag at the given index.
  ;If the closing character cannot be found, then an error is added
  ;to the error-list, the rest of the line is eaten, and fail() is called. 
  defn parse-bracket (start:Int, start-char:Char, end-char:Char) -> String|False :
    if upcoming-char?(start, start-char) :
      val tag-end = index-of-line-char?(start, end-char)
      match(tag-end:Int) :
        ;Compute the number of chars within the bracketing characters.
        val num-chars = tag-end - (start + 1)
        ;Eat past opening [
        eat-chars(start + 1)
        ;Retrieve characters within [...]
        val tag-string = get-chars(stream, num-chars)
        ;Eat closing ]
        eat-chars(1)
        ;Return tag string
        trim(tag-string)
      else :
        ;Report error
        val info = info(stream)
        add(errors, NoEndingBracket(info, end-char))
        ;Eat rest of line, and fail.
        eat-chars(index-of-line-end(start))
        fail()

  ;Parse the tag starting at index i.
  ;Assumes that character tag-start == '['.
  ;Returns [bracket-string, paren-string], where bracket-string
  ;is the string within the [...], and paren-string is the string
  ;within the following (...).
  ;Calls fail() if any bracket is unclosed.
  defn parse-tag (tag-start:Int) -> [String, String|False] :
    val bracket-str = parse-bracket(tag-start, '[', ']') as String
    val paren-str = parse-bracket(0, '<', '>')
    [bracket-str, paren-str]

  ;Parse the upcoming whitespace line.
  defn parse-whitespace () -> Whitespace :
    val info = info(stream)
    val end = index-of-line-end(0)
    val str = get-chars(stream, end)
    Whitespace(info, str)

  ;Split up an outdated tag into a flag and a string.
  defn split-outdated-tag (string:String|False) -> [String|False, True|False] :
    match(string:String) :
      if prefix?(string, outdated-str) :
        val stamp = string[outdated-len to false]
        [stamp, true]
      else : [string, false]
    else : [false, true]

  ;Parse the upcoming block tag.
  ;Calls fail() if bracket is unclosed.
  defn parse-block-tag () -> BlockTag :
    val info = info(stream)
    val [name, paren-str] = parse-tag(block-tag-marker-len)
    val [stamp, outdated?] = split-outdated-tag(paren-str)
    BlockTag(info, name, stamp, outdated?)

  ;Parse the upcoming block end tag.
  ;Calls fail() bracket is not closed.
  defn parse-block-end () -> BlockEnd :
    val info = info(stream)
    val string = parse-bracket(block-end-marker-len, '[', ']') as String
    BlockEnd(info, string)

  ;Convert file status string into an enum.
  defn file-status (info:FileInfo, str:String|False) -> FileStatus :
    switch(str) :
      false : StandardFile
      "outdated" : OutdatedFile
      "binary" : BinaryFile
      else :
        add(errors, InvalidFileStatus(info, str as String))
        BinaryFile

  ;Parse the upcoming reference or file reference.
  ;Reports an error if file status is invalid.
  ;Calls fail() if bracket is unclosed.
  defn parse-reference () -> Reference|FileReference :
    val info = info(stream)
    val [bracket-str, paren-str] = parse-tag(reference-marker-len)
    if prefix?(bracket-str, fileref-str) :
      val filename = bracket-str[fileref-len to false]
      FileReference(info, filename, file-status(info, paren-str))
    else :
      val [stamp, outdated?] = split-outdated-tag(paren-str)
      val names = to-tuple $ seq(trim, split(bracket-str, "|"))
      Reference(info, names, stamp, outdated?)

  ;Parse the upcoming anonymous block.
  ;Calls fail() if any bracket is unclosed.
  defn parse-anonymous () -> AnonymousBlock :
    val info = info(stream)
    val string = parse-bracket(block-tag-marker-len, '<', '>') as String
    val [stamp, outdated?] = split-outdated-tag(string)
    val stamp* = (str when not empty?(str)) where :
      val str = stamp as String
    AnonymousBlock(info, genid(), stamp*, outdated?)

  ;Eat the upcoming character in the input stream.
  defn parse-char () -> Char :
    get-char(stream) as Char

  ;Parse the upcoming new line
  defn parse-newline () -> NewLine :
    get-char(stream)
    NewLine()

  ;Parse the upcoming indent
  defn parse-indent () -> Indent :
    val info = info(stream)
    val num-whitespace =
      for i in 0 to false find! :
        not whitespace?(peek?(stream,i))
    Indent(info, num-whitespace)

  ;Accumulate parsed items
  val item-accum = Vector<CommentItem>()
  val char-accum = StringBuffer()

  ;Add a new character to the accumulator.
  defn add-item (c:Char) :
    add(char-accum, c)
  ;Add a new comment item to the accumulator.
  defn add-item (item:CommentItem) :
    flush-chars()
    add(item-accum, item)
  ;Retrieve all parsed items in the accumulator.
  defn parsed-items () -> Tuple<CommentItem> :
    flush-chars()
    to-tuple(item-accum)
  ;Helper: Empty the character accumulator and create a Text item.
  defn flush-chars () :
    if not empty?(char-accum) :
      add(item-accum, Text(to-string(char-accum)))
      clear(char-accum)

  ;Launch!
  defn main () :
    ;Starting line
    if upcoming-whitespace?() :
      add-item(parse-whitespace())
    else :
      add-item(parse-indent())

    ;Preconditions for starting loop
    ;  Any indents/whitespace at the beginning of the file has been parsed.
    let loop () :
      if upcoming-special-char?() :
        if upcoming-block-tag?() :
          attempt: add-item(parse-block-tag())
          loop()
        else if upcoming-block-end?() :
          attempt: add-item(parse-block-end())
          loop()
        else if upcoming-reference?() :
          attempt: add-item(parse-reference())
          loop()
        else if upcoming-anonymous?() :
          attempt: add-item(parse-anonymous())
          loop()
        else if upcoming-newline?() :
          add-item(parse-newline())
          if upcoming-whitespace?() :
            add-item(parse-whitespace())
            loop()
          else :
            add-item(parse-indent())
            loop()
        else if upcoming-eof?() :
          add-item(EndOfFile(info(stream)))
        else :
          add-item(parse-char())
          loop()
      else :    
        add-item(parse-char())
        loop()

    ;Return items
    if empty?(errors) : CommentDoc(path, full-path, params, parsed-items())
    else : CommentDocErrors(to-tuple(errors))

  ;Launch!
  main()

;============================================================
;==================== Read Linked Files =====================
;============================================================
  
defn read-linked-files (root-doc:CommentDoc, syntax-table:SyntaxTable, ignore-table:IgnoreTable) -> CommentDocs|CommentDocErrors :
  ;Table to keep track of all documents.
  val files = HashTable<String,CommentDoc|CommentDocErrors|BinaryFile>()
  defn add-file (full-path:String, doc:CommentDoc|CommentDocErrors|BinaryFile) :
    files[full-path] = doc

  ;Track all errors
  val errors = Vector<CommentDocError>()

  ;Track all dependencies
  val link-table = HashTable<String,Tuple<Link>>()  

  ;Read in and scan linked files in the given comment doc, unless
  ;the doc has already been scanned.
  ;The path and full-path to the comment doc is given.
  defn scan-doc (path:String, full-path:String) :
    if not key?(files, full-path) :
      val doc = parse-comment-doc(path, full-path, syntax-table)
      add-file(full-path, doc)
      match(doc:CommentDoc) :
        scan-doc(doc)

  ;Scan all referenced files in the given comment doc.
  ;Updates the link-table as well.
  ;If the reference is to a StandardFile or OutdatedFile:
  ;  Scan as normal.
  ;If the reference is to a BinaryFile:
  ;  Add the file as BinaryFile, but do not scan.
  defn scan-doc (doc:CommentDoc) :
    ;Returns the full path to the given filepath, assuming that it is
    ;defined relative to the current doc.
    ;Returns [full-path, resolved-path].
    ;Throws:
    ;  PathResolutionError - if file does not exist.
    ;  UpPastRoot - if joining the file path fails.
    defn relative-to-doc-file (filepath:String) -> [String, String] :
      val ppath = parse-path(filepath)
      val dirpath = enclosing-dir(parse-path(path(doc)))
      val fullpath = to-string(relative-to-dir(dirpath, ppath))
      [fullpath, resolve-path!(fullpath)]

    ;Track all linked files
    val links = Vector<Link>()

    ;Scan each file reference
    for ref in filter-by<FileReference>(items(doc)) do :
      try :
        val [path, full-path] = relative-to-doc-file(file(ref))
        if not ignore-table[full-path] :
          add(links, Link(full-path, status(ref)))
          if status(ref) is BinaryFile : add-file(full-path, BinaryFile)
          else : scan-doc(path, full-path)
      catch (e:PathResolutionError|UpPastRoot) :
        add(errors, UnresolvedFile(info(ref), file(ref)))

    ;Record links
    link-table[full-path(doc)] = to-tuple(links)

  ;Compute status of files.
  ;  An up-to-date file is a file that is reachable through only
  ;  up-to-date references.
  defn compute-outdated (cdocs:CommentDocs) -> CommentDocs :
    ;Compute set of up-to-date files.
    val up-to-date = HashSet<String>()
    defn mark-up-to-date (path:String) :
      if add(up-to-date, path) :
        for link in link-table[path] do :
          mark-up-to-date(/path(link)) when status(link) is StandardFile
    mark-up-to-date(full-path(root-doc))
    ;Annotate a doc with its status
    defn annotate (doc:CommentDoc) -> CommentDoc :
      val outdated? = not up-to-date[full-path(doc)]
      sub-outdated?(doc, outdated?)
    ;Annotate all docs
    val docs* = map(annotate, docs(cdocs))
    sub-docs(cdocs, docs*)

  ;If any errors occurred during linking, then collect them
  ;into a single CommentDocErrors structure.
  defn collect-errors () -> CommentDocErrors|False :
    val errors? = not empty?(errors) or
                  any?({value(_) is CommentDocErrors}, files)
    if errors? :
      val file-errors = filter-by<CommentDocErrors>(values(files))
      CommentDocErrors $ cat(
        [CommentDocErrors(to-tuple(errors))],
        file-errors)

  ;Launch!
  add-file(full-path(root-doc), root-doc)
  scan-doc(root-doc)
  match(collect-errors()) :
    (e:CommentDocErrors) :
      e
    (f:False) :
      val docs* = to-tuple $ filter-by<CommentDoc>(values(files))
      val bfiles* = to-tuple $ seq(key, filter({value(_) is BinaryFile}, files))
      val cdocs = CommentDocs(full-path(root-doc), docs*, bfiles*)
      compute-outdated(cdocs)

defstruct Link :
  path: String
  status: FileStatus

;============================================================
;================ Read all Files in Directory ===============
;============================================================
defstruct DirFiles :
  paths: Tuple<DirFile>
  
defstruct DirFile :
  path: String
  full-path: String
with:
  printer => true

defn list-dir-files (files:Tuple<String>) -> DirFiles :
  val accum = Vector<DirFile>()
  defn join-path (dir:ParsedPath, file:String) -> ParsedPath :
    relative-to-dir(dir, parse-path(file))
  defn scan (path:ParsedPath) :
    val file = to-string(path)
    match(file-type(file)) :
      (dir-type:DirectoryType) :
        for filename in dir-files(file) do :
          scan(join-path(path, filename))
      (file-type) :
        val full-path = resolve-path!(file)
        add(accum, DirFile(file, full-path))
  do(scan{parse-path(_)}, files)
  DirFiles(to-tuple(accum))    

;============================================================
;================== Check Docs Wellformedness ===============
;============================================================

;Check that the given documents are well-formed.
;Returns CommentDocErrors if there are errors or False otherwise.
defn check-doc-wellformed (cdocs:CommentDocs,
                           files:DirFiles,
                           accepts:Tuple<String>,
                           ignore-table:IgnoreTable) -> CommentDocErrors|False :
  ;Accumulate all errors
  val errors = Vector<CommentDocError>()

  ;Staged checking utility.
  ;Calling stop-if-errors will exit the block defined by
  ;staged-checking if any errors has been added since
  ;the block started.
  var stop-if-errors: () -> False = fatal{"Not in staged-checking block."}
  defn staged-checking (body:() -> ?) -> False :
    val num-errors = length(errors)
    label return :
      defn return-if-errors () :
        return() when length(errors) > num-errors
      let-var stop-if-errors = return-if-errors :
        body()    

  ;Scan document for any duplicate blocks or block ends.
  defn scan-for-duplicate-blocks (doc:CommentDoc) :
    val block-table = HashTable<String,BlockTag>()
    val end-table = HashTable<String,BlockEnd>()
    for item in items(doc) do :
      match(item) :
        (block:BlockTag) :
          if key?(block-table, name(block)) :
            val old-block = block-table[name(block)]
            add(errors, DuplicateBlockInFile(name(block), info(block), info(old-block)))
          else :
            block-table[name(block)] = block
        (end:BlockEnd) :
          val name = name(end) as String
          if key?(end-table, name) :
            val old-end = end-table[name]
            add(errors, DuplicateEndInFile(name, info(end), info(old-end)))
          else :
            end-table[name] = end
        (item) :
          false

  ;Scan document to ensure that ending tags are properly nested.
  ;Assumes that 'scan-for-duplicate-blocks' does not detect any errors.
  defn scan-for-invalid-nesting (doc:CommentDoc) :
    ;Stack of opened blocks seen thus far.
    val block-stack = Vector<BlockTag>()
    
    ;Returns the index of the block with the given name.
    defn index-of-block-on-stack! (block-name:String) -> Int :
      for b in block-stack index-when! :
        name(b) == block-name
        
    ;Block end set
    val block-end-set = to-hashset<String> $
      for item in filter-by<BlockEnd>(items(doc)) seq :
        name(item) as String
        
    ;Scan through each item, and process each
    ;BlockTag and BlockEnd.
    for item in items(doc) do :
      match(item) :
        (item:BlockTag) :
          add(block-stack, item) when block-end-set[name(item)]
        (item:BlockEnd) :
          val end-name = name(item) as String
          val index = index-of-block-on-stack!(end-name)
          if index != length(block-stack) - 1 :
            val skipped-block-names = to-tuple $
              seq(name, block-stack[(index + 1) to false])
            add(errors, InvalidNestedBlock(info(item), end-name, skipped-block-names))
          remove(block-stack, index)
        (item) : false

  ;Scan document for within-document errors.
  defn scan (doc:CommentDoc) :
    within staged-checking() :
      scan-for-duplicate-blocks(doc)
      stop-if-errors()
      scan-for-invalid-nesting(doc)

  ;Build table of all defined blocks and references in all up-to-date docs.
  ;If there are any duplicate blocks, these errors are added to the error buffer.
  defn defined-blocks-and-references () :
    val block-table = HashTable<String,BlockTag>()
    val ref-table = HashTable<String,List<Reference>>(List())
    for doc in up-to-date-docs(cdocs) do :
      for item in items(doc) do :
        match(item) :
          (block:BlockTag) :
            if key?(block-table, name(block)) :
              val old-block = block-table[name(block)]
              add(errors, DuplicateBlock(name(block), info(block), info(old-block)))
            else :
              block-table[name(block)] = block
          (ref:Reference) :
            for name in names(ref) do :
              update(ref-table, cons{ref, _}, name)
          (item) :
            false
    [block-table, ref-table]

  ;Check for the following:
  ;  - All references are to a defined block.
  ;  - All blocks are referenced at least once.
  defn check-consistent-references (blocks:HashTable<String,BlockTag>,
                                    references:HashTable<String,List<Reference>>) :
    ;Detect any references to undefined blocks.
    for entry in references do :
      if not key?(blocks, key(entry)) :
        val infos = to-tuple(seq(info, value(entry)))
        add(errors, UnresolvedBlock(key(entry), infos))
    ;Detect any blocks without a reference.
    for block in values(blocks) do :
      if not key?(references, name(block)) :
        add(errors, UnreferencedBlock(info(block), name(block)))

  ;Check that all blocks marked as accepted are defined.
  defn check-accepts-defined (blocks:HashTable<String,BlockTag>) :
    for accept in accepts do :
      if not key?(blocks, accept) :
        add(errors, UnresolvedAccept(accept))

  ;Check that all registered files are described by root document.
  defn check-all-files-described () :
    ;Compute set of all documents described by root.
    val doc-set = to-hashset<String> $ cat(
      seq(full-path, docs(cdocs)),
      binary-files(cdocs))
    for file in paths(files) do :
      if not ignore-table[full-path(file)] and not doc-set[full-path(file)] :
        add(errors, UndescribedFile(path(file)))

  ;Main algorithm
  defn main () :
    within staged-checking() :
      ;Check individual doc consistency.
      do(scan, docs(cdocs))
      stop-if-errors()
      ;Check project consistency.
      val [blocks, references] = defined-blocks-and-references()
      check-consistent-references(blocks, references)
      check-all-files-described()
      check-accepts-defined(blocks)
    ;Return errors if there are errors
    if not empty?(errors) :
      CommentDocErrors(to-tuple(errors))

  ;Launch!
  main()    

;Return sequence of all up-to-date documents.
defn up-to-date-docs (cdocs:CommentDocs) -> Seqable<CommentDoc> :
  for doc in docs(cdocs) filter :
    not outdated?(doc)

;============================================================
;================ Stamp Updating Driver =====================
;============================================================
defn update-stamps (cdocs:CommentDocs, accepts:Tuple<String>) -> [CommentDocs, CommentDocErrors|False] :
  val cdocs* = sub-docs(cdocs, map(compute-implicit-ends, docs(cdocs)))
  val stamp-table = compute-stamps(cdocs*)
  update-stamps(cdocs, stamp-table, accepts)

;<doc>=======================================================
;================ Find Implicit Block Ends ==================
;============================================================
Example of Computed Ends:

  ;+[A]
  asdf asdf :
    asdf asdf
    ;+[B]
    asdf asdf :
      asdf
      asdf

      asdf
      sadf       <-- End of block [B]

    ;+[C]
    asdfasdf :
      asdf
      asdf

      asdf
      asdf       <-- End of block [C]
                 <-- End of block [A]
  ;+[D]
  
  asdf asdf :
    asdf asdf
    asdf         <-- End of block [D]

  ;+[E]
  asdf
  asdf           <-- End of block [E]

  ;+[F]
  asdf asdf :
    ;+[G]
    asdf :
      asdf
      asdf       <-- End of block [G]

    ;+[H]
    asdf :
      asdf
      asdf       <-- End of block [H]
  asdf asdf
  asdf asdf
  asdf           <-- End of block [F]

  ;+[I]
  asfd asdf :
    asdf         <-- End of block [I]
    
;============================================================
;=======================================================<doc>

public defn compute-implicit-ends (doc:CommentDoc) -> CommentDoc :
  ;Compute set of all ending tags in document.
  defn compute-block-end-set () -> HashSet<String> :
    val ends = filter-by<BlockEnd>(items(doc))
    val end-names = seq({name(_) as String}, ends)
    to-hashset<String>(end-names)

  ;Returns true if the given block marker requires an implicit end.
  val block-end-set = compute-block-end-set()
  defn requires-implicit-end? (item:BlockTag|AnonymousBlock) -> True|False :
    match(item) :
      ;Named blocks have an implicit end only if they do not have
      ;an explicit end.
      (item:BlockTag) :
        not block-end-set[name(item)]
      ;Anonymous blocks always have an implicit end.
      (item:AnonymousBlock) :
        true

  ;Compute indent information for items
  defn compute-indent-annotations (items:Tuple<CommentItem>) -> Collection<CommentItem> :
    ;Cache in vector for compute.
    val item-list = to-vector<CommentItem>(items)
    val num-items = length(item-list)

    ;First compute indents of blocks
    var prev-indent:Int = 0
    var prev-block:String|Int|False = false
    for i in 0 to num-items do :
      match(item-list[i]) :
        (item:BlockTag|AnonymousBlock) :
          item-list[i] = sub-indent(item, prev-indent)
          prev-block = block-id(item)
        (item:Whitespace) :
          item-list[i] = sub-preceding-block(item, prev-block)
        (item:Indent) :
          prev-indent = indent(item)
          prev-block = false
        (item) : false

    ;Then compute following indents of whitespace, and following blocks of indents.
    var next-indent:Int|False = false
    var next-block:String|Int|False = false
    for i in reverse(0 to num-items) do :
      match(item-list[i]) :
        (item:BlockTag|AnonymousBlock) : next-block = block-id(item)
        (item:NewLine) : next-block = false
        (item:Whitespace) :
          item-list[i] = sub-following-indent(item, next-indent)
        (item:Indent) :
          item-list[i] = sub-following-block(item, next-block)
          next-indent = indent(item)
        (item) : false

    ;Return items
    item-list

  ;Scan through each item, and generate implicit ends.
  defn generate-implicit-ends (items:Collection<CommentItem>) -> Tuple<CommentItem> :
    ;Track new items containing newly generated implicit ends.
    val item-list = Vector<CommentItem>()

    ;Track stack of opened blocks.
    val block-stack = Vector<BlockTag|AnonymousBlock>()

    ;Find the index of the corresponding opening block on the block-stack.
    defn index-of-block-on-stack (end:BlockEnd) -> Int :
      for block in block-stack index-when! :
        match(block:BlockTag) :
          name(block) == name(end)

    ;Returns the corresponding implicit end for the given block.
    defn implicit-end (block:BlockTag|AnonymousBlock, info:FileInfo) -> BlockEnd :
      BlockEnd(info, block-id(block), true)

    ;Assumes block-stack is not empty. Pops the top block
    ;off, and inserts the appropriate implicit ends if required.
    ;The given info is the FileInfo to use for any generated implicit ends.
    defn pop-block (info:FileInfo) :
      val block = pop(block-stack)
      if requires-implicit-end?(block) :
        add(item-list, implicit-end(block, info))

    ;If the top block requires an implicit end, and the given
    ;whitespace line or indent ends it, then pop it off using pop-block.
    ;Returns true if a block has been popped off.
    defn pop-implicit-block? (item:Whitespace|Indent) -> True|False :
      if not empty?(block-stack) :
        val block = peek(block-stack)
        if requires-implicit-end?(block) :
          val block-ends? = match(item) :
            (item:Whitespace) :
              if preceding-block(item) != block-id(block) :
                match(following-indent(item)) :
                  (i:Int) : i <= indent(block)
                  (f:False) : true
            (item:Indent) :
              match(following-block(item)) :
                (f:False) : indent(item) < indent(block)
                (id) : indent(item) <= indent(block)
          if block-ends? :
            pop-block(info(item))
            true

    ;Scan through each item
    for item in items do :
      match(item) :
        (item:BlockTag|AnonymousBlock) :
          add(block-stack, item)
        (item:BlockEnd) :
          val index = index-of-block-on-stack(item)
          ;Pop blocks including matched block.
          while length(block-stack) > index : pop-block(info(item))
        (item:Whitespace|Indent) :
          while pop-implicit-block?(item) : ()
        (item:EndOfFile) :
          while not empty?(block-stack) :
            pop-block(info(item))
        (item) :
          false
      ;Add original item
      add(item-list, item)

    ;Return new items
    to-tuple(item-list)

  ;Main algorithm
  defn main () :
    val annotated = compute-indent-annotations(items(doc))
    val items* = generate-implicit-ends(annotated)
    sub-items(doc, items*)

  ;Launch!
  main()

;Return the identifier of the given block
defn block-id (b:BlockTag|AnonymousBlock) -> String|Int :
  match(b) :
    (b:BlockTag) : name(b)
    (b:AnonymousBlock) : id(b)

;============================================================
;=================== Stamp Computation ======================
;============================================================

defn compute-stamps (cdocs:CommentDocs) -> StampTable :
  StampTable $ to-hashtable<String|Int,Int> $
    seq-cat(compute-stamp-codes, docs(cdocs))

defn compute-stamp-codes (doc:CommentDoc) -> HashTable<String|Int,Int> :
  ;Utility for computing the stamp string.
  val stamp-buffer = StringBuffer()

  ;Return true if character represents a whitespace character.
  ;Ignored during stamp computation.
  defn whitespace? (c:Char) -> True|False :
    c == ' ' or c == '\t' or c == '\r'

  ;Add string into stamp buffer for use in computing stamps.
  defn add-stamp-buffer (str:String) :
    for c in str do :
      add(stamp-buffer, c) when not whitespace?(c)

  ;Utility for executing a body and then computing the
  ;total stamp for all calls to add-stamp-buffer.
  defn compute-stamp-code (body:() -> ?) -> Int :
    clear(stamp-buffer)
    body()
    hash(to-string(stamp-buffer))

  ;Compute stamp for items from start (exclusive) to end (exclusive).
  defn stamp (start:Int, end:Int) -> Int :
    within compute-stamp-code() :
      for i in (start + 1) through (end - 1) do :
        match(items(doc)[i]) :
          (item:Reference) : do(add-stamp-buffer, names(item))
          (item:FileReference) : add-stamp-buffer(file(item))
          (item:Text) : add-stamp-buffer(string(item))
          (item) : false

  ;Sanity check: Blocks should be properly nested.
  defn ensure-matched! (b:BlockTag|AnonymousBlock, e:BlockEnd) :
    fatal("Mismatched blocks!") when block-id(b) != name(e)

  ;Compute
  defn main () :
    ;Each entry is [block, index]
    val block-stack = Vector<[BlockTag|AnonymousBlock,Int]>()
    val items* = to-vector<CommentItem>(items(doc))
    val stamp-table = HashTable<String|Int, Int>()
    for (item in items(doc), i in 0 to false) do :
      match(item) :
        (item:BlockTag|AnonymousBlock) :
          add(block-stack, [item, i])
        (item:BlockEnd) :
          val [block, index] = pop(block-stack)
          ensure-matched!(block, item)
          stamp-table[block-id(block)] = stamp(index,i)
        (item) : false
    stamp-table

  ;Launch!
  main()

;------------------------------------------------------------
;-------------- String Stamp Representations ----------------
;------------------------------------------------------------
deftype StampTable
defmulti get (table:StampTable, id:String|Int) -> String
defmulti get (table:StampTable, ids:Tuple<String|Int>) -> String

defn StampTable (codetable:HashTable<String|Int,Int>) :
  ;Convert an integer code into a string
  defn to-hex (code:Int) -> String :
    defn letter (i:Int) :
      to-char $
        if i < 10 : to-int('0') + i
        else : to-int('A') + i - 10
    defn bits (i:Int) :
      (code >> i) & 0xF
    String $
      for i in reverse(0 to 32 by 4) seq :
        letter(bits(i))
        
  new StampTable :
    defmethod get (this, id:String|Int) :
      to-hex(codetable[id])
    defmethod get (this, ids:Tuple<String|Int>) :
      val code = hash $ map({codetable[_]}, ids)
      to-hex(code)

;============================================================
;===================== Stamp Updating =======================
;============================================================

defn update-stamps (cdocs:CommentDocs,
                    stamp-table:StampTable,
                    accepts:Tuple<String>) -> [CommentDocs, CommentDocErrors|False] :
  ;Compute set of blocks to accept.
  val accept-set = to-hashset<String>(accepts)

  ;Accumulate out-of-date errors
  val errors = Vector<CommentDocError>()

  ;Returns true if the given reference is out-of-date.
  defn ref-outdated? (id:String|Int,
                      new-stamp:String,
                      old-stamp:String|False,
                      previously-outdated?:True|False) -> True|False :
    val accepted? = match(id:String) :
      accept-set[id]
    ;If block is marked to be accepted, then it is not out-of-date.
    if accepted? :
      false
    ;If no old stamp was provided (ie. freshly written), then it is not out-of-date.
    else if old-stamp is False :
      false
    ;Otherwise, it is outdated if either
    ;  it was previously out-of-date,
    ;  or if the new-stamp is not equal to the old stamp.
    else :
      previously-outdated? or new-stamp != old-stamp

  ;Returns true if any of the given references are out-of-date.
  defn refs-outdated? (ids:Tuple<String>,
                       new-stamp:String,
                       old-stamp:String|False,
                       previously-outdated?:True|False) -> True|False :
    val accepted? = all?({accept-set[_]}, ids)
    ;If blocks are marked to be accepted, then it is not
    ;out-of-date.
    if accepted? :
      false
    ;If no old stamp was provided (ie. freshly written), then it is not out-of-date.
    else if old-stamp is False :
      false
    ;Otherwise, they are outdated if either
    ;  they were previously out-of-date,
    ;  or if the new-stamp is not equal to the old stamp.
    else :
      previously-outdated? or new-stamp != old-stamp      
  
  ;Update the comment item by filling in new hash information.
  defn update (item:CommentItem) -> CommentItem :
    match(item) :
      (item:BlockTag) :
        match(stamp(item)) :
          (item-stamp:String) :
            val stamp* = stamp-table[name(item)]
            val outdated?* = ref-outdated?(name(item), stamp*, item-stamp, outdated?(item))
            add(errors, OutdatedBlock(info(item), name(item))) when outdated?*
            BlockTag(info(item), name(item), stamp*, outdated?*)
          (f:False) :
            item
      (item:AnonymousBlock) :
        val stamp* = stamp-table[id(item)]
        val outdated?* = ref-outdated?(id(item), stamp*, stamp(item), outdated?(item))
        add(errors, OutdatedBlock(info(item), false)) when outdated?*
        AnonymousBlock(info(item), id(item), stamp*, outdated?*)
      (item:Reference) :
        val stamp* = stamp-table[names(item)]
        val outdated?* = refs-outdated?(names(item), stamp*, stamp(item), outdated?(item))
        add(errors, OutdatedReference(info(item), names(item))) when outdated?*
        Reference(info(item), names(item), stamp*, outdated?*)
      (item) : item

  ;Update the given document.
  defn update (doc:CommentDoc) -> CommentDoc :
    sub-items(doc, map(update, items(doc)))

  ;Launch!
  val cdocs* = sub-docs(cdocs, map(update,docs(cdocs)))
  val errors* = CommentDocErrors(to-tuple(errors)) when not empty?(errors)
  [cdocs*, errors*]

;============================================================
;======================== Export ============================
;============================================================

defn export (doc:CommentDoc) -> Printable :
  val params = params(doc)
  new Printable :
    defmethod print (o:OutputStream, this) :
      defn print-tag (prefix:String, start:Char, tag, end:Char) :
        print(o, prefix)
        print(o, start)
        print(o, tag)
        print(o, end)
      defn outdated-tag (str:String, outdated?:True|False) :
        if outdated? : "outdated:%_" % [str]
        else : str
      for item in items(doc) do :
        match(item) :
          (item:BlockTag) :
            print-tag(block-tag-marker(params), '[', name(item), ']')
            if stamp(item) is String :
              val tag = outdated-tag(stamp(item) as String, outdated?(item))
              print-tag("", '<', tag, '>')
          (item:BlockEnd) :
            if not implicit?(item) :
              print-tag(block-end-marker(params), '[', name(item), ']')
          (item:Reference) :
            val names = string-join(names(item), " | ")
            print-tag(reference-marker(params), '[', names, ']')
            val tag = outdated-tag(stamp(item) as String, outdated?(item))
            print-tag("", '<', tag, '>')
          (item:FileReference) :
            val tag = "file:%_" % [file(item)]
            print-tag(reference-marker(params), '[', tag, ']')
            switch(status(item)) :
              StandardFile : false
              BinaryFile : print-tag("", '<', "binary", '>')
              OutdatedFile : print-tag("", '<', "outdated", '>')
          (item:AnonymousBlock) :
            val tag = outdated-tag(stamp(item) as String, outdated?(item))
            print-tag(block-tag-marker(params), '<', tag, '>')
          (item:Text) :
            print(o, string(item))
          (item:Whitespace) :
            print(o, string(item))
          (item:Indent) :
            false
          (item:NewLine) :
            print(o, '\n')
          (item:EndOfFile) :
            false

;============================================================
;============== Write Updated Docs Back Out =================
;============================================================
defn write-back-to-disk (cdocs:CommentDocs) :
  for doc in docs(cdocs) do :
    spit(path(doc), export(doc))

;============================================================
;==================== Structure File ========================
;============================================================

public defstruct StructureFile :
  root: DocFile
  files: Tuple<DocFile>
  syntaxes: Tuple<DocSyntax>
  ignores: Tuple<FilePattern>

defstruct DocFile :
  info: FileInfo
  file: String
  full-path: String|False with: (init => false, updater => sub-full-path)

defn full-path! (f:DocFile) : full-path(f) as String

defstruct FilePattern :
  info: FileInfo
  file: String
  pattern: GlobPattern|False with: (init => false, updater => sub-pattern)  

defstruct DocSyntax :
  pattern: FilePattern with: (updater => sub-pattern)
  params: DocParams

defsyntax stanza-doc-structure-file :
  public defproduction structure-file: StructureFile
  defrule structure-file = (?stmts:#stmt! ...) :
    val stmt-table = HashTable<Symbol,List>(List())
    for stmt in stmts do :
      update(stmt-table, cons{value(stmt), _}, key(stmt))
    val root-file = switch(length(stmt-table[`root])) :
      0 : throw(DocFileError(false, "No root document listed in structure file."))
      1 : head(stmt-table[`root])
      else : throw(DocFileError(false, "Multiple root documents listed in structure file."))
    val files = switch(length(stmt-table[`files])) :
      0 : throw(DocFileError(false, "No files listed in structure file."))
      1 : head(stmt-table[`files])
      else : throw(DocFileError(false, "Multiple sets of files listed in structure file."))
    val syntaxes = to-tuple(stmt-table[`syntax])
    val ignores = to-tuple(stmt-table[`ignore])
    StructureFile(root-file, files, syntaxes, ignores)

  defproduction stmt!: KeyValue<Symbol,?>
  defrule stmt! = (root: ?f:#one-docfile!) : `root => f
  defrule stmt! = (files: ?fs:#docfiles!) : `files => fs
  defrule stmt! = (syntax for ?f:#filepattern! : ?p:#params!) : `syntax => DocSyntax(f,p)
  defrule stmt! = (ignore ?f:#filepattern!) : `ignore => f
  fail-if stmt! = () :
    DocFileError(closest-info(), "Invalid statement in document structure file.")

  defproduction one-docfile! : DocFile
  defrule one-docfile! = ((?f:#docfile!)) : f
  defrule one-docfile! = (?f:#docfile!) : f
  fail-if one-docfile! = ((#docfile! _)) : DocFileError(closest-info(), "Expected a single filename here.")

  defproduction docfiles! : Tuple<DocFile>
  defrule docfiles! = ((?fs:#docfile! ...)) : to-tuple(fs)
  defrule docfiles! = (?f:#docfile!) : [f]

  defproduction params! : DocParams
  defrule params! = ((tag-start: ?start:#string!
                      tag-end: ?end:#string!
                      reference: ?ref:#string!)) :
    DocParams(closest-info(), start, end, ref)
  fail-if params! = () :
    DocFileError(closest-info(), "Expected list of parameters here.")

  ;Read a string
  defproduction string! : String
  defrule string! = (?s) when unwrap-token(s) is String : unwrap-token(s)
  fail-if string! = () : DocFileError(closest-info(), "Expected a string here.")

  ;Read a file pattern
  defproduction filepattern! : FilePattern
  defrule filepattern! = (?s) when unwrap-token(s) is String :
    FilePattern(closest-info() as FileInfo, unwrap-token(s) as String)
  fail-if filepattern! = () :
    DocFileError(closest-info(), "Expected a filename pattern here.")

  ;Read a document file listing
  defproduction docfile! : DocFile
  defrule docfile! = (?s) when unwrap-token(s) is String :
    DocFile(closest-info() as FileInfo, unwrap-token(s) as String)
  fail-if docfile! = () :
    DocFileError(closest-info(), "Expected a filename here.")

defn read-structure-file (filename:String) -> StructureFile :
  parse-syntax[stanza-doc-structure-file / #structure-file](read-file(filename))

;============================================================
;======================= Errors =============================
;============================================================
public defstruct CommentDocErrors <: Exception :
  errors: Tuple<CommentDocError>

defn CommentDocErrors (es:Seqable<CommentDocErrors>) :
  CommentDocErrors $ to-tuple $ seq-cat(errors, es)

defmethod print (o:OutputStream, e:CommentDocErrors) :
  print(o, "%n" % [errors(e)])
  
public deftype CommentDocError <: Exception

public defstruct DuplicateBlockInFile <: CommentDocError :
  name: String
  info: FileInfo
  old-info: FileInfo

defmethod print (o:OutputStream, e:DuplicateBlockInFile) :
  print(o, "%_: Duplicate definition of block %~ in file. Previous definition \
            at %_." % [info(e), name(e), old-info(e)])

public defstruct DuplicateEndInFile <: CommentDocError :
  name: String
  info: FileInfo
  old-info: FileInfo
  
defmethod print (o:OutputStream, e:DuplicateEndInFile) :
  print(o, "%_: Duplicate ending tag for block %~ in file. Previous definition \
            at %_." % [info(e), name(e), old-info(e)])

public defstruct DuplicateBlock <: CommentDocError :
  name: String
  info: FileInfo
  old-info: FileInfo

defmethod print (o:OutputStream, e:DuplicateBlock) :
  print(o, "%_: Duplicate definition of block %~ in project. Previous definition \
            at %_." % [info(e), name(e), old-info(e)])

public defstruct InvalidNestedBlock <: CommentDocError :
  info: FileInfo
  name: String
  skipped-blocks: Tuple<String>

defmethod print (o:OutputStream, e:InvalidNestedBlock) :
  defn fmt (s:String) : "%~" % [s]
  print(o, "%_: Invalid block nesting. Cannot end block %~ before ending block(s) %*." % [
    info(e), name(e), seq(fmt, skipped-blocks(e))])

public defstruct UnresolvedBlock <: CommentDocError :
  name: String
  infos: Tuple<FileInfo>

defmethod print (o:OutputStream, e:UnresolvedBlock) :
  val info0 = infos(e)[0]
  val infon = infos(e)[1 to false]
  print(o, "%_: Cannot resolve reference to block %~." % [info0, name(e)])
  if not empty?(infon) :
    print(o, " Other references to block %~ at:" % [name(e)])
    val o2 = IndentedStream(o)
    do(lnprint{o2, _}, infon)

public defstruct UnreferencedBlock <: CommentDocError :
  info: FileInfo
  name: String  

defmethod print (o:OutputStream, e:UnreferencedBlock) :
  print(o, "%_: Block %~ is never referenced in the project." % [info(e), name(e)])

public defstruct OutdatedBlock <: CommentDocError :
  info: FileInfo
  name: String|False

defmethod print (o:OutputStream, e:OutdatedBlock) :
  match(name(e)) :
    (name:String) :
      print(o, "%_: Block %~ has been changed and is now out-of-date." % [info(e), name])
    (name:False) :
      print(o, "%_: Unnamed block has been changed and is now out-of-date." % [info(e)])

public defstruct OutdatedReference <: CommentDocError :
  info: FileInfo
  names: Tuple<String>

defmethod print (o:OutputStream, e:OutdatedReference) :
  if length(names(e)) == 1 :
    val name = names(e)[0]
    print(o, "%_: Reference to changed block %~ is now out-of-date." % [info(e), name])
  else :
    defn fmt (x) : "%~" % [x]
    print(o, "%_: Reference to changed blocks %, are now out-of-date." % [info(e), seq(fmt,names(e))])

public defstruct UnresolvedAccept <: CommentDocError :
  name: String  

defmethod print (o:OutputStream, e:UnresolvedAccept) :
  print(o, "Block %~ is marked to be accepted but is not defined in the project." % [name(e)])

public defstruct UndescribedFile <: CommentDocError :
  path: String

defmethod print (o:OutputStream, e:UndescribedFile) :
  print(o, "Project file %~ is not described in project comments." % [path(e)])

public defstruct DocFileError <: CommentDocError :
  info: FileInfo|False
  msg: String

defmethod print (o:OutputStream, e:DocFileError) :
  val info-str = "" when info(e) is False
            else "%_: " % [info(e)]
  print(o, "%_%_" % [info-str, msg(e)])

public defstruct CouldNotFindRootFile <: CommentDocError :
  info: FileInfo
  name: String  

defmethod print (o:OutputStream, e:CouldNotFindRootFile) :
  print(o, "%_: Root document %~ does not exist." % [info(e), name(e)])

public defstruct CouldNotReadRootFile <: CommentDocError :
  info: FileInfo
  name: String  

defmethod print (o:OutputStream, e:CouldNotReadRootFile) :
  print(o, "%_: Root document %~ is not a valid file." % [info(e), name(e)])

public defstruct CouldNotFindDocFile <: CommentDocError :
  info: FileInfo
  name: String  

defmethod print (o:OutputStream, e:CouldNotFindDocFile) :
  print(o, "%_: Project file %~ does not exist." % [info(e), name(e)])

public defstruct NoEndingBracket <: CommentDocError :
  info: FileInfo
  end-char: Char

defmethod print (o:OutputStream, e:NoEndingBracket) :
  print(o, "%_: No closing character %~ found." % [info(e), end-char(e)])

public defstruct InvalidFileStatus <: CommentDocError :
  info: FileInfo
  status: String  

defmethod print (o:OutputStream, e:InvalidFileStatus) :
  print(o, "%_: The string %~ is not a valid file status." % [info(e), status(e)])

public defstruct UnresolvedFile <: CommentDocError :
  info: FileInfo
  filename: String

defmethod print (o:OutputStream, e:UnresolvedFile) :
  print(o, "%_: Referenced project file %~ does not exist." % [info(e), filename(e)])

public defstruct InvalidGlob <: CommentDocError :
  info: FileInfo with: (default => void)
  string: String

defmethod print (o:OutputStream, e:InvalidGlob) :
  print(o, "%_: The file matching pattern %~ is not supported." % [info(e), string(e)])

public defstruct EmptyTag <: CommentDocError :
  info: FileInfo|False

defmethod print (o:OutputStream, e:EmptyTag) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print(o, "%_Cannot use the empty string as a marker tag." % [info-str])