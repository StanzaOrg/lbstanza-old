defpackage stz/dyn-tree :
  import core
  import collections
  import stz/utils
  import stz/dynamic-graph

;============================================================
;==================== Tree Interface ========================
;============================================================

public deftype DynTree
public defmulti add (t:DynTree, nodes:Seqable<NodeState>) -> False
public defmulti all-children (t:DynTree, n:Int) -> Tuple<Int>
public defmulti all-leaves (t:DynTree, n:Int) -> Tuple<Int>
public defmulti add (t:DynTree, listener:TreeListener) -> False

public defstruct NodeState :
  id: Int
  parents: Tuple<Int>
  children: Tuple<Int>
  leaf?: True|False
with:
  printer => true

;============================================================
;=================== Listener Interface =====================
;============================================================

public deftype TreeListener
public defmulti node-changed (t:TreeListener, n:Int) -> False

;============================================================
;==================== Tree Implementation ===================
;============================================================

public defn DynTree () :
  val listeners = Vector<TreeListener>()
  val changed-nodes = Vector<Int>()
  val graph = DynamicGraph()

  defn add-nodes (node-states:Seqable<NodeState>) :
    defn make-edge-set (s:NodeState) :
      EdgeSet(
        id(s),
        to-tuple(cat(
          for p in parents(s) seq :
            Edge(id(s), p)
          for c in children(s) seq :
            Edge(c, id(s)))))

    defn make-node (s:NodeState) :
      new Node :
        defmethod id (this) :
          id(s)
        defmethod compute-value (this, v0:Maybe<AllChildren>) :
          val children = Vector<Int>()
          val leaves = Vector<Int>()
          for input in inputs(graph, id(s)) do :
            val v = value(graph,input) as AllChildren
            add-all(children, /children(v))
            add-all(leaves, /leaves(v))
          add(children, id(s))
          add(leaves, id(s)) when leaf?(s)            
          val v* = AllChildren(sorted-tuple(children), sorted-tuple(leaves))
          add(changed-nodes, id(s)) when v0 != One(v*)
          v*

    ;Update the graph with the new nodes and edge set
    val change = GraphChange(
      to-tuple $ seq(make-node, node-states)
      to-tuple $ seq(make-edge-set, node-states))
    update(graph, change)

    ;Notify listeners
    for n in changed-nodes do :
      for l in listeners do : node-changed(l,n)
    clear(changed-nodes)

  new DynTree : 
    defmethod add (this, nodes:Seqable<NodeState>) :
      add-nodes(nodes)
    defmethod all-children (this, node:Int) :
      children(value(graph, node) as AllChildren)
    defmethod all-leaves (this, node:Int) :
      leaves(value(graph, node) as AllChildren)
    defmethod add (this, listen:TreeListener) :
      add(listeners, listen)

;============================================================
;===================== Children =============================
;============================================================

defstruct AllChildren <: Equalable :
  children: Tuple<Int>
  leaves: Tuple<Int>
with:
  printer => true

defmethod equal? (a:AllChildren, b:AllChildren) :
  (children(a) == children(b)) and
  (leaves(a) == leaves(b))

;============================================================
;================== Convenience API =========================
;============================================================

public defn DynTree (s:Seqable<NodeState>) :
  val t = DynTree()
  add(t, s)
  t

;Return true if p is a parent of x.
;(or equivalently: whether x is a child of p)
public defn parent? (t:DynTree, x:Int, p:Int) :
  bsearch(all-children(t,p), x) is Int
   
;============================================================
;==================== Utilities =============================
;============================================================

defn bsearch (xs:Tuple<Int>, x:Int) -> Int|False :
  let loop (start:Int = 0, end:Int = length(xs)) :
    if end > start :
      val center = (start + end) / 2
      val y = xs[center]
      if x == y : center
      else if x < y : loop(start, center)
      else : loop(center + 1, end)

defn sorted-tuple (xs:Vector<Int>) :
  qsort!(xs)
  remove-duplicates!(xs)
  to-tuple(xs)