defpackage stz/type-solver :
  import core
  import collections
  import stz/types
  import stz/type-formatter
  import stz/type-locs
  import stz/type-variance
  import stz/type-hierarchy
  import stz/printing-utils
  import stz/utils
  import stz/type-utils

;<doc>=======================================================
;======================= Reasoning ==========================
;============================================================

# Separating constraints #

  Suppose there's an equation with multiple type variables:

    Find x, y, z: s.t. T1 <: T2

  Is it possible to separate that equation, and solve for
  each of the variables separately?

  Ultimately, during the proof search for T1 <: T2, we will
  find some leaf clause:

    T <: ?x, or
    T <: ?y

  By definition, these clauses will be true. We are solving
  for the variables such that they are true. So there's
  nothing stopping us from just regarding them as true independently,
  and then collecting the constraints at the end.

  Why is this easier than just jointly solving for all of them?

  Because, these are joint equations, and as long as we have
  enough information to solve for one of the variables, we want
  to know the answer as soon as possible, and plug it in.

  So the summary is, we can break up that equation into the
  following:

    Find x: s.t. T1 <: T2
    Find y: s.t. T1 <: T2
    Find z: s.t. T1 <: T2

  And during the solve, if we hit:

    T <: ?y

  We can just regard it as true, and not even bother collecting
  the constraint for ?y unless ?y is the variable we are
  attempting to solve for.

# What does the capture algorithm return? #

What are the different cases?

  Case: The algorithm completed.

    Case: There is a solution.

      Then return:
      - The number of gradual assertions required in the proof tree.
      - The final leaf constraint imposed upon the variable.

    Case: There is no solution.

  Case: The algorithm could not complete.

    There is a vital relation that we do not know the answer
    to, because it depends upon a variable that has not yet
    been solved.

;============================================================
;=======================================================<doc>

;============================================================
;====================== Driver API ==========================
;============================================================

;Calculate the given capture variable.
public defn capture (cv:Int, variance:Variance, a:Type, b:Type, hier:TypeHierarchy) -> CaptureResult :
  val sresult = capture-search(cv, CapRight, a, b, hier)
  match(simplify(sresult,true,false)) :
    (r:Blocked) : r
    (r:NoSoln) : false  
    (r:Solved) : evaluate-constraint(constraint(r), variance)

;Calculate the given inference location.
public defn infer (a:InferLoc|Type, b:InferLoc|Type, hier:TypeHierarchy) -> CaptureResult :
  val sresult = capture-search(a, b, hier)
  match(simplify(sresult,true,false)) :
    (r:Blocked) : r
    (r:NoSoln) : false
    (r:Solved) :
      val variance = capture-variance(a,b)
      evaluate-constraint-conservative(constraint(r), variance)

;Represents the result of a capturing/inference function.
;- Type: captured successfully.
;- Blocked: blocked on some variable.
;- False: unsatisfiable.
public deftype CaptureResult :
  False <: CaptureResult
  Blocked <: CaptureResult
  Type <: CaptureResult

;Compute whether the given overloaded arrow is appropriate to be
;passed to b.
public defn select-overload (a:TArrow, b:Type, hier:TypeHierarchy) -> PredResult :
  val sresult = select-overload-search(a, b, hier)
  match(simplify(sresult,false,true)) :
    (r:Blocked) : r
    (r:NoSoln) : false
    (r:Solved) : true when num-gradual-expansions(r) == 0 else GradualMatch()

;Compute whether the given arrow is appropriate to be called with the given
;arguments.
public defn select-overload-call (a:TArrow, args:Tuple<Type>, hier:TypeHierarchy) -> PredResult :
  ;Form a dummy TArrow out of args. The return type is unused so it can be anything.
  val sresult = select-overload-search(a, TArrow(args, TGradual()), hier)
  match(simplify(sresult,false,true)) :
    (r:Blocked) : r
    (r:NoSoln) : false
    (r:Solved) : true when num-gradual-expansions(r) == 0 else GradualMatch()

;Represents the result of a boolean predicate function.
public deftype PredResult :
  True <: PredResult
  False <: PredResult
  Blocked <: PredResult

;Represents an overload match due to gradual expansion.
public defstruct GradualMatch <: PredResult

;============================================================
;====================== Search Tree =========================
;============================================================

public deftype SearchResult

;Represents a conjunction in the search tree.
public defstruct SAnd <: SearchResult :
  a: SearchResult
  b: SearchResult

;Represents a disjunction in the search tree.
public defstruct SOr <: SearchResult :
  a: SearchResult
  b: SearchResult

;Represents a successful search. The captured variable, x,
;must satisfy x <: type (if x is in covariant position.)
public defstruct SSoln <: SearchResult :
  type:Type
with: (printer => true)

;Represents a failed search. The search has failed because
;'tvar' is unknown.
public defstruct SBlocked <: SearchResult :
  tvar:Int
with: (printer => true)

;Represents a satisfied search. Most often used for the subtyping
;relation. Used in a capture search to indicate that a
;capture is trivially satisfied and the capture variable
;is unconstrained.
public defstruct SSatisfied <: SearchResult
with: (printer => true)

;Represents a failed search. The relation is unsatisfiable.
public defstruct SFail <: SearchResult
with: (printer => true)

;Represents the use of the gradual expansion rule during
;the search.
public defstruct SGradualExpansion <: SearchResult :
  result: SearchResult

;Represents the use of the subtype relation during
;computing variable capturing.
public defstruct SSubtype <: SearchResult :
  result: SearchResult

;Construct SAnd from multiple results.
public defn SAnd (rs:Seqable<SearchResult>) -> SearchResult :
  val rs-seq = to-seq(rs)
  if empty?(rs-seq) : SSatisfied()
  else : reduce(SAnd, rs-seq)

;Construct SOr from multiple results.
public defn SOr (rs:Seqable<SearchResult>) -> SearchResult :
  val rs-seq = to-seq(rs)
  if empty?(rs-seq) : SFail()
  else : reduce(SOr, rs-seq)

;------------------------------------------------------------
;------------------ Search Tree Printing --------------------
;------------------------------------------------------------

defmethod print (o:OutputStream, s:SAnd) :
  print(o, "SAnd(%_)" % [indented-field-list([a(s), b(s)])])

defmethod print (o:OutputStream, s:SOr) :
  print(o, "SOr(%_)" % [indented-field-list([a(s), b(s)])])

defmethod print (o:OutputStream, s:SGradualExpansion) :
  print(o, "SGradualExpansion(%_)" % [indented-field-list([result(s)])])

defmethod print (o:OutputStream, s:SSubtype) :
  print(o, "SSubtype(%_)" % [indented-field-list([result(s)])])

;------------------------------------------------------------
;------------------- Search Tree Formatting -----------------
;------------------------------------------------------------

public defn format (f:TypeFormatter, s:SearchResult) :
  defn fmt (n:Int) : fmt(TVar(n,false))
  defn fmt (t:Type) : format(f,t)
  defn fmt (s:SearchResult) : format(f,s)  
  match(s) :
    (s:SAnd) : "SAnd(%_)" % [indented-field-list([fmt(a(s)), fmt(b(s))])]
    (s:SOr) : "SOr(%_)" % [indented-field-list([fmt(a(s)), fmt(b(s))])]
    (s:SGradualExpansion) : "SGradualExpansion(%_)" % [indented-field-list([fmt(result(s))])]
    (s:SSubtype) : "SSubtype(%_)" % [indented-field-list([fmt(result(s))])]
    (s:SSoln) : "SSoln(%_)" % [fmt(type(s))]
    (s:SBlocked) : "SBlocked(%_)" % [fmt(tvar(s))]
    (s:SSatisfied) : s
    (s:SFail) : s

;============================================================
;=================== Capture Variance =======================
;============================================================

;Computes the capture variance of the given capture variables in the type.
public defn capture-variance (cvs:Tuple<Int>, t:Type) -> Tuple<KeyValue<Int,Variance>> :
  val table = IntTable<List<Variance>>(List())
  let loop (t:Type = t, v:Variance = Covariant) :
    match(t) :
      (t:TCap) :
        update(table, cons{v, _}, n(t))
      (t:TArrow) :
        do(loop{_ as Type, flip(v)}, a1(t))
        loop(a2(t), v)
      (t) :
        do(loop{_ as Type, v}, t)
  to-tuple $ for v in cvs seq :
    if not key?(table,v) :
      fatal("Variable V%_ is not captured." % [v])
    val vs = table[v]
    if all-equal?(vs) : v => head(vs)
    else : fatal("Variable V%_ is captured in both covariant \
                  and contravariant positions." % [v])

;Return the variance of an inference location.
public defn capture-variance (a:InferLoc|Type, b:InferLoc|Type) -> Variance :
  match(a, b) :
    (a:Type, b:TupleLoc|ReturnLoc) : Covariant
    (a:TupleLoc|ReturnLoc, b:Type) : Contravariant
    (a:Type, b:ArgLoc) : Contravariant
    (a:ArgLoc, b:Type) : Covariant

;============================================================
;=================== Capture Algorithm ======================
;============================================================

;Represents the side that the capturing variable is on.
public defenum CapSide :
  CapLeft
  CapRight

;Flip the direction.
defn opp (s:CapSide) -> CapSide :
  CapRight when s == CapLeft else CapLeft

;Main capturing algorithm.
;Returns the search tree corresponding to capturing cv such that x is a subtype of y.
public defn capture-search (cv:Int, side:CapSide, x:Type, y:Type, hier:TypeHierarchy) -> SearchResult :
  ;Sanity check.
  switch(side) :
    CapRight :
      if not captures-type?(y, cv) :
        fatal("Right-hand type (%_) does not capture variable V%_." % [y,cv])
      if not user-type?(x, true) :
        fatal("Left-hand type is not a user-type.")
    CapLeft :
      if not captures-type?(x, cv) :
        fatal("Left-hand type (%_) does not capture variable V%_." % [x,cv])
      if not user-type?(y, true) :
        fatal("Right-hand type is not a user-type.")

  ;Convenience: Call cap(cv, side, x, y) expecting the same side
  ;to continue containing the capture variable. If it does not,
  ;then call subtype instead.
  defn* cap (x:Type, y:Type) -> SearchResult :
    val t = x when side == CapLeft else y
    if captures-type?(t,cv) : capture-search(cv, side, x, y, hier)
    else : SSubtype(subtype-search(x, y, hier))

  ;Convenience: Call cap(cv, opp(side), x, y) expecting the opposite
  ;side to contain the capture variable. If it does not, then
  ;call subtype instead.
  defn* cap-inv (x:Type, y:Type) -> SearchResult :
    val opp-side = opp(side)
    val t = x when opp-side == CapLeft else y
    if captures-type?(t,cv) : capture-search(cv, opp-side, x, y, hier)
    else : SSubtype(subtype-search(x, y, hier))

  ;Syntax-directed capture algorithm.
  match(x, y) :
    ;Capture.
    (x, y:TCap) :
      fatal("Cap var does not match cv.") when n(y) != cv
      SSoln(x)
    (x:TCap, y) :
      fatal("Cap var does not match cv.") when n(x) != cv
      SSoln(y)
    ;Bottom and top type: Fast paths.
    (x:TBot, y) : SSatisfied()
    (x, y:TTop) : SSatisfied()
    ;Combinatory type.
    (x:TOr|TAnd, y) : search-tor-tand(cap, x, y)
    (x, y:TOr|TAnd) : search-tor-tand(cap, x, y)
    ;Unitary types.
    (x:TOf, y:TOf) : search-tof(cap, x, y, hier)
    (x:TTuple, y:TTuple|TOf) : search-ttuple(cap, x, y, hier)
    (x:TArrow, y:TArrow) : search-tarrow(cap, cap-inv, x, y)
    ;Unsolved types.
    (x:TUVar, y) : SBlocked(n(x))
    (x, y:TUVar) : SBlocked(n(y))
    ;Gradual Type.
    (x:TGradual, y) : search-tgradual(cap, x, y)
    (x, y:TGradual) : search-tgradual(cap, x, y)
    ;Fall through
    (x, y) : SFail()

;============================================================
;================== Inference Algorithm =====================
;============================================================
;Note about ArgLoc and ReturnLoc:
;  When used in CapLeft position, we are using it for argument inference, and
;  expected return type inference. If part of a multifn function, then we
;  may be matching a branch against a wrong-arity expectation, and trusting the
;  TOr/TAnd rules to handle it.
;  Thus we make sure to return SSubtype(Fail) so that the 'forced-top?' option
;  on simplify allows us to force a solution through.

public defn capture-search (x:InferLoc|Type, y:InferLoc|Type, hier:TypeHierarchy) -> SearchResult :
  ;Sanity check.
  match(x, y) :
    (x:Type, y:Type) : fatal("Must be passed one InferLoc and one Type.")
    (x:InferLoc, y:InferLoc) : fatal("Must be passed one InferLoc and one Type.")
    (x, y) : false

  ;Helper: Call capture-search(x, y, hier)
  defn cap (x:InferLoc|Type, y:InferLoc|Type) :
    capture-search(x, y, hier)
    
  ;Syntax directed search.
  match(x, y) :
    ;Bottom type.
    (x:TBot, y) : SSatisfied()
    (x, y:TTop) : SSatisfied()
    ;Combinatory type.
    (x:TOr, y) : SAnd(cap(a(x),y), cap(b(x),y))
    (x, y:TAnd) : SAnd(cap(x,a(y)), cap(x,b(y)))
    (x, y:TOr) : SOr(cap(x,a(y)),cap(x,b(y)))
    (x:TAnd, y) : SOr(cap(a(x),y), cap(b(x),y))
    ;Unitary types.
    (x:TTuple, y:TupleLoc) :
      if length(args(x)) == arity(y) : SSoln(args(x)[index(y)])
      else : SFail()
    (x:TupleLoc, y:TTuple) :
      if arity(x) == length(args(y)) : SSoln(args(y)[index(x)])
      else : SFail()
    (x:TupleLoc, y:TOf) :
      capture-search(0, CapLeft, collapse-tuple(x,hier), y, hier)
    (x:TArrow, y:ArgLoc) :
      if length(a1(x)) == arity(y) : SSoln(a1(x)[index(y)])
      else : SFail()
    (x:ArgLoc, y:TArrow) :
      if length(a1(y)) == arity(x) : SSoln(a1(y)[index(x)])
      else : SSubtype(SFail())
    (x:TArrow, y:ReturnLoc) :
      if length(a1(x)) == arity(y) : SSoln(a2(x))
      else : SFail()
    (x:ReturnLoc, y:TArrow) :
      if length(a1(y)) == arity(x) : SSoln(a2(y))
      else : SSubtype(SFail())
    ;Unsolved types.
    (x:TUVar, y) : SBlocked(n(x))
    (x, y:TUVar) : SBlocked(n(y))
    ;Gradual type.
    (x:TGradual, y) : SSoln(TGradual())
    (x, y:TGradual) : SSoln(TGradual())
    ;Fall through
    (x, y) : SFail()

;Collapse a tuple into a variable-arity tuple.
defn collapse-tuple (t:TupleLoc, hier:TypeHierarchy) -> TOf :
  val n = special-type(hier, CoreTuple)
  TOf(n, [TCap(0,false)])

;============================================================
;=================== Subtyping Algorithm ====================
;============================================================

;Main subtyping algorithm.
;Returns the search tree corresponding to calculating whether x is a subtype of y.
public defn subtype-search (x:Type, y:Type, hier:TypeHierarchy) -> SearchResult :
  ;Sanity checks.
  if not (user-type?(x, true) or fnarg-type?(x,true)) :
    fatal("Left-hand type is not a user-type.")
  if not (user-type?(y, true) or fnarg-type?(y,true)) :
    fatal("Right-hand type is not a user-type.")

  ;Helper: Call subtype-search(x,y,hier)
  defn st (x:Type, y:Type) -> SearchResult :
    subtype-search(x, y, hier)

  ;Syntax-directed subtype algorithm.
  match(x, y) :
    ;Irrelevant capture variables.
    (x:TCap, y) : SSatisfied()
    (x, y:TCap) : SSatisfied()
    ;Bottom type.
    (x:TBot, y) : SSatisfied()
    (x, y:TTop) : SSatisfied()
    ;Combinatory type.
    (x:TOr|TAnd, y) : search-tor-tand(st, x, y)
    (x, y:TOr|TAnd) : search-tor-tand(st, x, y)
    ;Unitary types.
    (x:TOf, y:TOf) : search-tof(st, x, y, hier)
    (x:TTuple, y:TTuple|TOf) : search-ttuple(st, x, y, hier)
    (x:TArrow, y:TArrow) : search-tarrow(st, st, x, y)
    ;Ground types.
    (x:TVar, y:TVar) :
      if n(x) == n(y) : SSatisfied()
      else : SFail()
    ;Unsolved types.
    (x:TUVar, y:TUVar) :
      if n(x) == n(y) : SSatisfied()
      else : SAnd(SBlocked(n(x)), SBlocked(n(y)))
    (x:TUVar, y) : SBlocked(n(x))
    (x, y:TUVar) : SBlocked(n(y))
    ;Gradual Type.
    (x:TGradual, y) : search-tgradual(st, x, y)
    (x, y:TGradual) : search-tgradual(st, x, y)
    ;Fall through.
    (x, y) : SFail()

;------------------------------------------------------------
;------------------ Helpers for Subscenarios ----------------
;------------------------------------------------------------

;Perform a search over TOr and TAnd types.
;NOTE: The (TAnd,TUVar) case is derived like this:
;  Does A&B <: tau imply (A <: tau OR B <: tau)?
;  NO. Counterexample: A&B <: A&B.
;  So if there is a chance that tau is an intersection type,
;  then this cannot be reduced.
defn search-tor-tand (search:(Type, Type) -> SearchResult,
                      x:Type,
                      y:Type) -> SearchResult :
  match(x, y) :
    (x:TAnd, y:TUVar) : SOr(SOr(search(a(x), y), search(b(x), y)),
                            SBlocked(n(y)))
    (x:TOr, y) : SAnd(search(a(x), y), search(b(x), y))
    (x, y:TAnd) : SAnd(search(x, a(y)), search(x, b(y)))
    (x, y:TOr) : SOr(search(x, a(y)), search(x, b(y)))
    (x:TAnd, y) : SOr(search(a(x), y), search(b(x), y))

;Perform a search over TOf types.
defn search-tof (search:(Type, Type) -> SearchResult,
                 x:TOf,
                 y:TOf,
                 hier:TypeHierarchy) -> SearchResult :
  if n(x) == n(y) :
    fatal("Unexpected differing lengths.") when not same-length?(args(x), args(y))
    SAnd(seq(search, args(x), args(y)))
  else :
    val xparents = parents(hier, x, n(y))
    if empty?(xparents) : SFail()
    else : SAnd(seq(search{_, y}, xparents))

;Perform a search over TTuple types.
defn search-ttuple (search:(Type, Type) -> SearchResult,
                    x:TTuple,
                    y:TTuple|TOf,
                    hier:TypeHierarchy) -> SearchResult :
  match(x, y) :
    (x:TTuple, y:TTuple) :
      if same-length?(args(x), args(y)) :
        SAnd(seq(search, args(x), args(y)))
      else :
        SFail()
    (x:TTuple, y:TOf) :
      search(collapse-tuple(x, hier), y)

;Perform a search over TArrow types.
defn search-tarrow (search:(Type, Type) -> SearchResult,
                    search-inv:(Type, Type) -> SearchResult,
                    x:TArrow,
                    y:TArrow) -> SearchResult :
  if same-length?(a1(x), a1(y)) :
    SAnd(SAnd(seq(search-inv, a1(y), a1(x)))
         search(a2(x), a2(y)))
  else :
    SFail()

;Perform a search by expanding graduals.
defn search-tgradual (search:(Type, Type) -> SearchResult,
                      x:Type,
                      y:Type) -> SearchResult :
  match(x, y) :
    (x:TGradual, y:TGradual) : SSatisfied()
    (x, y:TGradual) : SGradualExpansion(search(x, expand-gradual(x)))
    (x:TGradual, y) : SGradualExpansion(search(expand-gradual(y), y))

;Expand a gradual type.
defn expand-gradual (t:Type) -> Type :
  defn graduals (ts:Tuple<Type>) -> Tuple<TGradual> :
    map(TGradual{}, ts)
  match(t) :
    (t:TOf) : TOf(n(t), graduals(args(t)))
    (t:TTuple) : TTuple(graduals(args(t)))
    (t:TArrow) : TArrow(graduals(a1(t)), TGradual())
    (t) : fatal("Gradual expansion not supported for %_." % [t])

;Collapse a tuple into a variable-arity tuple.
defn collapse-tuple (t:TTuple, hier:TypeHierarchy) -> TOf :
  val n = special-type(hier, CoreTuple)
  val argt = TBot() when empty?(args(t))
        else simplify(reduce(TOr,args(t)))
  TOf(n, [argt])

;============================================================
;============== Simplifying the Search Tree =================
;============================================================

;The result of simplifying a search tree.
public deftype SimplifyResult :
  Blocked <: SimplifyResult

;Reached the end leaf constraint.
;Contains the number of gradual expansions required
;to reach it.
public defstruct Solved <: SimplifyResult :
  constraint:SolnConstraint
  num-gradual-expansions:Int

;Solution is not satisfiable.
public defstruct NoSoln <: SimplifyResult
with: (printer => true)

;Represents the final set of constraints
;for a variable.
public deftype SolnConstraint

;Represents a union of constraints from a search
;disjunctive clause.
public defstruct OrConstraint <: SolnConstraint :
  a:SolnConstraint
  b:SolnConstraint

;Represents an intersection of constraints from a
;search conjunctive clause.
public defstruct AndConstraint <: SolnConstraint :
  a:SolnConstraint
  b:SolnConstraint

;Represents one constraint.
public defstruct OneConstraint <: SolnConstraint :
  type:Type
with: (printer => true)

;Represents the absence of any constraint.
;Arises during trivial solutions, e.g. bot <: tau.
public defstruct NoConstraint <: SolnConstraint
with: (printer => true)

;------------------------------------------------------------
;-------------------- Printing ------------------------------
;------------------------------------------------------------

defmethod print (o:OutputStream, c:OrConstraint) :
  print(o, "OrConstraint(%_)" % [indented-field-list([a(c), b(c)])])

defmethod print (o:OutputStream, c:AndConstraint) :
  print(o, "AndConstraint(%_)" % [indented-field-list([a(c), b(c)])])

defmethod print (o:OutputStream, s:Solved) :
  val items = [
    simple-field("constraint", constraint(s))
    simple-field("num-gradual-expansions", num-gradual-expansions(s))]
  print(o, "Solved(%_)" % [indented-field-list(items)])

;------------------------------------------------------------
;---------------------- Formatting --------------------------
;------------------------------------------------------------

public defn format (f:TypeFormatter, r:SimplifyResult) :
  defn fmt (c:SolnConstraint) : format(f,c)
  defn fmt (n:Int) : format(f,TVar(n,false))
  match(r) :
    (r:Blocked) :
      "Blocked(%,)" % [seq(fmt,vars(r))]
    (r:NoSoln) :
      r
    (r:Solved) :
      val items = [
        simple-field("constraint", fmt(constraint(r)))
        simple-field("num-gradual-expansions", num-gradual-expansions(r))]
      "Solved(%_)" % [indented-field-list(items)]

public defn format (f:TypeFormatter, c:SolnConstraint) :
  defn fmt (c:SolnConstraint) : format(f,c)
  defn fmt (t:Type) : format(f,t)
  match(c) :
    (c:OrConstraint) : "OrConstraint(%_)" % [indented-field-list([fmt(a(c)), fmt(b(c))])]
    (c:AndConstraint) : "AndConstraint(%_)" % [indented-field-list([fmt(a(c)), fmt(b(c))])]
    (c:OneConstraint) : "OneConstraint(%_)" % [fmt(type(c))]
    (c:NoConstraint) : c

;------------------------------------------------------------
;--------------------- Implementation -----------------------
;------------------------------------------------------------

;- forced-top?: When this is true then top-level conjunctive subtype
;  relations are forced to be true. This helps cyclic capture relations
;  solve in a few more cases, and also helps the partof? relation where
;  captured variables are solved before function mixing.
public defn simplify (r:SearchResult,
                      forced-top?:True|False,
                      forced-free-graduals?:True|False) -> SimplifyResult :
  match(r) :
    (r:SAnd) :
      match(simplify(a(r), forced-top?, forced-free-graduals?)
            simplify(b(r), forced-top?, forced-free-graduals?)) :
        ;If either branch fails, then both fail.
        ;If this is a top-level conjunctive clause, then
        ;just force it to succeed.
        (sa:NoSoln, sb) : NoSoln()
        (sa, sb:NoSoln) : NoSoln()
        ;If branches are blocked then return blocked.
        (sa:Blocked, sb:Blocked): append(sa,sb)
        (sa:Blocked, sb) : sa
        (sa, sb:Blocked) : sb
        ;If both solved, then join their information.
        ;Add the total number of gradual expansions together.
        (sa:Solved, sb:Solved) :
          Solved(SimplifiedAndConstraint(constraint(sa), constraint(sb)),
                 num-gradual-expansions(sa) + num-gradual-expansions(sb))
    (r:SOr) :
      match(simplify(a(r), false, forced-free-graduals?),
            simplify(b(r), false, forced-free-graduals?)) :
        ;If one branch has no solution then choose the other.
        (sa:NoSoln, sb) : sb
        (sa, sb:NoSoln) : sa
        ;If branches are blocked then return this information.
        (sa:Blocked, sb:Blocked) : append(sa, sb)
        (sa:Blocked, sb) : sb when unconstrained?(sb) else sa
        (sa, sb:Blocked) : sa when unconstrained?(sa) else sb
        ;If both branches are solved, choose the one with the
        ;smaller number of gradual expansions.
        (sa:Solved, sb:Solved) :
          switch(compare(num-gradual-expansions(sa), num-gradual-expansions(sb))) :
            -1 : sa
            1 : sb
            0 : Solved(SimplifiedOrConstraint(constraint(sa), constraint(sb))
                       num-gradual-expansions(sa))
    (r:SGradualExpansion) :
      inc-gradual-expansions(simplify(result(r), forced-top?, forced-free-graduals?))
    (r:SSubtype) :
      if forced-top? : Solved(NoConstraint(), 0)
      else if forced-free-graduals? : zero-out-graduals(simplify(result(r), false, false))
      else : simplify(result(r), false, false)
    (r:SBlocked) :
      Blocked(List(tvar(r)))
    (r:SSoln) :
      Solved(OneConstraint(type(r)), 0)
    (r:SSatisfied) :
      Solved(NoConstraint(), 0)
    (r:SFail) :
      NoSoln()

;Create a simplified AndConstraint from two simplified constraints.
;- NoConstraint exists only at top-level.
;- AndConstraint is right-leaning.
defn SimplifiedAndConstraint (a:SolnConstraint, b:SolnConstraint) -> SolnConstraint :
  match(a, b) :
    (a:NoConstraint, b) : b
    (a, b:NoConstraint) : a
    (x:AndConstraint, y) : AndConstraint(/a(x), AndConstraint(/b(x), y))
    (a, b) : AndConstraint(a, b)

;Create a simplified AndConstraint from two simplified constraints.
;- NoConstraint exists only at top-level.
;- OrConstraint is right-leaning.
defn SimplifiedOrConstraint (a:SolnConstraint, b:SolnConstraint) -> SolnConstraint :
  match(a, b) :
    (a:NoConstraint, b) : a
    (a, b:NoConstraint) : b
    (x:OrConstraint, y) : OrConstraint(/a(x), OrConstraint(/b(x), y))
    (a, b) : OrConstraint(a, b)

;Helper: Return true if r is Solved, unconstrained, and no gradual expansions were used..
;This sort of result always takes precedence when in a SOr search, even if the other
;branch is Blocked.
defn unconstrained? (r:SimplifyResult) -> True|False :
  match(r:Solved) :
    num-gradual-expansions(r) == 0 and
    constraint(r) is NoConstraint

;Helper: Increment the 'num-gradual-expansions' field in the result.
defn inc-gradual-expansions (r:SimplifyResult) -> SimplifyResult :
  match(r:Solved) : Solved(constraint(r), num-gradual-expansions(r) + 1)
  else : r

;Helper: Set the number of gradual expansions to zero.
defn zero-out-graduals (r:SimplifyResult) -> SimplifyResult :
  match(r:Solved) : Solved(constraint(r), 0)
  else : r

;============================================================
;============= Evaluating the Search Tree ===================
;============================================================

;Evaluate the given set of constraints to get the final type
;for a captured variable of the given variance.
public defn evaluate-constraint (c:SolnConstraint,
                                 variance:Variance) -> Type :
  defn eval (c:SolnConstraint) -> Type :
    match(c) :
      (c:OneConstraint) :
        type(c)
      (c:NoConstraint) :
        switch(variance) :
          Covariant : TBot()
          Contravariant : TGradual()
      (c:AndConstraint) :
        switch(variance) :
          Covariant : TOr(eval(a(c)), eval(b(c)))
          Contravariant : TAnd(eval(a(c)), eval(b(c)))
      (c:OrConstraint) :
        switch(variance) :
          Covariant : TAnd(eval(a(c)), eval(b(c)))
          Contravariant : TOr(eval(a(c)), eval(b(c)))
  simplify(eval(c))

;============================================================
;================ Conservative Evaluation ===================
;============================================================

;Case: Covariant + OrConstraint
;  Argument type inference:
;    Expecting: INT -> INT or STR -> INT
;    Pass: x -> INT
;  Therefore:
;    x -> INT  <:  INT -> INT or STR -> INT
;  Therefore:
;    INT <: x  OR  STR <: x
;  Therefore:
;    x = INT|STR
;
;Case: Covariant + OrConstraint
;  Return type inference:
;    Expecting: INT -> x
;    Passed: INT -> INT  or  INT -> STR
;  Therefore:
;    INT -> INT  or  INT -> STR    <:    INT -> x
;  Therefore:
;    INT <: x  or  STR <: x
;  Therefore:
;    x = INT|STR
;
;Case: Contravariant + OrConstraint
;  Expected return type inference:
;    Expecting: INT -> (INT -> INT)  or  INT -> (STR -> INT)
;    Passed: INT -> x
;  Therefore:
;    INT -> x  <:  INT -> (INT -> INT)  or  INT -> (STR -> INT)
;  Therefore:
;    x <: (INT -> INT)  or  x <: (STR -> INT)
;  Therefore:
;    x = (INT -> INT) | (STR -> INT)
;
;Case: Contravariant + OrConstraint
;  Expected tuple type inference:
;    Expecting: [INT, INT] | [INT, STR]
;    Passed: [x, y]
;  Therefore:
;    [x, y] <: [INT, INT] | [INT, STR]
;  Therefore:
;    [x, y] <: [INT, INT] OR [x, y] <: [INT, STR]

public defn evaluate-constraint-conservative (c:SolnConstraint,
                                              variance:Variance) -> Type :
  defn eval (c:SolnConstraint) -> Type :
    match(c) :
      (c:OneConstraint) :
        type(c)
      (c:NoConstraint) :
        TGradual()
      (c:AndConstraint) :
        switch(variance) :
          Covariant : TOr(eval(a(c)), eval(b(c)))
          Contravariant : TAnd(eval(a(c)), eval(b(c)))
      (c:OrConstraint) :
        TOr(eval(a(c)), eval(b(c)))
  simplify(eval(c))


;============================================================
;================== Overload Selection ======================
;============================================================

;Returns success if the overloaded function 'x' should be selected
;given that the expected type is 't'.
;To use this function, 'x' is expected to have its type arguments properly filled in.
;NOTE: The return type of the arrow is not used during overload selection. This is
;mean to be consistent with the behaviour of overloaded functions in function
;call position: we do not use the expected return type to select the overloaded function.
defn select-overload-search (x:TArrow, t:Type, hier:TypeHierarchy) -> SearchResult :
  ;Sanity checks.
  if not user-type?(t, true) : fatal("Right-hand type is not a user-type.")
  if not user-type?(x, true) : fatal("Left-hand type is not a user-type")

  ;Convenience.
  defn so (a:TArrow, b:Type) : select-overload-search(a, b, hier)
  defn pt (a:Type, b:Type) : partof-search(a, b, hier)

  ;Syntax-directed subtype algorithm.
  match(t) :
    ;Top type.
    (t:TTop) : SSatisfied()
    ;Combinatory type.
    (t:TOr|TAnd) : SOr(so(x, a(t)), so(x, b(t)))
    ;Unitary types.
    (t:TArrow) :
      if same-length?(a1(x), a1(t)) : SAnd(seq(pt, a1(t), a1(x)))
      else : SFail()
    ;Unsolved types.
    (t:TUVar) : SBlocked(n(t))
    ;Gradual Type.
    (t:TGradual) : SSatisfied()
    ;Fall through.
    (t) : SFail()

;The argument type 'y' (as part of a mixed function) is going to be passed values of type 'x'.
;Return success if this is allowed.
;  Passing: a|other -> b|other
;  Expecting: x|y -> c
;  So: x|y <: a|other
defn partof-search (x:Type, y:Type, hier:TypeHierarchy) -> SearchResult :
  ;Sanity check.
  if not user-type?(y, true) :
    fatal("Right-hand type not a function argument type.")

  ;Helper: Shorthand for calling partof-search
  defn po (x:Type, y:Type) : partof-search(x, y, hier)
  
  match(x, y) :
    ;Bottom and top type.
    (x:TBot, y) : SSatisfied()
    (x, y:TTop) : SSatisfied()
    ;Combinatory types.
    (x:TAnd, y:TUVar) : SOr(SOr(po(a(x), y), po(b(x), y)),
                            SBlocked(n(y)))
    (x:TOr, y) : SOr(po(a(x),y), po(b(x),y))
    (x, y:TAnd) : SAnd(po(x,a(y)), po(x,b(y)))
    (x, y:TOr) : SOr(po(x, a(y)), po(x, b(y)))
    (x:TAnd, y) : SOr(po(a(x), y), po(b(x), y))
    ;Unsolved types.
    (x:TUVar, y:TUVar) :
      if n(x) == n(y) : SSatisfied()
      else : SAnd(SBlocked(n(x)), SBlocked(n(y)))
    (x:TUVar, y) : SBlocked(n(x))
    (x, y:TUVar) : SBlocked(n(y))
    ;Gradual types
    (x:TGradual, y:TGradual) : SSatisfied()
    (x:TGradual, y) : SGradualExpansion(po(expand-gradual(y), y))
    ;Other.
    (x, y) : SSubtype(subtype-search(x, y, hier))

;============================================================
;==================== Function Mixing =======================
;============================================================

public defn mix-functions (xs:Tuple<TArrow>, sel:Tuple<PredResult>) -> Type :
  ;Helper: Remove return type if using MatchGradual.
  defn remove-returns (x:TArrow, s:PredResult) -> Maybe<TArrow> :
    match(s) :
      (s:True) : One(x)
      (s:GradualMatch) : One(TArrow(a1(x), TGradual()))
      (s:False) : None()

  ;Helper: Mix homogenous-arity arrows together.
  defn mix-homo (xs:List<TArrow>) -> TArrow :
    if length(xs) == 1 :
      head(xs)
    else :
      val a1* = reduce(mix-a1, seq(a1,xs))
      val a2* = reduce(TOr, seq(a2,xs))
      TArrow(map(simplify,a1*), simplify(a2*))

  ;Helper: Mix the arg types of a bunch of functions.
  defn mix-a1 (a:Tuple<Type>, b:Tuple<Type>) -> Tuple<Type> :
    to-tuple(seq(TOr, a, b))

  ;Group by arity, and mix each arity separately.
  defn arity (a:TArrow) : length(a1(a))
  val arrows = seq?(remove-returns, xs, sel)
  val table = group-by(arity, arrows)
  reduce(TAnd, seq(mix-homo, values(table)))

;============================================================
;==================== Small Utilities =======================
;============================================================

;Returns true if all the items in the list are equal to each other.
defn all-equal? (vs:List<Equalable>) -> True|False :
  if empty?(vs) :
    true
  else :
    for v in tail(vs) all? :
      v == head(vs)

;Returns true if the given type captures cv.
defn captures-type? (t:Type, cv:Int) -> True|False :
  match(t:TCap) : n(t) == cv
  else : any?(captures-type?{_ as Type, cv}, t)

;Returns true if the two tuples have the same length.
defn same-length? (a:Tuple, b:Tuple) -> True|False :
  length(a) == length(b)