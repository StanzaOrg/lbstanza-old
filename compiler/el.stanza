defpackage stz/el :
  import core
  import collections
  import stz/dl-ir
  import stz/el-ir
  import stz/utils
  import stz/algorithms
  import stz/ehier
  import stz/el-var-table
  import stz/el-utils
  import stz/el-infer
  import stz/dyn-tree
  import stz/conversion-utils
  import stz/set-utils
  import stz/basic-ops
  import stz/dispatch-dag with:
    prefix(Top) => Dag
  import stz/el-unique-ids
  import stz/el-freevars
  import stz/verbose
  import core/stack-trace
  import stz/timing-log-api
  import stz/type-fargs
  import stz/dump-to-log

;============================================================
;==================== Drivers ===============================
;============================================================

public defn lower-optimized (epackages:Tuple<EPackage>) -> EPackage :
  vprintln("EL: Lower optimized packages: %," % [seq(name, epackages)])
  val epackages* = map(fill-stack-trace-entries, epackages)
  lower(collapse(epackages*), true)

public defn lower-unoptimized (epackage:EPackage) -> EPackage :
  vprintln("EL: Lower unoptimized package: %_" % [name(epackage)])
  lower(fill-stack-trace-entries(epackage), false)

;============================================================
;===================== Timers ===============================
;============================================================

val EL-LOWER = TimerLabel("EL Lower")

val EL-TIMERS = within pass-name = HashTable-init<String,TimerLabel>() :
  TimerLabel(to-string("EL Lower[%_]" % [pass-name]))

;============================================================
;========================= Lowering =========================
;============================================================

defn lower (epackage:EPackage, optimize?:True|False) -> EPackage :
  val lower-timer-name = to-string("EL-LOWER -- %_" % [name(epackage)])
  within log-time(EL-LOWER, lower-timer-name) :

    ;Reset id generation
    take-ids(epackage)

    ;Current processing package
    var cur-package:EPackage = epackage

    ;Necessary tables
    var iotable:IOTable
    var global-vt:VarTable
    var ehier:EHier
    defn update-tables () :
      iotable = IOTable(packageio(cur-package))
      global-vt = GlobalVarTable(cur-package, iotable)
      ehier = EHier(cur-package)
    update-tables()

    ;Run pass
    defn run-pass (pass-name:String, f:EPackage -> EPackage, suffix:String, update-tables?:True|False) :
      vprintln("EL: Running pass %_" % [pass-name])
      within log-time(EL-TIMERS[pass-name], /suffix(name(epackage))) :
        cur-package = f(cur-package)
        update-tables() when update-tables?
      dump(cur-package, "logs", suffix)
      #if-not-defined(OPTIMIZE) :
        ensure-unique-identifiers!(cur-package)
    defn run-pass (pass-name:String, f:(EPackage, IOTable) -> EPackage, suffix:String, update-tables?:True|False) :
      run-pass(pass-name, f{_, iotable}, suffix, update-tables?)
    defn run-pass (pass-name:String, f:(EPackage, VarTable) -> EPackage, suffix:String, update-tables?:True|False) :
      run-pass(pass-name, f{_, global-vt}, suffix, update-tables?)
    defn run-pass (pass-name:String, f:(EPackage, EHier, VarTable) -> EPackage, suffix:String, update-tables?:True|False) :
      run-pass(pass-name, f{_, ehier, global-vt}, suffix, update-tables?)

    ;Dump input
    ;dump(cur-package, "logs", "input")
    run-pass("Convert To Positional Args", conv-to-positional-args, "conv-pos-args", true)
    run-pass("Map Methods", map-methods, "mapped-methods", false)
    run-pass("Create Closures", create-closures, "closures", false)
    run-pass("Convert Mixes", convert-mixes, "mixes", false)
    run-pass("Insert Guards", insert-guards, "guarded", false)
    run-pass("Elide Checks", elide-checks, "elided", false)
    run-pass("Annotate Live", annotate-live, "live", false)
    if not optimize? :
      run-pass("Convert Checks to Typeof", convert-checks-to-typeof, "typeof", false)
    run-pass("Box Mutables", box-mutables, "boxed", false)
    run-pass("Detect Loops", detect-loops, "looped", false)
    run-pass("Simple Inline", simple-inline, "inlined0", false)
    run-pass("Within Package Inline", within-package-inline{_, true}, "wp-inlined0", false)
    run-pass("Cleanup Labels", cleanup-labels, "cleanup-labels", false)
    if optimize? :
      run-pass("Remove Reified Types", force-remove-types, "removed-types", true)
    run-pass("Simplify Typeof", simplify-typeof, "simplify-typeof1", false)
    run-pass("Lambda Lift", lambda-lift, "lambda", true)
    run-pass("Lift Objects", lift-objects, "objlifted", true)
    if optimize? :
      run-pass("Resolve Methods And Matches", resolve-methods-and-matches, "resolved-methods", false)
      ;Phase 1
      run-pass("Simple Inline", simple-inline, "inlined1", false)
      run-pass("Within Package Inline", within-package-inline{_, false}, "wp-inlined1", false)
      run-pass("Cleanup Labels", cleanup-labels, "cleanup-labels1", false)
      run-pass("Beta Reduce", beta-reduce, "beta-reduce1", false)
      run-pass("Box Unbox", box-unbox-fold, "box-unbox1", false)
      run-pass("Eliminate Dead Code", eliminate-dead-code, "dead-code1", false)
      run-pass("Remove Boxes", remove-boxes, "remove-boxes1", false)
      run-pass("Constant Fold", constant-fold, "constant-fold1", false)
      ;Phase 2
      run-pass("Simple Inline", simple-inline, "inlined2", false)
      run-pass("Within Package Inline", within-package-inline{_, true}, "wp-inlined2", false)
      run-pass("Cleanup Labels", cleanup-labels, "cleanup-labels2", false)
      run-pass("Beta Reduce", beta-reduce, "beta-reduce2", false)
      run-pass("Box Unbox", box-unbox-fold, "box-unbox2", false)
      run-pass("Eliminate Dead Code", eliminate-dead-code, "dead-code2", false)
      run-pass("Remove Boxes", remove-boxes, "remove-boxes2", false)
      ;Stabilize
      run-pass("Constant Fold Beta Reduce", iterative-constant-fold-beta-reduce, "constant-fold-beta-reduce", false)
      run-pass("Eliminate Dead Code", eliminate-dead-code, "dead-code3", false)
      ;Finish by removing checks
      run-pass("Force Remove Checks", force-remove-checks, "removed-checks", false)
    run-pass("Resolve Matches", resolve-matches, "resolved-matches", false)
    run-pass("Simplify Typeof", simplify-typeof, "simplify-typeof2", false)
    run-pass("Lift Closures", lift-closures, "closurelifted", false)
    run-pass("Lift Type Objects", lift-type-objects, "typelifted", false)

    ;Return processed package
    cur-package

;============================================================
;=================== Stack Trace Entries ====================
;============================================================

;Represent the current context for the purposes of printing
;the stack trace. Can be converted to a human-readable signature.
deftype StackTraceContext
defmulti package (c:StackTraceContext) -> Symbol

;Represents the top-level context.
defstruct TopLevel <: StackTraceContext:
  package:Symbol with: (as-method => true)

;Represents that we are within the named function with the given identifier.
defstruct FunctionContext <: StackTraceContext:
  n:Int
  package:Symbol with: (as-method => true)

;Fill all TraceInfo objects with context information.
defn fill-stack-trace-entries (epackage:EPackage) -> EPackage :
  ;Build the IOTable to build signatures of functions.
  val iotable = IOTable(packageio(epackage))
  defn signature? (c:StackTraceContext) -> String|False :
    match(c:FunctionContext) :
      if key?(iotable, n(c)) :
        val rec-id = id(iotable[n(c)])
        match(rec-id:FnId) :
          to-string(name(rec-id))

  ;Recursively compute stack trace contexts for all items.
  defn fill-entry (item:ELItem, context:StackTraceContext) -> ELItem :
    ;Compute the context based upon the current item.
    val context* = compute-context(context, item)

    ;Recursively fill the item.
    val item* = map(fill-entry{_, context*}, item)

    ;Add the context to the item's trace information.
    if has-trace-info?(item*) :
      sub-info(item*, add-context(context*, info(item*)))
    else : item*

  ;Compute the new context after entering the given item.
  defn compute-context (context:StackTraceContext, item:ELItem) -> StackTraceContext :
    match(context, item) :
      (context:TopLevel, item:EDefmulti) : FunctionContext(n(item), package(context))
      (context:TopLevel, item:EDefn) : FunctionContext(n(item), package(context))
      (context:TopLevel, item:EDefmethod) : FunctionContext(multi(item), package(context))
      (context:TopLevel, item:EExternFn) : FunctionContext(n(item), package(context))
      (context, item) : context

  ;Compute the new trace info after adding the context.
  defn add-context (context:StackTraceContext, info:TraceInfo) -> TraceInfo :
    StackTraceEntry(package(context), signature?(context), info as FileInfo|False)

  ;Launch!
  fill-entry(epackage, TopLevel(name(epackage))) as EPackage

;============================================================
;===================== Collapsing ===========================
;============================================================
defn collapse (epackages:Tuple<EPackage>) :
  ;Create global rec ids for everything
  val global-rec-ids = HashTable<RecId,Int>()

  ;Driver
  defn driver () :
    create-global-rec-ids()
    val pio = new-packageio()
    val exps* = to-tuple(seq-cat(renamed-exps, epackages))
    EPackage(pio, exps*)

  ;Create global ids
  defn create-global-rec-ids () :
    for e in epackages do :
      for ex in exports(packageio(e)) do :
        global-rec-ids[id(rec(ex))] = uniqueid()

  ;Create new packageio
  defn new-packageio () :
    val exports* = to-tuple $
      for e in epackages seq-cat :
        for ex in exports(packageio(e)) seq :
          val n* = global-rec-ids[id(rec(ex))]
          sub-n(ex, n*)
    PackageIO(`prog, [], [], exports*, false)

  ;Rename one specific package
  defn renamed-exps (epackage:EPackage) :
    val local-table = IntTable-init<Int>(uniqueid{})
    defn lookup-id (n:Int, r:Rec) :
      local-table[n] = global-rec-ids[id(r)]
    for e in imports(packageio(epackage)) do :
      lookup-id(n(e), rec(e))
    for e in exports(packageio(epackage)) do :
      lookup-id(n(e), rec(e))
    defn new-id (n:Int) : local-table[n]
    defn new-id (n:Tuple<Int>) : map(new-id, n)
    defn rename (e:ELItem) -> ELItem :
      match(map(rename, e)) :
        ;Types
        (e:EStructT) : EStructT(new-id(n(e)))
        (e:EOf) : EOf(new-id(n(e)))
        (e:ETVar) : ETVar(new-id(n(e)))
        ;ETExps
        (e:EDefGlobal) : sub-n(e, new-id(n(e)))
        (e:EDefn) : sub-n(e, new-id(n(e)))
        (e:EDefmulti) : sub-targs(sub-n(e, new-id(n(e))), new-id(targs(e)))
        (e:EDefmethod) : sub-multi(sub-n(e, new-id(n(e))), new-id(multi(e)))
        (e:EDefStruct) : sub-n(e, new-id(n(e)))
        (e:EExternFn) : sub-n(e, new-id(n(e)))
        (e:EExtern) : sub-n(e, new-id(n(e)))
        (e:EDefType) : sub-children(sub-n(e, new-id(n(e))), new-id(children(e)))
        ;EFunction
        (e:EFn) : sub-args(sub-targs(e, new-id(targs(e))), new-id(args(e)))
        (e:ELocal) : sub-n(e, new-id(n(e)))
        (e:ELocalType) : sub-n(e, new-id(n(e)))
        (e:ELocalFn) : sub-n(e, new-id(n(e)))
        (e:ELocalObj) : sub-n(e, new-id(n(e)))
        (e:EMethod) : sub-n(sub-thisn(sub-multi(e, new-id(multi(e))), new-id(thisn(e))), new-id(n(e)))
        ;Expressions
        (e:EVar) : sub-n(e, new-id(n(e)))
        (e:ETagof) : sub-n(e, new-id(n(e)))
        (e:EVarLoc) : sub-n(e, new-id(n(e)))
        (e:EField) : sub-n(e, new-id(n(e)))
        (e:ETVarLoc) : sub-n(e, new-id(n(e)))
        (e:ENew) : sub-n(e, new-id(n(e)))
        (e:EObject) : sub-n(e, new-id(n(e)))
        (e:EArray) : sub-n(e, new-id(n(e)))
        (e:EStruct) : sub-n(e, new-id(n(e)))
        (e:ELabel) : sub-n(e, new-id(n(e)))
        (e:EGoto) : sub-n(e, new-id(n(e)))
        (e:EIf) : sub-n2(sub-n1(e, new-id(n1(e))), new-id(n2(e)))
        (e:ENewObject) : sub-n(e, new-id(n(e)))
        (e:EObjectGet) : sub-n(e, new-id(n(e)))
        (e:EObjectTGet) : sub-n(e, new-id(n(e)))
        (e:EClosureGet) : sub-n(e, new-id(n(e)))
        (e:EClosureTGet) : sub-n(e, new-id(n(e)))
        (e:ETypeObject) : sub-n(e, new-id(n(e)))
        (e:ETypeof) : sub-n2(sub-n1(e, new-id(n1(e))), new-id(n2(e)))
        (e:EBranch) : sub-n(e, new-id(n(e)))
        (e:EClosure) : sub-n(e, new-id(n(e)))
        ;Doesn't exist
        (e:EDefClosure) : fatal("Not handled")
        (e:EDefObject) : fatal("Not handled")
        (e:EDefTypeObject) : fatal("Not handled")
        (e:EConstClosure) : fatal("Not handled")
        (e:EConstType) : fatal("Not handled")
        ;Default
        (e) : e
    seq({rename(_) as ETExp}, exps(epackage))

  ;Launch
  driver()

;============================================================
;============ Positional Argument Conversion ================
;============================================================

;------------------------------------------------------------
;--------------- General Argument Ordering ------------------
;------------------------------------------------------------

;- num-non-dispatch: The number of optional/vararg arguments
;  in front that do not participate in multi dispatch.
;- indices: E.g. indices[2] = 4 means that the new argument 2
;  corresponds to the previous argument 4.
;- args: The reordered arguments, with postprocessed types.
defstruct OrderedArgs :
  num-non-dispatch:Int
  indices:Tuple<Int>
  args:Tuple<FArg<EType>>

;Returns true if the arguments needs to be reordered or processed.
defn requires-ordering? (args:Tuple<FArg<EType>>) -> True|False :
  for arg in args any? :
    match(arg) :
      (arg:PositionalArg) : optional?(arg)
      (arg:KeywordArg) : true
      (arg:VarArg) : true

;Compute the new ordering of the given arguments.
defn reorder-args (args:Tuple<FArg<EType>>,
                   wrap-maybe:EType -> EType,
                   wrap-tuple:EType -> EType) -> OrderedArgs :
  ;Classify arguments into groups:
  ;- OPTIONAL POS ARGS
  ;- OPTIONAL KEY ARGS
  ;- VARARG?
  ;- REQUIRED POS ARGS
  ;- REQUIRED KEY ARGS
  ;(Keyword arguments are always sorted by name within
  ; their group.)
  val optional-pos-args = Vector<Int>()
  val optional-key-args = Vector<Int>()
  var vararg:Int|False = false
  val required-pos-args = Vector<Int>()
  val required-key-args = Vector<Int>()
  for (arg in args, i in 0 to false) do :
    match(arg) :
      (arg:PositionalArg<EType>) :
        if optional?(arg) : add(optional-pos-args, i)
        else : add(required-pos-args, i)
      (arg:KeywordArg<EType>) :
        if optional?(arg) : add(optional-key-args, i)
        else : add(required-key-args, i)
      (arg:VarArg<EType>) :
        vararg = i
        
  ;Sort keyword arguments by name.
  defn sort-keywords (vs:Vector<Int>) :
    defn name! (i:Int) : name(args[i] as KeywordArg)
    qsort!(name!, vs)
  sort-keywords(optional-key-args)
  sort-keywords(required-key-args)

  ;Generate final ordering.
  val new-indices = Vector<Int>()
  val new-args = Vector<PositionalArg<EType>>()
  defn identity (t:EType) : t
  defn process-arg (f:EType -> EType, i:Int) :
    add(new-indices, i)
    add(new-args, PositionalArg<EType>(false, f(type(args[i]))))  
  do(process-arg{wrap-maybe, _}, optional-pos-args)
  do(process-arg{wrap-maybe, _}, optional-key-args)
  match(vararg:Int) : process-arg(wrap-tuple, vararg)
  do(process-arg{identity, _}, required-pos-args)
  do(process-arg{identity, _}, required-key-args)

  ;Bundle result in OrderedArgs.
  val vararg-count = 1 when vararg is Int else 0
  val num-non-dispatch = length(optional-pos-args)
                       + length(optional-key-args)
                       + vararg-count
  OrderedArgs(num-non-dispatch,
              to-tuple(new-indices),
              to-tuple(new-args))

;Reorder a tuple of items according to the indices in 'ordered'.
defn reorder<?T> (ordered:OrderedArgs, xs:Tuple<?T>) -> Tuple<T> :
  for i in indices(ordered) map :
    xs[i]

;------------------------------------------------------------
;---------- Reorder Definitions in Package ------------------
;------------------------------------------------------------

;Convert and reorder all arguments for all multis and functions
;to required positional arguments only.
defn conv-to-positional-args (e:EPackage, iotable:IOTable) -> EPackage :

  ;Call reorder-args with proper wrapping functions.
  defn reorder-args (args:Tuple<FArg<EType>>) -> OrderedArgs :
    val tuple-n = n(iotable, CORE-TUPLE-ID)
    val maybe-n = n(iotable, CORE-MAYBE-ID)
    /reorder-args(args,
                  EOf{maybe-n},
                  EOf{tuple-n})    

  ;Convert all arguments in EFn to positional arguments.
  defn conv-pos-args (e:EFn) -> EFn :
    if requires-ordering?(a1-args(e)) :
      val ordered = reorder-args(a1-args(e))
      val new-args = reorder(ordered, args(e))
      e $> sub-args{_, new-args}
        $> sub-a1-args{_, args(ordered)}
    else :
      e

  ;Convert all arguments in EDefmulti to positional arguments.
  defn conv-pos-args (m:EDefmulti) -> EDefmulti :
    if requires-ordering?(a1-args(m)) :
      val ordered = reorder-args(a1-args(m))
      m $> sub-a1-args{_, args(ordered)}
        $> sub-num-non-dispatch{_, num-non-dispatch(ordered)}
    else :
      m

  ;Recursively analyze all EDefmulti and EFn in
  ;the package, and reorder the arguments.
  defn loop (x:ELBigItem) :
    match(map(loop,x)) :
      (x:EDefmulti) : conv-pos-args(x)
      (x:EFn) : conv-pos-args(x)
      (x) : x
  map(loop, e)

;============================================================
;================== Method TArg Mapping =====================
;============================================================

;INPUT:
;  input-xs: The type variables for the method.
;  targs: The types passed to the multi
;OUTPUT: [ys, ytypes]
;  ys: The new type variables for the method
;  xtypes: The values for the old input-xs, expressed in terms of ys.
defn inverse-solve (input-xs:Tuple<Int>, targs:Tuple<EType>) -> [Tuple<Int>, Tuple<EType>] :
  ;Created targs
  val ys = map(uniqueid{}, targs)

  ;Initialize solved table
  val solved = IntTable<ETVar>()
  ;Precise Solutions
  for (t in targs, y in ys) do :
    match(t:ETVar) : set?(solved, n(t), ETVar{y})
  ;Approximate Solutions
  for (t in targs, y in ys) do :
    let loop (t:EType = t) :
      match(t) :
        (t:ETVar) : set?(solved, n(t), ETVar{y})
        (t:EOr) : do*(loop, t)
        (t) : false
  ;Return solutions
  val solns = map(get?{solved, _, ETop()}, input-xs)
  [ys, solns]

defn replace-tvars (f:EFn, xs:Tuple<Int>, ys:Tuple<EType>) :
  val table = to-inttable<EType>(xs,ys)
  defn loop (x:EType) :
    match(x) :
      (x:ETVar) : get?(table, n(x), ETop())
      (x) : map(loop, x)
  map(loop, f)

defn replace-tvars (t:EType, xs:Tuple<Int>, ys:Tuple<EType>) :
  val table = to-inttable<EType>(xs,ys)
  defn loop (x:EType) :
    match(x) :
      (x:ETVar) : get?(table, n(x), ETop())
      (x) : map(loop, x)
  loop(t)

defn map-methods (e:EPackage, gvt:VarTable) :
  ;Return the return type of the given multi with the new
  ;type arguments.
  defn multi-return-type (multi:Int, arity:Int, new-targs:Tuple<Int>) :
    val [a1, a2] = fn-types(gvt, multi, arity, map(ETVar,new-targs))
    a2

  ;Return the argument types of the given multi.
  ;Uses ETop as the type arguments.
  defn multi-arg-types (multi:Int, arity:Int, targ-arity:Int) :
    val targs = to-tuple(repeat(ETop(), targ-arity))
    val [a1, a2] = fn-types(gvt, multi, arity, targs)
    a1

  defn loop (x:ELBigItem) :
    map{loop, _} $ match(x) :
      (m:EDefmethod) :
        val arity = length(args(func(m)))
        val [targs*, tvals] = inverse-solve(targs(func(m)), targs(m))
        val mrt = multi-return-type(multi(m), arity, targs*)
        val mat = multi-arg-types(multi(m), arity, length(targs(m)))
        var func*:EFn = replace-tvars(func(m), targs(func(m)), tvals)
        func* = sub-targs(func*, targs*)
        func* = sub-a1(func*, to-tuple(seq(EAnd, a1(func*), mat)))
        func* = sub-a2(func*, EAnd(a2(func*), mrt))
        EDefmethod(n(m), multi(m), [], func*, lostanza?(m))
      (m:EMethod) :
        val arity = length(args(func(m)))
        val [targs*, tvals] = inverse-solve(targs(func(m)), targs(m))
        val mrt = multi-return-type(multi(m), arity, targs*)
        val mat = multi-arg-types(multi(m), arity, length(targs(m)))
        var func*:EFn = replace-tvars(func(m), targs(func(m)), tvals)
        func* = sub-targs(func*, targs*)
        func* = sub-a1(func*, to-tuple(seq(EAnd, a1(func*), mat)))
        func* = sub-a2(func*, EAnd(a2(func*), mrt))
        EMethod(n(m), multi(m), [], thisn(m), func*)
      (x) :
        x
  map(loop, e)

;============================================================
;===================== Body Buffer ==========================
;============================================================

deftype BodyBuffer
defmulti emit (b:BodyBuffer, x:ELocal|ELocalType|ELocalFn|ELocalObj|EIns) -> False
defmulti to-body (b:BodyBuffer, append-locals?:True|False, append-fns?:True|False, append-objs?:True|False) -> EBody

defn BodyBuffer (body:EBody) :
  val new-locals = Vector<ELocal>()
  val new-localtypes = Vector<ELocalType>()
  val new-localfns = Vector<ELocalFn>()
  val new-localobjs = Vector<ELocalObj>()
  val new-ins = Vector<EIns>()
  new BodyBuffer :
    defmethod emit (this, x:ELocal|ELocalType|ELocalFn|ELocalObj|EIns) :
      val xs = match(x) :
        (x:ELocal) : new-locals
        (x:ELocalType) : new-localtypes
        (x:ELocalFn) : new-localfns
        (x:ELocalObj) : new-localobjs
        (x:EIns) : new-ins
      add(xs, x)
    defmethod to-body (this, append-locals?:True|False, append-fns?:True|False, append-objs?:True|False) :
      defn append?<?T> (append?:True|False, xs:Tuple<?T>, ys:Vector<?T>) :
        if not append? : to-tuple(ys)
        else if empty?(ys) : xs
        else : to-tuple(cat(xs,ys))
      val locals* = append?(append-locals?, locals(body), new-locals)
      val localtypes* = append?(append-locals?, localtypes(body), new-localtypes)
      val localfns* = append?(append-fns?, localfns(body), new-localfns)
      val localobjs* = append?(append-objs?, localobjs(body), new-localobjs)
      val ins* = to-tuple(new-ins)
      EBody(locals*, localtypes*, localfns*, localobjs*, ins*)

defn emit-all (b:BodyBuffer, xs:Seqable<ELocal|ELocalType|ELocalFn|ELocalObj|EIns>) :
  do(emit{b, _}, xs)

defn to-body (b:BodyBuffer) :
  to-body(b, true, true, true)

;============================================================
;=================== Closure Creation =======================
;============================================================

;Functions cannot be referenced directly.
;For each referenced function in expression position, create
;a closure that wraps up the call.
defn create-closures (epackage:EPackage, gvt:VarTable) -> EPackage :

  ;Lift all first-class functions in body.
  defn analyze-body (top-body:EBody, vt:VarTable) :

    ;Create trampoline table.    
    val trampoline-table = TrampolineTable()

    ;Hold the list of trampolines created for each
    ;function.
    ;An entry, N => F1,F2, means that F1 and F2 are
    ;trampolines to N. So they should be initialized
    ;as soon as N is declared.
    val trampolines = IntListTable<ELocalFn>()

    ;Track for which trampolines have we initialized
    ;by generating an EInitClosures instruction.
    val initialized? = IntSet()

    ;Return all the trampolines in 'trampolines' that
    ;haven't been marked as initialized.
    defn uninitialized-trampolines () -> Seq<ELocalFn> :
      for entry in trampolines seq-cat :
        if initialized?[key(entry)] : []
        else : value(entry)

    ;Lift all first-class functions in body to trampolines
    defn lift-trampolines (e:ELBigItem, top?:True|False) :
      match(map(lift-trampolines{_, false}, e)) :
        (e:EBody) :
          ;New definitions
          val buffer = BodyBuffer(e)

          ;Retrieve the wrapped identifier in EVar|ECurry
          defn lift (x:EMix2) -> EVar :
            ;Closure is (conservatively) allocated at use-site if it is a EMix
            ;or if it curries over type variables.
            val allocate-at-use-site? = switch(length(funcs(x))) :
              1 : not empty?(capvars(funcs(x)[0]))
              else : true

            ;If at use-site, then init here, otherwise lift to trampoline table
            if allocate-at-use-site? :
              val v = uniqueid()
              emit(buffer, ELocalFn(v, trampoline-fn(x)))
              emit(buffer, EInitClosures([EVarLoc(v)], info(funcs(x)[0])))
              EVar(v)
            else :
              val x = funcs(x)[0]
              if make-trampoline(trampoline-table, x) :
                add(trampolines, n(x), trampoline-table[n(x)])
              EVar(n(trampoline-table[n(x)]))

          ;Analyze an immediate, lifting when necessary
          defn lift-imm (x:EImm) :
            match(x) :
              (x:EMix2) : lift(x)
              (x) : x

          ;Analyze all instructions
          for i in ins(e) do :
            val i* = match(i) :
              (i:ECall|ETCall) : sub-ys(i, map(lift-imm,ys(i)))
              (i) : map(lift-imm, i)
            emit(buffer, i*)

          ;Return function with lifted closures
          init-trampolines(to-body(buffer), top?)
        ;Just return if not a body
        (e) : e

    ;Initialize trampolines.
    defn init-trampolines (body:EBody, top?:True|False) :
      val buffer = BodyBuffer(body)
      ;Emit all trampolines for functions
      for f in localfns(body) do :
        for t in trampolines[n(f)] do :
          add(initialized?, n(f))
          emit(buffer, t)
      ;Emit remaining trampolines
      if top? :
        do(emit{buffer, _}, uninitialized-trampolines())
        val locs = seq(EVarLoc{n(_)}, uninitialized-trampolines())
        if not empty?(locs) :
          emit(buffer, EInitClosures(to-tuple(locs), false))
      ;Emit instructions with added initializations
      for i in ins(body) do :
        match(i:EInitClosures) :
          val xs* = for x in xs(i) seq-cat :
            val ts = seq(EVarLoc{n(_)}, trampolines[n(x)])
            cat([x], ts)
          emit(buffer, EInitClosures(to-tuple(xs*), info(i)))
        else : emit(buffer, i)
      ;Return body
      to-body(buffer)

    ;Driver
    lift-trampolines(top-body, true)

  ;Scan through the package and call analyze-body on
  ;every 
  defn analyze (x:ELBigItem, vt:VarTable) :
    match(x:EBody) : analyze-body(x, vt)
    else : map(analyze{_, vt}, x)
  map-with-var-table({analyze(_, _) as ETExp}, gvt, epackage)

;Small trampoline table for avoiding redundantly creating
;closures over and over for the same function.
;TODO: Can be generalized to handle type arguments too.
defstruct TrampolineTable :
  table:IntTable<ELocalFn> with:
    init => IntTable<ELocalFn>()

;Create a new trampoline.
;Returns true if a new trampoline was created.
defn make-trampoline (t:TrampolineTable, f:EInstFn) -> True|False :
  if not key?(table(t), n(f)) :
    val func = uni-arity-trampoline-fn(f)
    table(t)[n(f)] = ELocalFn(uniqueid(), func)
    true

;Retrieve a previously created trampoline.
defn get (t:TrampolineTable, n:Int) -> ELocalFn :
  table(t)[n]

;Helper: Create a trampoline function that calls the given immediate.
defn uni-arity-trampoline-fn (f:EMix2|EInstFn) -> EFn :

  ;Retrieve the arity of the function to call.
  ;Assume if it is a mix that they are all the same arity.
  val arity = length $ match(f) :
    (f:EInstFn) : a1(f)
    (f:EMix2) : a1(funcs(f)[0])

  ;Create fresh identifiers of the trampoline arguments.    
  val args = arity * uniqueid

  ;For the CallGuarded call type, retrieve the input/output
  ;types. EMix will use ETop() as a placeholder.
  val [a1, a2] = match(f) :
    (f:EInstFn) : [a1(f), a2(f)]
    (f:EMix2) : [arity * ETop, ETop()]

  ;Create the tail-call expression.
  val tcall = ETCall(f, argvars, call-type, info) where :
    val argvars = map(EVar,args)
    val call-type = CallGuarded(a1,a2)
    val info = match(f) :
      (f:EInstFn) : info(f)
      (f:EMix2) : info(funcs(f)[0])

  ;Create the EFn.
  EFn(true, [], args, arity * PositionalArg<EType>{false,ETop()}, ETop(),
    EBody([], [], [], [], [tcall])
    false)

;Create a trampoline function that calls the given immediate
;with unknown (and potentially multiple) arities.
defn trampoline-fn (f:EMix2) -> EFn|EMultifn :
  ;Retrieve the arity of the given function.
  defn arity (f:EInstFn) -> Int :
    length(a1(f))
    
  ;Group by arity, and create a trampoline for each arity.
  val groups = group-by(arity, funcs(f))
  val trampolines = to-tuple $ for group in groups seq :
    val fs = value(group)
    val f = head(fs) when length(fs) == 1
       else EMix2(to-tuple(fs))
    uni-arity-trampoline-fn(f)

  ;Either return a single trampoline, or group them
  ;using EMultifn.
  if length(trampolines) == 1 : trampolines[0]
  else : EMultifn(trampolines)

;============================================================
;===================== Mix Conversion =======================
;============================================================

public defn convert-mixes (epackage:EPackage, gvt:VarTable) :
  ;Analyze a given body
  defn analyze-body (body:EBody, vt:VarTable) :
    ;Create buffer
    val buffer = BodyBuffer(body)

    ;Split a call into a dispatch branch
    defn make-dispatch (Call:(EVarLoc|False, EImm, Tuple<EImm>, CallGuarded, TraceInfo) -> EIns,
                        x:EVarLoc|False, f:EMix, ys:Tuple<EImm>, info:TraceInfo, end?:True|False) :
      ;Construct branches and blocks
      val branches = Vector<EBranch>()
      val blocks = Vector<(() -> False)>()
      val refmask = map(reftype?, a1) where :
        val [a1, a2] = fn-types(vt, funcs(f)[0], length(ys))
      val end-lbl = uniqueid()
      for f in funcs(f) do :
        val [a1, a2] = fn-types(vt, f, length(ys))
        val lbl = uniqueid()
        add(branches, EBranch(select(a1,refmask), lbl, false))
        add{blocks, _} $ fn () :
          emit(buffer, ELabel(lbl))
          emit(buffer, Call(x, f, ys, CallGuarded(a1, a2), info))
          emit(buffer, EGoto(end-lbl)) when not end?
      ;Yield branches
      emit(buffer, EDispatch(select(ys,refmask), to-tuple(branches), info))
      for b in blocks do : b()
      emit(buffer, ELabel(end-lbl)) when not end?

    ;Scan through instructions
    for i in ins(body) do :
      ;Dispatch needed?
      val dispatch? = match(i:ECall|ETCall) : f(i) is EMix
      if dispatch? :
        match(i) :
          (i:ECall) :
            within (x, f, ys, g, info) = make-dispatch(x(i), f(i) as EMix, ys(i), info(i), false) :
              match(calltype(i):CallGuarded) : ECall(x, f, ys, g, info)
              else : ECall(x, f, ys, calltype(i), info)
          (i:ETCall) :
            within (_, f, ys, g, info) = make-dispatch(false, f(i) as EMix, ys(i), info(i), true) :
              match(calltype(i):CallGuarded) : ETCall(f, ys, g, info)
              else : ETCall(f, ys, calltype(i), info)
      else :
        emit(buffer, i)

    ;Yield new body
    to-body(buffer)

  ;Recursively analyze body
  defn analyze (x:ELBigItem, vt:VarTable) :
    match(map(analyze{_, vt}, x)) :
      (x:EBody) : analyze-body(x,vt)
      (x) : x
  map-with-var-table({analyze(_, _) as ETExp}, gvt, epackage)

;============================================================
;=============== Boundary Guard Derivations  ================
;============================================================
;<DOC>
Philosophy:
- All possible boundary changes are checked.
- There is only one exception: interaction with a LoStanza object
  from within a LoStanza context.

All possible boundary guards:
- EDefn
  - Arguments must be correct type.
- EDefmethod
  - Arguments must be correct type.
- ELocalFn
  - Arguments must be correct type.
- EMethod
  - Arguments must be correct type.
- EVar
  - Variable must be assigned.
  - Variable must have correct type.
- EDef
  - Initializing value must have correct type.
- EStore to EVarLoc
  - Value must have correct type.
- ETCall
  - Arguments must have correct type.
  - Function must have Fn type.
- ECall
  - Arguments must have correct type.
  - Function must have Fn type.
  - If return type is bottom :
    - Call should not return.
  - Otherwise:
    - Return value must have correct type.
- EBranch
  - Arguments must have correct type.
- ECheckLength
  - Expression must have Tuple type.
- EReturn
  - Value must have correct type.

Implementation:
- HiStanza functions :
  - Arguments are checked before call.
  - Return value is checked within function. (Unless tailcall.)
- HiStanza variables :
  - Values are checked before assignment.
;<DOC>
;============================================================
;==================== Boundary Guards =======================
;============================================================

defn insert-guards (epackage:EPackage, gvt:VarTable) :
  ;Scan through the given block and find all the
  ;variables that are not initialized upon declaration.
  defn discover-uninitialized-vars (e:ELBigItem) -> IntSet :
    val uninitialized-vars = IntSet()
    defn scan (e:ELBigItem) -> False :
      do*(scan, e)
      match(e:EBody) :
        ;Collect all the uninitialized variables in the instructions.
        for ins in filter-by<EDef>(ins(e)) do :
          if y(ins) is False :
            add(uninitialized-vars, n(x(ins)))
    scan(e)
    uninitialized-vars

  ;Guard expression for body
  defn guard-body (body:EBody, buffer:BodyBuffer, vt:VarTable,
                   lostanza-context?:True|False,
                   return-type:EType|False, function-info:TraceInfo,
                   uninitialized-vars:IntSet) :
    ;Buffer for holding label entrance guards
    val entry-blocks = IntTable<List<EIns>>(List())
    defn add-entry (b:Int, i:EIns) : update(entry-blocks, cons{i, _}, b)

    ;Return true if n refers to a reference-typed variable.
    defn refvar? (n:Int) :
      variable?(vt,n) and reftype?(type(vt,n))

    ;Ensure that variable has been set
    defn ensure-vars-set (x:EImm) :
      match(x:EVar) :
        ;Possible unset
        val can-be-unset? =
          if refvar?(n(x)) :
            global?(vt,n(x)) or
            (mutable?(vt,n(x)) and uninitialized-vars[n(x)])
        ;Compute whether to emit check
        val emit-check? =
          if lostanza-context? and lostanza?(vt,n(x)) : false
          else : can-be-unset?
        ;Emit check
        emit(buffer, ECheckSet(x,name(x),info(x))) when emit-check?

    ;Ensure that variables have correct type
    defn ensure-vars-type-consistent (x:EImm) :
      match(x:EVar) :
        ;Possible inconsistent
        val can-be-inconsistent? =
          refvar?(n(x)) and lostanza?(vt,n(x))
        if not lostanza-context? and can-be-inconsistent? :
          val t = type(vt,n(x))
          emit(buffer, ECheck(x, t, GetVarContext(), info(x)))

    ;Emit guards for each instruction
    for ins in ins(body) do :
      ;Ensure that variables have been set
      do*(ensure-vars-set, ins)
      ;Ensure that variables are type-consistent
      do*(ensure-vars-type-consistent, ins)

      match(ins) :
        (ins:EDef) :
          ;Guard the initialization value
          if not lostanza-context? and y(ins) is-not False :
            val t = type(vt,n(x(ins)))
            val y = y(ins) as EImm
            emit(buffer, ECheck(y, t, DefContext(), info(ins)))
          ;Initialize x
          emit(buffer, ins)
        (ins:EStore) :
          ;Guard the assigned value
          match(loc(ins)) :
            (l:EVarLoc) :
              val check? =
                if lostanza-context? and lostanza?(vt,n(l)) : false
                else : true
              if check? and refvar?(n(l)) :
                val t = type(vt,n(l))
                emit(buffer, ECheck(y(ins), t, SetContext(), info(ins)))
            (l) : false
          ;Store
          emit(buffer, ins)
        (ins:ECheckLength) :
          if not lostanza-context? :
            val tuple = EOf(n(iotable(vt), CORE-TUPLE-ID))
            emit(buffer, ECheck(y(ins), tuple, DetupleContext(), info(ins)))
          emit(buffer, ins)
        (ins:EReturn) :
          match(return-type:EType) :
            emit(buffer, ECheck(y(ins), return-type, ReturnContext(), function-info))
          emit(buffer, ins)
        (ins:EMatch|EDispatch) :
          val branches* = for b in branches(ins) map :
            if not lostanza-context? :
              for (y in ys(ins), t in types(b)) do :
                if has-tvar?(t) :
                  add-entry(n(b), ECheck(y, t, BranchContext(), info(b)))
            sub-types(b, map(remove-tvars, types(b)))
          emit(buffer, sub-branches(ins, branches*))
        (ins:ELabel) :
          emit(buffer, ins)
          for i in reverse(entry-blocks[n(ins)]) do :
            emit(buffer, i)
        (ins:ECall|ETCall) :
          let :
            if function?(f(ins)) :
              val arity = length(ys(ins))
              val [a1, a2] = fn-types(vt, f(ins) as EVar|ECurry, arity)
              if lostanza-context? and lostanza-function?(f(ins)) :
                unguarded-call(a2)
              else : guard-call(a1, a2)
            else if calltype(ins) is CallGuarded :
              val ct = calltype(ins) as CallGuarded
              if lostanza-context? : unguarded-call(a2(ct))
              else : guard-call(a1(ct), a2(ct))
            else : unguarded-call(EUnknown())
          where :
            defn function? (e:EImm) :
              match(e) :
                (e:EVar) : /function?(vt, n(e))
                (e:ECurry) : /function?(vt, n(x(e)))
                (e) : false
            defn lostanza-function? (f:EImm) :
              match(f) :
                (f:EVar) : lostanza?(vt, n(f))
                (f:ECurry) : lostanza?(vt, n(x(f)))
            defn guard-call (a1:Tuple<EType>, a2:EType) :
              ;Sanity check
              fatal("Incorrect call type") when calltype(ins) is-not CallGuarded

              match(ins) :
                (ins:ECall) :
                  ;Create a temporary return location
                  ;if there isn't one, and if the function returns.
                  val xloc* = match(x(ins)) :
                    (x:EVarLoc) :
                      x
                    (_:False) :
                      if not bottom?(a2) :
                        val n = uniqueid()
                        emit(buffer, ELocal(n, a2, false))
                        EVarLoc(n)
                  ;Check this variable if it is not false
                  val x* = if not bottom?(a2) :
                    EVar(n(xloc* as EVarLoc))
                  ;Check arguments
                  for (y in ys(ins), t in a1) do :
                    emit(buffer, ECheck(y, t, ArgContext(), info(ins)))
                  ;Check function
                  if not function?(f(ins)) :
                    val t = EOf(n(iotable(vt), CORE-FN-ID))
                    emit(buffer, ECheck(f(ins), t, FuncContext(), info(ins)))
                  ;Make call
                  emit(buffer, ECall(xloc*, f(ins), ys(ins), CallStanza(), info(ins)))
                  ;Check return type
                  match(x*:EVar) : emit(buffer, ECheck(x*, a2, ReturnContext(), info(ins)))
                  else : emit(buffer, EEnd(info(ins)))
                (ins:ETCall) :
                  ;Check arguments
                  for (y in ys(ins), t in a1) do :
                    emit(buffer, ECheck(y, t, ArgContext(), info(ins)))
                  ;Check function
                  if not function?(f(ins)) :
                    val t = EOf(n(iotable(vt), CORE-FN-ID))
                    emit(buffer, ECheck(f(ins), t, FuncContext(), info(ins)))
                  ;Make call
                  emit(buffer, ETCall(f(ins), ys(ins), CallStanza(), info(ins)))
            defn unguarded-call (a2:EType) :
              val ct* = CallStanza() when calltype(ins) is CallGuarded
                   else calltype(ins)
              emit(buffer, sub-calltype(ins, ct*))
              emit(buffer, EEnd(info(ins))) when bottom?(a2)
        (ins) :
          emit(buffer, ins)

  ;Guard functions
  defn guard-fn (f:EFn, vt:VarTable, lostanza-context?:True|False, uninitialized-vars:IntSet) -> EFn :
    val buffer = BodyBuffer(body(f))
    for f in localfns(body(f)) do :
      emit(buffer, guard-localfn(f,vt,uninitialized-vars))
    for o in localobjs(body(f)) do :
      emit(buffer, guard-localobj(o,vt,uninitialized-vars))
    val return-type = a2(f) when not lostanza-context?
    guard-body(body(f), buffer, vt, lostanza-context?, return-type, info(f), uninitialized-vars)
    sub-body(f, to-body(buffer, true, false, false))

  defn guard-method (f:EFn, vt:VarTable, lostanza-context?:True|False, uninitialized-vars:IntSet) -> EFn :
    fatal("TODO")
;    val buffer = BodyBuffer(body(f))
;    for f in localfns(body(f)) do :
;      emit(buffer, guard-localfn(f,vt,uninitialized-vars))
;    for o in localobjs(body(f)) do :
;      emit(buffer, guard-localobj(o,vt,uninitialized-vars))
;    if not lostanza-context? :
;      for (v in args(f), t in a1(f)) do :
;        if has-tvar?(t) :
;          emit(buffer, ECheck(EVar(v), t, ArgContext(), info(f)))
;    guard-body(body(f), buffer, vt, lostanza-context?, a2(f), info(f), uninitialized-vars)
;    val body* = to-body(buffer, true, false, false)
;    val a1* = map(remove-tvars, a1(f))
;    EFn(tail?(f), targs(f), args(f), a1*, a2(f), body*, info(f))

  defn map-fns<?T> (f:EFn -> EFn, x:?T&ELBigItem) -> T :
    val result = let loop (x:ELBigItem = x) :
      match(x:EFn) : f(x)
      else : map(loop, x)
    result as T&ELBigItem

  defn guard-localfn (f:ELocalFn, vt:VarTable, uninitialized-vars:IntSet) :
    ELocalFn(n(f), map-fns(guard-fn{_, vt, false, uninitialized-vars}, func(f)))

  defn guard-localobj (o:ELocalObj, vt:VarTable, uninitialized-vars:IntSet) :
    val methods* = for m in methods(o) map :
      map-fns(guard-method{_, vt, false, uninitialized-vars}, m)
    ELocalObj(n(o), type(o), methods*)

  defn guard-init (e:EInit, vt:VarTable, uninitialized-vars:IntSet) -> EInit :
    val buffer = BodyBuffer(body(e))
    for f in localfns(body(e)) do :
      emit(buffer, guard-localfn(f, vt, uninitialized-vars))
    for o in localobjs(body(e)) do :
      emit(buffer, guard-localobj(o,vt, uninitialized-vars))
    guard-body(body(e), buffer, vt, lostanza?(e), false, false, uninitialized-vars)
    val body* = to-body(buffer, true, false, false)
    EInit(body*, lostanza?(e))

  ;Overall driver
  defn analyze (e:ELBigItem, vt:VarTable) -> ELBigItem :
    val uninitialized-vars = discover-uninitialized-vars(e)
    match(e) :
      (e:EDefmethod) : map-fns(guard-method{_, vt, lostanza?(e), uninitialized-vars}, e)
      (e:EMethod) : map-fns(guard-method{_, vt, false, uninitialized-vars}, e)
      (e:EDefn) : map-fns(guard-fn{_, vt, lostanza?(e), uninitialized-vars}, e)
      (e:EExternFn) : map-fns(guard-fn{_, vt, true, uninitialized-vars}, e)
      (e:EInit) : guard-init(e, vt, uninitialized-vars)
      (e) : e
  map-with-var-table({analyze(_, _) as ETExp}, gvt, epackage)

;============================================================
;===================== Liveness Annotation ==================
;============================================================

defn annotate-live (epackage:EPackage) -> EPackage :
  defn annotate (e0:ELBigItem) -> ELBigItem :
    val e = map(annotate,e0)
    val annotate? = match(e:EFn) :
      not empty?(args(e))
    if annotate? :
      val e = e as EFn
      val ref-args = to-tuple $
        for (a in args(e), t in a1(e)) seq? :
          if reftype?(t) : One(EVar(a))
          else : None()
      val buffer = BodyBuffer(body(e))
      for i in ins(body(e)) do :
        match(i:ETCall|EReturn|EEnd) :
          if not empty?(ref-args) :
            emit(buffer, ELive(ref-args))
        emit(buffer, i)
      sub-body(e, to-body(buffer))
    else :
      e
  annotate(epackage) as EPackage

;============================================================
;================= Force Remove Checks ======================
;============================================================

defn force-remove-checks (epackage:EPackage) -> EPackage :
  defn convert-body (e:EBody) :
    val buffer = BodyBuffer(e)
    for i in ins(e) do :
      match(i) :
        (i:ECheck) : false
        (i:ECheckSet) : false
        (i:ECheckLength) : false
        (i) : emit(buffer, i)
    to-body(buffer)
  defn convert (e:ELBigItem) :
    match(map(convert,e)) :
      (e:EBody) : convert-body(e)
      (e) : e
  convert(epackage) as EPackage

;============================================================
;=============== Convert Checks to Typeof ===================
;============================================================

defn convert-checks-to-typeof (epackage:EPackage) -> EPackage :
  defn convert (e0:ELBigItem) :
    val e = map(convert, e0)
    match(e:EBody) :
      val buffer = BodyBuffer(e)
      for i in ins(e) do :
        match(i) :
          (i:ECheck) :
            match(normalize(type(i))) :
              (t:ETop) :
                false
              (t:EBot) :
                emit(buffer, ECheckFail(t, y(i), ctxt(i), info(i)))
              (t) :
                val pass-lbl = uniqueid()
                val fail-lbl = uniqueid()
                emit(buffer, ETypeof(pass-lbl, fail-lbl, t, y(i)))
                emit(buffer, ELabel(fail-lbl))
                emit(buffer, ECheckFail(t, y(i), ctxt(i), info(i)))
                emit(buffer, ELabel(pass-lbl))
          (i) :
            emit(buffer, i)
      to-body(buffer)
    else : e
  convert(epackage) as EPackage

;============================================================
;===================== Mutable Boxing =======================
;============================================================

defn box-mutables (epackage:EPackage, gvt:VarTable) -> EPackage :
  val boxed = IntSet()
  defn box (e:ELBigItem, vt:VarTable) -> ELBigItem :
    match(e) :
      (e0:EBody) :
        ;Find all closed-over variables
        val closed-over = IntSet()
        defn add-to-closed (e:ELBigItem) :
          match(e:EFn) : add-all(closed-over, vars(free(e)))
          else : do*(add-to-closed, e)
        do*(add-to-closed, e0)

        ;Add all locally closed-over mutable items to boxed set
        for l in locals(e0) do :
          if mutable?(l) and closed-over[n(l)] :
            add(boxed, n(l))

        ;Recursively analyze sub-bodies
        val e = map(box{_, vt}, e0)

        ;Perform boxing
        val buffer = BodyBuffer(e)

        ;Convert a boxed var retrieval into a BoxGet instruction
        defn retrieve-var (e:EImm) :
          match(e:EVar) :
            if boxed[n(e)] :
              val x = uniqueid()
              emit(buffer, ELocal(x, type(vt, n(e)), false))
              emit(buffer, EBoxGet(EVarLoc(x), e))
              EVar(x)
            else : e
          else : e

        ;Convert instructions for operating with boxed variables
        for i in ins(e) do :
          match(map(retrieve-var, i)) :
            (i:EDef) :
              if boxed[n(x(i))] : emit(buffer,EBox(x(i), y(i), type(vt, n(x(i)))))
              else : emit(buffer,i)
            (i:EStore) :
              match(loc(i)) :
                (x:EVarLoc) : box-store(x) when boxed[n(x)] else std-store()
                (x) : std-store()
              where :
                defn box-store (x:EVarLoc) : emit(buffer,EBoxSet(EVar(n(x)), y(i)))
                defn std-store () : emit(buffer, i)
            (i) :
              emit(buffer,i)

        ;Change local types
        defn change-to-box-type (e:EBody) :
          val locals* = for x in locals(e) map :
            if boxed[n(x)] : ELocal(n(x), EOf(n(iotable(vt),CORE-BOX-ID)), false)
            else : x
          sub-locals(e, locals*)

        ;Return new body
        change-to-box-type(to-body(buffer))
      (e) :
        map(box{_, vt}, e)

  ;Perform freevar analysis and then boxing
  within (texp, vt) = map-with-var-table(gvt, epackage) :
    box(analyze-freevars(texp, vt), vt) as ETExp

;============================================================
;=================== Detect Loops ===========================
;============================================================

defn detect-loops (epackage:EPackage) -> EPackage :
  ;Does the given immediate match the given function id?
  defn matches-fid? (e:EImm, fid:Int|False) :
    match(e) :
      (e:EVar) : n(e) == fid
      (e:ECurry) : n(x(e)) == fid
      (e) : false

  ;Scan the given body for tail calls
  defn has-loop? (e:EFn, fid:Int) :
    if empty?(targs(e)) :
      val farity = length(args(e))
      for i in ins(body(e)) any? :
        match(i:ETCall) :
          matches-fid?(f(i), fid) and
          length(ys(i)) == farity

  ;Transform tail calls
  defn transform-loops (e:ELBigItem, fid:Int|False) -> ELBigItem :
    ;First recursively evaluate all the subfunctions in the item, then
    ;work on the transformations.
    ;If we need to transform the body, then:
    ;- Introduce dummy expressions for the arguments and type arguments.
    ;- Introduce the loop label
    ;- Copy the dummy arguments into the real arguments
    ;- Scan through the instructions and generate the looping instructions when necessary.

    ;Recursively evaluate all the subfunctions in the item
    defn recurse () :
      val fid* = match(e) :
                   (e:ELocalFn) : n(e)
                   (e:EDefn) : n(e)
                   (e) : fid
      map(transform-loops{_, fid*}, e)

    ;Detect any loops in the item, and transform them
    defn detect-loop (e:ELBigItem) :
      match(e:EFn, fid:Int) :
        if has-loop?(e,fid) : transform-loop(e, fid)
        else : e
      else : e

    ;Transform the given function into a loop
    defn transform-loop (e:EFn, fid:Int) :
      fatal("TODO")
;      ;Precondition
;      fatal("Illegal input function.") when not empty?(targs(e))
;
;      val farity = length(args(e))
;      val buffer = BodyBuffer(body(e))
;
;      ;Create dummy arguments
;      val args0 = map(uniqueid{}, args(e))
;      val loop-lbl = uniqueid()
;      for (a in args(e), t in a1(e)) do :
;        emit(buffer, ELocal(a, t, false))
;
;      ;Create dummy locals for handling parallel assignment.
;      val parallel-args = map(uniqueid{}, args(e))
;      for (a in parallel-args, t in a1(e)) do :
;        emit(buffer, ELocal(a, t, false))
;
;      ;Emit loop start and entry prologue
;      for (a0 in args0, a in args(e)) do :
;        emit(buffer, EDef(EVarLoc(a), EVar(a0)))
;      emit(buffer, ELabel(loop-lbl))
;
;      ;Emit instructions and generate looping instructions
;      ;for matching tail calls.
;      for i in ins(body(e)) do :
;        ;Classify the instruction into either a loop call
;        ;or a standard instruction.
;        defn* classify () :
;          match(i:ETCall) :
;            if matches-fid?(f(i), fid) and length(ys(i)) == farity :
;              loop-call(f(i), ys(i))
;            else : standard-ins()
;          else : standard-ins()
;        ;For standard instructions just emit them to the buffer
;        defn standard-ins () :
;          emit(buffer, i)
;        ;For loop calls, generate the appropriate instructions.
;        defn loop-call (f:EImm, ys:Tuple<EImm>) :
;          for (a in parallel-args, y in ys) do :
;            emit(buffer, EDef(EVarLoc(a), y))
;          for (a in args(e), b in parallel-args) do :
;            emit(buffer, EDef(EVarLoc(a), EVar(b)))
;          emit(buffer, EGoto(loop-lbl))
;        ;Start with classify
;        classify()
;
;      ;Substitute the new body and arguments
;      val body* = to-body(buffer)
;      sub-args(sub-body(e, body*), args0)

    ;Driver
    detect-loop(recurse())

  ;Transform all functions
  map(transform-loops{_, false}, epackage)

;============================================================
;=================== Simple Inlining ========================
;============================================================

defn increment<?K> (t:Table<?K,Int>, k:K) :
  update(t, {_ + 1}, k)

defn add<?K,?V> (t:Table<?K,List<?V>>, k:K, v:V) :
  update(t, cons{v, _}, k)

defn efns (f:EFunction) :
  match(f) :
    (f:EFn) : [f]
    (f:EMultifn) : funcs(f)

deftype Ctxt <: Hashable&Equalable
defstruct Top <: Ctxt with: (printer => true)
defstruct LocalFn <: Ctxt : (n:Int) with: (printer => true)
defmethod hash (id:Ctxt) :
  match(id) :
    (id:Top) : 0
    (id:LocalFn) : 27 * n(id)
defmethod equal? (a:Ctxt, b:Ctxt) :
  match(a,b) :
    (a:Top, b:Top) : true
    (a:LocalFn, b:LocalFn) : n(a) == n(b)
    (a,b) : false

defstruct InlineFnRec :
  n: Int
  func: EFunction
  level: Int
  parent: Ctxt

defn inlining-order (return:ELocalFn -> ?, e:ELBigItem) :
  ;Tables for keeping track of all calls
  val callee-count = IntTable<Int>(0)
  val usage-count = IntTable<Int>(0)
  val callers = IntTable<List<Ctxt>>(List())

  ;Table for holding all the defined functions
  val fn-recs = IntTable<InlineFnRec>()
  defn in-fn-table? (n:Int, farity:Int) :
    val f = get?(fn-recs, n)
    match(f:InlineFnRec) :
      for efn in efns(func(f)) any? :
        farity == length(args(efn))

  ;Returns true if a is a child of b
  defn* child? (a:Ctxt, b:Ctxt) :
    if a == b :
      true
    else :
      match(a) :
        (a:LocalFn) :
          val p = parent(fn-recs[n(a)])
          child?(p, b)
        (a:Top) : false

  ;Returns the parent of a that lives at the same level as b.
  defn* match-level (a:LocalFn, b:LocalFn) :
    val ar = fn-recs[n(a)]
    val br = fn-recs[n(b)]
    if level(ar) == level(br) :
      a
    else if level(ar) > level(br) :
      match-level(parent(ar) as LocalFn, b)

  ;Loop through each item to fill the above tables
  defn loop (e:ELBigItem, fid:Ctxt, level:Int) :
    ;Register in fn table
    defn register-in-fn-table () :
      match(e:EBody) :
        for f in localfns(e) do :
          fn-recs[n(f)] = InlineFnRec(n(f), func(f), level + 1, fid)
    ;Recursively loop on subitems
    defn recurse () :
      val [fid*, level*] = match(e) :
        (e:ELocalFn) : [LocalFn(n(e)), level + 1]
        (e) : [fid, level]
      do*(loop{_, fid*, level*}, e)
    ;Look for usages
    defn look-for-usages () :
      defn loop (e:ELItem) :
        if e is-not EInitClosures :
          do(loop, e)
        match(e) :
          (e:EVar) :
            increment(usage-count, n(e))
          (e:ECall|ETCall) :
            val f* = deconstruct-function(f(e))
            if not empty?(f*) :
              val [callee, targs] = value!(f*)
              if in-fn-table?(callee, length(ys(e))) :
                increment(callee-count, callee)
                add(callers, callee, fid)
          (e) : false
      match(e:EBody) :
        do(loop, ins(e))

    ;Driver
    register-in-fn-table()
    recurse()
    look-for-usages()

  ;Compute all inlined functions.
  ;Compute all the call graph at each level.
  val inlined? = IntSet()
  val called = IntTable<List<Int>>(List())
  defn compute-inlined () :
    for fid in keys(fn-recs) do :
      if callee-count[fid] == 1 and usage-count[fid] == 1 :
        val callee = LocalFn(fid)
        val caller = head(callers[fid])
        if not child?(caller, callee) :
          add(inlined?, fid)
          match(caller:LocalFn) :
            val parent-caller = match-level(caller, callee)
            match(parent-caller:LocalFn) :
              add(called, n(parent-caller), n(callee))

  ;Order children before roots
  defn post-order (roots:Seqable<Int>, children:Int -> Seqable<Int>) :
    generate<Int> :
      val visited = IntSet()
      defn loop (n:Int) :
        if not visited[n] :
          add(visited,n)
          do(loop, children(n))
          yield(n)
      do(loop, roots)

  ;Output the functions in inlining order
  defn compute-inlining-order () :
    defn loop (e:ELBigItem) :
      match(e:EBody) :
        ;Retrieve all the local functions to be inlined
        val inlined-fns = filter({inlined?[_]}, seq(n, localfns(e)))
        val ordered-fns = post-order(inlined-fns, {called[_]})
        for f in ordered-fns do :
          val func = func(fn-recs[f])
          loop(func)
          return(ELocalFn(f, func))
        ;Recurse on non-inlined items
        for f in localfns(e) do :
          loop(f) when not inlined?[n(f)]
        do(loop, localobjs(e))
      else :
        do*(loop, e)
    loop(e)

  ;Driver
  loop(e, Top(), 0)
  compute-inlined()
  compute-inlining-order()

defn inline-call (buffer:BodyBuffer,
                  ret:EVarLoc|False, f:EFn, call-targs:Tuple<EType>, call-args:Tuple<EImm>,
                  tail?:True|False) :
  ;Utilities for substituting type arguments
  val targ-table = IntTable<EType>()
  for (ta in targs(f), v in call-targs) do :
    targ-table[ta] = v
  defn substitute-targs (x:ELItem) :
    if empty?(call-targs) :
      x
    else :
      match(x) :
        (x:ETVar) : get?(targ-table, n(x), x)
        (x) : map(substitute-targs, x)

  ;Create locals for inlining
  defn create-locals () :
    ;Define locals for arguments
    for (a in args(f), t in a1(f)) do :
      val t* = substitute-targs(t) as EType
      emit(buffer, ELocal(a, t*, false))
    ;Add all locals from function
    do(emit{buffer, substitute-targs(_) as ELocal}, locals(body(f)))
    do(emit{buffer, _}, localtypes(body(f)))
    do(emit{buffer, substitute-targs(_) as ELocalFn}, localfns(body(f)))
    do(emit{buffer, substitute-targs(_) as ELocalObj}, localobjs(body(f)))

  ;Generate instructions
  defn gen-instructions () :
    ;Label for end of function
    val end-lbl = uniqueid()

    ;Put arguments into argument locals
    for (a in args(f), v in call-args) do :
      emit(buffer, EDef(EVarLoc(a), v))

    ;Emit instructions
    for i in ins(body(f)) do :
      match(substitute-targs(i) as EIns) :
        (i:EReturn) :
          if tail? :
            emit(buffer, i)
          else :
            match(ret:EVarLoc) :
              emit(buffer, EDef(ret, y(i)))
            emit(buffer, EGoto(end-lbl))
        (i:ETCall) :
          if tail? :
            emit(buffer, i)
          else :
            match(ret:EVarLoc) :
              emit(buffer, ECall(ret, /f(i), ys(i), calltype(i), info(i)))
            emit(buffer, EGoto(end-lbl))
        (i) :
          emit(buffer, i)

    ;Emit ending label
    if not tail? :
      emit(buffer, ELabel(end-lbl))

  ;Create locals
  create-locals()
  gen-instructions()

defn simple-inline (epackage:EPackage) :
  defn inline-texp (e:ETExp) :
    ;Inlining a single function
    ;Table for holding inlined functions
    val inlined-functions = IntTable<ELocalFn>()
    defn get-inlined-function (fid:Int, arity:Int) :
      if key?(inlined-functions, fid) :
        val efns = efns(func(inlined-functions[fid]))
        for f in efns find :
          arity == length(args(f))

    ;Inlining of a body
    defn inline (e:ELBigItem) :
      match(e:EBody) :
        val buffer = BodyBuffer(e)
        for l in localfns(e) do :
          if not key?(inlined-functions, n(l)) :
            emit(buffer, inline(l) as ELocalFn)
        for o in localobjs(e) do :
          emit(buffer, inline(o) as ELocalObj)
        for i in ins(e) do :
          match(i) :
            (i:ECall|ETCall) :
              val f* = deconstruct-function(f(i))
              if empty?(f*) :
                emit(buffer, i)
              else :
                val [fid, targs] = value!(f*)
                match(get-inlined-function(fid, length(ys(i)))) :
                  (func:EFn) :
                    val [ret, tail?] = match(i) :
                      (i:ECall) : [x(i), false]
                      (i:ETCall) : [false, true]
                    inline-call(buffer, ret, func, targs, ys(i), tail?)
                  (_:False) :
                    emit(buffer, i)
            (i:EInitClosures) :
              val xs* = for x in xs(i) filter : not key?(inlined-functions, n(x))
              if not empty?(xs*) :
                emit(buffer, EInitClosures(to-tuple(xs*), info(i)))
            ;During removal of local functions, remove any references to them
            ;from ELive instructions as well.
            (i:ELive) :
              val xs* = to-tuple $ for x in xs(i) filter :
                not key?(inlined-functions, n(x as EVar))
              if not empty?(xs*) :
                emit(buffer, ELive(xs*))
            (i) :
              emit(buffer, i)
        to-body(buffer, true, false, false)
      else :
        map(inline, e)

    ;Inline in the proper inlining order
    within f = inlining-order(e) :
      val f* = inline(f) as ELocalFn
      inlined-functions[n(f*)] = f*

    ;Inline the top level
    inline(e) as ETExp

  ;Inline all top-level expressions
  sub-exps(epackage, map(inline-texp, exps(epackage)))

;============================================================
;================== Inlining ================================
;============================================================

;------------------------------------------------------------
;--------------- Special Inlining Sets ----------------------
;------------------------------------------------------------

;Returns the ids of core functions that are manually determined
;to be useful to inline.
defn force-inline-core-functions (epackage:EPackage) -> Tuple<Int> :
  ;Create set of functions to force inline.
  val functions = HashSet<ValId>()
  add(functions, ValId(`core, `do))
  add(functions, ValId(`collections, `bsearch))

  ;GC functions
  add(functions, ValId(`core, `mark-and-push))
  add(functions, ValId(`core, `test-and-set-mark))
  add(functions, ValId(`core, `extend-incomplete-range))

  ;Return true if the given export corresponds to one of the
  ;functions in the above inline table.
  defn inline? (e:Export) -> True|False :
    val id = id(rec(e))
    match(id:FnId) :
      functions[ValId(package(id), name(id))]

  ;Return ids of all functions to force inline.
  to-tuple $ seq(n, filter(inline?, exports(packageio(epackage))))

;Helper function for within-package-inline with parameter to control
;whether to include core functions to force include.
defn within-package-inline (epackage:EPackage, inline-from-core?:True|False) :
  val ids = force-inline-core-functions(epackage) when inline-from-core?
       else []
  within-package-inline(epackage, ids)

;------------------------------------------------------------
;--------------- Main Inlining Algorithm --------------------
;------------------------------------------------------------

;Scans through the given package and performing function
;inlining. Only functions defined within the given
;package are considered for inlining.
;- force-inline contains the functions that are forced to
;  to always be inlined regardless of their size.
defn within-package-inline (epackage:EPackage, force-inline:Tuple<Int>) :
  ;Scans through the top-level definitions in the package,
  ;and collects the functions that are appropriate for
  ;inlining.
  defn compute-global-inlining-table () -> IntTable<EFunction> :
    ;Get ids of functions to force inline.
    val force-set = to-intset(force-inline)

    ;Create table of functions to inline.
    val inline-table = IntTable<EFunction>()
    for exp in exps(epackage) do :
      match(exp) :
        (exp:EDefn) :
          if force-set[n(exp)] or inline-function?(func(exp)) :
            inline-table[n(exp)] = func(exp)
        (exp:EDefmethod) :
          if force-set[multi(exp)] or inline-function?(func(exp)) :
            inline-table[n(exp)] = func(exp)
        (exp) : false
    inline-table

  ;Determine whether the function with the given
  ;arity exists in either the local inlining table (lit),
  ;or the global inlining table (git). The arity is used for inlining
  ;variable-arity functions to retrieve the appropriate branch.
  defn get-inlined-function (fid:Int, arity:Int,
                             git:IntTable<EFunction>,
                             lit:IntTable<EFunction>) -> EFn|False :
    ;Lookup function in both tables.
    val func = match(get?(lit, fid), get?(git, fid)) :
      (lf:EFunction, gf) : lf
      (lf:False, gf:EFunction) : gf
      (lf:False, gf:False) : false
    ;Lookup appropriate arity branch.
    match(func:EFunction) :
      for f in efns(func) find :
        arity == length(args(f))

  ;Recursively performing inlining on all definitions
  ;and nested definitions within the given top-level
  ;expression.
  ;- git is the global inlining table.
  defn inline-texp (e:ETExp, git:IntTable<EFunction>) -> ETExp :
    ;Hold table of local functions appropriate to be inlined.
    ;An entry, n => f, in this table indicates that
    ;all calls to the function with identifier 'n' will be
    ;inlined.
    val inlined-functions = IntTable<EFunction>()
    defn add-to-inline-table (l:ELocalFn) :
      inlined-functions[n(l)] = func(l)

    ;Return a version of e with inlining performed.
    defn inline (e:ELBigItem) -> ELBigItem :
      match(e:EBody) :
        ;Scan through local functions within this body,
        ;and add them to the inline table if they
        ;are appropriate to be inlined.
        for l in localfns(e) do :
          add-to-inline-table(l) when inline-function?(func(l))

        ;Create buffer to store new inlined instructions.
        val buffer = BodyBuffer(e)

        ;Recursively inline local functions and
        ;objects.
        for l in localfns(e) do :
          emit(buffer, inline(l) as ELocalFn)
        for o in localobjs(e) do :
          emit(buffer, inline(o) as ELocalObj)

        ;Scan through each instruction and for
        ;function calls inline them when appropriate.
        ;Pass through other instructions changed.
        for i in ins(e) do :
          match(i:ECall|ETCall) :
            ;Retrieve the function being called, and the
            ;type arguments it is called with.
            val f* = deconstruct-function(f(i))
            if empty?(f*) :
              ;Cannot determine the name of the
              ;function being called.
              emit(buffer, i)
            else :
              ;Calling fid with type arguments targs.
              val [fid, targs] = value!(f*)
              match(get-inlined-function(fid, length(ys(i)), git, inlined-functions)) :
                (func:EFn) :
                  ;Retrieve the variable the function call
                  ;is returned to, and whether it is a tail call
                  ;or not.
                  val [ret, tail?] = match(i) :
                    (i:ECall) : [x(i), false]
                    (i:ETCall) : [false, true]
                  ;Inline all of the instruction in the function body
                  ;into the current buffer.
                  inline-call(buffer, ret, rename-fn(func), targs, ys(i), tail?)
                (_:False) :
                  emit(buffer, i)
          else :
            emit(buffer, i)

        ;Return new body
        to-body(buffer, true, false, false)

      else :
        ;Recursively perform inlining on all nested bodies.
        map(inline, e)

    ;Inline the top level.
    inline(e) as ETExp

  ;Launch!
  val git = compute-global-inlining-table()
  val texps* = for e in exps(epackage) map :
    inline-texp(e, git)
  sub-exps(epackage, texps*)

;------------------------------------------------------------
;--------------- Determine Whether to Inline ----------------
;------------------------------------------------------------

;Return true if the given function should be inlined.
defn inline-function? (f:EFunction) -> True|False :
  match(f) :
    (f:EMultifn) :
      all?(inline-function?, funcs(f))
    (f:EFn) :
      if empty?(localfns(body(f))) and empty?(localobjs(body(f))) :
        small-function?(f) or
        higher-order-function?(f)

;Return true if the given function is a leaf function.
;It contains no nested functions or objects and does not call
;any other function.
defn leaf-function? (f:EFn) -> True|False :
  empty?(localfns(body(f))) and
  empty?(localobjs(body(f))) and
  none?({_ is ECall|ETCall}, ins(body(f)))

;Return true if the given function is a "small" function.
defn small-function? (f:EFn) -> True|False :
  ;Is it a leaf function?
  val leaf? = none?({_ is ECall|ETCall}, ins(body(f)))
  ;A leaf function is "small" if it has less than 12 instructions.
  ;A non-leaf function is "small" if it has less than 8 instructions.
  val num-ins = length(ins(body(f)))
  if leaf? : num-ins < 12
  else : num-ins < 8

;Return true if the given function is a "higher-order function".
;A "higher-order function" is a function that contains at least one
;argument that only appears in function call position within the
;body of the function.
defn higher-order-function? (e:EFn) -> True|False :
  ;Returns true if the variable 'a' is used and only used in function
  ;call position in the body.
  defn only-called? (a:Int) -> True|False :
    ;Track whether 'a' has been called.
    ;Initialized to false, and then set as true.
    var called?:True|False = false

    ;Return true if the given immediate i is equal to EVar(a).
    defn equals-a? (i:EImm) -> True|False :
      match(i:EVar) : n(i) == a

    ;Compute whether a is only used in call position.
    val only-appears-in-call-position? = 
      for i in ins(body(e)) all? :
        match(i) :
          (i:ECall|ETCall) :
            ;Record whether the function was 'a'.
            if equals-a?(f(i)) : called? = true
            ;Ensure none of the arguments use 'a'.
            none?(equals-a?, ys(i))
          (i:ELive) : true
          (i:EIns) :  none?(equals-a?, uses(i))

    ;Return true if a only appears in call position and
    ;a is called.
    only-appears-in-call-position? and called?

  ;Return true if any of the arguments appear only in calling position.
  any?(only-called?, args(e))

;------------------------------------------------------------
;------------ Rename using Fresh Variables ------------------
;------------------------------------------------------------

;Return a behaviourally-identical function with fresh
;identifiers generated for all local definitions.
defn rename-fn (f:EFn) -> EFn :
  ;Collect renamed identifiers
  val id-table = IntTable<Int>()
  val label-table = IntTable-init<Int>(uniqueid{})
  defn make-id (x:Int) : id-table[x] = uniqueid()
  defn make-ids (xs:Tuple<Int>) : do(make-id, xs)
  defn id (x:Int) : get?(id-table, x, x)
  defn ids (xs:Tuple<Int>) : map(id, xs)
  defn label* (x:Int) : label-table[x]

  ;Create new names for all local definitions, and
  ;all locals contained within nested definitions.
  ;This call will populate the 'id-table' above.
  defn create-definitions (e:ELItem) :
    match(e) :
      (e:EFn) :
        make-ids(targs(e))
        make-ids(args(e))
      (e:EBody) :
        do(make-id{n(_)}, locals(e))
        do(make-id{n(_)}, localtypes(e))
        do(make-id{n(_)}, localfns(e))
        do(make-id{n(_)}, localobjs(e))
      (e:EMethod) :
        make-id(n(e))
      (e) :
        false
    do(create-definitions, e)

  ;Use the id-table populated previously to rename all references to
  ;local definitions.
  defn rename (e:ELItem) :
    match(map(rename, e)) :
      ;Local definitions
      (e:EFn) : sub-args(sub-targs(e, ids(targs(e))), ids(args(e)))
      (e:ELocal) : sub-n(e, id(n(e)))
      (e:ELocalType) : sub-n(e, id(n(e)))
      (e:ELocalFn) : sub-n(e, id(n(e)))
      (e:ELocalObj) : sub-n(e, id(n(e)))
      ;Local usages - immediates
      (e:EMethod) : sub-n(sub-thisn(e, id(thisn(e))), id(n(e)))
      (e:EVar) : EVar(id(n(e)))
      (e:EVarLoc) : EVarLoc(id(n(e)))
      (e:ETVar): ETVar(id(n(e)))
      (e:ETVarLoc) : ETVarLoc(id(n(e)))
      ;Local usages - operations
      (e:ENew) : ENew(x(e), id(n(e)), info(e))
      ;Local usages - labels
      (e:ELabel) : ELabel(label*(n(e)))
      (e:EGoto)  : EGoto(label*(n(e)))
      (e:EIf) : EIf(label*(n1(e)), label*(n2(e)), op(e), ys(e))
      (e:EBranch) : EBranch(types(e), label*(n(e)), info(e))
      (e:ETypeof) : ETypeof(label*(n1(e)), label*(n2(e)), type(e), y(e))
      ;Fall through
      (e) : e

  create-definitions(f)
  rename(f) as EFn

;============================================================
;==================== Label Cleanup =========================
;============================================================

;Remove simple occurrences of immediate jumps to the next label.
;For this pattern:
;  goto n
;  label n
;We can remove those two instructions if that is the only
;usage of that label.
;This pattern occurs as a result of function inlining.

defn cleanup-labels (epackage:EPackage) -> EPackage :
  defn cleanup-body (e:EBody) -> EBody :
    ;Collect all used labels
    val num-uses = IntTable<Int>(0)
    for i in ins(e) do :
      for v in label-uses(i) do :
        update(num-uses, {_ + 1}, v)
    ;Remove simple label patterns
    val buffer = BodyBuffer(e)
    val len = length(ins(e))
    let loop (i:Int = 0) :
      if i < len - 1 :
        val ins1 = ins(e)[i]
        val ins2 = ins(e)[i + 1]
        match(ins1:EGoto, ins2:ELabel) :
          if n(ins1) == n(ins2) and num-uses[n(ins2)] == 1 :
            loop(i + 2)
          else :
            emit(buffer, ins1)
            emit(buffer, ins2)
            loop(i + 2)
        else :
          emit(buffer, ins1)
          loop(i + 1)
      else if i < len :
        emit(buffer, ins(e)[i])
    ;Return the new body
    to-body(buffer)

  ;Recursively clean up all nested definitions
  defn cleanup-item (e:ELBigItem) -> ELBigItem :
    match(map(cleanup-item, e)) :
      (b:EBody) : cleanup-body(b)
      (item) : item

  ;Launch!
  val exps* = for e in exps(epackage) map :
    cleanup-item(e) as ETExp
  sub-exps(epackage, exps*)

;============================================================
;==================== CONSTANT FOLD =========================
;============================================================

;------------------------------------------------------------
;-------------------- Constant Values -----------------------
;------------------------------------------------------------

;Primitive numbers supported by constant folding.
deftype ConstantValue :
  Byte <: ConstantValue
  Int <: ConstantValue
  Long <: ConstantValue
  Float <: ConstantValue
  Double <: ConstantValue
  True <: ConstantValue
  False <: ConstantValue

;Return true if the given two constants are of the same type.
defn same-type? (a:ConstantValue, b:ConstantValue) -> True|False :
  match(a, b) :
    (a:Byte, b:Byte) : true
    (a:Int, b:Int) : true
    (a:Long, b:Long) : true
    (a:Float, b:Float) : true
    (a:Double, b:Double) : true
    (a:True|False, b:True|False) : true
    (a, b) : false

;Return true if the given constant represents zero.
defn zero? (v:ConstantValue) -> True|False :
  match(v) :
    (v:Byte) : v == 0Y
    (v:Int) : v == 0
    (v:Long) : v == 0L
    (v:Float) : v == 0.0f
    (v:Double) : v == 0.0
    (v) : false

;Return true if the given constant represents one.
defn one? (v:ConstantValue) -> True|False :
  match(v) :
    (v:Byte) : v == 1Y
    (v:Int) : v == 1
    (v:Long) : v == 1L
    (v:Float) : v == 1.0f
    (v:Double) : v == 1.0
    (v) : false

;Return a representation of zero with the same type as the given constant.
defn zero (v:ConstantValue) -> ConstantValue :
  match(v) :
    (v:Byte) : 0Y
    (v:Int) : 0
    (v:Long) : 0L
    (v:Float) : 0.0f
    (v:Double) : 0.0

;------------------------------------------------------------
;-------------------- Folding Primitives --------------------
;------------------------------------------------------------

;The multis for handling the different cases of folding.
;- fold-binary-op: Responsible for folding binary operations when both arguments are known constants.
;- fold-unary-op: Responsible for folding unary operations when argument is a known constant.
;- partial-fold-binary-op: Responsible for folding binary operations when one argument is a known constant.
;- fold-conv: Responsible for folding conversion operations when one argument is a known constant.
;For each folding function, if we are able to successfully statically evaluate the operator,
;then f is called with the result, and the returned instruction by f is returned by the folder. Otherwise, we
;return false.
defmulti fold-binary-op (op:EOp, f:ConstantValue -> EIns|False, a0:ConstantValue, a1:ConstantValue) -> False|EIns
defmulti fold-unary-op (op:EOp, f:ConstantValue -> EIns|False, a0:ConstantValue) -> False|EIns
defmulti fold-conv (f:ConstantValue -> EIns|False, xtype:EType, a0:ConstantValue) -> False|EIns
defmulti partial-fold-binary-op (op:EOp, f:ConstantValue|EImm -> EIns|False, a0:ConstantValue|EImm, a1:ConstantValue|EImm) -> False|EIns

;------------------------------------------------------------
;-------------------- Defaults ------------------------------
;------------------------------------------------------------

;Return false by default to signal no successful constant folding.
defmethod partial-fold-binary-op (op:EOp, f:ConstantValue|EImm -> EIns|False, a0:ConstantValue|EImm, a1:ConstantValue|EImm) : false
defmethod partial-fold-binary-op (op:EOp, f:ConstantValue|EImm -> EIns|False, a0:ConstantValue, a1:ConstantValue) : fatal("Invalid arguments.")
defmethod partial-fold-binary-op (op:EOp, f:ConstantValue|EImm -> EIns|False, a0:EImm, a1:EImm) : fatal("Invalid arguments.")

;<doc>-------------------------------------------------------
;------------------- Binary Op Folding ----------------------
;------------------------------------------------------------

## Description of Folding Table ##
Guard:
- Simple: No guard is needed. The final value can always be computed from input values.
- Guarded: Guard is needed. For some specific values, we do not attempt to compute the final value.
Types:
- B: Byte
- I: Int
- L: Long
- F: Float
- D: Double
Stanza Operator:
- existing: The behaviour of the operator can be implemented using an existing Stanza operator.
- custom: The behaviour of the operator needs some custom logic to be implemented.
Left Operand Folding / Right Operand Folding:
- Z: Do something if the argument is zero.
- I: Do something if the argument is one.
- unchanged: The result is the other argument unchanged.
- zeroed: The result is zero.
- multiply: The zero/one multiply relation.

Arity  | Op        | Guard   | Types  | Stanza Operator | Left Operand Folding | Right Operand Folding
======================================================================================================
Binary | IntAddOp  | Simple  | I      | existing        | Z -> unchanged       | Z -> unchanged
Binary | IntSubOp  | Simple  | I      | existing        |                      | Z -> unchanged
Binary | IntMulOp  | Simple  | I      | existing        | ZI -> multiply       | ZI -> multiply
Binary | IntDivOp  | Guarded | I      | existing        |                      | I -> unchanged
Binary | IntModOp  | Guarded | I      | existing        |                      | I -> zeroed
Binary | IntAndOp  | Simple  | I      | existing        | Z -> zeroed          | Z -> zeroed
Binary | IntOrOp   | Simple  | I      | existing        | Z -> unchanged       | Z -> unchanged
Binary | IntXorOp  | Simple  | I      | existing        | Z -> unchanged       | Z -> unchanged
Binary | IntShlOp  | Simple  | I      | existing        | Z -> zeroed          | Z -> unchanged
Binary | IntShrOp  | Simple  | I      | existing        | Z -> zeroed          | Z -> unchanged
Binary | IntAshrOp | Simple  | I      | existing        | Z -> zeroed          | Z -> unchanged
Binary | IntLtOp   | Simple  | I      | existing        |
Binary | IntGtOp   | Simple  | I      | existing        |
Binary | IntLeOp   | Simple  | I      | existing        |
Binary | IntGeOp   | Simple  | I      | existing        |
Binary | RefEqOp   | Simple  | ?      | existing        |
Binary | RefNeOp   | Simple  | ?      | existing        |
Binary | AddOp     | Simple  | BILFD  | existing        | Z -> unchanged       | Z -> unchanged
Binary | SubOp     | Simple  | BILFD  | existing        |                      | Z -> unchanged
Binary | MulOp     | Simple  | BILFD  | existing        | ZI -> multiply       | ZI -> multiply
Binary | DivOp     | Guarded | ILFD   | existing        |                      | I -> unchanged
Binary | ModOp     | Guarded | IL     | existing        |                      | I -> zeroed
Binary | AndOp     | Simple  | BIL    | existing        | Z -> zeroed          | Z -> zeroed
Binary | OrOp      | Simple  | BIL    | existing        | Z -> unchanged       | Z -> unchanged
Binary | XorOp     | Simple  | BIL    | existing        | Z -> unchanged       | Z -> unchanged
Binary | ShlOp     | Simple  | BIL    | existing        | Z -> zeroed          | Z -> unchanged
Binary | ShrOp     | Simple  | BIL    | existing        | Z -> zeroed          | Z -> unchanged
Binary | AshrOp    | Simple  | IL     | existing        | Z -> zeroed          | Z -> unchanged
Binary | EqOp      | Simple  | BILFD  | custom          |
Binary | NeOp      | Simple  | BILFD  | custom          |
Binary | LtOp      | Simple  | BILFD  | custom          |
Binary | GtOp      | Simple  | BILFD  | custom          |
Binary | LeOp      | Simple  | BILFD  | custom          |
Binary | GeOp      | Simple  | BILFD  | custom          |
Unary  | IntNotOp  | Simple  | I      | existing        |
Unary  | IntNegOp  | Simple  | I      | existing        |
Unary  | NotOp     | Simple  | BIL    | existing        |
Unary  | NegOp     | Simple  | ILFD   | existing        |

;------------------------------------------------------------
;-------------------------------------------------------<doc>

;------------------------------------------------------------
;------------------- Full Binary Folding  -------------------
;------------------------------------------------------------

defmethod fold-binary-op (op:EOp, f:ConstantValue -> EIns|False, a0:ConstantValue, a1:ConstantValue) -> False|EIns :
  defn call<?T> (f:(T,T) -> ConstantValue, a:?T, b:?T) : f(a,b)
  defn bool-to-long (v:True|False) : 1L when v else 0L
  if same-type?(a0,a1) :
    match(op, a0, a1) :
      (op:IntAddOp, a0:Int, a1:Int) : f(a0 + a1)
      (op:IntSubOp, a0:Int, a1:Int) : f(a0 - a1)
      (op:IntMulOp, a0:Int, a1:Int) : f(a0 * a1)
      (op:IntDivOp, a0:Int, a1:Int) : f(a0 / a1) when a1 != 0
      (op:IntModOp, a0:Int, a1:Int) : f(a0 % a1) when a1 != 0
      (op:IntAndOp, a0:Int, a1:Int) : f(a0 & a1)
      (op:IntOrOp, a0:Int, a1:Int) : f(a0 | a1)
      (op:IntXorOp, a0:Int, a1:Int) : f(a0 ^ a1)
      (op:IntShlOp, a0:Int, a1:Int) : f(a0 << a1)
      (op:IntShrOp, a0:Int, a1:Int) : f(a0 >> a1)
      (op:IntAshrOp, a0:Int, a1:Int) : f(a0 >>> a1)
      (op:IntLtOp, a0:Int, a1:Int) : f(a0 < a1)
      (op:IntGtOp, a0:Int, a1:Int) : f(a0 > a1)
      (op:IntLeOp, a0:Int, a1:Int) : f(a0 <= a1)
      (op:IntGeOp, a0:Int, a1:Int) : f(a0 >= a1)
      (op:RefEqOp, a0:ConstantValue&Equalable, a1:ConstantValue&Equalable) : f(a0 == a1)
      (op:RefNeOp, a0:ConstantValue&Equalable, a1:ConstantValue&Equalable) : f(a0 != a1)
      (op:AddOp, a0:Byte|Int|Long|Float|Double, a1:Byte|Int|Long|Float|Double) : f(call(plus,a0,a1))
      (op:SubOp, a0:Byte|Int|Long|Float|Double, a1:Byte|Int|Long|Float|Double) : f(call(minus,a0,a1))
      (op:MulOp, a0:Byte|Int|Long|Float|Double, a1:Byte|Int|Long|Float|Double) : f(call(times,a0,a1))
      (op:DivOp, a0:Int|Long|Float|Double, a1:Int|Long|Float|Double) : f(call(divide,a0,a1)) when not zero?(a1)
      (op:ModOp, a0:Int|Long, a1:Int|Long) : f(call(modulo,a0,a1)) when not zero?(a1)
      (op:AndOp, a0:Byte|Int|Long, a1:Byte|Int|Long) : f(call(bit-and,a0,a1))
      (op:OrOp, a0:Byte|Int|Long, a1:Byte|Int|Long) : f(call(bit-or,a0,a1))
      (op:XorOp, a0:Byte|Int|Long, a1:Byte|Int|Long) : f(call(bit-xor,a0,a1))
      (op:ShlOp, a0:Byte|Int|Long, a1:Byte|Int|Long) : f(call(shift-left,a0,a1))
      (op:ShrOp, a0:Byte|Int|Long, a1:Byte|Int|Long) : f(call(shift-right,a0,a1))
      (op:AshrOp, a0:Int|Long, a1:Int|Long) : f(call(arithmetic-shift-right,a0,a1))
      (op:EqOp, a0:Byte|Int|Long|Float|Double, a1:Byte|Int|Long|Float|Double) : f(bool-to-long(a0 == a1))
      (op:NeOp, a0:Byte|Int|Long|Float|Double, a1:Byte|Int|Long|Float|Double) : f(bool-to-long(a0 != a1))
      (op:LtOp, a0:Byte|Int|Long|Float|Double, a1:Byte|Int|Long|Float|Double) : f(bool-to-long(a0 < a1))
      (op:GtOp, a0:Byte|Int|Long|Float|Double, a1:Byte|Int|Long|Float|Double) : f(bool-to-long(a0 > a1))
      (op:LeOp, a0:Byte|Int|Long|Float|Double, a1:Byte|Int|Long|Float|Double) : f(bool-to-long(a0 <= a1))
      (op:GeOp, a0:Byte|Int|Long|Float|Double, a1:Byte|Int|Long|Float|Double) : f(bool-to-long(a0 >= a1))
      (op, a0, a1) : false

;------------------------------------------------------------
;------------------- Full Unary Folding  --------------------
;------------------------------------------------------------

defmethod fold-unary-op (op:EOp, f:ConstantValue -> EIns|False, a0:ConstantValue) -> False|EIns :
  defn call<?T> (f:T -> ConstantValue, a:?T) : f(a)
  match(op, a0) :
    (op:IntNotOp, a0:Int) : f(bit-not(a0))
    (op:IntNegOp, a0:Int) : f(negate(a0))
    (op:NotOp, a0:Byte|Int|Long) : f(call(bit-not,a0))
    (op:NegOp, a0:Int|Long|Float|Double) : f(call(negate,a0))
    (op:LowestZeroBitCountOp, a0:Long) : f(call(lowest-zero-bit-count,a0))
    (op, a0) : false


;------------------------------------------------------------
;---------------------- Conv Folding ------------------------
;------------------------------------------------------------

defmethod fold-conv (f:ConstantValue -> EIns|False, xtype:EType, y:ConstantValue) -> False|EIns :
  match(xtype, y) :
    (xtype:EByte, y:Byte|Int|Long|Float|Double) : f(to-byte(y))
    (xtype:EInt, y:Byte|Int|Long|Float|Double) : f(to-int(y))
    (xtype:ELong, y:Byte|Int|Long|Float|Double) : f(to-long(y))
    (xtype:EFloat, y:Byte|Int|Long|Float|Double) : f(to-float(y))
    (xtype:EDouble, y:Byte|Int|Long|Float|Double) : f(to-double(y))
    (xtype, y) : false

;------------------------------------------------------------
;-------------- Partial Folding Left Operand  ---------------
;------------------------------------------------------------

defmethod partial-fold-binary-op (op:EOp, f:ConstantValue|EImm -> EIns|False, a0:ConstantValue, a1:EImm) :
  defn Z-to-unchanged () : f(a1) when zero?(a0)
  defn I-to-unchanged () : f(a1) when one?(a0)
  defn Z-to-zeroed () : f(zero(a0)) when zero?(a0)
  defn ZI-to-multiply () :
    if zero?(a0) : f(zero(a0))
    else if one?(a0) : f(a1)
    else : false
  match(op, a0) :
    (op:IntAddOp, a0:Int) : Z-to-unchanged()
    (op:IntMulOp, a0:Int) : ZI-to-multiply()
    (op:IntAndOp, a0:Int) : Z-to-zeroed()
    (op:IntOrOp, a0:Int) : Z-to-unchanged()
    (op:IntXorOp, a0:Int) : Z-to-unchanged()
    (op:IntShlOp, a0:Int) : Z-to-zeroed()
    (op:IntShrOp, a0:Int) : Z-to-zeroed()
    (op:IntAshrOp, a0:Int) : Z-to-zeroed()
    (op:AddOp, a0:Byte|Int|Long|Float|Double) : Z-to-unchanged()
    (op:MulOp, a0:Byte|Int|Long) : ZI-to-multiply()
    (op:MulOp, a0:Float|Double) : I-to-unchanged()
    (op:AndOp, a0:Byte|Int|Long) : Z-to-zeroed()
    (op:OrOp, a0:Byte|Int|Long) : Z-to-unchanged()
    (op:XorOp, a0:Byte|Int|Long) : Z-to-unchanged()
    (op:ShlOp, a0:Byte|Int|Long) : Z-to-zeroed()
    (op:ShrOp, a0:Byte|Int|Long) : Z-to-zeroed()
    (op:AshrOp, a0:Int|Long) : Z-to-zeroed()
    (op, a0) : false

;------------------------------------------------------------
;-------------- Partial Folding Right Operand  --------------
;------------------------------------------------------------

defmethod partial-fold-binary-op (op:EOp, f:ConstantValue|EImm -> EIns|False, a0:EImm, a1:ConstantValue) :
  defn Z-to-unchanged () : f(a0) when zero?(a1)
  defn I-to-unchanged () : f(a0) when one?(a1)
  defn Z-to-zeroed () : f(zero(a1)) when zero?(a1)
  defn I-to-zeroed () : f(zero(a1)) when one?(a1)
  defn ZI-to-multiply () :
    if zero?(a1) : f(zero(a1))
    else if one?(a1) : f(a0)
    else : false
  match(op, a1) :
    (op:IntAddOp, a1:Int) : Z-to-unchanged()
    (op:IntSubOp, a1:Int) : Z-to-unchanged()
    (op:IntMulOp, a1:Int) : ZI-to-multiply()
    (op:IntDivOp, a1:Int) : I-to-unchanged()
    (op:IntModOp, a1:Int) : I-to-zeroed()
    (op:IntAndOp, a1:Int) : Z-to-zeroed()
    (op:IntOrOp, a1:Int) : Z-to-unchanged()
    (op:IntXorOp, a1:Int) : Z-to-unchanged()
    (op:IntShlOp, a1:Int) : Z-to-unchanged()
    (op:IntShrOp, a1:Int) : Z-to-unchanged()
    (op:IntAshrOp, a1:Int) : Z-to-unchanged()
    (op:AddOp, a1:Byte|Int|Long|Float|Double) : Z-to-unchanged()
    (op:SubOp, a1:Byte|Int|Long|Float|Double) : Z-to-unchanged()
    (op:MulOp, a1:Byte|Int|Long) : ZI-to-multiply()
    (op:MulOp, a1:Float|Double) : I-to-unchanged()
    (op:DivOp, a1:Int|Long|Float|Double) : I-to-unchanged()
    (op:ModOp, a1:Int|Long) : I-to-zeroed()
    (op:AndOp, a1:Byte|Int|Long) : Z-to-zeroed()
    (op:OrOp, a1:Byte|Int|Long) : Z-to-unchanged()
    (op:XorOp, a1:Byte|Int|Long) : Z-to-unchanged()
    (op:ShlOp, a1:Byte|Int|Long) : Z-to-unchanged()
    (op:ShrOp, a1:Byte|Int|Long) : Z-to-unchanged()
    (op:AshrOp, a1:Int|Long) : Z-to-unchanged()
    (op, a1) : false

;------------------------------------------------------------
;------------------ Constant Classification -----------------
;------------------------------------------------------------

;Utility structure to represent the result of classifying an EImm.
deftype ClassifiedEImm
defstruct ConstantEImm <: ClassifiedEImm : (histanza?:True|False, value:ConstantValue)
defstruct NonConstantEImm <: ClassifiedEImm : (value:EImm)

;Classify the given EImm.
defn classify-eimm (eimm:EImm) -> ClassifiedEImm :
  match(eimm) :
    (eimm:ELiteral|ELSLiteral) :
      match(value(eimm)) :
        (v:ConstantValue) : ConstantEImm(eimm is ELiteral, v)
        (v) : NonConstantEImm(eimm)
    (eimm) : NonConstantEImm(eimm)

;Returns true if the given op has a HiStanza return value.
defn histanza? (op:EOp) -> True|False :
  op is IntAddOp|IntSubOp|IntMulOp|IntDivOp|IntModOp|IntAndOp|
        IntOrOp|IntXorOp|IntNotOp|IntShlOp|IntShrOp|IntAshrOp|
        IntLtOp|IntGtOp|IntLeOp|IntGeOp|IntNegOp|RefEqOp|RefNeOp

;------------------------------------------------------------
;---------- Classify and Fold Over Primitive Op -------------
;------------------------------------------------------------

;Classify the given arguments and fold them if appropriate.
;Returns an EIns if both folding and creating instruction is successful.
;Otherwise returns false.
;- make-ins (histanza?, value): The function for creating the resulting instruction
;  after constant folding has been performed.
defn* fold-args (make-ins:(True|False, ConstantValue|EImm) -> EIns|False,
                 op:EOp|False,
                 args:Tuple<EImm>) -> EIns|False :
  switch(length(args)) :
    1 :
      match(classify-eimm(args[0])) :
        (a0:ConstantEImm) :
          match(op:EOp) : fold-unary-op(op, make-ins{histanza?(op), _}, value(a0))
          else : make-ins(histanza?(a0), value(a0))
        (a0:NonConstantEImm) :
          false
    2 :
      match(classify-eimm(args[0]), classify-eimm(args[1])) :
        (a0:ConstantEImm, a1:ConstantEImm) :
          if histanza?(a0) == histanza?(a1) :
            fold-binary-op(op as EOp, make-ins{histanza?(op as EOp), _}, value(a0), value(a1))
        (a0:ConstantEImm, a1:NonConstantEImm) :
          partial-fold-binary-op(op as EOp, make-ins{histanza?(op as EOp), _}, value(a0), value(a1))
        (a0:NonConstantEImm, a1:ConstantEImm) :
          partial-fold-binary-op(op as EOp, make-ins{histanza?(op as EOp), _}, value(a0), value(a1))
        (a0:NonConstantEImm, a1:NonConstantEImm) :
          false
    else :
      false

;------------------------------------------------------------
;-------------- Classify and Fold Over Conv -----------------
;------------------------------------------------------------

;Classify the given argument and fold the conv instruction.
;Returns an EIns if both folding and creating instruction is successful.
;Otherwise returns false.
;- make-ins(value): The function for creating the resulting instruction
;  after constant folding has been performed.
defn* classify-and-fold-conv (make-ins:ConstantValue -> EIns|False,
                              xtype:EType,
                              y:EImm) -> EIns|False :
  match(classify-eimm(y)) :
    (c:ConstantEImm) :
      ;Conv is not defined on HiStanza literals.
      fold-conv(make-ins, xtype, value(c)) when not histanza?(c)
    (c:NonConstantEImm) :
      false

;------------------------------------------------------------
;---------------------- Driver ------------------------------
;------------------------------------------------------------

; Compiler pass to fold constants in both primitives and if operations.
; Tracks immutable literal bindings and then uses them
; to feed a large set of functions that run operations at compile time on
; values of these literals and produce new literal bindings as a result or
; in partial folding cases just create simplifications.
; Returns false if no changes were made.
defn try-constant-fold (epackage:EPackage, gvt:VarTable) -> EPackage|False :
  ;Record whether progress was made.
  var progress?:True|False = false
  defn record-progress () : progress? = true

  ;Perform constant folding on all instructions in the given body.
  ;Assumes that nested bodies are already folded.
  defn fold-in-body (e:EBody, vt:VarTable) -> EBody :
    ;Return the constant-folded version of the given instruction.
    defn fold (i:EIns) -> EIns :
      match(i) :
        (i:EPrim) :
          ;Create EDef instruction out of ConstantValue|EImm
          defn make-def (histanza?:True|False, v:ConstantValue|EImm) -> EDef :
            val value = match(histanza?, v) :
              (hi-stanza?:True, v:ConstantValue) : ELiteral(v)
              (hi-stanza?:False, v:ConstantValue) : ELSLiteral(v)
              (hi-stanza?, v:EImm) : v
            EDef(x(i) as EVarLoc, value)
          ;Fold the arguments and store result in EDef instruction.
          match(fold-args(make-def, op(i), ys(i))) :
            (ins:EIns) :
              record-progress()
              ins
            (f:False) : i
        (i:EConv) :
          ;Create EDef instruction out of ConstantValue.
          defn make-def (v:ConstantValue) -> EDef :
            EDef(x(i), ELSLiteral(v))
          val xtype = type(vt,n(x(i)))
          match(classify-and-fold-conv(make-def, xtype, y(i))) :
            (ins:EIns) :
              record-progress()
              ins
            (f:False) : i
        (i:EIf) :
          ;Create EGoto instruction out of ConstantValue
          defn make-goto (histanza?:True|False, v:ConstantValue|EImm) -> EGoto|False :
            match(histanza?, v) :
              (histanza?:True, v:True) : EGoto(n1(i))
              (histanza?:True, v:False) : EGoto(n2(i))
              (histanza?:False, v:Long) : EGoto(n2(i) when v == 0L else n1(i))
              (histanza?, v) : false
          ;Fold the arguments and create goto instruction.
          match(fold-args(make-goto, op(i), ys(i))) :
            (ins:EIns) :
              record-progress()
              ins
            (f:False) : i
        (i) :
          i
    ;Launch!
    val ins* = map(fold, ins(e))
    sub-ins(e, ins*)

  ;Recursively perform constant folding on all bodies.
  defn fold-all-bodies (x:ELBigItem, vt:VarTable) -> ELBigItem :
    match(map(fold-all-bodies{_, vt}, x)) :
      (x:EBody) : fold-in-body(x,vt)
      (x) : x

  ;Launch!
  val result = map-with-var-table({fold-all-bodies(_, _) as ETExp}, gvt, epackage)
  result when progress?

;Return the original package if constant folding didn't do anything.
defn constant-fold (epackage:EPackage, gvt:VarTable) -> EPackage :
  match(try-constant-fold(epackage, gvt)) :
    (p:EPackage) : p
    (f:False) : epackage

;============================================================
;================== Type Simplification =====================
;============================================================

defn simplify-typeof (epackage:EPackage) -> EPackage :
  ;Simplify all ETypeof expressions.
  defn simplify (e:EIns) -> EIns :
    match(e:ETypeof) :
      ;If type is Top, then goto pass label.
      ;If type is Bot, then goto fail label.
      ;Otherwise keep the typeof expression.
      match(normalize(type(e))) :
        (type*:ETop) : EGoto(n1(e))
        (type*:EBot) : EGoto(n2(e))
        (type*) : sub-type(e, type*)
    else :
      e

  ;Recursively simplify all instructions in the big item.
  defn simplify-bodies (x:ELBigItem) -> ELBigItem :
    match(map(simplify-bodies,x)) :
      (x:EBody) : sub-ins(x, map(simplify,ins(x)))
      (x) : x

  ;Launch!
  simplify-bodies(epackage) as EPackage

;============================================================
;=================== Lambda Lifting =========================
;============================================================

deftype LiftTable
defmulti lift? (t:LiftTable, f:Int) -> True|False
defmulti get (t:LiftTable, f:Int) -> Free

defn LiftTable (etexp:ETExp, allow-global-closures?:True|False) :
  ;Populate freevar-table and value usage table
  val freevar-table = IntTable<Tuple<Int>>()
  val used-as-value = IntSet()
  val var-or-tvar = IntTable<True|False>()

  defn record-free (n:Int, f:Free) :
    freevar-table[n] = to-tuple(cat(vars(f), tvars(f)))
    for v in vars(f) do : var-or-tvar[v] = true
    for v in tvars(f) do : var-or-tvar[v] = false

  defn to-free (vs:Tuple<Int>) :
    val [vars, tvars] = split({var-or-tvar[_]}, vs)
    Free(to-tuple(vars), to-tuple(tvars))

  scan(etexp) where :
    defn scan (e:ELItem) :
      match(e) :
        (e:ELocalFn) :
          record-free(n(e), fnfree(func(e)))
          do(scan, e)
        (e:EVar) : add(used-as-value, n(e))
        (e:ECall|ETCall) : do(scan, ys(e))
        (e) : do(scan, e)
    defn fnfree (f:EFunction) :
      match(f) :
        (f:EFn) : free(f)
        (f:EMultifn) : join-free $ seq(free, funcs(f))

  ;Compute lifting parameters
  ;Initially assume that all functions are lifted.
  val liftvar-table = let loop () :
    let :
      val num-lifted = length(freevar-table)
      identify-unlifted-functions()
      if length(freevar-table) < num-lifted :
        loop()
      else :
        val liftvars = compute-lift-vars()
        if length(freevar-table) < num-lifted : loop()
        else : liftvars
    where :
      defn forbid-lift? (f:Int, vars:Tuple<Int>) :
        defn unlifted? (n:Int) : not key?(freevar-table, n)
        val max-lift-vars = 8
        val num-free = count(unlifted?, vars)
        if allow-global-closures? :
          if num-free > 0 :
            used-as-value[f] or num-free > max-lift-vars
        else :
          used-as-value[f] or num-free > max-lift-vars

      defn identify-unlifted-functions () :
        for f in to-tuple(keys(freevar-table)) do :
          val free = freevar-table[f]
          remove(freevar-table,f) when forbid-lift?(f,free)

      defn compute-lift-vars () :
        to-inttable<Tuple<Int>> $
          for e in bipartite-closure(freevar-table) seq :
            val [f, free] = [key(e), value(e)]
            remove(freevar-table,f) when forbid-lift?(f,free)
            e

  ;Return table
  new LiftTable :
    defmethod lift? (this, f:Int) : key?(liftvar-table, f)
    defmethod get (this, f:Int) : to-free(liftvar-table[f])

defn lambda-lift (epackage:EPackage, gvt:VarTable) :
  ;Buffer for new top level expressions
  val new-texps = Vector<ETExp>()

  defn analyze (item:ETExp, lift-table:LiftTable, vt:VarTable) -> ETExp :
    ;Should the given local function be lifted?
    defn lifted? (e:ELocalFn) :
      lift?(lift-table, n(e))
    defn lifted? (e:EVarLoc) :
      lift?(lift-table, n(e))

    ;Return the free vars to lift e with, if e refers to a lifted function
    defn lift-free (e:EImm) -> Free|False :
      match(e) :
        (e:EVar) : lift-table[n(e)] when lift?(lift-table, n(e))
        (e:ECurry) : lift-table[n(x(e))] when lift?(lift-table, n(x(e)))
        (e) : false

    ;Add lifted type arguments to the given function immediate
    defn add-targs (e:EImm, free:Free) :
      defn curry (v:EVar, targs:Seq<EType>) :
        if empty?(targs) : v
        else : ECurry(v, to-tuple(targs))
      val free-targs = seq(ETVar, tvars(free))
      match(e) :
        (e:EVar) : curry(e, free-targs)
        (e:ECurry) : curry(x(e), cat(free-targs, targs(e)))

    ;Add lifted arguments to the given arguments
    defn add-args (xs:Tuple<EImm>, free:Free) :
      val vs = vars(free)
      if empty?(vs) : xs
      else : to-tuple(cat(seq(EVar, vs), xs))

    ;Lift a locally-defined function to the top-level
    defn lift-function (f:ELocalFn) -> False :
      ;Rename the free variables used in the func
      defn rename-free (func:EFn, free:Free) :
        if empty?(vars(free)) and empty?(tvars(free)) :
          func
        else :
          val rename-table = IntTable<Int>()
          for v in cat(vars(free), tvars(free)) do :
            rename-table[v] = uniqueid()
          rename-vars+tvars(func, rename-table)

      ;Lift all bodies in function
      defn lift-inner-functions (x:ELBigItem, free:Free) :
        match(x:EFn) :
          fatal("TODO")
;          val targs* = to-tuple(cat(tvars(free), targs(x)))
;          val args* = to-tuple(cat(vars(free), args(x)))
;          val vartypes = seq(type{vt, _}, vars(free))
;          val a1* = to-tuple(cat(vartypes, a1(x)))
;          val body* = lift-bodies(body(x))
;          val func* = EFn(tail?(x), targs*, args*, a1*, a2(x), body*, info(x))
;          rename-free(func*, free)
        else :
          map(lift-inner-functions{_, free}, x)

      ;Driver
      val func* = lift-inner-functions(func(f), lift-table[n(f)])
      add(new-texps, EDefn(n(f), func* as EFunction, false))

    ;Process a body:
    ;  - Lift all local functions to top-level
    ;  - Transform instructions as necessary
    defn lift-bodies<?T> (x:?T&ELBigItem) -> T :
      match(x) :
        (body:EBody) :
          val buffer = BodyBuffer(body)
          for f in localfns(body) do :
            if lifted?(f) : lift-function(f)
            else : emit(buffer, lift-bodies(f))
          for o in localobjs(body) do :
            emit(buffer, lift-bodies(o))
          for ins in ins(body) do :
            match(ins) :
              (ins:ECall|ETCall) :
                fatal("Expected guards to be removed.") when calltype(ins) is CallGuarded
                match(lift-free(f(ins))) :
                  (free:Free) :
                    val f* = add-targs(f(ins), free)
                    val ys* = add-args(ys(ins), free)
                    emit(buffer, sub-f(sub-ys(ins, ys*), f*))
                  (_:False) :
                    emit(buffer, ins)
              (ins:EInitClosures) :
                val xs* = to-tuple(filter({not lifted?(_)}, xs(ins)))
                if not empty?(xs*) :
                  emit(buffer, EInitClosures(xs*, info(ins)))
              (ins) :
                emit(buffer, ins)
          to-body(buffer, true, false, false) as T&EBody
        (x) :
          map(lift-bodies, x)

    ;Driver: Recursively find all bodies and analyze them
    lift-bodies(item)

  ;Drive with local var table and free var analysis
  val epackage* = within (texp, vt) = map-with-var-table(gvt, epackage) :
    val texp* = analyze-freevars(texp,vt)
    val lift-table = LiftTable(texp*, false)
    analyze(texp*, lift-table, vt)
  add-exps(epackage*, new-texps)

;============================================================
;==================== Check Elision =========================
;============================================================
defn elide-checks (epackage:EPackage, ehier:EHier, gvt:VarTable) -> EPackage :
  ;Elide all checks in body.
  defn elide-checks (e:EBody, vt:VarTable) -> EBody :
    val buffer = BodyBuffer(e)
    val annotations = EBodyAnnotations(e, vt, false)
    for e in ins(annotations) do :
      match(e:ECheck) :
        val ytype = annotations[y(e)]
        emit(buffer, e) when not subtype?(ehier, ytype, type(e))
      else :
        emit(buffer, e)
    to-body(buffer)

  ;Elide checks recursively in the given top level expression e
  defn elide-texp (e:ETExp, vt:VarTable) :
    ;Elide checks in all bodies
    defn elide-checks-in-bodies (e:ELBigItem) :
      match(map(elide-checks-in-bodies, e)) :
        (e:EBody) : elide-checks(e, vt)
        (e) : e
    ;Add type annotations and then run the elide checks algorithm.
    val annotated = add-type-annotations(e, IntTable<EDefObject>(), vt, false)
    elide-checks-in-bodies(annotated) as ETExp

  ;Launch
  map-with-var-table(elide-texp, gvt, epackage)

;============================================================
;=================== Object Lifting =========================
;============================================================

defn lift-objects (epackage:EPackage, gvt:VarTable) -> EPackage :
  ;Buffer for new top level expressions
  val new-texps = Vector<ETExp>()

  ;Lift an instance method to the top level
  ;objfree contains the freevars stored in the object
  ;obj-n is the identifier of the EDefObject of the object declaration
  ;Returns the method id
  defn lift-method (obj-n:Int, m:EMethod, objfree:Free, vt:VarTable) -> Int :
    val fbody = body(func(m))
    val buffer = BodyBuffer(fbody)

    ;Track necessary renames
    val rename-table = IntTable<Int>()
    defn rename-var (v:Int) :
      val v* = uniqueid()
      rename-table[v] = v*
      v*

    ;Emit freevars for variables
    for v in vars(free(func(m))) do :
      val i = index-of(vars(objfree), v)
      match(i:Int) :
        val v* = rename-var(v)
        val t = type(vt, v)
        emit(buffer, ELocal(v*, t, false))
        emit(buffer, EObjectGet(EVarLoc(v*), EVar(thisn(m)), obj-n, i))
    ;Emit freetypes
    for v in tvars(free(func(m))) do :
      val i = index-of!(tvars(objfree), v)
      val v* = rename-var(v)
      emit(buffer, ELocalType(v*))
      emit(buffer, EObjectTGet(ETVarLoc(v*), EVar(thisn(m)), obj-n, i))

    ;Check that recursion has been done
    fatal("Objects not yet lifted!") when not empty?(localobjs(fbody))

    ;Emit renamed function and body
    for f in localfns(fbody) do :
      emit(buffer, rename-vars+tvars(f, rename-table))
    for i in ins(fbody) do :
      emit(buffer, rename-vars+tvars(i, rename-table))

    ;Push new method to top level
    val f = func(m)
    val a1* = to-tuple $
      for (x in args(f), t in a1(f)) seq :
        EOf(obj-n) when x == thisn(m) else remove-tvars(t)
    val a2* = remove-tvars(a2(f))
    fatal("TODO")
;    val f* = EFn(tail?(f), targs(f), args(f), a1*, a2*, to-body(buffer, true, false, false), info(f))
;    add(new-texps, EDefmethod(n(m), multi(m), [], f*, false))
;    n(m)

  ;Sweep through the body and lift out declarations of local objects.
  defn lift-body (e:EBody, vt:VarTable) :
    ;For each object, which we will lift to obj-n:
    ;- calculate the freevars stored in the object
    ;- then generate the object declaration
    ;- then lift each instance method to the top level
    ;- then sweep through instructions and replace ENew with ENewObject

    ;Keep track of computed object freevars
    val objfree-table = IntTable<Free>()

    ;Lift each object
    for obj in localobjs(e) do :
      ;Compute object freevars
      val objfree = join-free(seq(free{func(_)}, methods(obj)))
      objfree-table[n(obj)] = objfree

      ;Lift instance methods
      val methods = map(lift-method{n(obj), _, objfree, vt}, methods(obj))

      ;Generate object declaration
      add(new-texps, EDefObject(n(obj), type(obj), ntargs, nargs, methods)) where :
        val ntargs = length(tvars(objfree))
        val nargs = length(vars(objfree))

    ;Generate new instructions
    val ins* = for i in ins(e) map :
      match(i:ENew) :
        val objfree = objfree-table[n(i)]
        val ys = map(EVar, vars(objfree))
        val targs = map(ETVar, tvars(objfree))
        ENewObject(x(i), n(i), targs, ys, info(i))
      else : i

    ;Return new body
    sub-localobjs{_, []} $
    sub-ins(e, ins*)

  ;Recursively analyze each body
  defn analyze (e:ELBigItem, vt:VarTable) -> ELBigItem :
    match(map(analyze{_, vt}, e)) :
      (e:EBody) : lift-body(e, vt)
      (e) : e

  val epackage* = within (texp, vt) = map-with-var-table(gvt, epackage) :
    val texp* = analyze-freevars(texp,vt)
    analyze(texp*, vt) as ETExp
  add-exps(epackage*, new-texps)

;============================================================
;=============== Building the Dispatch Table ================
;============================================================

;------------------------------------------------------------
;-------------------- Utility Structs -----------------------
;------------------------------------------------------------

;Represents the dispatch dag for a particular defmulti.
;- dag: allows us to calculate which methods a call
;  can dispatch to.
;- targets: Holds the labels corresponding to each method.
defstruct MethodDag :
  dag: Dag
  targets: Tuple<Int>

;Represents the dispatch dag for a set of branches.
;- dag: allows us to calculate which branches a match/dispatch
;  can dispatch to.
;- branches: Holds the corresponding branches.
defstruct BranchDag :
  dag: Dag
  branches: Tuple<EBranch>

defmethod print (o:OutputStream, dag:MethodDag) :
  val o2 = IndentedStream(o)
  print(o, "MethodDag:")
  lnprint(o2, "dag:")
  lnprint(o2, Indented(/dag(dag)))
  lnprint(o2, "targets: %," % [targets(dag)])

;------------------------------------------------------------
;-------------- Dispatch Table Interface --------------------
;------------------------------------------------------------
;A table containing the necessary type and method information
;to enable statically dispatching to a specific method/branch.
deftype DispatchTable

;Returns true if the given identifier corresponds to a multi.
defmulti multi? (t:DispatchTable, multi:Int) -> True|False

;Calculates the specific method that a call to a multi resolves to.
;Returns the identifier of the method if the call can be resolved, or false otherwise.
;Note that the given multi must be guaranteed to be a multi.
defmulti resolve-method (t:DispatchTable, multi:Int, args:Tuple<EType>) -> Int|False

;Calculates the specific branches that are applicable in a match/dispatch statement.
;Returns all the branches that are reachable for the specific argument types given.
;Topological? should be true to consider branches according to their specificity relation.
;Used for EDispatch.
defmulti resolve-branches (t:DispatchTable, branches:Tuple<EBranch>, args:Tuple<EType>, topological?:True|False) -> Tuple<EBranch>

;------------------------------------------------------------
;--------------- Building the Dispatch Table ----------------
;------------------------------------------------------------

;Create a DispatchTable given the type definitions in the package.
defn DispatchTable (epackage:EPackage) -> DispatchTable :
  ;Overall algorithm
  defn driver () :
    val class-tree = make-class-tree()
    val method-table = create-method-table()
    val dag-table = create-method-dag-table(class-tree, method-table)
    build-dispatch-table(class-tree, dag-table)

  ;Create a class tree
  defn make-class-tree () -> DynTree :
    ;Retrieve the identifiers of nested EOf in 't'.
    defn parent-ids (t:EType|False) -> Tuple<Int> :
      to-tuple $ let loop (t:EType|False = t) :
        match(t) :
          (t:EAnd) : cat(loop(a(t)), loop(b(t)))
          (t:EOf) : [n(t)]
          (t:False) : []

    ;Create class tree.
    ;Note that DefStruct and DefObject are passed true for "leaf?" argument.
    DynTree $ for e in exps(epackage) seq? :
        match(e) :
          (e:EDefType) : One(NodeState(n(e), parent-ids(parent(e)), children(e), false))
          (e:EDefStruct) : One(NodeState(n(e), parent-ids(parent(e)), [], true))
          (e:EDefObject): One(NodeState(n(e), parent-ids(parent(e)), [], true))
          (e) : None()

  ;Create method table.
  defn create-method-table () -> HashTable<Int,List<EDefmethod>> :
    val methods = filter-by<EDefmethod>(exps(epackage))
    group-by(multi, methods)

  ;Create a single method dag.
  defn create-method-dag (class-tree:DynTree, ms:Tuple<EDefmethod>) -> MethodDag :
    defn to-branch (m:EDefmethod) :
      val method-types = a1(func(m))
      val args* = map(etype-to-arg{class-tree, _, true}, method-types)
      Branch(args*)
    val branch-table = BranchTable(map(to-branch, ms), non-leaves(class-tree))
    val dag = compute-dispatch-dag(branch-table, true)
    MethodDag(dag, map(n,ms))

  ;Create a single branch dag.
  defn create-branch-dag (class-tree:DynTree, bs:Tuple<EBranch>, topological?:True|False) -> BranchDag :
    defn to-branch (b:EBranch) :
      val args* = map(etype-to-arg{class-tree, _, true}, types(b))
      Branch(args*)
    val branch-table = BranchTable(map(to-branch, bs), non-leaves(class-tree))
    val dag = compute-dispatch-dag(branch-table, topological?)
    BranchDag(dag, bs)

  ;Create the method dag table.
  defn create-method-dag-table (class-tree:DynTree, method-table:HashTable<Int,List<EDefmethod>>) -> IntTable<MethodDag> :
    to-inttable<MethodDag> $ for entry in method-table seq :
      key(entry) => create-method-dag(class-tree, to-tuple(value(entry)))

  ;Resolve through dag
  defn resolve-method (class-tree:DynTree, dag-table:IntTable<MethodDag>, multi:Int, types:Tuple<EType>) -> Int|False :
    val mdag = dag-table[multi]
    val args = map(etype-to-arg{class-tree, _, false}, types)
    val solns = all-solns(dag(mdag), args, false)
    if length(solns) == 1 :
      val i = index(solns[0] as UniqueSoln)
      targets(mdag)[i]

  ;Resolve through branch dag table.
  defn resolve-branches (class-tree:DynTree, bdag:BranchDag, types:Tuple<EType>) -> Tuple<EBranch> :
    val args = map(etype-to-arg{class-tree, _, false}, types)
    val solns = all-solns(dag(bdag), args, false) as Tuple<UniqueSoln>
    val bs = branches(bdag)
    switch(length(solns)) :
      0 : []
      1 : [bs[index(solns[0])]]
      length(bs) : bs
      else : map({bs[_]}, qsort(seq(index,solns)))

  ;Build the Dispatch Table
  defn build-dispatch-table (class-tree:DynTree, dag-table:IntTable<MethodDag>) :
    new DispatchTable :
      defmethod multi? (this, n:Int) :
        key?(dag-table, n)
      defmethod resolve-method (this, multi:Int, args:Tuple<EType>) :
        resolve-method(class-tree, dag-table, multi, args)
      defmethod resolve-branches (this, branches:Tuple<EBranch>, args:Tuple<EType>, topological?:True|False) :
        val dag = create-branch-dag(class-tree, branches, topological?)
        resolve-branches(class-tree, dag, args)

  ;Launch
  driver()

;------------------------------------------------------------
;-------------- Resolution Algorithm Table ------------------
;------------------------------------------------------------

;Resolves all multis, matches, dispatches.
;Calls to multis are attempted to be replaced by a call to a specific method.
;Matches are replaced with either a goto, or a match with a smaller set of branches.
;Dispatches are replaced with either a goto, or a dispatch with a smaller set of branches.
;Note that this is an unsafe optimization: a match with only a single branch remaining
;is not guaranteed to be equivalent to a Goto. It may also not match any of the branches.
defn resolve-methods-and-matches (epackage:EPackage, gvt:VarTable) -> EPackage :
  ;Create the dispatch table for the package.
  val dispatch-table = DispatchTable(epackage)

  ;Create the table of defobjects for use by the type
  ;annotation engine.
  val defobjects = to-inttable<EDefObject> $
    for e in filter-by<EDefObject>(exps(epackage)) seq :
      n(e) => e

  ;Resolve all dispatches in the given body.
  ;Does not recurse to nested definitions.
  defn resolve-in-body (e:EBody, vt:VarTable) -> EBody :
    ;Compute type annotations for the body.
    val annotations = EBodyAnnotations(e, vt, true)

    ;Resolve target of call.
    ;Returns the new function if the call can be resolved.
    defn resolve-call-target (f:EImm, ys:Tuple<EImm>) -> EImm|False :
      ;Retrieve the function id.
      val fid = match(f) :
        (f:EVar) : n(f)
        (f:ECurry) : n(x(f))
        (f) : false
      ;Function for replacing the function id.
      defn sub-fid (n:Int) :
        match(f) :
          (f:EVar) : EVar(n)
          (f:ECurry) : ECurry(EVar(n), targs(f))
      ;If the function id corresponds to a multi.
      match(fid:Int) :
        if multi?(dispatch-table, fid) :
          ;Then resolve the method based upon the inferred types.
          val ys-types = map({annotations[_]}, ys)
          match(resolve-method(dispatch-table, fid, ys-types)) :
            (n:Int) : sub-fid(n)
            (n:False) : false

    ;Resolve a call to a multi.
    defn resolve-call (i:ECall|ETCall) -> ECall|ETCall :
      val f* = resolve-call-target(f(i), ys(i))
      match(f*:EImm) : sub-f(i, f*)
      else : i

    ;Resolve branches in match and dispatch instructions.
    ;Strip away any unreachable branches. If there is only a single
    ;branch remaining, then replace it with a goto instruction.
    defn resolve-branches (i:EMatch|EDispatch) -> EIns :
      val ys-types = map({annotations[_]}, ys(i))
      val branches* = /resolve-branches(dispatch-table, branches(i), ys-types, i is EDispatch)
      if length(branches*) == 1 : EGoto(n(branches*[0]))
      else : sub-branches(i, branches*)

    ;Resolve all calls, matches, and dispatches.
    val ins* = for i in ins(annotations) seq :
      ;Resolve calls and tcalls
      match(i) :
        (i:ECall|ETCall) : resolve-call(i)
        (i:EMatch|EDispatch) : resolve-branches(i)
        (i) : i
    sub-ins(e, to-tuple(ins*))

  ;Call resolve-in-body for all EBody structures in the
  ;given top-level expression.
  defn resolve-texp (e:ETExp, vt:VarTable) -> ETExp :
    defn resolve-bodies (e:ELBigItem) -> ELBigItem :
      match(map(resolve-bodies,e)) :
        (e:EBody) : resolve-in-body(e,vt)
        (e) : e
    val annotated = add-type-annotations(e, defobjects, vt, true)
    resolve-bodies(annotated) as ETExp

  ;Resolve each top-level expression with the computed
  ;local VarTable for each top-level expression.
  map-with-var-table(resolve-texp, gvt, epackage)

;============================================================
;==================== Beta Reduction ========================
;============================================================

;Attempt beta reduction on the epackage.
;Returns false if no progress was made.
defn try-beta-reduce (epackage:EPackage, gvt:VarTable) -> EPackage|False :
  ;Record whether any progress was made.
  var progress?:True|False = false
  defn record-progress () : progress? = true

  ;If the given location is an immutable global value, then
  ;return its identifier, otherwise return false.
  defn immutable-global-value? (loc:ELoc) -> Int|False :
    match(loc:EVarLoc) :
      n(loc) when key?(gvt,n(loc)) and not mutable?(gvt, n(loc))

  ;Returns true if the given immediate is appropriate to be substituted
  ;in place of all beta-reduced variables.
  defn appropriate-beta-reduced-value? (y:EImm, vt:VarTable) -> True|False :
    match(y) :
      (y:EVar) : key?(vt,n(y)) and not mutable?(vt, n(y))
      (y:ELiteral) : value(y) is Byte|Int|Long|Float|Double|Char|True|False
      (y:ELSLiteral) : value(y) is Byte|Int|Long|Float|Double|Char|True|False
      (y:ETagof) : true
      (y:ESizeof) : true
      (y) : false

  ;Inspect the globally initialized defs in the package.
  ;Collect their initial values.
  defn collect-global-initial-values () -> IntListTable<EImm> :
    val entries = IntListTable<EImm>()
    for einit in filter-by<EInit>(exps(epackage)) do :
      for ins in ins(body(einit)) do :
        match(ins:EStore) :
          val loc-id = immutable-global-value?(loc(ins))
          match(loc-id:Int) :
            if appropriate-beta-reduced-value?(y(ins),gvt) :
              add(entries, loc-id, y(ins))
    entries

  ;For all immutable variables that are initialized only using EDef
  ;instructions to other immutable variables, collect those EDef
  ;instructions.
  defn collect-local-initial-values (e:EBody, vt:VarTable) -> IntListTable<EImm> :
    ;Collect all initial values in entries.
    ;Collect all variables that are assigned through non-EDef instruction
    ;in remove-set. These are never appropriate to be beta-reduced variables.
    val entries = IntListTable<EImm>()
    val remove-set = IntSet()
    for i in ins(e) do :
      match(i:EDef) :
        val v = n(x(i))
        if not mutable?(vt,v) and y(i) is EImm :
          if appropriate-beta-reduced-value?(y(i) as EImm,vt) :
            add(entries, v, y(i) as EImm)
          else :
            add(remove-set, v)
      else :
        do(add{remove-set, n(_)}, varlocs(i))

    ;Remove any inappropriate entries.
    for v in to-tuple(keys(entries)) do :
      remove(entries,v) when remove-set[v]

    ;Return entries
    entries

  ;Returns true if a and b refer to equivalent immediates.
  defn equal-imm? (a:EImm, b:EImm) -> True|False :
    match(a,b) :
      (a:EVar, b:EVar) : n(a) == n(b)
      (a:ELiteral, b:ELiteral) : value(a) == value(b)
      (a:ELSLiteral, b:ELSLiteral) : value(a) == value(b)
      (a:ETagof, b:ETagof) : n(a) == n(b)
      (a:ESizeof, b:ESizeof) : type(a) == type(b)
      (a, b) : false

  ;Compute the substitution table to use for beta reduction.
  ;If n => e appears in the result table, then any reference to variable
  ;n should be replaced by e.
  defn compute-sub-table (values:IntListTable<EImm>) -> IntTable<EImm> :
    ;Returns an entry in the substitution table if the given
    ;entry in the deftable is appropriate.
    defn subentry? (e:KeyValue<Int,List<EImm>>) -> Maybe<KeyValue<Int,EImm>> :
      ;Compute whether all the values are the same.
      val v0 = head(value(e))
      val all-equal-to-v0? = all?(equal-imm?{v0, _}, tail(value(e)))

      ;If all the values are the same, then we can
      ;perform the substitution.
      if all-equal-to-v0? : One(key(e) => v0)
      else : None()

    ;Compute the initial substitution table.
    val table = to-inttable<EImm> $ seq?(subentry?, values)

    ;Iteratively follow chains of substitutions until we reach the root.
    defn* follow (v:EImm) -> EImm :
      match(v:EVar) :
        match(get?(table, n(v))) :
          (x:EImm) : follow(x)
          (f:False) : v
      else : v

    ;Replace every entry in the table with its chain root.
    for entry in to-tuple(table) do :
      remove(table, key(entry))
      table[key(entry)] = follow(value(entry))

    ;Return final subtitution table
    table

  ;Add new substitution entries from the given body to an existing
  ;substitution table.
  defn add-to-sub-table (subtable:IntTable<EImm>, e:EBody, vt:VarTable) -> False :
    val new-table = compute-sub-table $
      collect-local-initial-values(e,vt)
    for entry in new-table do :
      subtable[key(entry)] = value(entry)

  ;Perform beta-substitution on the given instruction.
  ;Returns the new instruction resulting from beta-substition.
  defn beta-sub? (e:EIns, local-subtable:IntTable<EImm>, global-subtable:IntTable<EImm>) -> EIns :
    ;Return the substitution for the given immediate.
    defn sub-imm? (e:EImm) -> EImm :
      match(e:EVar) :
        match(get?(local-subtable,n(e)), get?(global-subtable,n(e))) :
          (x:EImm, y) :
            record-progress()
            x
          (x, y:EImm) :
            record-progress()
            y
          (x, y) : e
      else : e
    ;Perform substitutions on all immediates in the instruction.
    match(e:ELive) :
      ;ELive is treated specially because the arguments need to
      ;be EVar. This is handled by filtering out everything that isn't
      ;an EVar after performing substitutions.
      ELive $ to-tuple $
        filter-by<EVar>(seq(sub-imm?, xs(e)))
    else :
      map(sub-imm?, e)

  ;Perform beta-reduction on the given body.
  defn beta-reduce-body (e:ELBigItem,
                         local-subtable:IntTable<EImm>,
                         global-subtable:IntTable<EImm>,
                         vt:VarTable) -> ELBigItem :
    ;Compute updated entry by performing substitutions.
    val e* =
      match(e:EBody) :
        ;Add new entries to the substitution table.
        add-to-sub-table(local-subtable, e, vt)

        ;If there are no substitutions to perform, then no substitutions
        ;are necessary
        if empty?(local-subtable) and empty?(global-subtable) :
          e
        ;Otherwise, perform substitution on all instructions.
        else :
          val ins* = for ins in ins(e) map :
            beta-sub?(ins, local-subtable, global-subtable)
          sub-ins(e, ins*)
      else :
        e

    ;Recursively perform substitution on nested definitions.
    map(beta-reduce-body{_, local-subtable, global-subtable, vt}, e*)

  ;Beta-reduce all bodies in the package.
  defn beta-reduce-texp (e:ETExp, global-subtable:IntTable<EImm>, vt:VarTable) :
    val local-subtable = IntTable<EImm>()
    beta-reduce-body(e, local-subtable, global-subtable, vt) as ETExp

  ;Launch!
  val global-subtable = compute-sub-table $ collect-global-initial-values()
  val result = map-with-var-table(beta-reduce-texp{_, global-subtable, _}, gvt, epackage)
  result when progress?

;Return the original EPackage if no progress was made.
defn beta-reduce (epackage:EPackage, gvt:VarTable) -> EPackage :
  match(try-beta-reduce(epackage, gvt)) :
    (p:EPackage) : p
    (f:False) : epackage

;============================================================
;============ Iterative Constant-Beta-Reduction =============
;============================================================

;Iteratively alternate between constant-folding and beta-reduction until
;no more progress.
defn iterative-constant-fold-beta-reduce (epackage:EPackage, gvt:VarTable) -> EPackage :
  var result:EPackage = epackage
  within progress = fixpoint() :
    ;Try constant folding
    match(try-constant-fold(result, gvt)) :
      (p:EPackage) :
        result = p
        progress()
      (f:False) :
        false
    ;Try beta reduction
    match(try-beta-reduce(result, gvt)) :
      (p:EPackage) :
        result = p
        progress()
      (f:False) :
        false
  result

;============================================================
;================= Dead Code Elimination ====================
;============================================================

;Returns true if the given instruction is pure.
;If the result of a pure instruction is not used, then it
;is safe to be eliminated without altering the behaviour
;of the program.
defn pure? (e:EIns) -> True|False :
  match(e) :
    (e:EDef|EInitClosures|ENew|ETuple|EVoidTuple|ETupleGet|EObject|EArray|
       EStruct|EPtr|ELoad|EInterpret|EConv|EBox|EBoxGet|ENewObject|
       EObjectGet|EClosureGet|
       ELetRec|ETypeObject|ETypeof) : true
    (e:ETupleSet|EStore|ETCall|ECall|EDump|EGoto|EIf|ELabel|EClosureTGet|
       EMatch|EDispatch|ECheckLength|ECheck|ECheckSet|EBoxSet|ETDef|EObjectTGet|
       EReturn|EEnd|ELive|ECheckFail) : false
    (e:EPrim) :
      pure?(op(e))

;Returns true if the given instruction is pure.
defn pure? (op:EOp) -> True|False :
  match(op) :
    (op:FlushVMOp|GCOp|PrintStackTraceOp|CollectStackTraceOp|CRSPOp|EnterStackOp|YieldOp) : false
    (op:TestBitOp|TestAndSetBitOp|TestAndClearBitOp|SetBitOp|ClearBitOp) : false
    (op) : true

;Annotations for different types of usages.
;- UsedInLive means that a variable is used in only ELive instructions.
;- UsedAsArg means that a variable is used at least once as an argument.
defenum UsageType :
  UsedInLive
  UsedAsArg

;Returns the more prioritized usage type.
;Returns UsedAsArg if either argument is UsedAsArg.
defn max (a:UsageType, b:UsageType) -> UsageType :
  match(a, b) :
    (a:UsedAsArg, b) : a
    (a, b:UsedAsArg) : b
    (a:UsedInLive, b:UsedInLive) : a

;Removes any pure instructions in the package whose
;results are not used at all.
defn eliminate-dead-code (epackage:EPackage) -> EPackage :
  ;Collect all uses of variables in the given top-level expression.
  defn collect-defs-and-uses (e:ETExp) -> [IntListTable<EIns>, IntTable<UsageType>] :
    val def-table = IntListTable<EIns>()
    val use-table = IntTable<UsageType>()
    let loop (e:ELItem = e) :
      match(e:EIns) :
        ;Gather all defs in this instruction
        for x in varlocs(e) do :
          add(def-table, n(x), e)
        ;Gather all uses in this instruction.
        val usage-type = UsedInLive when e is ELive
                    else UsedAsArg
        for x in uses(e) do :
          match(x:EVar) :
            use-table[n(x)] = match(get?(use-table, n(x))) :
              (t0:UsageType) : max(t0, usage-type)
              (f:False) : usage-type
      else :
        do(loop, e)
    ;Return def and use tables
    [def-table, use-table]

  ;Compute the set of variables to eliminate based on their definitions and usages.
  defn vars-to-eliminate (def-table:IntListTable<EIns>, use-table:IntTable<UsageType>) -> IntSet :
    ;Returns true if the given instruction can be eliminated.
    ;Note that for 'EDef x = v' instructions, where v is a variable, we consider
    ;ELive as a proper usage so that object live ranges are preserved.
    defn eliminate? (i:EIns) -> True|False :
      if pure?(i) :
        ;Determine whether ELive is considered as a usage.
        val consider-live? = match(i:EDef) : y(i) is EVar
        ;If Elive is considered then see whether any
        ;varloc is used.
        if consider-live? :
          for v in varlocs(i) none? :
            get?(use-table, n(v)) is UsedInLive|UsedAsArg
        else :
          for v in varlocs(i) none? :
            get?(use-table, n(v)) is UsedAsArg

    ;A variable can be eliminated if all instructions that define
    ;it can be eliminated.
    to-intset $ for entry in def-table seq? :
      if all?(eliminate?, value(entry)) : One(key(entry))
      else : None()

  ;Eliminate dead instructions in the given body.
  defn eliminate-vars-in-body (e:EBody, elim-vars:IntSet) -> EBody :
    ;Gather new instructions in buffer.
    val buffer = BodyBuffer(e)
    ;Keep only the instructions that are not eliminated.
    ;Record all the used objects and fns during this sweep.
    val used-objs-and-fns = IntSet()
    for i in ins(e) do :
      match(i:ELive) :
        ;Remove any references to eliminated variables
        ;in the ELive instruction.
        val xs* = to-tuple $ for x in xs(i) filter :
          not elim-vars[n(x as EVar)]
        if not empty?(xs*) :
          emit(buffer, ELive(xs*))
      else :
        ;Eliminate the instruction if any of the variables
        ;it defines is supposed to be eliminated.
        val elim? = for v in varlocs(i) any? :
          elim-vars[n(v)]
        if not elim? :
          emit(buffer, i)
          ;Since we keep the instruction, record whether
          ;they reference a local function or object.
          match(i) :
            (i:ENew) : add(used-objs-and-fns, n(i))
            (i:EInitClosures) : do(add{used-objs-and-fns, n(_)}, xs(i))
            (i) : false
    ;Keep all the locals that are not eliminated.
    for l in locals(e) do :
      emit(buffer,l) when not elim-vars[n(l)]
    ;Keep only the fns and objects that are not eliminated.
    for f in localfns(e) do :
      emit(buffer,f) when used-objs-and-fns[n(f)]
    for obj in localobjs(e) do :
      emit(buffer, obj) when used-objs-and-fns[n(obj)]
    ;Create new body
    to-body(buffer, false, false, false)

  ;Peephole prune redundant live var instructions.
  defn consolidate-live-vars (e:EBody) -> EBody :
    ;Gather new instructions in buffer.
    val buffer = BodyBuffer(e)

    ;Track pending live vars to be emitted next.
    ;If x exists in this set, that means that we have scanned through
    ;a sequence of ELive instructions in a row, and x is one of the live variables.
    val pending-live-vars = IntSet()

    ;Create an ELive instruction containing the set of all
    ;pending live variables. Doesn't do anything if there aren't any.
    defn emit-pending-live-vars () :
      if not empty?(pending-live-vars) :
        emit(buffer, ELive(to-tuple(seq(EVar,pending-live-vars))))
        clear(pending-live-vars)

    ;Scan through the instructions. If they're ELive
    ;instructions then add to the pending-live-vars set,
    ;otherwise emit the pending vars before emitting the original
    ;instruction.
    for i in ins(e) do :
      match(i:ELive) :
        add-all(pending-live-vars, seq(n, xs(i) as Tuple<EVar>))
      else :
        emit-pending-live-vars()
        emit(buffer, i)
    ;Emit any remaining live variables.
    emit-pending-live-vars()

    ;Return the new body
    to-body(buffer)

  ;Eliminate dead code in body.
  defn eliminate-in-item (e:ELBigItem, elim-vars:IntSet) -> ELBigItem :
    match(e:EBody) :
      val e* = consolidate-live-vars $
               eliminate-vars-in-body(e, elim-vars)
      map(eliminate-in-item{_, elim-vars}, e*)
    else :
      map(eliminate-in-item{_, elim-vars}, e)

  ;Launch!
  val texps* = for e in exps(epackage) map :
    val [defs, uses] = collect-defs-and-uses(e)
    val elim-vars = vars-to-eliminate(defs, uses)
    eliminate-in-item(e, elim-vars) as ETExp
  sub-exps(epackage, texps*)

;============================================================
;=================== RESOLVE MATCHES ========================
;============================================================
defn resolve-matches (epackage:EPackage, ehier:EHier, gvt:VarTable) -> EPackage :
  defn resolve-in-body (e:EBody, vt:VarTable) -> EBody :
    val ins* = for i in ins(e) map :
      match(i) :
        (i:EMatch) :
          if length(ys(i)) == 1 :
            val ys-type = type(vt, ys(i)[0])
            val combined-branch-type = union $ seq({types(_)[0]}, branches(i))
            val covered? = subtype?(ehier, ys-type, combined-branch-type)
            sub-covered?(i, covered?)
          else :
            i
        (i) : i
    sub-ins(e, ins*)
  defn resolve-texp (x:ETExp, vt:VarTable) :
    val result = let loop (x:ELBigItem = x) :
      match(map(loop, x)) :
        (e:EBody) : resolve-in-body(e,vt)
        (e) : e
    result as ETExp
  map-with-var-table(resolve-texp, gvt, epackage)

defn union (input-ts:Seqable<EType>) :
  val ts = to-seq(input-ts)
  if empty?(ts) : EBot()
  else : reduce(EOr, ts)

;============================================================
;===================== REMOVE-BOXES =========================
;============================================================
;Currently boxes are used to hold variables that are written to.
;In this pass, we remove boxes for those boxes that are only
;accessed locally in a single body, since the ELIR supports
;writing to local vars. This permits a number of follow-on
;optimizations to trigger as well.
defn remove-boxes (epackage:EPackage, gvt:VarTable) -> EPackage :

  ;Translate all local boxes and their accesses to operations
  ;on regular mutable variables.
  ;Assumes that all nested definitions have been analyzed.
  defn remove-local-boxes-in-body (e:EBody, vt:VarTable) -> EBody :
    ;Compute set of closed-over variables. If a box is closed-over
    ;then we cannot convert it to a local mutable variable.
    val closed-over = IntSet()
    defn add-to-closed (e:ELBigItem) :
      match(e:EFn) : add-all(closed-over, vars(free(e)))
      else : do*(add-to-closed, e)
    do(add-to-closed, cat(localfns(e), localobjs(e)))

    ;Compute set of variables that are read from instructions
    ;other than EBoxGet instructions.
    defn collect-non-box-reads (ins:EIns) -> Seqable<Int> :
      val imms = match(ins) :
        (ins:EBoxGet) : []
        (ins:EBoxSet) : [z(ins)]
        (ins) : uses(ins)
      seq(n, filter-by<EVar>(imms))
    val non-box-read = to-intset $
      seq-cat(collect-non-box-reads, ins(e))

    ;Collect all the definitions of all boxes.
    val box-defs = group-by(n{x(_)}, filter-by<EBox>(ins(e)))

    ;If the given variable corresponds to a locally defined
    ;box then return its initializing box expression. Otherwise
    ;return false.
    defn local-box? (n:Int) -> EBox|False :
      if not mutable?(vt,n) and
         not closed-over[n] and
         not non-box-read[n] and
         length(box-defs[n]) == 1 :
        head(box-defs[n])

    ;Remove operations on local boxes and replace them
    ;with the equivalent operation assuming the local box
    ;is now a regular mutable variable.
    defn remove-local-boxes (e:EIns) -> EIns :
      match(e) :
        (e:EBox) :
          match(local-box?(n(x(e)))) :
            (b:EBox) : EDef(x(e), y(b))
            (f:False) : e
        (e:EBoxGet) :
          match(local-box?(n(y(e) as EVar))) :
            (b:EBox) : EDef(x(e), y(e))
            (f:False) : e
        (e:EBoxSet) :
          match(local-box?(n(y(e) as EVar))) :
            (b:EBox) : EStore(EVarLoc(n(y(e) as EVar)), z(e), type(b), false)
            (f:False) : e
        (e) :
          e

    ;If the given local is initialized as a local box,
    ;then convert it to a regular mutable variable meant for holding
    ;the contents of the local box.
    defn convert-local-box-to-var (local:ELocal) -> ELocal :
      match(local-box?(n(local))) :
        (b:EBox) : ELocal(n(local), type(b), true)
        (f:False) : local

    ;Launch!
    val ins* = map(remove-local-boxes, ins(e))
    val locals* = map(convert-local-box-to-var, locals(e))
    sub-locals(sub-ins(e, ins*), locals*)

  ;Remove all local boxes in the given item.
  defn remove-boxes (e:ELBigItem, vt:VarTable) -> ELBigItem :
    match(map(remove-boxes{_, vt}, e)) :
      (e:EBody) : remove-local-boxes-in-body(e,vt)
      (e) : e

  ;Compute local VarTable and freevars for each
  ;top-level expression and then remove the local boxes.
  within (texp, vt) = map-with-var-table(gvt, epackage) :
    remove-boxes(analyze-freevars(texp, vt), vt) as ETExp

;============================================================
;==================== BOX-UNBOX-FOLD ========================
;============================================================

;------------------------------------------------------------
;-------------------- DefStructTable ------------------------
;------------------------------------------------------------

;Represents the struct information in the package.
deftype DefStructTable

;Returns true if the 'index' field of struct 'n' is mutable.
defmulti mutable-field? (t:DefStructTable, n:Int, index:Int) -> True|False

defn DefStructTable (epackage:EPackage) -> DefStructTable :
  ;Create table of all structs in package.
  val defstructs = filter-by<EDefStruct>(exps(epackage))
  val table = to-inttable<EDefStruct> $
    for e in defstructs seq: n(e) => e

  new DefStructTable :
    defmethod mutable-field? (this, n:Int, index:Int) :
      val struct = table[n]
      val fields = base(struct)
      fatal("Index out of bounds.") when index >= length(fields)
      val field = fields[index]
      mutable?(field)

;------------------------------------------------------------
;-------------------- Analysis ------------------------------
;------------------------------------------------------------

defn box-unbox-fold (epackage:EPackage, gvt:VarTable) -> EPackage :
  ;Compute defstruct table
  val defstruct-table = DefStructTable(epackage)

  ;Compute binding table.
  ;Every entry in the binding table, x => e, indicates that
  ;x is defined exactly once by the EObject, ENewObject, EPtr instruction.
  defn binding-table (e:EBody) -> IntTable<EObject|ENewObject|EPtr> :
    val table = IntListTable<EObject|ENewObject|EPtr>()
    val remove-set = IntSet()
    for i in ins(e) do :
      match(i:EObject|ENewObject|EPtr) : add(table, n(x(i)), i)
      else : do(add{remove-set, n(_)}, varlocs(i))
    to-inttable<EObject|ENewObject|EPtr> $
      for entry in table seq? :
        if remove-set[key(entry)] : None()
        else if length(value(entry)) == 1 : One(key(entry) => head(value(entry)))
        else : None()

  ;Returns true if the given value represents an immutable
  ;quantity.
  defn immutable? (vt:VarTable, value:EImm) -> True|False :
    match(value:EVar) : not mutable?(vt,n(value))
    else : true

  ;If the given ECall expression has type CallPtr, and calls a function
  ;that is known to be an EPtr of variable f, then return f.
  ;Calls fail() if not a match.
  defn unbox-call-ptr (e:ECall,
                       vt:VarTable,
                       bindings:IntTable<EObject|ENewObject|EPtr>) -> EVar :
    fail() when calltype(e) is-not CallPtr
    val v = f(e) as? EVar
    val p = get?(bindings, n(v)) as? EPtr
    val l = loc(p) as? EVarLoc
    EVar(n(l))

  ;If the given EObjectGet expression corresponds to retrieval
  ;of a known object field then return the destination and the
  ;field. Calls fail() if not a match.
  defn unbox-object-get (e:EObjectGet,
                         vt:VarTable,
                         bindings:IntTable<EObject|ENewObject|EPtr>) -> [EVarLoc, EImm] :
    val v = y(e) as? EVar
    val o = get?(bindings, n(v)) as? ENewObject

    ;Note that the existence of n(v) in the bindings table
    ;does not absolutely imply that the EObjectGet is wellformed.
    ;The EObjectGet may be in a context where n(v) is assumed to be
    ;of a certain type. Because of this we have to check whether
    ;the index is actually within bounds.
    val num-fields = length(ys(o))
    fail() when index(e) >= num-fields

    val value = ys(o)[index(e)]
    fail() when not immutable?(vt,value)
    [x(e), value]

  ;If the given ELoad expression corresponds to a retrieval
  ;of a known object field then return the destination and the field.
  ;Calls fail() if not a match.
  defn unbox-load (e:ELoad,
                   vt:VarTable,
                   bindings:IntTable<EObject|ENewObject|EPtr>) -> [EVarLoc, EImm] :
    val field = loc(e) as? EField
    val v = y(loc(field) as? EDeref) as? EVar
    val o = get?(bindings, n(v)) as? EObject

    ;See previous note in unbox-object-get.
    val num-fields = length(ys(o))
    fail() when index(field) >= num-fields

    fail() when mutable-field?(defstruct-table, n(o), index(field))
    val value = ys(o)[index(field)]
    fail() when not immutable?(vt,value)
    [x(e), value]

  ;Perform unboxing folds in the given body.
  ;Assumes that all nested bodies have already been folded.
  defn fold-in-body (e:EBody, vt:VarTable) -> EBody :
    ;Compute the binding table
    val bindings = binding-table(e)

    ;Attempt to fold the given instruction.
    defn fold? (i:EIns) -> EIns :
      match(i) :
        (i:EObjectGet) :
          attempt :
            val [x, v] = unbox-object-get(i, vt, bindings)
            EDef(x, v, false)
          else : i
        (i:ELoad) :
          attempt :
            val [x, v] = unbox-load(i, vt, bindings)
            EDef(x, v, false)
          else : i
        (i:ECall) :
          attempt :
            val f = unbox-call-ptr(i, vt, bindings)
            sub-calltype(sub-f(i, f), CallStanza())
          else : i
        (i) : i

    ;Attempt to fold all instructions.
    sub-ins(e, map(fold?, ins(e)))

  ;Fold all bodies in top-level expression.
  defn fold-texp (e:ETExp, vt:VarTable) -> ETExp :
    val result = let loop (e:ELBigItem = e) :
      match(map(loop, e)) :
        (e:EBody) : fold-in-body(e, vt)
        (e) : e
    result as ETExp

  ;Launch!
  map-with-var-table(fold-texp, gvt, epackage)

;============================================================
;=================== Closure Lifting ========================
;============================================================

defn lift-closures (epackage:EPackage, gvt:VarTable) -> EPackage :
  ;Track new top level expressions
  val new-texps = Vector<ETExp>()

  ;Lift the given function with the computed free vars to the top-level.
  ;- Use closure as the identifier of the closure argument.
  ;- Write a recursive function to compute translated EFn.
  ;  - For every EFn:
  ;    - Retrieve the free variables from closure argument
  ;    - Retrieve the type variables from closure argument
  ;    - Rename all instructions, input types, and output types
  ;- Construct EDefClosure expression and add to top level.
  ;- Returns the identifier used for the DefClosure expression.
  defn lift-to-defclosure (f:EFunction, fnfree:Free, vt:VarTable) -> Int :
    ;DefClosure identifier
    val fid = uniqueid()

    ;Closure argument
    val closure = uniqueid()

    ;Helper function for processing the body of an EFunction
    defn lift (e:ELBigItem) -> ELBigItem :
      match(e:EFn) :
        ;Track necessary renames
        val rename-table = IntTable<Int>()
        defn rename-var (v:Int) :
          val v* = uniqueid()
          rename-table[v] = v*
          v*

        ;Create buffer
        val buffer = BodyBuffer(body(e))

        ;Retrieve free variables from closure argument
        for v in vars(free(e)) do :
          val i = index-of(vars(fnfree), v)
          match(i:Int) :
            val v* = rename-var(v)
            val t = type(vt,v)
            emit(buffer, ELocal(v*, t, false))
            emit(buffer, EClosureGet(EVarLoc(v*), EVar(closure), fid, i))

        ;Retrieve type variables from closure argument
        for v in tvars(free(e)) do :
          val i = index-of!(tvars(fnfree), v)
          val v* = rename-var(v)
          emit(buffer, ELocalType(v*))
          emit(buffer, EClosureTGet(ETVarLoc(v*), EVar(closure), fid, i))

        ;Check that recursion has been done
        fatal("Closures not yet lifted!") when not empty?(localfns(body(e)))
        fatal("Objects not yet lifted!") when not empty?(localobjs(body(e)))

        ;Emit renamed body
        for i in ins(body(e)) do :
          emit(buffer, rename-vars+tvars(i,rename-table))

        ;Return new function
        defn remove-nonlocal-tvars (t:EType) -> EType :
          match(t:ETVar) : ETop() when key?(rename-table,n(t)) else t
          else : map(remove-nonlocal-tvars, t)
        fatal("TODO")
;        val a1* = map(remove-nonlocal-tvars, a1(e))
;        val a2* = rename-vars+tvars(a2(e), rename-table)
;        EFn(tail?(e), targs(e), args(e), a1*, a2*, to-body(buffer), info(e))
      else :
        map(lift, e)

    ;Construct EDefClosure and push to top level
    val ntargs = length(tvars(fnfree))
    val nargs = length(vars(fnfree))
    val func* = lift(f) as EFunction
    add(new-texps, EDefClosure(fid, closure, ntargs, nargs, func*))

    ;Return the DefClosure identifier
    fid

  ;Sweep through the body and lift out declarations of local functions
  ;- Lift each function to the top level
  ;- Sweep through instructions, and convert EInitClosures into ELetRec statements.
  ;  - Create each closure by looking up its freevars in free-table
  ;- Return new function
  ;  - The local functions are now empty, and moved over to local definitions
  ;  - Use the new instructions
  defn lift-body (e:EBody, vt:VarTable) :
    ;Track the freevars for each function
    val free-table = IntTable<Free>()

    ;Track the identifiers for each function
    val closureid-table = IntTable<Int>()

    ;Lift each function to the top level
    for f in localfns(e) do :
      ;Compute freevars
      val fnfree = match(func(f)) :
        (f:EFn) : free(f)
        (f:EMultifn) : join-free(seq(free, funcs(f)))
      free-table[n(f)] = fnfree
      ;Lift function
      closureid-table[n(f)] = lift-to-defclosure(func(f), fnfree, vt)

    ;Generate new instructions
    val buffer = BodyBuffer(e)
    for i in ins(e) do :
      match(i) :
        (i:EInitClosures) :
          val xs* = Vector<EVarLoc>()
          val closures* = Vector<EClosure>()
          for x in xs(i) do :
            val free = free-table[n(x)]
            val closureid = closureid-table[n(x)]
            if empty?(free):
              emit(buffer, EDef(x, EConstClosure(closureid)))
            else :
              val targs = map(ETVar, tvars(free))
              val ys = map(EVar, vars(free))
              add(xs*, x)
              add(closures*, EClosure(closureid, targs, ys))
            emit(buffer, ELocal(n(x), EOf(n(iotable(vt),CORE-FN-ID)), false))
          if not empty?(xs*) :
            emit(buffer, ELetRec(to-tuple(xs*), to-tuple(closures*), info(i)))
        (i) :
          emit(buffer, i)

    ;Return body
    to-body(buffer, true, false, true)

  defn analyze (e:ELBigItem, vt:VarTable) -> ELBigItem :
    match(map(analyze{_, vt},e)) :
      (e:EBody) : lift-body(e,vt)
      (e) : e
  val epackage* = within (texp, vt) = map-with-var-table(gvt, epackage) :
    val texp* = analyze-freevars(texp,vt)
    analyze(texp*, vt) as ETExp
  add-exps(epackage*, new-texps)

;============================================================
;=============== Force Remove Type Objects ==================
;============================================================

defn force-remove-types (epackage:EPackage) :
  defn remove-from (e:ELItem) :
    match(map(remove-from,e)) :
      ;Top-level expressions
      (e:EDefmulti) : sub-targs(e, [])
      ;Small expressions
      (e:EFn) : sub-targs(e, [])
      (e:ECurry) : x(e)
      (e:EMethod) : sub-targs(e, [])
      (e:ETVar) : ETop()
      ;Unexpected expressions
      (e:EDefClosure) : fatal("Unexpected")
      (e:EDefObject) : fatal("Unexpected")
      (e:ENewObject) : fatal("Unexpected")
      (e:EClosureTGet) : fatal("Unexpected")
      (e:EObjectTGet) : fatal("Unexpected")
      (e:EClosure) : fatal("Unexpected")
      (e:ETypeObject) : fatal("Unexpected")
      (e:EDefTypeObject) : fatal("Unexpected")
      ;Default
      (e) : e
  remove-from(epackage) as EPackage

;============================================================
;================= Lifting Type Objects =====================
;============================================================

defn lift-type-objects (epackage:EPackage) :
  ;Store lifted types
  val type-table = HashTable<EType,EDefTypeObject>()

  ;Lift a type to the top level
  ;Returns the id of the deftype object.
  defn lift-to-deftype-object (t:EType, nargs:Int) -> Int :
    if not key?(type-table,t) :
      val n = uniqueid()
      type-table[t] = EDefTypeObject(n, nargs, t)
    n(type-table[t])

  ;Reindex a type
  defn reindex (t:EType) -> [EType, Tuple<ETVar>] :
    val table = IntTable<Int>()
    val tvars = Vector<Int>()
    val t* = let loop (t:EType = t) :
      match(t:ETVar) :
        if not key?(table, n(t)) :
          val i = length(tvars)
          table[n(t)] = i
          add(tvars, n(t))
        ETVar(table[n(t)])
      else : map(loop, t)
    [normalize(t*), to-tuple(seq(ETVar,tvars))]

  ;Lift all first-class types in body
  defn lift-body (e:EBody) :
    val buffer = BodyBuffer(e)

    ;Reify a type
    defn reify-type (t:EType) -> ETVar :
      match(t) :
        (t:ETVar) :
          t
        (t) :
          val [t*, tvars] = reindex(t)
          val n = lift-to-deftype-object(t*, length(tvars))
          val x = uniqueid()
          emit(buffer, ELocalType(x))
          if empty?(tvars) :
            emit(buffer, ETDef(ETVarLoc(x), EConstType(n)))
          else :
            emit(buffer, ETypeObject(ETVarLoc(x), n, tvars))
          ETVar(x)
    defn reify-type (e:EImm) -> EImm :
      match(e) :
        (e:ECurry) : ECurry(x(e), map(reify-type,targs(e)))
        (e) : e
    defn reify-type (e:EClosure) :
      sub-targs(e, map(reify-type,targs(e)))

    ;Reify all type arguments in instructions
    for i in ins(e) do :
      emit{buffer, _} $ match(i) :
        (i:ECall|ETCall) : sub-f(i, reify-type(f(i)))
        (i:ELetRec) : sub-ys(i, map(reify-type,ys(i)))
        (i:ENewObject) : sub-targs(i, map(reify-type, targs(i)))
        (i:ECheckFail) : ECheckFail(reify-type(type(i)), y(i), ctxt(i), info(i))
        (i) : i

    ;Return new body
    to-body(buffer)

  ;Recursively lift all bodies
  defn analyze (e:ELBigItem) -> ELBigItem :
    match(map(analyze,e)) :
      (e:EBody) : lift-body(e)
      (e) : e
  sub-exps(epackage, exps*) where :
    val analyzed-exps = for e in exps(epackage) map :
      analyze(e) as ETExp
    val exps* = to-tuple(cat(analyzed-exps, values(type-table)))

;============================================================
;====================== Utilities ===========================
;============================================================

defn add-exps (ep:EPackage, exps*:Seqable<ETExp>) :
  sub-exps(ep, to-tuple(cat(exps(ep), exps*)))

;Join the sequence of Free structures.
defn join-free (fs:Seqable<Free>) :
  val var-set = IntSet()
  val tvar-set = IntSet()
  for f in fs do :
    add-all(var-set, vars(f))
    add-all(tvar-set, tvars(f))
  Free(to-tuple(var-set), to-tuple(tvar-set))

;Compute a local var table for each top level definition.
;- f: Called on each top-level expression with the analyzed VarTable for that expression.
;- gvt: The global VarTable.
;- epackage: The package to analyze.
;Returns the new analyzed package.
defn map-with-var-table (f:(ETExp, VarTable) -> ETExp, gvt:VarTable, epackage:EPackage) -> EPackage :
  val exps* = for e in exps(epackage) map :
    f(e, LocalVarTable(gvt, e))
  sub-exps(epackage, exps*)

;Rename all variables and type variables
defn rename-vars+tvars<?T> (e:ELItem&?T, table:IntTable<Int>) -> T :
  defn rename (e:ELItem) :
    defn f (x:Int) : get?(table, x, x)
    match(map(rename,e)) :
      (e:EDefClosure) : EDefClosure(n(e), f(closure(e)), ntargs(e), nargs(e), func(e))
      (e:EDefmulti) : EDefmulti(n(e), map(f,targs(e)), a1-args(e), a2(e), num-non-dispatch(e), info(e))
      (e:EFn) : EFn(tail?(e), map(f,targs(e)), map(f,args(e)), a1-args(e), a2(e), body(e), info(e), free?(e))
      (e:EMethod) : EMethod(n(e), multi(e), targs(e), f(thisn(e)), func(e))
      (e:EVar) : EVar(f(n(e)))
      (e:EVarLoc) : EVarLoc(f(n(e)))
      (e:ETVar) : ETVar(f(n(e)))
      (e:ETVarLoc) : ETVarLoc(f(n(e)))
      (e) : e
  rename(e) as ELItem&T

;Check whether type has type variable
defn has-tvar? (t:EType) :
  var tvar? = false
  let loop (t:EType = t) :
    match(t:ETVar) : tvar? = true
    else : do*(loop, t)
  tvar?

defn select<?T> (xs:Tuple<?T>, mask:Tuple<True|False>) -> Tuple<T> :
  to-tuple(filter(xs, mask))

;============================================================
;===================== Small Utilities ======================
;============================================================

;Shorthand for calling 'repeatedly'.
defn times<?T> (n:Int, f:() -> ?T) -> Tuple<T> :
  to-tuple(repeatedly(f,n))