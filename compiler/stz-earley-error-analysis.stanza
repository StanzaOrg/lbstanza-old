defpackage stz/earley-error-analysis :
  import core
  import collections
  import stz/earley-errors
  import stz/earley-eitems
  import stz/earley-grammar
  import stz/earley-sexp-stream

;============================================================
;=================== Datastructures =========================
;============================================================

public defstruct MissingInput :
  input
  set-index: Int
  info: FileInfo|False
  items: Tuple<EItem>

;============================================================
;==================== Error Creation ========================
;============================================================

defn prune-nondescriptive-items (g:Grammar, items:Tuple<EItem>) -> Tuple<EItem> :
  ;For any completed productions, compute the
  ;earliest position that those productions began.
  val start-of-completed-productions = IntTable<Int>()
  defn compute-start-of-completed-productions () :
    defn completed? (item:EItem) :
      upcoming(item) is False
    for item in filter(completed?, items) do :
      val prod = production(item)
      start-of-completed-productions[prod] =
        match(get?(start-of-completed-productions, prod)) :
          (p:Int) : min(parent(item), p)
          (f:False) : parent(item)

  ;Classify an item as descriptive or not.
  defn descriptive? (item:EItem) -> True|False :
    defn error? () :
      /error?(item)
    defn completed? () :
      val prod = production(item)
      match(get?(start-of-completed-productions,prod)) :
        (p:Int) : p <= parent(item)
        (f:False) : false
    defn complete? () :
      upcoming(item) is False
    defn predicted? () :
      num-parsed(item) == 0
    not (error?() or
         completed?() or
         complete?() or
         predicted?())

  ;Launch!
  compute-start-of-completed-productions()
  to-tuple(filter(descriptive?, items))

defn to-exception (g:Grammar, m:MissingInput) -> Maybe<MissingInputError> :
  val items* = prune-nondescriptive-items(g, items(m))
  ;Return None() if no items remaining.
  if empty?(items*) :
    None()
  else :
    defn get-production (item:EItem) : production(item)
    defn get-upcoming (item:EItem) : upcoming(item) as GToken
    val prods = to-intset(seq(get-production, items*))
    val tokens = to-hashset<GToken>(seq(get-upcoming, items*))
    One $ MissingInputError(
      input(m), info(m),
      to-tuple(prods), qsort(tokens))    

public defn to-exception (g:Grammar, input-ms:Collection<MissingInput>) :  
  EarleySyntaxErrors $ to-tuple $ seq?(to-exception{g, _}, input-ms)

