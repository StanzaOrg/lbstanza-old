defpackage stz/type2 :
  import core
  import collections
  import stz/il-ir
  import stz/il-to-tl
  import stz/tl-ir2
  import stz/dl-ir
  import stz/tl-to-dl2
  import stz/type-errors
  import stz/tl-formatter
  import stz/type-gen-equations
  import stz/type-equation-solver
  import stz/type-fill
  import stz/tl-guards

;============================================================
;====================== Typing Environment ==================
;============================================================

;Represents the type definitions from non-source-defined packages.
public deftype Env

;Return the publicly visible exports from a package.
;Used to retrieve the definitions from packages that are not
;defined directly in source as an IPackage.
public defmulti exports (e:Env, package:Symbol) -> PackageExports

;============================================================
;====================== Main Entrypoint =====================
;============================================================

public defn type-program (ipackages:Tuple<IPackage>,
                          environment:Env) -> TProg|TypeErrors :
  ;Return TypeErrors if necessary.
  label<TProg|TypeErrors> return :

    ;Gather all the exports from the environment.
    val exports = gather-exports(ipackages, environment)

    ;Convert the input packages to a typed program.
    val tprog = match(to-tl(ipackages, exports)) :
      (prog:TProg) : prog
      (err:TypeErrors) : return(err)

    ;Debugging
    println(format(tprog))

    ;Generating type equations
    val [tprog-with-vars, type-eqns] = generate-type-equations(tprog)

    ;Solving type equations.
    set-debug-formatter(TLFormatter(tprog-with-vars))
    val solver = SolverState(type-eqns, hierarchy(tprog-with-vars))
    solve(solver)

    ;Now that they are solved, fill in the
    ;program with the solutions.
    val tprog-solved = fill-solution(tprog-with-vars, solver)
    println(format(tprog-solved))

    ;Sanity check: Ensure TProg satisfies Solved invariants.
    guard!(tprog-solved, SolvedTL)

    ;Return solved tprog with the PackageIO filled.
    compute-packageios(tprog-solved)

;============================================================
;============= Gather Exports from Environment ==============
;============================================================

;Gather the exports from non-source-defined packages.
defn gather-exports (ipackages:Tuple<IPackage>, env:Env) -> Tuple<Export> :
  ;Initialize set with all source-defined packages.
  val defined-packages = to-hashset<Symbol>(seq(name, ipackages))

  ;Include the exports for all the imported packages
  val export-accum = Vector<Export>()

  ;Add exports from 'p' to 'export-accum' if it hasn't
  ;already been added.
  defn include-package (p:Symbol) -> False :
    if add(defined-packages, p) :
      include-package(exports(env,p))

  ;Add the given exports, and all its transitive
  ;imports to 'export-accum'.
  defn include-package (pex:PackageExports) -> False :
    add-all(export-accum, exports(pex))
    do(include-package, imported-packages(pex))

  ;Include all imports from packages.
  for p in ipackages do :
    do(include-package{package(_)}, imports(p))

  ;Always include the 'core' package.
  include-package(`core)

  ;Return the accumulated exports.
  to-tuple(export-accum)