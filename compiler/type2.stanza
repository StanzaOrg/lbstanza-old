defpackage stz/type2 :
  import core
  import collections
  import stz/il-ir
  import stz/il-to-tl
  import stz/tl-ir2
  import stz/dl-ir
  import stz/type-errors
  import stz/tl-formatter
  import stz/type-gen-equations

;============================================================
;====================== Typing Environment ==================
;============================================================

;Represents the type definitions from non-source-defined packages.
public deftype Env

;Return the publicly visible exports from a package.
;Used to retrieve the definitions from packages that are not
;defined directly in source as an IPackage.
public defmulti exports (e:Env, package:Symbol) -> PackageExports

;============================================================
;====================== Main Entrypoint =====================
;============================================================

public defn type-program (ipackages:Tuple<IPackage>,
                          environment:Env) -> TProg|TypeErrors :
  ;Return TypeErrors if necessary.
  label<TProg|TypeErrors> return :

    ;Gather all the exports from the environment.
    val exports = gather-exports(ipackages, environment)

    ;Convert the input packages to a typed program.
    val tprog = match(to-tl(ipackages, exports)) :
      (prog:TProg) : prog
      (err:TypeErrors) : return(err)

    ;Debugging
    println(format(tprog))

    ;Generating type equations
    generate-type-equations(tprog)
      

    fatal("STOP HERE")

;============================================================
;============= Gather Exports from Environment ==============
;============================================================

;Gather the exports from non-source-defined packages.
defn gather-exports (ipackages:Tuple<IPackage>, env:Env) -> Tuple<Export> :
  ;Initialize set with all source-defined packages.
  val defined-packages = to-hashset<Symbol>(seq(name, ipackages))

  ;Include the exports for all the imported packages
  val export-accum = Vector<Export>()

  ;Add exports from 'p' to 'export-accum' if it hasn't
  ;already been added.
  defn include-package (p:Symbol) -> False :
    if add(defined-packages, p) :
      include-package(exports(env,p))

  ;Add the given exports, and all its transitive
  ;imports to 'export-accum'.
  defn include-package (pex:PackageExports) -> False :
    add-all(export-accum, exports(pex))
    do(include-package, imported-packages(pex))

  ;Include all imports from packages.
  for p in ipackages do :
    do(include-package{package(_)}, imports(p))

  ;Always include the 'core' package.
  include-package(`core)

  ;Return the accumulated exports.
  to-tuple(export-accum)