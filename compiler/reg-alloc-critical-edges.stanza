defpackage stz/reg-alloc-critical-edges :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-block

;Add additional blocks such that there are no critical
;edges remaining.
public defn remove-critical-edges (blocks:Vector<Block>) -> False :
  ;Helper: Replace an element within a tuple.
  defn replace-element (xs:Tuple<Int>, old-x:Int, new-x:Int) -> Tuple<Int> :
    for x in xs map :
      new-x when x == old-x else x

  ;Create a safe block between the given pred and succ blocks.
  defn make-safe-block (pred:Int, succ:Int) -> False :
    val pred-block = blocks[pred]
    val succ-block = blocks[succ]
    val safe-block = Block(length(blocks), ;index
                           0,              ;start
                           0,              ;length
                           [succ],         ;succs
                           [pred],         ;preds
                           true)           ;ends-with-goto?
    ;Mutate the blocks vector.
    ;- Add the new safe block.
    ;- Change the successor list of the pred block.
    ;- Change the predecessor list of the succ block.
    add(blocks, safe-block)
    set-succs(pred-block, replace-element(succs(pred-block), succ, index(safe-block)))
    set-preds(succ-block, replace-element(preds(succ-block), pred, index(safe-block)))

  ;Loop through existing blocks only.
  val nblocks = length(blocks)
  for i in 0 to nblocks do :
  
    ;Retrieve the i'th block.
    val block = blocks[i]
    
    ;Principle: If the block has multiple successors, then none of
    ;those successors are allowed to have multiple predecessors.
    if length(succs(block)) > 1 :
      for succ in succs(block) do :
        val succ-block = blocks[succ]
        ;Case: Violation of principle. Generate safe block to act
        ;as replacement for successor.
        if length(preds(succ-block)) > 1 :
          make-safe-block(i, succ)