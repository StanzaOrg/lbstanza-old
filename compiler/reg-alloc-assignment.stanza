defpackage stz/reg-alloc-assignment :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-engine
  import stz/reg-alloc-block-engine
  import stz/reg-alloc-shuffle
  import stz/reg-alloc-datastructures
  import stz/printing-utils

;<doc>=======================================================
;======================= Algorithm ==========================
;============================================================

Sweep through the instructions in forward order:

Keep a table mapping variables to assigned registers.

Keep a scratch array mapping temporaries to assigned registers.

Keep a table indicating which variables are saved.

Processing the input ports:

Each input port contains an optional 'pref-reg' field that indicates
which register it prefers to be in. For the ports that prefer to be
loaded, and have preferred registers, and where the registers are
free, assign the variable to those registers. Then, afterwards, assign
arbitrary remaining registers to the remaining variables. Use sanity
checks to ensure that the allocation pass guaranteed there are exactly
enough registers.

Processing OperationStmt:

For the operations, we have to choose registers for:
- Arguments
- Temporaries
- Results

Note that we need to choose registers for the arguments first,
and then we need to interpret the model itself. The model
will indicate when registers are released, and when registers
are assigned. The model statements of interest are: Release,
Assign, ClearRegisters.

By the end of the operation, the result registers will have
been assigned, and we can record the final assignment, and
emit an AssignedOperationStmt.

For each of the results, indicate that they are no longer
saved so that the save table remains up-to-date.

Processing Save:

Record this in the table so that we can use this information
in the shuffling engine.

Processing Load:

Retrieve the preferred register for the load. Use a sanity
check to ensure that the variable hasn't already been loaded.
Then assign the register to the variable.

Processing Unload:

Remove the assignment for the given variable. Use a sanity
check to ensure that the variable was actually assigned.

# Algorithm For Assigning Registers Before Operation #

## Input ##

- The list of free registers.
- For each argument, what register it is in.

## Step: Identify Swap Registers ##

For the shuffling engine, we may need swap registers. Identify
one free integer register and one free floating register
right now before we begin. They will be used later.

## Step: Reserve Registers ##

Reserve all of the concrete output registers right now.

(If it's a ClearRegisters operation, then only reserve
 the concrete temporary registers.)

Reserve (using the reserved-input set) all of the concrete input
registers right now.

## Step: Processing the input arguments ##

For each argument, the following cases apply:

Case: Desired register.
  Case: Current register == Desired register.
    Do nothing.
  Case: Current register != Desired register.
    Evict.
Case: No Desired Register.
  Case: Killed Arg.
    Evict if current register is a reserved input register.  
  Case: Live Arg.
    Evict if current register is a reserved input or output register.
    
For each temporary/output register, suppose the register is presently occupied:

Case: Occupied by Arg.
  Case: Killed Arg.
    Do nothing. Leave for model to handle.
  Case: Live Arg.
    Evict.
Case: Occupied by Var.
  Evict.

Based upon the above, we can derive this loop:

Loop through each argument:
  Case: Desired register.
    if current register != desired register:
      unassign variable from current register.
      evict occupant of desired register.
      assign variable to desired register.

## Step: Processing the model statements ##

Case: Assign concrete register. Register is free.

  Assign this register to the value. Register is now no longer free.

Case: Assign concrete register. Register is not free.

  Evict the current occupant.
  Assign this register to the value. 

Case: Assign arbitrary register.

  Choose a non-reserved register.
  Follow preferences.
  Assign this register to the value.

Case: Release argument. Argument is in register.

  Unassign variable.
  Record the register for the argument.

Case: Release argument. Argument is not in register.

  Choose a non-reserved-input register.
  Record the register for the argument.
  Remove this from the evicted list.
  Add this move to the shuffle.

## Step: Relocating current occupants ##

Some existing variables have been evicted to make space for required registers.

For each of these, we can now choose a free register for each one.

## Step: Performing the shuffle ##

The inputs to the shuffle are:
- All of the argument variables.
- All of the live relocated variables.
- The free registers are the ones identified at the beginning of the process.

;============================================================
;=======================================================<doc>

public defn assign-registers (e:BlockEngine,
                              assignment-table:AssignmentTable) :
  fatal("Not yet implemented")
  ;<comment>
  within (i, stmt, emit) = process-instructions(e) :
    match(stmt) :

      ;Processing an operation statement.
      (stmt:AnnotatedOperationStmt) :
      
        ;Step: Preemptively identify swap registers
        val swap-reg = free-register(assignment-table, AnyReg(), true, true)
        val swap-freg = free-register(assignment-table, AnyFReg(), true, true)

        ;Step: Reserve input/output registers.
        clear-reserved(assignment-table)
        clear-reserved-input(assignment-table)
        for r in temp-registers(e,stmt) do :
          match(r:Reg|FReg) :
            mark-reserved(assignment-table, r)
        if not clears-registers?(e,stmt) :
          for r in result-registers(e,stmt) do :
            match(r:Reg|FReg) :
              mark-reserved(assignment-table, r)
        for r in arg-registers(e,stmt) do :
          match(r:Reg|FReg) :
            mark-reserved-input(assignment-table, r)

        ;Step: Processing the input arguments.
        for (v in args(stmt), reg in arg-registers(e,stmt)) do :
          match(reg:Reg|FReg) :
            val current-reg = assignment-table[v]
            if current-reg != reg :
              unassign(assignment-table, v)
              evict?(assignment-table, reg)
              assign(assignment-table, v, reg)
              assign-arg(assignment-table, v, reg)

        ;Helper: Prepare to assign a location to a result or temporary.
        ;Returns the final register to assign to the result/temporary.
        ;- loc: The location to assign.
        ;- pref: Any preference on the final assigned register.
        defn prepare-assignment-location (loc:Location, pref:Preference) -> Reg|FReg :
          match(loc) :
            (reg:Reg|FReg) :
              evict?(assignment-table, reg)
              reg
            ;Case: Assign an abitrary register.
            (loc:AnyReg|AnyFReg) :
              ;Find a non-reserved register.
              free-register(assignment-table, loc, false, true)        
                
        ;Step: Process the model statements.
        process-model{_, e ,stmt} $ new ModelProcessor :
        
          ;Processing an assignment statement to a variable.
          defmethod assign (this, v:Int, loc:Location, pref:Preference) :
            val reg = prepare-assignment-location(loc, pref)
            assign(assignment-table, v, reg)
                
          ;Processing an assignment statement to a temporary variable.
          defmethod assign-temp (this, temp:Int, loc:Location, pref:Preference) :
            val reg = prepare-assignment-location(loc, pref)
            assign-temp(assignment-table, temp, reg)
                
          ;Processing a release statement.
          defmethod release (this, v:Int) :
            match(get?(assignment-table,v)) :
              ;Case: This register is safe to be kept for use by this argument.
              (r:Reg|FReg) :
                unassign(assignment-table, v, r)
                assign-arg(assignment-table, v, r)
              ;Case: Argument was unassigned. The register it was originally
              ;in was required by one of the outputs.
              (f:False) :
                ;Find a non-reserved-input register.
                val reg = free-register(assignment-table, loc, true, false)
                mark-reserved-input(assignment-table, reg)
                assign-arg(assignment-table, v, reg)

          ;Processing a clear registers statement.
          defmethod clear-registers (this) :
            ;[TODO] Unassign all the registers.
            ;[TODO] Reserve only the output registers again. (Ignoring the temp).
            fatal("Not sure about this.")

        ;Step: Relocating the displaced variables.
        val shuffle = Vector<[Int, Reg|FReg, Reg|FReg]>()
        within (v, old-reg, new-reg) = evicted(assignment-table) :
          match(new-reg:Reg|FReg) :
            add(shuffle, [v, old-reg, new-reg])
          else :
            ;Find a non-reserved-input register.
            val new-reg = free-register(assignment-table, old-reg, true, false)
            assign(assignment-table, v, new-reg)
            add(shuffle, [v, old-reg, new-reg])
            
        ;Step: Performing the shuffle.
        println("SHUFFLE%_" % [colon-field-list(shuffle)])        
  ;<comment>  
;<comment>
  ;----------------------------------------------------------
  ;-------------------- State Tables ------------------------
  ;----------------------------------------------------------

  ;Holds which registers are currently assigned to each
  ;variable.
  val register-table = IntTable<Reg|FReg>()

  ;Holds which registers are currently assigned to the
  ;temp variables.
  val temp-table = Vector<Reg|FReg|False>()

  ;----------------------------------------------------------
  ;-------------------- Main Algorithm ----------------------
  ;----------------------------------------------------------

  ;Process the input ports.
  ;First assign registers for all the ports with preferred registers.
  val unassigned = Vector<Port>()
  for p in inputs(e) do :
    if loaded?(p) :
      println("Port %_ is loaded" % [id(p)])
      match(pref-reg(p)) :
        (r:Reg|FReg) :
          println("Port prefers register %_" % [r])
          if free-register?(r) :
            println("Assign register %_" % [r])
            assign-register(id(p), r)
          else :
            add(unassigned, p)
        (f:False) :
          println("Port has no preferred register.")
          add(unassigned, p)
  ;Next assign arbitrary registers to remaining ports.
  while not empty?(unassigned) :
    val p = pop(unassigned)
    val r = free-register(register-category(p))
    assign-register(id(p), r)

  ;Print the currently assigned registers.
  print-register-table()

  ;Record the final registers that were assigned.
  val new-input-ports = to-tuple $ for p in inputs(e) seq :
    sub-assigned-reg(p, register-table[id(p)])
  set-contents(inputs(e), new-input-ports)

  ;Print the new input ports.
  println("New input ports%_" % [colon-field-list(inputs(e))])

  ;Scan through the instructions.
  within (i, stmt, emit) = process-instructions(e) :
    println("Process: %_" % [stmt])
    match(stmt) :
      (stmt:AnnotatedOperationStmt) :
        ;Initialize temp registers to initially unassigned.
        clear(temp-table)
        lengthen(temp-table, num-temp(e,stmt), false)

        ;Retrieve:
        ;- args: The argument variables to the operation.
        ;- arg-input-regs: The registers they are currently in.
        ;- arg-output-regs: The locations they need to be in.
        ;And determine whether a straightforward assignment
        ;will work.
        val args = args(stmt)
        val arg-input-regs = map({register-table[_]}, args)
        val arg-output-regs = arg-registers(e, stmt)

        ;Perform what is necessary to move arguments to the
        ;right registers. And get final position of arguments.
        val arg-final-regs = match(needs-shuffle?(arg-input-regs, arg-output-regs)) :
          (status:AlreadyInPosition) :
            arg-input-regs
          (status:UseNaiveMoves) :
            fatal("Not yet implemented")
          (status:UseShuffle) :
            fatal("Not yet implemented")

        ;Now process each of the model statements.
        process-model{_, e, stmt} $ new ModelProcessor :
          defmethod release-temp (this, index:Int) :
            ;Sanity check: Ensure that the temporary was assigned.
            if temp-table[index] is False :
              fatal("Temporary %_ was not assigned." % [index])
            ;Remove the assigned register from the temporary.
            temp-table[index] = false
          defmethod release (this, v:Int) :
            ;Sanity check: Ensure that the variable was assigned.
            if not key?(register-table, v) :
              fatal("Variable V%_ was not assigned." % [v])
            ;Remove the assigned register from that variable.
            remove(register-table, v)
            false
          defmethod assign-temp (this, index:Int, loc:Location, pref:Preference) :
            fatal("Not yet implemented")
;            ;Retrieve the most appropriate register
;            ;[TODO] We need a taboo list so that temporary variables
;            ;that can be assigned anywhere don't get assigned to registers
;            ;that are required by other temporaries.
;            val reg = free-register(loc)
;            ;If it is free, then we can just assign it.
;            if free-register?(reg) :
;              temp-table[index] = reg
;            ;Otherwise, we have to relocate the old contents.
;            else :
;              ;Retrieve the variable that is currently in that register.
;              val v = var-in-register(reg)
;
;              ;Retrieve a fresh free register to relocate the variable to.
;              val new-reg = free-register(generalize(loc))
;              
;              ;Relocate the old contents to there.
;              emit(Relocate(v, reg, new-reg))
;              register-table[v] = new-reg
;
;              ;Now the old register is free to be used
;              ;for the temporary.
;              temp-table[index] = reg            

          defmethod assign (this, id:Int, loc:Location, pref:Preference) :
            fatal("Not yet implemented")
;            ;Retrieve the most appropriate register.
;            ;[TODO] We need a taboo list so that result variables
;            ;that can be assigned anywhere don't get assigned to registers
;            ;that are required by other results.
;            val reg = free-register(loc)
;            ;If it is free, then we can just assign it.
;            if free-register?(reg) :
;              register-table[id] = reg
;            ;Otherwise, we have to relocate the old contents.
;            else :
;              ;Retrieve the variable that is currently in that register.
;              val v = var-in-register(reg)
;
;              ;Retrieve a fresh free register to relocate the variable to.
;              val new-reg = free-register(generalize(loc))
;              
;              ;Relocate the old contents to there.
;              emit(Relocate(v, reg, new-reg))
;              var-in-register[v] = new-reg
;
;              ;Now the old register is free to be used
;              ;for the temporary.
;              register-table[id] = reg

            false


          defmethod clear-registers (this) :
            false

      (stmt:Save) :
        false
      (stmt:Unload) :
        ;Sanity check: Ensure that the variable is assigned.
        if not key?(register-table, arg(stmt)) :
          fatal("Variable V%_ is not assigned." % [arg(stmt)])
        ;Remove the assigned register from that variable.
        remove(register-table, arg(stmt))
      (stmt:Load) :
        false

;------------------------------------------------------------
;--------------------- Process a Model ----------------------
;------------------------------------------------------------

;Callbacks for processing the different actions of a model.
deftype ModelProcessor

;Release the temporary at index 'index'.
defmulti release-temp (proc:ModelProcessor, index:Int) -> False

;Release the variable register.
defmulti release (proc:ModelProcessor, id:Int) -> False

;Assign the temporary at index 'index'.
defmulti assign-temp (proc:ModelProcessor, index:Int, loc:Location, pref:Preference) -> False

;Assign the variable with id 'id'.
defmulti assign (proc:ModelProcessor, id:Int, loc:Location, pref:Preference) -> False

;Clear all of the registers.
defmulti clear-registers (proc:ModelProcessor) -> False

defn process-model (proc:ModelProcessor,
                    e:BlockEngine,
                    anno-stmt:AnnotatedOperationStmt) -> False :
  ;Retrieve the model.
  val op-stmt = stmt(anno-stmt)
  val model = models(e)[op-id(op-stmt)]

  ;Retrieve the index ranges of the different variables.
  val first-temp = length(results(model)) + length(args(model))
  val first-arg = length(results(model))
  val num-vars = length(results(model)) + length(args(model)) + length(temp(model))

  ;Return true if the given variable is a temp variable.
  defn temp? (v:Int) : v >= first-temp and v < num-vars

  ;Return true if the given variable is an arg variable.
  defn arg? (v:Int) : v >= first-arg and v < first-temp

  ;Return true if the given variable is a result variable.
  defn result? (v:Int) : v >= 0 and v < first-arg

  ;Return true if arg at index 'i' is killed in this
  ;operation.
  defn arg-killed? (i:Int) -> True|False :
    contains?(killed-args(anno-stmt), i)

  ;Return the id of the global argument variable at index 'i'.
  defn arg-var (i:Int) -> Int :
    args(op-stmt)[i]

  ;Return the id of the global result variable at index 'i'.
  defn result-var (i:Int) -> Int :
    results(op-stmt)[i]

  ;Return the index of the temp variable.
  defn temp-index (v:Int) : v - first-temp

  ;Return the index of the arg variable.
  defn arg-index (v:Int) : v - first-arg

  ;Return the index of the result variable.
  defn result-index (v:Int) : v

  ;Return true if the model calls clear-registers.
  defn model-clears-registers? () -> True|False :
    val props = model-properties(e)[op-id(op-stmt)]
    clears-registers?(props)

  ;Analyze the given preference, and update it
  ;to reflect the global variable ids.
  defn analyze (pref:Preference) -> Preference :
    match(pref:PreferSame) :
      if temp?(arg(pref)) :
        PreferSameAsTemp(temp-index(arg(pref)))
      else if arg?(arg(pref)) :
        val i = arg-index(arg(pref))
        PreferSame(arg-var(i))
      else :
        fatal("Invalid preference: %_" % [pref])
    else :
      pref

  ;Iterate through each statement and call
  ;the appropriate callbacks.
  for mstmt in stmts(model) do :
    match(mstmt) :
      (mstmt:Release) :
        if temp?(arg(mstmt)) :
          release-temp(proc, temp-index(arg(mstmt)))
        else :
          val i = arg-index(arg(mstmt))
          release(proc, arg-var(i)) when arg-killed?(i)
      (mstmt:Assign) :
        if temp?(arg(mstmt)) :
          assign-temp(proc,
                      temp-index(arg(mstmt)),
                      location(mstmt),
                      analyze(preference(mstmt)))
        else if arg?(arg(mstmt)) :
          val i = arg-index(arg(mstmt))
          assign(proc,
                 arg-var(i),
                 location(mstmt),
                 analyze(preference(mstmt)))
        else if result?(arg(mstmt)) :
          val i = result-index(arg(mstmt))
          assign(proc,
                 result-var(i),
                 location(mstmt),
                 analyze(preference(mstmt)))
        else :
          fatal("Invalid variable: V%_" % [arg(mstmt)])
      (mstmt:ClearRegisters) :
        clear-registers(proc)
      (mstmt:Return) :
        false

  ;Finish by releasing any other temp/arg variables,
  ;that hasn't explicitly been released.
  if not model-clears-registers?() :
    ;Compute all that has been released.
    val all-released = to-intset $
      seq(arg, filter-by<Release>(stmts(model)))

    ;Release any other temp that hasn't yet been released.
    for v in temp(model) do :
      if not all-released[v] :
        release-temp(proc, temp-index(v))

    ;Release any other killed arguments that hasn't already been
    ;released.
    for v in seq(id,args(model)) do :
      if not all-released[v] :
        val i = arg-index(v)
        release(proc, v) when arg-killed?(i)

;Prefer to be same as the temp for the operation.
defstruct PreferSameAsTemp <: Preference :
  index:Int

;------------------------------------------------------------
;--------------------- Utilities ----------------------------
;------------------------------------------------------------

;Returns true if the given port is loaded into a register.
defn loaded? (p:Port) -> True|False :
  val s = status(p) as PortStatus
  loaded(s) is Location

;Returns the register category that a port is in.
defn register-category (p:Port) -> AnyReg|AnyFReg :
  val s = status(p) as PortStatus
  loaded(s) as AnyReg|AnyFReg

;Fill in the final assigned register for the given port.
defn sub-assigned-reg (p:Port, r:Reg|FReg) -> Port :
  val s = status(p) as PortStatus
  val new-status = sub-loaded(s, r)
  sub-status(p, new-status)

;Helper: Set the contents of the given vector.
defn set-contents<?T> (vs:Vector<?T>, xs:Seqable<T>) :
  clear(vs)
  add-all(vs,xs)

;Return the argument variables to the operation.
defn args (op:AnnotatedOperationStmt) -> Tuple<Int> :
  args(stmt(op))

;Helper: Return the registers that the arguments are required
;to be in.
defn arg-registers (e:BlockEngine, op:AnnotatedOperationStmt) -> Tuple<Location> :
  val m = models(e)[op-id(stmt(op))]
  map(location, args(m))

;Helper: Return the number of temporary variables this
;operation has.
defn num-temp (e:BlockEngine, op:AnnotatedOperationStmt) -> Int :
  val m = models(e)[op-id(stmt(op))]
  length(temp(m))

;<comment>

;============================================================
;==================== Assignment Table ======================
;============================================================

public deftype AssignmentTable

;Record that the given variable has been saved.
;The shuffling engine needs to know which variables are saved so that
;it doesn't emit extraneous Save statements.
public defmulti set-saved (t:AssignmentTable, v:Int, s:True|False) -> False

;Return whether the variable has been saved.
public defmulti saved? (t:AssignmentTable, v:Int) -> True|False

;Assign the given register to the given variable.
;Condition: r must not be assigned already.
public defmulti assign (t:AssignmentTable, v:Int, r:Reg|FReg) -> False

;Unassign the variable, such that it doesn't hold any register.
;Condition: v must have an assigned register.
public defmulti unassign (t:AssignmentTable, v:Int) -> False

;Retrieve the register that the variable is assigned to (if any).
public defmulti get? (t:AssignmentTable, v:Int) -> Reg|FReg|False

;Retrieve the variable that the given register is assigned to (if any).
public defmulti get? (t:AssignmentTable, r:Reg|FReg) -> Int|False

;Retrieve a free register of the following type.
;Used for:
;- Identifying swap registers.
;Arguments:
;- category: The type of register that is desired.
;- allow-reserved?: If false, then registers that are marked as reserved
;  are not considered.
;- allow-reserved-input?: If false, then registers that are marked in the
;  reserved-input set are not considered.
public defmulti free-register (t:AssignmentTable,
                               category:AnyReg|AnyFReg,
                               allow-reserved?:True|False,
                               allow-reserved-input?:True|False) -> Reg|FReg

;Mark and clear the reserved register set.
;Used in free-register calculation when selecting registers for output variables.
public defmulti clear-reserved (t:AssignmentTable) -> False
public defmulti mark-reserved (t:AssignmentTable, r:Reg|FReg) -> True|False

;Mark and clear the reserved-input register set.
;Used in free-register calculation when selecting registers for input variables.
public defmulti clear-reserved-input (t:AssignmentTable) -> False
public defmulti mark-reserved-input (t:AssignmentTable, r:Reg|FReg) -> False

;Record the registers that were ultimately chosen for an operation statement.
public defmulti record-arg-register (t:AssignmentTable, arg-index:Int, r:Reg|FReg) -> False
public defmulti record-temp-register (t:AssignmentTable, temp-index:Int, r:Reg|FReg) -> False
public defmulti record-result-register (t:AssignmentTable, result-index:Int, r:Reg|FReg) -> False

public defn AssignmentTable (resources:ResourceProvider) :
  fatal("Not yet implemented")
;  ;Hold which registers each variable is assigned to.
;  ;e.g. V0 => R0
;  val 