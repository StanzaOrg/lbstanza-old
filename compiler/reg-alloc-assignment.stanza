defpackage stz/reg-alloc-assignment :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-engine
  import stz/reg-alloc-block-engine
  import stz/reg-alloc-shuffle
  import stz/reg-alloc-datastructures
  import stz/reg-alloc-assignment-table
  import stz/printing-utils

;<doc>=======================================================
;======================= Algorithm ==========================
;============================================================

Sweep through the instructions in forward order:

Keep a table mapping variables to assigned registers.

Keep a scratch array mapping temporaries to assigned registers.

Keep a table indicating which variables are saved.

Processing the input ports:

Each input port contains an optional 'pref-reg' field that indicates
which register it prefers to be in. For the ports that prefer to be
loaded, and have preferred registers, and where the registers are
free, assign the variable to those registers. Then, afterwards, assign
arbitrary remaining registers to the remaining variables. Use sanity
checks to ensure that the allocation pass guaranteed there are exactly
enough registers.

Processing OperationStmt:

For the operations, we have to choose registers for:
- Arguments
- Temporaries
- Results

Note that we need to choose registers for the arguments first,
and then we need to interpret the model itself. The model
will indicate when registers are released, and when registers
are assigned. The model statements of interest are: Release,
Assign, ClearRegisters.

By the end of the operation, the result registers will have
been assigned, and we can record the final assignment, and
emit an AssignedOperationStmt.

For each of the results, indicate that they are no longer
saved so that the save table remains up-to-date.

Processing Save:

Record this in the table so that we can use this information
in the shuffling engine.

Processing Load:

Retrieve the preferred register for the load. Use a sanity
check to ensure that the variable hasn't already been loaded.
Then assign the register to the variable.

Processing Unload:

Remove the assignment for the given variable. Use a sanity
check to ensure that the variable was actually assigned.

# Algorithm For Assigning Registers Before Operation #

## Input ##

- The list of free registers.
- For each argument, what register it is in.

## Step: Identify Swap Registers ##

For the shuffling engine, we may need swap registers. Identify
one free integer register and one free floating register
right now before we begin. They will be used later.

## Step: Reserve Registers ##

Reserve all of the concrete output registers right now.

(If it's a ClearRegisters operation, then only reserve
 the concrete temporary registers.)

Reserve (using the reserved-input set) all of the concrete input
registers right now.

## Step: Processing the input arguments ##

For each argument, the following cases apply:

Case: Desired register.
  Case: Current register == Desired register.
    Do nothing.
  Case: Current register != Desired register.
    Evict.
Case: No Desired Register.
  Case: Killed Arg.
    Evict if current register is a reserved input register.  
  Case: Live Arg.
    Evict if current register is a reserved input or output register.
    
For each temporary/output register, suppose the register is presently occupied:

Case: Occupied by Arg.
  Case: Killed Arg.
    Do nothing. Leave for model to handle.
  Case: Live Arg.
    Evict.
Case: Occupied by Var.
  Evict.

Based upon the above, we can derive this loop:

Loop through each argument:
  Case: Desired register.
    if current register != desired register:
      evict occupant of desired register.
      assign variable to desired register.

## Step: Processing the model statements ##

Case: Assign concrete register. Register is free.

  Assign this register to the value. Register is now no longer free.

Case: Assign concrete register. Register is not free.

  Evict the current occupant.
  Assign this register to the value. 

Case: Assign arbitrary register.

  Choose a non-reserved register.
  Follow preferences.
  Assign this register to the value.

Case: Release argument. Argument is in register.

  Unassign variable.
  Record the register for the argument.

Case: Release argument. Argument is not in register.

  Choose a non-reserved-input register.
  Record the register for the argument.
  Remove this from the evicted list.
  Add this move to the shuffle.

## Step: Relocating current occupants ##

Some existing variables have been evicted to make space for required registers.

For each of these, we can now choose a free register for each one.

## Step: Performing the shuffle ##

The inputs to the shuffle are:
- All of the argument variables.
- All of the live relocated variables.
- The free registers are the ones identified at the beginning of the process.

;============================================================
;=======================================================<doc>

public defn assign-registers (e:BlockEngine,
                              assignment-table:AssignmentTable) :

  ;## Step: Process the input ports ##
  ;- Try to assign the ports with free preferred registers first.
  ;- Then assign remaining ports.
  ;- Mark as saved for the saved ports.

  ;Assign the ports with preferred registers.
  val unassigned-ports = Vector<Port>()
  for p in inputs(e) do :
    if loaded?(p) :
      val reg = reg-pref(p)
      val assign? =
        match(reg:Register) :
          get?(assignment-table, reg) is False
      if assign? :
        assign(assignment-table, id(p), reg as Register)
      else :
        add(unassigned-ports, p)

  ;Assign the remaining ports.
  for p in unassigned-ports do :
    val r = free-register(assignment-table, location-type(p),
                          true, true, false)
    assign(assignment-table, id(p), r)

  ;Mark the saved ports.
  for p in inputs(e) do :
    set-saved(assignment-table, id(p), true) when saved?(p)      

  ;Record the final registers that were assigned to the ports.
  val new-ports = to-tuple $ for p in inputs(e) seq :
    if loaded?(p) : sub-location(p, assignment-table[id(p)])
    else : p    
  set-contents(inputs(e), new-ports)
    
  ;## Step: Process the instructions ##
  within (i, stmt, emit) = process-instructions(e) :
    println("\n\nPROCESS: %_" % [stmt])
    
    match(stmt) :

      ;Processing a Save statement.
      (stmt:Save) :
        set-saved(assignment-table, id(stmt), true)
        val reg = assignment-table[id(stmt)]
        emit(Save(id(stmt), reg))

      ;Processing a Unload statement.
      (stmt:Unload) :
        unassign(assignment-table, id(stmt))
        
      ;Processing a Load statement
      (stmt:Load) :
        val type = reg(stmt) as RegisterType
        val reg = free-register(assignment-table, type, true, true, false)
        assign(assignment-table, id(stmt), reg)
        emit(Load(id(stmt), reg))

      ;Processing an operation statement.
      (stmt:AnnotatedOperationStmt) :
        ;Initialize the assignment table.
        initialize-before-operation(assignment-table, args(stmt), num-temps) where :
          val num-temps = num-temps(e,stmt)
        
        ;Step: Preemptively identify swap registers
        val swap-reg = free-register(assignment-table, AnyReg(), true, true, false) as Reg|False
        val swap-freg = free-register(assignment-table, AnyFReg(), true, true, false) as FReg|False
        println("\n\nswap-reg = %_, swap-freg = %_" % [swap-reg, swap-freg])

        ;Step: Reserve input/output registers.
        for r in temp-registers(e,stmt) do :
          mark-reserved(assignment-table, r)
        if not clears-registers?(e,stmt) :
          for r in result-registers(e,stmt) do :
            mark-reserved(assignment-table, r)
        for r in arg-registers(e,stmt) do :
          mark-reserved-input(assignment-table, r)

        ;Step: Processing the input arguments.
        for (v in args(stmt), reg in arg-locations(e,stmt), arg-index in 0 to false) do :
          match(reg:Register) :
            val current-reg = assignment-table[v]
            if current-reg != reg :
              unassign(assignment-table, v)
              evict?(assignment-table, reg)
              assign(assignment-table, v, reg)

        ;Helper: Prepare to assign a location to a result or temporary.
        ;Returns the final register to assign to the result/temporary.
        ;- loc: The location to assign.
        ;- pref: Any preference on the final assigned register.
        defn prepare-assignment-location (loc:Location, pref:Preference) -> Register :
          match(loc) :
            (reg:Register) :
              evict?(assignment-table, reg)
              reg
            ;Case: Assign an abitrary register.
            (type:RegisterType) :
              ;Find a non-reserved register.
              free-register(assignment-table, type, false, true, false)

        ;Helper: Save the chosen argument and temporary registers.
        ;This is required because this needs to be called before clearing registers
        ;and assigning result registers.
        var arg-regs:Tuple<Register>
        var temp-regs:Tuple<Register>
        defn save-arg-and-temp-registers () :
          arg-regs = to-tuple $ for i in 0 to length(args(stmt)) seq :
            arg(assignment-table,i) as Register
          temp-regs = to-tuple $ for i in 0 to num-temps(e,stmt) seq :
            temp(assignment-table,i) as Register
            
        ;Helper: Retrieve the final chosen result registers.
        defn result-regs () -> Tuple<Register> :
          to-tuple $ for v in results(stmt) seq :
            assignment-table[v]

        ;Helper: Assign registers to remaining arguments that were not
        ;killed during processing the model.
        ;Will be called either during clear-registers, or right after
        ;processing the model (if the operation does not clear-registers.)
        defn assign-remaining-args () -> False :
          for (v in args(stmt), loc in arg-locations(e,stmt), i in 0 to false) do :
            if arg(assignment-table,i) is False :
              match(get?(assignment-table, v)) :
                (reg:Register) :
                  assign-arg(assignment-table, i, reg)
                (f:False) :
                  ;Sanity check.
                  if loc is Register :
                    fatal("Unexpected eviction of argument Arg%_ (V%_) with concrete register." % [i,v])
                  ;Find a non-reserved-input register.
                  val reg = free-register(assignment-table, loc as RegisterType, true, false, false)
                  assign(assignment-table, v, reg)
                  assign-arg(assignment-table, i, reg)

        ;Helper: Is a shuffle needed for this operation?
        defn shuffle-needed? () -> True|False :
          defn has-evictions? () :
            not empty?(evicted(assignment-table))
          defn args-moved? () :
            for i in 0 to length(args(stmt)) any? :
              prev-arg(assignment-table, i) != arg(assignment-table, i)
          has-evictions?() or args-moved?()

        ;Helper: Emit the shuffle to get variables into position before start
        ;of operation.
        ;Will be called either during clear-registers, or right after
        ;processing the model (if the operation does not clear-registers.)
        defn shuffle-args-into-position () -> False :
          if shuffle-needed?() :
            val vars = Vector<Int>()
            val saved = Vector<True|False>()
            val inputs = Vector<Register>()
            val outputs = Vector<Register>()
            for (v in args(stmt), i in 0 to false) do :
              add(vars, v)
              add(saved, saved?(assignment-table, v))
              add(inputs, prev-arg(assignment-table, i))
              add(outputs, arg(assignment-table, i) as Register)
            for entry in evicted(assignment-table) do :
              val v = variable(entry)
              val reg = reg(entry)
              val new-reg = free-register(assignment-table, type(reg), true, false, false)
              assign(assignment-table, v, new-reg)
              add(vars, v)
              add(saved, saved?(assignment-table,v))
              add(inputs, reg)
              add(outputs, new-reg)
            load-problem(shuffle-engine(e),
                         to-tuple(vars),
                         to-tuple(inputs),
                         to-tuple(saved),
                         to-tuple(outputs))
            shuffle(shuffle-engine(e),
                    to-tuple(outputs),
                    swap-reg,
                    swap-freg,
                    emit)
                
        ;Step: Process the model statements.
        process-model{_, e ,stmt} $ new ModelProcessor :
        
          ;Processing an assignment statement to a variable.
          defmethod assign-result (this, v:Int, loc:Location, pref:Preference) :
            println("Assign %_ to Result V%_" % [loc, v])
            val reg = prepare-assignment-location(loc, pref)
            assign(assignment-table, v, reg)
                
          ;Processing an assignment statement to a temporary variable.
          defmethod assign-temp (this, temp:Int, loc:Location, pref:Preference) :
            println("Assign %_ to Temp T%_" % [loc, temp])
            val reg = prepare-assignment-location(loc, pref)
            assign-temp(assignment-table, temp, reg)

          ;Processing a release statement.
          defmethod release-arg (this, index:Int, v:Int, loc:Location) :
            println("Release Arg%_ (V%_)" % [index, v])
            match(get?(assignment-table,v)) :
              ;Case: This register is safe to be kept for use by this argument.
              (r:Register) :
                unassign(assignment-table, v)
                assign-arg(assignment-table, index, r)
              ;Case: Argument was unassigned. The register it was originally
              ;in was required by one of the outputs, and it got evicted.
              (f:False) :
                ;Find a non-reserved-input register.
                val reg = free-register(assignment-table, type(loc), true, false, false)
                mark-reserved-input(assignment-table, reg)
                assign-arg(assignment-table, index, reg)

          ;Processing a clear registers statement.
          defmethod clear-registers (this) :
            ;Process everything before the actual operation.
            assign-remaining-args()
            shuffle-args-into-position()
            save-arg-and-temp-registers()
            ;Clear all the loaded registers.
            clear-registers(assignment-table)
            ;Now reserve the output registers so that when we assign the result,
            ;they get the right registers.
            for r in result-registers(e,stmt) do :
              mark-reserved(assignment-table, r)

        ;If the operation does not clear registers, then process everything
        ;required to get arguments into position.
        if not clears-registers?(e,stmt) :
          assign-remaining-args()
          shuffle-args-into-position()
          save-arg-and-temp-registers()

        ;Emit the now assigned operation.
        emit $ AssignedOperationStmt(/stmt(stmt),
                                     arg-regs,
                                     temp-regs,
                                     result-regs())

        ;Step: Release the temp variables unless clear-registers has already done it.
        if not clears-registers?(e,stmt) :
          release-all-temp(assignment-table)

      ;Processing some other statement.
      (stmt) :
        emit(stmt)

  ;Record the final registers that were assigned to the output ports.
  val new-output-ports = to-tuple $ for p in outputs(e) seq :
    sub-location(p, get?(assignment-table, id(p)))
  set-contents(outputs(e), new-output-ports)

;------------------------------------------------------------
;--------------------- Process a Model ----------------------
;------------------------------------------------------------

;Callbacks for processing the different actions of a model.
deftype ModelProcessor

;Release the variable register.
defmulti release-arg (proc:ModelProcessor, index:Int, id:Int, loc:Location) -> False

;Assign the temporary at index 'index'.
defmulti assign-temp (proc:ModelProcessor, index:Int, loc:Location, pref:Preference) -> False

;Assign the result with id 'id'.
defmulti assign-result (proc:ModelProcessor, id:Int, loc:Location, pref:Preference) -> False

;Clear all of the registers.
defmulti clear-registers (proc:ModelProcessor) -> False

;Process the given operation statement using the model processor.
defn process-model (proc:ModelProcessor,
                    e:BlockEngine,
                    anno-stmt:AnnotatedOperationStmt) -> False :
  ;Retrieve the model.
  val op-stmt = stmt(anno-stmt)
  val model = models(e)[op-id(op-stmt)]

  ;Retrieve the index ranges of the different variables.
  val first-temp = length(results(model)) + length(args(model))
  val first-arg = length(results(model))
  val num-vars = length(results(model)) + length(args(model)) + length(temp(model))

  ;Return true if the given variable is a temp variable.
  defn temp? (v:Int) : v >= first-temp and v < num-vars

  ;Return true if the given variable is an arg variable.
  defn arg? (v:Int) : v >= first-arg and v < first-temp

  ;Return true if the given variable is a result variable.
  defn result? (v:Int) : v >= 0 and v < first-arg

  ;Return true if arg at index 'i' is killed in this
  ;operation.
  defn arg-killed? (i:Int) -> True|False :
    contains?(killed-args(anno-stmt), i)

  ;Return the id of the global argument variable at index 'i'.
  defn arg-var (i:Int) -> Int :
    args(op-stmt)[i]

  ;Return the id of the global result variable at index 'i'.
  defn result-var (i:Int) -> Int :
    results(op-stmt)[i]

  ;Return the index of the temp variable.
  defn temp-index (v:Int) : v - first-temp

  ;Return the index of the arg variable.
  defn arg-index (v:Int) : v - first-arg

  ;Return the index of the result variable.
  defn result-index (v:Int) : v

  ;Analyze the given preference, and update it
  ;to reflect the global variable ids.
  ;[TODO] Improve the preference calculator.
  defn analyze (pref:Preference) -> Preference :
    match(pref:PreferSame) :
      fatal("Invalid preference") when not arg?(id(pref))
      val i = arg-index(id(pref))
      PreferSame(arg-var(i))
    else :
      pref

  ;Iterate through each statement and call
  ;the appropriate callbacks.
  for mstmt in stmts(model) do :
    match(mstmt) :
      (mstmt:Release) :
        fatal("Invalid release") when not arg?(id(mstmt))
        val i = arg-index(id(mstmt))
        release-arg(proc, i, arg-var(i), location(args(model)[i])) when arg-killed?(i)
      (mstmt:Assign) :
        if temp?(id(mstmt)) :
          val i = temp-index(id(mstmt))
          assign-temp(proc,
                      i,
                      location(temp(model)[i]),
                      analyze(preference(temp(model)[i])))
        else if result?(id(mstmt)) :
          val i = result-index(id(mstmt))
          assign-result(proc,
                        result-var(i),
                        location(results(model)[i]),
                        analyze(preference(results(model)[i])))
        else :
          fatal("Invalid assignment")
      (mstmt:ClearRegisters) :
        clear-registers(proc)
      (mstmt:Return) :
        false

;------------------------------------------------------------
;--------------------- Utilities ----------------------------
;------------------------------------------------------------

;Assumes that the current location of p is a general type
;because a specific register has not been assigned yet.
defn location-type (p:Port) -> RegisterType :
  location(p) as RegisterType

;Helper: Set the contents of the given vector.
defn set-contents<?T> (vs:Vector<?T>, xs:Seqable<T>) :
  clear(vs)
  add-all(vs,xs)

;Return the argument variables to the operation.
defn args (op:AnnotatedOperationStmt) -> Tuple<Int> :
  args(stmt(op))

;Return the result variables to the operation.
defn results (op:AnnotatedOperationStmt) -> Tuple<Int> :
  results(stmt(op))

;Helper: Return the number of temporary variables this
;operation has.
defn num-temps (e:BlockEngine, op:AnnotatedOperationStmt) -> Int :
  val m = models(e)[op-id(stmt(op))]
  length(temp(m))

;Helper: Return the tuple of locations required by the temporaries of an operation.
defn temp-locations (e:BlockEngine, op:AnnotatedOperationStmt) -> Tuple<Location> :
  val m = models(e)[op-id(stmt(op))]
  map(location, temp(m))

;Helper: Return the tuple of locations required by the arguments of an operation.
defn arg-locations (e:BlockEngine, op:AnnotatedOperationStmt) -> Tuple<Location> :
  val m = models(e)[op-id(stmt(op))]
  map(location, args(m))

;Helper: Return the tuple of locations required by the results of an operation.
defn result-locations (e:BlockEngine, op:AnnotatedOperationStmt) -> Tuple<Location> :
  val m = models(e)[op-id(stmt(op))]
  map(location, results(m))

;Helper: Returns the sequence of required registers by the temporaries of an operation.
defn temp-registers (e:BlockEngine, op:AnnotatedOperationStmt) -> Seqable<Register> :
  filter-by<Register>(temp-locations(e,op))

;Helper: Return the sequence of required registers by the arguments of an operation.
defn arg-registers (e:BlockEngine, op:AnnotatedOperationStmt) -> Seqable<Register> :
  filter-by<Register>(arg-locations(e,op))

;Helper: Return the sequence of required registers by the results of an operation.
defn result-registers (e:BlockEngine, op:AnnotatedOperationStmt) -> Seqable<Register> :
  filter-by<Register>(result-locations(e,op))

;Returns true if the given operation statement clears the registers.
defn clears-registers? (e:BlockEngine, op:AnnotatedOperationStmt) -> True|False :
  val mprops = model-properties(e)[op-id(stmt(op))]
  clears-registers?(mprops)