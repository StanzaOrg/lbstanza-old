defpackage stz/reg-alloc-assignment :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-engine
  import stz/reg-alloc-block-engine
  import stz/reg-alloc-shuffle
  import stz/reg-alloc-datastructures
  import stz/reg-alloc-assignment-table
  import stz/printing-utils

;<doc>=======================================================
;======================= Algorithm ==========================
;============================================================

Sweep through the instructions in forward order:

Keep a table mapping variables to assigned registers.

Keep a scratch array mapping temporaries to assigned registers.

Keep a table indicating which variables are saved.

Processing the input ports:

Each input port contains an optional 'pref-reg' field that indicates
which register it prefers to be in. For the ports that prefer to be
loaded, and have preferred registers, and where the registers are
free, assign the variable to those registers. Then, afterwards, assign
arbitrary remaining registers to the remaining variables. Use sanity
checks to ensure that the allocation pass guaranteed there are exactly
enough registers.

Processing OperationStmt:

For the operations, we have to choose registers for:
- Arguments
- Temporaries
- Results

Note that we need to choose registers for the arguments first,
and then we need to interpret the model itself. The model
will indicate when registers are released, and when registers
are assigned. The model statements of interest are: Release,
Assign, ClearRegisters.

By the end of the operation, the result registers will have
been assigned, and we can record the final assignment, and
emit an AssignedOperationStmt.

For each of the results, indicate that they are no longer
saved so that the save table remains up-to-date.

Processing Save:

Record this in the table so that we can use this information
in the shuffling engine.

Processing Load:

Retrieve the preferred register for the load. Use a sanity
check to ensure that the variable hasn't already been loaded.
Then assign the register to the variable.

Processing Unload:

Remove the assignment for the given variable. Use a sanity
check to ensure that the variable was actually assigned.

# Algorithm For Assigning Registers Before Operation #

## Input ##

- The list of free registers.
- For each argument, what register it is in.

## Step: Identify Swap Registers ##

For the shuffling engine, we may need swap registers. Identify
one free integer register and one free floating register
right now before we begin. They will be used later.

## Step: Reserve Registers ##

Reserve all of the concrete output registers right now.

(If it's a ClearRegisters operation, then only reserve
 the concrete temporary registers.)

Reserve (using the reserved-input set) all of the concrete input
registers right now.

## Step: Processing the input arguments ##

For each argument, the following cases apply:

Case: Desired register.
  Case: Current register == Desired register.
    Do nothing.
  Case: Current register != Desired register.
    Evict.
Case: No Desired Register.
  Case: Killed Arg.
    Evict if current register is a reserved input register.  
  Case: Live Arg.
    Evict if current register is a reserved input or output register.
    
For each temporary/output register, suppose the register is presently occupied:

Case: Occupied by Arg.
  Case: Killed Arg.
    Do nothing. Leave for model to handle.
  Case: Live Arg.
    Evict.
Case: Occupied by Var.
  Evict.

Based upon the above, we can derive this loop:

Loop through each argument:
  Case: Desired register.
    if current register != desired register:
      unassign variable from current register.
      evict occupant of desired register.
      assign variable to desired register.

## Step: Processing the model statements ##

Case: Assign concrete register. Register is free.

  Assign this register to the value. Register is now no longer free.

Case: Assign concrete register. Register is not free.

  Evict the current occupant.
  Assign this register to the value. 

Case: Assign arbitrary register.

  Choose a non-reserved register.
  Follow preferences.
  Assign this register to the value.

Case: Release argument. Argument is in register.

  Unassign variable.
  Record the register for the argument.

Case: Release argument. Argument is not in register.

  Choose a non-reserved-input register.
  Record the register for the argument.
  Remove this from the evicted list.
  Add this move to the shuffle.

## Step: Relocating current occupants ##

Some existing variables have been evicted to make space for required registers.

For each of these, we can now choose a free register for each one.

## Step: Performing the shuffle ##

The inputs to the shuffle are:
- All of the argument variables.
- All of the live relocated variables.
- The free registers are the ones identified at the beginning of the process.

;============================================================
;=======================================================<doc>

public defn assign-registers (e:BlockEngine,
                              assignment-table:AssignmentTable) :

  ;## Step: Process the input ports ##
  ;- Try to assign the ports with free preferred registers first.
  ;- Then assign remaining ports.
  ;- Mark as saved for the saved ports.

  ;Assign the ports with preferred registers.
  val unassigned-ports = Vector<Port>()
  for p in inputs(e) do :
    if loaded?(p) :
      val reg = pref-reg(p)
      val assign? =
        match(reg:Reg|FReg) :
          get?(assignment-table, reg) is False
      if assign? :
        assign(assignment-table, id(p), reg as Reg|FReg)
      else :
        add(unassigned-ports, p)

  ;Assign the remaining ports.
  for p in unassigned-ports do :
    val loc = register-category(p)
    val r = free-register(assignment-table, loc, true, true, false)
    assign(assignment-table, id(p), r)

  ;Mark the saved ports.
  for p in inputs(e) do :
    set-saved(assignment-table, id(p), true) when saved?(p)      

  ;Record the final registers that were assigned to the ports.
  val new-ports = to-tuple $ for p in inputs(e) seq :
    sub-assigned-reg(p, assignment-table[id(p)])
  set-contents(inputs(e), new-ports)
    
  ;## Step: Process the instructions ##
  within (i, stmt, emit) = process-instructions(e) :
    println("PROCESS: %_" % [stmt])
    
    match(stmt) :

      ;Processing a Save statement.
      (stmt:Save) :
        false

      ;Processing a Unload statement.
      (stmt:Unload) :
        false

      ;Processing an operation statement.
      (stmt:AnnotatedOperationStmt) :
        false
      
;        ;Step: Preemptively identify swap registers
;        val swap-reg = free-register(assignment-table, AnyReg(), true, true)
;        val swap-freg = free-register(assignment-table, AnyFReg(), true, true)
;
;        ;Step: Reserve input/output registers.
;        clear-reserved(assignment-table)
;        clear-reserved-input(assignment-table)
;        for r in temp-registers(e,stmt) do :
;          match(r:Reg|FReg) :
;            mark-reserved(assignment-table, r)
;        if not clears-registers?(e,stmt) :
;          for r in result-registers(e,stmt) do :
;            match(r:Reg|FReg) :
;              mark-reserved(assignment-table, r)
;        for r in arg-registers(e,stmt) do :
;          match(r:Reg|FReg) :
;            mark-reserved-input(assignment-table, r)
;
;        ;Step: Processing the input arguments.
;        for (v in args(stmt), reg in arg-registers(e,stmt)) do :
;          match(reg:Reg|FReg) :
;            val current-reg = assignment-table[v]
;            if current-reg != reg :
;              unassign(assignment-table, v)
;              evict?(assignment-table, reg)
;              assign(assignment-table, v, reg)
;              assign-arg(assignment-table, v, reg)
;
;        ;Helper: Prepare to assign a location to a result or temporary.
;        ;Returns the final register to assign to the result/temporary.
;        ;- loc: The location to assign.
;        ;- pref: Any preference on the final assigned register.
;        defn prepare-assignment-location (loc:Location, pref:Preference) -> Reg|FReg :
;          match(loc) :
;            (reg:Reg|FReg) :
;              evict?(assignment-table, reg)
;              reg
;            ;Case: Assign an abitrary register.
;            (loc:AnyReg|AnyFReg) :
;              ;Find a non-reserved register.
;              free-register(assignment-table, loc, false, true)        
;                
;        ;Step: Process the model statements.
;        process-model{_, e ,stmt} $ new ModelProcessor :
;        
;          ;Processing an assignment statement to a variable.
;          defmethod assign (this, v:Int, loc:Location, pref:Preference) :
;            val reg = prepare-assignment-location(loc, pref)
;            assign(assignment-table, v, reg)
;                
;          ;Processing an assignment statement to a temporary variable.
;          defmethod assign-temp (this, temp:Int, loc:Location, pref:Preference) :
;            val reg = prepare-assignment-location(loc, pref)
;            assign-temp(assignment-table, temp, reg)
;                
;          ;Processing a release statement.
;          defmethod release (this, v:Int) :
;            match(get?(assignment-table,v)) :
;              ;Case: This register is safe to be kept for use by this argument.
;              (r:Reg|FReg) :
;                unassign(assignment-table, v, r)
;                assign-arg(assignment-table, v, r)
;              ;Case: Argument was unassigned. The register it was originally
;              ;in was required by one of the outputs.
;              (f:False) :
;                ;Find a non-reserved-input register.
;                val reg = free-register(assignment-table, loc, true, false)
;                mark-reserved-input(assignment-table, reg)
;                assign-arg(assignment-table, v, reg)
;
;          ;Processing a clear registers statement.
;          defmethod clear-registers (this) :
;            ;[TODO] Unassign all the registers.
;            ;[TODO] Reserve only the output registers again. (Ignoring the temp).
;            fatal("Not sure about this.")
;
;        ;Step: Relocating the displaced variables.
;        val shuffle = Vector<[Int, Reg|FReg, Reg|FReg]>()
;        within (v, old-reg, new-reg) = evicted(assignment-table) :
;          match(new-reg:Reg|FReg) :
;            add(shuffle, [v, old-reg, new-reg])
;          else :
;            ;Find a non-reserved-input register.
;            val new-reg = free-register(assignment-table, old-reg, true, false)
;            assign(assignment-table, v, new-reg)
;            add(shuffle, [v, old-reg, new-reg])
;
;        ;Are arguments guaranteed to be assigned?
;        ;NO: only killed arguments are assigned. Because they have the release.
;        ;So at the end of the isntruction processing:
;        ;- All the killed arguments have a recorded register.
;        ;- The other arguments do not.
;        ;- But it's easy to assign them a register. Or figure out which ones don't have a register.
;        ;- For the remaining arguments,
;        ;    either they are still assigned a register, which means no one needed their register.
;        ;    or they are unassigned, which means they were evicted.
;        ;- And then, we just want the other registers to have a variable.
;        ;  So we want to grab all the evicted entries that are NOT arguments.
;            
;        ;Step: Performing the shuffle.
;        println("SHUFFLE%_" % [colon-field-list(shuffle)])        



;<comment>
;------------------------------------------------------------
;--------------------- Process a Model ----------------------
;------------------------------------------------------------

;Callbacks for processing the different actions of a model.
deftype ModelProcessor

;Release the temporary at index 'index'.
defmulti release-temp (proc:ModelProcessor, index:Int) -> False

;Release the variable register.
defmulti release (proc:ModelProcessor, id:Int) -> False

;Assign the temporary at index 'index'.
defmulti assign-temp (proc:ModelProcessor, index:Int, loc:Location, pref:Preference) -> False

;Assign the variable with id 'id'.
defmulti assign (proc:ModelProcessor, id:Int, loc:Location, pref:Preference) -> False

;Clear all of the registers.
defmulti clear-registers (proc:ModelProcessor) -> False

defn process-model (proc:ModelProcessor,
                    e:BlockEngine,
                    anno-stmt:AnnotatedOperationStmt) -> False :
  ;Retrieve the model.
  val op-stmt = stmt(anno-stmt)
  val model = models(e)[op-id(op-stmt)]

  ;Retrieve the index ranges of the different variables.
  val first-temp = length(results(model)) + length(args(model))
  val first-arg = length(results(model))
  val num-vars = length(results(model)) + length(args(model)) + length(temp(model))

  ;Return true if the given variable is a temp variable.
  defn temp? (v:Int) : v >= first-temp and v < num-vars

  ;Return true if the given variable is an arg variable.
  defn arg? (v:Int) : v >= first-arg and v < first-temp

  ;Return true if the given variable is a result variable.
  defn result? (v:Int) : v >= 0 and v < first-arg

  ;Return true if arg at index 'i' is killed in this
  ;operation.
  defn arg-killed? (i:Int) -> True|False :
    contains?(killed-args(anno-stmt), i)

  ;Return the id of the global argument variable at index 'i'.
  defn arg-var (i:Int) -> Int :
    args(op-stmt)[i]

  ;Return the id of the global result variable at index 'i'.
  defn result-var (i:Int) -> Int :
    results(op-stmt)[i]

  ;Return the index of the temp variable.
  defn temp-index (v:Int) : v - first-temp

  ;Return the index of the arg variable.
  defn arg-index (v:Int) : v - first-arg

  ;Return the index of the result variable.
  defn result-index (v:Int) : v

  ;Return true if the model calls clear-registers.
  defn model-clears-registers? () -> True|False :
    val props = model-properties(e)[op-id(op-stmt)]
    clears-registers?(props)

  ;Analyze the given preference, and update it
  ;to reflect the global variable ids.
  defn analyze (pref:Preference) -> Preference :
    match(pref:PreferSame) :
      if temp?(arg(pref)) :
        PreferSameAsTemp(temp-index(arg(pref)))
      else if arg?(arg(pref)) :
        val i = arg-index(arg(pref))
        PreferSame(arg-var(i))
      else :
        fatal("Invalid preference: %_" % [pref])
    else :
      pref

  ;Iterate through each statement and call
  ;the appropriate callbacks.
  for mstmt in stmts(model) do :
    match(mstmt) :
      (mstmt:Release) :
        if temp?(arg(mstmt)) :
          release-temp(proc, temp-index(arg(mstmt)))
        else :
          val i = arg-index(arg(mstmt))
          release(proc, arg-var(i)) when arg-killed?(i)
      (mstmt:Assign) :
        if temp?(arg(mstmt)) :
          assign-temp(proc,
                      temp-index(arg(mstmt)),
                      location(mstmt),
                      analyze(preference(mstmt)))
        else if arg?(arg(mstmt)) :
          val i = arg-index(arg(mstmt))
          assign(proc,
                 arg-var(i),
                 location(mstmt),
                 analyze(preference(mstmt)))
        else if result?(arg(mstmt)) :
          val i = result-index(arg(mstmt))
          assign(proc,
                 result-var(i),
                 location(mstmt),
                 analyze(preference(mstmt)))
        else :
          fatal("Invalid variable: V%_" % [arg(mstmt)])
      (mstmt:ClearRegisters) :
        clear-registers(proc)
      (mstmt:Return) :
        false

  ;Finish by releasing any other temp/arg variables,
  ;that hasn't explicitly been released.
  if not model-clears-registers?() :
    ;Compute all that has been released.
    val all-released = to-intset $
      seq(arg, filter-by<Release>(stmts(model)))

    ;Release any other temp that hasn't yet been released.
    for v in temp(model) do :
      if not all-released[v] :
        release-temp(proc, temp-index(v))

    ;Release any other killed arguments that hasn't already been
    ;released.
    for v in seq(id,args(model)) do :
      if not all-released[v] :
        val i = arg-index(v)
        release(proc, v) when arg-killed?(i)

;Prefer to be same as the temp for the operation.
defstruct PreferSameAsTemp <: Preference :
  index:Int

;------------------------------------------------------------
;--------------------- Utilities ----------------------------
;------------------------------------------------------------
;<comment>

;Returns true if the given port is loaded into a register.
defn loaded? (p:Port) -> True|False :
  val s = status(p) as PortStatus
  loaded(s) is Location

;Returns true if the given port is saved.
defn saved? (p:Port) -> True|False :
  val s = status(p) as PortStatus
  saved?(s)

;Returns the register category that a port is in.
defn register-category (p:Port) -> AnyReg|AnyFReg :
  val s = status(p) as PortStatus
  loaded(s) as AnyReg|AnyFReg

;Fill in the final assigned register for the given port.
defn sub-assigned-reg (p:Port, r:Reg|FReg) -> Port :
  val s = status(p) as PortStatus
  val new-status = sub-loaded(s, r)
  sub-status(p, new-status)

;Helper: Set the contents of the given vector.
defn set-contents<?T> (vs:Vector<?T>, xs:Seqable<T>) :
  clear(vs)
  add-all(vs,xs)

;Return the argument variables to the operation.
defn args (op:AnnotatedOperationStmt) -> Tuple<Int> :
  args(stmt(op))

;Helper: Return the registers that the arguments are required
;to be in.
defn arg-registers (e:BlockEngine, op:AnnotatedOperationStmt) -> Tuple<Location> :
  val m = models(e)[op-id(stmt(op))]
  map(location, args(m))

;Helper: Return the number of temporary variables this
;operation has.
defn num-temp (e:BlockEngine, op:AnnotatedOperationStmt) -> Int :
  val m = models(e)[op-id(stmt(op))]
  length(temp(m))



