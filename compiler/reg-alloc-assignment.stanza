defpackage stz/reg-alloc-assignment :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-engine
  import stz/reg-alloc-block-engine
  import stz/reg-alloc-shuffle
  import stz/printing-utils

;<doc>=======================================================
;======================= Algorithm ==========================
;============================================================

Sweep through the instructions in forward order:

Keep a table mapping variables to assigned registers.

Keep a scratch array mapping temporaries to assigned registers.

Keep a table indicating which variables are saved.

Processing the input ports:

Each input port contains an optional 'pref-reg' field that indicates
which register it prefers to be in. For the ports that prefer to be
loaded, and have preferred registers, and where the registers are
free, assign the variable to those registers. Then, afterwards, assign
arbitrary remaining registers to the remaining variables. Use sanity
checks to ensure that the allocation pass guaranteed there are exactly
enough registers.

Processing OperationStmt:

For the operations, we have to choose registers for:
- Arguments
- Temporaries
- Results

Note that we need to choose registers for the arguments first,
and then we need to interpret the model itself. The model
will indicate when registers are released, and when registers
are assigned. The model statements of interest are: Release,
Assign, ClearRegisters.

By the end of the operation, the result registers will have
been assigned, and we can record the final assignment, and
emit an AssignedOperationStmt.

For each of the results, indicate that they are no longer
saved so that the save table remains up-to-date.

Processing Save:

Record this in the table so that we can use this information
in the shuffling engine.

Processing Load:

Retrieve the preferred register for the load. Use a sanity
check to ensure that the variable hasn't already been loaded.
Then assign the register to the variable.

Processing Unload:

Remove the assignment for the given variable. Use a sanity
check to ensure that the variable was actually assigned.

# Algorithm For Assigning Registers Before Operation #

## Input ##

- The list of free registers.
- For each argument, what register it is in.

## Step: Identify Swap Registers ##

For the shuffling engine, we may need swap registers. Identify
one free integer register and one free floating register
right now before we begin. They will be used later.

## Step: Reserve Registers ##

Reserve all of the concrete output registers right now.

(If it's a ClearRegisters operation, then only reserve
 the concrete temporary registers.)

## Step: Processing the input arguments ##

For each argument, the following cases apply:

Case:  Desired register is concrete. Current register == Desired register.

  Do nothing.

Case: Desired register is concrete. Current register != Desired register. 

  Put current register on free list.
  
Case: No desired register. Current register is a concrete input registers. 

  Flag this argument as invalid.

Case: No desired register. Current register is not a concrete input registers. 

  Do nothing.

## Step: Processing the model statements ##

Case: Assign concrete register. Register is free.

  Assign this register to the value. Register is now no longer free.

Case: Assign concrete register. Register is not free.

  Guarantee: The occupants of the register is an argument.
             The argument had no concrete desired register.
  Flag the argument as invalid.
  Assign this register to the value. 

Case: Assign arbitrary register.

  Choose a non-reserved register.
  Follow preferences.
  Assign this register to the value.

Case: Release argument. Argument is in register.

  Put register in free.
  Variable is now unassigned.

Case: Release argument. Argument is flagged invalid.

  Choose a free register that hasn't already been used for an invalid
  argument. It's okay for it to be reserved.
  Assign this register to the argument.
  Mark this register as having been used for an invalid argument.

## Step: Relocating current occupants ##

All of the outputs, temporaries, and arguments have specific registers now.

For each of these registers look at their current occupants:

Case 1: No occupant.

Case 2: Occupied by one of the arguments. (Doesn't matter which.)

Case 3: Occupied by some other live variable.

Case 1 and 2 require no special handling. All live variables
identified by case 3 now require some other register for them to be
moved to. Choose a free register for each one.

## Step: Performing the shuffle ##

The inputs to the shuffle are:
- All of the argument variables.
- All of the live relocated variables.
- The free registers are the ones identified at the beginning of the process.

;============================================================
;=======================================================<doc>

public defn assign-registers (e:BlockEngine,
                              num-regs:Int,
                              num-fregs:Int) :
  fatal("Not yet implemented")
;<comment>
  ;----------------------------------------------------------
  ;-------------------- State Tables ------------------------
  ;----------------------------------------------------------

  ;Holds which registers are currently assigned to each
  ;variable.
  val register-table = IntTable<Reg|FReg>()

  ;Holds which registers are currently assigned to the
  ;temp variables.
  val temp-table = Vector<Reg|FReg|False>()

  ;----------------------------------------------------------
  ;-------------------- State Manipulation ------------------
  ;----------------------------------------------------------

  ;Returns true if the given register is free to be assigned.
  defn free-register? (r:Reg|FReg) -> True|False :
    not contains?(values(register-table), r) and
    not contains?(temp-table, r)

  ;Returns a free register in the given category.
  defn free-register (r:AnyReg|AnyFReg) -> Reg|FReg :
    match(r) :
      (r:AnyReg) : find!(free-register?, seq(Reg,0 to num-regs))
      (r:AnyFReg) : find!(free-register?, seq(FReg,0 to num-fregs))

  ;Assign the given register to the given port.
  defn assign-register (v:Int, r:Reg|FReg) -> False :
    ;Sanity checks
    if not free-register?(r) : fatal("%_ is not free." % [r])
    if key?(register-table,v) : fatal("V%_ is already assigned." % [v])
    register-table[v] = r

  ;Assign the given register to the given temporary.
  defn assign-temp-register (index:Int, r:Reg|FReg) -> False :
    ;Sanity checks
    if not free-register?(r) : fatal("%_ is not free." % [r])
    if temp-table[index] is-not False : fatal("Temp %_ is already assigned." % [index])
    temp-table[index] = r

  ;Print the current contents of the register table.
  defn print-register-table () -> False :
    val items = for e in register-table seq :
      simple-field(to-string("V%_" % [key(e)]), value(e))
    println("Currently assigned registers%_" % [colon-field-list(items)])

  ;----------------------------------------------------------
  ;-------------------- Main Algorithm ----------------------
  ;----------------------------------------------------------

  ;Process the input ports.
  ;First assign registers for all the ports with preferred registers.
  val unassigned = Vector<Port>()
  for p in inputs(e) do :
    if loaded?(p) :
      println("Port %_ is loaded" % [id(p)])
      match(pref-reg(p)) :
        (r:Reg|FReg) :
          println("Port prefers register %_" % [r])
          if free-register?(r) :
            println("Assign register %_" % [r])
            assign-register(id(p), r)
          else :
            add(unassigned, p)
        (f:False) :
          println("Port has no preferred register.")
          add(unassigned, p)
  ;Next assign arbitrary registers to remaining ports.
  while not empty?(unassigned) :
    val p = pop(unassigned)
    val r = free-register(register-category(p))
    assign-register(id(p), r)

  ;Print the currently assigned registers.
  print-register-table()

  ;Record the final registers that were assigned.
  val new-input-ports = to-tuple $ for p in inputs(e) seq :
    sub-assigned-reg(p, register-table[id(p)])
  set-contents(inputs(e), new-input-ports)

  ;Print the new input ports.
  println("New input ports%_" % [colon-field-list(inputs(e))])

  ;Scan through the instructions.
  within (i, stmt, emit) = process-instructions(e) :
    println("Process: %_" % [stmt])
    match(stmt) :
      (stmt:AnnotatedOperationStmt) :
        ;Initialize temp registers to initially unassigned.
        clear(temp-table)
        lengthen(temp-table, num-temp(e,stmt), false)

        ;Retrieve:
        ;- args: The argument variables to the operation.
        ;- arg-input-regs: The registers they are currently in.
        ;- arg-output-regs: The locations they need to be in.
        ;And determine whether a straightforward assignment
        ;will work.
        val args = args(stmt)
        val arg-input-regs = map({register-table[_]}, args)
        val arg-output-regs = arg-registers(e, stmt)

        ;Perform what is necessary to move arguments to the
        ;right registers. And get final position of arguments.
        val arg-final-regs = match(needs-shuffle?(arg-input-regs, arg-output-regs)) :
          (status:AlreadyInPosition) :
            arg-input-regs
          (status:UseNaiveMoves) :
            fatal("Not yet implemented")
          (status:UseShuffle) :
            fatal("Not yet implemented")

        ;Now process each of the model statements.
        process-model{_, e, stmt} $ new ModelProcessor :
          defmethod release-temp (this, index:Int) :
            ;Sanity check: Ensure that the temporary was assigned.
            if temp-table[index] is False :
              fatal("Temporary %_ was not assigned." % [index])
            ;Remove the assigned register from the temporary.
            temp-table[index] = false
          defmethod release (this, v:Int) :
            ;Sanity check: Ensure that the variable was assigned.
            if not key?(register-table, v) :
              fatal("Variable V%_ was not assigned." % [v])
            ;Remove the assigned register from that variable.
            remove(register-table, v)
            false
          defmethod assign-temp (this, index:Int, loc:Location, pref:Preference) :
            fatal("Not yet implemented")
;            ;Retrieve the most appropriate register
;            ;[TODO] We need a taboo list so that temporary variables
;            ;that can be assigned anywhere don't get assigned to registers
;            ;that are required by other temporaries.
;            val reg = free-register(loc)
;            ;If it is free, then we can just assign it.
;            if free-register?(reg) :
;              temp-table[index] = reg
;            ;Otherwise, we have to relocate the old contents.
;            else :
;              ;Retrieve the variable that is currently in that register.
;              val v = var-in-register(reg)
;
;              ;Retrieve a fresh free register to relocate the variable to.
;              val new-reg = free-register(generalize(loc))
;              
;              ;Relocate the old contents to there.
;              emit(Relocate(v, reg, new-reg))
;              register-table[v] = new-reg
;
;              ;Now the old register is free to be used
;              ;for the temporary.
;              temp-table[index] = reg            

          defmethod assign (this, id:Int, loc:Location, pref:Preference) :
            fatal("Not yet implemented")
;            ;Retrieve the most appropriate register.
;            ;[TODO] We need a taboo list so that result variables
;            ;that can be assigned anywhere don't get assigned to registers
;            ;that are required by other results.
;            val reg = free-register(loc)
;            ;If it is free, then we can just assign it.
;            if free-register?(reg) :
;              register-table[id] = reg
;            ;Otherwise, we have to relocate the old contents.
;            else :
;              ;Retrieve the variable that is currently in that register.
;              val v = var-in-register(reg)
;
;              ;Retrieve a fresh free register to relocate the variable to.
;              val new-reg = free-register(generalize(loc))
;              
;              ;Relocate the old contents to there.
;              emit(Relocate(v, reg, new-reg))
;              var-in-register[v] = new-reg
;
;              ;Now the old register is free to be used
;              ;for the temporary.
;              register-table[id] = reg

            false


          defmethod clear-registers (this) :
            false

      (stmt:Save) :
        false
      (stmt:Unload) :
        ;Sanity check: Ensure that the variable is assigned.
        if not key?(register-table, arg(stmt)) :
          fatal("Variable V%_ is not assigned." % [arg(stmt)])
        ;Remove the assigned register from that variable.
        remove(register-table, arg(stmt))
      (stmt:Load) :
        false

;------------------------------------------------------------
;--------------------- Process a Model ----------------------
;------------------------------------------------------------

;Callbacks for processing the different actions of a model.
deftype ModelProcessor

;Release the temporary at index 'index'.
defmulti release-temp (proc:ModelProcessor, index:Int) -> False

;Release the variable register.
defmulti release (proc:ModelProcessor, id:Int) -> False

;Assign the temporary at index 'index'.
defmulti assign-temp (proc:ModelProcessor, index:Int, loc:Location, pref:Preference) -> False

;Assign the variable with id 'id'.
defmulti assign (proc:ModelProcessor, id:Int, loc:Location, pref:Preference) -> False

;Clear all of the registers.
defmulti clear-registers (proc:ModelProcessor) -> False

defn process-model (proc:ModelProcessor,
                    e:BlockEngine,
                    anno-stmt:AnnotatedOperationStmt) -> False :
  ;Retrieve the model.
  val op-stmt = stmt(anno-stmt)
  val model = models(e)[op-id(op-stmt)]

  ;Retrieve the index ranges of the different variables.
  val first-temp = length(results(model)) + length(args(model))
  val first-arg = length(results(model))
  val num-vars = length(results(model)) + length(args(model)) + length(temp(model))

  ;Return true if the given variable is a temp variable.
  defn temp? (v:Int) : v >= first-temp and v < num-vars

  ;Return true if the given variable is an arg variable.
  defn arg? (v:Int) : v >= first-arg and v < first-temp

  ;Return true if the given variable is a result variable.
  defn result? (v:Int) : v >= 0 and v < first-arg

  ;Return true if arg at index 'i' is killed in this
  ;operation.
  defn arg-killed? (i:Int) -> True|False :
    contains?(killed-args(anno-stmt), i)

  ;Return the id of the global argument variable at index 'i'.
  defn arg-var (i:Int) -> Int :
    args(op-stmt)[i]

  ;Return the id of the global result variable at index 'i'.
  defn result-var (i:Int) -> Int :
    results(op-stmt)[i]

  ;Return the index of the temp variable.
  defn temp-index (v:Int) : v - first-temp

  ;Return the index of the arg variable.
  defn arg-index (v:Int) : v - first-arg

  ;Return the index of the result variable.
  defn result-index (v:Int) : v

  ;Return true if the model calls clear-registers.
  defn model-clears-registers? () -> True|False :
    val props = model-properties(e)[op-id(op-stmt)]
    clears-registers?(props)

  ;Analyze the given preference, and update it
  ;to reflect the global variable ids.
  defn analyze (pref:Preference) -> Preference :
    match(pref:PreferSame) :
      if temp?(arg(pref)) :
        PreferSameAsTemp(temp-index(arg(pref)))
      else if arg?(arg(pref)) :
        val i = arg-index(arg(pref))
        PreferSame(arg-var(i))
      else :
        fatal("Invalid preference: %_" % [pref])
    else :
      pref

  ;Iterate through each statement and call
  ;the appropriate callbacks.
  for mstmt in stmts(model) do :
    match(mstmt) :
      (mstmt:Release) :
        if temp?(arg(mstmt)) :
          release-temp(proc, temp-index(arg(mstmt)))
        else :
          val i = arg-index(arg(mstmt))
          release(proc, arg-var(i)) when arg-killed?(i)
      (mstmt:Assign) :
        if temp?(arg(mstmt)) :
          assign-temp(proc,
                      temp-index(arg(mstmt)),
                      location(mstmt),
                      analyze(preference(mstmt)))
        else if arg?(arg(mstmt)) :
          val i = arg-index(arg(mstmt))
          assign(proc,
                 arg-var(i),
                 location(mstmt),
                 analyze(preference(mstmt)))
        else if result?(arg(mstmt)) :
          val i = result-index(arg(mstmt))
          assign(proc,
                 result-var(i),
                 location(mstmt),
                 analyze(preference(mstmt)))
        else :
          fatal("Invalid variable: V%_" % [arg(mstmt)])
      (mstmt:ClearRegisters) :
        clear-registers(proc)
      (mstmt:Return) :
        false

  ;Finish by releasing any other temp/arg variables,
  ;that hasn't explicitly been released.
  if not model-clears-registers?() :
    ;Compute all that has been released.
    val all-released = to-intset $
      seq(arg, filter-by<Release>(stmts(model)))

    ;Release any other temp that hasn't yet been released.
    for v in temp(model) do :
      if not all-released[v] :
        release-temp(proc, temp-index(v))

    ;Release any other killed arguments that hasn't already been
    ;released.
    for v in seq(id,args(model)) do :
      if not all-released[v] :
        val i = arg-index(v)
        release(proc, v) when arg-killed?(i)

;Prefer to be same as the temp for the operation.
defstruct PreferSameAsTemp <: Preference :
  index:Int

;------------------------------------------------------------
;--------------------- Utilities ----------------------------
;------------------------------------------------------------

;Returns true if the given port is loaded into a register.
defn loaded? (p:Port) -> True|False :
  val s = status(p) as PortStatus
  loaded(s) is Location

;Returns the register category that a port is in.
defn register-category (p:Port) -> AnyReg|AnyFReg :
  val s = status(p) as PortStatus
  loaded(s) as AnyReg|AnyFReg

;Fill in the final assigned register for the given port.
defn sub-assigned-reg (p:Port, r:Reg|FReg) -> Port :
  val s = status(p) as PortStatus
  val new-status = sub-loaded(s, r)
  sub-status(p, new-status)

;Helper: Set the contents of the given vector.
defn set-contents<?T> (vs:Vector<?T>, xs:Seqable<T>) :
  clear(vs)
  add-all(vs,xs)

;Return the argument variables to the operation.
defn args (op:AnnotatedOperationStmt) -> Tuple<Int> :
  args(stmt(op))

;Helper: Return the registers that the arguments are required
;to be in.
defn arg-registers (e:BlockEngine, op:AnnotatedOperationStmt) -> Tuple<Location> :
  val m = models(e)[op-id(stmt(op))]
  map(location, args(m))

;Helper: Return the number of temporary variables this
;operation has.
defn num-temp (e:BlockEngine, op:AnnotatedOperationStmt) -> Int :
  val m = models(e)[op-id(stmt(op))]
  length(temp(m))

;<comment>