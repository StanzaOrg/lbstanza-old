defpackage stz/type-gen-equations :
  import core
  import collections
  import stz/types
  import stz/tl-ir2
  import stz/il-to-tl
  import stz/dl-ir
  import stz/tl-to-dl2
  import stz/type-equations
  import stz/namemap
  import stz/ids
  import stz/tl-formatter
  import stz/type-locs
  import stz/type-hierarchy

;============================================================
;================== Main Entry Point ========================
;============================================================

;Generate the type equations for the program.
public defn generate-type-equations (prog:TProg) -> False :

  within with-type-env() :
    ;Add top level definitions to typing environment.
    val packages-with-top-vars = map(add-top-level-variables, packages(prog))

    ;Add environment definitions to typing environment.
    within set-id-env(TypeIDEnv(namemap(prog))) :
      add-environment-types(environment(prog))

    val formatter = TLFormatter(prog)
    for p in packages-with-top-vars do :
      println(format(formatter, p))

    ;Set the active type hierarchy.
    let-var ACTIVE-TYPE-HIERARCHY = hierarchy(prog) :

      ;Collect type equations.
      val type-eqns = Vector<TypeEqn>()
      within collect-type-equations(type-eqns) :

        ;Generate equations for all packages.
        val packages-with-eqns = map(gen-equations, packages-with-top-vars)

        println("GENERATED TYPE EQUATIONS!")
        for p in packages-with-eqns do :
          println(format(formatter, p))

        for e in type-eqns do :
          println(format(formatter, e))

  fatal("Not yet implemented")

;============================================================
;=================== Type Environment =======================
;============================================================

;Each entry, V => T, means that the variable V has type
;type T.
var TYPE-ENV:IntTable<Type|LSType>|False = false

;Execute the body with an active type environment.
defn with-type-env<?T> (body:() -> ?T) -> T :
  let-var TYPE-ENV = IntTable<Type|LSType>() :
    body()

;Retrieve the active type environment.
defn type-env! () -> IntTable<Type|LSType> :
  if TYPE-ENV is False :
    fatal("No active type environment.")
  TYPE-ENV as IntTable<Type|LSType>

;Set the type of a variable.
defn set-type (n:Int, t:Type|LSType) -> False :
  val env = type-env!()
  if key?(env,n) :
    fatal("Type already set in environment for variable %_." % [n])
  env[n] = t

;Retrieve the HiStanza type of a variable.
defn get-type (n:Int) -> Type|LSType :
  type-env!()[n]

;============================================================
;=================== Type Hierarchy =========================
;============================================================

;The currently active type hierarchy.
var ACTIVE-TYPE-HIERARCHY:TypeHierarchy|False = false

;Retrieve the currently active type hierarchy.
defn type-hierarchy () -> TypeHierarchy :
  match(ACTIVE-TYPE-HIERARCHY) :
    (h:TypeHierarchy) : h
    (f:False) : fatal("No active type hierarchy set.")

;============================================================
;================ Collect Type Equations ====================
;============================================================

;Hold all the generated type equations.
var TYPE-EQNS:Vector<TypeEqn>|False = false

;Execute a body with an active type equation list.
defn collect-type-equations<?T> (body:() -> ?T, eqns:Vector<TypeEqn>) -> T :
  let-var TYPE-EQNS = eqns :
    body()

;Add a new type equation to solve.
defn add-equation (eqn:TypeEqn) -> False :
  match(TYPE-EQNS) :
    (eqns:Vector<TypeEqn>) : add(eqns, eqn)
    (f:False) : fatal("No active type equation list.")

;Helper: Generate equality constraint a = b if a is a
;TUVar.
defn add-equal? (a:Type, b:Type) -> False :
  match(a:TUVar) :
    add-equation(EqualEqn(n(a), b))

;Helper: Generate super constraint a :> b if a is a
;TUVar.
defn add-super? (a:Type, b:Type) -> False :
  match(a:TUVar) :
    add-equation(SuperEqn(n(a), b))

;============================================================
;================= Top Level Variables ======================
;============================================================

;Simultaneously adds type variables to top-level commands,
;and also adds types to the type environment.
defn add-top-level-variables (p:TPackage) -> TPackage :    
  sub-comms(p, map(add-top-level-variables, comms(p)))

;Simultaneously adds type variables to top-level commands,
;and also adds types to the type environment.
defn add-top-level-variables (comm:TComm) -> TComm :
  match(comm) :
    (c:TDef) :
      sub-type(c, gen-var(n(c), type(c)))
    (c:TDefTuple) :
      val new-types = seq(gen-var, ns(c), types(c))
      sub-types(c, to-tuple(new-types))
    (c:TDefVar) :
      sub-type(c, gen-var(n(c), type(c)))
    (c:TDefn) :
      val new-a1 = map(or-gradual, a1(c))
      val new-a2 = or-var(a2(c))
      val new-a1-args = map(to-farg, new-a1)
      val new-type = TFunction(targs(c), cargs(c), new-a1-args, new-a2)
      set-type(n(c), new-type)
      c $> sub-a1{_, new-a1}
        $> sub-a2{_, new-a2}
    (c:TDefmulti) :
      val new-a1 = map(or-gradual, a1(c))
      val new-a2 = or-gradual(a2(c))
      val new-a1-args = map(to-farg, new-a1)
      val new-type = TFunction(targs(c), cargs(c), new-a1-args, new-a2)
      set-type(n(c), new-type)
      c $> sub-a1{_, new-a1}
        $> sub-a2{_, new-a2}
    (c:TLDef) :
      set-type(n(c), type(c))
      c
    (c:TLDefVar) :
      set-type(n(c), type(c))
      c
    (c:TLDefn) :
      fatal("Old code")
;      val a1-args = map(LSPositionalArg{false, _}, a1(c))
;      val type = TLSFunction(targs(c), cargs(c), a1-args, a2(c))
;      set-type(n(c), type)
;      c
    (c:TLExternFn) :
      fatal("Old code")
;      val a1-args = map(LSPositionalArg{false, _}, a1(c))
;      val type = TLSFunction([], [], a1-args, a2(c))
;      set-type(n(c), type)
;      c
    (c:TExtern) :
      set-type(n(c), type(c))
      c
    (c) :
      c

;============================================================
;==== Add Environment Definitions to Type Environment =======
;============================================================

;Add the types of the environment definitions to the type
;environment.
defn add-environment-types (env:Tuple<Export>) -> False :

  ;Helper: Create a TFunction from a FnId.
  defn to-fn-type (id:FnId, a2:DType) -> TFunction :
    val tvars = to-tuple(0 to ntargs(id))
    val cvars = to-tuple(ntargs(id) to ntargs(id) + ncargs(id))
    val targs = to-tuple(seq(TVar{_, false}, cat(tvars,cvars)))
    val new-a1 = map(to-type{_, targs}, a1(id))
    val new-a2 = to-type(a2, targs)
    val a1-args = map(PositionalArg{false, _}, new-a1)
    TFunction(tvars, cvars, a1-args, new-a2)

  ;Helper: Create a TLSFunction from a FnId.
  defn to-lsfn-type (id:FnId, a2:DType) -> TLSFunction :
    fatal("Old code")
;    val tvars = to-tuple(0 to ntargs(id))
;    val cvars = to-tuple(ntargs(id) to ntargs(id) + ncargs(id))
;    val targs = to-tuple(seq(TVar{_, false}, cat(tvars,cvars)))
;    val new-a1 = map(to-lstype{_, targs}, a1(id))
;    val new-a2 = to-lstype(a2, targs)
;    val a1-args = map(LSPositionalArg{false, _}, new-a1)
;    TLSFunction(tvars, cvars, a1-args, new-a2)

  ;Loop through each environment entry and add them
  ;to the typing environment.
  for e in env do :
    val type = match(rec(e)) :
      (r:ValRec) :
        if lostanza?(r) : to-lstype(type(r), [])
        else : to-type(type(r), [])
      (r:FnRec) :
        if lostanza?(r) : to-lsfn-type(id(r) as FnId, a2(r))
        else : to-fn-type(id(r) as FnId, a2(r))
      (r:MultiRec) :
        to-fn-type(id(r) as FnId, a2(r))
      (r:ExternFnRec) :
        to-lsfn-type(id(r) as FnId, a2(r))
      (r:ExternRec) :
        to-lstype(type(r), [])
      (r:StructRec) : false
      (r:TypeRec) : false
      (r:TypeDecl) : false
      (r) : false
    match(type:Type|LSType) :
      set-type(n(e), type)

;Extract DL identifier environment from NameMap.
;Used for to-deftype function.
defn TypeIDEnv (namemap:NameMap) -> IDEnv :
  val table = to-hashtable<TypeId,Int> $
    for e in toplevel(namemap) seq? :
      if type(e) is TypeE|LTypeE :
        One(TypeId(package(e), name(e)) => n(e))
      else :
        None()
  new IDEnv :
    defmethod get (this, id:TypeId) : table[id]

;============================================================
;================ Generate Type Equations ===================
;============================================================

;Generate equations for the given package.
defn gen-equations (p:TPackage) -> TPackage :
  val new-comms = map(gen-equations, comms(p))
  sub-comms(p, new-comms)

;Generate equations for the given command.
defn gen-equations (c:TComm) -> TComm :
  match(c) :
  
    (c:TDef) :
      val value-ctxt = ExpCtxt(or-top(type(c) as Type))
      val new-value = gen-equations(value(c), value-ctxt)
      TDef(info(c), n(c), type(c), new-value)

    (c:TDefTuple) :
      ;Sanity check: either all types are given, or none are given.
      if not (all?({_ is TUVar}, types(c)) or
              none?({_ is TUVar}, types(c))) :
        fatal("Illegal type annotations on tuple.")

      ;Are types inferred or explicit?
      val inferred? = all?({_ is TUVar}, types(c))

      ;If inferred types, then generate equations.
      if inferred? :
        val value-ctxt = ExpCtxt(TTop())
        val new-value = gen-equations(value(c), value-ctxt)
        val arity = length(ns(c))
        for (v in types(c), i in 0 to false) do :
          add-equation $ InferEqn(n(v as TUVar),
                                  type!(new-value), TupleLoc(arity, i))
        TDefTuple(info(c), ns(c), types(c), new-value)
      
      ;Otherwise, it's easy.
      else :
        val value-ctxt = ExpCtxt(TTuple(types(c) as Tuple<Type>))
        val new-value = gen-equations(value(c), value-ctxt)
        TDefTuple(info(c), ns(c), types(c), new-value)

    (c:TDefVar) :
      val new-value = match(value(c)) :
        (v:TExp) :
          val value-ctxt = ExpCtxt(or-top(type(c) as Type))
          val new-v = gen-equations(v, value-ctxt)
          add-super?(type(c) as Type, type!(new-v))
        (f:False) :
          false
      TDefVar(info(c), n(c), type(c), new-value)
      
    (c:TDefn) :
      ;Add arguments to the environment.
      do(set-type, args(c), seq(type!, a1(c)))
      ;Generate equations for body.
      val body-ctxt = ExpCtxt(or-top(a2!(c)))
      val new-body = gen-equations(body(c), body-ctxt)
      add-equal?(a2!(c), type!(new-body))
      sub-body(c, new-body)
      
    (c:TDefmethod) :
      gen-method(c, None())
      
    (c:TInit) :
      val new-exp = gen-equations(exp(c), ExpCtxt(TTop()))
      TInit(info(c), new-exp)
      
    (c:TLDefType) :
      fatal("gen-equations for TLDefType")
    (c:TLDef) :
      fatal("gen-equations for TLDef")
    (c:TLDefVar) :
      fatal("gen-equations for TLDefVar")
    (c:TLDefn) :
      fatal("gen-equations for TLDefn")
    (c:TLExternFn) :
      fatal("gen-equations for TLExternFn")
    (c:TLDefmethod) :
      fatal("gen-equations for TLDefmethod")
    (c:TLInit) :
      fatal("gen-equations for TLInit")
    (c) :
      c

;Generate equations for the given expression.
defn gen-equations (e:TExp, ctxt:Context) -> TExp :
  match(e) :

    (e:TLet) :
      val new-type = gen-var(n(e), ntype(e))
      val value-ctxt = ExpCtxt(or-top(ntype(e)))
      val new-value = gen-equations(value(e), value-ctxt)
      add-equal?(new-type, type!(new-value))
      val new-body = gen-equations(body(e), ctxt)
      TLet(info(e), type!(new-body), ctxt,
           n(e), new-type, new-value, new-body)

    (e:TLetVar) :
      val new-type = gen-var(n(e), ntype(e))
      val new-value = match(value(e)) :
        (v:TExp) :
          val value-ctxt = ExpCtxt(or-top(ntype(e)))
          val new-v = gen-equations(v, value-ctxt)
          add-super?(new-type, type!(new-v))
          new-v
        (f:False) :
          false
      val new-body = gen-equations(body(e), ctxt)
      TLetVar(info(e), type!(new-body), ctxt,
              n(e), new-type, new-value, new-body)

    (e:TLetTuple) :
      ;Sanity check: either all types are given, or none are given.
      if not all?({_ is Type}, ntypes(e)) and
         not all?({_ is False}, ntypes(e)) :
        fatal("Illegal type annotations on tuple.")

      ;Are types inferred or explicit?
      val inferred? = any?({_ is False}, ntypes(e))

      ;If inferred types, then generate equations.
      if inferred? :
        val new-types = to-tuple(seq(gen-var, ns(e), ntypes(e))) as Tuple<TUVar>
        val new-value = gen-equations(value(e), ExpCtxt(TTop()))
        val new-body = gen-equations(body(e), ctxt)
        val arity = length(ns(e))
        for (v in new-types, i in 0 to false) do :
          add-equation $ InferEqn(n(v), type!(new-value), TupleLoc(arity,i))
        TLetTuple(info(e), type!(new-body), ctxt, ns(e), ntypes(e), new-value, new-body)

      ;Otherwise, it's easy.
      else :
        val value-ctxt = ExpCtxt(TTuple(ntypes(e) as Tuple<Type>))
        val new-value = gen-equations(value(e), value-ctxt)
        val new-body = gen-equations(body(e), ctxt)
        TLetTuple(info(e), type!(new-body), ctxt, ns(e), ntypes(e), new-value, new-body)

    (e:TLetRec) :
      ;Add the defn types to the environment.
      val defns* = map({add-top-level-variables(_) as TDefn}, defns(e))
      ;Generate equations for bodies of defns.
      val new-defns = map({gen-equations(_) as TDefn}, defns*)
      ;Generate equations for body.
      val new-body = gen-equations(body(e), ctxt)
      ;Return new letrec
      TLetRec(info(e), type!(new-body), ctxt, new-defns, new-body)
      
    (e:TFn) :

      ;Generate type variables
      val new-a1 = to-tuple(seq(gen-var, args(e), a1(e)))
      val new-a2 = or-var(a2(e))

      ;The body context has three cases.
      ;Case: When return type is explicitly provided.
      ;  Then context is ExpCtxt(a2)
      ;Case: When return type is inferred, and the current context is ExpCtxt(T).
      ;  Then context is ExpCtxt(R) where R is inferred from 'T'.
      ;Case: When return type is inferred, and the current context is CallCtxt.
      ;  Then context is ExpCtxt(TTop()).
      val body-ctxt = match(a2(e), ctxt) :
        (a2:Type, ctxt) :
          ExpCtxt(a2)
        (a2:False, ctxt:ExpCtxt) :
          val r = fresh-tuvar()
          val arity = length(a1(e))
          add-equation $ InferEqn(n(r), ReturnLoc(arity), expected(ctxt))
          ExpCtxt(r)
        (a2:False, ctxt:CallCtxt) :
          ExpCtxt(TTop())
      val new-body = gen-equations(body(e), body-ctxt)

      ;Now we know the return type.
      add-equal?(new-a2, type!(new-body))

      ;Return the function
      val new-type = TArrow(new-a1, new-a2)
      TFn(info(e), new-type, ctxt,
          tail?(e), new-a1, new-a2, args(e), new-body)
          
    (e:TMulti) :
      val new-funcs = for f in funcs(e) map :
        gen-equations(f, ctxt) as TFn
      val new-type = reduce(TAnd, seq(type!, new-funcs))
      TMulti(info(e), new-type, ctxt, new-funcs)
      
    (e:TSeq) :
      val new-a = gen-equations(a(e), ExpCtxt(TTop()))
      val new-b = gen-equations(b(e), ctxt)
      TSeq(info(e), type!(new-b), ctxt, new-a, new-b)
      
    (e:TMatch) :
      ;Analyze the arguments first.
      val new-args = for a in args(e) map :
        gen-equations(a, ExpCtxt(TTop()))

      ;For each branch, compute the body.
      val new-branches = for b in branches(e) map :
        ;Put the argument types in the environment.
        val arg-types = to-tuple $ for (a in args(b), t in atypes(b), ma in new-args) seq :
          val new-type = gen-var(a, t)
          add-equal?(new-type, type!(ma))
          new-type
        ;Analyze the body
        val new-body = gen-equations(body(b), ctxt)
        ;Form the new branch.
        TBranch(info(b), type!(new-body), ctxt, args(b), arg-types, new-body)

      ;Form the match.
      val new-type = reduce(TOr, seq(type!, new-branches))
      TMatch(info(e), new-type, ctxt, new-args, new-branches)
      
    (e:TNew) :    
      val new-methods = for m in methods(e) map :
        gen-method(m, One(class(e)))
      TNew(info(e), class(e), ctxt, class(e), new-methods)
      
    (e:TRef) :
      if get-type(n(e)) is TFunction|TLSFunction :
        gen-mix(e,ctxt)
      else :
        match(typed-ref(e,ctxt)) :
          (r:TRef) : r
          (f:False) : TRef(info(e), unsatisfiable-tuvar(), ctxt, n(e))
        
    (e:TCast) :
      val new-exp = gen-equations(exp(e), ExpCtxt(TTop()))
      TCast(info(e), targ(e), ctxt, new-exp, targ(e))
      
    (e:TUpCast) :
      val new-exp = gen-equations(exp(e), ExpCtxt(targ(e)))
      TUpCast(info(e), targ(e), ctxt, new-exp, targ(e))
      
    (e:TSet) :
      ;Retrieve the ref of the variable.
      val new-ref = typed-ref(ref(e), ExpCtxt(TTop()))

      ;Process the value.
      val value-ctxt =
        match(new-ref:TRef) : ExpCtxt(or-top(type!(new-ref)))
        else : ExpCtxt(TTop())
      val new-value = gen-equations(value(e), value-ctxt)

      ;Generate the super constraint.
      match(new-ref:TRef) :
        add-super?(type!(new-ref), type!(new-value))

      ;Create the false type
      val false-n = special-type(type-hierarchy(), CoreFalse)
      val false-type = TOf(false-n, [])

      ;Return the new data.
      match(new-ref:TRef) :
        TSet(info(e), false-type, ctxt, new-ref, new-value)
      else :
        val new-ref = TRef(info(ref(e)), unsatisfiable-tuvar(), ExpCtxt(TTop()), n(ref(e)))
        TSet(info(e), false-type, ctxt, new-ref, new-value)
      
    (e:TDo) :
      ;Gen equations for arguments using tuvar for expected types.
      val expected-arg-types = fresh-tuvars(length(args(e)))
      val new-args = to-tuple $
        for (arg in args(e), et in expected-arg-types) seq :
          val new-value = gen-equations(value(arg), ExpCtxt(et))
          TArg(keyword(arg), new-value)
          
      ;Gen equations for func now that we have argument types.
      val func-ctxt = CallCtxt(targs(e), map(to-farg, new-args))
      val new-func = gen-equations(func(e), func-ctxt)

      ;Infer return type from function type.
      val ret-type = fresh-tuvar()
      add-equation $ InferEqn(n(ret-type), type!(new-func), ReturnLoc(length(new-args)))
      
      ;Infer expected argument types from function type.
      for (et in expected-arg-types, i in 0 to false) do :
        add-equation $ InferEqn(n(et), type!(new-func), ArgLoc(length(new-args), i))
        
      ;Return new data.
      TDo(info(e), ret-type, ctxt, new-func, targs(e), new-args)
      
    (e:TPrim) :
      fatal("gen-equations TPrim")
      
    (e:TLiteral) :
      ;Retrieve the SpecialType that the value corresponds to.
      val special = match(value(e)) :
        (v:Byte) : CoreByte
        (v:Char) : CoreChar
        (v:Int) : CoreInt
        (v:Long) : CoreLong
        (v:Float) : CoreFloat
        (v:Double) : CoreDouble
        (v:String) : CoreString
        (v:Symbol) : CoreSymbol
        (v:List) : CoreList
        (v:True) : CoreTrue
        (v:False) : CoreFalse
        (v) : fatal("%_ is an unsupported literal type." % [object-type(v)])
      ;Create the type.
      val hier = type-hierarchy()
      val n = special-type(hier, special)
      val arity = type-arity(hier, n)
      val value-type = TOf(n, to-tuple(repeat(TGradual(), arity)))
      ;Return bundled data.
      TLiteral(info(e), value-type, ctxt, value(e))
      
    (e:TTupleExp) :
      ;Generate contexts for the individual expressions.
      val arity = length(exps(e))
      val exp-ctxts = match(ctxt) :
        (ctxt:ExpCtxt) :
          val vars = fresh-tuvars(arity)
          for (v in vars, i in 0 to false) do :
            add-equation $ InferEqn(n(v), TupleLoc(arity,i), expected(ctxt))
          map(ExpCtxt, vars)
        (ctxt:CallCtxt) :
          to-tuple(repeat(ExpCtxt(TTop()), arity))
      ;Generate equations for expressions.
      val new-exps = to-tuple $
        for (e in exps(e), ctxt in exp-ctxts) seq :
          gen-equations(e, ctxt)
      ;Return new data.
      val new-type = TTuple(map(type!, new-exps))
      TTupleExp(info(e), new-type, ctxt, new-exps)

    (e:TMix) :
      gen-mix(e,ctxt)

;Generate equations for the given method.
defn gen-method (m:TDefmethod, thist:Maybe<Type>) -> TDefmethod :
  ;Compute the a1 types.
  val new-a1 = to-tuple $
    for (arg in args(m), t in a1(m)) seq :
      val new-type = 
        if arg == thisn(m) :
          match(type(t)) :
            (t:Type) : t
            (f:False) : value!(thist)
        else :
          or-gradual(type(t))
      sub-type(t,new-type)
      
  ;Compute the a2 type.
  val new-a2 = or-var(a2(m))
  
  ;Store the args into the type environment.
  do(set-type, args(m), seq(type!,new-a1))

  ;Compute the body in the right context.
  val body-ctxt = ExpCtxt(or-top(new-a2))
  val new-body = gen-equations(body(m), body-ctxt)
  add-equal?(new-a2, type!(new-body))

  ;Return new method with filled types.
  TDefmethod(info(m), tail?(m), n(m), multi(m),
             thisn(m), targs(m), cargs(m),
             new-a1, new-a2, args(m), new-body)

;Generate equations for the given expression.
defn gen-equations (e:LSExp, ctxt:LSContext) -> LSExp :
  match(e) :
    (e) :
      e

;============================================================
;================= Function Equations =======================
;============================================================

;Generate the mixed function from the given reference.
;Assumes that the TRef refers to a function definition.
defn gen-mix (func:TRef|TMix, ctxt:Context) -> TMix :
  match(func, ctxt) :
    ;Treat a single reference identically to a mix of one reference.
    (func:TRef, ctxt) :
      gen-mix(TMix(info(func), false, [func], false, false), ctxt)
      
    ;Instantiate the mixed functions in a calling context.
    (func:TMix, ctxt:CallCtxt) :
      ;Annotate each of the refs with types.
      val typed-refs = map(typed-ref?{_, ctxt}, refs(func))

      ;Instantiate the refs if they were typed correctly.
      val instfns? = for r in typed-refs seq :
        match(type(r):TFunction) :
          instantiate(r, ctxt)
      val instfns = to-tuple(filter-by<InstantiatedFn>(instfns?))

      ;Add the overloading equation to solve for the final mixed type.
      val mixed-type = fresh-tuvar()
      val mix-sel = fresh-svar()
      add-equation $ OverloadCallEqn(
        n(mixed-type),
        n(mix-sel),
        map(type,instfns),
        map(type,fargs(ctxt)))
          
      ;Return the final mix.
      TMix(info(func), mixed-type, ctxt, typed-refs, mix-sel, InstFns(instfns))

    ;Instantiate the mixed functions in an expression context.
    (func:TMix, ctxt:ExpCtxt) :
      ;Annotate each of the refs with types.
      val typed-refs = map(typed-ref?{_, ctxt}, refs(func))

      ;Add the overloading equation to solve for the final mixed type.
      val mixed-type = fresh-tuvar()
      val mix-sel = fresh-svar()
      val inst-var = fresh-instvar()
      val functions = to-tuple $ filter-by<TFunction>(seq(type, typed-refs))
      add-equation $ OverloadExpEqn(
        n(mixed-type),
        n(mix-sel),
        n(inst-var),
        functions,
        None(),
        expected(ctxt))

      ;Return the final mix.
      TMix(info(func), mixed-type, ctxt, typed-refs, mix-sel, inst-var)

;Instantiate a function within a calling context.
defn instantiate (f:TRef, ctxt:CallCtxt) -> InstantiatedFn|False :
  val ft = type!(f) as TFunction
  val inst = instantiate(ft, length(targs(ctxt)), fargs(ctxt))
  match(inst:FnInst) :      
    ;Create the variables for the captures.
    val capvars = fresh-tuvars(length(cargs(ft)))

    ;Substitute the given types to get the actual argument types.
    val env = to-tuple $ cat(seq(KeyValue, targs(ft), targs(ctxt))
                             seq({_ => n(_)}, cargs(ft), capvars))

    ;Retrieve the instantiated arrow.
    val tuple-n = special-type(type-hierarchy(), CoreTuple)
    val arrow = arrow(ft, inst, tuple-n)

    ;Fast track: non-polymorphic function. No substitutions or
    ;capturing necessary.
    if empty?(env) :
      InstantiatedFn(n(f), inst, [], arrow)

    ;Perform substitutions and capturing.
    else :

      ;Substitute env to compute new a1.
      val new-a1 = sub-caps(a1(arrow), env)

      ;Perform any necessary capturing.
      if not empty?(capvars) :
        add-equation $ CaptureAllEqn(
          map(n,capvars),
          TTuple(map(type,fargs(ctxt))),
          TTuple(new-a1))

      ;Perform a substitution for the return type, if the
      ;return type is not fully known. During equation generation time
      ;there are only two cases: either the return type was provided explicitly
      ;by the user, or a TUVar has been generated for it.
      val subenv = to-tuple $ cat(seq(KeyValue, /targs(ft), targs(ctxt))
                                  seq(KeyValue, /cargs(ft), capvars))
      val new-a2 = match(a2(arrow)) :
        ;Case: Inferred return type.
        (a2:TUVar) :
          val v = fresh-tuvar()
          add-equation $ SubEqn(n(v), a2, subenv)
          v
        ;Case: Explicit return type.
        (a2:Type) :
          sub(a2, subenv)

      ;Return the instantiated arrow.
      val new-arrow = TArrow(new-a1, new-a2)
      InstantiatedFn(n(f), inst, capvars, new-arrow)

;Retrieve the HiStanza type of a curried ref.
;Type is allowed to be a TFunction.
;Returns false if ref cannot be referenced from a HiStanza context.
defn typed-ref (e:TRef, ctxt:Context) -> TRef|False :
  match(get-type(n(e))) :
    (t:Type) :
      TRef(info(e), t, ctxt, n(e))
    (t:LSType) :
      fatal("Not yet implemented")

;Returns the typed ref of e. If it cannot be referenced from a
;HiStanza context, then returns the original ref.
defn typed-ref? (e:TRef, ctxt:Context) -> TRef :
  match(typed-ref(e,ctxt)) :
    (r:TRef) : r
    (f:False) : e

;============================================================
;======== Small Variable Generation Utilities ===============
;============================================================

;Convert a TArg into an FArg. 
defn to-farg (a:TArg) -> FArg :
  match(keyword(a)) :
    (f:False) : PositionalArg(false, type!(value(a)))
    (name:Symbol) : KeywordArg(name, false, type!(value(a)))

;Returns true if a and b have the same length.
defn same-length? (a:Tuple, b:Tuple) -> True|False :
  length(a) == length(b)

;Convert to an FArg assuming that types have been filled in.
defn to-farg (a:FArg?) -> FArg : 
  match(a) :
    (a:PositionalArg?) : PositionalArg(optional?(a), type!(a))
    (a:KeywordArg?) : KeywordArg(name(a), optional?(a), type!(a))
    (a:VarArg?) : VarArg(name(a), type!(a))

;Create a fresh selection variable.
defn fresh-svar () -> SVar :
  SVar(fresh-id())

;Create a fresh instantiation variable.
defn fresh-instvar () -> InstVar :
  InstVar(fresh-id())

;Create a fresh tuvar.
defn fresh-tuvar () -> TUVar :
  TUVar(fresh-id())
defn fresh-tuvars (n:Int) -> Tuple<TUVar> :
  to-tuple(seq(fresh-tuvar{}, 0 to n))

;Create an id with an unsatisfiable equation.
defn unsatisfiable-var () -> Int :
  val v = fresh-id()
  add-equation $ UnsatisfiableEqn(v)
  v

;Create a uvar with an unsatisfiable equation.
defn unsatisfiable-tuvar () -> TUVar :
  TUVar(unsatisfiable-var())

;Return a gradual when false.
defn or-gradual (f:False) : TGradual()
defn or-gradual (t:Type) : t
defn or-gradual (a:FArg?) : sub-type(a, or-gradual(type(a)))

;Return a type variable when false.
defn or-var (f:False) : fresh-tuvar()
defn or-var (t:Type) : t

;Return a Top when false or TUVar.
;Used for generating contexts.
defn or-top (f:False) : TTop()
defn or-top (t:Type) : TTop() when t is TUVar else t

;Generate a type variable for 't', and also
;set it in the type environment.
defn gen-var (n:Int, t:Type|False) -> Type :
  val new-type = or-var(t)
  set-type(n, new-type)
  new-type