defpackage stz/type-gen-equations :
  import core
  import collections
  import stz/types
  import stz/tl-ir2
  import stz/il-to-tl
  import stz/dl-ir
  import stz/tl-to-dl2
  import stz/type-equations
  import stz/namemap
  import stz/ids
  import stz/tl-formatter

;============================================================
;================== Main Entry Point ========================
;============================================================

;Generate the type equations for the program.
public defn generate-type-equations (prog:TProg) -> False :

  within with-type-env() :
    ;Add top level definitions to typing environment.
    val packages-with-top-vars = map(add-top-level-variables, packages(prog))

    ;Add environment definitions to typing environment.
    within set-id-env(TypeIDEnv(namemap(prog))) :
      add-environment-types(environment(prog))

    val formatter = TLFormatter(prog)
    for p in packages-with-top-vars do :
      println(format(formatter, p))

  fatal("Not yet implemented")

;============================================================
;=================== Type Environment =======================
;============================================================

var TYPE-ENV:IntTable<Type|LSType>|False = false

;Execute the body with an active type environment.
defn with-type-env<?T> (body:() -> ?T) -> T :
  let-var TYPE-ENV = IntTable<Type|LSType>() :
    body()

;Retrieve the active type environment.
defn type-env! () -> IntTable<Type|LSType> :
  if TYPE-ENV is False :
    fatal("No active type environment.")
  TYPE-ENV as IntTable<Type|LSType>

;Set the type of a variable.
defn set-type (n:Int, t:Type|LSType) -> False :
  val env = type-env!()
  if key?(env,n) :
    fatal("Type already set in environment for variable %_." % [n])
  env[n] = t

;Retrieve the HiStanza type of a variable.
defn get-type (n:Int) -> Type :
  match(type-env!()[n]) :
    (t:Type) : t
    (t:LSType) : fatal("Variable %_ expected to have HiStanza type." % [n])

;Retrieve the LoStanza type of a variable.
defn get-lstype (n:Int) -> LSType  :
  match(type-env!()[n]) :
    (t:LSType) : t
    (t:Type) : fatal("Variable %_ expected to have LoStanza type." % [n])

;Add a new type equation to solve.
defn add-equation (eqn:TypeEqn) -> False :
  fatal("Not yet implemented")

;============================================================
;================= Top Level Variables ======================
;============================================================

;Simultaneously adds type variables to top-level commands,
;and also adds types to the type environment.
defn add-top-level-variables (p:TPackage) -> TPackage :
  val new-comms = for comm in comms(p) map :
    match(comm) :
      (c:TDef) :
        sub-type(c, gen-var(n(c), type(c)))        
      (c:TDefTuple) :
        val new-types = seq(gen-var, ns(c), types(c))
        sub-types(c, to-tuple(new-types))
      (c:TDefVar) :
        sub-type(c, gen-var(n(c), type(c)))                
      (c:TDefn) :
        val new-a1 = map(or-gradual, a1(c))
        val new-a2 = or-var(a2(c))
        val new-a1-args = map(PositionalArg{false, _}, new-a1)
        val new-type = TFunction(targs(c), cargs(c), new-a1-args, new-a2)
        set-type(n(c), new-type)
        c $> sub-a1{_, new-a1}
          $> sub-a2{_, new-a2}
      (c:TDefmulti) :
        val new-a1 = map(or-gradual, a1(c))
        val new-a2 = or-gradual(a2(c))
        val new-a1-args = map(PositionalArg{false, _}, new-a1)
        val new-type = TFunction(targs(c), cargs(c), new-a1-args, new-a2)
        set-type(n(c), new-type)
        c $> sub-a1{_, new-a1}
          $> sub-a2{_, new-a2}        
      (c:TLDef) :
        set-type(n(c), type(c))
        c
      (c:TLDefVar) :
        set-type(n(c), type(c))
        c
      (c:TLDefn) :
        val a1-args = map(LSPositionalArg{false, _}, a1(c))
        val type = TLSFunction(targs(c), cargs(c), a1-args, a2(c))
        set-type(n(c), type)
        c
      (c:TLExternFn) :
        val a1-args = map(LSPositionalArg{false, _}, a1(c))
        val type = TLSFunction([], [], a1-args, a2(c))
        set-type(n(c), type)
        c        
      (c:TExtern) :
        set-type(n(c), type(c))
        c
      (c) :
        c
  sub-comms(p, new-comms)

;Return a gradual when false.
defn or-gradual (f:False) : TGradual()
defn or-gradual (t:Type) : t

;Return a type variable when false.
defn or-var (f:False) : TUVar(fresh-id())
defn or-var (t:Type) : t

;Generate a type variable for 't', and also
;set it in the type environment.
defn gen-var (n:Int, t:Type|False) -> Type :
  val new-type = or-var(t)
  set-type(n, new-type)
  new-type

;============================================================
;==== Add Environment Definitions to Type Environment =======
;============================================================

;Add the types of the environment definitions to the type
;environment.
defn add-environment-types (env:Tuple<Export>) -> False :

  ;Helper: Create a TFunction from a FnId.
  defn to-fn-type (id:FnId, a2:DType) -> TFunction :
    val tvars = to-tuple(0 to ntargs(id))
    val cvars = to-tuple(ntargs(id) to ntargs(id) + ncargs(id))
    val targs = to-tuple(seq(TVar{_, false}, cat(tvars,cvars)))
    val new-a1 = map(to-type{_, targs}, a1(id))
    val new-a2 = to-type(a2, targs)
    val a1-args = map(PositionalArg{false, _}, new-a1)
    TFunction(tvars, cvars, a1-args, new-a2)

  ;Helper: Create a TLSFunction from a FnId.
  defn to-lsfn-type (id:FnId, a2:DType) -> TLSFunction :
    val tvars = to-tuple(0 to ntargs(id))
    val cvars = to-tuple(ntargs(id) to ntargs(id) + ncargs(id))
    val targs = to-tuple(seq(TVar{_, false}, cat(tvars,cvars)))
    val new-a1 = map(to-lstype{_, targs}, a1(id))
    val new-a2 = to-lstype(a2, targs)
    val a1-args = map(LSPositionalArg{false, _}, new-a1)
    TLSFunction(tvars, cvars, a1-args, new-a2)
    
  ;Loop through each environment entry and add them
  ;to the typing environment.
  for e in env do :
    val type = match(rec(e)) :
      (r:ValRec) :
        if lostanza?(r) : to-lstype(type(r), [])
        else : to-type(type(r), [])
      (r:FnRec) :
        if lostanza?(r) : to-lsfn-type(id(r) as FnId, a2(r))
        else : to-fn-type(id(r) as FnId, a2(r))
      (r:MultiRec) :
        to-fn-type(id(r) as FnId, a2(r))
      (r:ExternFnRec) :
        to-lsfn-type(id(r) as FnId, a2(r))
      (r:ExternRec) :
        to-lstype(type(r), [])
      (r:StructRec) : false
      (r:TypeRec) : false
      (r:TypeDecl) : false
      (r) : false
    match(type:Type|LSType) :
      set-type(n(e), type)

;Extract DL identifier environment from NameMap.
;Used for to-deftype function.
defn TypeIDEnv (namemap:NameMap) -> IDEnv :
  val table = to-hashtable<TypeId,Int> $
    for e in toplevel(namemap) seq? :
      if type(e) is TypeE|LTypeE :
        One(TypeId(package(e), name(e)) => n(e))
      else :
        None()
  new IDEnv :
    defmethod get (this, id:TypeId) : table[id]

;============================================================
;================ Generate Type Equations ===================
;============================================================

;Generate equations for the given command.
defn gen-equations (c:TComm) -> TComm :
  match(c) :
    (c:TDef) :
      fatal("gen-equations for TDef")
    (c:TDefTuple) :
      fatal("gen-equations for TDefTuple")
    (c:TDefVar) :
      fatal("gen-equations for TDefVar")
    (c:TDefn) :
      fatal("gen-equations for TDefn")
    (c:TDefmethod) :
      fatal("gen-equations for TDefmethod")
    (c:TInit) :
      fatal("gen-equations for TInit")
    (c:TLDefType) :
      fatal("gen-equations for TLDefType")
    (c:TLDef) :
      fatal("gen-equations for TLDef")
    (c:TLDefVar) :
      fatal("gen-equations for TLDefVar")
    (c:TLDefn) :
      fatal("gen-equations for TLDefn")
    (c:TLExternFn) :
      fatal("gen-equations for TLExternFn")
    (c:TLDefmethod) :
      fatal("gen-equations for TLDefmethod")
    (c:TLInit) :
      fatal("gen-equations for TLInit")
    (c) :
      c

;Generate equations for the given expression.
defn gen-equations (e:TExp, ctxt:Context) -> TExp :
  match(e) :
    (e) :
      e

;============================================================
;============================================================
;============================================================