defpackage stz/reg-alloc-blocks :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/basic-blocks with:
    prefix(Block) => Util
  import stz/reg-alloc-engine
  import stz/printing-utils
  import stz/reg-alloc-checks
  import stz/reg-alloc-model-properties

public defn analyze-basic-blocks (engine:RegAllocEngine) -> False :
  ;Preconditions
  no-blocks!(engine)
  
  val block-table = analyze-basic-blocks(
                      make-instructions(program(engine), model-properties(engine)))
  val blocks = seq(make-block, blocks(block-table))
  add-all(/blocks(engine), blocks)

;Return the Instructions view into the Program for
;the basic block analysis.
defn make-instructions (prog:Program,
                        model-properties:Vector<ModelProperties>) -> Instructions :
  defn returns? (s:OperationStmt) -> True|False :
    /returns?(model-properties[op-id(s)])

  val label-counter = to-seq((max-label(prog) + 1) to false)
  val stmts = stmts(prog)
  new Instructions :
    defmethod classify (this, i:Int) :
      match(stmts[i]) :
        (s:LabelStmt) : LabelInstruction(index(s))
        (s:OperationStmt) :
          if returns?(s) : JumpInstruction([])
          else : StandardInstruction()
        (s:BranchStmt) : JumpInstruction(targets(s))
        (s:GotoStmt) : GotoInstruction(target(s))
    defmethod unique-label (this) :
      next(label-counter)
    defmethod length (this) :
      length(stmts)

;Convert a utility block into a real block.
defn make-block (b:UtilBlock) -> Block :
  Block(index(b),
        start(b),
        length(b),
        succs(b),
        preds(b),
        ends-with-goto?(b))

;Compute the maximum label that was used, or -1
;if there exists no label.
defn max-label (prog:Program) -> Int :
  val labels = filter-by<LabelStmt>(stmts(prog))
  maximum(-1, seq(index, labels))