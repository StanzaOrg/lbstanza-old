defpackage stz/tl-guards :
  import core
  import collections
  import stz/tl-ir2
  import stz/types
  import stz/type-instfns
  import stz/type-utils

;Represents the different phases that the TL goes through.
public defenum TLPhase :
  SolvedTL

;Run sanity checks for the given phase on the typed program.
public defn guard! (prog:TProg, phase:TLPhase) -> False :
  for package in packages(prog) do :
    for comm in comms(package) do :
      guard!(comm, phase)

;Run sanity checks on the given item under the given phase.
defmulti guard! (item:TLItem, phase:TLPhase) -> False

;------------------------------------------------------------
;-------------------- After Solving -------------------------
;------------------------------------------------------------

defmethod guard! (item:TLItem, phase:SolvedTL) -> False :
  ;Helper: Recursively guard subitems.
  defn guard-subitems! () -> False :
    do(guard!{_, phase}, item)

  ;If it's an expression, then ensure it has a type
  ;and a context.
  match(item) :
    (item:LSExp) :
      if not resolved-type?(type(item)) :
        println(item)
        fatal("Expression %_ has no annotated type." % [object-type(item)])
      if ctxt(item) is False|LSBadCtxt :
        fatal("Expression %_ has an unsolved context." % [object-type(item)])
    (item:TExp) :
      if not resolved-type?(type(item)) :
        println(item)
        fatal("Expression %_ has no annotated type." % [object-type(item)])
      if ctxt(item) is False :
        fatal("Expression %_ has an unsolved context." % [object-type(item)])      
    (item) :
      false
    
  ;Expression-specific guards.
  match(item) :

    (item:LSMix) :
      if sel(item) is-not SSel :
        fatal("Unannotated selection.")
      if inst(item) is-not LSInstFns :
        fatal("Unannotated instantiation.")
      if ctxt(item) is-not LSCallCtxt :
        fatal("LSMix detected in unsupported context: %_." % [object-type(ctxt(item))])
      val sel = sel(item) as SSel
      val funcs = funcs(inst(item) as LSInstFns)
      ensure-no-false!(sel)
      ensure-match!(sel, funcs)
      for ref in refs(item) do :
        if type(ref) is-not TLSFunction :
          fatal("Referenced function has unexpected type: %_." % [object-type(type(ref))])
        if ctxt(ref) is-not LSCallCtxt :
          fatal("Referenced function in unsupported context: %_." % [object-type(ctxt(ref))])
      if type(item) is-not FnT :
        fatal("LSMix does not have mixed function type.")

    (item:TMix) :
      if sel(item) is-not SSel :
        println(item)
        fatal("Unannotated selection.")
      if inst(item) is-not InstFns :
        fatal("Unsolved instantiation.")
      val sel = sel(item) as SSel      
      val funcs = funcs(inst(item) as InstFns)
      ensure-no-false!(sel)
      ensure-match!(sel, funcs)
      for ref in refs(item) do :
        if type(ref) is-not TFunction :
          fatal("Referenced function has unexpected type: %_." % [object-type(type(ref))])
      match(ctxt(item)) :
        (ctxt:CallCtxt) :
          if type(item) is-not TArrow :
            fatal("Referenced function does not have TArrow type.")            
          for ref in refs(item) do :
            if /ctxt(ref) is-not CallCtxt :
              fatal("Referenced function in unsupported context: %_." % [object-type(/ctxt(ref))])
        (ctxt:ExpCtxt) :
          if not arrow?(type(item) as Type) :
            fatal("Referenced function does not have arrow type.")
          for ref in refs(item) do :
            if /ctxt(ref) is-not ExpCtxt :
              fatal("Referenced function in unsupported context: %_." % [object-type(/ctxt(ref))])
        (ctxt:MultiCtxt|LSMultiCtxt) :
          if type(item) is-not TArrow :
            println(item)
            fatal("Referenced item does not have TArrow type.")
          if length(funcs) != 1 :
            fatal("Unresolved multi.")
          if length(refs(item)) != 1 :
            fatal("Uncorrect length of refs.")
        (ctxt) :
          fatal("TMix in unsupported context: %_." % [object-type(ctxt)])

    (item:TRef) :
      if type(item) is TFunction :
        fatal("Detected direct reference to TFunction.")

    (item:LSVar) :
      if type(item) is TLSFunction and ctxt(item) is-not LSAddrCtxt :
        fatal("Detected direct reference to TLSFunction.")

    (item:TDo) :
      guard-subitems!()
      do(ensure-exp-ctxt!{value(_)}, args(item))

    (item:LSDo|LSCallC) :
      guard-subitems!()
      do(ensure-exp-ctxt!{value(_)}, args(item))

    (item:LSNew) :
      guard-subitems!()
      do(ensure-exp-ctxt!, args(item))

    (item:LSStruct) :
      guard-subitems!()
      do(ensure-exp-ctxt!, args(item))

    (item:LSReturn) :
      guard-subitems!()
      ensure-exp-ctxt!(exp(item))

    (item:TDefmulti) :
      guard-subitems!()
      do(ensure-type!, a1(item))
      ensure-type!(a2(item))

    (item:TDefn) :
      guard-subitems!()
      do(ensure-type!, a1(item))
      ensure-type!(a2(item))

    (item:TDefmethod|TLDefmethod) :
      guard-subitems!()
      do(ensure-type!, a1(item))
      ensure-type!(a2(item))
      if multi(item) is-not TMix :
        fatal("Multi is not TMix.")
        
    (item) :
      guard-subitems!()

;Ensure expression is in expression context.
defn ensure-exp-ctxt! (e:TExp) :
  if ctxt(e) is-not ExpCtxt :
    fatal("Expression expected to have LSExpCtxt.")
  val type = expected(ctxt(e) as ExpCtxt)
  if not resolved-type?(type) :
    fatal("Context does not have resolved type.")

;Ensure expression is in expression context.
defn ensure-exp-ctxt! (e:LSExp) :
  if ctxt(e) is-not LSExpCtxt :
    fatal("Expression expected to have LSExpCtxt.")
  val type = expected(ctxt(e) as LSExpCtxt)
  if not resolved-type?(type) :
    fatal("Context does not have resolved type.")

;Ensure no false selections are remaining.
defn ensure-no-false! (s:SSel) :
  if any?({_ is False}, sels(s)) :
    fatal("False selections remaining.")

;Ensure lengths match between selection and functions.
defn ensure-match! (s:SSel, f:Tuple<InstFn|LSInstFn>) :
  if length(sels(s)) != length(f) :
    fatal("Mismatch between selection and functions.")

;Ensure that the type is given.
defn ensure-type! (t:LSType|Type|False) :
  if not resolved-type?(t) :
    fatal("Missing resolved type.")
defn ensure-type! (a:FArg?) :
  ensure-type!(type(a))
defn ensure-type! (a:LSFArg) :
  ensure-type!(type(a))
    
;Return true if the 't' is a TArrow or TAnd of arrows.
defn arrow? (t:Type) -> True|False :
  match(t) :
    (t:TArrow) : true
    (t:TAnd) : arrow?(a(t)) and arrow?(b(t))
    (t) : false

;Return true if 't' is a fully resolved type.
defn resolved-type? (t:Type|LSType|False) -> True|False :
  match(t:Type|LSType) :
    resolved?(t)
