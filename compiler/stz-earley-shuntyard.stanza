defpackage stz/earley-shuntyard :
  import core
  import collections
  
;============================================================
;================= Operator and Items =======================
;============================================================

public deftype ShuntItem

public deftype Operator <: ShuntItem
public defmulti priority (op:Operator) -> Int
public defmulti associativity (op:Operator) -> Associativity
public defmulti type (op:Operator) -> OperatorType
public defmulti value (op:Operator, x, y) -> ?
public defmulti value (op:Operator, x) -> ?

public deftype Item <: ShuntItem
public defmulti value (x:Item) -> ?

public defenum Associativity :
  LeftAssociative
  RightAssociative

public defenum OperatorType :
  Binary
  Prefix
  Postfix

;============================================================
;================== Shuntyard Algorithm =====================
;============================================================

public deftype Shuntyard
public defmulti process (sh:Shuntyard, input:Seqable<ShuntItem>) -> ?

;============================================================
;================= Shuntyard Algorithm ======================
;============================================================

public defn Shuntyard () :
  ;Output vector to hold processed arguments.
  val output = Vector<?>()
  ;Stack to hold pending operators.
  val opstack = Vector<Operator>()

  ;Given that 'a' is the current top of the operator stack.
  ;Return true if a should be popped given that the next
  ;seen operator is b.
  defn pop? (a:Operator, b:Operator) -> True|False :
    if type(b) is Prefix :
      ;Prefix operators don't have a left argument
      ;so it should not pop earlier results.
      false
    else :
      ;Compare the priority of 'a' versus 'b'.
      val c = compare(priority(a), priority(b))
      if c == 0 :
        ;Pop the operator if 'a' is left associative.
        associativity(a) is LeftAssociative
      else :
        ;Pop operator if lower priority than the
        ;upcoming operator.
        c < 0

  ;Add the given item to the output vector.
  defn add-output (x:ShuntItem) :
    match(x) :
      (x:Item) :
        add(output, value(x))
      (x:Operator) :
        val v = match(type(x)) :
          (t:Prefix|Postfix) :
            value(x, pop(output))
          (t:Binary) :
            val b = pop(output)
            val a = pop(output)
            value(x, a, b)
        add(output, v)            

  ;Process all items in input
  defn process-items (input:Seqable<ShuntItem>) :
    for item in input do :
      match(item) :
        (item:Item) :
          add-output(item)
        (item:Operator) :
          while not empty?(opstack) and
                pop?(peek(opstack), item) :
            add-output(pop(opstack))
          if type(item) is Postfix : add-output(item)
          else : add(opstack, item)
    while not empty?(opstack) :
      add-output(pop(opstack))

  ;Return engine
  new Shuntyard :
    defmethod process (this, input:Seqable<ShuntItem>) :
      process-items(input)
      fatal("Illegal combination of operators.") when length(output) != 1
      val result = output[0]
      clear(output)
      result

