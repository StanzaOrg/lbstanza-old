defpackage stz/earley-shuntyard :
  import core
  import collections
  
;============================================================
;================= Operator and Items =======================
;============================================================

deftype ShuntItem

deftype Operator <: ShuntItem
defmulti priority (op:Operator) -> Int
defmulti associativity (op:Operator) -> Associativity
defmulti type (op:Operator) -> OperatorType
defmulti value (op:Operator, x, y) -> ?
defmulti value (op:Operator, x) -> ?

deftype Item <: ShuntItem
defmulti value (x:Item) -> ?

defenum Associativity :
  LeftAssociative
  RightAssociative

defenum OperatorType :
  Binary
  Prefix
  Postfix

;============================================================
;================= Shuntyard Algorithm ======================
;============================================================

defn shuntyard (input:Seqable<ShuntItem>) -> ? :
  ;Output vector to hold processed arguments.
  val output = Vector<?>()
  ;Stack to hold pending operators.
  val opstack = Vector<Operator>()

  ;Given that 'a' is the current top of the operator stack.
  ;Return true if a should be popped given that the next
  ;seen operator is b.
  defn pop? (a:Operator, b:Operator) -> True|False :
    if type(b) is Prefix :
      ;Prefix operators don't have a left argument
      ;so it should not pop earlier results.
      false
    else :
      ;Compare the priority of 'a' versus 'b'.
      val c = compare(priority(a), priority(b))
      if c == 0 :
        ;Pop the operator if 'a' is left associative.
        associativity(a) is LeftAssociative
      else :
        ;Pop operator if lower priority than the
        ;upcoming operator.
        c < 0

  ;Add the given item to the output vector.
  defn add-output (x:ShuntItem) :
    match(x) :
      (x:Item) :
        add(output, value(x))
      (x:Operator) :
        val v = match(type(x)) :
          (t:Prefix|Postfix) :
            value(x, pop(output))
          (t:Binary) :
            val b = pop(output)
            val a = pop(output)
            value(x, a, b)
        add(output, v)            

  ;Process all items in input
  defn process-items (input:Seqable<ShuntItem>) :
    for item in input do :
      match(item) :
        (item:Item) :
          add-output(item)
        (item:Operator) :
          while not empty?(opstack) and
                pop?(peek(opstack), item) :
            add-output(pop(opstack))
          if type(item) is Postfix : add-output(item)
          else : add(opstack, item)
    while not empty?(opstack) :
      add-output(pop(opstack))

  ;Launch!
  process-items(input)
  output[0]

;============================================================
;===================== Testing ==============================
;============================================================

defstruct Number <: Item :
  value: Int with: (as-method => true)
defstruct BinaryOp <: Operator :
  name: Symbol
  priority: Int with: (as-method => true)
  associativity: Associativity with: (as-method => true)
defstruct UnaryOp <: Operator :
  name: Symbol
  priority: Int with: (as-method => true)
  type: OperatorType with: (as-method => true)

defmethod type (op:BinaryOp) :
  Binary
  
defmethod associativity (op:UnaryOp) :
  match(type(op)) :
    (t:Prefix) : RightAssociative
    (t:Postfix) : LeftAssociative

defmethod value (op:UnaryOp, x) :
  qquote(~(name(op)), ~ x)

defmethod value (op:BinaryOp, x, y) :
  qquote(~ x ~(name(op)) ~ y)

defn test-shuntyard (input:List) :
  defn make-token (x) :
    switch(x) :
      `. : UnaryOp(`., 6, Postfix)
      `: : UnaryOp(`:, 5, Prefix)
      `+ : BinaryOp(`+, 4, LeftAssociative)
      `- : BinaryOp(`-, 4, LeftAssociative)
      `x : BinaryOp(`x, 3, LeftAssociative)
      `/ : BinaryOp(`/, 3, LeftAssociative)
      `^ : BinaryOp(`^, 2, RightAssociative)
      `~ : UnaryOp(`~, 1, Prefix)
      `! : UnaryOp(`!, 0, Postfix)
      else : Number(x)
  println("Parse: %s" % [input])
  val result = shuntyard(seq(make-token, input))
  println("Parsed: %_" % [result])

;;============================================================
;;========================= Testing ==========================
;;============================================================
;
defn main () :
  test-shuntyard $ `(3 + 3 x 4 / 3 x 4 ^ 3 ^ 2 + 5 + 6 ^ 3 ^ 2 x 3)
  test-shuntyard $ `(1 ^ 2 ^ : ~ 3 ! ^ 4 ! ^ : ~ 5 .)

main()