defpackage stz/reg-alloc-stackmap :
  import core
  import collections
  import stz/utils
  import stz/reg-alloc-ir
  import stz/reg-alloc-block
  import stz/reg-alloc-ports
  import stz/reg-alloc-block-processing

public defn compute-stackmap (vars:Vector<VarDef>,
                              instructions:Vector<ProgramStmt>
                              blocks:Vector<Block>) -> StackMap :
  val ints = to-tuple $ stack-intervals(instructions, blocks)
  println("Intervals:\n%_" % [Indented("%n" % [ints])])
  val stackmap = stack-map(vars, ints)
  println(stackmap)
  stackmap

;============================================================
;================== Compute Intervals =======================
;============================================================

;Represent the positions of the input/output ports of a block. 
defstruct PortPos :
  input-pos:Int
  output-pos:Int
with:
  printer => true

;Represents one-half of a liveness interval for a stack slot.
;- id: The id of the variable.
;- start?: True if start of an interval, false if end of an interval.
defstruct Interval :
  id:Int
  start?:True|False
  pos:Int
with:
  printer => true

;Retrieve the stack intervals of all blocks.
defn stack-intervals (instructions:Vector<ProgramStmt>,
                      blocks:Vector<Block>) -> Seqable<Interval> :
  ;Compute port positions of all blocks.
  val nblocks = length(blocks)
  val port-positions = Array<PortPos>(nblocks)
  val pos-counter = Counter(0)
  for (block in blocks, i in 0 to false) do :
    val input-pos = next(pos-counter, 1)
    next(pos-counter, length(block))
    val output-pos = next(pos-counter, 1)
    port-positions[i] = PortPos(input-pos, output-pos)

  ;Record the minimum and maximum positions of each interval.
  val var-start-table = IntTable<Int>()
  val var-end-table = IntTable<Int>()

  ;Note the usage of variable v at position i.
  defn note-usage (v:Int, i:Int) :
    var-start-table[v] = match(get?(var-start-table, v)) :
      (p:Int) : min(i,p)
      (f:False) : i
    var-end-table[v] = match(get?(var-end-table,v)) :
      (p:Int) : max(i,p)
      (f:False) : i

  ;Note the usage of variable v as an input port to block b.
  defn note-input-port-usage (b:Int, v:Int) :
    val block = blocks[b]
    note-usage(v, input-pos(port-positions[b]))
    for b in preds(block) do :
      note-usage(v, output-pos(port-positions[b]))

  ;Note all usages of all variables.
  defn note-all-usages () :
    for (block in blocks, b in 0 to false) do :
      ;Mark usage of all saved input ports.
      for port in inputs(block) do :
        if saved?(status!(port)) :
          note-input-port-usage(b, id(port))
          
      ;Mark usage of all save/load instructions.
      val input-pos = input-pos(port-positions[b])
      within (i, stmt) = stmts(instructions, block) :
        match(stmt:Save|Load) :
          val pos = input-pos + 1 + i
          note-usage(id(stmt), pos)

  ;Compute the total number of positions.
  defn num-positions () -> Int :
    sum(seq({2 + length(_)}, blocks))

  ;Create the sequence of sorted intervals.
  defn sorted-intervals () -> Seq<Interval> :
    val ints = Array<List<Interval>>(num-positions(), List())
    defn add-interval (pos:Int, int:Interval) :
      ints[pos] = cons(int, ints[pos])
    ;Add ends first so that starts appear before ends in the final lists.
    for entry in var-end-table do :
      val pos = value(entry)
      add-interval(pos, Interval(key(entry), false, pos))
    for entry in var-start-table do :
      val pos = value(entry)
      add-interval(pos, Interval(key(entry), true, pos))
    cat-all(ints)

  ;Launch!
  note-all-usages()
  sorted-intervals()  

;============================================================
;================== Computing the StackMap ==================
;============================================================

;Calculate the stack map from the given intervals.
defn stack-map (vars:Vector<VarDef>,
                ints:Seqable<Interval>) -> StackMap :
  ;Hold all the stack slots here.
  val slots = Vector<StackMapSlot>()

  ;Hold the free slots here, for each category.
  val free-slots = Vector<Vector<StackMapSlot>>()

  ;Each entry, VAR => SLOT, means that the variable 'VAR'
  ;was assigned to slot 'SLOT'.  
  val slot-table = IntTable<StackMapSlot>()

  ;Compute the slots assigned to each variable.
  defn all-varslots () -> Tuple<Int|False> :
    to-tuple $ for v in 0 to length(vars) seq :
      match(get?(slot-table, v)) :
        (slot:StackMapSlot) : id(slot)
        (f:False) : false

  ;Add the given slot to the free lists.
  defn add-to-free (slot:StackMapSlot) -> False :
    ;Ensure that we have enough free categories.
    val num-categories = category(slot) + 1
    if length(free-slots) < num-categories :
      for i in length(free-slots) to num-categories do :
        add(free-slots, Vector<StackMapSlot>())
    ;Add the slot to the given category.
    add(free-slots[category(slot)], slot)

  ;Create a fresh slot of the given category.
  defn fresh-slot (category:Int) -> StackMapSlot :
    val id = length(slots)
    val slot = StackMapSlot(id, category)
    add(slots, slot)
    slot

  ;Retrieve an available slot of the given category.
  defn available-slot (category:Int) -> StackMapSlot :
    if length(free-slots) > category :
      val free = free-slots[category]
      if empty?(free) : fresh-slot(category)
      else : pop(free)
    else : fresh-slot(category)

  ;Assign a slot to a given variable.
  defn assign-slot (v:Int, slot:StackMapSlot) -> False :
    slot-table[v] = slot

  ;Release the slot assigned to a given variable.
  defn release-slot (v:Int) -> False :
    val slot = slot-table[v]
    add-to-free(slot)

  ;Main algorithm: Loop through each interval
  ;and assign slots to each variable as they come up.
  for int in ints do :
    ;Case: The start of an interval.
    if start?(int) :
      ;Retrieve an available slot of the given category.
      val category = category(vars[id(int)])
      val slot = available-slot(category)
      ;Assign that slot to the given variable.
      assign-slot(id(int), slot)
    ;Case: The end of an interval.
    else :
      ;Retrieve the slot that the variable was assigned
      ;to, and release it.
      release-slot(id(int))

  ;Return results in a StackMap datastructure.
  StackMap(to-tuple(slots), all-varslots())
  