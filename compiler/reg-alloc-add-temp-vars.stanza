defpackage stz/reg-alloc-add-temp-vars :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-datastructures
  import stz/reg-alloc-model-env

;Type for adding temporary variables to a program.
public deftype AddTempVars 

;Process the given Program and return a new Program.
public defmulti process (a:AddTempVars, prog:Program, models:ModelEnv) -> Program

;Create the AddTempVars system for preprocessing a program.
public defn AddTempVars (resources:ResourceProvider) :

  ;Buffer for holding program statements.
  val program-statements = Vector<ProgramStmt>()

  ;Buffer for holding already created temporary variables.
  val temp-vardefs = Vector<VarDef>()

  ;Buffer for holding temporary variables to be assigned.
  val temp-buffer = Vector<KeyValue<Int,Int>>()

  ;Scratch set for holding variables.
  val var-set = IntSet()

  ;Add a new program statement to the buffer
  defn emit (s:ProgramStmt) -> False :
    add(program-statements,s)

  ;Create a temporary for the given variable.
  defn make-temp (prog:Program, v:Int) -> Int :
    val id = length(temp-vardefs) + length(vars(prog))
    val oldv = vars(prog)[v]
    add(temp-vardefs, VarDef(id,type(oldv),category(oldv)))
    add(temp-buffer, id => v)
    id

  ;Emit the set statement for assigning the temporaries.
  defn emit-temps () -> False :
    emit $ SetStmt(to-tuple(seq(value,temp-buffer))
                   to-tuple(seq(key,temp-buffer)))
    clear(temp-buffer)

  ;Returns true if any argument variables are repeated.
  defn repeated-vars? (results:Tuple<Int>, args:Tuple<Int>) -> True|False :
    add-all(var-set, results)
    val result = for a in args any? :
      not add(var-set, a)
    clear(var-set)
    result

  ;Create new Program from buffer.
  defn flush-buffers-to-prog (prog:Program) -> Program :
    ;Create the new program.
    val new-vars = to-tuple $ cat(vars(prog), temp-vardefs)
    val new-stmts = to-tuple $ program-statements
    val new-prog = Program(new-vars, new-stmts)
    ;Clear all the buffers.
    clear(program-statements)
    clear(temp-vardefs)
    ;Ensure already cleared.
    if not empty?(temp-buffer) :
      fatal("temp-buffer is expected to be empty.")
    if not empty?(var-set) :
      fatal("var-set is expected to be empty.")
    ;Return the new program
    new-prog

  ;Process a program.
  defn process-program (prog:Program, models:ModelEnv) -> Program :
    ;Process all the statements in the program.
    for stmt in stmts(prog) do :
      match(stmt) :
        (stmt:SetStmt) :
          ;Temporaries are required if arguments are repeated.
          if repeated-vars?(results(stmt), args(stmt)) :
            add-all(var-set, results(stmt))
            val new-args = to-tuple $
              for (v in args(stmt), i in 0 to false) seq :
                if add(var-set,v) : v
                else : make-temp(prog,v)
            clear(var-set)
            emit-temps()
            emit(sub-args(stmt, new-args))
          else :
            emit(stmt)
        (stmt:OperationStmt) :
          ;Temporaries are required if the operation forces
          ;arguments to be released or if some of the arguments
          ;are repeated.
          if any-forced-release?(models, op-id(stmt)) or
             repeated-vars?(results(stmt), args(stmt)) :
            add-all(var-set, results(stmt))
            val new-args = to-tuple $
              for (v in args(stmt), i in 0 to false) seq :
                val temp? = not add(var-set,v)
                         or forced-release?(models, op-id(stmt), i)
                if temp? : make-temp(prog,v)
                else : v
            clear(var-set)
            emit-temps()
            emit(sub-args(stmt, new-args))
          ;If it does not, then just emit the operation as is.
          else :
            emit(stmt)
        (stmt) :
          emit(stmt)
    ;Output the new program.
    flush-buffers-to-prog(prog)

  ;Create the actual type.
  new AddTempVars :
    defmethod process (this, prog:Program, models:ModelEnv) -> Program :
      process-program(prog, models)