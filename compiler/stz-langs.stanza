defpackage stz/input-lang :
   import core
   import verse
   import core/macro-utils

;============================================================
;================ defreader Lang ============================
;============================================================

;======== PARSING STRUCTURES ========
defstruct Reader :
   reader: Symbol
   error: False|Symbol

definterface ListClause
defstruct TagClause <: ListClause :
   tag: Symbol
   args: List<Symbol>
   rest?: True|False
   readers: List<KeyValue<Symbol, Reader>>
   body: ?
defstruct ElseClause <: ListClause :
   body

definterface TypeForm
defstruct ListTypeForm <: TypeForm : (clauses: List<ListClause>)
defstruct DefaultTypeForm <: TypeForm : (type, body)

defstruct DefReader :
   name: Symbol
   form: Symbol
   inf: Symbol
   typeforms: List<TypeForm>

defstruct DefError :
   name: Symbol
   args: List<Symbol>
   rest?: True|False
   body

;======== PARSING ========
defsyntax stz/input-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   ;defreader syntax
   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      rest = (~ ...) : true
      rest = () : false
      reader = (?name:#sym => ?r:#sym (error:?e:#sym)) : name => Reader(r, e)
      reader = (?name:#sym => ?r:#sym) : name => Reader(r, false)
      listclause = ((?tag:#sym ?args:#sym ... ?r:#rest) :
                       ?readers:#reader ...
                       ?body ...) :
         if map(key, readers) != args :
            error("Given arguments are ~@, but given readers are ~@." % [
               join(args, ", "), join(map(key, readers), ", ")])
         TagClause(tag, args, r, readers, body)
      listclause = (else : ?body:#exp) :
         ElseClause(body)
      typeform = (List : (?cs:#listclause ...)) : ListTypeForm(cs)
      typeform = (?t:#type : ?body:#exp) : DefaultTypeForm(t, body)
      prefix-op = (defreader ?name:#sym (?f:#sym, ?inf:#sym) :
                      ?typeforms:#typeform ...) :
         println("=== Parse Result ===")
         println(DefReader(name, f, inf, typeforms))
         val r = compile(DefReader(name, f, inf, typeforms))
         println(r)
         expande(r)

   ;deferror syntax
   defrule :
      prefix-op = (deferror ?name:#sym (?args:#sym ... ?r:#rest) : ?body:#exp) :
         val e = compile(DefError(name, args, r, body))
         println(e)
         expande(e)

;======== COMPILATION ========
defn compile (d:DefReader) :
   val #pass = gensym()
   val #ensure-min-arity = gensym()
   val #ensure-arity = gensym()
   val #try-read = gensym()
   
   defn compile (c:ListClause) :
      match(c) :
         (c:TagClause) :
            val template = `(
               `tag :
                  rest?{
                     ensure-min-arity(n - 1)}{
                     ensure-arity(n)}
                  readers{
                     val #name = error?{
                        try-read(error, read, rest?{tailn(form,i)}{form[i]})}{
                        try-read(read, rest?{tailn(form,i)}{form[i]})}}
                  throw(ReadError()) when not pass?
                  readers{
                     val name = item!(#name)}                  
                  body)
            val n = length(args(c))
            fill-template(template, [
               `pass? => #pass
               `ensure-min-arity => #ensure-min-arity
               `ensure-arity => #ensure-arity
               `try-read => #try-read
               `tag => tag(c),
               `body => body(c),
               `form => form(d),
               `inf => inf(d),
               `rest? => choice(rest?(c)),
               `n => n,
               `readers => nested $ for (r in readers(c), i in 1 to false) stream : [
                  `i => i,
                  `rest? => choice(rest?(c) and i == n - 1)
                  `name => key(r),
                  `#name => gensym(key(r)),
                  `read => reader(value(r)),
                  `error? => choice(error(value(r)) != false),
                  `error => error(value(r))]])
         (c:ElseClause) :
            qquote(else : ~ (body(c)))

   defn compile (t:TypeForm) :
      match(t) :
         (t:ListTypeForm) :
            val template = `(
               (form:List) :
                  var pass? = true
                  defn best-info () :
                     first-info(inf, first-info(form))
                  defn try-read<?T,?S> (error: (List, FileInfo) -> ReadError, f: (S, FileInfo) -> ?T, x: ?S) -> Option<T> :
                     try :
                        Some(f(x, inf))
                     catch (e) :
                        add(read-errors, error(form, best-info()))
                        pass? = false
                        None()
                  defn try-read<?T,?S> (f: (S, FileInfo) -> ?T, x: ?S) -> Option<T> :
                     try :
                        Some(f(x, inf))
                     catch (e) :
                        pass? = false
                        None()
                  defn ensure-arity (n:Int) :
                     if length(form) - 1 != n :
                        add(read-errors, ArityError(form, n, best-info()))
                        throw(ReadError())
                  defn ensure-min-arity (n:Int) :
                     if length(form) - 1 < n :
                        add(read-errors, MinArityError(form, n, best-info()))
                        throw(ReadError())
                  val inf = if empty?(form) : inf
                            else : first-info(first-info(head(form)), inf)
                  switch tagged-list?{form, _} :
                     clauses)
            fill-template(template, [
               `pass? => #pass
               `best-info => gensym()
               `try-read => #try-read
               `ensure-arity => #ensure-arity
               `ensure-min-arity => #ensure-min-arity
               `form => form(d),
               `inf => inf(d),
               `clauses => splice(map-append(compile, clauses(t)))])

         (t:DefaultTypeForm) :
            val template = `(
               (form:Type) : body)
            fill-template(template, [
               `form => form(d),
               `Type => type(t),
               `body => body(t)])

   val template = `(
      defn name (form, inf:FileInfo) :
         match(form) :
            (form:Token) :
               name(item(form), first-info(inf, info(form)))
            typeforms)
   fill-template(template, [
      `name => name(d),
      `form => form(d),
      `inf => inf(d),
      `typeforms => splice(map-append(compile, typeforms(d)))])

defn compile (d:DefError) :
   val template = `(
      defn name (form:List, info:FileInfo) :
         ReadError{_, info} $ let :
            args{val x = rest?{tailn(form,i)}{form[i]}}
            body)
   val n = length(args(d))         
   fill-template(template, [
      `name => name(d),
      `form => gensym()
      `info => gensym()
      `body => body(d)
      `args => nested $ for (x in args(d), i in 1 to false) stream : [
         `x => x
         `i => i
         `rest? => choice(rest?(d) and i == n - 1)]])

defn expande (e) :
   match-syntax(e) :
      (?e:#exp) :
         e


;======== DEBUG ========
defmethod print (o:OutputStream, r:Reader) :
   print(o, "~ (~)" << [reader(r), error(r)])

defmethod print (o:OutputStream, c:ListClause) :
   print{o, _} $ match(c) :
      (c:TagClause) : "(~ ~@ ~) : (~@, ~)" << [
         tag(c),
         join(args(c), " "),
         "..." when rest?(c) else ""
         join(readers(c), " "),
         body(c)]
      (c:ElseClause) : "(else : ~)" << [body(c)]

defmethod print (o:OutputStream, t:TypeForm) :
   print{o, _} $ match(t) :
      (t:ListTypeForm) : "(List : (~@))" << [join(clauses(t), " ")]
      (t:DefaultTypeForm) : "(~ : ~)" << [type(t), body(t)]

defmethod print (o:OutputStream, r:DefReader) :
   print(o, "($defreader ~ (~ ~) ~@)" << [
      name(r),
      form(r),
      inf(r),
      join(typeforms(r), " ")])


