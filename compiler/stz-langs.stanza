defpackage stz/langs :
   import core

public defn expande (e) :
   with-syntax(core) :
      match-syntax(e) :
         (?e:#exp) :
            e

;============================================================
;================ defast Lang ===============================
;============================================================

defpackage stz/ast-lang :
   import core
   import verse
   import core/macro-utils

;======== AST TABLE ========
public val AST-TABLE = HashTable<Symbol, ASTStructure>(symbol-hash)
public defstruct ASTStructure :
   nodes: List<KeyValue<Symbol, List<Symbol>>>

;======== PARSING STRUCTURES ========
defstruct DefAst :
   defs: List<Def>
definterface Def
defstruct DefType <: Def :
   name: Symbol
   parent
   fields: List<Field>
defstruct DefMap <: Def :
   f: Symbol
   ftype
   x: Symbol
   xtype: Symbol
   rettype
   clauses:List<Clause>
defstruct DefDo <: Def :
   f: Symbol
   ftype
   x: Symbol
   xtype: Symbol
   rettype
   clauses:List<Clause>
defstruct DefNodes <: Def :
   type: Symbol
   nodes: List<Node>
defstruct Node :
   name: Symbol
   fields: List<Field>
defstruct Field :
   name: Symbol
   type
   options: List

definterface Clause
defmulti type (c:Clause) -> ?
defstruct TypeClause <: Clause :
   x:Symbol
   type with: (as-method => true)
   body
defstruct IgnoreClause <: Clause :
   type with: (as-method => true)

;======== PARSING ========
defsyntax stz/ast-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      prefix-op = (defast : (?defs:#def ... ?rest ...)) :
         if not empty?(rest) :
            error("Invalid syntax: The following forms are not defs: ~@" % [join(rest, " ")])
         stz/langs/expande(compile(DefAst(defs)))

      def = (deftype ?name:#sym ?parent:#parent : (?fields:#field ...)) :
         DefType(name, parent, fields)
      def = (deftype ?name:#sym ?parent:#parent) :
         DefType(name, parent, List())
      parent = (<: ?t:#type) : t
      parent = () : false

      def = (defnodes ?name:#sym : (?nodes:#node ...)) :
         DefNodes(name, nodes)
      node = (?name:#sym : (?fields:#field ...)) :
         Node(name, fields)
      node = (?name:#sym) :
         Node(name, List())
      field = (?name:#sym : ?t:#type with : (?options ...)) :
         Field(name, t, options)
      field = (?name:#sym : ?t:#type) :
         Field(name, t, List())

      def = (defmap (?f:#sym : ?ft:#type , ?x:#sym : ?xt:#sym) -> ?rt:#type :
                ?cs:#clause ...) :
         DefMap(f, ft, x, xt, rt, cs)
      def = (defdo (?f:#sym : ?ft:#type , ?x:#sym : ?xt:#sym) -> ?rt:#type :
                ?cs:#clause ...) :
         DefDo(f, ft, x, xt, rt, cs)
      clause = ((?x:#sym : ?xt:#type) : ?body:#exp) :
         TypeClause(x, xt, body)
      clause = (ignore(?t:#type)) :
         IgnoreClause(t)

;======== COMPILATION ========
defn fill-each<?T> (f: T -> Streamable<KeyValue<Symbol,?>>, xs:Streamable<?T>) :
   nested(stream(f, xs))

defn compile (d:DefAst) :
   ;Type Tables
   val type-table = to-list $
      for e in filter({_ typeof DefType}, defs(d)) stream :
         val e* = e as DefType
         name(e*) => e*
   defn typefields (n:Symbol) :
      fields(lookup!(type-table, n))

   ;Save AST Structure
   for def in filter({_ typeof DefNodes}, defs(d)) as Streamable<DefNodes> do :
      val tfs = typefields(type(def))
      val nodes = for n in nodes(def) map :
         val fs = append(fields(n), tfs)
         name(n) => map(name, fs)
      AST-TABLE[type(def)] = ASTStructure(nodes)   

   ;Node Table
   val node-table = to-list $
      for e in filter({_ typeof DefNodes}, defs(d)) stream :
         val e* = e as DefNodes
         type(e*) => nodes(e*)
   defn nodes-of (n:Symbol) :
      lookup!(node-table, n)

   ;Compile DefType
   defn compile (d:DefType) :
      val template = `(definterface name parent?{<: parent}{})
      fill-template(template, [
         `name => name(d)
         `parent? => choice(parent(d) != false)
         `parent => parent(d)])

   ;Compile DefNodes
   defn compile (d:DefNodes) :
      val tfs = typefields(type(d))
      defn comp (n:Node) :
         val template = `(defstruct name <: type : (fs tfs))
         fill-template(template, [
            `name => name(n),
            `type => type(d),
            `fs => splice(stream-concat(comp, fields(n))),
            `tfs => splice(stream-concat(comp, tfs))])
      defn comp (f:Field) :
         qquote(~ (name(f)) : ~ (type(f)) with : ~ (options(f)))
      map-append(comp, nodes(d))

   ;Create a type table
   defn make-type-table (cs:List<Clause>) :
      ;Map function table
      val table = for c in cs map :
         unwrap-all(type(c)) =>
            match(c) :
               (c:TypeClause) : gensym()
               (c:IgnoreClause) : false
      fn (type) :
         val t = unwrap-all(type)
         val e = for e in table find :
            key(e) == t
         if e == false :
            error("Invalid syntax. No handler declared for type ~." % [type])
         value(e as KeyValue<?,Symbol|False>)

   ;Compiling type table
   defn compile-type-functions (f, ftype, table: ? -> False|Symbol, cs:List<Clause>) :
      val forms = Vector<?>()
      for c* in filter({_ typeof TypeClause}, cs) do :
         val c = c* as TypeClause
         val template = `(defn #name (f:ftype, x:xtype) : body)
         val filled = fill-template(template, [
            `#name => table(type(c))
            `f => f
            `ftype => ftype
            `x => x(c)
            `xtype => type(c)
            `body => body(c)])
         add(forms, filled)
      to-list(forms)   

   ;Compile DefMap
   defn compile (dm:DefMap) :
      ;Map function table
      val mapfunction = make-type-table(clauses(dm))
      val mapfunctions = compile-type-functions(f(dm), ftype(dm), mapfunction, clauses(dm))

      ;Compiling a field
      defn compile (x:Symbol, f:Symbol, fd:Field) :
         val template = `(ignore?{name(x)}{#f(f, name(x))})
         val #f = mapfunction(type(fd))
         fill-template(template, [
            `name => name(fd)
            `x => x
            `f => f
            `#f => #f
            `ignore? => choice(#f == false)])

      ;Compiling main map function
      defn compile-map () :
         val template = `(
            defn map (f:ft, x:xt) -> rt :
               match(x) :
                  nodes{(x:Node) : Node(fs)})
         fill-template(template, [
            `f => f(dm)
            `ft => ftype(dm)
            `x => x(dm)
            `xt => xtype(dm)
            `rt => rettype(dm)
            `nodes => for n in nodes-of(xtype(dm)) fill-each :
               val fs = append(fields(n), typefields(xtype(dm)))
               [`Node => name(n)
                `fs => splice $ map(compile{x(dm), f(dm), _}, fs)]])

      ;Bundle
      list(mapfunctions, compile-map())

   ;Compile DefDo
   defn compile (dd:DefDo) :
      ;do function table
      val dofunction = make-type-table(clauses(dd))
      val dofunctions = compile-type-functions(f(dd), ftype(dd), dofunction, clauses(dd))

      ;Compiling a field
      defn compile (x:Symbol, f:Symbol, fd:Field) :
         val template = `(ignore?{}{#f(f, name(x))})
         val #f = dofunction(type(fd))
         fill-template(template, [
            `name => name(fd)
            `x => x
            `f => f
            `#f => #f
            `ignore? => choice(#f == false)])

      ;Compiling main map function
      defn compile-do () :
         val template = `(
            defn do (f:ft, x:xt) -> rt :
               match(x) :
                  nodes{(x:Node) :
                     fs
                     false})
         fill-template(template, [
            `f => f(dd)
            `ft => ftype(dd)
            `x => x(dd)
            `xt => xtype(dd)
            `rt => rettype(dd)
            `nodes => for n in nodes-of(xtype(dd)) fill-each :
               val fs = append(fields(n), typefields(xtype(dd)))
               [`Node => name(n)
                `fs => splice $ map-append(compile{x(dd), f(dd), _}, fs)]])

      ;Bundle
      list(dofunctions, compile-do())

   ;Driver
   list $ for d in defs(d) map :
      compile(d as DefType|DefMap|DefDo|DefNodes)

;============================================================
;================= defreader Lang ===========================
;============================================================
defpackage stz/reader-lang :
   import core
   import verse
   import core/macro-utils

defstruct DefReader :
   name: Symbol
   prods: List<Prod>
defstruct Prod :
   name: Symbol
   type
   forms: List<Form>
definterface Form
defstruct TagForm <: Form :
   tag: Symbol
   fields: List<Field>
   body
defstruct SForm <: Form :
   body
defstruct VForm <: Form :
   body
defstruct Field :
   name: Symbol
   prod: Symbol
   type: Int

val STYPE = 0
val LTYPE = 1
val RTYPE = 2

defsyntax stz/reader-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      prefix-op = (defreader ?name:#sym :
                      (?ps:#sym -> ?ts:#type :
                          ?fs:#form ...) @...) :
         val d = DefReader(name, map(Prod, ps, ts, fs))
         stz/langs/expande(compile(d))
      form = ((?tag:#sym ?fs:#field ...) : ?body:#exp) :
         TagForm(tag, fs, body)
      form = (x : ?body:#exp) :
         SForm(body)
      form = (v : ?body:#exp) :
         VForm(body)
      field = (?name:#sym : ?prod:#sym ~ ...) :
         Field(name, prod, RTYPE)
      field = (?name:#sym : ?prod:#sym) :
         Field(name, prod, STYPE)
      field = ((?name:#sym : ?prod:#sym ~ ...)) :
         Field(name, prod, LTYPE)


defmulti compile-body (f:Form, ret, prod-type: Symbol -> ?) -> List

defmethod compile-body (f:TagForm, ret, prod-type: Symbol -> ?) :
   defn field-type (t:Int, ptype) :
      switch {t == _} :
         STYPE : ptype
         LTYPE : qquote(List<~ ptype>)
         RTYPE  : qquote(List<~ ptype>)
   val template = `(
      fn (#array:Array, info:FileInfo) -> ret :
         fields{val name:type = #array[i]}
         body)
   fill-template(template, [
      `body => body(f)
      `ret => ret
      `fields => nested $ for (f in fields(f), i in 0 to false) stream : [
         `name => name(f)
         `type => field-type(type(f), prod-type(prod(f)))
         `i => i]])

defmethod compile-body (f:SForm, ret, prod-type: Symbol -> ?) :
   val template = `(
      fn (x:Symbol, info:FileInfo) -> ret :
         body)
   fill-template(template, [
      `body => body(f),
      `ret => ret])

defmethod compile-body (f:VForm, ret, prod-type: Symbol -> ?) :
   val template = `(
      fn (v:?, info:FileInfo) -> ret :
         body)
   fill-template(template, [
      `body => body(f),
      `ret => ret])

defn compile (f:Field) :
   val template = `(type{SField(`prod)}{LField(`prod)}{RField(`prod)})
   fill-template(template, [
      `type => choice(type(f))
      `prod => prod(f)])

defmulti compile (f:Form, ret, prod-type: Symbol -> ?) -> List

defmethod compile (f:TagForm, ret, prod-type: Symbol -> ?) :
   val template = `(TagForm(`tag, [fs], body))
   fill-template(template, [
      `tag => tag(f)
      `fs => splice(map(compile, fields(f)))
      `body => compile-body(f, ret, prod-type)])

defmethod compile (f:SForm, ret, prod-type: Symbol -> ?) :
   val template = `(SForm(body))
   fill-template(template, [
      `body => compile-body(f, ret, prod-type)])

defmethod compile (f:VForm, ret, prod-type: Symbol -> ?) :
   val template = `(VForm(body))
   fill-template(template, [
      `body => compile-body(f, ret, prod-type)])

defn compile (d:DefReader) :
   defn prod-type (n:Symbol) :
      label return :
         return(`?) when n == `?
         for p in prods(d) do :
            return(type(p)) when name(p) == n
         error("No production named ~" % [n])

   val template = `(
      val name = FormTable $ [
         prods{`name => [fs]}])
   fill-template(template, [
      `name => name(d),
      `prods => nested $ for p in prods(d) stream : [
         `name => name(p)
         `fs => splice(map(compile{_, type(p), prod-type}, forms(p)))]])


;============================================================
;================= defast-printer Lang ======================
;============================================================
defpackage stz/ast-printer-lang :
   import core
   import verse
   import core/macro-utils

defstruct DefAstPrinter :
   exp: Symbol
   type
   clauses: List<Clause>
defstruct Clause :
   type
   form: Form
definterface Form
defstruct TagForm <: Form :
   tag: Symbol
   fields: List<Field>
defstruct CustomForm <: Form :
   exp
defstruct IfForm <: Form :
   pred
   conseq: Form
   alt: Form

definterface Field
defmulti name (f:Field) -> Symbol
defstruct SField <: Field :
   name:Symbol with: (as-method => true)
defstruct LField <: Field :
   name:Symbol with: (as-method => true)
defstruct RField <: Field :
   name:Symbol with: (as-method => true)

defsyntax stz/printer-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      prefix-op = (defprinter (?name:#sym : ?type:#type) :
                      ?clauses:#clause ... ?rest ...) :
         error("Not a printer clause: ~" % [rest]) when not empty?(rest)               
         val d = DefAstPrinter(name, type, clauses)
         stz/langs/expande(compile(d))
      clause = (?t:#type : (?f:#form)) :
         Clause(t, f)
      form = ((?tag:#sym ?fs:#field ...)) :
         TagForm(tag, fs)
      form = (if ?pred:#exp : ?conseq:#form else : ?alt:#form) :
         IfForm(pred, conseq, alt)
      form = (custom{?exp:#exp}) :
         CustomForm(exp)
      field = (?name:#sym ~ ...) :
         RField(name)
      field = (?name:#sym) :
         SField(name)
      field = ((?name:#sym ~ ...)) :
         LField(name)

defn format-string (f:TagForm) :
   val o = StringBuffer()
   print(o, "(~" << [tag(f)])
   for f in fields(f) do :
      print{o, _} $ match(f) :
         (f:SField) : " ~"
         (f:LField) : " (~@)"
         (f:RField) : "~@"
   print(o, ")")
   to-string(o)

defn value-obj (e:Symbol, f:Field) :
   val template = match(f) :
      (f:SField) : `(name(e))
      (f:LField) : `(core/join(name(e) as core/List, " "))
      (f:RField) : `(core/stream-concat(list{" ", _}, name(e) as core/List))
   fill-template(template, [
      `name => name(f)
      `e => e])

defn compile (e:Symbol, f:Form) :
   match(f) :
      (f:TagForm) :
         val template = `(core/print(#o, str << [vs]))
         fill-template(template, [
            `str => format-string(f)
            `vs => splice(map(value-obj{e, _}, fields(f)))])
      (f:CustomForm) :
         val template = `(core/print(#o, exp))
         fill-template(template, [
            `exp => exp(f)])
      (f:IfForm) :
         val template = `(if pred : conseq else : alt)
         fill-template(template, [
            `pred => pred(f)
            `conseq => compile(e, conseq(f))
            `alt => compile(e, alt(f))])

defn compile (d:DefAstPrinter) :
   val template = `(
      defmethod print (#o:core/OutputStream, e:Type) :
         match(e) :
            clauses{(e:Type) : body})
   fill-template(template, [
      `e => exp(d)
      `Type => type(d)
      `clauses => nested $
         for c in clauses(d) stream : [
            `Type => type(c)
            `body => compile(exp(d), form(c))]])


;============================================================
;===================== defcheck Lang ========================
;============================================================
defpackage stz/check-lang :
   import core
   import verse
   import core/macro-utils
   import stz/lexer

;======== Parse Structures ========
definterface CType
defstruct SymType <: CType :
   type: Symbol
defstruct RestType <: CType :
   type: Symbol
defstruct ListType <: CType :
   types: List<CType>

definterface Checker
defstruct FormChecker <: Checker :
   args: List<Symbol>
   types: List<CType>
defstruct IfChecker <: Checker :
   pred
   conseq: Checker
   alt: Checker
defstruct CustomChecker <: Checker :
   exp
defstruct SwitchChecker <: Checker :
   pred
   clauses: List<KeyValue<?, Checker>>
   else-clause: Checker
defstruct BeginChecker <: Checker :
   checkers: List<Checker>

definterface Clause
defstruct TypeClause <: Clause :
   type
   checker: Checker
defstruct PlusClause <: Clause :
   type: Symbol
defstruct AfterClause <: Clause :
   exp

defstruct FormSpec :
   type: Symbol
   description: String
   clauses: List<Clause>

defstruct DefCheck :
   name: Symbol
   exp: Symbol
   type
   specs: List<FormSpec>

;======== Syntax Definition ========
defsyntax stz/check-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      prefix-op = (defcheck ?name:#sym (?exp:#sym : ?type:#type) :
                      ?fs:#spec ...) :
         stz/langs/expande(compile(DefCheck(name, exp, type, fs)))
      spec = (?name:#sym(?desc) :
                 ?cs:#clause ...) :
         FormSpec(name, unwrap-token(desc), cs)
      clause = (after{?e:#exp}) :
         AfterClause(e)
      clause = (+ ?name:#sym) :
         PlusClause(name)
      clause = (?type:#type :
                   ?cs:#checker ...) :
         TypeClause(type, BeginChecker(cs))
      clause = (?type:#type ?c:#checker) :
         TypeClause(type, c)
      checker = (if ?pred:#exp : ?conseq:#checker else : ?alt:#checker) :
         IfChecker(pred, conseq, alt)
      checker = (custom{?e:#exp}) :
         CustomChecker(e)
      checker = (switch ?pred:#exp :
                    ((! else) ?keys:#exp : ?cs:#checker) @...
                    else : ?ec:#checker) :
         SwitchChecker(pred, map(KeyValue, keys, cs), ec)
      checker = (((?ns:#sym : ?ts:#ctype) @...)) :
         FormChecker(ns, ts)
      ctype = (?type:#sym ~ ...) :
         RestType(type)
      ctype = (?type:#sym) :
         SymType(type)
      ctype = ((?ts:#ctype ...)) :
         ListType(ts)


;======== Compilation ========
defn fill-each<?T> (f: T -> Streamable<KeyValue<Symbol,?>>, xs:Streamable<?T>) :
   nested(stream(f, xs))

defn compile (d:DefCheck) :
   ;Create function names
   val #types = map({type(_) => gensym()}, specs(d))
   defn #type (n:Symbol) : lookup!(#types, n)
   defn #type (s:FormSpec) : #type(type(s))
   defn #type (t:SymType|RestType) : #type(type(t))

   ;Retrieving all type and after clauses in a spec
   val spec-table = map({type(_) => _}, specs(d), specs(d))
   defn all-clauses (s:FormSpec) :
      val tcs = Vector<TypeClause>()
      val acs = Vector<AfterClause>()
      for c in clauses(s) do :
         match(c) :
            (c:TypeClause) :
               add(tcs, c)
            (c:AfterClause) :
               add(acs, c)
            (c:PlusClause) :
               val [tcs*, acs*] = all-clauses(lookup!(spec-table, type(c)))
               do(add{tcs, _}, tcs*)
               do(add{acs, _}, acs*)
      [tcs, acs]

   ;Compiling a CType
   defn compile (pos:String, t:CType) :
      match(t) :
         (t:SymType) :
            fill-template(`(lang/check/SymType(#t)), [
               `#t => #type(t)])
         (t:RestType) :
            fill-template(`(lang/check/RestType(#t)), [
               `#t => #type(t)])
         (t:ListType) :
            fill-template(`(lang/check/ListType(e, pos, [ts])), [
               `e => exp(d)
               `pos => pos
               `ts => splice(map(compile{pos, _}, types(t)))])

   ;Compiling a field check against a CType
   defn compile-check (field:Symbol, t:CType) :
      match(t) :
         (t:ListType) :
            fill-template(`(lang/check/check(field(e) as core/List, t)), [
               `e => exp(d)
               `field => field
               `t => compile(to-string(field), t)])
         (t) :
            fill-template(`(lang/check/check(field(e), t)), [
               `e => exp(d)
               `field => field
               `t => compile(to-string(field), t)])

   ;Compiling a checker
   defn compile (c:Checker) -> ? :
      match(c) :
         (c:FormChecker) :
            map(compile-check, args(c), types(c))
         (c:IfChecker) :
            fill-template(`(if pred : conseq else : alt), [
               `pred => pred(c)
               `conseq => compile(conseq(c))
               `alt => compile(alt(c))])
         (c:CustomChecker) :
            exp(c)
         (c:SwitchChecker) :
            val template = `(
               switch pred :
                  clauses{key : check}
                  else : else-check)
            fill-template(template, [
               `pred => pred(c)
               `clauses => for c in clauses(c) fill-each : [
                  `key => key(c)
                  `check => compile(value(c))]
               `else-check => compile(else-clause(c))])
         (c:BeginChecker) :
            map(compile, checkers(c))

   ;Compiling a form specification
   defn compile (s:FormSpec) :
      val template = `(
         defn name (e:type) :
            var pass? = true
            match(e) :
               type-clauses{
                  (e:type) :
                     check
                     false}
               (e) :
                  lang/check/invalid-form(description, e)
                  pass? = false
            if pass? :
               after-clauses{exp}
               false)
      val [type-clauses, after-clauses] = all-clauses(s)
      fill-template(template, [
         `name => #type(s)
         `pass? => gensym()
         `e => exp(d)
         `type => type(d)
         `description => description(s)
         `type-clauses => for c in type-clauses fill-each : [
            `type => type(c)
            `check => compile(checker(c))]
         `after-clauses => for c in after-clauses fill-each : [
            `exp => exp(c)]])

   ;Compiling the DefCheck
   val template = `(
      defn check (e:type) :
         checkers
         lang/check/run-check(check0, e))
   fill-template(template, [
      `check => name(d)
      `e => exp(d)
      `type => type(d)
      `checkers => splice(map(compile, specs(d)))
      `check0 => #type(head(specs(d)))])

;;============================================================
;;=============== defrenamer lang ============================
;;============================================================
;
;defpackage stz/renamer-lang :
;   import core
;   import verse
;   import core/macro-utils
;   import stz/lexer
;
;;======== Parse Structures ========
;definterface Arg
;defstruct SimpleArg <: Arg :
;   name: Symbol
;   type: Symbol
;defstruct IgnoreArg <: Arg :
;   name: Symbol
;defstruct ScopeArg <: Arg :
;   args: List<Arg>
;defstruct GroupArg <: Arg :
;   args: List<Arg>
;defstruct PublicArg <: Arg :
;   args: List<Arg>
;defstruct ProtectedArg <: Arg :
;   args: List<Arg>
;
;definterface Body
;defstruct IgnoreBody <: Body
;defstruct FormBody <: Body :
;   args: List<Arg>
;defstruct MapBody <: Body :
;   type: Symbol
;defstruct RecurBody <: Body :
;   type: Symbol
;
;defstruct Clause :
;   node: Symbol
;   body: Body
;
;definterface Renamer
;defmulti abbr (r:Renamer) -> Symbol
;defmulti name (r:Renamer) -> Symbol
;defstruct TypeRenamer <: Renamer :
;   abbr: Symbol with: (as-method => true)
;   name: Symbol with: (as-method => true)
;   clauses: List<Clause>
;defstruct CustomRenamer <: Renamer :
;   abbr: Symbol with: (as-method => true)
;   name: Symbol with: (as-method => true)
;   arglist: List
;   body
;
;defstruct DefRenamers :
;   renamers: List<Renamer>
;
;;======== Syntax Definition ========
;defsyntax stz/rename-lang :
;   defn sym? (x) :
;      match(unwrap-token(x)) :
;         (x:Symbol) : x != `...
;         (x) : false
;
;   defrule :
;      sym = (?x) when sym?(x) : unwrap-token(x)
;      prefix-op = (defrenamers : (?rs:#renamer ...)) :
;         stz/langs/expande(compile(DefRenamers(rs)))
;
;      renamer = (custom ?abbr:#sym ?name:#name? (?arglist ...) : ?body:#exp) :
;         CustomRenamer(abbr, name, arglist, body)
;      renamer = (?abbr:#sym ?name:#name? : (?cs:#clause ...)) :
;         TypeRenamer(abbr, name, cs)      
;      name? = ((@do ?name:#sym)) : name      
;      name? = () : gensym()
;
;      clause = (?node:#sym : ?b:#body) :
;         Clause(node, b)
;      body = (goto ?type:#sym) :
;         RecurBody(type)
;      body = ((~ _:?)) :
;         IgnoreBody()
;      body = ((~ _:?type:#sym)) :
;         MapBody(type)
;      body = ((?xs:#arg ...)) :
;         FormBody(xs)
;         
;      arg = (?x:#sym : ?) :
;         IgnoreArg(x)
;      arg = (?x:#sym : ?t:#sym) :
;         SimpleArg(x, t)
;      arg = ({?xs:#arg ...}) :
;         ScopeArg(xs)
;      arg = (group{?xs:#arg ...}) :
;         GroupArg(xs)
;      arg = (public{?xs:#arg ...}) :
;         PublicArg(xs)
;      arg = (protected{?xs:#arg ...}) :
;         ProtectedArg(xs)
;
;
;
;
;;======== Compilation ========
;defn fill-each<?T> (f: T -> Streamable<KeyValue<Symbol,?>>, xs:Streamable<?T>) :
;   nested(stream(f, xs))
;
;defn compile (d:DefRenamers) :
;   defn memoize<?T> (f: Symbol -> ?T) :
;      val table = HashTable<Symbol,T>(symbol-hash)
;      fn (x:Symbol) :
;         if not key?(table, x) :
;            table[x] = f(x)
;         table[x]
;
;   ;Temporary names
;   val #e = gensym()
;
;   ;Temporary names for arguments
;   val arg-names = memoize(gensym)
;   defn #name (a:SimpleArg|IgnoreArg) :
;      arg-names(name(a))
;   defn #names (a:List<Arg>) -> List<Symbol> :
;      map-append(#names, a)
;   defn #names (a:Arg) :
;      match(a) :
;         (a:SimpleArg|IgnoreArg) : list(#name(a))
;         (a:ScopeArg|GroupArg|PublicArg|ProtectedArg) : #names(args(a))      
;
;   ;Renamer name given abbreviation
;   val abbr-name = memoize $ fn (ab:Symbol) :
;      val r = for r in renamers(d) find :
;         abbr(r) == ab
;      match(r) :
;         (r:False) : error("No renamer with abbreviation ~." % [ab])
;         (r:Renamer) : name(r)
;   defn #type (a:SimpleArg) : abbr-name(type(a))
;   defn #type (b:MapBody|RecurBody) : abbr-name(type(b))
;
;   defn compile (a:Arg) :
;      match(a) :
;         (a:SimpleArg) :
;            fill-template(`(val #name = #map(t, name(e))), [
;               `t => #type(a)
;               `name => name(a)
;               `#name => #name(a)
;               `e => #e])
;         (a:IgnoreArg) :
;            fill-template(`(val #name = name(e)), [
;               `name => name(a)
;               `#name => #name(a)
;               `e => #e])
;         (a:ScopeArg) :
;            val template = `(
;               begin-scope()
;               val #vis = visibility
;               visibility = Local()
;               args
;               visibility = #vis
;               end-scope())               
;            fill-template(template, [
;               `#vis => gensym()
;               `args => splice(stream(compile, args(a)))])
;         (a:GroupArg) :
;            val template = `(
;               begin-group()
;               args
;               end-group())
;            fill-template(template, [
;               `args => splice(stream(compile, args(a)))])
;         (a:PublicArg|ProtectedArg) :
;            val template = `(
;               val #vis = visibility
;               visibility = public?{Public()}{Protected()}
;               args
;               visibility = #vis)
;            fill-template(template, [
;               `#vis => gensym()
;               `public? => choice(a typeof PublicArg)
;               `args => splice(stream(compile, args(a)))])
;
;   defn compile (node:Symbol, b:Body) :
;      match(b) :
;         (b:IgnoreBody) :
;            #e            
;         (b:FormBody) :
;            fill-template(`(args, Node(#args)), [
;               `args => splice(stream(compile, args(b)))
;               `#args => splice(#names(args(b)))
;               `Node => node])            
;         (b:MapBody) :
;            fill-template(`(map(t, e)), [
;               `t => #type(b)
;               `e => #e])
;         (b:RecurBody) :
;            fill-template(`(t(e)), [
;               `t => #type(b)
;               `e => #e])
;
;   defn compile (r:Renamer) :
;      match(r) :
;         (r:TypeRenamer) :
;            val template = `(
;               defn name (e:IExp) :
;                  match(e) :
;                     clauses{(e:Node) : body})
;            fill-template(template, [
;               `name => name(r)
;               `e => #e
;               `clauses => for c in clauses(r) fill-each : [
;                  `Node => node(c)
;                  `body => compile(node(c), body(c))]])
;         (r:CustomRenamer) :
;            val template = `(defn name arglist : body)
;            fill-template(template, [
;               `name => name(r)
;               `arglist => arglist(r)
;               `body => body(r)])
;
;   val r = list(map(compile, renamers(d)))
;   println("=== defrenamer ===")
;   println(r)
;   r

;============================================================
;================ defresolver lang ==========================
;============================================================

defpackage stz/resolver-lang :
   import core
   import verse
   import core/macro-utils
   import stz/lexer

;======== Parse Structures ========
definterface Arg
defstruct Define <: Arg :
   name: Symbol
defstruct Field <: Arg :
   name: Symbol
   prod: Symbol
defstruct Scope <: Arg :
   arg: Arg
defstruct Begin <: Arg :
   args: List<Arg>

definterface Clause
defstruct MapClause <: Clause :
   node
   prod: Symbol
defstruct ResolveClause <: Clause :
   node
   type: Symbol
defstruct PlusClause <: Clause :
   prod: Symbol
defstruct NodeClause <: Clause :
   node: Symbol
   arg: Arg

definterface Prod
defmulti prod (p:Prod) -> Symbol
defmulti type (p:Prod) -> ?
defstruct DefineProd <: Prod :
   prod: Symbol with: (as-method => true)
   type: ? with: (as-method => true)
   clauses: List<Clause>
defstruct ResolveProd <: Prod :
   prod: Symbol with: (as-method => true)
   type: ? with: (as-method => true)
   clauses: List<Clause>

defstruct Structure :
   nodes: List<Symbol>
   args: List<List<Symbol>>

defstruct DefResolver :
   name
   exp
   type
   eng
   eng-type
   structure: Structure
   prods: List<Prod>

;======== Syntax Definition ========
defsyntax stz/resolver-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      prefix-op = (defresolver ?name:#sym (?exp:#sym:?type:#type, ?eng:#sym:?eng-type:#type) :
                      ?s:#structure
                      ?ps:#prod ...) :
         stz/langs/expande(compile(DefResolver(name, exp, type, eng, eng-type, s, ps)))

      structure = (structure :
                      (?nodes:#sym (?args:#sym ...)) @...) :
         Structure(nodes, args)
         
      prod = (define ?prod:#sym ?type:#type? : (?cs:#clause ...)) :
         DefineProd(prod, type, cs)
      prod = (resolve ?prod:#sym ?type:#type? : (?cs:#clause ...)) :
         ResolveProd(prod, type, cs)

      type? = ((?t:#type)) : t
      type? = () : false

      clause = (?node:#type : (~ _:?p:#sym)) : MapClause(node, p)
      clause = (?node:#type : resolve ?type:#sym) : ResolveClause(node, type)
      clause = (+ ?prod:#sym) : PlusClause(prod)
      clause = (?node:#sym : ?arg:#arg) : NodeClause(node, arg)
      
      arg = (?name:#sym :+) : Define(name)
      arg = (?name:#sym : ?prod:#sym) : Field(name, prod)
      arg = ({?args:#arg ...}) : Scope(Begin(args))
      arg = ((?args:#arg ...)) : Begin(args)


;======== Compilation ========
defn fill-each<?T> (f: T -> Streamable<KeyValue<Symbol,?>>, xs:Streamable<?T>) :
   nested(stream(f, xs))

defn compile (d:DefResolver) :
   ;Utilities
   defn memoize<?T> (f: Symbol -> ?T) :
      val table = HashTable<Symbol,T>(symbol-hash)
      fn (x:Symbol) :
         if not key?(table, x) :
            table[x] = f(x)
         table[x]

   ;Temporaries
   val #e = gensym()
   val #eng = gensym()

   ;Field name
   val #get-name = memoize(gensym{})
   defn #name (x:Symbol) : #get-name(x)
   defn #name (a:Field) : #get-name(name(a))
   
   ;Production name table
   val prod-table = HashTable<Symbol,Symbol>(symbol-hash)
   for p in prods(d) do : prod-table[prod(p)] = gensym()
   defn #prod (x:Field|MapClause|PlusClause|Prod) :
      prod-table[prod(x)]

   ;First resolver
   val resolver0 = #prod{_ as Prod} $
      for p in prods(d) find :
         p typeof ResolveProd
      
   ;Define table   
   val def-table = HashTable<Symbol,True|False>(symbol-hash)
   for p in prods(d) do : def-table[prod(p)] = p typeof DefineProd
   defn define? (prod:Symbol) :
      def-table[prod]

   ;Structure table
   val struct-table = HashTable<Symbol, List<Symbol>>(symbol-hash)
   for (n in nodes(structure(d)), args in args(structure(d))) do : struct-table[n] = args
   defn constructor-args (n:Symbol, arg:Arg) :
      for x in struct-table[n] map :
         if mapped?(x, arg) : #name(x)
         else : qquote(~ x(~ #e))

   defn mapped? (x:Symbol, a:Arg) :
      match(a) :
         (a:Define) : false
         (a:Field) : (name(a) == x) and (not define?(prod(a)))
         (a:Scope) : mapped?(x, arg(a))
         (a:Begin) : for a in args(a) any? : mapped?(x, a)
   
   defn compile (a:Arg) -> ? :
      match(a) :
         (a:Define) :
            fill-template(`(#do(#new-definition, name(#e))), [
               `#eng => #eng,
               `#e => #e,
               `name => name(a)])
         (a:Field) :
            val template = `(
               define?{
                  #do(#prod, name(#e))}{
                  val #name = #map(#prod, name(#e))})
            fill-template(template, [
               `define? => choice(define?(prod(a)))
               `#prod => #prod(a)
               `#e => #e
               `#name => #name(a)
               `name => name(a)])
         (a:Scope) :
            val template = `(
               new-scope(#eng)
               arg
               end-scope(#eng))
            fill-template(template, [
               `#eng => #eng
               `arg => compile(arg(a))])
         (a:Begin) :
            map(compile, args(a))

   defn compile (def?:True|False, c:Clause) :
      match(def?, c) :
         (_, c:MapClause) :
            val template = `(
               (#e:Node) : 
                  define?{
                     do(#prod, #e)}{
                     map(#prod, #e)})
            fill-template(template, [
               `define? => choice(define?(prod(c)))
               `#prod => #prod(c)
               `#e => #e               
               `Node => node(c)])
         (_, c:ResolveClause) :
            val template = `(
               (#e:Node) :
                  resolve-type(#eng, #e))
            fill-template(template, [
               `#eng => #eng
               `#e => #e
               `Node => node(c)
               `resolve-type => to-symbol("resolve-~" << [type(c)])])               
         (_, c:PlusClause) :
            val template = `(
               (#e) : #prod(#e))
            fill-template(template, [
               `#e => #e
               `#prod => #prod(c)])
         (_:True, c:NodeClause) :
            fill-template(`((#e:Node) : arg), [
               `#e => #e
               `Node => node(c)
               `arg => compile(arg(c))])
         (_:False, c:NodeClause) :
            val template = `(
               (#e:Node) :
                  arg
                  Node(fields))
            fill-template(template, [
               `#e => #e
               `Node => node(c)
               `arg => compile(arg(c))
               `fields => splice(constructor-args(node(c), arg(c)))])

   defn compile (p:Prod) :
      match(p) :
         (p:DefineProd) :
            val template = `(
               defn #prod (#e:type) -> core/False :
                  match(#e) :
                     clauses{c})
            fill-template(template, [
               `#prod => #prod(p)
               `#e => #e
               `type => type!(p)
               `clauses => for c in clauses(p) fill-each : [
                  `c => splice(compile(true, c))]])
         (p:ResolveProd) :
            val template = `(
               defn #prod (#e:type) :
                  match(#e) :
                     clauses{c})
            fill-template(template, [
               `#prod => #prod(p)
               `#e => #e
               `type => type!(p)
               `clauses => for c in clauses(p) fill-each : [
                  `c => splice(compile(false, c))]])

   defn type! (p:Prod) :
      match(type(p)) :
         (p:False) : type(d)
         (p) : p

   val template = `(
      defn name (#e:type, #eng:engtype) :
         defn #map<?S,?T> (f:T -> ?S , x: ?T) : f(x)
         defn #map<?S,?T> (f:T -> ?S, x: List<?T>) : core/map(f, x)
         defn #do<?S,?T> (f:T -> ?S , x: ?T) : f(x)
         defn #do<?S,?T> (f:T -> ?S, x: List<?T>) : core/do(f, x)
         defn #new-definition (#e:type) : new-definition(#eng, #e)
         resolvers
         resolver0(#e))
   fill-template(template, [
      `name => name(d),
      `#e => #e
      `type => type(d)
      `#eng => #eng
      `engtype => eng-type(d)
      `resolvers => map(compile, prods(d))
      `resolver0 => resolver0])