defpackage stz/langs :
   import core

public defn expande (e) :
   with-syntax(core) :
      match-syntax(e) :
         (?e:#exp) :
            e

;============================================================
;================ defast Lang ===============================
;============================================================

defpackage stz/ast-lang :
   import core
   import verse
   import core/macro-utils

;======== PARSING STRUCTURES ========
defstruct DefAst :
   types: List<DefType>
   nodes: List<DefNodes>
defstruct DefType :
   name: Symbol
   parent
   fields: List
defstruct DefNodes :
   type: Symbol
   nodes: List<Node>
defstruct Node :
   name: Symbol
   fields: List

;======== PARSING ========
defsyntax stz/ast-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      prefix-op = (defast : (?types:#deftype ... ?nodes:#defnode ...)) :
         stz/langs/expande(compile(DefAst(types, nodes)))
      deftype = (deftype ?name:#sym ?parent:#parent : (?fields ...)) :
         DefType(name, parent, fields)
      deftype = (deftype ?name:#sym ?parent:#parent) :
         DefType(name, parent, List())         
      parent = (<: ?t:#type) : t
      parent = () : false
      defnode = (defnodes ?name:#sym : (?nodes:#node ...)) :
         DefNodes(name, nodes)
      node = (?name:#sym : (?fields ...)) :
         Node(name, fields)
      node = (?name:#sym) :
         Node(name, List())

;======== COMPILATION ========
defn compile (d:DefAst) :
   defn typefields (n:Symbol) :
      label<List> return :
         for t in types(d) do :
            if name(t) == n :
               return(fields(t))
         error("No type named ~." % [n])      
   defn comp (d:DefType) :
      val template = `(definterface name parent?{<: parent}{})
      fill-template(template, [
         `name => name(d)
         `parent? => choice(parent(d) != false)
         `parent => parent(d)])         
   defn comp (d:DefNodes) :
      val tfs = typefields(type(d))
      defn comp (n:Node) :
         val template = `(defstruct name <: type : (fs tfs))
         fill-template(template, [
            `name => name(n),
            `type => type(d),
            `fs => splice(fields(n)),
            `tfs => splice(tfs)])
      map-append(comp, nodes(d))
      
   list(append(
      map-append(comp, types(d))
      map-append(comp, nodes(d))))

;============================================================
;================= defreader Lang ===========================
;============================================================
defpackage stz/reader-lang :
   import core
   import verse
   import core/macro-utils
   
defstruct DefReader :
   name: Symbol
   prods: List<Prod>
defstruct Prod :
   name: Symbol
   type
   forms: List<Form>   
definterface Form
defstruct TagForm <: Form :
   tag: Symbol
   fields: List<Field>
   body
defstruct SForm <: Form :
   body
defstruct VForm <: Form :
   body
defstruct Field :
   name: Symbol
   prod: Symbol
   type: Int

val STYPE = 0
val LTYPE = 1
val RTYPE = 2
   
defsyntax stz/reader-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      prefix-op = (defreader ?name:#sym :
                      (?ps:#sym -> ?ts:#type :
                          ?fs:#form ...) @...) :
         val d = DefReader(name, map(Prod, ps, ts, fs))
         stz/langs/expande(compile(d))
      form = ((?tag:#sym ?fs:#field ...) : ?body:#exp) :
         TagForm(tag, fs, body)
      form = (x : ?body:#exp) :
         SForm(body)
      form = (v : ?body:#exp) :
         VForm(body)
      field = (?name:#sym : ?prod:#sym ~ ...) :
         Field(name, prod, RTYPE)
      field = (?name:#sym : ?prod:#sym) :
         Field(name, prod, STYPE)
      field = ((?name:#sym : ?prod:#sym ~ ...)) :
         Field(name, prod, LTYPE)


defmulti compile-body (f:Form, ret, prod-type: Symbol -> ?) -> List

defmethod compile-body (f:TagForm, ret, prod-type: Symbol -> ?) :
   defn field-type (t:Int, ptype) :
      switch {t == _} :
         STYPE : ptype
         LTYPE : qquote(List<~ ptype>)
         RTYPE  : qquote(List<~ ptype>)
   val template = `(
      fn (#array:Array, info:FileInfo) -> ret :
         fields{val name:type = #array[i]}
         body)
   fill-template(template, [
      `body => body(f)
      `ret => ret
      `fields => nested $ for (f in fields(f), i in 0 to false) stream : [
         `name => name(f)
         `type => field-type(type(f), prod-type(prod(f)))
         `i => i]])
   
defmethod compile-body (f:SForm, ret, prod-type: Symbol -> ?) :
   val template = `(
      fn (x:Symbol, info:FileInfo) -> ret :
         body)
   fill-template(template, [
      `body => body(f),
      `ret => ret])

defmethod compile-body (f:VForm, ret, prod-type: Symbol -> ?) :
   val template = `(
      fn (v:?, info:FileInfo) -> ret :
         body)
   fill-template(template, [
      `body => body(f),
      `ret => ret])
      
defn compile (f:Field) :
   val template = `(type{SField(`prod)}{LField(`prod)}{RField(`prod)})
   fill-template(template, [
      `type => choice(type(f))
      `prod => prod(f)])

defmulti compile (f:Form, ret, prod-type: Symbol -> ?) -> List

defmethod compile (f:TagForm, ret, prod-type: Symbol -> ?) :
   val template = `(TagForm(`tag, [fs], body))
   fill-template(template, [
      `tag => tag(f)
      `fs => splice(map(compile, fields(f)))
      `body => compile-body(f, ret, prod-type)])

defmethod compile (f:SForm, ret, prod-type: Symbol -> ?) :
   val template = `(SForm(body))
   fill-template(template, [
      `body => compile-body(f, ret, prod-type)])

defmethod compile (f:VForm, ret, prod-type: Symbol -> ?) :
   val template = `(VForm(body))
   fill-template(template, [
      `body => compile-body(f, ret, prod-type)])

defn compile (d:DefReader) :
   defn prod-type (n:Symbol) :
      label return :
         return(`?) when n == `?
         for p in prods(d) do :
            return(type(p)) when name(p) == n
         error("No production named ~" % [n])

   val template = `(
      val name = FormTable $ [
         prods{`name => [fs]}])
   fill-template(template, [
      `name => name(d),
      `prods => nested $ for p in prods(d) stream : [
         `name => name(p)
         `fs => splice(map(compile{_, type(p), prod-type}, forms(p)))]])


;============================================================
;================= defast-printer Lang ======================
;============================================================
defpackage stz/ast-printer-lang :
   import core
   import verse
   import core/macro-utils

defstruct DefAstPrinter :
   exp: Symbol
   type
   clauses: List<Clause>
defstruct Clause :
   type
   form: Form
definterface Form
defstruct TagForm <: Form :
   tag: Symbol
   fields: List<Field>
defstruct SForm <: Form :
   name: Symbol
defstruct IfForm <: Form :
   pred
   conseq: Form
   alt: Form

definterface Field
defmulti name (f:Field) -> Symbol
defstruct SField <: Field :
   name:Symbol with: (as-method => true)
defstruct LField <: Field :
   name:Symbol with: (as-method => true)
defstruct RField <: Field :
   name:Symbol with: (as-method => true)

defsyntax stz/printer-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      prefix-op = (defprinter (?name:#sym : ?type:#type) :
                      ?clauses:#clause ...) :
         val d = DefAstPrinter(name, type, clauses)
         stz/langs/expande(compile(d))
      clause = (?t:#type : (?f:#form)) :
         Clause(t, f)
      form = ((?tag:#sym ?fs:#field ...)) :
         TagForm(tag, fs)
      form = (if ?pred:#exp : ?conseq:#form else : ?alt:#form) :
         IfForm(pred, conseq, alt)
      form = (?name:#sym) :
         SForm(name)
      field = (?name:#sym ~ ...) :
         RField(name)
      field = (?name:#sym) :
         SField(name)
      field = ((?name:#sym ~ ...)) :
         LField(name)

defn format-string (f:TagForm) :
   val o = StringBuffer()
   print(o, "(~" << [tag(f)])
   for f in fields(f) do :
      print{o, _} $ match(f) :
         (f:SField) : " ~"
         (f:LField) : " (~@)"
         (f:RField) : "~@"
   print(o, ")")
   to-string(o)

defn value-obj (e:Symbol, f:Field) :
   val template = match(f) :
      (f:SField) : `(name(e))
      (f:LField) : `(core/join(name(e) as core/List, " "))
      (f:RField) : `(core/stream-concat(list{" ", _}, name(e) as core/List))
   fill-template(template, [
      `name => name(f)
      `e => e])

defn compile (e:Symbol, f:Form) :
   match(f) :
      (f:TagForm) :
         val template = `(core/print(#o, str << [vs]))
         fill-template(template, [
            `str => format-string(f)
            `vs => splice(map(value-obj{e, _}, fields(f)))])
      (f:SForm) :
         val template = `(core/print(#o, name(e)))
         fill-template(template, [
            `name => name(f)
            `e => e])
      (f:IfForm) :
         val template = `(if pred : conseq else : alt)
         fill-template(template, [
            `pred => pred(f)
            `conseq => compile(e, conseq(f))
            `alt => compile(e, alt(f))])

defn compile (d:DefAstPrinter) :
   val template = `(
      defmethod print (#o:core/OutputStream, e:Type) :
         match(e) :
            clauses{(e:Type) : body})
   fill-template(template, [
      `e => exp(d)
      `Type => type(d)
      `clauses => nested $
         for c in clauses(d) stream : [
            `Type => type(c)
            `body => compile(exp(d), form(c))]])

               