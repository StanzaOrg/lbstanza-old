defpackage stz/input-lang :
   import core
   import verse
   import core/macro-utils

;============================================================
;================ Reader Lang ===============================
;============================================================

;======== PARSING STRUCTURES ========
defstruct Reader :
   reader: Symbol
   error: False|Symbol

definterface ListClause
defstruct TagClause <: ListClause :
   tag: Symbol
   args: List<Symbol>
   rest?: True|False
   readers: List<KeyValue<Symbol, Reader>>
   body: ?
defstruct ElseClause <: ListClause :
   body

definterface TypeForm
defstruct ListTypeForm <: TypeForm : (clauses: List<ListClause>)
defstruct DefaultTypeForm <: TypeForm : (type, body)

defstruct DefReader :
   name: Symbol
   form: Symbol
   inf: Symbol
   typeforms: List<TypeForm>

;======== PARSING ========
defsyntax stz/input-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      rest = (~ ...) : true
      rest = () : false
      reader = (?name:#sym => ?r:#sym (?e:#sym)) : name => Reader(r, e)
      reader = (?name:#sym => ?r:#sym) : name => Reader(r, false)
      listclause = ((?tag:#sym ?args:#sym ... ?r:#rest) :
                       ?readers:#reader ...
                       ?body ...) :
         if map(key, readers) != args :
            error("Given arguments are ~@, but given readers are ~@." % [
               join(args, ", "), join(map(key, readers), ", ")])
         TagClause(tag, args, r, readers, body)
      listclause = (else : ?body:#exp) :
         ElseClause(body)
      typeform = (List : (?cs:#listclause ...)) : ListTypeForm(cs)
      typeform = (?t:#type : ?body:#exp) : DefaultTypeForm(t, body)
      prefix-op = (defreader ?name:#sym (?f:#sym, ?inf:#sym) :
                      ?typeforms:#typeform ...) :
         println("=== Parse Result ===")
         println(DefReader(name, f, inf, typeforms))
         val r = compile(DefReader(name, f, inf, typeforms))
         println(r)
         expande(r)

;======== COMPILATION ========
defn compile (d:DefReader) :
   defn compile (c:ListClause) :
      match(c) :
         (c:TagClause) :
            val template = `(
               `tag :
                  rest?{
                     ensure-min-arity(n - 1)}{
                     ensure-arity(n)}
                  readers{
                     val name = error?{
                        try-read(error, read, rest?{tailn(form,i)}{form[i]})}{
                        read(rest?{tailn(form,i)}{form[i]}, inf)}}
                  body)
            fill-template(template, [
               `tag => tag(c),
               `body => body(c),
               `form => form(d),
               `inf => inf(d),
               `rest? => choice(rest?(c)),
               `n => length(args(c)),
               `readers => nested $ for (r in readers(c), i in 0 to false) stream : [
                  `i => i,
                  `name => key(r),
                  `read => reader(value(r)),
                  `error? => choice(error(value(r)) != false),
                  `error => error(value(r))]])
         (c:ElseClause) :
            qquote(else : ~ (body(c)))

   defn compile (t:TypeForm) :
      match(t) :
         (t:ListTypeForm) :
            val template = `(
               (form:List) :
                  defn try-read<?T,?S> (error: (List, FileInfo) -> ReadError, f: (S, FileInfo) -> ?T, x: ?S) :
                     try :
                        f(x, inf)
                     catch (e) :
                        add(read-errors, error(form, first-info(inf, first-info(form))))
                        throw(ReadError())
                  defn ensure-arity (n:Int) :
                     if length(form) - 1 != n :
                        throw(ArityError(form, n, inf))
                  defn ensure-min-arity (n:Int) :
                     if length(form) - 1 < n :
                        throw(MinArityError(form, n, inf))                        
                  val inf = if empty?(head(form)) : inf
                            else : first-info(first-info(head(form)), inf)
                  switch tagged-list?{form, _} :
                     clauses)
            fill-template(template, [
               `form => form(d),
               `inf => inf(d),
               `clauses => splice(map-append(compile, clauses(t)))])

         (t:DefaultTypeForm) :
            val template = `(
               (form:Type) : body)
            fill-template(template, [
               `form => form(d),
               `Type => type(t),
               `body => body(t)])

   val template = `(
      defn name (form, inf:FileInfo) :
         match(form) :
            (form:Token) :
               name(form, first-info(inf, info(form)))
            typeforms)
   fill-template(template, [
      `name => name(d),
      `form => form(d),
      `inf => inf(d),
      `typeforms => splice(map-append(compile, typeforms(d)))])

defn expande (e) :
   match-syntax(e) :
      (?e:#exp) :
         e


;======== DEBUG ========
defmethod print (o:OutputStream, r:Reader) :
   print(o, "~ (~)" << [reader(r), error(r)])

defmethod print (o:OutputStream, c:ListClause) :
   print{o, _} $ match(c) :
      (c:TagClause) : "(~ ~@ ~) : (~@, ~)" << [
         tag(c),
         join(args(c), " "),
         "..." when rest?(c) else ""
         join(readers(c), " "),
         body(c)]
      (c:ElseClause) : "(else : ~)" << [body(c)]

defmethod print (o:OutputStream, t:TypeForm) :
   print{o, _} $ match(t) :
      (t:ListTypeForm) : "(List : (~@))" << [join(clauses(t), " ")]
      (t:DefaultTypeForm) : "(~ : ~)" << [type(t), body(t)]

defmethod print (o:OutputStream, r:DefReader) :
   print(o, "($defreader ~ (~ ~) ~@)" << [
      name(r),
      form(r),
      inf(r),
      join(typeforms(r), " ")])