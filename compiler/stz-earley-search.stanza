defpackage stz/earley-search :
  import core
  import collections
  import stz/earley-eitems
  import stz/earley-grammar
  import stz/earley-sexp-stream
  import stz/earley-errors

;============================================================
;======================= ESet ===============================
;============================================================

deftype ESet <: Collection<EItem>
defmulti start-completed? (s:ESet) -> True|False
defmulti scanned-atomic-any? (s:ESet) -> True|False
defmulti scanned-non-reluctant? (s:ESet) -> True|False
defmulti scanned-non-reluctant-list-start? (s:ESet) -> True|False
defmulti scanned-rest? (s:ESet) -> True|False
defmulti wildcard-expected? (s:ESet) -> True|False
defmulti list-expected? (s:ESet) -> True|False
defmulti list-end-expected? (s:ESet) -> True|False
defmulti add (s:ESet, item:EItem) -> False
defmulti clear (s:ESet, length:Int) -> False
defmulti length (s:ESet) -> Int
defmulti get (s:ESet, i:Int) -> EItem
defmulti map! (f:EItem -> EItem, s:ESet) -> False
defmulti remove! (f:EItem -> True|False, s:ESet) -> False

defn ESet (ctrl:SearchControls) :
  ;Accumulate items
  val items = Vector<EItem>()

  ;Track flags
  var start-completed?:True|False
  var scanned-atomic-any?:True|False
  var scanned-non-reluctant?:True|False
  var scanned-non-reluctant-list-start?:True|False
  var scanned-rest?:True|False
  var wildcard-expected?: True|False
  var list-expected?: True|False
  var list-end-expected?: True|False

  defn recompute-flags () :
    start-completed? = false
    scanned-atomic-any? = false
    scanned-non-reluctant? = false
    scanned-non-reluctant-list-start? = false
    scanned-rest? = false
    wildcard-expected? = false
    list-expected? = false
    list-end-expected? = false
    do(process-flags, items)

  defn process-flags (item:EItem) :
    ;Set flags for what was scanned.
    val prev-item = prev-token(ctrl,item)
    match(prev-item) :
      (t:GAny) :
        if type(t) is Atomic : scanned-atomic-any? = true
      (t:GListStart) :
        if not reluctant?(t) :
          scanned-non-reluctant-list-start? = true
      (t:GListRest) :
        scanned-rest? = true
      (t) :
        false

    ;Process scanned non-reluctant flag
    if non-reluctant-terminal?(prev-item) :
      scanned-non-reluctant? = true

    ;Set flags for what is upcoming
    match(next-token(ctrl,item)) :
      (t:GListStart) :
        list-expected? = true
      (t:GListEnd) :
        list-end-expected? = true
      (t:GTerminal) :
        wildcard-expected? = true
      (t:False) :
        if rule(item) == 0 : start-completed? = true
      (t) :
        false

  recompute-flags()
  new ESet :
    ;===== Set Operations =====
    defmethod clear (this, l:Int) :
      shorten(items, l)
      recompute-flags()
    defmethod add (this, item:EItem) :
      add(items, item)
      process-flags(item)
    defmethod get (this, i:Int) : items[i]
    defmethod length (this) : length(items)
    defmethod to-seq (this) : to-seq(items)
    ;===== Compute =====
    defmethod map! (f:EItem -> EItem, this) :
      map!(f, items)
    defmethod remove! (f:EItem -> True|False, this) :
      remove-when(f, items)
      recompute-flags()
    ;===== Retrieve Flags =====
    defmethod start-completed? (this) : start-completed?
    defmethod scanned-atomic-any? (this) : scanned-atomic-any?
    defmethod scanned-non-reluctant? (this) : scanned-non-reluctant?
    defmethod scanned-non-reluctant-list-start? (this) : scanned-non-reluctant-list-start?
    defmethod scanned-rest? (this) : scanned-rest?
    defmethod wildcard-expected? (this) : wildcard-expected?
    defmethod list-expected? (this) : list-expected?
    defmethod list-end-expected? (this) : list-end-expected?

defmethod do (f:EItem -> ?, eset:ESet) :
  val item-index = to-seq(0 to false)
  while peek(item-index) < length(eset) :
    f(eset[next(item-index)])

defn empty? (s:ESet) :
  length(s) == 0

defn print-current-set (grammar:Grammar, set-index:Int, current-set:ESet) :
  println("Set %_" % [set-index])
  within indented() :
    do(println{format(grammar,_)}, current-set)

;============================================================
;============= Classification of Terminals ==================
;============================================================

;Returns true if the given terminal is a reluctant terminal.
defn reluctant-terminal? (t:GTerminal) :
  match(t) :
    (t:GListStart) : reluctant?(t)
    (t:GAny) : type(t) is Reluctant
    (t:GListRest) : true
    (t) : false

;Returns true if the given token is a non-reluctant terminal.
defn non-reluctant-terminal? (t:GToken|False) :
  match(t:GTerminal) : not reluctant-terminal?(t)
  else : false

;============================================================
;=================== Saved Matches ==========================
;============================================================

deftype SavedMatches
defmulti save (s:SavedMatches, position:Int, s:GTerminal) -> False
defmulti matched? (s:SavedMatches, position:Int, s:GTerminal) -> True|False

defn SavedMatches (grammar:Grammar) :
  ;Compute number of matcher-id tokens.
  defn num-matcher-ids (g:Grammar) -> Int :
    val all-tokens = seq-cat(tokens, g)
    val ids = for t in filter-by<GMatcherToken>(all-tokens) seq :
      matcher-id(t) + 1
    maximum(0, ids)
  
  ;Saved index => set-index pairs
  val matched = Array<Vector<Int>>(3 + num-matcher-ids(grammar))
  for i in 0 to length(matched) do :
    matched[i] = Vector<Int>()

  ;Retrieve category index of special terminal.
  defn index (t:GTerminal) :
    match(t) :
      (t:GListRest) : 0
      (t:GAny) : 1
      (t:GListStart) : 2
      (t:GMatcherToken) : matcher-id(t) + 3

  new SavedMatches :
    defmethod save (this, position:Int, s:GTerminal) :
      val pos = matched[index(s)]
      if empty?(pos) or peek(pos) < position :
        add(pos, position)
    defmethod matched? (this, position:Int, s:GTerminal) :
      val pos = matched[index(s)]
      let loop () :
        if empty?(pos) :
          false
        else :
          val p = peek(pos)
          if p == position :
            true
          else if p > position :
            pop(pos)
            loop()
          else :
            false
    defmethod print (o:OutputStream, this) :
      print(o, "SavedMatches:")
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, matched)

defn save-match? (t:GTerminal) -> True|False :
  match(t) :
    (t:GListRest) : true
    (t:GAny) : true
    (t:GMatcherToken) : true
    (t:GListStart) : reluctant?(t)
    (t) : false

;============================================================
;================= Matching Predicates ======================
;============================================================

;Returns true if the given terminal matches against the given input.
defn matches-input? (grammar:Grammar, t:GTerminal, input:SExpToken) :
  match(input) :
    ;Wildcard matching
    (input:SExpWildcard) :
      t is-not GListStart|GListEnd
    ;Form matching
    (input:SExpForm) :
      match(t) :
        (t:GKeyword) : unwrap-token(form(input)) == item(t)
        (t:GPrimToken) :
          switch(type(t)) :
            GCharType : unwrap-token(form(input)) is Char
            GByteType : unwrap-token(form(input)) is Byte
            GIntType : unwrap-token(form(input)) is Int
            GLongType : unwrap-token(form(input)) is Long
            GFloatType : unwrap-token(form(input)) is Float
            GDoubleType : unwrap-token(form(input)) is Double
            GStringType : unwrap-token(form(input)) is String
            GSymbolType : unwrap-token(form(input)) is Symbol
            GTrueType : unwrap-token(form(input)) is True
            GFalseType : unwrap-token(form(input)) is False
        (t:GListStart) : unwrap-token(form(input)) is List        
        (t:GAny) : true
        (t:GListRest) : true
        (t:GMatcherToken) : matches-input?(grammar, terminal(t), input) and
                            match?(grammar, matcher-id(t), form(input))
        (t) : false
    ;List end matching
    (input:SExpListEnd) :
      t is GListEnd

;============================================================
;====================== SearchControls ======================
;============================================================

deftype SearchControls
defmulti next-token (c:SearchControls, item:EItem) -> GToken|False
defmulti prev-token (c:SearchControls, item:EItem) -> GToken|False
defmulti next-token-is-last? (c:SearchControls, item:EItem) -> True|False
defmulti advance (c:SearchControls, item:EItem, matched-wildcard?:True|False) -> EItem
defmulti nullable? (c:SearchControls, t:GProduction) -> True|False
defmulti production (c:SearchControls, item:EItem) -> Int
defmulti predict (c:SearchControls, set-index:Int, t:GProduction) -> Seqable<EItem>
defmulti predict (c:SearchControls, set-index:Int, t:GProduction, input:SExpToken) -> Seqable<EItem>
defmulti start (c:SearchControls) -> EItem
defmulti print-set (c:SearchControls, set-index:Int, eset:ESet) -> False
defmulti matches-input? (c:SearchControls, set-index:Int, t:GTerminal, input:SExpToken) -> True|False
defmulti save-match (c:SearchControls, set-index:Int, t:GTerminal) -> False
defmulti supports-conditional-match? (c:SearchControls) -> True|False
defmulti num-productions (c:SearchControls) -> Int
defmulti taboo? (c:SearchControls, rule:Int, num-parsed:Int, completed:Int) -> True|False

defn forward-search (grammar:Grammar, saved:SavedMatches) -> SearchControls :
  new SearchControls :
    defmethod next-token (this, item:EItem) :
      upcoming(grammar, item)
    defmethod prev-token (this, item:EItem) :
      previous(grammar, item)
    defmethod next-token-is-last? (this, item:EItem) :
      val num-tokens = length(tokens(grammar[rule(item)]))
      num-parsed(item) == num-tokens - 1
    defmethod advance (this, item:EItem, matched-wildcard?:True|False) :
      inc-num-parsed(item, matched-wildcard?)
    defmethod nullable? (this, t:GProduction) :
      nullable?(grammar, id(t))
    defmethod production (this, item:EItem) :
      production(grammar, item)
    defmethod predict (this, set-index:Int, t:GProduction) :
      for r in rules(grammar, id(t)) seq :
        EItem(r, 0, set-index, false)
    defmethod predict (this, set-index:Int, t:GProduction, input:SExpToken) :
      for r in rules-with-prefix(grammar, id(t), input) seq :
        EItem(r, 0, set-index, false)
    defmethod start (this) :
      EItem(0, 0, 0, false)
    defmethod print-set (this, set-index:Int, eset:ESet) :
      print-current-set(grammar, set-index, eset)
    defmethod matches-input? (this, set-index:Int, t:GTerminal, input:SExpToken) :
      matches-input?(grammar, t, input)
    defmethod save-match (this, set-index:Int, t:GTerminal) :
      if save-match?(t) :
        save(saved, set-index, t)
    defmethod supports-conditional-match? (this) :
      true
    defmethod num-productions (this) :
      num-productions(grammar)
    defmethod taboo? (this, rule:Int, num-parsed:Int, completed:Int) :
      taboo?(grammar, rule, num-parsed, completed)

defn backward-search (grammar:Grammar, saved:SavedMatches, total-matched-length:Int) -> SearchControls :
  new SearchControls :
    defmethod next-token (this, item:EItem) :
      previous(grammar, item)
    defmethod prev-token (this, item:EItem) :
      upcoming(grammar, item)
    defmethod next-token-is-last? (this, item:EItem) :
      num-parsed(item) == 1
    defmethod advance (this, item:EItem, matched-wildcard?:True|False) :
      dec-num-parsed(item, matched-wildcard?)
    defmethod nullable? (this, t:GProduction) :
      nullable?(grammar, id(t))
    defmethod production (this, item:EItem) :
      production(grammar, item)
    defmethod predict (this, set-index:Int, t:GProduction) :
      for r in rules(grammar, id(t)) seq :
        val num-tokens = length(tokens(grammar[r]))
        EItem(r, num-tokens, set-index, false)
    defmethod predict (this, set-index:Int, t:GProduction, input:SExpToken) :
      for r in rules-with-suffix(grammar, id(t), input) seq :
        val num-tokens = length(tokens(grammar[r]))
        EItem(r, num-tokens, set-index, false)
    defmethod start (this) :
      val n = length(tokens(grammar[0]))
      EItem(0, n, 0, false)
    defmethod print-set (this, set-index:Int, eset:ESet) :
      print-current-set(grammar, set-index, eset)
    defmethod matches-input? (this, set-index:Int, t:GTerminal, input:SExpToken) :
      if save-match?(t) :
        val position = total-matched-length - set-index - 1
        matched?(saved, position, t)
      else :
        matches-input?(grammar, t, input)
    defmethod save-match (this, set-index:Int, t:GTerminal) :
      false
    defmethod supports-conditional-match? (this) :
      false
    defmethod num-productions (this) :
      num-productions(grammar)
    defmethod taboo? (this, rule:Int, num-parsed:Int, completed:Int) :
      taboo?(grammar, rule, num-parsed - 1, completed)

;============================================================
;=================== Search Result ==========================
;============================================================

public deftype SearchResult

public defstruct SearchSuccess <: SearchResult :
  setlist: ESetList
  inputlist: Vector<SExpToken>
  infolist: Vector<FileInfo|False>

public defstruct SearchFailure <: SearchResult :
  missing: Tuple<MissingInput>

;============================================================
;==================== Main Algorithm ========================
;============================================================

;Performs the forward search followed by the backward search.
public defn search (grammar:Grammar, input:List) -> SearchResult :
  val saved-matches = SavedMatches(grammar)
  val forward-ctrl = forward-search(grammar, saved-matches)
  match(search(forward-ctrl, SExpStream(input))) :
    (result:SearchSuccess) :
      println("Begin Backward Search")
      val num-tokens = length(inputlist(result))
      val backward-ctrl = backward-search(grammar, saved-matches, num-tokens)
      val back-stream = BackwardSExpStream(inputlist(result), infolist(result))
      val back-result = search(backward-ctrl, back-stream) as SearchSuccess
      SearchSuccess(setlist(back-result), inputlist(result), infolist(result))
    (result:SearchFailure) :
      result

;Performs the forward search followed by the backward search.
public defn new-search (grammar:Grammar, input:List) -> SearchResult :
  val saved-matches = SavedMatches(grammar)
  val forward-ctrl = forward-search(grammar, saved-matches)
  search(forward-ctrl, SExpStream(input))

;============================================================
;====================== Algorithm ===========================
;============================================================

defn search (ctrl:SearchControls, input-stream:SExpStream) -> SearchResult :
  val setlist = ESetList(next-token{ctrl, _})
  val prediction-set = ProductionSet(num-productions(ctrl))
  val completion-set = CompletionSet()
  val production-count = ProductionTable<Int>(num-productions(ctrl), 0)
  val inputlist = Vector<SExpToken>()
  val infolist = Vector<FileInfo|False>()
  val missing = Vector<MissingInput>()

  ;Advances items in current-set and puts them in next-set.
  defn process-set (set-index:Int,
                    current-set:ESet,
                    next-set:ESet,
                    next-input:SExpToken,
                    include-all-rules?:True|False) :
    ;Clear state
    clear-markers(setlist)
    clear(prediction-set)
    clear(completion-set)

    ;Iterate through each item
    for item in current-set do :
      dispatch(item) where :
        defn* dispatch (item:EItem) :
          ;Dispatch
          match(next-token(ctrl,item)) :
            (t:GTerminal) : upcoming-terminal(item, t)
            (p:GProduction) : upcoming-production(item, p)
            (f:False) : end-of-rule(item)
        defn add-completion (item:EItem) :
          add(current-set, item) when add(completion-set, item)
        defn upcoming-terminal (item:EItem, t:GTerminal) :
          if matches-input?(ctrl, set-index, t, next-input) :
            add(next-set, advance(ctrl,item, next-input is SExpWildcard))
        defn upcoming-production (item:EItem, t:GProduction) :
          if nullable?(ctrl, t) :
            add-completion(advance(ctrl,item,false))
          if add(prediction-set, id(t)) :
            val items = predict(ctrl, set-index, t) when include-all-rules?
                   else predict(ctrl, set-index, t, next-input)
            for new-item in items do :
              if not taboo?(ctrl, rule(item), num-parsed(item), rule(new-item)) :
                add(current-set, new-item)
              
        defn end-of-rule (completed-item:EItem) :
          val prod = production(ctrl,completed-item)
          if parent(completed-item) < set-index :
            within item = items(setlist, parent(completed-item), prod, true) :
              if not taboo?(ctrl, rule(item), num-parsed(item), rule(completed-item)) :
                ;Compute normal advance of item.
                val item* = advance(ctrl, item, matched-wildcard?(completed-item))                
                ;Compute advance of item with potentially right-recursive completion.
                val completion* = match(completion-root(item)) :
                  (root:EItem) :
                    if core(root) == core(item) :
                      item*
                    else :
                      val root* = advance(ctrl,root,matched-wildcard?(completed-item))
                      sub-completion-root(root*, item*)
                  (f:False) :
                    item*
                ;Add advanced item to set.
                add-completion(completion*)

  ;Remove any conditional matches in the given set to handle
  ;reluctant matching algorithm.
  ;Returns true if the matched terminals implies the input stream
  ;should be expanded.
  defn prune-conditional-matches (eset:ESet, input:SExpToken) -> True|False :
    ;Compute expansion condition
    val expand? = scanned-non-reluctant-list-start?(eset)
              and not scanned-atomic-any?(eset)
    ;Remove items
    for item in eset remove! :
      match(prev-token(ctrl, item)) :
        (t:GListStart) : not expand?
        (t:GAny) :
          if type(t) is Reluctant : expand? or not scanned-non-reluctant?(eset)
          else : expand?
        (t:GListRest) : scanned-non-reluctant?(eset)
        (t) : false
    ;Return list expansion
    expand?

  ;For any matched special tokens, record the position
  ;at which they matched.
  defn save-matches (set-index:Int, eset:ESet, input:SExpToken) :
    for item in eset do :
      val t = prev-token(ctrl, item) as GTerminal
      save-match(ctrl, set-index, t) when save-match?(t)

  ;Compute completion-roots of all deterministic reductions.
  defn compute-completion-root (set-index:Int, current-set:ESet) :
    ;Compute count table
    clear(production-count)
    for item in current-set do :
      val t = next-token(ctrl,item)
      match(t:GProduction) :
        production-count[id(t)] = production-count[id(t)] + 1
    ;Determine whether deterministic reduction
    defn deterministic-reduction? (item:EItem) :
      if next-token-is-last?(ctrl, item) :
        val t = next-token(ctrl, item)
        match(t:GProduction) : production-count[id(t)] == 1
    ;Compute completion
    defn complete (item:EItem) :
      if parent(item) < set-index :
        val pitem = first-item(setlist, parent(item), production(ctrl,item))
        match(pitem:EItem) : completion-root(pitem)
    ;Compute completions of all deterministic reductions.
    for item in current-set map! :
      if deterministic-reduction?(item) :
        match(complete(item)) :
          (c:EItem) : sub-completion-root(item, c)
          (f:False) : sub-completion-root(item, item)
      else : item

  defn process-all-sets () :
    ;Initialize current-set and next-set.
    val current-set = ESet(ctrl)
    val next-set = ESet(ctrl)
    add(current-set, start(ctrl))

    ;Process sets until finished.
    let loop (set-index:Int = 0,
              current-set:ESet = current-set,
              next-set:ESet = next-set) :
      ;println("=== BEGIN PROCESSING ===")
      val next-input = peek(input-stream)
      ;println("CURRENT SET:")
      ;print-set(ctrl, set-index, current-set)
      ;println("[%_] NEXT INPUT: %_" % [set-index, next-input])

      val num-scanned = length(current-set)
      process-set(set-index, current-set, next-set, next-input, false)
      val expand-list? = prune-conditional-matches(next-set, next-input) when supports-conditional-match?(ctrl)
      ;println("FINISHED SCANNING CURRENT SET:")
      ;print-set(ctrl, set-index, current-set)
      ;println("NEXT SET:")
      ;print-set(ctrl, set-index, next-set)

      ;Dispatch to different cases
      defn* dispatch () :
        if empty?(next-set) :
          if start-completed?(current-set) : finished-parse()
          else : unexpected-input()
        else if supports-conditional-match?(ctrl) and scanned-rest?(next-set) :
          advance-to-next-set(true)
        else :
          advance-to-next-set(false)

      defn* finished-parse () :
        ;print-set(ctrl, set-index, current-set)
        add(setlist, current-set)

      defn* advance-to-next-set (advance-rest?:True|False) :
        ;Record the current set
        ;Add matched input
        add(inputlist, next-input)
        add(infolist, info(input-stream))

        ;Save matches
        save-matches(set-index, next-set, next-input)

        ;Compute the completion root and add to the setlist
        compute-completion-root(set-index, current-set)

        ;Debug
        ;
        ;println("COMPLETE CURRENT SET:")
        print-set(ctrl, set-index, current-set)

        ;Add to setlist
        add(setlist, current-set)

        ;Advance either to the end of the list, or by one token
        if advance-rest? : advance-rest(input-stream)
        else : advance(input-stream, expand-list?)

        ;Scan the next set
        clear(current-set, 0)
        loop(set-index + 1, next-set, current-set)

      defn* unexpected-input () :
        ;Compute the complete current set without using look-ahead prediction.
        clear(current-set, num-scanned)
        process-set(set-index, current-set, next-set, next-input, true)

        ;Record context of missing input
        add(missing, MissingInput(next-input, set-index, info(input-stream), to-tuple(current-set)))

        ;Perform error recovery
        if list-end-expected?(current-set) : advance(input-stream, false)
        else if wildcard-expected?(current-set) : insert-wildcard(input-stream)
        else if list-expected?(current-set) : insert-list(input-stream)
        else : fatal("Unrecoverable")

        ;Scan current set again now with additional inserted tokens.
        clear(current-set, num-scanned)
        loop(set-index, current-set, next-set)

      ;Launch
      dispatch()

  ;Launch!
  defn main () :
    process-all-sets()
    if empty?(missing) :
      SearchSuccess(setlist, inputlist, infolist)
    else :
      SearchFailure(to-tuple(missing))

  main()