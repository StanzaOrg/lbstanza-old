defpackage stz/earley-search :
  import core
  import collections
  import stz/earley
  import stz/earley-eitems
  import stz/earley-grammar
  import stz/earley-eval-result
  import stz/earley-sexp-stream

;============================================================
;============== ProductionTable/ProductionSet ===============
;============================================================

deftype ProductionTable<T>
defmulti get<?T> (t:ProductionTable<?T>, key:Symbol) -> T
defmulti set<?T> (t:ProductionTable<?T>, key:Symbol, v:T) -> False
defmulti clear (t:ProductionTable) -> False

defn ProductionTable<T> (default:T) :
  val table = HashTable<Symbol,T>(default)
  new ProductionTable<T> :
    defmethod get (this, key:Symbol) : table[key]
    defmethod set (this, key:Symbol, v:T) : table[key] = v
    defmethod clear (this) : clear(table)

deftype ProductionSet
defmulti get (t:ProductionSet, key:Symbol) -> True|False
defmulti add (t:ProductionSet, key:Symbol) -> True|False
defmulti clear (t:ProductionSet) -> False

defn ProductionSet () :
  val keys = HashSet<Symbol>()
  new ProductionSet :
    defmethod get (this, key:Symbol) : keys[key]
    defmethod add (this, key:Symbol) : add(keys,key)
    defmethod clear (this) : clear(keys)

deftype CompletionSet
defmulti add (s:CompletionSet, item:EItem) -> True|False
defmulti get (s:CompletionSet, item:EItem) -> True|False
defmulti clear (s:CompletionSet) -> False

defn CompletionSet () :
  val keys = HashSet<[Int,Int,Int]>()
  new CompletionSet :
    defmethod add (this, item:EItem) :
      add(keys, [rule(item), num-parsed(item), parent(item)])
    defmethod get (this, item:EItem) :
      keys[[rule(item), num-parsed(item), parent(item)]]
    defmethod clear (this) :
      clear(keys)

;============================================================
;======================= ESet ===============================
;============================================================

public deftype ESet <: Collection<EItem>
defmulti start-completed? (s:ESet) -> True|False
defmulti scanned-any? (s:ESet) -> True|False
defmulti scanned-atomic-any? (s:ESet) -> True|False
defmulti scanned-non-reluctant? (s:ESet) -> True|False
defmulti scanned-non-reluctant-list-start? (s:ESet) -> True|False
defmulti scanned-rest? (s:ESet) -> True|False
defmulti wildcard-expected? (s:ESet) -> True|False
defmulti list-expected? (s:ESet) -> True|False
defmulti list-end-expected? (s:ESet) -> True|False
defmulti add (s:ESet, item:EItem) -> False
defmulti clear (s:ESet, length:Int) -> False
defmulti length (s:ESet) -> Int
defmulti get (s:ESet, i:Int) -> EItem
defmulti map! (f:EItem -> EItem, s:ESet) -> False
defmulti remove! (f:EItem -> True|False, s:ESet) -> False

defn ESet (grammar:Grammar) :
  ;Accumulate items
  val items = Vector<EItem>()

  ;Track flags
  var start-completed?:True|False
  var scanned-any?:True|False
  var scanned-atomic-any?:True|False
  var scanned-non-reluctant?:True|False
  var scanned-non-reluctant-list-start?:True|False
  var scanned-rest?:True|False
  var wildcard-expected?: True|False
  var list-expected?: True|False
  var list-end-expected?: True|False
  
  defn recompute-flags () :
    start-completed? = false
    scanned-any? = false
    scanned-atomic-any? = false
    scanned-non-reluctant? = false
    scanned-non-reluctant-list-start? = false
    scanned-rest? = false
    wildcard-expected? = false
    list-expected? = false
    list-end-expected? = false
    do(process-flags, items)

  defn process-flags (item:EItem) :
    ;Set flags for what was scanned.
    val prev-item = previous(grammar,item)
    match(prev-item) :
      (t:GAny) :
        scanned-any? = true
        if type(t) is Atomic : scanned-atomic-any? = true
      (t:GListStart) :
        if not reluctant?(t) :
          scanned-non-reluctant-list-start? = true
      (t:GListRest) :
        scanned-rest? = true      
      (t) :
        false

    ;Process scanned non-reluctant flag
    if non-reluctant-terminal?(prev-item) :
      scanned-non-reluctant? = true
        
    ;Set flags for what is upcoming
    match(upcoming(grammar,item)) :
      (t:GListStart) :
        list-expected? = true
      (t:GListEnd) :
        list-end-expected? = true
      (t:GTerminal) :
        wildcard-expected? = true
      (t:False) :        
        if rule(item) == 0 : start-completed? = true
      (t) :
        false

  recompute-flags()
  new ESet :
    defmethod clear (this, l:Int) :
      shorten(items, l)
      recompute-flags()
    defmethod add (this, item:EItem) :
      add(items, item)
      process-flags(item)
    defmethod get (this, i:Int) : items[i]
    defmethod length (this) : length(items)
    defmethod to-seq (this) : to-seq(items)
    defmethod map! (f:EItem -> EItem, this) : map!(f, items)
    defmethod remove! (f:EItem -> True|False, this) :
      remove-when(f, items)
      recompute-flags()
    ;Flags
    defmethod start-completed? (this) : start-completed?
    defmethod scanned-any? (this) : scanned-any?
    defmethod scanned-atomic-any? (this) : scanned-atomic-any?
    defmethod scanned-non-reluctant? (this) : scanned-non-reluctant?
    defmethod scanned-non-reluctant-list-start? (this) : scanned-non-reluctant-list-start?
    defmethod scanned-rest? (this) : scanned-rest?
    defmethod wildcard-expected? (this) : wildcard-expected?
    defmethod list-expected? (this) : list-expected?
    defmethod list-end-expected? (this) : list-end-expected?

defmethod do (f:EItem -> ?, eset:ESet) :
  val item-index = to-seq(0 to false)
  while peek(item-index) < length(eset) :
    f(eset[next(item-index)])

defn empty? (s:ESet) :
  length(s) == 0

;============================================================
;================= Matching Predicates ======================
;============================================================

;Returns true if the given token is a non-reluctant terminal.
defn non-reluctant-terminal? (t:GToken|False) :
  match(t) :
    (t:GProduction) : false
    (t:False) : false
    (t:GListRest) : false
    (t:GAny) : type(t) is-not Reluctant
    (t:GListStart) : not reluctant?(t)
    (t) : true

;Returns true if the given terminal matches against the given input.
defn matches-input? (t:GTerminal, input:SExpToken) :
  match(t, input) :
    ;Wildcard matching
    (t:GListStart|GListEnd, input:SExpWildcard) : false
    (t, input:SExpWildcard) : true
    ;Form matching
    (t:GKeyword, input:SExpForm) : unwrap-token(form(input)) == item(t)
    (t:GCharToken, input:SExpForm) : unwrap-token(form(input)) is Char
    (t:GByteToken, input:SExpForm) : unwrap-token(form(input)) is Byte
    (t:GIntToken, input:SExpForm) : unwrap-token(form(input)) is Int
    (t:GLongToken, input:SExpForm) : unwrap-token(form(input)) is Long
    (t:GFloatToken, input:SExpForm) : unwrap-token(form(input)) is Float
    (t:GDoubleToken, input:SExpForm) : unwrap-token(form(input)) is Double
    (t:GStringToken, input:SExpForm) : unwrap-token(form(input)) is String
    (t:GSymbolToken, input:SExpForm) : unwrap-token(form(input)) is Symbol
    (t:GTrueToken, input:SExpForm) : unwrap-token(form(input)) is True
    (t:GFalseToken, input:SExpForm) : unwrap-token(form(input)) is False
    (t:GListStart, input:SExpForm) : unwrap-token(form(input)) is List
    (t:GAny, input:SExpForm) : true
    (t:GListRest, input:SExpForm) : true
    (t, input:SExpForm) : false
    ;List end matching
    (t:GListEnd, input:SExpListEnd) : true
    (t, input:SExpListEnd) : false

;Returns true if the upcoming input satisfies the matcher of the given rule.
defn matches-input? (rule:GMatcherRule, input:SExpToken) :
  match(input) :
    (input:SExpWildcard) : true
    (input:SExpForm) : matcher(rule)(form(input))
    (input) : false

;============================================================
;====================== Algorithm ===========================
;============================================================

public defstruct ParseResult :
  node: ParseNode
  grammar: Grammar
  inputlist: Vector<SExpToken>
  infolist: Vector<FileInfo|False>

public defn parse-result (grammar:Grammar, input:List) -> ParseResult|ParsingErrors :
  val setlist = ESetList(grammar)
  val prediction-set = ProductionSet()
  val completion-set = CompletionSet()
  val production-count = ProductionTable<Int>(0)
  val inputlist = Vector<SExpToken>()
  val infolist = Vector<FileInfo|False>()
  val missing = Vector<MissingInput>()

  ;Returns true if the starting rule has been completed
  defn process-set (set-index:Int,
                    current-set:ESet,
                    next-set:ESet,
                    next-input:SExpToken,
                    include-all-rules?:True|False) -> True|False :                    
    ;Clear state
    clear-markers(setlist)
    clear(prediction-set)
    clear(completion-set)

    ;Iterate through each item
    for item in current-set do :
      dispatch(item) where :
        defn* dispatch (item:EItem) :
          if passed-guard?(item) :
            ;Dispatch
            match(upcoming(grammar,item)) :
              (t:GTerminal) : upcoming-terminal(item, t)
              (p:GProduction) : upcoming-production(item, p)
              (f:False) : end-of-rule(item)
          else :
            test-guard(item)
        defn test-guard (item:EItem) :
          val rule = grammar[rule(item)] as GMatcherRule
          if matches-input?(rule, next-input) :
            add(current-set, sub-passed-guard?(item, true))
        defn add-completion (item:EItem) :
          add(current-set, item) when add(completion-set, item)
        defn upcoming-terminal (item:EItem, t:GTerminal) :
          if matches-input?(t, next-input) :
            add(next-set, inc-num-parsed(item))
        defn upcoming-production (item:EItem, t:GProduction) :
          if nullable?(grammar, name(t)) :
            add-completion(inc-num-parsed(item))          
          if add(prediction-set, name(t)) :
            val rules = rules(grammar, name(t)) when include-all-rules?
                   else rules(grammar, name(t), next-input)
            for rule in rules do :
              val passed-guard? = grammar[rule] is-not GMatcherRule
              add(current-set, EItem(rule, 0, set-index, passed-guard?))
        defn end-of-rule (completed-item:EItem) :
          val prod = production(grammar,completed-item)
          if parent(completed-item) < set-index :
            within item = items(setlist, parent(completed-item), prod, true) :
              val item* = inc-num-parsed(item)
              val completion* = match(completion-root(item)) :
                (root:EItem) :
                  if core(root) == core(item) : item*
                  else : sub-completion-root(inc-num-parsed(root), item*)
                (f:False) : item*
              add-completion(completion*)

  defn prune-conditional-matches (eset:ESet, input:SExpToken) -> True|False :
    ;Remove all items whose previous token satisfies f.
    defn remove-previous (f:GToken|False -> True|False) :
      remove!(f{previous(grammar, _)}, eset)

    ;Is the input a list?
    val input-is-list? = match(input:SExpForm) :
      unwrap-token(form(input)) is List

    ;Determine whether we have made any progress?
    if scanned-non-reluctant?(eset) :
      ;Determine whether we have conditional matches to take care of. This
      ;occurs if the input is a list and an ANY has been scanned.
      if input-is-list? and scanned-any?(eset) :
        ;If an atomic any has been scanned, then we do not want the
        ;list to be expanded, and all matches with LIST-START should
        ;be removed.
        if scanned-atomic-any?(eset) :
          remove-previous({_ is GListStart|GListRest})
          false
        ;If a non-reluctant list start has been scanned, then we do want
        ;the list to be expanded, and all matches with ANY should
        ;be removed.
        else if scanned-non-reluctant-list-start?(eset) :
          remove-previous({_ is GAny|GListRest})
          true
        ;Otherwise, we do not need the list to be expanded, and all
        ;matches with LIST-START should be removed.
        else :
          remove-previous({_ is GListStart|GListRest})
          false
      ;If we scanned a rest production, then we need to remove it, since
      ;we know that we have successfully scanned a non-reluctant terminal.
      else if scanned-rest?(eset) :
        remove-previous({_ is GListRest})
        true
      ;By default, we expand the list.
      else :
        true
    ;Otherwise, we have scanned only reluctant items, and
    ;they should all should be removed, except for rest.
    else :
      remove-previous({_ is-not GListRest})
      false

  defn compute-completion-root (set-index:Int, current-set:ESet) :
    ;Compute count table
    clear(production-count)
    for item in current-set do :
      val t = upcoming(grammar,item)
      match(t:GProduction) :
        production-count[name(t)] = production-count[name(t)] + 1
    ;Determine whether deterministic reduction
    defn deterministic-reduction? (item:EItem) :
      val num-tokens = length(tokens!(grammar[rule(item)]))
      if num-parsed(item) == num-tokens - 1 :
        val t = upcoming(grammar,item)
        match(t:GProduction) : production-count[name(t)] == 1
    ;Compute completion
    defn complete (item:EItem) :
      if parent(item) < set-index :
        val pitem = first-item(setlist, parent(item), production(grammar,item))
        match(pitem:EItem) : completion-root(pitem)
    ;Compute completions of all deterministic reductions.
    for item in current-set map! :
      if deterministic-reduction?(item) :
        match(complete(item)) :
          (c:EItem) : sub-completion-root(item, c)
          (f:False) : sub-completion-root(item, item)
      else : item

  defn add-to-setlist (current-set:ESet) :
    defn prod? (e:EItem) : passed-guard?(e); and upcoming(grammar,e) is GProduction|False
    add(setlist, filter(prod?, current-set))

  defn record-missing-input (next-input, index:Int, info:FileInfo|False, eset:ESet) :
    add(missing, MissingInput(next-input, index, info, to-tuple(eset)))
      
  defn process-all-sets () :
    ;Initialize current-set and next-set.
    val current-set = ESet(grammar)
    val next-set = ESet(grammar)
    add(current-set, EItem(0, 0, 0))
    
    ;Initialize input stream
    val input-stream = SExpStream(input)
    
    ;Process sets until finished.
    let loop (set-index:Int = 0,
              current-set:ESet = current-set,
              next-set:ESet = next-set) :
      val next-input = peek(input-stream)
      val num-scanned = length(current-set)      
      process-set(set-index, current-set, next-set, next-input, false)
      val expand-list? = prune-conditional-matches(next-set, next-input)

      ;Utilities
      defn* record-current-set () :
        ;Add matched input
        add(inputlist, next-input)
        add(infolist, info(input-stream))
        ;Compute the completion root and add to the setlist
        compute-completion-root(set-index, current-set)
        ;Debug
        print-current-set(grammar, set-index, current-set)
        add-to-setlist(current-set)
      defn* scan-next-set () :
        clear(current-set, 0)
        loop(set-index + 1, next-set, current-set)
      defn* scan-current-set-again () :
        clear(current-set, num-scanned)
        loop(set-index, current-set, next-set)
      defn* compute-complete-current-set () :
        clear(current-set, num-scanned)
        process-set(set-index, current-set, next-set, next-input, true)

      ;Dispatch to different cases
      defn* dispatch () :
        if empty?(next-set) :
          if start-completed?(current-set) : finished-parse()
          else : unexpected-input()
        else if scanned-rest?(next-set) : advance-to-list-end()
        else : advance-one()
      defn* finished-parse () :
        record-current-set()
      defn* advance-to-list-end () :
        record-current-set()
        advance-rest(input-stream)
        scan-next-set()
      defn* advance-one () :
        record-current-set()
        advance(input-stream, expand-list?)
        scan-next-set()
      defn* unexpected-input () :
        compute-complete-current-set()
        record-missing-input(next-input, set-index, info(input-stream), current-set)
        if list-end-expected?(current-set) : advance(input-stream, false)          
        else if wildcard-expected?(current-set) : insert-wildcard(input-stream)
        else if list-expected?(current-set) : insert-list(input-stream)
        else : fatal("Unrecoverable")
        scan-current-set-again()

      ;Launch
      dispatch()

  ;Launch!
  defn main () :
    within with-timer("process all sets") :
      process-all-sets()
    if empty?(missing) :
      val parse-forest = ParseForest(grammar, setlist)
      val node = within with-timer("select tree") :
        select-tree(grammar, parse-forest)
      ParseResult(node, grammar, inputlist, infolist)
    else :
      to-exception(grammar, missing)    

  main()  