defpackage stz/earley-search :
  import core
  import collections
  import stz/earley
  import stz/earley-eitems
  import stz/earley-grammar
  import stz/earley-eval-result
  import stz/earley-sexp-stream

;============================================================
;============== ProductionTable/ProductionSet ===============
;============================================================

deftype ProductionTable<T>
defmulti get<?T> (t:ProductionTable<?T>, key:Symbol) -> T
defmulti set<?T> (t:ProductionTable<?T>, key:Symbol, v:T) -> False
defmulti clear (t:ProductionTable) -> False

defn ProductionTable<T> (default:T) :
  val table = HashTable<Symbol,T>(default)
  new ProductionTable<T> :
    defmethod get (this, key:Symbol) : table[key]
    defmethod set (this, key:Symbol, v:T) : table[key] = v
    defmethod clear (this) : clear(table)

deftype ProductionSet
defmulti get (t:ProductionSet, key:Symbol) -> True|False
defmulti add (t:ProductionSet, key:Symbol) -> True|False
defmulti clear (t:ProductionSet) -> False

defn ProductionSet () :
  val keys = HashSet<Symbol>()
  new ProductionSet :
    defmethod get (this, key:Symbol) : keys[key]
    defmethod add (this, key:Symbol) : add(keys,key)
    defmethod clear (this) : clear(keys)

deftype CompletionSet
defmulti add (s:CompletionSet, item:EItem) -> True|False
defmulti get (s:CompletionSet, item:EItem) -> True|False
defmulti clear (s:CompletionSet) -> False

defn CompletionSet () :
  val keys = HashSet<[Int,Int,Int]>()
  new CompletionSet :
    defmethod add (this, item:EItem) :
      add(keys, [rule(item), num-parsed(item), parent(item)])
    defmethod get (this, item:EItem) :
      keys[[rule(item), num-parsed(item), parent(item)]]
    defmethod clear (this) :
      clear(keys)

;============================================================
;======================= ESet ===============================
;============================================================

deftype ESet <: Collection<EItem>
defmulti start-completed? (s:ESet) -> True|False
defmulti scanned-any? (s:ESet) -> True|False
defmulti scanned-atomic-any? (s:ESet) -> True|False
defmulti scanned-non-reluctant? (s:ESet) -> True|False
defmulti scanned-non-reluctant-list-start? (s:ESet) -> True|False
defmulti scanned-rest? (s:ESet) -> True|False
defmulti wildcard-expected? (s:ESet) -> True|False
defmulti list-expected? (s:ESet) -> True|False
defmulti list-end-expected? (s:ESet) -> True|False
defmulti add (s:ESet, item:EItem) -> False
defmulti clear (s:ESet, length:Int) -> False
defmulti length (s:ESet) -> Int
defmulti get (s:ESet, i:Int) -> EItem
defmulti map! (f:EItem -> EItem, s:ESet) -> False
defmulti remove! (f:EItem -> True|False, s:ESet) -> False

defn ESet (ctrl:SearchControls) :
  ;Accumulate items
  val items = Vector<EItem>()

  ;Track flags
  var start-completed?:True|False
  var scanned-any?:True|False
  var scanned-atomic-any?:True|False
  var scanned-non-reluctant?:True|False
  var scanned-non-reluctant-list-start?:True|False
  var scanned-rest?:True|False
  var wildcard-expected?: True|False
  var list-expected?: True|False
  var list-end-expected?: True|False
  
  defn recompute-flags () :
    start-completed? = false
    scanned-any? = false
    scanned-atomic-any? = false
    scanned-non-reluctant? = false
    scanned-non-reluctant-list-start? = false
    scanned-rest? = false
    wildcard-expected? = false
    list-expected? = false
    list-end-expected? = false
    do(process-flags, items)

  defn process-flags (item:EItem) :
    ;Set flags for what was scanned.
    val prev-item = prev-token(ctrl,item)
    match(prev-item) :
      (t:GAny) :
        scanned-any? = true
        if type(t) is Atomic : scanned-atomic-any? = true
      (t:GListStart) :
        if not reluctant?(t) :
          scanned-non-reluctant-list-start? = true
      (t:GListRest) :
        scanned-rest? = true      
      (t) :
        false

    ;Process scanned non-reluctant flag
    if non-reluctant-terminal?(prev-item) :
      scanned-non-reluctant? = true
        
    ;Set flags for what is upcoming
    match(next-token(ctrl,item)) :
      (t:GListStart) :
        list-expected? = true
      (t:GListEnd) :
        list-end-expected? = true
      (t:GTerminal) :
        wildcard-expected? = true
      (t:False) :        
        if rule(item) == 0 : start-completed? = true
      (t) :
        false

  recompute-flags()
  new ESet :
    defmethod clear (this, l:Int) :
      shorten(items, l)
      recompute-flags()
    defmethod add (this, item:EItem) :
      add(items, item)
      process-flags(item)
    defmethod get (this, i:Int) : items[i]
    defmethod length (this) : length(items)
    defmethod to-seq (this) : to-seq(items)
    defmethod map! (f:EItem -> EItem, this) : map!(f, items)
    defmethod remove! (f:EItem -> True|False, this) :
      remove-when(f, items)
      recompute-flags()
    ;Flags
    defmethod start-completed? (this) : start-completed?
    defmethod scanned-any? (this) : scanned-any?
    defmethod scanned-atomic-any? (this) : scanned-atomic-any?
    defmethod scanned-non-reluctant? (this) : scanned-non-reluctant?
    defmethod scanned-non-reluctant-list-start? (this) : scanned-non-reluctant-list-start?
    defmethod scanned-rest? (this) : scanned-rest?
    defmethod wildcard-expected? (this) : wildcard-expected?
    defmethod list-expected? (this) : list-expected?
    defmethod list-end-expected? (this) : list-end-expected?

defmethod do (f:EItem -> ?, eset:ESet) :
  val item-index = to-seq(0 to false)
  while peek(item-index) < length(eset) :
    f(eset[next(item-index)])

defn empty? (s:ESet) :
  length(s) == 0

defn print-current-set (grammar:Grammar, set-index:Int, current-set:ESet) :
  println("Set %_" % [set-index])
  within indented() :
    do(println{format(grammar,_)}, current-set)

;============================================================
;=================== Saved Matches ==========================
;============================================================

deftype SavedMatches
defmulti save (s:SavedMatches, position:Int, s:GTerminal) -> False
defmulti matched? (s:SavedMatches, position:Int, s:GTerminal) -> True|False

defn SavedMatches () :
  ;Saved index => set-index pairs
  val matched = Array<Vector<Int>>(3)
  for i in 0 to 3 do :
    matched[i] = Vector<Int>()

  ;Retrieve category index of special terminal.
  defn index (t:GTerminal) :
    match(t) :
      (t:GListRest) : 0
      (t:GAny) : 1
      (t:GListStart) : 2

  new SavedMatches :
    defmethod save (this, position:Int, s:GTerminal) :
      val pos = matched[index(s)]
      if empty?(pos) or peek(pos) < position :
        add(pos, position)
    defmethod matched? (this, position:Int, s:GTerminal) :
      val pos = matched[index(s)]
      let loop () :
        if empty?(pos) :
          false
        else :
          val p = peek(pos)
          if p == position :
            true
          else if p > position :
            pop(pos)
            loop()
          else :
            false
    defmethod print (o:OutputStream, this) :
      print(o, "SavedMatches:")
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, matched)

defn save-match? (t:GTerminal) -> True|False :
  match(t) :
    (t:GListRest) : true
    (t:GAny) : true
    (t:GListStart) : reluctant?(t)
    (t) : false

;============================================================
;================= Matching Predicates ======================
;============================================================

;Returns true if the given terminal is a reluctant terminal.
defn reluctant-terminal? (t:GTerminal) :
  match(t) :
    (t:GListStart) : reluctant?(t)
    (t:GAny) : type(t) is Reluctant
    (t:GListRest) : true
    (t) : false

;Returns true if the given token is a non-reluctant terminal.
defn non-reluctant-terminal? (t:GToken|False) :
  match(t:GTerminal) : not reluctant-terminal?(t)
  else : false

;Returns true if the given terminal matches against the given input.
defn matches-input? (t:GTerminal, input:SExpToken) :
  match(input) :
    ;Wildcard matching
    (input:SExpWildcard) :
      t is-not GListStart|GListEnd
    ;Form matching
    (input:SExpForm) :
      match(t) :
        (t:GKeyword) : unwrap-token(form(input)) == item(t)
        (t:GCharToken) : unwrap-token(form(input)) is Char
        (t:GByteToken) : unwrap-token(form(input)) is Byte
        (t:GIntToken) : unwrap-token(form(input)) is Int
        (t:GLongToken) : unwrap-token(form(input)) is Long
        (t:GFloatToken) : unwrap-token(form(input)) is Float
        (t:GDoubleToken) : unwrap-token(form(input)) is Double
        (t:GStringToken) : unwrap-token(form(input)) is String
        (t:GSymbolToken) : unwrap-token(form(input)) is Symbol
        (t:GTrueToken) : unwrap-token(form(input)) is True
        (t:GFalseToken) : unwrap-token(form(input)) is False
        (t:GListStart) : unwrap-token(form(input)) is List
        (t:GAny) : true
        (t:GListRest) : true
        (t) : false    
    ;List end matching
    (input:SExpListEnd) :
      t is GListEnd

;Returns true if the upcoming input satisfies the matcher of the given rule.
defn matches-input? (rule:GMatcherRule, input:SExpToken) :
  match(input) :
    (input:SExpWildcard) : true
    (input:SExpForm) : matcher(rule)(form(input))
    (input) : false

;============================================================
;====================== Algorithm ===========================
;============================================================

public defstruct ParseResult :
  node: ParseNode
  grammar: Grammar
  inputlist: Vector<SExpToken>
  infolist: Vector<FileInfo|False>

defn forward-search (grammar:Grammar, saved:SavedMatches) -> SearchControls :
  new SearchControls :
    defmethod next-token (this, item:EItem) :
      upcoming(grammar, item)
    defmethod prev-token (this, item:EItem) :
      previous(grammar, item)
    defmethod next-token-is-last? (this, item:EItem) :
      val num-tokens = length(tokens!(grammar[rule(item)]))
      num-parsed(item) == num-tokens - 1
    defmethod advance (this, item:EItem) :
      inc-num-parsed(item)
    defmethod nullable? (this, t:GProduction) :
      nullable?(grammar, name(t))
    defmethod production (this, item:EItem) :
      production(grammar, item)
    defmethod predict (this, set-index:Int, t:GProduction) :
      for r in rules(grammar, name(t)) seq :
        EItem(r, 0, set-index, true)
    defmethod predict (this, set-index:Int, t:GProduction, input:SExpToken) :
      for r in rules-with-prefix(grammar, name(t), input) seq :
        EItem(r, 0, set-index, true)
    defmethod start (this) :
      EItem(0, 0, 0)
    defmethod print-set (this, set-index:Int, eset:ESet) :
      print-current-set(grammar, set-index, eset)
    defmethod matches-input? (this, set-index:Int, t:GTerminal, input:SExpToken) :      
      matches-input?(t, input)
    defmethod save-match (this, set-index:Int, t:GTerminal) :
      if save-match?(t) :
        save(saved, set-index, t)
    defmethod supports-conditional-match? (this) :
      true

defn backward-search (grammar:Grammar, saved:SavedMatches, total-matched-length:Int) -> SearchControls :
  new SearchControls :
    defmethod next-token (this, item:EItem) :
      previous(grammar, item)
    defmethod prev-token (this, item:EItem) :
      upcoming(grammar, item)
    defmethod next-token-is-last? (this, item:EItem) :
      num-parsed(item) == 1
    defmethod advance (this, item:EItem) :
      EItem(rule(item), num-parsed(item) - 1, parent(item))
    defmethod nullable? (this, t:GProduction) :
      nullable?(grammar, name(t))
    defmethod production (this, item:EItem) :
      production(grammar, item)
    defmethod predict (this, set-index:Int, t:GProduction) :
      for r in rules(grammar, name(t)) seq :
        val num-tokens = length(tokens!(grammar[r]))
        EItem(r, num-tokens, set-index, true)
    defmethod predict (this, set-index:Int, t:GProduction, input:SExpToken) :
      for r in rules-with-suffix(grammar, name(t), input) seq :
        val num-tokens = length(tokens!(grammar[r]))
        EItem(r, num-tokens, set-index, true)
    defmethod start (this) :
      val n = length(tokens!(grammar[0]))
      EItem(0, n, 0)
    defmethod print-set (this, set-index:Int, eset:ESet) :
      print-current-set(grammar, set-index, eset)
    defmethod matches-input? (this, set-index:Int, t:GTerminal, input:SExpToken) :
      if save-match?(t) :
        val position = total-matched-length - set-index - 1
        matched?(saved, position, t)
      else :
        matches-input?(t, input)
    defmethod save-match (this, set-index:Int, t:GTerminal) :
      false
    defmethod supports-conditional-match? (this) :
      false

public defn parse-result (grammar:Grammar, input:List) -> ParseResult|ParsingErrors :
  val saved-matches = SavedMatches()
  val result = parse-result(forward-search(grammar, saved-matches), SExpStream(input))
  match(result) :
    (result:SearchSuccess) :
      ;BACKWARD SEARCH
      println("==== Backward search! ====")
      val result2 = (parse-result(ctrl, sexpstream) as SearchSuccess) where :
        val num-tokens = length(inputlist(result))
        val ctrl = backward-search(grammar, saved-matches, num-tokens)
        val sexpstream = BackwardSExpStream(inputlist(result), infolist(result))
      


;      val parse-forest = ParseForest(grammar, setlist(result))
;      val node = within with-timer("select tree") :
;        select-tree(grammar, parse-forest)
;      ParseResult(node, grammar, inputlist(result), infolist(result))      

      val parse-forest = NewParseForest(grammar, setlist(result2))
      val node = within with-timer("select tree") :
        new-select-tree(grammar, parse-forest)
      ParseResult(node, grammar, inputlist(result2), infolist(result2))      
    (result:SearchFailure) :
      to-exception(grammar, missing(result))

;============================================================
;====================== Algorithm2 ==========================
;============================================================

public deftype SearchControls
public defmulti next-token (c:SearchControls, item:EItem) -> GToken|False
public defmulti prev-token (c:SearchControls, item:EItem) -> GToken|False
public defmulti next-token-is-last? (c:SearchControls, item:EItem) -> True|False
public defmulti advance (c:SearchControls, item:EItem) -> EItem
public defmulti nullable? (c:SearchControls, t:GProduction) -> True|False
public defmulti production (c:SearchControls, item:EItem) -> Symbol
public defmulti predict (c:SearchControls, set-index:Int, t:GProduction) -> Seqable<EItem>
public defmulti predict (c:SearchControls, set-index:Int, t:GProduction, input:SExpToken) -> Seqable<EItem>
public defmulti start (c:SearchControls) -> EItem
public defmulti print-set (c:SearchControls, set-index:Int, eset:ESet) -> False
public defmulti matches-input? (c:SearchControls, set-index:Int, t:GTerminal, input:SExpToken) -> True|False
public defmulti save-match (c:SearchControls, set-index:Int, t:GTerminal) -> False
public defmulti supports-conditional-match? (c:SearchControls) -> True|False

public deftype SearchResult
public defstruct SearchSuccess <: SearchResult :
  setlist: ESetList
  inputlist: Vector<SExpToken>
  infolist: Vector<FileInfo|False>
public defstruct SearchFailure <: SearchResult :
  missing: Tuple<MissingInput>

public defn parse-result (ctrl:SearchControls, input-stream:SExpStream) -> SearchResult :
  val setlist = ESetList(next-token{ctrl, _})
  val prediction-set = ProductionSet()
  val completion-set = CompletionSet()
  val production-count = ProductionTable<Int>(0)
  val inputlist = Vector<SExpToken>()
  val infolist = Vector<FileInfo|False>()
  val missing = Vector<MissingInput>()

  ;Returns true if the starting rule has been completed
  defn process-set (set-index:Int,
                    current-set:ESet,
                    next-set:ESet,
                    next-input:SExpToken,
                    include-all-rules?:True|False) -> True|False :                    
    ;Clear state
    clear-markers(setlist)
    clear(prediction-set)
    clear(completion-set)

    ;Iterate through each item
    for item in current-set do :
      dispatch(item) where :
        defn* dispatch (item:EItem) :
          ;Dispatch
          match(next-token(ctrl,item)) :
            (t:GTerminal) : upcoming-terminal(item, t)
            (p:GProduction) : upcoming-production(item, p)
            (f:False) : end-of-rule(item)
        defn add-completion (item:EItem) :
          add(current-set, item) when add(completion-set, item)
        defn upcoming-terminal (item:EItem, t:GTerminal) :
          if matches-input?(ctrl, set-index, t, next-input) :
            add(next-set, advance(ctrl,item))
        defn upcoming-production (item:EItem, t:GProduction) :
          if nullable?(ctrl, t) :
            add-completion(advance(ctrl,item))          
          if add(prediction-set, name(t)) :
            val items = predict(ctrl, set-index, t) when include-all-rules?
                   else predict(ctrl, set-index, t, next-input)
            for item in items do :
              add(current-set, item)
        defn end-of-rule (completed-item:EItem) :
          val prod = production(ctrl,completed-item)
          if parent(completed-item) < set-index :
            within item = items(setlist, parent(completed-item), prod, true) :
              val item* = advance(ctrl, item)
              val completion* = item*
              ;val completion* = match(completion-root(item)) :
              ;  (root:EItem) :
              ;    if core(root) == core(item) : item*
              ;    else : sub-completion-root(advance(ctrl,root), item*)
              ;  (f:False) : item*
              add-completion(completion*)

  defn prune-conditional-matches (eset:ESet, input:SExpToken) -> True|False :
    ;Compute expansion condition
    val expand? = scanned-non-reluctant-list-start?(eset)
              and not scanned-atomic-any?(eset)
    ;Remove items
    for item in eset remove! :
      match(prev-token(ctrl, item)) :
        (t:GListStart) : not expand?
        (t:GAny) :
          if type(t) is Reluctant : expand? or not scanned-non-reluctant?(eset)
          else : expand?
        (t:GListRest) : scanned-non-reluctant?(eset)       
        (t) : false
    ;Return list expansion
    expand?
        
  defn save-matches (set-index:Int, eset:ESet, input:SExpToken) :
    for item in eset do :
      val t = prev-token(ctrl, item) as GTerminal
      if save-match?(t) :
        save-match(ctrl, set-index, t)

  defn compute-completion-root (set-index:Int, current-set:ESet) :
    ;Compute count table
    clear(production-count)
    for item in current-set do :
      val t = next-token(ctrl,item)
      match(t:GProduction) :
        production-count[name(t)] = production-count[name(t)] + 1
    ;Determine whether deterministic reduction
    defn deterministic-reduction? (item:EItem) :
      if next-token-is-last?(ctrl, item) :
        val t = next-token(ctrl, item)
        match(t:GProduction) : production-count[name(t)] == 1
    ;Compute completion
    defn complete (item:EItem) :
      if parent(item) < set-index :
        val pitem = first-item(setlist, parent(item), production(ctrl,item))
        match(pitem:EItem) : completion-root(pitem)
    ;Compute completions of all deterministic reductions.
    for item in current-set map! :
      if deterministic-reduction?(item) :
        match(complete(item)) :
          (c:EItem) : sub-completion-root(item, c)
          (f:False) : sub-completion-root(item, item)
      else : item

  defn add-to-setlist (current-set:ESet) :
    add(setlist, current-set)

  defn record-missing-input (next-input, index:Int, info:FileInfo|False, eset:ESet) :
    add(missing, MissingInput(next-input, index, info, to-tuple(eset)))
      
  defn process-all-sets () :
    ;Initialize current-set and next-set.
    val current-set = ESet(ctrl)
    val next-set = ESet(ctrl)
    add(current-set, start(ctrl))
        
    ;Process sets until finished.
    let loop (set-index:Int = 0,
              current-set:ESet = current-set,
              next-set:ESet = next-set) :
      ;println("=== BEGIN PROCESSING ===")
      val next-input = peek(input-stream)
      ;println("CURRENT SET:")
      ;print-set(ctrl, set-index, current-set)
      ;println("[%_] NEXT INPUT: %_" % [set-index, next-input])
      
      val num-scanned = length(current-set)      
      process-set(set-index, current-set, next-set, next-input, false)
      val expand-list? = prune-conditional-matches(next-set, next-input) when supports-conditional-match?(ctrl)
      ;println("FINISHED SCANNING CURRENT SET:")
      ;print-set(ctrl, set-index, current-set)
      ;println("NEXT SET:")
      ;print-set(ctrl, set-index, next-set)

      ;Utilities
      defn* record-current-set () :
        ;Add matched input
        add(inputlist, next-input)
        add(infolist, info(input-stream))
        ;Save matches
        save-matches(set-index, next-set, next-input)
        ;Compute the completion root and add to the setlist
        compute-completion-root(set-index, current-set)
        ;Debug
        ;print-set(ctrl, set-index, current-set)
        add-to-setlist(current-set)
      defn* scan-next-set () :
        clear(current-set, 0)
        loop(set-index + 1, next-set, current-set)
      defn* scan-current-set-again () :
        clear(current-set, num-scanned)
        loop(set-index, current-set, next-set)
      defn* compute-complete-current-set () :
        clear(current-set, num-scanned)
        process-set(set-index, current-set, next-set, next-input, true)

      ;Dispatch to different cases
      defn* dispatch () :
        if empty?(next-set) :
          if start-completed?(current-set) : finished-parse()
          else : unexpected-input()
        else if supports-conditional-match?(ctrl) and scanned-rest?(next-set) : advance-to-list-end()
        else : advance-one()
      defn* finished-parse () :
        ;record-current-set()
        ;print-set(ctrl, set-index, current-set)
        add-to-setlist(current-set)
      defn* advance-to-list-end () :
        record-current-set()
        advance-rest(input-stream)
        scan-next-set()
      defn* advance-one () :
        record-current-set()
        advance(input-stream, expand-list?)
        scan-next-set()
      defn* unexpected-input () :
        compute-complete-current-set()
        record-missing-input(next-input, set-index, info(input-stream), current-set)
        if list-end-expected?(current-set) : advance(input-stream, false)          
        else if wildcard-expected?(current-set) : insert-wildcard(input-stream)
        else if list-expected?(current-set) : insert-list(input-stream)
        else : fatal("Unrecoverable")
        scan-current-set-again()

      ;Launch
      dispatch()

  ;Launch!
  defn main () :
    within with-timer("process all sets") :
      process-all-sets()
    if empty?(missing) :
      SearchSuccess(setlist, inputlist, infolist)
    else :
      SearchFailure(to-tuple(missing))

  main()  