defpackage stz/earley-search :
  import core
  import collections
  import stz/earley-eitems
  import stz/earley-grammar
  import stz/earley-sexp-stream
  import stz/earley-errors

;============================================================
;======================= ESet ===============================
;============================================================

public deftype ESet <: Collection<EItem>
defmulti start-completed? (s:ESet) -> True|False
defmulti scanned-atomic-any? (s:ESet) -> True|False
defmulti scanned-non-reluctant? (s:ESet) -> True|False
defmulti scanned-non-reluctant-list-start? (s:ESet) -> True|False
defmulti scanned-rest? (s:ESet) -> True|False
defmulti wildcard-expected? (s:ESet) -> True|False
defmulti list-expected? (s:ESet) -> True|False
defmulti list-end-expected? (s:ESet) -> True|False
defmulti add (s:ESet, item:EItem) -> False
defmulti clear (s:ESet, length:Int) -> False
defmulti length (s:ESet) -> Int
defmulti get (s:ESet, i:Int) -> EItem
defmulti map! (f:EItem -> EItem, s:ESet) -> False
defmulti remove! (f:EItem -> True|False, s:ESet) -> False

defn ESet (grammar:Grammar) :
  ;Starting rule
  val start-rule = next(to-seq(rules(grammar,0)))
  
  ;Accumulate items
  val items = Vector<EItem>()

  ;Track flags
  var start-completed?:True|False
  var scanned-atomic-any?:True|False
  var scanned-non-reluctant?:True|False
  var scanned-non-reluctant-list-start?:True|False
  var scanned-rest?:True|False
  var wildcard-expected?: True|False
  var list-expected?: True|False
  var list-end-expected?: True|False

  defn recompute-flags () :
    start-completed? = false
    scanned-atomic-any? = false
    scanned-non-reluctant? = false
    scanned-non-reluctant-list-start? = false
    scanned-rest? = false
    wildcard-expected? = false
    list-expected? = false
    list-end-expected? = false
    do(process-flags, items)

  defn process-flags (item:EItem) :
    ;Set flags for what was scanned.
    val prev-item = previous(grammar,item)
    match(prev-item) :
      (t:GAny) :
        if type(t) is Atomic : scanned-atomic-any? = true
      (t:GListStart) :
        if not reluctant?(t) :
          scanned-non-reluctant-list-start? = true
      (t:GListRest) :
        scanned-rest? = true
      (t) :
        false

    ;Process scanned non-reluctant flag
    if non-reluctant-terminal?(prev-item) :
      scanned-non-reluctant? = true

    ;Set flags for what is upcoming
    match(upcoming(grammar,item)) :
      (t:GListStart) :
        list-expected? = true
      (t:GListEnd) :
        list-end-expected? = true
      (t:GTerminal) :
        wildcard-expected? = true
      (t:False) :
        if rule(item) == start-rule : start-completed? = true
      (t) :
        false

  recompute-flags()
  new ESet :
    ;===== Set Operations =====
    defmethod clear (this, l:Int) :
      shorten(items, l)
      recompute-flags()
    defmethod add (this, item:EItem) :
      add(items, item)
      process-flags(item)
    defmethod get (this, i:Int) : items[i]
    defmethod length (this) : length(items)
    defmethod to-seq (this) : to-seq(items)
    ;===== Compute =====
    defmethod map! (f:EItem -> EItem, this) :
      map!(f, items)
    defmethod remove! (f:EItem -> True|False, this) :
      remove-when(f, items)
      recompute-flags()
    ;===== Retrieve Flags =====
    defmethod start-completed? (this) : start-completed?
    defmethod scanned-atomic-any? (this) : scanned-atomic-any?
    defmethod scanned-non-reluctant? (this) : scanned-non-reluctant?
    defmethod scanned-non-reluctant-list-start? (this) : scanned-non-reluctant-list-start?
    defmethod scanned-rest? (this) : scanned-rest?
    defmethod wildcard-expected? (this) : wildcard-expected?
    defmethod list-expected? (this) : list-expected?
    defmethod list-end-expected? (this) : list-end-expected?

defmethod do (f:EItem -> ?, eset:ESet) :
  val item-index = to-seq(0 to false)
  while peek(item-index) < length(eset) :
    f(eset[next(item-index)])

defn empty? (s:ESet) :
  length(s) == 0

;defn print-current-set (grammar:Grammar, set-index:Int, current-set:ESet) :
;  println("Set %_" % [set-index])
;  within indented() :
;    do(println{format(grammar,_)}, current-set)

;============================================================
;============= Classification of Terminals ==================
;============================================================

;Returns true if the given terminal is a reluctant terminal.
defn reluctant-terminal? (t:GTerminal) :
  match(t) :
    (t:GListStart) : reluctant?(t)
    (t:GAny) : type(t) is Reluctant
    (t:GListRest) : true
    (t) : false

;Returns true if the given token is a non-reluctant terminal.
defn non-reluctant-terminal? (t:GToken|False) :
  match(t:GTerminal) : not reluctant-terminal?(t)
  else : false

;============================================================
;=================== Search Result ==========================
;============================================================

public deftype SearchResult

public defstruct SearchSuccess <: SearchResult :
  setlist: ESetList
  inputlist: Vector<SExpToken>
  infolist: Vector<FileInfo|False>

public defstruct SearchFailure <: SearchResult :
  missing: Tuple<MissingInput>

;============================================================
;==================== Search Progress =======================
;============================================================

public deftype SearchProgress
public defmulti completed-set (progress:SearchProgress, index:Int, eset:ESet) -> False

;============================================================
;====================== Algorithm ===========================
;============================================================

public defn search (progress:SearchProgress, grammar:Grammar, input:List) -> SearchResult :
  val input-stream = SExpStream(input)
  val setlist = ESetList(grammar)
  val prediction-set = ProductionSet(num-productions(grammar))
  val completion-set = CompletionSet()
  val production-count = ProductionTable<Int>(num-productions(grammar), 0)
  val inputlist = Vector<SExpToken>()
  val infolist = Vector<FileInfo|False>()
  val missing = Vector<MissingInput>()

  ;Advances items in current-set and puts them in next-set.
  defn process-set (set-index:Int,
                    current-set:ESet,
                    next-set:ESet,
                    next-input:SExpToken,
                    include-all-rules?:True|False) :
    ;Clear state
    clear-markers(setlist)
    clear(prediction-set)
    clear(completion-set)

    ;Iterate through each item
    for item in current-set do :
      dispatch(item) where :
        defn* dispatch (item:EItem) :
          ;Dispatch
          match(upcoming(grammar,item)) :
            (t:GTerminal) : upcoming-terminal(item, t)
            (p:GProduction) : upcoming-production(item, p)
            (f:False) : end-of-rule(item)
        defn add-completion (item:EItem) :
          add(current-set, item) when add(completion-set, item)
        defn upcoming-terminal (item:EItem, t:GTerminal) :
          if matches-input?(grammar, t, next-input) :
            add(next-set, inc-num-parsed(item, next-input is SExpWildcard))
        defn upcoming-production (item:EItem, t:GProduction) :
          if nullable?(grammar, id(t)) :
            add-completion(inc-num-parsed(item,false))
          if add(prediction-set, id(t)) :
            val rules = rules(grammar, id(t)) when include-all-rules?
                   else rules-with-prefix(grammar, id(t), next-input)
            val items = seq(EItem{_, 0, set-index, false}, rules)
            do(add{current-set, _}, items)              
        defn end-of-rule (completed-item:EItem) :
          val prod = production(grammar,completed-item)
          if parent(completed-item) < set-index :
            within item = items(setlist, parent(completed-item), prod, true) :
              ;Compute normal advance of item.
              val item* = inc-num-parsed(item, matched-wildcard?(completed-item))                
              ;Compute advance of item with potentially right-recursive completion.
              val completion* = match(completion-root(item)) :
                (root:EItem) :
                  if core(root) == core(item) :
                    item*
                  else :
                    val root* = inc-num-parsed(root, matched-wildcard?(completed-item))
                    sub-completion-root(root*, item*)
                (f:False) :
                  item*
              ;Add advanced item to set.
              add-completion(completion*)

  ;Remove any conditional matches in the given set to handle
  ;reluctant matching algorithm.
  ;Returns true if the matched terminals implies the input stream
  ;should be expanded.
  defn prune-conditional-matches (eset:ESet, input:SExpToken) -> True|False :
    ;Compute expansion condition
    val expand? = scanned-non-reluctant-list-start?(eset)
              and not scanned-atomic-any?(eset)
    ;Remove items
    for item in eset remove! :
      match(previous(grammar, item)) :
        (t:GListStart) : not expand?
        (t:GAny) :
          if type(t) is Reluctant : expand? or not scanned-non-reluctant?(eset)
          else : expand?
        (t:GListRest) : scanned-non-reluctant?(eset)
        (t) : false
    ;Return list expansion
    expand?

  ;Compute completion-roots of all deterministic reductions.
  defn compute-completion-root (set-index:Int, current-set:ESet) :
    ;Compute count table
    clear(production-count)
    for item in current-set do :
      val t = upcoming(grammar,item)
      match(t:GProduction) :
        production-count[id(t)] = production-count[id(t)] + 1
    ;Determine whether deterministic reduction
    defn deterministic-reduction? (item:EItem) :
      val num-tokens = length(tokens(grammar[rule(item)]))
      if num-parsed(item) == num-tokens - 1 :
        val t = upcoming(grammar, item)
        match(t:GProduction) : production-count[id(t)] == 1
    ;Compute completion
    defn complete (item:EItem) :
      if parent(item) < set-index :
        val pitem = first-item(setlist, parent(item), production(grammar,item))
        match(pitem:EItem) : completion-root(pitem)
    ;Compute completions of all deterministic reductions.
    for item in current-set map! :
      if deterministic-reduction?(item) :
        match(complete(item)) :
          (c:EItem) : sub-completion-root(item, c)
          (f:False) : sub-completion-root(item, item)
      else : item

  defn process-all-sets () :
    ;Initialize current-set and next-set.
    val current-set = ESet(grammar)
    val next-set = ESet(grammar)
    val starting-rule = next(to-seq(rules(grammar,0)))
    add(current-set, EItem(starting-rule, 0, 0, false))

    ;Process sets until finished.
    let loop (set-index:Int = 0,
              current-set:ESet = current-set,
              next-set:ESet = next-set) :
      val next-input = peek(input-stream)
      val num-scanned = length(current-set)
      process-set(set-index, current-set, next-set, next-input, false)
      val expand-list? = prune-conditional-matches(next-set, next-input)

      ;Dispatch to different cases
      defn* dispatch () :
        if empty?(next-set) :
          if start-completed?(current-set) : finished-parse()
          else : unexpected-input()
        else if scanned-rest?(next-set) :
          advance-to-next-set(true)
        else :
          advance-to-next-set(false)

      defn* finished-parse () :
        ;Complete and add to setlist
        compute-completion-root(set-index, current-set)
        add(setlist, current-set)
        ;Report completion
        completed-set(progress, set-index, current-set)

      defn* advance-to-next-set (advance-rest?:True|False) :
        ;Record the current set
        ;Add matched input
        add(inputlist, next-input)
        add(infolist, info(input-stream))

        ;Compute the completion root and add to the setlist
        compute-completion-root(set-index, current-set)

        ;Debug
        ;print-current-set(grammar, set-index, current-set)

        ;Add to setlist
        add(setlist, current-set)

        ;Report completion
        completed-set(progress, set-index, current-set)

        ;Advance either to the end of the list, or by one token
        if advance-rest? : advance-rest(input-stream)
        else : advance(input-stream, expand-list?)

        ;Scan the next set
        clear(current-set, 0)
        loop(set-index + 1, next-set, current-set)

      defn* unexpected-input () :
        ;Compute the complete current set without using look-ahead prediction.
        clear(current-set, num-scanned)
        process-set(set-index, current-set, next-set, next-input, true)

        ;Record context of missing input
        add(missing, MissingInput(next-input, set-index, info(input-stream), to-tuple(current-set)))

        ;Perform error recovery
        if list-end-expected?(current-set) : advance(input-stream, false)
        else if wildcard-expected?(current-set) : insert-wildcard(input-stream)
        else if list-expected?(current-set) : insert-list(input-stream)
        else : fatal("Unrecoverable")

        ;Scan current set again now with additional inserted tokens.
        clear(current-set, num-scanned)
        loop(set-index, current-set, next-set)

      ;Launch
      dispatch()

  ;Launch!
  defn main () :
    process-all-sets()
    if empty?(missing) :
      SearchSuccess(setlist, inputlist, infolist)
    else :
      SearchFailure(to-tuple(missing))

  main()