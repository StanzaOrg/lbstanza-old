defpackage stz/padder :
   import core
   import verse

public definterface PadItem
public defstruct Item <: PadItem :
   alignment: Int
   data
public defstruct Padding <: PadItem :
   size: Int
public defstruct Group <: PadItem :
   items: List<PadItem>

defmethod print (o:OutputStream, i:PadItem) :
   print{o, _} $ match(i) :
      (i:Item) : "Item(~, ~)" << [alignment(i), data(i)]
      (i:Padding) : "Padding(~)" << [size(i)]
      (i:Group) : "{~@}" << [join(items(i), ", ")]

public defn pad (xs:Streamable<PadItem>, align:Int) :
   val output = Vector<PadItem>()
   var accum = 0

   defn add-item (i:PadItem) :
      match(i) :
         (i:Item) :
            add(output, i)
            accum = accum + alignment(i)
         (i:Padding) :
            add(output, i)
            accum = accum + size(i)
            
   defn align-accum (sz:Int) :
      println("align-accum(~)" << [sz])
      defn smaller (sz:Int) :
         switch {sz == _} :
            8 : 4
            4 : 1
            
      if accum % sz > 0 :
         val sz2 = smaller(sz)
         align-accum(sz2)
         while accum % sz > 0 :
            add-item(Padding(sz2))

   defn add-aligned (i:PadItem) :
      defn item-alignment (i:PadItem) :
         match(i) :
            (i:Item) : alignment(i)
            (i:Group) : maximum(stream(item-alignment, items(i)))

      match(i) :
         (i:Item) :
            align-accum(alignment(i))
            add-item(i)
         (i:Group) :
            align-accum(item-alignment(i))
            do(add-aligned, items(i))

   do(add-aligned, xs)
   align-accum(align)
   output

