defpackage stz/reg-alloc-allocation :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-engine
  import stz/reg-alloc-block-engine
  import stz/reg-alloc-pref-scanner
  import stz/reg-alloc-model-analysis

;<doc>=======================================================
;====================== Algorithm ===========================
;============================================================

Sweep through the instructions in forward order.

Keep a table that indicates whether a variable is currently
assigned to a register.

Keep a table that indicates whether a variable is currently
saved or not.

When we hit a Save operation, emit it, but also record
that the variable is now saved. As a sanity check, ensure
that the variable was previously unsaved before the operation.

When we hit an Unload operation, emit it, and also indicate in
the table that the variable is now not assigned to a register.

When we hit an operation statement, we need to ensure that
the arguments are loaded into registers, and that we have
enough free registers to complete the operation.

  Ensuring arguments are loaded:

  If the argument is already loaded, then we don't need to do
  anything. If the argument is unloaded, we need to issue a Load
  statement, and, as a result, indicate that the argument is now
  assigned to a register. Use a sanity check to guensure that the
  variable is saved before issuing the Load statement. It is supposed
  to be guaranteed by the annotation pass.

  In order to issue a Load statement, we need to ensure that
  we have at least one free register. If there isn't, then
  spill a variable first. 

  Ensuring enough free registers:

  After all the arguments are loaded, make sure that we
  have enough free registers to complete the operation. Spill
  variables until that is true. 

Because of the intricacies of the spilling and annotation algorithm,
use sanity checks to ensure that the arguments are indeed
loaded now. 

Now that we have everything we need, we can emit the operation itself.
(Emit the annotated statement, so that the assignment pass can use it
later.)

After the operation, we need to unload the arguments that
have been killed. Use the 'killed-args' field to unload
the correct arguments.

Spilling Variables:

Keep a table that indicates, for each variable, when
it is next used. 

Inspect the list of variables that are currently assigned to
registers, and choose the one that is used latest to spill.

To actually perform the spill, we need to ensure that the variable is
saved, and then emit an Unload statement, and remove it from
the table.

Maintain the next use table by updating it after every operation
statement.

;============================================================
;=======================================================<doc>

public defn allocate-block (e:BlockEngine) -> False :
  ;Scan through the instructions.
  within (i, stmt, emit) = process-instructions(e) :
    match(stmt) :
      (op:AnnotatedOperationStmt) :
        fatal("Not yet implemented")
      (op:Save) :
        fatal("Not yet implemented")
      (op:Unload) :
        fatal("Not yet implemented")
      (op:OperationStmt) :
        fatal("Unexpected unannotated operation statement.")
      (op) :
        emit(op)