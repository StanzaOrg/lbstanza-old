defpackage stz/reg-alloc-allocation :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-engine
  import stz/reg-alloc-block-engine
  import stz/reg-alloc-pref-scanner
  import stz/reg-alloc-model-analysis

;<doc>=======================================================
;====================== Algorithm ===========================
;============================================================

Sweep through the instructions in forward order.

Keep a table that indicates whether a variable is currently
assigned to a register.

Keep a table that indicates whether a variable is currently
saved or not.

When we hit a Save operation, emit it, but also record
that the variable is now saved. As a sanity check, ensure
that the variable was previously unsaved before the operation.

When we hit an Unload operation, emit it, and also indicate in
the table that the variable is now not assigned to a register.

When we hit an operation statement, we need to ensure that
the arguments are loaded into registers, and that we have
enough free registers to complete the operation.

  Ensuring arguments are loaded:

  If the argument is already loaded, then we don't need to do
  anything. If the argument is unloaded, we need to issue a Load
  statement, and, as a result, indicate that the argument is now
  assigned to a register. Use a sanity check to ensure that the
  variable is saved before issuing the Load statement. It is supposed
  to be guaranteed by the annotation pass.

  In order to issue a Load statement, we need to ensure that
  we have at least one free register. If there isn't, then
  spill a variable first.

  Ensuring enough free registers:

  After all the arguments are loaded, make sure that we
  have enough free registers to complete the operation. Spill
  variables until that is true.

Because of the intricacies of the spilling and annotation algorithm,
use sanity checks to ensure that the arguments are indeed
loaded now.

Now that we have everything we need, we can emit the operation itself.
(Emit the annotated statement, so that the assignment pass can use it
later.)

After the operation, we need to unload the arguments that
have been killed. Use the 'killed-args' field to unload
the correct arguments. If the operation calls clear-registers, then
every variable is unloaded. For the results of the operation, load
them into registers. There should be enough free registers guaranteed
to hold the results. Use sanity checks to ensure this.

Spilling Variables:

Keep a table that indicates, for each variable, when
it is next used.

Inspect the list of variables that are currently assigned to
registers, and choose the one that is used latest to spill.

To actually perform the spill, we need to ensure that the variable is
saved, and then emit an Unload statement, and remove it from
the table.

Maintain the next use table by updating it after every operation
statement.

;============================================================
;=======================================================<doc>

public defn allocate-block (e:BlockEngine,
                            num-regs:Int,
                            num-fregs:Int) -> False :

  ;----------------------------------------------------------
  ;--------------------- Algorithm State --------------------
  ;----------------------------------------------------------

  ;Table tracking whether a variable is currently
  ;assigned to a register.
  val variable-loaded = IntTable<AnyReg|AnyFReg>()

  ;Table tracking whether a variable is currently
  ;saved in a stack slot.
  val variable-saved = IntSet()

  ;Table tracking the next usage of a variable.
  val variable-next-usage = IntTable<Int>()

  ;----------------------------------------------------------
  ;--------------------- Sanity Checks ----------------------
  ;----------------------------------------------------------

  ;Ensure that v is loaded, and that v's loaded into a location
  ;that is compatible with loc.
  defn check-variable-loaded! (v:Int, loc:AnyReg|AnyFReg) -> False :
    match(get?(variable-loaded,v)) :
      (r:AnyReg|AnyFReg) :
        if r != loc :
          fatal("Variable %_ is loaded to %_, but expecting %_." % [
            v, r, loc])
      (f:False) :
        fatal("Variable %_ is not loaded." % [v])

  ;Ensure that there are the specified number of free registers.
  defn check-free-registers! (regs:UsedRegisters) -> False :
    if used-regs(regs) > num-free(AnyReg()) :
      fatal("%_ integer registers are required but only %_ are free." % [
        used-regs(regs), num-free(AnyReg())])
    if used-fregs(regs) > num-free(AnyFReg()) :
      fatal("%_ floating-point registers are required but only %_ are free." % [
        used-fregs(regs), num-free(AnyFReg())])

  ;Ensure there is at least one free register of the given type.
  defn check-free-register! (loc:AnyReg|AnyFReg) -> False :
    if num-free(loc) == 0 :
      val type = "integer" when loc is AnyReg else "floating-point"
      fatal("There are no %_ registers free." % [type])

  ;----------------------------------------------------------
  ;--------------------- Helper Functions -------------------
  ;----------------------------------------------------------

  ;Return, for the given location, the number of free
  ;registers of that type.
  defn num-free (loc:AnyReg|AnyFReg) -> Int :
    val num-assigned = count({value(_) == loc}, variable-loaded)
    val num-available = match(loc) :
      (loc:AnyReg) : num-regs
      (loc:AnyFReg) : num-fregs
    num-available - num-assigned

  ;Spill one register of the given type.
  defn spill-register (loc:AnyReg|AnyFReg, emit:ProgramStmt -> ?) -> False :
    ;Find all the loaded variables of the right type.
    val vars-of-same-type = for v in variable-loaded seq? :
      if value(v) == loc : One(key(v))
      else : None()
    ;Sanity check: there should be at least one variable.
    if empty?(vars-of-same-type) :
      fatal("No variable to spill.")
    ;Find the one that is used farthest from now.
    val farthest-var = maximum({variable-next-usage[_]},
                               vars-of-same-type)
    ;Unload the variable.
    emit(Unload(farthest-var))
    remove(variable-loaded, farthest-var)
    false

  ;Ensure there is at least one free register of the
  ;same category as loc. Spill variables to make space
  ;if necessary.
  defn ensure-free-register (loc:AnyReg|AnyFReg, emit:ProgramStmt -> ?) -> False :
    if num-free(loc) == 0 :
      spill-register(loc, emit)
      if num-free(loc) != 1 :
        fatal("Spilling algorithm failed.")

  ;Ensure that there is as many free registers as is specified in
  ;UsedRegisters. Spill variables to make space if necessary.
  defn ensure-free-registers (regs:UsedRegisters, emit:ProgramStmt -> ?) -> False :
    val num-additional-regs = used-regs(regs) - num-free(AnyReg())
    val num-additional-fregs = used-fregs(regs) - num-free(AnyFReg())
    for i in 0 to num-additional-regs do : spill-register(AnyReg(), emit)
    for i in 0 to num-additional-fregs do : spill-register(AnyFReg(), emit)

  ;Return true if v is assigned to some register.
  defn loaded? (v:Int) -> True|False :
    key?(variable-loaded,v)

  ;If v is not loaded, then load it.
  ;Spill variables to make space if necessary.
  defn ensure-loaded (v:Int, loc:AnyReg|AnyFReg, emit:ProgramStmt -> ?) -> False :
    if loaded?(v) :
      check-variable-loaded!(v,loc)
    else :
      ensure-free-register(loc, emit)
      emit(Load(v,loc))
      variable-loaded[v] = loc


  ;----------------------------------------------------------
  ;--------------------- Main Algorithm ---------------------
  ;----------------------------------------------------------

  ;Scan through the instructions.
  within (i, stmt, emit) = process-instructions(e) :
    match(stmt) :
      (op:AnnotatedOperationStmt) :
        ;Retrieve the locations that the operation expects
        ;arguments to be, and the locations where results will be.
        val arg-locs = arg-locations(e, op)
        val result-locs = result-locations(e, op)

        ;Ensure that the arguments are loaded for use by the operation.
        for (v in args(op), loc in arg-locs) do :
          ensure-loaded(v, loc, emit)

        ;Ensure that there are enough free registers to
        ;complete the operation.
        ensure-free-registers(used-registers(op), emit)

        ;Sanity check: Ensure arguments are actually loaded
        ;into the correct place.
        do(check-variable-loaded!, args(op), arg-locs)

        ;Sanity check: Ensure we actually have enough registers.
        check-free-registers!(used-registers(op))

        ;Emit the (annotated) operation itself.
        emit(op)

        ;Unload the arguments.
        if clears-registers?(e, op) :
          clear(variable-loaded)
        else :
          for i in killed-args(op) do :
            val v = args(op)[i]
            remove(variable-loaded, v)

        ;Load the results into registers.
        ;Ensure that they are not already loaded, and that there
        ;are free registers available.
        for (v in results(op), loc in result-locs) do :
          if key?(variable-loaded,v) :
            fatal("Variable already loaded.")
          check-free-register!(loc)
          variable-loaded[v] = loc

        ;Update the next usage information for all results
        ;and arguments.
        for (v in results(op), usage in result-uses(op)) do :
          match(usage) :
            (usage:Int) : variable-next-usage[v] = usage
            (usage:False) : remove(variable-next-usage, v)
        for (v in args(op), usage in arg-uses(op)) do :
          match(usage) :
            (usage:Int) : variable-next-usage[v] = usage
            (usage:False) : remove(variable-next-usage, v)

      (op:Save) :
        if variable-saved[arg(op)] :
          fatal("Variable has already been saved. Cannot save.")
        emit(op)
        add(variable-saved, arg(op))

      (op:Unload) :
        if not loaded?(arg(op)) :
          fatal("Variable has not been loaded. Cannot unload.")
        emit(op)
        remove(variable-loaded, arg(op))

      (op:OperationStmt) :
        fatal("Unexpected unannotated operation statement.")

      (op) :
        emit(op)

  ;Update the output port statuses.
  val new-ports = to-tuple $ for p in outputs(e) seq :
    val status = PortStatus(
      variable-saved[id(p)]
      get?(variable-loaded, id(p)))
    sub-status(p, status)
  set-contents(outputs(e), new-ports)

;============================================================
;====================== Helpers =============================
;============================================================

;Return the wrapped arguments.
defn args (op:AnnotatedOperationStmt) -> Tuple<Int> :
  args(stmt(op))

;Return the wrapped results.
defn results (op:AnnotatedOperationStmt) -> Tuple<Int> :
  results(stmt(op))

;Return the general locations of the arguments to the statement.
defn arg-locations (e:BlockEngine, op:AnnotatedOperationStmt) -> Tuple<AnyReg|AnyFReg> :
  val mprops = model-properties(e)[op-id(stmt(op))]
  general-arg-locations(mprops)

;Return the general locations of the results of the statement.
defn result-locations (e:BlockEngine, op:AnnotatedOperationStmt) -> Tuple<AnyReg|AnyFReg> :
  val mprops = model-properties(e)[op-id(stmt(op))]
  general-result-locations(mprops)

;Return true if the given operation calls clear-registers
defn clears-registers? (e:BlockEngine, op:AnnotatedOperationStmt) -> True|False :
  val mprops = model-properties(e)[op-id(stmt(op))]
  clears-registers?(mprops)

;Helper: Set the contents of the given vector.
defn set-contents<?T> (vs:Vector<?T>, xs:Seqable<T>) :
  clear(vs)
  add-all(vs,xs)      