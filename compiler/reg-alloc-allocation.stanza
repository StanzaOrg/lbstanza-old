defpackage stz/reg-alloc-allocation :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-model-env
  import stz/reg-alloc-block-stmt-processor

;<doc>=======================================================
;====================== Algorithm ===========================
;============================================================

Sweep through the instructions in forward order.

Keep a table that indicates whether a variable is currently
assigned to a register.

Keep a table that indicates whether a variable is currently
saved or not.

For the input ports, check its port preferences. If it prefers to be
saved, then assume it is saved. If it prefers to be loaded, then
initially mark it as loaded in the table, and then spill if we are
using more registers than we have available. Record the input
port status after this spilling has been done.

When we hit a Save operation, emit it, but also record
that the variable is now saved. As a sanity check, ensure
that the variable was previously unsaved before the operation.

When we hit an Unload operation, emit it, and also indicate in
the table that the variable is now not assigned to a register.

When we hit an operation statement, we need to ensure that
the arguments are loaded into registers, and that we have
enough free registers to complete the operation.

  Ensuring arguments are loaded:

  If the argument is already loaded, then we don't need to do
  anything. If the argument is unloaded, we need to issue a Load
  statement, and, as a result, indicate that the argument is now
  assigned to a register. Use a sanity check to ensure that the
  variable is saved before issuing the Load statement. It is supposed
  to be guaranteed by the annotation pass.

  In order to issue a Load statement, we need to ensure that
  we have at least one free register. If there isn't, then
  spill a variable first.

  Ensuring enough free registers:

  After all the arguments are loaded, make sure that we
  have enough free registers to complete the operation. Spill
  variables until that is true.

Because of the intricacies of the spilling and annotation algorithm,
use sanity checks to ensure that the arguments are indeed
loaded now.

Now that we have everything we need, we can emit the operation itself.
(Emit the annotated statement, so that the assignment pass can use it
later.)

After the operation, we need to unload the arguments that
have been killed. Use the 'killed-args' field to unload
the correct arguments. If the operation calls clear-registers, then
every variable is unloaded. For the results of the operation, load
them into registers. There should be enough free registers guaranteed
to hold the results. Use sanity checks to ensure this.

Spilling Variables:

Keep a table that indicates, for each variable, when
it is next used.

Inspect the list of variables that are currently assigned to
registers, and choose the one that is used latest to spill.

To actually perform the spill, we need to ensure that the variable is
saved, and then emit an Unload statement, and remove it from
the table.

Maintain the next use table by updating it after every operation
statement.

;============================================================
;=======================================================<doc>

public defn allocate-block (proc:BlockStmtProcessor,
                            models:ModelEnv,
                            num-regs:Int,
                            num-fregs:Int) -> False :

  ;----------------------------------------------------------
  ;--------------------- Algorithm State --------------------
  ;----------------------------------------------------------

  ;Table tracking whether a variable is currently
  ;assigned to a register.
  val variable-loaded = IntTable<RegisterType>()

  ;Table tracking whether a variable is currently
  ;saved in a stack slot.
  val variable-saved = IntSet()

  ;Table tracking the next usage of a variable.
  val variable-next-usage = IntTable<Int>()

  ;----------------------------------------------------------
  ;--------------------- Sanity Checks ----------------------
  ;----------------------------------------------------------

  ;Ensure that v is loaded.
  defn check-variable-loaded! (v:Int, type:RegisterType) -> False :
    match(get?(variable-loaded,v)) :
      (r:RegisterType) :
        if r != type :
          fatal("Variable %_ is loaded to %_, but expecting %_." % [
            v, r, type])
      (f:False) :
        fatal("Variable %_ is not loaded." % [v])

  ;Ensure that there are the specified number of free registers.
  defn check-free-registers! (regs:UsedRegisters) -> False :
    if used-regs(regs) > num-free(AnyReg()) :
      fatal("%_ integer registers are required but only %_ are free." % [
        used-regs(regs), num-free(AnyReg())])
    if used-fregs(regs) > num-free(AnyFReg()) :
      fatal("%_ floating-point registers are required but only %_ are free." % [
        used-fregs(regs), num-free(AnyFReg())])

  ;Ensure there is at least one free register of the given type.
  defn check-free-register! (type:RegisterType) -> False :
    if num-free(type) == 0 :
      val type-str = "integer" when type is AnyReg else "floating-point"
      fatal("There are no %_ registers free." % [type-str])

  ;----------------------------------------------------------
  ;--------------------- Helper Functions -------------------
  ;----------------------------------------------------------

  ;Return, for the given location, the number of free
  ;registers of that type.
  defn num-free (type:RegisterType) -> Int :
    val num-assigned = count({value(_) == type}, variable-loaded)
    val num-available = match(type) :
      (type:AnyReg) : num-regs
      (type:AnyFReg) : num-fregs
    num-available - num-assigned

  ;Spill one register of the given type.
  defn spill-register (type:RegisterType) -> False :
    ;Find all the loaded variables of the right type.
    val vars-of-same-type = for v in variable-loaded seq? :
      if value(v) == type : One(key(v))
      else : None()
    ;Sanity check: there should be at least one variable.
    if empty?(vars-of-same-type) :
      fatal("No variable to spill.")
    ;Find the one that is used farthest from now.
    val farthest-var = maximum({variable-next-usage[_]},
                               vars-of-same-type)
    ;Save the variable if necessary.
    if not variable-saved[farthest-var] :
      add(variable-saved, farthest-var)
      emit(proc, Save(farthest-var, type))
    ;Unload the variable.
    emit(proc, Unload(farthest-var))
    remove(variable-loaded, farthest-var)
    false

  ;Acts like 'spill-register' except that instructions are not generated.
  ;This is used upon entry to the block to decide which input ports should arrive
  ;already spilled.
  defn prespill-register (type:RegisterType) -> False :
    ;Find all the loaded variables of the right type.
    val vars-of-same-type = for v in variable-loaded seq? :
      if value(v) == type : One(key(v))
      else : None()
    ;Sanity check: there should be at least one variable.
    if empty?(vars-of-same-type) :
      fatal("No variable to spill.")
    ;Find the one that is used farthest from now.
    val farthest-var = maximum({variable-next-usage[_]},
                               vars-of-same-type)
    ;Mark the variable is saved, but not loaded.
    add(variable-saved, farthest-var)
    remove(variable-loaded, farthest-var)
    false

  ;Ensure there is at least one free register of the
  ;same category as loc. Spill variables to make space
  ;if necessary.
  defn ensure-free-register (type:RegisterType) -> False :
    if num-free(type) == 0 :
      spill-register(type)
      if num-free(type) != 1 :
        fatal("Spilling algorithm failed.")

  ;Ensure that there is as many free registers as is specified in
  ;UsedRegisters. Spill variables to make space if necessary.
  defn ensure-free-registers (regs:UsedRegisters) -> False :
    val num-additional-regs = used-regs(regs) - num-free(AnyReg())
    val num-additional-fregs = used-fregs(regs) - num-free(AnyFReg())
    for i in 0 to num-additional-regs do : spill-register(AnyReg())
    for i in 0 to num-additional-fregs do : spill-register(AnyFReg())

  ;Return true if v is assigned to some register.
  defn loaded? (v:Int) -> True|False :
    key?(variable-loaded,v)

  ;If v is not loaded, then load it.
  ;Spill variables to make space if necessary.
  defn ensure-loaded (v:Int, type:RegisterType) -> False :
    if loaded?(v) :
      check-variable-loaded!(v,type)
    else :
      ensure-free-register(type)
      emit(proc, Load(v,type))
      variable-loaded[v] = type


  ;----------------------------------------------------------
  ;--------------------- Main Algorithm ---------------------
  ;----------------------------------------------------------

  ;## Inherit PortPref From Predecessors ##
  val pred-regs = IntTable<Register>()
  for ports in predecessor-ports(proc) do :
    for p in ports do :
      val s = status!(p)
      if loaded(s) is Location :
        pred-regs[id(p)] = loaded(s) as Register
  for port in proc update-inputs :
    val prefs = prefs!(port)
    val [new-load-pref, pref-reg] =
      match(load-pref(prefs), get?(pred-regs, id(port))) :
        (lp:PreferUnload, reg) : [lp, false]
        (lp:NoPreferUnload, reg:False) : [PreferUnload, false]
        (lp:NoPreferUnload, reg:Register) : [NoPreferUnload, reg]
    val new-prefs = PortPref(save-pref(prefs), new-load-pref, pref-reg)
    sub-prefs(port, new-prefs)
  
  ;## Prelude ##

  ;Initialize the variable-loaded table and variable-saved tables.
  for port in inputs(proc) do :
    val pref = prefs!(port)
    if save-pref(pref) is PreferSave :
      add(variable-saved, id(port))
    if load-pref(pref) is NoPreferUnload :
      variable-loaded[id(port)] = vartype(proc,id(port))
  
  ;Record the next usages of ports.
  for p in inputs(proc) do :
    variable-next-usage[id(p)] = usage-position(p)
      
  ;Spill ports if we are using more than the available
  ;number of registers.
  while num-free(AnyReg()) < 0 :
    prespill-register(AnyReg())
  while num-free(AnyFReg()) < 0 :
    prespill-register(AnyFReg())
    
  ;Save the status of the ports at this point.
  for p in proc update-inputs :
    val status = PortStatus(
      variable-saved[id(p)]
      get?(variable-loaded, id(p)))
    sub-status(p, status)

  ;## Instructions ##

  within (i, stmt) = stmts(proc) :
    match(stmt) :
      (op:AnnotatedOperationStmt) :
        ;Retrieve the locations that the operation expects
        ;arguments to be, and the locations where results will be.
        val arg-types = arg-types(models, op-id(op))
        val result-types = result-types(models, op-id(op))

        ;Ensure that the arguments are loaded for use by the operation.
        for (v in args(op), type in arg-types) do :
          ensure-loaded(v, type)

        ;Ensure that there are enough free registers to
        ;complete the operation.
        ensure-free-registers(used-registers(op))

        ;Sanity check: Ensure arguments are actually loaded
        ;into the correct place.
        do(check-variable-loaded!, args(op), arg-types)

        ;Sanity check: Ensure we actually have enough registers.
        check-free-registers!(used-registers(op))

        ;Emit the (annotated) operation itself.
        emit(proc, op)

        ;Unload the arguments.
        if clears-registers?(models, op-id(op)) :
          clear(variable-loaded)
        else :
          for i in killed-args(op) do :
            val v = args(op)[i]
            remove(variable-loaded, v)

        ;Load the results into registers, and indicate they are
        ;not yet saved.
        ;Ensure that they are not already loaded, and that there
        ;are free registers available.
        for (v in results(op), type in result-types) do :
          if key?(variable-loaded,v) :
            fatal("Variable V%_ already loaded." % [v])
          check-free-register!(type)
          variable-loaded[v] = type
          remove(variable-saved, v)

        ;Update the next usage information for all results
        ;and arguments.
        for (v in args(op), usage in arg-uses(op)) do :
          match(usage) :
            (usage:Int) : variable-next-usage[v] = usage
            (usage:False) : remove(variable-next-usage, v)
        for (v in results(op), usage in result-uses(op)) do :
          match(usage) :
            (usage:Int) : variable-next-usage[v] = usage
            (usage:False) : remove(variable-next-usage, v)

      (op:Save) :
        if variable-saved[id(op)] :
          fatal("Variable has already been saved. Cannot save.")
        emit(proc, op)
        add(variable-saved, id(op))

      (op:Unload) :
        if not loaded?(id(op)) :
          fatal("Variable has not been loaded. Cannot unload.")
        emit(proc, op)
        remove(variable-loaded, id(op))

      (op:OperationStmt) :
        fatal("Unexpected unannotated operation statement.")

      (op) :
        emit(proc, op)

  ;## Postlude ##

  for p in proc update-outputs :
    ;Compute new save and loaded status.
    val status = PortStatus(
      variable-saved[id(p)]
      get?(variable-loaded, id(p)))
    ;Sanity check: If it's an output, then the variable needs
    ;to be either saved, or loaded into a register.
    if not saved?(status) and loaded(status) is False :
      fatal("Output port V%_ is neither saved nor loaded." % [id(p)])
    ;Substitute port with new status.
    sub-status(p, status)            