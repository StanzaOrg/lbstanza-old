defpackage stz/reg-alloc-allocation :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-engine
  import stz/reg-alloc-block-engine
  import stz/reg-alloc-pref-scanner
  import stz/reg-alloc-model-analysis

;<doc>=======================================================
;====================== Algorithm ===========================
;============================================================

Sweep through the instructions in forward order.

Keep a table that indicates whether a variable is currently
assigned to a register.

Keep a table that indicates whether a variable is currently
saved or not.

When we hit a Save operation, emit it, but also record
that the variable is now saved. As a sanity check, ensure
that the variable was previously unsaved before the operation.

When we hit an Unload operation, emit it, and also indicate in
the table that the variable is now not assigned to a register.

When we hit an operation statement, we need to ensure that
the arguments are loaded into registers, and that we have
enough free registers to complete the operation.

  Ensuring arguments are loaded:

  If the argument is already loaded, then we don't need to do
  anything. If the argument is unloaded, we need to issue a Load
  statement, and, as a result, indicate that the argument is now
  assigned to a register. Use a sanity check to ensure that the
  variable is saved before issuing the Load statement. It is supposed
  to be guaranteed by the annotation pass.

  In order to issue a Load statement, we need to ensure that
  we have at least one free register. If there isn't, then
  spill a variable first. 

  Ensuring enough free registers:

  After all the arguments are loaded, make sure that we
  have enough free registers to complete the operation. Spill
  variables until that is true. 

Because of the intricacies of the spilling and annotation algorithm,
use sanity checks to ensure that the arguments are indeed
loaded now. 

Now that we have everything we need, we can emit the operation itself.
(Emit the annotated statement, so that the assignment pass can use it
later.)

After the operation, we need to unload the arguments that
have been killed. Use the 'killed-args' field to unload
the correct arguments. If the operation calls clear-registers, then
every variable is unloaded. For the results of the operation, load
them into registers. There should be enough free registers guaranteed
to hold the results. Use sanity checks to ensure this. 

Spilling Variables:

Keep a table that indicates, for each variable, when
it is next used. 

Inspect the list of variables that are currently assigned to
registers, and choose the one that is used latest to spill.

To actually perform the spill, we need to ensure that the variable is
saved, and then emit an Unload statement, and remove it from
the table.

Maintain the next use table by updating it after every operation
statement.

;============================================================
;=======================================================<doc>

public defn allocate-block (e:BlockEngine,
                            num-regs:Int,
                            num-fregs:Int) -> False :

  ;----------------------------------------------------------
  ;--------------------- Algorithm State --------------------
  ;----------------------------------------------------------

  ;Table tracking whether a variable is currently
  ;assigned to a register.
  val variable-loaded = IntTable<AnyReg|AnyFReg>()

  ;Table tracking whether a variable is currently
  ;saved in a stack slot.
  val variable-saved = IntSet()

  ;Table tracking the next usage of a variable.
  val variable-next-usage = IntTable<Int>()

  ;----------------------------------------------------------
  ;--------------------- Main Algorithm ---------------------
  ;----------------------------------------------------------

  ;Scan through the instructions.
  within (i, stmt, emit) = process-instructions(e) :
    println("Process %_" % [stmt])
    match(stmt) :
      (op:AnnotatedOperationStmt) :
        ;Retrieve the locations that the operation expects
        ;arguments to be, and the locations where results will be.
        val arg-locs = arg-locations(e, /stmt(op))
        val result-locs = fatal("Get result locs")
        
        ;Ensure that the arguments are loaded for use by the operation.
        do(ensure-loaded, args(op), arg-locs)

        ;Ensure that there are enough free registers to
        ;complete the operation.
        ensure-free-registers(used-registers(op))

        ;Sanity check: Ensure arguments are actually loaded
        ;into the correct place.
        do(check-variable-loaded!, args(op), arg-locs)
        
        ;Sanity check: Ensure we actually have enough registers.
        ensure-free-registers!(used-registers(op))

        ;Emit the (annotated) operation itself.
        emit(op)

        ;Unload the arguments.
        if clears-registers?(e, /stmt(op)) :
          clear(variable-loaded)
        else :
          for i in killed-args(op) do :
            val v = args(op)[i]
            remove(variable-loaded, v)

        ;Load the results into registers.
        ;Ensure that they are not already loaded, and that there
        ;are free registers available.
        for (v in results(op), loc in result-locs) do :
          if key?(variable-loaded,v) :
            fatal("Variable already loaded.")
          ensure-free-register!(loc)
          variable-loaded[v] = loc

        ;Update the next usage information for all results
        ;and arguments.
        for (v in results(op), usage in result-uses(op)) do :
          match(usage) :
            (usage:Int) : variable-next-usage[v] = usage
            (usage:False) : remove(variable-next-usage, v)
        for (v in args(op), usage in arg-uses(op)) do :
          match(usage) :
            (usage:Int) : variable-next-usage[v] = usage
            (usage:False) : remove(variable-next-usage, v)        

      (op:Save) :
        if variable-saved[arg(op)] :
          fatal("Variable has already been saved. Cannot save.")
        emit(op)
        add(variable-saved, arg(op))
        
      (op:Unload) :
        if not key?(variable-loaded,arg(op)) :
          fatal("Variable has not been loaded. Cannot unload.")
        emit(op)
        remove(variable-loaded, arg(op))
        
      (op:OperationStmt) :
        fatal("Unexpected unannotated operation statement.")
        
      (op) :
        emit(op)