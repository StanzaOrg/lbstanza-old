defpackage stz/reg-alloc-block-engine :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-engine
  import stz/printing-utils
  import stz/reg-alloc-model-analysis
  import stz/reg-alloc-shuffle

public defstruct BlockEngine :
  inputs:Vector<Port> with:
    init => Vector<Port>()
  instructions:Vector<ProgramStmt> with:
    init => Vector<ProgramStmt>()
  outputs:Vector<Port> with:
    init => Vector<Port>()
  models:Tuple<OperationModel>
  model-properties:Vector<ModelProperties>
  model-analyzer:ModelAnalyzer
  var-types:IntTable<RegisterType>
  shuffle-engine:ShuffleEngine

;============================================================
;==================== Printers ==============================
;============================================================

defmethod print (o:OutputStream, be:BlockEngine) :
  val items = [
    named-list-fields("inputs", inputs(be))
    named-list-fields("instructions", instructions(be))
    named-list-fields("outputs", outputs(be))]
  print(o, "BlockEngine%_" % [colon-field-list(items)])

;============================================================
;==================== Processors ============================
;============================================================

;Process the instructions in the engine.
public defn process-instructions (
              prelude:(ProgramStmt -> False) -> ?,
              f:(Int, ProgramStmt, ProgramStmt -> False) -> ?,
              postlude:(ProgramStmt -> False) -> ?,
              e:BlockEngine,
              reverse?:True|False) -> False :
  ;Create callback for pushing to a new buffer.
  val new-instructions = Vector<ProgramStmt>()
  defn emit (stmt:ProgramStmt) -> False :
    add(new-instructions, stmt)

  ;Process all the instructions.
  prelude(emit)
  val indices = reverse(0 to length(instructions(e))) when reverse?
           else 0 to length(instructions(e))
  for i in indices do :
    val ins = instructions(e)[i]
    f(i, ins, emit)
  postlude(emit)

  ;Replace instructions in engine.
  reverse!(new-instructions) when reverse?
  clear(instructions(e))
  add-all(instructions(e), new-instructions)

;Process the instructions in the engine.
public defn process-instructions (
              f:(Int, ProgramStmt, ProgramStmt -> False) -> ?,
              e:BlockEngine) -> False :
  process-instructions({false}, f, {false}, e, false)

;Process the instructions in reverse in the engine.
public defn process-instructions-in-reverse (
              f:(Int, ProgramStmt, ProgramStmt -> False) -> ?,
              e:BlockEngine) -> False :
  process-instructions({false}, f, {false}, e, true)