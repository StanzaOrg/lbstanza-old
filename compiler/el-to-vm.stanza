defpackage stz/el-to-vm :
  import core
  import collections
  import stz/el-ir
  import stz/el-utils
  import stz/el
  import stz/dl-ir
  import stz/vm-ir
  import stz/typeset
  import stz/vm-analyze
  import stz/utils
  import stz/basic-ops
  import stz/algorithms
  import stz/ehier
  import core/stack-trace
  import stz/safepoint-table-creator
  import stz/dump-to-log
  import stz/absolute-info
  import stz/trace-info
  import stz/el-trace-info

;============================================================
;======================== Driver ============================
;============================================================

public defn compile (epackage:EPackage) -> VMPackage :
  val io = packageio(epackage)
  val iotable = IOTable(io)
  val ehier = EHier(epackage)
  val progbuffer = ProgBuffer()
  val global-table = GlobalTable(io, epackage)
  val init-compiler = Compiler(global-table, iotable, ehier, progbuffer)
  take-ids(cat(used-ids(io), used-ids(epackage)))
  val dtable = within time-ms!("Analyze Dependencies") :
    analyze-dependencies(epackage, global-table)

  compile-debug-info(progbuffer, io)
  val init = within time-ms!("Compile to VM") :
    for e in exps(epackage) do :
      match(e) :
        (e:EDefn) : compile(e, global-table, iotable, ehier, progbuffer)
        (e:EDefClosure) : compile(e, dtable, global-table, iotable, ehier, progbuffer)
        (e:EDefGlobal) : compile(e, global-table, iotable, progbuffer)
        (e:EDefStruct) : compile(e, global-table, iotable, progbuffer)
        (e:EInit) : compile(init-compiler, e)
        (e:EExtern) : compile(e, progbuffer)
        (e:EDefType) : compile(e, progbuffer)
        (e:EDefObject) : compile(e, dtable, global-table, iotable, progbuffer)
        (e:EDefTypeObject) : compile(e, global-table, iotable, ehier, progbuffer)
        (e:EDefmulti) : compile(e, global-table, iotable, ehier, progbuffer)
        (e:EDefmethod) : compile(e, global-table, iotable, ehier, progbuffer)
        (e:EExternFn) : compile(e, global-table, iotable, ehier, progbuffer)
    val init = compile-init(init-compiler, iotable, progbuffer)
    init

  val vmp = to-vmpackage(progbuffer, io, init)
  ;dump(vmp, "logs", "pre-analyze")
  val vmp* = within time-ms!("VM Analyze") : analyze(vmp)
  dump(vmp*, "logs")
  vmp*

;============================================================
;====================== Unique IDs ==========================
;============================================================

val TAKEN-IDS = IntSet()
var ID-COUNTER:Seq<Int> = to-seq(0 to false)

defn take-ids (ids:Seqable<Int>) :
  clear(TAKEN-IDS)
  add-all(TAKEN-IDS, ids)
  ID-COUNTER = to-seq(0 to false)

defn used-ids (io:PackageIO) :
  seq(n, cat(imports(io), exports(io)))
defn used-ids (e:EPackage) :
  for e in exps(e) seq? :
    match(e) :
      (e:EDefGlobal) : One(n(e))
      (e:EDefn) : One(n(e))
      (e:EDefClosure) : One(n(e))
      (e:EDefmulti) : One(n(e))
      (e:EDefmethod) : One(n(e))
      (e:EDefStruct) : One(n(e))
      (e:EExternFn) : One(n(e))
      (e:EExtern) : One(n(e))
      (e:EInit) : None()
      (e:EDefType) : One(n(e))
      (e:EDefObject) : One(n(e))
      (e:EDefTypeObject) : One(n(e))

;Generates a globally unique id.
defn uniqueid () -> Int :
  for i in ID-COUNTER find! :
    not TAKEN-IDS[i]

;============================================================
;================= Dependency Analysis ======================
;============================================================

defn analyze-dependencies (ep:EPackage, gt:GlobalTable) :
  ;Returns all dependencies in ELItem
  defn scan (e:ELItem, initial-set:Seqable<Int>) :
    val dependencies = to-intset(initial-set)
    let loop (e:ELItem = e) :
      do(loop, e)
      match(e) :
        ;Types
        (e:EStructT) : add(dependencies, n(e))
        (e:EOf) : add(dependencies, n(e))
        ;Immediates and Locations
        (e:EVar|EVarLoc) : add(dependencies, n(e)) when global?(gt,n(e))
        (e:ETagof) : add(dependencies, n(e))
        ;Instructions
        (e:EField) : add(dependencies, n(e))
        (e:ENew) : add(dependencies, n(e))
        (e:EObject) : add(dependencies, n(e))
        (e:EArray) : add(dependencies, n(e))
        (e:EStruct) : add(dependencies, n(e))
        (e:ENewObject) : add(dependencies, n(e))
        (e:EObjectGet) : add(dependencies, n(e))
        (e:EObjectTGet) : add(dependencies, n(e))
        (e:EClosureGet) : add(dependencies, n(e))
        (e:EClosureTGet) : add(dependencies, n(e))
        (e:EClosure) : add(dependencies, n(e))
        (e:ETypeObject) : add(dependencies, n(e))
        ;Remaining
        (e) : false
    to-tuple(dependencies)

  defn scan (e:ELItem) :
    scan(e, IntSet())

  ;Compute dependency graph
  val dtable = IntTable<Tuple<Int>>([])
  within time-ms!("Construct Immediate Dependency Graph") :
    for e in exps(ep) do :
      match(e) :
        (e:EDefGlobal) :
          dtable[n(e)] = scan(e)
        (e:EDefn) :
          dtable[n(e)] = scan(e)
        (e:EDefClosure) :
          dtable[n(e)] = scan(e)
        (e:EDefmulti) :
          dtable[n(e)] = scan(e)
        (e:EDefmethod) :
          dtable[n(e)] = scan(e, [multi(e)])
        (e:EDefStruct) :
          dtable[n(e)] = scan(e)
        (e:EExternFn) :
          dtable[n(e)] = scan(e)
        (e:EExtern) :
          dtable[n(e)] = scan(e)
        (e:EInit) :
          false
        (e:EDefType) :
          dtable[n(e)] = scan(e, children(e))
        (e:EDefObject) :
          dtable[n(e)] = scan(e, methods(e))
        (e:EDefTypeObject) :
          dtable[n(e)] = scan(e)

  ;Compute function and object dependencies
  val reload-set = to-intset(seq(n, exports(packageio(ep))))

  val dclosure = within time-ms!("Compute Bipartite Closure") :
    bipartite-closure $
      for entry in dtable seq? :
        if reload-set[key(entry)] : None()
        else : One(key(entry) => value(entry))
  clear(dtable)
  for entry in dclosure do :
    dtable[key(entry)] = value(entry)

  ;Return dependencies
  dtable

;============================================================
;==================== Specific Compilers ====================
;============================================================

defn compile (e:EDefn, global-table:GlobalTable, iotable:IOTable, ehier:EHier, progbuffer:ProgBuffer) :
  add(progbuffer, compile-efunction(true, n(e), false, func(e), global-table, iotable, ehier, progbuffer))

defn compile (e:EDefClosure, dtable:IntTable<Tuple<Int>>,
              global-table:GlobalTable, iotable:IOTable, ehier:EHier, progbuffer:ProgBuffer) :
  val f = compile-efunction(true, n(e), closure(e), func(e), global-table, iotable, ehier, progbuffer)
  add(progbuffer, sub-dependencies(f, dtable[n(e)]))

defn compile (e:EDefGlobal, global-table:GlobalTable, iotable:IOTable, progbuffer:ProgBuffer) :
  ;Compile the VMGlobal definition.
  val size = size(global-table, type(e))
  val offsets = offsets(global-table, type(e))
  val vmtypes = vmtypes(global-table, type(e))
  val roots = roots(global-table, type(e))
  add(progbuffer, VMGlobal(n(e), size, roots))

  ;Compile the VMDebugName entry.
  ;Retrieve the name of the imported/exported definitions.
  defn name? (n:Int) -> String|False :
    if key?(iotable,n) :
      val rec = iotable[n]
      to-string(name(id(rec)))
  match(name?(n(e))) :
    (str:String) : add(progbuffer, VMDebugName(n(e), str))
    (f:False) : false

defn parent-ids (t:EType|False) :
  val ids = Vector<Int>()
  match(t:EType) :
    let loop (t:EType = t) :
      match(t) :
        (t:EOf) : add(ids, n(t))
        (t:EAnd) : do*(loop, t)
  to-tuple(ids)

defn compile (e:EDefStruct, global-table:GlobalTable, iotable:IOTable, progbuffer:ProgBuffer) :
  val parents = parent-ids(parent(e))
  val class-name = class-name(n(e), parents, iotable)
  val base-size = size(global-table, n(e))
  val base-roots = roots(global-table, n(e))
  val base-root-names = root-names(global-table, n(e))
  val class = match(items(e)) :
    ;Object class
    (items:False) :
      VMLeafClass(n(e), class-name, [n(e)], parents, base-size, base-roots, base-root-names)
    ;Array class
    (items:EDefField) :
      val item-size = size(global-table, type(items))
      val item-roots = roots(global-table, type(items))
      val item-root-names = root-names(global-table, type(items))
      VMArrayClass(n(e), class-name, [n(e)], parents, base-size, item-size, base-roots, item-roots, base-root-names, item-root-names)
  add(progbuffer, class)

defn compile (compiler:Compiler, e:EInit) :
  val body = body(e)
  for l in localtypes(body) do :
    make-tvar-local(compiler, n(l), false)
  for l in locals(body) do :
    make-locals(compiler, n(l), type(l), debug-name(l))
  compile(compiler, ins(body))
  clear-locals(compiler)

defn compile-init (compiler:Compiler, iotable:IOTable, progbuffer:ProgBuffer) -> Int|False :
  if not empty?(compiler) :
    val id = uniqueid()
    emit(compiler, ReturnIns([false-obj(iotable)]))

    ;Debugname table is empty for now because inits don't have any arguments,
    ;and we haven't yet added the locals yet.
    val func = VMFunc([], defs(compiler), ins(compiler), VMDebugNameTable([]))

    ;Add to program buffer, and return its id.
    add(progbuffer, VMDefn(id, func))
    id

defn compile (e:EDefObject, dtable:IntTable<Tuple<Int>>, global-table:GlobalTable, iotable:IOTable, progbuffer:ProgBuffer) :
  val parents = parent-ids(parent(e))
  val class-name = class-name(n(e), parents, iotable)
  val nslots = ntargs(e) + nargs(e)
  val base-size = 8 * nslots
  val base-roots = to-tuple(0 to nslots)
  val base-root-names = to-tuple(seq({to-symbol("slot@%_" % [_ * 8])}, base-roots))
  add(progbuffer, VMLeafClass(n(e), class-name, dtable[n(e)], parents, base-size, base-roots, base-root-names))

defn compile (e:EDefType, progbuffer:ProgBuffer) :
  val parents = parent-ids(parent(e))
  add(progbuffer, VMAbstractClass(n(e), parents, children(e)))

defn compile (e:EExtern, progbuffer:ProgBuffer) :
  add(progbuffer, VMExtern(n(e), lbl(e)))

defn compile (e:EDefTypeObject, global-table:GlobalTable, iotable:IOTable, ehier:EHier, progbuffer:ProgBuffer) :
  defn call-util (compiler:Compiler, x:Local, fid:RecId, args:Tuple<VMImm>) :
    val arity = NumConst(length(args))
    val ys = to-tuple $ cat([false-obj(iotable), arity], args)
    val code = CodeId(n(iotable,fid))
    emit(compiler, CallIns([x], code, ys, false))

  ;Compile function for testing its argument
  defn test-function () :
    ;Create compiler
    val compiler = Compiler(global-table, iotable, ehier, progbuffer)

    ;Argument 0: type object
    ;Argument 1: arity
    ;Argument 2: argument to check
    val tobj = make-local(compiler, VMRef())
    val arg = make-local(compiler, VMRef())
    ;Make locals for free type variables
    val tvars = for i in 0 to nargs(e) map :
      val tvar = make-tvar-local(compiler, i, false)
      val offset = 8 + 8 + 8 * i
      emit(compiler, LoadIns(tvar, tobj, offset, n(iotable,CORE-TYPE-ID)))
      tvar
    ;Function to check whether argument is a type of type
    return-typeof(compiler, arg, type(e))

    ;Compile to function.
    ;  Debugname table is empty for autogenerated function that debugger won't
    ;  step inside of.
    VMFunc([tobj, VMLong(), arg], defs(compiler), ins(compiler), VMDebugNameTable([]))

  ;Compile function for returning itself as a printable tuple
  defn print-function () :
    ;Create compiler
    val compiler = Compiler(global-table, iotable, ehier, progbuffer)

    ;Argument 0: type object
    ;Argument 1: arity
    val tobj = make-local(compiler, VMRef())
    ;Make locals for free type variables
    val tvars = for i in 0 to nargs(e) map :
      val tvar = make-tvar-local(compiler, i, false)
      val offset = 8 + 8 + 8 * i
      emit(compiler, LoadIns(tvar, tobj, offset, n(iotable,CORE-TYPE-ID)))
      tvar
    ;Make tuple
    val tuple = make-local(compiler, VMRef())
    val parts = type-parts(type(e), iotable)
    val len = LongConst(length(parts))
    call-util(compiler, tuple, CORE-VOID-TUPLE-ID, [len])
    for (part in parts, i in 0 to false) do :
      val o = 8 + 8 * i
      val part-imm = match(part) :
        (part:String) :
          ;Put characters into data
          val chars = uniqueid()
          add(progbuffer, VMData(chars, string-bytes(part)))
          ;Create a Stanza String
          val s = make-local(compiler, VMRef())
          call-util(compiler, s, CORE-MAKE-STRING-ID, [DataId(chars)])
          ;Store string into tuple
          s
        (part:ETVar) :
          tvars[n(part)]
      val tuple-id = n(iotable,CORE-TUPLE-ID)
      emit(compiler, StoreIns(tuple, o, part-imm, tuple-id))
    ;Return created tuple
    emit(compiler, ReturnIns([tuple]))

    ;Compile to function.
    ;  Debugname table is empty for autogenerated function that debugger won't
    ;  step inside of.
    VMFunc([VMLong(), VMLong(), tobj], defs(compiler), ins(compiler), VMDebugNameTable([]))

  ;Add to top level
  val type-func = VMMultifn(1, [1 => print-function()], test-function())
  add(progbuffer, VMDefn(n(e), type-func))

defn compile (e:EDefmulti, global-table:GlobalTable, iotable:IOTable, ehier:EHier, progbuffer:ProgBuffer) :
  val compiler = Compiler(global-table, iotable, ehier, progbuffer)

  ;Generate instructions
  val targs = for v in targs(e) map :
    make-tvar-local(compiler, n(v), debug-name(v))
  val args = for a in args(e) map :
    make-local(compiler, n(a), VMRef(), debug-name(a))
  val arity = NumConst(length(/args(e)))
  val ys = to-tuple(cat([false-obj(iotable), arity], targs))
  method-dispatch(compiler, n(e), ys, args, stack-trace-info(e))

  ;Compile to function
  val all-args = to-tuple $ cat-all $ [[VMLong(), VMLong()], targs, args]
  val func = VMFunc(all-args, defs(compiler), ins(compiler), debug-name-table(compiler))

  ;Add to top level
  add(progbuffer, VMDefn(n(e), func))

defn compile (e:EDefmethod, global-table:GlobalTable, iotable:IOTable, ehier:EHier, progbuffer:ProgBuffer) :
  add(progbuffer, compile-efunction(true, n(e), false, func(e), global-table, iotable, ehier, progbuffer))
  val types = map(to-typeset{type(_)}, args(func(e)))
  val instance-method? = instance-method?(global-table, n(e))
  add(progbuffer, VMMethod(instance-method?, multi(e), types, n(e)))

defn compile (e:EExternFn, global-table:GlobalTable, iotable:IOTable, ehier:EHier, progbuffer:ProgBuffer) :
  val f = func(e)
  add(progbuffer, compile-efunction(false, n(e), false, f, global-table, iotable, ehier, progbuffer))
  add(progbuffer, VMExternDefn(lbl(e), n(e), map(to-vm-type{type(_)},args(f)), to-vm-type(ret(f))))

;- include-closure-and-arity-args? controls whether the calling convention includes
;  the closure and the arity as the first arguments. If true, then they are included
;  as the first arguments, otherwise they are not included. Normal Stanza functions
;  include them as part of the calling convention. Extern functions do not.
defn compile-efunction (include-closure-and-arity-args?:True|False,
                        id:Int, closure:Int|False, f:EFunction,
                        global-table:GlobalTable, iotable:IOTable, ehier:EHier, progbuffer:ProgBuffer) -> VMDefn :
  val func = match(f) :
    (f:EFn) :
      compile-efn(include-closure-and-arity-args?, closure, f, global-table, iotable, ehier, progbuffer)
    (f:EMultifn) :
      val funcs* = for f in funcs(f) map :
        val arity = length(args(f))
        arity => compile-efn(include-closure-and-arity-args?, closure, f, global-table, iotable, ehier, progbuffer)
      val info? = stack-trace-info(funcs(f)[0]) when not empty?(funcs(f))
      VMMultifn(1, funcs*, wrong-arity-fn(iotable, info?))
  VMDefn(id, func)

;- include-closure-and-arity-args? controls whether the calling convention includes
;  the closure and the arity as the first arguments. If true, then they are included
;  as the first arguments, otherwise they are not included. Normal Stanza functions
;  include them as part of the calling convention. Extern functions do not.
defn compile-efn (include-closure-and-arity-args?:True|False,
                  closure:Int|False, f:EFn,
                  global-table:GlobalTable, iotable:IOTable, ehier:EHier, progbuffer:ProgBuffer) -> VMFunc :
  ;Create a new compiler to compile the instructions for the given
  ;function.
  val compiler = Compiler(global-table, iotable, ehier, progbuffer)

  ;Make local for closure
  val closure-local =
    match(closure:Int) : make-local(compiler, closure, VMRef(), false)
    else : VMLong()
  val arity-local =
    match(closure:Int) : make-local(compiler, VMLong())
    else : VMLong()

  ;Make locals for arguments
  val targ-locals = for t in targs(f) map :
    make-tvar-local(compiler, n(t), debug-name(t))
  val arg-locals = for a in args(f) map-cat :
    make-locals(compiler, n(a), type(a), debug-name(a))

  ;Make locals for locals
  for l in localtypes(body(f)) do :
    make-tvar-local(compiler, n(l), false)
  for l in locals(body(f)) do :
    make-locals(compiler, n(l), type(l), debug-name(l))

  ;Guard the arity if it's a closure
  match(arity-local:Local) :
    val arity-err = CodeId(n(iotable,CORE-ARITY-ERROR-ID))
    val num-args = NumConst(to-long(length(args(f))))
    val pass-lbl = make-label(compiler)
    val fail-lbl = make-label(compiler)
    emit(compiler, Branch2Ins(pass-lbl, fail-lbl, EqOp(), arity-local, num-args))
    emit(compiler, LabelIns(fail-lbl))
    emit(compiler, CallIns([], arity-err, [false-obj(iotable), NumConst(1L), arity-local], stack-trace-info(f)))
    emit(compiler, UnreachableIns())
    emit(compiler, LabelIns(pass-lbl))

  ;Compile instructions
  compile(compiler, ins(body(f)))

  ;Return the compiled function
  val closure-args = [closure-local, arity-local] when include-closure-and-arity-args? else []
  val args = to-tuple $ cat-all $ [closure-args, targ-locals, arg-locals]
  VMFunc(args, defs(compiler), ins(compiler), debug-name-table(compiler))

defn wrong-arity-fn (iotable:IOTable, info:StackTraceInfo|False) :
  val arity-err = CodeId(n(iotable,CORE-ARITY-ERROR-ID))
  val num-args = NumConst(1)
  val arity-def = VMDef(0, VMLong(), 0)
  val arity = Local(id(arity-def))
  val ins = [
    CallIns([], arity-err, [false-obj(iotable), num-args, arity], info)
    UnreachableIns()]
  VMFunc([VMLong(), arity], [arity-def], ins, VMDebugNameTable([]))

;============================================================
;================= Human-Readable Names =====================
;============================================================

;Compute the human-readable name for the given class.
;If there is no explicit name given, then use the parent ids to construct
;a name for the class.
defn class-name (n:Int, parents:Tuple<Int>, iotable:IOTable) -> String :
  ;If the class has an entry in the IOTable then use the name stored in there.
  if key?(iotable, n) :
    val rec = iotable[n]
    to-string(name(id(rec)))
  else :
    ;Sanity check.
    if empty?(parents) :
      fatal("Cannot compute class name of class %_. No entry in IOTable and no parents." % [n])
    ;Get parent names.
    val parent-names = seq(class-name{_, [], iotable}, parents)
    ;Return parent parents joined with '&'.
    string-join(parent-names, "&")

;============================================================
;========== Compilation of Debug Information Table ==========
;============================================================

;Construct an individual VMDebugInfo for each exported entry in the
;package. Push the entries to the given ProgBuffer.
defn compile-debug-info (buffer:ProgBuffer, packageio:PackageIO) -> False :
  for e in exports(packageio) do :
    val entry = VMDebugInfo(n(e), name-string(rec(e)), info(e))
    add(buffer, entry)

;Convert the given record into a human readable name.
defn name-string (r:Rec) -> String :
  ;Convert RecId to human readable name.
  defn id-to-name (id:RecId) :
    match(id) :
      (id:ValId) : "%_/%_" % [package(id), name(id)]
      (id:TypeId) : "%_/%_" % [package(id), name(id)]
      (id:FnId) : "%_/%_" % [package(id), name(id)]

  ;Convert Rec to human readable type.
  defn rec-to-type (r:Rec) :
    match(r) :
      (r:ValRec) : "val"
      (r:FnRec) : "defn"
      (r:MultiRec) : "defmulti"
      (r:ExternFnRec) : "externfn"
      (r:ExternRec) : "extern"
      (r:StructRec) : "lostanza deftype"
      (r:TypeRec) : "deftype"
      (r:TypeDecl) : "deftype"

  ;Launch!
  string-join([rec-to-type(r), " ", id-to-name(id(r))])

;============================================================
;=================== Prog Buffer ============================
;============================================================

deftype ProgBuffer
defmulti add (b:ProgBuffer, e:VMGlobal) -> False
defmulti add (b:ProgBuffer, e:VMData) -> False
defmulti add (b:ProgBuffer, e:VMConst) -> False
defmulti add (b:ProgBuffer, e:VMClass) -> False
defmulti add (b:ProgBuffer, e:VMDefn) -> False
defmulti add (b:ProgBuffer, e:VMExtern) -> False
defmulti add (b:ProgBuffer, e:VMExternDefn) -> False
defmulti add (b:ProgBuffer, e:VMMethod) -> False
defmulti add (b:ProgBuffer, e:VMDebugInfo) -> False
defmulti add (b:ProgBuffer, e:SafepointEntry) -> SafepointIns
defmulti add (b:ProgBuffer, e:VMDebugName) -> False
defmulti to-vmpackage (b:ProgBuffer, io:PackageIO, init:Int|False) -> VMPackage

defn ProgBuffer () :
  val globals = Vector<VMGlobal>()
  val datas = Vector<VMData>()
  val consts = Vector<VMConst>()
  val classes = Vector<VMClass>()
  val funcs = Vector<VMDefn>()
  val externs = Vector<VMExtern>()
  val extern-defns = Vector<VMExternDefn>()
  val methods = Vector<VMMethod>()
  val debug = Vector<VMDebugInfo>()
  val debugnames = Vector<VMDebugName>()
  val sptable = VMSafepointTableCreator(uniqueid)
  new ProgBuffer :
    defmethod add (this, e:VMGlobal) : add(globals, e)
    defmethod add (this, e:VMData) : add(datas, e)
    defmethod add (this, e:VMConst) : add(consts, e)
    defmethod add (this, e:VMClass) : add(classes, e)
    defmethod add (this, e:VMDefn) : add(funcs, e)
    defmethod add (this, e:VMExtern) : add(externs, e)
    defmethod add (this, e:VMExternDefn) : add(extern-defns, e)
    defmethod add (this, e:VMMethod) : add(methods, e)
    defmethod add (this, e:VMDebugInfo) : add(debug, e)
    defmethod add (this, e:SafepointEntry) : add(sptable, e)
    defmethod add (this, e:VMDebugName) : add(debugnames, e)
    defmethod to-vmpackage (this, io:PackageIO, init:Int|False) :
      VMPackage(io, init,
                to-tuple(globals),
                to-tuple(datas),
                to-tuple(consts),
                to-tuple(classes),
                to-tuple(funcs),
                to-tuple(methods),
                to-tuple(externs),
                to-tuple(extern-defns),
                VMDebugNameTable(to-tuple(debugnames)),
                VMDebugInfoTable(to-tuple(debug)),
                compile(sptable))

;============================================================
;================= Instruction Compiler =====================
;============================================================

;------------------------------------------------------------
;---------------------- API----------------------------------
;------------------------------------------------------------

;Utility for compiling instructions from EL to VM instructions.
deftype Compiler

;Create a temporary with the given type.
defmulti make-local (c:Compiler, t:VMType) -> Local

;Create a local with the given type and id. Type must
;be a single-word value.
defmulti make-local (c:Compiler, x:Int, t:VMType, debug-name:String|False) -> Local

;Create locals representing the given type.
defmulti make-locals (c:Compiler, x:Int, t:EType, debug-name:String|False) -> Tuple<Local>

;Create a fresh type variable local.
defmulti make-tvar-local (c:Compiler, x:Int, debug-name:String|False) -> Local

;Create a fresh label.
defmulti make-label (c:Compiler) -> Int

;Clear the locals tables such that we cannot lookup
;the local given the variable id. Used during compilation
;of EInit: All the inits are compiled together into a single
;function, but one init cannot reference the local in another
;init.
;Not strictly necessary, but prevents us from accidentally
;referencing locals that we shouldn't.
defmulti clear-locals (c:Compiler) -> False

;Compile the given instructions to VM-IR.
defmulti compile (c:Compiler, ins:Seqable<EIns>) -> False

;Bypass the compile function and directly emit low-level VM-IR.
defmulti emit (c:Compiler, i:VMIns) -> False

;Generate code: If x is t, then return 1L, otherwise return 0L.
;Used during compilation of type objects.
defmulti return-typeof (c:Compiler, x:VMImm, t:EType) -> False

;Generate code: Perform dispatch for given multi using given arguments.
defmulti method-dispatch (c:Compiler, multi:Int, ys:Tuple<VMImm>, zs:Tuple<VMImm>, info:StackTraceInfo|False) -> False

;Return true if no VM instructions has been generated yet.
defmulti empty? (c:Compiler) -> True|False

;Retrieve all the definitions created using make-local.
defmulti defs (c:Compiler) -> Tuple<VMDef>

;Retrieve all the compiled and emitted VM instructions.
defmulti ins (c:Compiler) -> Tuple<VMIns>

;Return the debug name table holding the debugger names
;of all generated locals.
defmulti debug-name-table (c:Compiler) -> VMDebugNameTable

;------------------------------------------------------------
;-------------------- Implementation ------------------------
;------------------------------------------------------------

defn Compiler (gt:GlobalTable,
               iotable:IOTable,
               ehier:EHier,
               progbuffer:ProgBuffer) :

  ;---------------------------------------------------------
  ;--------------- VMDef List ------------------------------
  ;---------------------------------------------------------
  ;Accumulate all generated locals.
  val defs = Vector<VMDef>()

  ;Create a local corresponding to the given type.
  defn makedef (t:VMType) -> Local :
    val n = length(defs)
    add(defs, VMDef(n, t, 0))
    Local(n)

  ;Create multiple locals corresponding to the given types.
  defn makedefs (ts:Tuple<VMType>) -> Tuple<Local> :
    map(makedef, ts)

  ;---------------------------------------------------------
  ;--------------- DebugName List --------------------------
  ;---------------------------------------------------------
  ;Accumulate the human-readable debugger names for
  ;locals.
  ;[TODO] Note that for EL variables that are stored
  ;in multiple slots, we will need more sophisticated
  ;handling for the debugger to know where to find its fields.
  val debug-names = Vector<VMDebugName>()

  ;If a name is given for the local, then record it.
  defn record-debug-name? (l:Local, name:String|False) :
    match(name:String) :
      add(debug-names, VMDebugName(index(l),name))

  ;---------------------------------------------------------
  ;--------------- Instruction Buffer ----------------------
  ;---------------------------------------------------------
  ;Stores all generated VM instructions.
  val insbuffer = Vector<VMIns>()

  ;Add instruction to buffer.
  defn emit (c:VMIns) : add(insbuffer, c)

  ;Add top-level data/const definition to program buffer.
  defn emit (c:VMData|VMConst) : add(progbuffer, c)

  ;---------------------------------------------------------
  ;-------------------- Locals Table -----------------------
  ;---------------------------------------------------------
  ;Given the EL-IR id of a variable, retrieve the generated
  ;local corresponding to it.
  val locals-table = IntTable<Tuple<Local>>()
  val tlocals-table = IntTable<Local>()

  ;Retrieve the set of Locals for a given variable location.
  defn locals (x:EVarLoc) -> Tuple<Local> :
    locals-table[n(x)]

  ;Retrieve the Local for a given variable location.
  ;Mandates that the variable corresponds to a single local.
  defn local (x:EVarLoc) -> Local :
    val xs = locals(x)
    fatal("Incorrect length") when length(xs) != 1
    xs[0]

  ;Retrieve the local for a given type variable.
  defn local (x:ETVarLoc) -> Local :
    tlocals-table[n(x)]

  ;---------------------------------------------------------
  ;-------------------- Labels Table -----------------------
  ;---------------------------------------------------------
  ;Given the EL-IR id of a label, store the corresponding
  ;VM label.
  val labels-table = IntTable<Int>()

  ;Create a unique label.
  val label-counter = to-seq(0 to false)
  defn make-label () -> Int :
    next(label-counter)

  ;Retrieve the VM label corresponding to the given EL label.
  defn get-label (n:Int) -> Int :
    if not key?(labels-table, n) :
      labels-table[n] = make-label()
    labels-table[n]

  ;---------------------------------------------------------
  ;---------------------------------------------------------
  ;---------------------------------------------------------
  ;Put a compiled value into a compiled location
  defn put (x:EVarLoc, y:CVal) :
    val xs = locals(x)
    match(y) :
      (y:CImm) :
        fatal("Mismatch") when length(xs) != length(imms(y))
        for (x in xs, y in imms(y)) do :
          emit(SetIns(x,y))
      (y:CMem) :
        fatal("Mismatch") when length(xs) != length(offsets(y))
        val a = address(y)
        for (x in xs, o in offsets(y)) do :
          emit(LoadIns(x, a, o))

  ;Retrieve the immediate from a CVal
  defn imms! (x:CVal) :
    match(x) :
      (x:CImm) :
        imms(x)
      (x:CMem) :
        val tmp = makedefs(types(x))
        val a = address(x)
        for (t in tmp, o in offsets(x)) do :
          emit(LoadIns(t, a, o))
        tmp
  defn imm! (x:CVal) :
    val xs = imms!(x)
    fatal("Not unary") when length(xs) != 1
    xs[0]
  defn imms! (x:EImm) : imms!(cval(x))
  defn imm! (x:EImm) : imm!(cval(x))
  defn imms! (x:EType) : [imm!(x)]
  defn imm! (x:EType) : tlocals-table[n(x as ETVar)]

  ;Code generation utilities
  defn call-error (f:Int, args:Tuple<VMImm>, info:StackTraceInfo|False) :
    val arity = NumConst(length(args))
    val ys = to-tuple $ cat([false-obj(iotable), arity], args)
    emit(CallIns([], CodeId(f), ys, info))
    emit(UnreachableIns())

  ;Helper: Call a utility function.
  ;- f: The identifier of the function to call.
  ;- args: The arguments to call it with.
  ;- x: The local to store the result in.
  ;- trace-entry: The stack trace entry corresponding to this call.
  defn call-util (x:Local, f:Int, args:Tuple<VMImm>, info:StackTraceInfo|False) :
    val arity = NumConst(length(args))
    val ys = to-tuple $ cat([false-obj(iotable), arity], args)
    emit(CallIns([x], CodeId(f), ys, info))

  ;Return true if the given type identifier is a
  ;subtype of Unique
  defn unique? (n:Int) :
    val unique-n = /n(iotable,CORE-UNIQUE-ID)
    subtype?(ehier, EOf(n), EOf(unique-n))

  ;Compile an immediate to a location
  defn cval (x:EImm) -> CVal :
    match(x) :
      (x:EVar) :
        match(get?(locals-table, n(x))) :
          (v:Tuple<Local>) :
            CImm(v)
          (_:False) :
            val a = address(gt,n(x))
            val t = type(gt,n(x))
            val ts = vmtypes(gt,t)
            val os = offsets(gt,t)
            CMem(a, ts, os)
      (x:ELSLiteral) :
        match(value(x)) :
          (v:String) :
            val did = uniqueid()
            emit(VMData(did, string-bytes(v)))
            CImm([DataId(did)])
          (v:Char|Byte|Int|Long|Float|Double) :
            CImm([NumConst(v)])
          (v:True) :
            CImm([true-obj(iotable)])
          (v:False) :
            CImm([false-obj(iotable)])
      (x:ELiteral) :
        match(value(x)) :
          (v:Char|Byte|Int|Float) :
            val tmp = makedef(VMRef())
            val type = n{iotable, _} $ match(v) :
              (v:Char) : CORE-CHAR-ID
              (v:Byte) : CORE-BYTE-ID
              (v:Int) : CORE-INT-ID
              (v:Float) : CORE-FLOAT-ID
            emit(Op1Ins(tmp, TagOp(type), NumConst(v)))
            CImm([tmp])
          (v:True) :
            CImm([true-obj(iotable)])
          (v:False) :
            CImm([false-obj(iotable)])
          (v:List|String|Symbol|Long|Double) :
            val cid = uniqueid()
            emit(VMConst(cid, v))
            CImm([ConstId(cid)])
      (x:EConstClosure) :
        val cid = uniqueid()
        emit(VMConst(cid, VMClosure(CodeId(n(x)))))
        CImm([ConstId(cid)])
      (x:EConstType) :
        val cid = uniqueid()
        emit(VMConst(cid, VMTypeObject(CodeId(n(x)))))
        CImm([ConstId(cid)])
      (x:ESizeof) :
        val sz = size(gt,type(x))
        CImm([NumConst(to-long(sz))])
      (x:ETagof) :
        CImm([Tag(n(x))])

  ;Compile a location to a CVal
  defn cloc (x:ELoc) -> CLoc :
    match(x) :
      (x:EVarLoc) :
        if key?(locals-table, n(x)) :
          LocalLoc(n(x), 0)
        else :
          val v = address(gt,n(x))
          PtrLoc(CImm([v]), false, 0)
      (x:EDeref) :
        PtrLoc(cval(y(x)), false, 0)
      (x:EDeptr) :
        PtrLoc(cval(y(x)), false, 0)
      (x:EField) :
        match(loc(x)) :
          (l:EDeref) :
            switch {n(x) == n(iotable, _)} :
              CORE-CHAR-ID : tagged-primitive-field(y(l))
              CORE-BYTE-ID : tagged-primitive-field(y(l))
              CORE-INT-ID : tagged-primitive-field(y(l))
              CORE-FLOAT-ID : tagged-primitive-field(y(l))
              else : standard-field()
          (l) : standard-field()
        where :
          defn tagged-primitive-field (y:EImm) :
            TaggedPrimLoc(cval(y), n(x))
          defn standard-field () :
            match(cloc(loc(x))) :
              (l:LocalLoc) : field-of-local(l)
              (l:PtrLoc) : field-of-pointer(l)
          defn field-of-local (l:LocalLoc) :
            val fi = field-index(gt, n(x), index(x))
            LocalLoc(n(l), index(l) + fi)
          defn field-of-pointer (l:PtrLoc) :
            val fo = field-offset(gt, n(x), index(x))
            PtrLoc(base(l), offset(l), const(l) + fo)
      (x:ESlot) :
        val size = size(gt, type(x))
        val base-loc = cloc(loc(x)) as PtrLoc
        val offset* = match(offset(base-loc)) :
          (o:CVal) :
            if size == 1 :
              val tmp = makedef(VMLong())
              emit(Op2Ins(tmp, AddOp(), imm!(o), imm!(index(x))))
              CImm([tmp])
            else :
              val tmp = makedef(VMLong())
              emit(Op2Ins(tmp, MulOp(), imm!(index(x)), NumConst(size)))
              emit(Op2Ins(tmp, AddOp(), imm!(o), tmp))
              CImm([tmp])
          (_:False) :
            if size == 1 :
              cval(index(x))
            else :
              val tmp = makedef(VMLong())
              emit(Op2Ins(tmp, MulOp(), imm!(index(x)), NumConst(size)))
              CImm([tmp])
        PtrLoc(base(base-loc), offset*, const(base-loc))

  ;If x typeof t return 1 otherwise return 0
  defn return-ctypeof (x:VMImm, t:EType):
    match(t) :
      (t:ETop|EBot) :
        val v = 1 when t is ETop else 0
        emit(ReturnIns([LongConst(v)]))
      (t:ETVar) :
        val t* = imm!(t)
        emit(TCallClosureIns(t*, [t*, NumConst(0), x]))
      (t:EOf) :
        val ret = makedef(VMLong())
        emit(Op1Ins(ret, InstanceofOp(SingleType(n(t))), x))
        emit(ReturnIns([ret]))
      (t:EAnd) :
        val pass = make-label()
        val fail = make-label()
        ctypeof(pass, fail, x, a(t))
        emit(LabelIns(pass))
        return-ctypeof(x, b(t))
        emit(LabelIns(fail))
        emit(ReturnIns([LongConst(0)]))
      (t:EOr) :
        val pass = make-label()
        val fail = make-label()
        ctypeof(pass, fail, x, a(t))
        emit(LabelIns(pass))
        emit(ReturnIns([LongConst(1)]))
        emit(LabelIns(fail))
        return-ctypeof(x, b(t))

  ;If x typeof t goto pass, otherwise goto fail
  defn ctypeof (pass:Int, fail:Int, x:VMImm, t:EType) :
    match(t) :
      (t:ETVar) :
        val pred = makedef(VMLong())
        val t* = imm!(t)
        emit(CallClosureIns([pred], t*, [t*, NumConst(0), x], false))
        emit(Branch1Ins(pass, fail, false, pred))
      (t:EOf) :
        emit(Branch1Ins(pass, fail, InstanceofOp(SingleType(n(t))), x))
      (t:EAnd) :
        val next = make-label()
        ctypeof(next, fail, x, a(t))
        emit(LabelIns(next))
        ctypeof(pass, fail, x, b(t))
      (t:EOr) :
        val next = make-label()
        ctypeof(pass, next, x, a(t))
        emit(LabelIns(next))
        ctypeof(pass, fail, x, b(t))

  ;Allocate a small tuple in x
  defn ctuple (x:Local, ys:Tuple<VMImm>, info:StackTraceInfo|False) :
    val len = length(ys)
    val size = NumConst(8 + 8 * len)
    val tuple-id = n(iotable, CORE-TUPLE-ID)
    emit(AllocIns([x], [tuple-id], [size], info))
    emit(StoreIns(x, 0, LongConst(len), tuple-id))
    for (y in ys, o in 8 to false by 8) do :
      emit(StoreIns(x, o, y, tuple-id))

  ;Method dispatch
  defn method-dispatch (multi:Int, ys:Tuple<VMImm>, zs:Tuple<VMImm>, info:StackTraceInfo|False) :
    ;Add name of multi to program
    val multi-name-id = uniqueid()
    val multi-name = string-join([package(e) "/" name(e)]) where :
      val e = id(iotable[multi])
    add(progbuffer, VMConst(multi-name-id, multi-name))

    ;Construct tuple of arguments
    defn arg-tuple () :
      val tuple = makedef(VMRef())
      ctuple(tuple, zs, info)
      tuple

    val default = make-label()
    val amb = make-label()
    emit(MethodDispatchIns(multi, ys, zs, default, amb))
    emit(LabelIns(default))
    call-error(n(iotable, CORE-NO-METHOD-ERROR-ID), [ConstId(multi-name-id), arg-tuple()], info)
    emit(LabelIns(amb))
    call-error(n(iotable, CORE-AMB-METHOD-ERROR-ID), [ConstId(multi-name-id), arg-tuple()], info)

  ;Compile instructions
  defn compile (ins:EIns) :
    match(ins) :
      (ins:EDef) :
        match(y(ins)) :
          ;Initialize local to tagged primitive
          (y:ELiteral) :
            match(value(y)) :
              (v:Char|Byte|Int|Float) :
                val x = local(x(ins))
                val type = n{iotable, _} $ match(v) :
                  (v:Char) : CORE-CHAR-ID
                  (v:Byte) : CORE-BYTE-ID
                  (v:Int) : CORE-INT-ID
                  (v:Float) : CORE-FLOAT-ID
                emit(Op1Ins(x, TagOp(type), NumConst(v)))
              (v) :
                put(x(ins), cval(y))
          ;Initialize local to given value
          (y:EImm) :
            put(x(ins), cval(y))
          ;Initialize local to fresh value
          (y:False) :
            for x in locals(x(ins)) do :
              val t = type(defs[index(x)])
              val v = match(t) :
                (t:VMByte) : NumConst(0Y)
                (t:VMInt) : NumConst(0)
                (t:VMLong) : NumConst(0L)
                (t:VMFloat) : NumConst(0.0f)
                (t:VMDouble) : NumConst(0.0)
                (t:VMRef) : VoidMarker()
              emit(SetIns(x, v))
      (ins:ETuple) :
        val x = local(x(ins))
        val ys = map(imm!, ys(ins))
        ctuple(x, ys, stack-trace-info(ins))
      (ins:EVoidTuple) :
        val len = LongConst(length(ins))
        call-util(local(x(ins)), n(iotable,CORE-VOID-TUPLE-ID), [len], stack-trace-info(ins))
      (ins:ETupleGet) :
        val x = local(x(ins))
        val o = 8 + 8 * index(ins)
        emit(LoadIns(x, imm!(y(ins)), o, n(iotable,CORE-TUPLE-ID)))
      (ins:ETupleSet) :
        val y = imm!(y(ins))
        val o = 8 + 8 * index(ins)
        val z = imm!(z(ins))
        emit(StoreWithBarrierIns(y, o, z, n(iotable,CORE-TUPLE-ID)))
      (ins:ECheckLength) :
        val pass-lbl = make-label()
        val fail-lbl = make-label()
        val len = makedef(VMLong())
        val expected-len = LongConst(length(ins))
        emit(LoadIns(len, imm!(y(ins)), 0, n(iotable,CORE-TUPLE-ID)))
        emit(Branch2Ins(pass-lbl, fail-lbl, EqOp(), len, expected-len))
        emit(LabelIns(fail-lbl))
        call-error(n(iotable,CORE-TUPLE-LENGTH-ERROR-ID), [len, expected-len], stack-trace-info(ins))
        emit(LabelIns(pass-lbl))
      (ins:EEnd) :
        call-error(n(iotable,CORE-INVALID-RETURN-ID), [], stack-trace-info(ins))
      (ins:EObject) :
        switch {n(ins) == n(iotable, _)} :
          CORE-BYTE-ID : tagged-prim()
          CORE-CHAR-ID : tagged-prim()
          CORE-INT-ID : tagged-prim()
          CORE-FLOAT-ID : tagged-prim()
          else :
            if empty?(ys(ins)) and not unique?(n(ins)) : marker-object()
            else : heap-object()
        where :
          defn tagged-prim () :
            val x = local(x(ins))
            val y = imm!(ys(ins)[0])
            emit(Op1Ins(x, TagOp(n(ins)), y))
          defn marker-object () :
            val x = local(x(ins))
            emit(SetIns(x, Marker(n(ins))))
          defn heap-object () :
            val obj-size = size(gt, n(ins))
            ;Pad size up to nearest 8 bytes for VM
            val padded-size = (obj-size + 7) & -8
            val offsets = offsets(gt, n(ins))
            val x = local(x(ins))
            emit(AllocIns([x], [n(ins)], [NumConst(padded-size)], stack-trace-info(ins)))
            for (o in offsets, y in ys(ins)) do :
              ;No write barrier needed because of object construction.
              emit(StoreIns(x, o, imm!(y), n(ins)))
      (ins:ENewObject) :
        val ntargs = length(targs(ins))
        val nargs = length(ys(ins))
        val nslots = ntargs + nargs
        let :
          if nslots == 0 and not unique?(n(ins)) : marker-object()
          else : heap-object()
        where :
          defn marker-object () :
            val x = local(x(ins))
            emit(SetIns(x, Marker(n(ins))))
          defn heap-object () :
            val x = local(x(ins))
            emit(AllocIns([x], [n(ins)], [NumConst(8 * nslots)], stack-trace-info(ins)))
            for (a in cat(targs(ins), ys(ins)), o in 0 to false by 8) do :
              ;No write barrier needed because of object construction.
              emit(StoreIns(x, o, imm!(a), n(ins)))
      (ins:EArray) :
        ;Struct properties
        val base-size = size(gt,n(ins))
        val item-size = item-size(gt,n(ins))
        ;Evaluate arguments
        val ys = map-cat(imms!, ys(ins))
        val len = ys[0]
        ;Compute size
        val size = makedef(VMLong())
        if item-size == 1 :
          emit(Op2Ins(size, AddOp(), len, LongConst(base-size + 7)))
          emit(Op2Ins(size, AndOp(), size, LongConst(-8)))
        else :
          emit(Op2Ins(size, MulOp(), len, LongConst(item-size)))
          if item-size % 8 == 0 :
            emit(Op2Ins(size, AddOp(), size, LongConst(base-size)))
          else :
            emit(Op2Ins(size, AddOp(), size, LongConst(base-size + 7)))
            emit(Op2Ins(size, AndOp(), size, LongConst(-8)))
        ;Allocate array
        val x = local(x(ins))
        emit(AllocIns([x], [n(ins)], [size], stack-trace-info(ins)))
        for (y in ys, o in base+item-offsets(gt,n(ins))) do :
          ;No write barrier needed because of array construction.
          emit(StoreIns(x, o, y, n(ins)))
      (ins:EStruct) :
        val xs = to-seq(locals(x(ins)))
        for y in ys(ins) do :
          match(cval(y)) :
            (y:CImm) :
              for y in imms(y) do :
                emit(SetIns(next(xs), y))
            (y:CMem) :
              val a = address(y)
              for o in offsets(y) do :
                emit(LoadIns(next(xs), a, o))
      (ins:EPtr) :
        val x = local(x(ins))
        val ptr = cloc(loc(ins)) as PtrLoc
        if base(loc(ins)) is EDeref :
          emit(Op1Ins(x, DerefOp(), imm!(base(ptr))))
          if offset(ptr) is CVal :
            emit(Op2Ins(x, AddOp(), x, imm!(offset(ptr) as CVal)))
          if const(ptr) > 0 :
            emit(Op2Ins(x, AddOp(), x, LongConst(const(ptr))))
        else :
          match(offset(ptr) is CVal, const(ptr) > 0) :
            (r1:True, r2:True) :
              emit(Op2Ins(x, AddOp(), imm!(base(ptr)), imm!(offset(ptr) as CVal)))
              emit(Op2Ins(x, AddOp(), x, LongConst(const(ptr))))
            (r1:True, r2:False) :
              emit(Op2Ins(x, AddOp(), imm!(base(ptr)), imm!(offset(ptr) as CVal)))
            (r1:False, r2:True) :
              emit(Op2Ins(x, AddOp(), imm!(base(ptr)), LongConst(const(ptr))))
            (r1:False, r2:False) :
              put(/x(ins), base(ptr))
      (ins:ELoad) :
        match(cloc(loc(ins))) :
          (l:TaggedPrimLoc) :
            val x = local(x(ins))
            emit(Op1Ins(x, DetagOp(n(l)), imm!(prim(l))))
          (l:LocalLoc) :
            val ys = locals-table[n(l)]
            val len = length(gt,xtype(ins))
            for (x in locals(x(ins)), i in 0 to len) do :
              emit(SetIns(x, ys[index(l) + i]))
          (l:PtrLoc) :
            val base = imm!(base(l))
            val base-offset = match(offset(l)) :
              (o:CVal) : imm!(o)
              (o:False) : false
            for (x in locals(x(ins)), o in offsets(gt,xtype(ins))) do :
              emit(LoadIns(x, base, base-offset, const(l) + o, class(loc(ins))))
      (ins:EStore) :
        ;Returns true if the given location 'l' represents a heap object.
        ;This is necessary to know whether we need a write barrier when assigning
        ;into it.
        defn heap-object-location? (l:ELoc) -> True|False :
          match(l) :
            (l:EVarLoc) : false
            (l:EDeref) : true
            (l:EDeptr) : false
            (l:EField) : heap-object-location?(loc(l))
            (l:ESlot) : heap-object-location?(loc(l))

        match(cloc(loc(ins)), cval(y(ins))) :
          (l:LocalLoc, y:CImm) :
            val xs = locals-table[n(l)]
            for (y in imms(y), i in 0 to false) do :
              emit(SetIns(xs[index(l) + i], y))
          (l:LocalLoc, y:CMem) :
            val xs = locals-table[n(l)]
            val a = address(y)
            for (o in offsets(y), i in 0 to false) do :
              emit(LoadIns(xs[index(l) + i], a, o))
          (l:PtrLoc, y) :
            val base = imm!(base(l))
            val base-offset = match(offset(l)) :
              (o:CVal) : imm!(o)
              (o:False) : false
            match(ytype(ins)) :
              (ytype:LoEType) :
                ;LoStanza objects can be multiple words (if it is a struct).
                for (o in offsets(gt,ytype), y in imms!(y)) do :
                  emit(StoreIns(base, base-offset, const(l) + o, y, class(loc(ins))))
              (ytype:HiEType) :
                ;Storing a HiStanza object.
                ;Guaranteed to be a single word.
                ;[TODO] If storing objects that fit in a single word, then no write barrier needed.
                val class = class(loc(ins))
                if heap-object-location?(loc(ins)) :
                  ;Storing into a heap object location.
                  emit(StoreWithBarrierIns(base, base-offset, const(l), imm!(y), class as Int))
                else :
                  ;Storing into a non-heap object location.
                  emit(StoreIns(base, base-offset, const(l), imm!(y), class))
      (ins:ELabel) :
        val lbl = get-label(n(ins))
        emit(LabelIns(lbl))
      (ins:ECall|ETCall) :
        val info? = match(ins:ECall) :
          stack-trace-info(ins)
        val xs = match(ins) :
          (ins:ECall) :
            match(x(ins)) :
              (x:EVarLoc) : locals(x)
              (x:False) : []
          (ins:ETCall) : []
        val tail? = ins is ETCall
        ;Categorize the call according to the function and call type
        match(f(ins), calltype(ins)) :
          (f, ct:CallPtr) :
            call-pointer(xs, f, ys(ins), tail?)
          (f:ECurry, ct:CallStanza) :
            if function?(gt, n(x(f))) : call-code(n(x(f)), xs, targs(f), ys(ins), tail?)
            else : call-closure(xs, x(f), targs(f), ys(ins), tail?)
          (f:EVar, ct:CallStanza) :
            if function?(gt, n(f)) : call-code(n(f), xs, [], ys(ins), tail?)
            else : call-closure(xs, f, [], ys(ins), tail?)
          (f, ct:CallStanza) :
            call-closure(xs, f, [], ys(ins), tail?)
          (f:EVar, ct:CallC) :
            if function?(gt, n(f)) : call-c-code(n(f), xs, ys(ins))
            else : call-c-pointer(xs, f, ys(ins))
          (f, ct:CallC) :
            call-c-pointer(xs, f, ys(ins))
        where :
          ;Call a known function with the Stanza calling convention
          defn call-code (n:Int, xs:Tuple<Local>, targs:Tuple<EType>, args:Tuple<EImm>, tail?:True|False) :
            val args* = cat-all $ [
              [false-obj(iotable), NumConst(length(args))]
              seq-cat(imms!, cat(targs, args))]
            val f = code-address(gt,n)
            if tail? : emit(TCallIns(f, to-tuple(args*)))
            else : emit(CallIns(xs, f, to-tuple(args*), info?))

          ;Call a function pointer
          defn call-pointer (xs:Tuple<Local>, f:EImm, args:Tuple<EImm>, tail?:True|False) :
            val f* = imm!(f)
            val args* = cat-all $ [
              [false-obj(iotable), NumConst(length(args))]
              seq-cat(imms!, args)]
            if tail? : emit(TCallIns(f*, to-tuple(args*)))
            else : emit(CallIns(xs, f*, to-tuple(args*), info?))

          ;Call a stanza closure
          defn call-closure (xs:Tuple<Local>, f:EImm, targs:Tuple<EType>, args:Tuple<EImm>, tail?:True|False) :
            val f* = imm!(f)
            val args* = cat-all $ [
              [f*, NumConst(length(args))]
              seq-cat(imms!, cat(targs, args))]
            if tail? : emit(TCallClosureIns(f*, to-tuple(args*)))
            else : emit(CallClosureIns(xs, f*, to-tuple(args*), info?))

          ;Call a C function
          defn call-c-code (n:Int, xs:Tuple<Local>, args:Tuple<EImm>) :
            val f = code-address(gt,n)
            emit(CallCIns(xs, f, map-cat(imms!, args), info?))

          ;Call a C function pointer
          defn call-c-pointer (xs:Tuple<Local>, f:EImm, args:Tuple<EImm>) :
            emit(CallCIns(xs, imm!(f), map-cat(imms!, args), info?))
      (ins:EDump) :
        val ys* = to-tuple(filter-by<Local>(seq-cat(imms!,ys(ins))))
        emit(DumpIns(ys*))
      (ins:EInterpret) :
        emit(Op1Ins(local(x(ins)), InterpretOp(), imm!(y(ins))))
      (ins:EConv) :
        emit(Op1Ins(local(x(ins)), ConvOp(), imm!(y(ins))))
      (ins:EGoto) :
        emit(GotoIns(get-label(n(ins))))
      (ins:EPrim) :
        match(op(ins)) :
          (op:YieldOp) :
            val x = local(x(ins) as EVarLoc)
            val stk = imm!(ys(ins)[0])
            val y = imm!(ys(ins)[1])
            emit(YieldIns(false, [x], stk, [y], stack-trace-info(ins)))
          (op:EnterStackOp) :
            val x = local(x(ins) as EVarLoc)
            val args = to-tuple(seq-cat(imms!, ys(ins)))
            val stk = args[0]
            val arity = length(ys(ins))
            val all-args = to-tuple(cat([false-obj(iotable), NumConst(arity)], args))
            emit(YieldIns(true, [x], stk, all-args, stack-trace-info(ins)))
          (op:BasicOp) :
            val x = local(x(ins) as EVarLoc) when x(ins) is EVarLoc
            defn y0 () : imm!(ys(ins)[0])
            defn y1 () : imm!(ys(ins)[1])
            emit $ switch(arity(op)) :
              0 : Op0Ins(x, op)
              1 : Op1Ins(x, op, y0())
              2 : Op2Ins(x, op, y0(), y1())
      (ins:EIf) :
        val pass-lbl = get-label(n1(ins))
        val fail-lbl = get-label(n2(ins))
        defn y0 () : imm!(ys(ins)[0])
        defn y1 () : imm!(ys(ins)[1])
        emit $ match(op(ins)) :
          (op:BasicOp) :
            switch(arity(op)) :
              1 : Branch1Ins(pass-lbl, fail-lbl, op, y0())
              2 : Branch2Ins(pass-lbl, fail-lbl, op, y0(), y1())
          (op:False) :
            Branch1Ins(pass-lbl, fail-lbl, false, y0())
      (ins:EMatch) :
        val ys* = map(imm!, ys(ins))
        val branches* = for b in branches(ins) map :
          VMBranch(map(to-typeset, types(b)), get-label(n(b)))
        if covered?(ins) :
          val len-1 = length(branches(ins)) - 1
          emit(MatchIns(ys*, to-tuple $ branches*[0 to len-1], n(branches*[len-1])))
        else :
          val fail-lbl = make-label()
          emit(MatchIns(ys*, branches*, fail-lbl))
          emit(LabelIns(fail-lbl))
          val arg-tuple = makedef(VMRef())
          ctuple(arg-tuple, ys*, stack-trace-info(ins))
          call-error(n(iotable,CORE-NO-BRANCH-ERROR-ID), [arg-tuple], stack-trace-info(ins))
      (ins:EDispatch) :
        val ys* = map(imm!, ys(ins))
        val fail-lbl = make-label()
        val amb-lbl = make-label()
        val branches* = for b in branches(ins) map :
          VMBranch(map(to-typeset, types(b)), get-label(n(b)))
        emit(DispatchIns(ys*, branches*, fail-lbl, amb-lbl))
        emit(LabelIns(fail-lbl))
        call-error(n(iotable,CORE-NO-BRANCH-ERROR-ID), [arg-tuple], stack-trace-info(ins)) where :
          val arg-tuple = makedef(VMRef())
          ctuple(arg-tuple, ys*, stack-trace-info(ins))
        emit(LabelIns(amb-lbl))
        call-error(n(iotable,CORE-AMB-BRANCH-ERROR-ID), [arg-tuple], stack-trace-info(ins)) where :
          val arg-tuple = makedef(VMRef())
          ctuple(arg-tuple, ys*, stack-trace-info(ins))
      (ins:ECheckFail) :
        val t* = imm!(type(ins))
        val y* = imm!(y(ins))
        val ctxt = NumConst(to-int(ctxt(ins)))
        call-error(n(iotable,CORE-CAST-ERROR-ID), [t*, y*, ctxt], stack-trace-info(ins))
      (ins:ETypeof) :
        val pass-lbl = get-label(n1(ins))
        val fail-lbl = get-label(n2(ins))
        ctypeof(pass-lbl, fail-lbl, imm!(y(ins)), type(ins))
      (ins:ECheckSet) :
        val y = imm!(y(ins))
        val pass-lbl = make-label()
        val fail-lbl = make-label()
        emit(Branch2Ins(pass-lbl, fail-lbl, NeOp(), y, VoidMarker()))
        emit(LabelIns(fail-lbl))
        val var-name = match(name(ins)) :
          (name:String) :
            val n = uniqueid()
            add(progbuffer, VMConst(n, name))
            ConstId(n)
          (n:False) :
            false-obj(iotable)
        call-error(n(iotable,CORE-VARIABLE-UNINITIALIZED-ERROR-ID), [var-name], stack-trace-info(ins))
        emit(LabelIns(pass-lbl))
      (ins:EBox) :
        ;Creation of a box to hold contents of mutable variable.
        val x = local(x(ins))
        val v = match(y(ins)) :
          (y:EImm) : imm!(y)
          (y:False) : VoidMarker()
        emit(AllocIns([x], [n(iotable,CORE-BOX-ID)], [NumConst(8)], false))
        ;No write barrier needed for construction of box.
        emit(StoreIns(x, 0, v, n(iotable,CORE-BOX-ID)))
      (ins:EBoxGet) :
        val x = local(x(ins))
        emit(LoadIns(x, imm!(y(ins)), 0, n(iotable,CORE-BOX-ID)))
      (ins:EBoxSet) :
        val y = imm!(y(ins))
        val z = imm!(z(ins))
        ;Write barrier is needed.
        emit(StoreWithBarrierIns(y, 0, z, n(iotable,CORE-BOX-ID)))
      (ins:EReturn) :
        emit(ReturnIns(imms!(y(ins))))
      (ins:EObjectGet) :
        val x = local(x(ins))
        val y = imm!(y(ins))
        val slot-index = num-targs(gt,n(ins)) + index(ins)
        emit(LoadIns(x, y, slot-index * 8, n(ins)))
      (ins:EObjectTGet) :
        val x = local(x(ins))
        val y = imm!(y(ins))
        emit(LoadIns(x, y, index(ins) * 8, n(ins)))
      (ins:EClosureGet) :
        val x = local(x(ins))
        val y = imm!(y(ins))
        val slot-index = num-targs(gt,n(ins)) + index(ins)
        emit(LoadIns(x, y, 16 + slot-index * 8, n(iotable,CORE-FN-ID)))
      (ins:EClosureTGet) :
        val x = local(x(ins))
        val y = imm!(y(ins))
        emit(LoadIns(x, y, 16 + index(ins) * 8, n(iotable,CORE-FN-ID)))
      (ins:ELetRec) :
        ;Compute total memory needed to allocate all closures.
        val sizes = for c in ys(ins) map :
          val num-slots = length(targs(c)) + length(ys(c))
          NumConst(8 + 8 + num-slots * 8)
        val xs* = map(local, xs(ins))
        val fn-type = n(iotable,CORE-FN-ID)
        val ts = map({fn-type}, xs(ins))
        ;Reserve and allocate space for all closures atomically.
        emit(AllocIns(xs*, ts, sizes, stack-trace-info(ins)))
        ;Populate fields of closures.
        for (x in xs*, c in ys(ins)) do :
          val num-slots = length(targs(c)) + length(ys(c))
          ;No write barriers needed for construction of closures.
          emit(StoreIns(x, 0, LongConst(num-slots), fn-type))
          emit(StoreIns(x, 8, CodeId(n(c)), fn-type))
          for (a in cat(targs(c), ys(c)), o in 16 to false by 8) do :
            emit(StoreIns(x, o, imm!(a), fn-type))
      (ins:ETypeObject) :
        val x = local(x(ins))
        val size = NumConst(8 + 8 + 8 * length(targs(ins)))
        val type-type = n(iotable,CORE-TYPE-ID)
        ;No write barriers needed for construction of new type object.
        emit(AllocIns([x], [type-type], [size], false))
        emit(StoreIns(x, 0, LongConst(length(targs(ins))), type-type))
        emit(StoreIns(x, 8, CodeId(n(ins)), type-type))
        for (a in targs(ins), o in 16 to false by 8) do :
          emit(StoreIns(x, o, imm!(a), type-type))
      (ins:ETDef) :
        val x = local(x(ins))
        val y = imm!(y(ins))
        emit(SetIns(x,y))
      (ins:ELive) :
        val xs* = seq-cat(imms!, xs(ins))
        emit(LiveIns(to-tuple(xs*)))
      (ins:ESafepoint) :

        defn* make-safepoint (info:StackTraceInfo) :
          val entry = SafepointEntry(info, group-id(ins))
          val ins = add(progbuffer, entry)
          emit(ins)

        match(stack-trace-info(ins)) :
          (info:StackTraceInfo) :
            if /info(info) is AbsoluteFileInfo :
              make-safepoint(info)
          (f:False) : false

  ;---------------------------------------------------------
  ;--------------- Create the Compiler Type ----------------
  ;---------------------------------------------------------
  new Compiler :
    defmethod emit (this, i:VMIns) :
      emit(i)

    defmethod make-local (this, t:VMType) :
      makedef(t)

    defmethod make-local (this, x:Int, t:VMType, debug-name:String|False) :
      val l = makedef(t)
      locals-table[x] = [l]
      record-debug-name?(l, debug-name)
      l

    defmethod make-locals (this, x:Int, t:EType, debug-name:String|False) :
      val ls = makedefs(vmtypes(gt,t))
      locals-table[x] = ls
      record-debug-name?(ls[0], debug-name)
      ls

    defmethod make-tvar-local (this, x:Int, debug-name:String|False) :
      val l = makedef(VMRef())
      tlocals-table[x] = l
      record-debug-name?(l, debug-name)
      l

    defmethod make-label (this) :
      make-label()

    defmethod clear-locals (this) :
      clear(locals-table)
      clear(tlocals-table)
      clear(labels-table)

    defmethod compile (this, ins:Seqable<EIns>) :
      do(compile, ins)

    defmethod return-typeof (this, x:VMImm, t:EType) :
      return-ctypeof(x,t)

    defmethod method-dispatch (this,
                               multi:Int, ys:Tuple<VMImm>, zs:Tuple<VMImm>,
                               trace-entry:StackTraceInfo|False) :
      method-dispatch(multi, ys, zs, trace-entry)

    defmethod defs (this) : to-tuple(defs)

    defmethod ins (this) : to-tuple(insbuffer)

    defmethod empty? (this) : empty?(insbuffer)

    defmethod debug-name-table (this) :
      VMDebugNameTable(to-tuple(debug-names))

deftype CVal
defstruct CImm <: CVal :
  imms: Tuple<VMImm>
defstruct CMem <: CVal :
  address: VMImm
  types: Tuple<VMType>
  offsets: Tuple<Int>

;Represents a location to store/assign to.
deftype CLoc
;Represents the field of a tagged primitive.
;Storing into this field is accomplished using a bit-shift plus adding the tag bits.
defstruct TaggedPrimLoc <: CLoc :
  prim: CVal
  n: Int
;Represents some virtual register.
defstruct LocalLoc <: CLoc :
  n: Int
  index: Int
;Represents some offset away from a pointer in memory.
defstruct PtrLoc <: CLoc :
  base: CVal
  offset: CVal|False
  const: Int

defn to-vm-type (t:EType) :
  match(t) :
    (t:EByte) : VMByte()
    (t:EInt) : VMInt()
    (t:ELong) : VMLong()
    (t:EFloat) : VMFloat()
    (t:EDouble) : VMDouble()
    (t:EOf) : VMRef()
    (t:EPtrT) : VMLong()

;If the given location represents a slot
;within a heap-allocated object, returns the
;identifier of the type of the object.
defn class (l:ELoc) -> Int|False :
  match(l) :
    (l:EField) :
      match(loc(l)) :
        (b:EDeref) : n(l)
        (b:EDeptr) : n(l)
        (b) : class(b)
    (l:ESlot) :
      class(loc(l))
    (l) :
      false

defn base (l:ELoc) :
  match(l) :
    (l:EField) : base(loc(l))
    (l:ESlot) : base(loc(l))
    (l) : l

defn LongConst (x:Int) :
  NumConst(to-long(x))

defn map-cat<?T,?S> (f:T -> Seqable<?S>, xs:Tuple<?T>) :
  to-tuple(seq-cat(f,xs))
defn map-cat<?T1,?T2,?S> (f:(T1,T2) -> Seqable<?S>, xs:Tuple<?T1>, ys:Seqable<?T2>) :
  to-tuple(seq-cat(f,xs,ys))

;Convert to typeset
defn to-typeset (t:EType) :
  let loop (t:EType = t) :
    match(t) :
      (t:EOf) : SingleType(n(t))
      (t:ETop) : TopType()
      (t:EAnd) : AndType?([loop(a(t)), loop(b(t))])
      (t:EOr) : OrType?([loop(a(t)), loop(b(t))])

defn string-bytes (s:String) :
  val n = length(s)
  val a = ByteArray(n + 1)
  for (c in s, i in 0 to false) do :
    a[i] = to-byte(c)
  a[n] = 0Y
  a

defn to-int (c:CastErrorContext) :
  match(c) :
    (c:CastContext) : 0
    (c:ArgContext) : 1
    (c:ReturnContext) : 2
    (c:DefContext) : 3
    (c:SetContext) : 4
    (c:FuncContext) : 5
    (c:DetupleContext) : 6
    (c:GetVarContext) : 7
    (c:BranchContext) : 8

;============================================================
;=================== Special Definitions ====================
;============================================================

defn false-obj (iotable:IOTable) :
  Marker(n(iotable,CORE-FALSE-ID))

defn true-obj (iotable:IOTable) :
  Marker(n(iotable,CORE-TRUE-ID))

;============================================================
;==================== Type Printing =========================
;============================================================

defn type-parts (t:EType, iotable:IOTable) -> Tuple<String|ETVar> :
  val parts = generate<String|ETVar> :
    ;Break down type into parts
    defn level (t:EType) :
      match(t) :
        ;Variables and Or Types
        (t:ETVar|EOr) : 0
        ;And Types
        (t:EAnd) : 1
        ;Atomic Types
        (t) : 2
    defn format (t:EType, l:Int) :
      ;Compute whether parenthesis are needed
      val paren? = level(t) < l
      yield("(") when paren?
      match(t) :
        (t:EOr) :
          format(a(t), 0)
          yield("|")
          format(b(t), 0)
        (t:EAnd) :
          format(a(t), 1)
          yield("&")
          format(b(t), 1)
        (t:EOf) :
          val id = id(iotable[n(t)])
          yield(to-string(name(id as TypeId)))
        (t:ETop) :
          yield("?")
        (t:EBot) :
          yield("Void")
        (t:ETVar) :
          yield(t)
      yield(")") when paren?
    format(t, 0)

  to-tuple $ generate<String|ETVar> :
    while not empty?(parts) :
      match(peek(parts)) :
        (v:ETVar):
          yield(next(parts))
        (v:String) :
          val vs = take-while({_ is String}, parts)
          yield(string-join(vs))

;============================================================
;====================== GlobalTable =========================
;============================================================

deftype GlobalTable
;Retrieve type of global variable
defmulti type (t:GlobalTable, n:Int) -> EType
defmulti function? (t:GlobalTable, n:Int) -> True|False
defmulti global? (t:GlobalTable, n:Int) -> True|False
defmulti instance-method? (t:GlobalTable, n:Int) -> True|False
defmulti code-address (t:GlobalTable, n:Int) -> VMImm
defmulti address (t:GlobalTable, n:Int) -> VMImm

;Retrieve struct properties
defmulti offsets (t:GlobalTable, t:EType) -> Tuple<Int>
defmulti field-names (t:GlobalTable, t:EType) -> Tuple<Symbol>
defmulti size (t:GlobalTable, t:EType) -> Int
defmulti length (t:GlobalTable, t:EType) -> Int
defmulti vmtypes (t:GlobalTable, t:EType) -> Tuple<VMType>
defmulti offsets (t:GlobalTable, n:Int) -> Tuple<Int>
defmulti field-names (t:GlobalTable, n:Int) -> Tuple<Symbol>
defmulti size (t:GlobalTable, n:Int) -> Int
defmulti length (t:GlobalTable, n:Int) -> Int
defmulti vmtypes (t:GlobalTable, n:Int) -> Tuple<VMType>
defmulti alignment (t:GlobalTable, t:EType) -> Int
defmulti field-index (t:GlobalTable, n:Int, index:Int) -> Int
defmulti field-offset (t:GlobalTable, n:Int, index:Int) -> Int
defmulti item-size (t:GlobalTable, n:Int) -> Int
defmulti base+item-offsets (t:GlobalTable, n:Int) -> Seq<Int>
defmulti num-targs (t:GlobalTable, n:Int) -> Int

deftype GlobalEntry
defstruct VarEntry <: GlobalEntry :
  type: EType
  extern?: True|False
defstruct FnEntry <: GlobalEntry :
  type: FnType
defstruct StructEntry <: GlobalEntry :
  base: Tuple<EDefField>
  items: False|EDefField
  offsets: Tuple<Int> with: (default => void)
  size: Int with: (default => void)
  length: Int with: (default => void)
  alignment: Int with: (default => void)
  vmtypes: Tuple<VMType> with: (default => void)
  field-indices: Tuple<Int> with: (default => void)
  field-offsets: Tuple<Int> with: (default => void)
  field-names: Tuple<Symbol> with: (default => void)
defstruct ClosureEntry <: GlobalEntry :
  ntargs: Int
  nargs: Int
defstruct ObjectEntry <: GlobalEntry :
  ntargs: Int
  nargs: Int

deftype FnType
defstruct StanzaFn <: FnType
defstruct ExternFn <: FnType
defstruct ExternDefn <: FnType

defn GlobalTable (io:PackageIO, epackage:EPackage) :
  ;Conversion to ETypes
  val tt = IOTable(io)
  defn to-etype (t:DType, tarity:Int) :
    val targs = to-tuple(seq(ETop{}, 0 to tarity))
    /to-etype(tt, t, targs)
  defn to-etype (t:DType) : /to-etype(tt, t, [])
  defn to-etype (t:False, tarity:Int) : false
  defn to-etype (t:False) : false

  ;Register instance methods
  val instance-methods = IntSet()

  ;Create global entries
  val table = IntTable<GlobalEntry>()
  for import in imports(io) do :
    match(rec(import)) :
      (r:FnRec|MultiRec|ExternFnRec) :
        val t = match(r) :
          (r:FnRec|MultiRec) : StanzaFn()
          (r:ExternFnRec) : ExternDefn()
        table[n(import)] = FnEntry(t)
      (r:ValRec) :
        table[n(import)] = VarEntry(to-etype(type(r)), false)
      (r:ExternRec) :
        table[n(import)] = match(type(r)) :
          (t:DFnT) : FnEntry(ExternFn())
          (t) : VarEntry(to-etype(t), true)
      (r:StructRec) :
        defn sfield (f) : EDefField(mutable?(f), name(f), to-etype(type(f), ntargs(r)))
        val base* = map(sfield, base(r))
        val items* = match(items(r)) :
          (items:StructField) : sfield(items)
          (items:False) : false
        table[n(import)] = StructEntry(base*, items*)
      (r) : false
  for e in exps(epackage) do :
    match(e) :
      (e:EDefn|EDefmulti|EExternFn|EDefmethod) :
        val t = match(e) :
          (e:EDefn|EDefmulti|EDefmethod) : StanzaFn()
          (e:EExternFn) : ExternDefn()
        table[n(e)] = FnEntry(t)
      (e:EDefGlobal) :
        table[n(e)] = VarEntry(type(e), false)
      (e:EExtern) :
        table[n(e)] = match(type(e)) :
          (t:EFnT) : FnEntry(ExternFn())
          (t) : VarEntry(t, true)
      (e:EDefStruct) :
        table[n(e)] = StructEntry(base(e), items(e))
      (e:EDefObject) :
        table[n(e)] = ObjectEntry(ntargs(e), nargs(e))
        add-all(instance-methods, methods(e))
      (e:EDefClosure) :
        table[n(e)] = ClosureEntry(ntargs(e), nargs(e))
      (e) :
        false

  ;Compute struct properties
  defn compute-struct-properties (this:GlobalTable) :
    ;Compute the properties for struct n and all
    ;dependents of struct n.
    val analyzed = IntSet()
    defn compute-properties (sn:Int) :
      if not analyzed[sn] :
        val e = table[sn] as StructEntry
        val items! = [items(e) as EDefField] when items(e) is EDefField else []
        val structs = filter-by<EStructT>(seq(type, cat(base(e), items!)))
        do(compute-properties{n(_)}, structs)
        table[sn] = analyze(e)
        add(analyzed, sn)

    ;Analyze the given StructEntry
    ;(assumes that all dependencies have been analyzed)
    defn analyze (e:StructEntry) :
      ;Accumulators
      val offsets-list = Vector<Int>()
      var size-accum:Int = 0
      var length-accum:Int = 0
      var alignment-accum:Int = 1
      val vmtypes-list = Vector<VMType>()
      val field-indices-list = Vector<Int>()
      val field-offsets-list = Vector<Int>()
      val field-names-list = Vector<Symbol>()

      ;Analyze each base field
      for f in base(e) do :
        ;Retrieve properties of this type
        val t = type(f)
        val n = name(f)
        val os = offsets(this,t)
        val vmts = vmtypes(this,t)
        val fnms = field-names(this,t)
        val nms = [n] when fnms == [`value] else to-tuple(seq({to-symbol("%_.%_" % [n _])}, fnms))
        val aln = alignment(this,t)
        val size = size(this,t)
        val len = length(this,t)

        ;Pad to appropriate alignment (assumes aln is power of 2)
        size-accum = (size-accum + aln - 1) & (- aln)

        ;Update accumulators
        add(field-offsets-list, size-accum)
        add(field-indices-list, length-accum)
        add-all(offsets-list, seq({size-accum + _}, os))
        add-all(vmtypes-list, vmts)
        add-all(field-names-list, nms)
        size-accum = size-accum + size
        length-accum = length-accum + len
        alignment-accum = max(alignment-accum, aln)

      ;Pad to appropriate alignment to finish
      match(items(e)) :
        (items:EDefField) :
          val aln = alignment(this, type(items))
          size-accum = (size-accum + aln - 1) & (- aln)
        (items:False) :
          size-accum = (size-accum + alignment-accum - 1) & (- alignment-accum)

      ;Return analyzed StructEntry
      StructEntry(base(e), items(e),
                  to-tuple(offsets-list),
                  size-accum,
                  length-accum,
                  alignment-accum,
                  to-tuple(vmtypes-list),
                  to-tuple(field-indices-list),
                  to-tuple(field-offsets-list),
                  to-tuple(field-names-list))

    ;Driver
    do(compute-properties, struct-ns) where :
      val structs = filter({value(_) is StructEntry}, table)
      val struct-ns = seq(key, structs)

  ;Create and initialize global table
  val gt = new GlobalTable :
    defmethod code-address (this, n:Int) :
      val rec = table[n] as FnEntry
      match(type(rec)) :
        (t:StanzaFn) : CodeId(n)
        (t:ExternFn) : ExternId(n)
        (t:ExternDefn) : ExternDefnId(n)
    defmethod address (this, n:Int) :
      match(table[n]) :
        (r:FnEntry) :
          code-address(this, n)
        (r:VarEntry) :
          if extern?(r) : ExternId(n)
          else : GlobalId(n)
    defmethod global? (this, n:Int) :
      get?(table,n) is VarEntry|FnEntry
    defmethod type (this, n:Int) :
      type(table[n] as VarEntry)
    defmethod function? (this, n:Int) :
      get?(table,n) is FnEntry
    defmethod num-targs (this, n:Int) :
      match(table[n]) :
        (e:ClosureEntry) : ntargs(e)
        (e:ObjectEntry) : ntargs(e)
    defmethod vmtypes (this, t:EType) :
      match(t) :
        (t:EStructT) : vmtypes(table[n(t)] as StructEntry)
        (t:EFnT) : fatal("Invalid argument")
        (t:EUnknown) : fatal("Invalid argument")
        (t:EByte) : [VMByte()]
        (t:EInt) : [VMInt()]
        (t:ELong) : [VMLong()]
        (t:EFloat) : [VMFloat()]
        (t:EDouble) : [VMDouble()]
        (t:EPtrT) : [VMLong()]
        (t) : [VMRef()]
    defmethod vmtypes (this, n:Int) :
      vmtypes(table[n] as StructEntry)
    defmethod alignment (this, t:EType) :
      match(t) :
        (t:EStructT) : alignment(table[n(t)] as StructEntry)
        (t) : size(this, t)
    defmethod size (this, t:EType) :
      match(t) :
        (t:EStructT) : size(table[n(t)] as StructEntry)
        (t:EFnT) : fatal("Invalid argument")
        (t:EUnknown) : fatal("Invalid argument")
        (t:EByte) : 1
        (t:EInt) : 4
        (t:ELong) : 8
        (t:EFloat) : 4
        (t:EDouble) : 8
        (t) : 8
    defmethod size (this, n:Int) :
      size(table[n] as StructEntry)
    defmethod length (this, t:EType) :
      match(t) :
        (t:EStructT) : length(table[n(t)] as StructEntry)
        (t:EFnT) : fatal("Invalid argument")
        (t:EUnknown) : fatal("Invalid argument")
        (t) : 1
    defmethod length (this, n:Int) :
      length(table[n] as StructEntry)
    defmethod offsets (this, t:EType) :
      match(t) :
        (t:EStructT) : offsets(table[n(t)] as StructEntry)
        (t:EFnT) : fatal("Invalid argument")
        (t:EUnknown) : fatal("Invalid argument")
        (t) : [0]
    defmethod offsets (this, n:Int) :
      offsets(table[n] as StructEntry)
    defmethod field-names (this, t:EType) :
      match(t) :
        (t:EStructT) : field-names(table[n(t)] as StructEntry)
        (t:EFnT) : fatal("Invalid argument")
        (t:EUnknown) : fatal("Invalid argument")
        (t) : [`value]
    defmethod field-names (this, n:Int) :
      field-names(table[n] as StructEntry)
    defmethod field-index (this, n:Int, index:Int) :
      val e = table[n] as StructEntry
      if index < length(field-indices(e)) :
        field-indices(e)[index]
      else if index == length(field-indices(e)) :
        fatal("No rest field") when items(e) is False
        length(e)
      else :
        fatal("Field index out of bounds.")
    defmethod field-offset (this, n:Int, index:Int) :
      val e = table[n] as StructEntry
      if index < length(field-offsets(e)) :
        field-offsets(e)[index]
      else if index == length(field-offsets(e)) :
        fatal("No rest field") when items(e) is False
        size(e)
      else :
        fatal("Field index out of bounds.")
    defmethod item-size (this, n:Int) :
      val e = table[n] as StructEntry
      fatal("Not an array type") when items(e) is False
      size(this, type(items(e) as EDefField))
    defmethod base+item-offsets (this, n:Int) :
      val e = table[n] as StructEntry
      fatal("Not an array type") when items(e) is False
      val base-size = size(this, n)
      val item-size = size(this, type(items(e) as EDefField))
      val item-os = offsets(this, type(items(e) as EDefField))
      val recur-item-os =
        for offset in base-size to false by item-size seq-cat :
          seq({offset + _}, item-os)
      cat(offsets(this,n), recur-item-os)
    defmethod instance-method? (this, n:Int) :
      instance-methods[n]

  compute-struct-properties(gt)
  gt

defn roots (gt:GlobalTable, t:EType) :
  roots(offsets(gt,t), vmtypes(gt,t))
defn roots (gt:GlobalTable, n:Int) :
  roots(offsets(gt, n), vmtypes(gt, n))
defn roots (offsets:Seqable<Int>, types:Seqable<VMType>) :
  val root-offsets = for (o in offsets, t in types) filter : t is VMRef
  to-tuple(seq({_ / 8}, root-offsets))

defn root-names (gt:GlobalTable, t:EType) :
  root-names(field-names(gt,t), vmtypes(gt,t))
defn root-names (gt:GlobalTable, n:Int) :
  root-names(field-names(gt,n), vmtypes(gt,n))
defn root-names (names:Seqable<Symbol>, types:Seqable<VMType>) :
  val root-names = for (n in names, t in types) filter : t is VMRef
  to-tuple(root-names)
