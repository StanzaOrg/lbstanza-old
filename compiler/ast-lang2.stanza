defpackage stz/ast-lang2 :
  import core
  import collections
  import macro-utils
  import stz/core-macros

;<doc>=======================================================
;==================== Example ===============================
;============================================================

Defining nodes with common fields and common options.

  defnodes MyType <: Hashable&Equalable :
    common :
      info: FileInfo|False with: (as-method => true)
    common-options :
      printer => true
      equalable => true
    A :
      field1: Type1
      field2: Type2 with: (options ...)
    B :
      field1: Type1
      field2: Type2 with: (options ...)

Defining a mapper.

  defmapper (f:TLItem -> TLItem) :
    (x:List<TDefn>) : map({f(_) as TDefn}, x)
    (x:List<TDefmethod>) : map({f(_) as TDefmethod}, x)

  make-mapper :
    func: TLItem -> TLItem
    item: TLItem
    nodes: (MyType)

Defining a doer.

  make-doer :
    func: TLItem -> ?
    item: TLItem
    nodes: (MyType)

;============================================================
;=======================================================<doc>

;============================================================
;==================== Parse Structures ======================
;============================================================

;Overall structure of the AST definition.
defstruct DefAst :
  defs:Tuple<Def>
with:
  printer => true

;Represents definitions in the AST.
deftype Def

;Defining nodes in the AST.
defstruct DefNodes <: Def :
  type: Symbol
  parent: Maybe
  common: Tuple<NodeField>
  common-options: Maybe<List>
  nodes: Tuple<Node>
with:
  printer => true

;Represents one node.
defstruct Node :
  name: Symbol
  fields: Tuple<NodeField>
with:
  printer => true

;Represents a field in a node.
defstruct NodeField :
  name: Symbol
  type
  options: Maybe<List>
with:
  printer => true

;Represents a mapper for a function type.
defstruct DefMapper <: Def :
  func:Symbol
  func-type
  clauses: Tuple<Clause>
with:
  printer => true

;Represents a doer for a function type.
defstruct DefDoer <: Def :
  func:Symbol
  func-type
  clauses: Tuple<Clause>
with:
  printer => true

;Represents types to ignore for mappers/doers.
defstruct Ignore <: Def :
  types: Tuple
with:
  printer => true

;Make a new mapper.
defstruct MakeMapper <: Def :
  func-type
  item-type
  nodes: Tuple<Symbol>
with:
  printer => true

;Make a new doer.
defstruct MakeDoer <: Def :
  func-type
  item-type
  nodes: Tuple<Symbol>
with:
  printer => true

;Represents either a mapper/doer clause.
defstruct Clause :
  x:Symbol
  type
  body
with:
  printer => true

;============================================================
;====================== Reader ==============================
;============================================================

defsyntax ast-lang2 :

  ;Imports
  import (:!, type!, exp!, id!, id, type, exp) from core

  ;Overall defast production.
  public defproduction defast:DefAst
  defrule defast = (defast :
                      ?defs:#def! ...) :
    DefAst(to-tuple(defs))
  
  ;Each type of definition.
  defproduction def:Def

  ;Define nodes.
  defrule def = (defnodes ?name:#name ?parent:#parent? #:! (
                   ?common:#common?
                   ?common-options:#common-options?
                   ?nodes:#node! ...)) :
    DefNodes(
      name
      parent
      common
      common-options
      to-tuple(nodes))

  ;Helper: Parent of defnodes.
  defproduction parent?: Maybe
  defrule parent? = (<: ?t:#type) : One(t)
  defrule parent? = () : None()

  ;Helper: common fields
  defproduction common?: Tuple<NodeField>
  defrule common? = (common #:! (?fs:#field! ...)) : to-tuple(fs)
  defrule common? = () : []

  ;Helper: common options
  defproduction common-options?: Maybe<List>
  defrule common-options? = (common-options #:! (?options ...)) : One(options)
  defrule common-options? = () : None()

  ;Define Nodes
  defproduction node: Node
  defrule node = (?name:#name #:! (?fs:#field! ...)) :
    Node(name, to-tuple(fs))

  ;Define Fields
  defproduction field: NodeField
  defrule field = (?name:#name : ?type:#type! ?options:#field-options?) :
    NodeField(name, type, options)

  ;Helper: field options
  defproduction field-options?: Maybe<List>
  defrule field-options? = (with: (?options ...)) : One(options)
  defrule field-options? = () : None()

  ;Define a mapper.
  defrule def = (defmapper (?func:#name! : ?func-type:#type!) :
                   ?cs:#clause! ...) :
    DefMapper(func, func-type, to-tuple(cs))

  ;Define a doer.
  defrule def = (defdoer (?func:#name! : ?func-type:#type!) :
                   ?cs:#clause! ...) :
    DefDoer(func, func-type, to-tuple(cs))

  ;Helper: a clause in a mapper.
  defproduction clause:Clause
  defrule clause = ((?name:#name : ?type:#type!) : ?body:#exp!) : Clause(name, type, body)

  ;Define making a mapper.
  defrule def = (make-mapper :
                   func: ?func-type:#type!
                   item: ?item-type:#type!
                   nodes: (?nodes:#name! ...)) :
    MakeMapper(func-type, item-type, to-tuple(nodes))

  ;Define making a doer.
  defrule def = (make-doer :
                   func: ?func-type:#type!
                   item: ?item-type:#type!
                   nodes: (?nodes:#name! ...)) :
    MakeDoer(func-type, item-type, to-tuple(nodes))

  ;Utility productions
  defproduction name: Symbol
  defrule name = (?x:#id) : unwrap-token(x)
 
  ;Error productions.
  defproduction def!:Def
  defrule def! = (?x:#def)
  fail-if def! = () : AE(closest-info(), "Illegal syntax for AST definition.")
  defproduction name!:Symbol
  defrule name! = (?x:#name)
  fail-if name! = () : AE(closest-info(), "Expected a name here.")
  defproduction node!:Node
  defrule node! = (?x:#node)
  fail-if node! = () : AE(closest-info(), "Invalid syntax for node.")
  defproduction field!:NodeField
  defrule field! = (?x:#field)
  fail-if field! = () : AE(closest-info(), "Invalid syntax for field.")
  defproduction clause!:Clause
  defrule clause! = (?x:#clause)
  fail-if clause! = () : AE(closest-info(), "Invalid syntax for clause.")

;============================================================
;========================= Errors ===========================
;============================================================

defstruct ASTError <: Exception :
  info:FileInfo|False
  message
with:
  constructor => AE

defmethod print (o:OutputStream, e:ASTError) :
  val info-str = "" when info(e) is False
            else "%_ :" % [info(e)]
  print(o, "%_%_" % [info-str, message(e)])

;============================================================
;==================== Compilation ===========================
;============================================================

defn compile () :
  ;Generation template.
  val template = `(
    nodetype{
      ;Generate the overall type.
      deftype Type parent?{<: Parent}{}

      nodes{
        defstruct Node <: Type :
          all-fields{
            name:type options?{with: options}{}
          }
        common-options?{with : common-options}{}
      }
    }
    
    mappers{
      defn map<?T> (func:FuncType, item:?T&ItemType) -> T :
        val result = match(item) :
          nodes{
            (item:Node) : Node(
                            all-fields{
                              ignore?{
                                name(item)
                              }{
                                mapper(func, name(item))
                              }
                            })
          }
        result as T&ItemType
    }

    doers{
      defn do<?T> (func:FuncType, item:ItemType) -> False :
        match(item) :
          nodes{
            (item:Node) :
              all-fields{
                ignore?{}{
                  doer(func, name(item))
                }
              }
          }
        false
    }

    mapper-functions{
      defn mapper (func:func-type, item:type) : body
    }

    doer-functions{
      defn doer (func:func-type, item:type) : body
    }
  )

  template

  

;============================================================
;=================== Syntax Definition ======================
;============================================================

defsyntax stz/ast-lang2 :
  import exp4 from core

  defrule exp4 = (say-hello) :
    val form = `(println("Hello everyone!"))
    parse-syntax[core / #exp](form)

;============================================================
;====================== Scratch =============================
;============================================================

let :
  within (package,sig) = set-stack-trace-filter() :
    package != `core
  val str = \<STR>
    defast :
      defnodes MyType <: Hashable&Equalable :
        common :
          info: FileInfo|False with: (as-method => true)
        common-options :
          printer => true
          equalable => true
        A :
          field1: Type1
          field2: Type2 with: (options ...)
        B :
          field1: Type1
          field2: Type2 with: (options ...)

      defmapper (f:TLItem -> TLItem) :
        (x:List<TDefn>) : map({f(_) as TDefn}, x)
        (x:List<TDefmethod>) : map({f(_) as TDefmethod}, x)

      make-mapper :
        func: TLItem -> TLItem
        item: TLItem
        nodes: (MyType)

      make-doer :
        func: TLItem -> ?
        item: TLItem
        nodes: (MyType)      
  <STR>
  val form = reader/read-all(str)
  val parsed = parse-syntax[ast-lang2 / #defast](form)
  println(parsed)

println $ compile()