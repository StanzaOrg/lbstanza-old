defpackage stz/reg-alloc-block-analysis :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-block-ir
  import stz/reg-alloc-engine
  import stz/reg-alloc-block-engine
  import stz/reg-alloc-annotations
  import stz/reg-alloc-model-analysis
  import stz/reg-alloc-datastructures
  import stz/reg-alloc-shuffle

public defn analyze-blocks (e:RegAllocEngine) -> False :
  val resources = ResourceProvider(16, 16, 20)
  val shuffle = ShuffleEngine(resources)
  val be = BlockEngine(models(e), model-properties(e), model-analyzer(e), var-types(e), shuffle)
  for block in blocks(e) do :
    load-block(e, block, be)
    println(be)
    annotate-block(be)
    println(be)
    fatal("STOP HERE")
  fatal("Not yet implemented")

;============================================================
;============= Loading into the Block Engine ================
;============================================================

;Loading a block from the RegAllocEngine.
public defn load-block (e:RegAllocEngine, b:Block, be:BlockEngine) -> False :
  val indices = start(b) to start(b) + length(b)
  val stmts = for i in indices seq : stmts(program(e))[i]
  set-contents(instructions(be), stmts)
  set-contents(inputs(be), inputs(b))
  set-contents(outputs(be), outputs(b))

;============================================================
;=================== Standalone Testing =====================
;============================================================

;Loading a standalone block from BlockStmts.
public defn load-block (b:BlockStmts,
                        models:Tuple<OperationModel>,
                        model-properties:Vector<ModelProperties>,
                        model-analyzer:ModelAnalyzer) -> BlockEngine :
  val resources = ResourceProvider(16, 16, 20)
  val shuffle = ShuffleEngine(resources)
  val var-types = to-inttable<RegisterType> $
    for v in vars(b) seq : id(v) => type(v)
  val be = BlockEngine(models, model-properties, model-analyzer, var-types, shuffle)
  set-contents(instructions(be), stmts(b))
  set-contents(inputs(be), inputs(b))
  set-contents(outputs(be), outputs(b))
  be

;============================================================
;===================== Utilities ============================
;============================================================
  
;Helper: Set the contents of the given vector.
defn set-contents<?T> (vs:Vector<?T>, xs:Seqable<T>) :
  clear(vs)
  add-all(vs,xs)      