defpackage stz/earley-eval :
  import core
  import collections
  import stz/earley-eval-result
  import stz/earley-grammar
  import stz/earley-parse-tree
  import stz/earley-sexp-stream
  import stz/earley-errors

;============================================================
;================= Evaluate the Parse Tree ==================
;============================================================

public defn evaluate-parse-tree (grammar:Grammar,
                                 node:ParseNode,
                                 inputlist:Vector<SExpToken>,
                                 infolist:Vector<FileInfo|False>) -> ? :  
  ;Accumulated errors                        
  val errors = Vector<Exception>()

  ;Attempt evaluation of a given ParseNode
  ;If the node evaluates without error, then it returns a One.
  ;Otherwise it adds an error to the error list, and returns a None.
  defn evaluate (tree:ParseNode) -> Maybe :
    ;Retrieve rule
    val rule = grammar[rule(range(tree))]
    val params = params(rule) as TokenRuleParams
    defn evaluate-child (i:Int) -> Maybe :
      match(children(tree)[i]) :
        (child:ParseNode) :
          evaluate(child)
        (pos:Int) :
          val token = tokens(rule)[i]
          val input = inputlist[pos]
          match(token, input) :
            (token:GListRest, input:SExpForm|SExpListEnd) : One(list(input))
            (token:GListEnd, input:SExpListEnd) : One(false)
            (token, input:SExpForm) : One(form(input))
            
    ;Lazy evaluation
    defn lazy-evaluation () :
      label<Maybe> return :
        val result = new ParsedResult :
          defmethod get (this, i:Int) :
            val v = evaluate-child(i)
            return(None()) when empty?(v)
            value!(v)
          defmethod info (this) : infolist[start(range(tree))]
          defmethod form (this) : list(inputlist[start(range(tree))] as SExpForm|SExpListEnd)
        try :
          One(action(params)(result))
        catch (e:Exception) :
          add(errors, e)
          None()
        
    ;Eager evaluation
    defn eager-evaluation () :
      val results = to-tuple $
        seq(evaluate-child, 0 to length(tokens(rule)))
      if none?(empty?, results) :
        val result = new ParsedResult :
          defmethod get (this, i:Int) : value!(results[i])
          defmethod info (this) : infolist[start(range(tree))]
          defmethod form (this) : list(inputlist[start(range(tree))] as SExpForm|SExpListEnd)
        try :
          One(action(params)(result))
        catch (e:Exception) :
          add(errors, e)
          None()
      else :
        None()

    ;Launch!
    if lazy-action?(params) : lazy-evaluation()
    else : eager-evaluation()        

  ;Launch!
  val v = evaluate(node)
  if empty?(v) : throw(ParsingErrors(to-tuple(errors)))
  else : value!(v)