defpackage stz/reg-alloc-basic-blocks :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-block
  import stz/reg-alloc-model-env
  import stz/basic-blocks with:
    prefix(Block) => Util

;Compute the basic blocks in the given program.
public defn analyze-basic-blocks (program:Program, models:ModelEnv) -> Seqable<Block> :
  val block-table = analyze-basic-blocks(
                      make-instructions(program, models))
  seq(make-block, blocks(block-table))

;Return the Instructions view into the Program for
;the basic block analysis.
defn make-instructions (prog:Program, models:ModelEnv) -> Instructions :
  val label-counter = to-seq((max-label(prog) + 1) to false)
  val stmts = stmts(prog)
  new Instructions :
    defmethod classify (this, i:Int) :
      match(stmts[i]) :
        (s:LabelStmt) : LabelInstruction(index(s))
        (s:OperationStmt) :
          if returns?(models,op-id(s)) : JumpInstruction([])
          else : StandardInstruction()
        (s:SetStmt) : StandardInstruction()
        (s:BranchStmt) : JumpInstruction(targets(s))
        (s:GotoStmt) : GotoInstruction(target(s))
    defmethod unique-label (this) :
      next(label-counter)
    defmethod length (this) :
      length(stmts)

;Convert a utility block into a real block.
defn make-block (b:UtilBlock) -> Block :
  Block(index(b),
        start(b),
        length(b),
        succs(b),
        preds(b),
        ends-with-goto?(b))

;Compute the maximum label that was used, or -1
;if there exists no label.
defn max-label (prog:Program) -> Int :
  val labels = filter-by<LabelStmt>(stmts(prog))
  maximum(-1, seq(index, labels))