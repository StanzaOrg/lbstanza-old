defpackage stz/reg-alloc-block-processing :
  import core
  import collections
  import stz/reg-alloc-engine
  import stz/reg-alloc-ir

;Represents information about the desired order to
;process the blocks.
public deftype ProcessingOrder

;Retrieve the initial order to process the blocks in.
public defmulti initial-order (p:ProcessingOrder) -> Seqable<Int>

;Retrieve the next blocks to process if block 'i' changes.
public defmulti process-next (p:ProcessingOrder, i:Int) -> Seqable<Int>

;Main algorithm.
public defn iterative-block-analysis (process:Block -> True|False,
                                      blocks:Vector<Block>,
                                      ordering:ProcessingOrder) -> False :
  ;Track what blocks to process next.
  val worklist = Queue<Int>()

  ;Track whether blocks has been processed or not.
  val processed-blocks = IntSet()

  ;Add successors
  defn add-successors-to-queue (i:Int) -> False :
    ;Put each successor in the queue, and also mark it
    ;as no longer processed.
    for succ in process-next(ordering,i) do :
      add(worklist, succ)
      remove(processed-blocks, succ)

  ;Add the blocks according to the desired initial ordering.
  do(add{worklist, _}, initial-order(ordering))
  
  ;Process while the worklist is not empty.
  while not empty?(worklist) :
    ;Retrieve the next item in the worklist.
    val id = pop(worklist)

    ;If it hasn't already been processed:
    if not processed-blocks[id] :
      ;Process the block, and retrieve whether
      ;it changed.
      val progress? = process(blocks[id])

      ;Mark it as processed.
      add(processed-blocks, id)

      ;If progress was made, then process the next blocks it affect.
      add-successors-to-queue(id) when progress?