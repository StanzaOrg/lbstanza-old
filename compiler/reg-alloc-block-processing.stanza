defpackage stz/reg-alloc-block-processing :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-block

;============================================================
;===================== Iteration ============================
;============================================================

;Retrieve all statements in the given block in reverse.
public defn stmts-in-reverse (return:(Int, ProgramStmt) -> ?,
                              program:Program,
                              b:Block) -> False :
  val indices = reverse(start(b) to end(b))
  val stmts = stmts(program)
  for i in indices do :
    return(i - start(b), stmts[i])

;Retrieve all SetStmt|OperationStmt in the given block in reverse.
public defn operations-in-reverse (return:(Int, SetStmt|OperationStmt) -> ?,
                                   program:Program,
                                   b:Block) -> False :
  within (i, stmt) = stmts-in-reverse(program, b) :
    match(stmt:SetStmt|OperationStmt) :
      return(i, stmt)

;============================================================
;=================== Reverse Order ==========================
;============================================================

;Return the ProcessingOrder for processing blocks in reverse
;order (successors before predecessors).
public defn reverse-order (blocks:Vector<Block>) -> ProcessingOrder :
  val visited = IntSet()
  val ordering = Vector<Int>()
  if not empty?(blocks) :
    let loop (i:Int = 0) :
      if add(visited,i) :
        do(loop, succs(blocks[i]))
        add(ordering, i)
  new ProcessingOrder :
    defmethod initial-order (this) : ordering
    defmethod process-next (this, i:Int) : preds(blocks[i])

;============================================================
;=================== Processing Order =======================
;============================================================

;Represents information about the desired order to
;process the blocks.
public deftype ProcessingOrder

;Retrieve the initial order to process the blocks in.
public defmulti initial-order (p:ProcessingOrder) -> Seqable<Int>

;Retrieve the next blocks to process if block 'i' changes.
public defmulti process-next (p:ProcessingOrder, i:Int) -> Seqable<Int>

;============================================================
;================== Iterative Analysis ======================
;============================================================

;Main algorithm.
public defn iterative-block-analysis (process:Block -> True|False,
                                      blocks:Vector<Block>,
                                      ordering:ProcessingOrder) -> False :
  ;Track what blocks to process next.
  val worklist = Queue<Int>()

  ;Track whether blocks has been processed or not.
  val processed-blocks = IntSet()

  ;Add successors
  defn add-successors-to-queue (i:Int) -> False :
    ;Put each successor in the queue, and also mark it
    ;as no longer processed.
    for succ in process-next(ordering,i) do :
      add(worklist, succ)
      remove(processed-blocks, succ)

  ;Add the blocks according to the desired initial ordering.
  do(add{worklist, _}, initial-order(ordering))
  
  ;Process while the worklist is not empty.
  while not empty?(worklist) :
    ;Retrieve the next item in the worklist.
    val id = pop(worklist)

    ;If it hasn't already been processed:
    if not processed-blocks[id] :
      ;Process the block, and retrieve whether
      ;it changed.
      val progress? = process(blocks[id])

      ;Mark it as processed.
      add(processed-blocks, id)

      ;If progress was made, then process the next blocks it affect.
      add-successors-to-queue(id) when progress?