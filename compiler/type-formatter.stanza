defpackage stz/type-formatter :
  import core
  import collections
  import stz/types

;============================================================
;======================== API ===============================
;============================================================

;A type that can be used to create human-readable representations
;of types.
public deftype TypeFormatter

;Format a type as a human-readable object.
public defmulti format (f:TypeFormatter, t:Type) -> Printable

;Format an FArg as a human-readable object.
public defmulti format (f:TypeFormatter, a:FArg) -> Printable

;============================================================
;========================= Format ===========================
;============================================================

;Create a new type formatter with the given callback for
;looking up names of variables.
public defn TypeFormatter (name:Int -> Symbol) :

  ;HiStanza format(s). 
  ;Format a list of HiStanza types.
  ;- angle-context: True if the list is surrounded by angle brackets <...>. 
  defn hsfs (o:OutputStream, ts:Seqable<Type>, angle-context:True|False) :
    for (t in ts, i in 0 to false) do :
      print(o, ", ") when i > 0
      hsf(o, t, 0, angle-context)

  ;HiStanza formatting.
  ;- The level that this type appears in.
  defn hsf (o:OutputStream, t:Type, lvl:Int, angle-context:True|False) -> ? :
  
    ;Decide whether parentheses are necessary.
    val paren? =
      if hslevel(t) < lvl : true
      else if angle-context : t is TArrow
    val angle-context* = angle-context and not paren?

    print(o, "(") when paren?
    match(t) :
      (t:TArrow) :
        if length(a1(t)) == 1 :
          hsf(o, a1(t)[0], 1, angle-context*)
          print(o, " -> ")
          hsf(o, a2(t), 0, angle-context*)
        else :
          print(o, "(")
          hsfs(o, a1(t), false)
          print(o, ") -> ")
          hsf(o, a2(t), 0, angle-context*)
;      (t:TPoly) :
;        val type-args = cat(
;          for v in targs(t) seq : "%~" % [name(v)]
;          for v in cargs(t) seq : "?%~" % [name(v)])
;        print(o, "<%,> . " % [type-args])
;        hsf(o, func(t), 0, angle-context*)
      (t:TOr) :
        hsf(o, a(t), 1, angle-context*)
        print(o, "|")
        hsf(o, b(t), 1, angle-context*)
      (t:TAnd) :
        hsf(o, a(t), 2, angle-context*)
        print(o, "&")
        hsf(o, b(t), 2, angle-context*)
      ;Atomic
      (t:TOf) :
        write(o, name(n(t)))
        val elide-args? = empty?(args(t))
                       or all?({_ is TGradual}, args(t))
        if not elide-args? :
          print(o, "<")
          hsfs(o, args(t), true)
          print(o, ">")
      (t:TVar) :
        match(/name(t)) :
          (n:Symbol) : write(o, n)
          (_:False) : write(o, name(n(t)))
      (t:TCap) :
        print(o, "?")
        match(/name(t)) :
          (n:Symbol) : write(o, n)
          (_:False) : write(o, name(n(t)))
      (t:TGradual) :
        print(o, "?")
      (t:TBot) :
        print(o, "Void")
      (t:TTuple) :
        print(o, "[")
        hsfs(o, args(t), false)
        print(o, "]")
      (t:TUVar) :
        print(o, name(n(t)))
    print(o, ")") when paren?

  ;Return the formatting function.
  new TypeFormatter :
    defmethod format (this, t:Type) :
      wrap-printable $ hsf{_, t, 0, false}

    defmethod format (this, a:FArg) :
      defn option-str (b:True|False) :
        "optional " when b else ""
      match(a) :
        (a:PositionalArg) :
          "%_%_" % [option-str(optional?(a)), format(this,type(a))]
        (a:KeywordArg) :
          "%_%_:%_" % [option-str(optional?(a)), /name(a), format(this,type(a))]
        (a:VarArg) :
          "%_ ..." % [format(this,type(a))]

;============================================================
;================== Precedences =============================
;============================================================

;Syntax level of type.
;Lower means lower priority. Higher means tighter binding.
defn hslevel (t:Type)-> Int :
  match(t) :
    ;Arrows
    (t:TArrow) : 0
    ;Or Types
    (t:TOr) : 1
    ;And Types
    (t:TAnd) : 2
    ;Atomic types
    (t) : 3

;============================================================
;================== Utilities ===============================
;============================================================

;Helper: Wrap closure in printable object
defn wrap-printable (f:OutputStream -> False) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      f(o)