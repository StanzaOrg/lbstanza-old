defpackage stz/type-formatter :
  import core
  import collections
  import stz/types

;============================================================
;======================== API ===============================
;============================================================

;A type that can be used to create human-readable representations
;of types.
public deftype Formatter

;Format a type as a human-readable object.
public defmulti format (f:Formatter, t:Type) -> Printable

;============================================================
;========================= Format ===========================
;============================================================

public defn Formatter (name:Int -> Symbol) :

  ;Syntax level of type
  defn hslevel (t:Type) :
    match(t) :
      ;Arrows
      (t:TArrow) : 0
      ;Or Types
      (t:TOr) : 1
      ;And Types
      (t:TAnd) : 2
      ;Atomic types
      (t) : 3

  ;Format HiStanza type
  defn hsfs (o:OutputStream, ts:Seqable<Type>, lvl:Int, angle-context:True|False) :
    for (t in ts, i in 0 to false) do :
      print(o, ", ") when i > 0
      hsf(o, t, lvl, angle-context)

  defn hsf (o:OutputStream, t:Type, lvl:Int, angle-context:True|False) :
    val paren? =
      if hslevel(t) < lvl : true
      else if angle-context : t is TArrow
    val angle-context* = angle-context and not paren?
    print(o, "(") when paren?
    match(t) :
      (t:TArrow) :
        val a1 = types(a(t) as TTuple)
        if length(a1) == 1 :
          hsf(o, head(a1), 1, angle-context*)
          print(o, " -> ")
          hsf(o, b(t), 0, angle-context*)
        else :
          print(o, "(")
          hsfs(o, a1, 0, false)
          print(o, ") -> ")
          hsf(o, b(t), 0, angle-context*)
;      (t:TPoly) :
;        val type-args = cat(
;          for v in targs(t) seq : "%~" % [name(v)]
;          for v in cargs(t) seq : "?%~" % [name(v)])
;        print(o, "<%,> . " % [type-args])
;        hsf(o, func(t), 0, angle-context*)
      (t:TOr) :
        hsf(o, a(t), 1, angle-context*)
        print(o, "|")
        hsf(o, b(t), 1, angle-context*)
      (t:TAnd) :
        hsf(o, a(t), 2, angle-context*)
        print(o, "&")
        hsf(o, b(t), 2, angle-context*)
      ;Atomic
      (t:TOf) :
        write(o, name(n(t)))
        val args = match(type(t)) :
          (t:TTuple) : types(t)
          (t:TGradual) : List()
        if not empty?(args) :
          print(o, "<")
          hsfs(o, args, 0, true)
          print(o, ">")
      (t:TVar) :
        match(/name(t)) :
          (n:Symbol) : write(o, n)
          (_:False) : write(o, name(n(t)))
      (t:TCap) :
        print(o, "?")
        match(/name(t)) :
          (n:Symbol) : write(o, n)
          (_:False) : write(o, name(n(t)))
      (t:TGradual|TUVar) :
        print(o, "?")
      (t:TBot) :
        print(o, "Void")
      (t:TTuple) :
        print(o, "[")
        hsfs(o, types(t), 0, false)
        print(o, "]")
    print(o, ")") when paren?

  ;Return the formatting function.
  new Formatter :
    defmethod format (this, t:Type) :
      wrap-printable $ hsf{_, t, 0, false}

;Helper: Wrap closure in printable object
defn wrap-printable (f:OutputStream -> False) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      f(o)