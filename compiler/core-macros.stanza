;See License.txt for details about licensing.

defpackage stz/core-macros :
   import core
   import macro-utils
   import collections
   import stz/params
   import stz/utils
   import parser/macro-syntax
   import stz/preparsed-template

;============================================================
;==================== Exceptions ============================
;============================================================

public deftype CoreSyntaxError <: Exception

defn CSE (info:False|FileInfo, msg) :
  new CoreSyntaxError :
    defmethod print (o:OutputStream, this) :
      print{o, _} $ match(info) :
        (info:FileInfo) : "%_: Syntax Error: %_" % [info msg]
        (info:False) : "Syntax Error: %_" % [msg]

;============================================================
;==================== Utilities =============================
;============================================================

defstruct ForBinding :
  name:Symbol
  values:List

defn wrap-info (info:False|FileInfo, x) :
   match(info) :
      (info:FileInfo) : Token(x, info)
      (info:False) : x

defstruct CatchClause :
  binder
  type: Maybe
  body

;============================================================
;====================== ChainedFn ===========================
;============================================================

;This "ChainedFn" datastructure is used to implement an
;exception for the precedence of the '$>' operator.
;
;Consider this expression:
;
;  fn (x) : x $> f
;
;The precedence of $> ensures that the above parses as:
;
;  fn (x) : (x $> f)
;
;instead of the following:
;
;  (fn (x) : x) $> f
;
;This is desired behaviour. Unfortunately, there is an
;extremely common use case which conflicts with the above
;behaviour:
;
;  x $> fn (x) :
;         x + 1
;    $> println
;
;To make it clear, we will rewrite the above on a single line:
;
;  x $> fn (x) : (x + 1) $> println
;
;According to the standard behaviour, the expression above
;should parse to this:
;
;  x $> (fn (x) : ((x + 1) $> println))
;
;which is not what is desired. Here is what is actually desired:
;
;  x $> (fn (x) : (x + 1)) $> println
;
;This use case is so common that:
;
;1) The standard behaviour is essentially never the desired behaviour.
;
;2) The standard behaviour is strange enough that users cannot
;   figure out what is happening.
;
;For these reasons, we specially implement an exception to the
;precedence rules of the $> operator.

;Represents a chained function expression, which is used to
;handle a common case in $> expressions.
defstruct ChainedFn :
  fnform
  tail

;Compile a chained function expression.
;- v: The expression at the very beginning of the chain.
defn compile (v, f:ChainedFn) -> ? :
  defn expand-tail (x) :
    match(x) :
      (f:ChainedFn) : qquote(~(fnform(f)) $> ~@(expand-tail(tail(f))))
      (x) : List(x)
  qquote(~ v $> ~@(expand-tail(f)))

;============================================================
;================== Duplicate Errors ========================
;============================================================

;Return all of the duplicate items in xs.
defn duplicates<?T> (xs:Seqable<?T&Equalable&Hashable>) -> Tuple<T> :
  val seen = HashSet<T>()
  val duplicates = HashSet<T>()
  for x in xs do :
    add(duplicates, x) when not add(seen, x)      
  to-tuple(duplicates)

defn ensure-no-duplicate-entries! (info:FileInfo|False, entries:Seqable<KeyValue<Symbol,?>>) :
  val keys = duplicates(seq(key,entries))
  if not empty?(keys) :
    val keystrs = for k in keys seq : "'%~'" % [k]
    val plural-s = "s" when length(keys) > 1 else ""
    val msg = "The option%_ %, cannot be used more than once." % [plural-s, keystrs]
    throw(CSE(info, msg))

;============================================================
;============== Anonymous Function Compilation ==============
;============================================================

deftype AfnArg
defstruct AfnNumberedArg <: AfnArg: (index:Int)
defstruct AfnStandardArg <: AfnArg

defstruct AfnArgEntry :
  arg: AfnArg
  type: Maybe

defsyntax anonymous-function-body :
  import type! from core
  
  ;Classify form as an anonymous function argument.
  ;Returns false if not an argument.
  ;Either _ or _0 is accepted as arguments.
  defn classify-arg (x) -> AfnArg|False :
    match(unwrap-token(x)) :
      (s:StringSymbol) :
        if s == `_ :
          AfnStandardArg()
        else if prefix?(name(s), "_") :
          val index-str = name(s)[1 to false]
          match(to-int(index-str)) :
            (x:Int) : AfnNumberedArg(x) when x >= 0 and x < 256
            (x) : false
      (f) :
        false

  ;Returns true if the given form is an appropriate
  ;argument placeholder.
  defn placeholder? (x) -> True|False :
    classify-arg(x) is-not False  

  ;Syntax of anonymous function form
  public defproduction aform
  defrule aform = (?h:((@afn | @do-afn | @quote | $quote) _ ...))
  defrule aform = (?p:#placeholder ~ : ?t:#type!) :
    AfnArgEntry(p, One(t))
  defrule aform = (?p:#placeholder) :
    AfnArgEntry(p, None())
  defrule aform = ((?p:#aform ...))
  defrule aform = (?x)

  ;Represents a _ or _n
  defproduction placeholder: AfnArg
  defrule placeholder = (?p) when placeholder?(p) :
    classify-arg(p) as AfnArg

val MULTIFN-TEMPLATE = CoreExp $ `(
  multifn :
    () : ~body
    ( ~x : ?) : ~body)

defn compile-afn-body (afn-info:FileInfo|False, body:List) :
  ;Create arguments.
  val arg-table = IntTable-init<Symbol>(gensym{`arg})
  val arg-list = Vector<AfnArgEntry>()
  defn make-arg (e:AfnArgEntry) -> Symbol :
    add(arg-list, e)
    val index = match(arg(e)) :
      (a:AfnNumberedArg) : index(a)
      (a:AfnStandardArg) : length(arg-list) - 1
    arg-table[index]

  ;Verify proper form.
  defn verify-form () -> True|False :
    ;Verify that either the user uses standard arguments
    ;or numbered arguments but not both.
    val standard-arg? = any?({arg(_) is AfnStandardArg}, arg-list)
    val numbered-arg? = any?({arg(_) is AfnNumberedArg}, arg-list)
    if standard-arg? and numbered-arg? :
      val msg = "Anonymous function cannot contain both standard placeholder \
                 arguments as well as numbered placeholder arguments."
      throw(CSE(afn-info, msg))

  ;Assuming that it is a anonymous function using numbered arguments,
  ;construct the type table. Ensure that all types are consistent.
  defn type-table () :
    val table = IntTable<?>()
    defn arg-index (e:AfnArgEntry) : index(arg(e) as AfnNumberedArg)
    defn arg-type (e:AfnArgEntry) : value!(type(e))
    defn typed? (e:AfnArgEntry) : not empty?(type(e))
    for group in group-by(arg-index, arg-type, filter(typed?,arg-list)) do :
      val types = unique(seq(unwrap-all,value(group)))
      if length(types) > 1 :
        val msg = "Argument %_ in anonymous function is declared repeatedly with \
                   different types: %,."
        throw(CSE(afn-info, msg % [key(group), types]))
      table[key(group)] = head(value(group))
    table

  ;Construct arg list, for functions with one argument or more.
  defn make-arg-list () -> List :
    match(arg(arg-list[0])) :
      (a:AfnStandardArg) :
        for (entry in arg-list, index in 0 to false) seq-append :
          val name = arg-table[index]
          if empty?(type(entry)) : List(name)
          else : List(name, `:, value!(type(entry)))
      (a:AfnNumberedArg) :
        val max-arg = maximum(keys(arg-table))
        for i in 0 through max-arg seq-append :
          val types = type-table()
          val name = arg-table[i]
          if key?(types, i) : List(name, `:, types[i])
          else : List(name)

  ;Create the modified body.
  ;Calls `make-arg` on each occurrence of a placeholder.
  defn replace (xs) -> ? :
    match(unwrap-token(xs)) :
      (xs*:List) : sub-token-item?(xs, map(replace, xs*))
      (xs*:AfnArgEntry) : make-arg(xs*)
      (xs*) : xs

  ;Perform substitutions on body
  val aform = parse-syntax[anonymous-function-body / #aform](List(body))
  val replaced = replace(aform)
  verify-form()
  val body* = parse-syntax[core + current-overlays / #exp$](replaced)
  if empty?(arg-list) :
    fill(MULTIFN-TEMPLATE, [
      `body => body*
      `x => gensym(`x)])
  else :
    val template = `(fn args : body)
    parse-syntax[core / #exp](
       fill-template(template, [
          `body => body*,
          `args => make-arg-list()]))

;============================================================
;====================== DefStruct Compilation ===============
;============================================================

deftype StructField
defmulti bindings (s:StructField, first?:True|False, sname:Token|Symbol) -> Tuple
defmulti argument? (s:StructField) -> True|False|Symbol
defmulti voidable? (s:StructField) -> True|False
defmulti has-default? (s:StructField) -> True|False
defmulti has-updater? (s:StructField) -> True|False
defmulti has-init? (s:StructField) -> True|False
defmulti has-ensure? (s:StructField) -> True|False

defn StructField (name:Token|Symbol,              ;Name of field
                  doc-string:Maybe,               ;Doc String
                  type,                           ;Type of field
                  as-method?:True|False,          ;Define as method?
                  setter:Maybe,                   ;Setter for field
                  updater:Maybe,                  ;Updater for field
                  ensure:Maybe,                   ;Precondition for field
                  init:Maybe,                     ;Initial value for field
                  default:Maybe) :                ;Default value for field
  val box? = not empty?(setter)
  val local-name = gensym(name) when box? else name
  val init-value = match(init, default) :
    (i:One, d) : value!(i)
    (i, d:One) : value!(d)
    (i, d) : false
  new StructField :
    defmethod argument? (this) :
      match(init, default) :
        (i:One, d) : false
        (i, d:One) : `optional
        (i, d) : true
    defmethod voidable? (this) :
      defn void? (x:Maybe) : unwrap-token(value?(x)) == `void
      void?(init) or void?(default)
    defmethod has-default? (this) :
      not empty?(default)
    defmethod has-updater? (this) :
      not empty?(updater)
    defmethod has-init? (this) :
      not empty?(init)
    defmethod has-ensure? (this) :
      not empty?(ensure)
    defmethod bindings (this, first?:True|False, sname:Token|Symbol) :
     [`name => name
      `type => type
      `first? => choice(first?)
      `doc-string => value?(doc-string)
      `doc-string? => choice(not empty?(doc-string))
      `description => to-string("field %_/%_" % [sname, name])
      `full-name => to-string("%_/%_" % [sname, name])
      `method? => choice(as-method?)
      `setter? => choice(not empty?(setter))
      `setter => value?(setter)
      `updater? => choice(not empty?(updater))
      `updater => value?(updater)
      `ensure? => choice(not empty?(ensure))
      `ensure => value?(ensure)
      `voidable? => choice(voidable?(this))
      `box? => choice(box?)
      `local-name => local-name
      `init? => choice(not empty?(init))
      `init-value => init-value]

defn gen-defstruct (sname:Token|Symbol,
                    targs:List,
                    parent:Maybe,
                    fields:List<StructField>,
                    constructor:Maybe,
                    printer?:True|False,
                    writer?:True|False,
                    equalable?:True|False,
                    hashable?:True|False,
                    meta-utils?:True|False) :
  ;===== Bindings =====
  val field-bindings = for (f in fields, i in 0 to false) map :
    bindings(f, i == 0, sname)

  ;===== Subconstructors =====
  defn mark-optional (num-opt-args:Int) :
    defn cons (entry:Symbol, value:?, bs:Tuple<KeyValue<Symbol,?>>) :
      to-tuple(cat([entry => value], bs))
    val counter = to-seq(0 to false)
    for (bs in field-bindings, f in fields) map :
      val arg? = switch(argument?(f)) :
        true : true
        false : false
        `optional : next(counter) < num-opt-args
      val new-bs = [
        `arg? => choice(arg?)
        `initialized? => choice(arg? or not voidable?(f))]
      to-tuple(cat(new-bs, bs))
      
  val num-optional = count({argument?(_) == `optional}, fields)
  val sub-constructors = for n in 0 through num-optional map :
    [`fields => nested(mark-optional(n))]

  ;Do we need sub-constructors?
  val sub-constructors? = (has-defaults? or (has-updaters? and (has-inits? or has-ensures?))) where :
    val has-defaults? = any?(has-default?, fields)
    val has-updaters? = any?(has-updater?, fields)
    val has-inits? = any?(has-init?, fields)
    val has-ensures? = any?(has-ensure?, fields)

  ;===== Define Template =====
  val template = `((
    ;Type declaration
    deftype Struct<targs{name}> meta-utils?{
                                  <: parent?{Parent &}{} core/meta-utils/HasMetaUtils
                                }{
                                  parent?{<: Parent}{}
                                }
    
    sub-constructors?{      
      ;Main constructor
      defn MainConstructor<targs{name}> (fields{name:voidable?{type|Uninitialized}{type}}) :
        ;Local variables      
        fields{box?{
          var local-name:voidable?{type|Uninitialized}{type} = name
        }{}}
        
        new Struct<targs{name}> :
          fields{
            defmethod name (this) :
              voidable?{
                fatal("Field %_ has not been initialized." % [full-name]) when local-name is Uninitialized
                local-name as type
              }{
                local-name
              }
            setter?{
              defmethod setter (this, value:type) :
                ensure?{
                  #if-not-defined(OPTIMIZE) :
                    ensure(description, value)
                }{}
                local-name = value
            }{}
            updater?{
              defmethod updater (this, local-name:type) :
                ensure?{
                  #if-not-defined(OPTIMIZE) :
                    ensure(description, local-name)
                }{}
                MainConstructor<targs{name}>(fields{local-name})
            }{}
          }
          printer?{
            defmethod print (o:OutputStream, this) :
              val print-items = [
                fields{
                  voidable?{
                    if local-name is Uninitialized : "%~ = void" % [`name]
                    else : "%~ = %~" % [`name, local-name]
                  }{
                    "%~ = %~" % [`name, local-name]
                  }
                }
              ]            
              print(o, "%~(%,)" % [`Struct, print-items])
          }{}
          writer?{
            defmethod write (o:OutputStream, this) :
              val write-items = Vector<?>()
              fields{
                init?{}{
                  voidable?{
                    if local-name is-not Uninitialized :
                      collections/add(write-items, "%~" % [local-name])
                  }{
                    collections/add(write-items, "%~" % [local-name])
                  }
                }
              }
              print(o, "%~(%,)" % [`Struct, write-items])
          }{}
      ;Sub constructors
      sub-constructors{
        defn Constructor<targs{name}> (fields{arg?{name:type}{}}) :
          ;Initialize arguments
          fields{
            arg?{}{
              voidable?{
                var name:type
              }{
                val name:type = init-value
              }            
            }
          }
          
          ;Check preconditions
          fields{ensure?{
            initialized?{
              ;If it is passed in explicitly, then check it
              #if-not-defined(OPTIMIZE) :
                ensure(description, name)
            }{}
          }{}}

          ;Call main constructor
          MainConstructor<targs{name}>(fields{initialized?{name}{uninitialized}})
      }
    }{      
      ;Main constructor
      defn Constructor<targs{name}> (fields{init?{}{name:type}}) :
        ;Initialize init fields
        fields{
          init?{
            voidable?{
              var name:type
            }{
              val name:type = init-value
            }            
          }{}
        }

        ;Check preconditions
        fields{ensure?{
          voidable?{}{
            ;If it is not void, then check it
            #if-not-defined(OPTIMIZE) :
              ensure(description, name)            
          }
        }{}}

        ;Initialize boxes
        fields{box?{
          voidable?{
            var local-name:type|Uninitialized = uninitialized
          }{
            var local-name:type = name
          }
        }{}}
        
        new Struct<targs{name}> :
          fields{
            defmethod name (this) :
              voidable?{
                fatal("Field %_ has not been initialized." % [full-name]) when local-name is Uninitialized
                local-name as type
              }{
                local-name
              }
            setter?{
              defmethod setter (this, value:type) :
                ensure?{
                  #if-not-defined(OPTIMIZE) :
                    ensure(description, value)
                }{}
                local-name = value
            }{}
            updater?{
              defmethod updater (this, local-name:type) :
                ensure?{
                  #if-not-defined(OPTIMIZE) :
                    ensure(description, local-name)
                }{}
                Constructor<targs{name}>(fields{local-name})
            }{}
          }
          printer?{
            defmethod print (o:OutputStream, this) :
              val print-items = [
                fields{
                  voidable?{
                    if local-name is Uninitialized : "%~ = void" % [`name]
                    else : "%~ = %~" % [`name, local-name]
                  }{
                    "%~ = %~" % [`name, local-name]
                  }
                }
              ]            
              print(o, "%~(%,)" % [`Struct, print-items])
          }{}
          writer?{
            defmethod write (o:OutputStream, this) :
              val write-items = Vector<?>()
              fields{
                init?{}{
                  voidable?{
                    if local-name is-not Uninitialized :
                      collections/add(write-items, "%~" % [local-name])
                  }{
                    collections/add(write-items, "%~" % [local-name])
                  }
                }
              }
              print(o, "%~(%,)" % [`Struct, write-items])
          }{}
    }

    ;Multi declarations
    fields{method?{}{
      doc-string?{ doc-string }{ }
      defmulti name<targs{?name}> (x:Struct<targs{?name}>) -> type
      setter?{defmulti setter<targs{?name}> (x:Struct<targs{?name}>, v:type) -> False}{}
      updater?{defmulti updater<targs{?name}> (x:Struct<targs{?name}>, v:type) -> Struct<targs{name}>}{}
    }}

    ;Equalable definition
    equalable?{
      defmethod equal? (lhs:Struct, rhs:Struct) :
        has-fields?{
          fields{first?{}{and} equal?(name(lhs), name(rhs))}
        }{
          true
        }
    }{}

    ;Hashable definition
    hashable?{
      defmethod hash (x:Struct) :
        hash([Struct-name fields{name(x)}])
    }{}

    ;Metaprogramming Utilities
    meta-utils?{
      defmethod core/meta-utils/field-values (x:Struct) :
        [fields{name(x)}]
      defmethod core/meta-utils/field-names (x:Struct) :
        [fields{`name}]
      defmethod core/meta-utils/field-accessors (x:Struct) :
        val accessors = [fields{name upcast-as (Struct -> ?)}]
        accessors as Tuple<(core/meta-utils/HasMetaUtils -> ?)>
      defmethod core/meta-utils/field-entries (x:Struct) :
        [fields{`name => name(x)}]
    }{}
  ))

  ;===== Fill Template =====
  val targ-bindings = nested $
    for targ in targs map : [
      `name => targ]
      
  fill-template(template, [
    `Struct => sname
    `Struct-name => to-string(sname)
    `targs => targ-bindings
    `parent? => choice(not empty?(parent))
    `Parent => value?(parent)
    `fields => nested(field-bindings)
    `has-fields? => choice(not empty?(fields))
    `value => gensym(`value)
    `MainConstructor => gensym(sname)
    `Constructor => value?(constructor, sname)
    `sub-constructors? => choice(sub-constructors?)
    `sub-constructors => nested(sub-constructors)
    `Uninitialized => `core/Uninitialized
    `uninitialized => `core/uninitialized    
    `OutputStream => `core/OutputStream
    `Vector => `collections/Vector
    `print => `core/print
    `fatal => `core/fatal
    `equal? => `core/equal?
    `hash => `core/hash
    `o => gensym(`o)
    `lhs => gensym(`lhs)
    `rhs => gensym(`rhs)
    `x => gensym(`x)
    `printer? => choice(printer?)
    `print-items => gensym(`print-items)
    `writer? => choice(writer?)
    `write-items => gensym(`write-items)
    `equalable? => choice(equalable?)
    `hashable? => choice(hashable?)
    `meta-utils? => choice(meta-utils?)])

;============================================================
;===================== Function Header ======================
;============================================================

;------------------------------------------------------------
;--------------------- Parse Structures ---------------------
;------------------------------------------------------------

;Examples of various arguments.
;
;  defn func<T> (a:Int,
;                [b,c]:Int = 0,
;                c:Int
;                d:String,
;                e:String = ?,
;                rest ...) -> Type :
;    body

;Represent the argument specifiers and return type of
;a 'defn' header.
defstruct DefnHeader :
  args:Tuple<ArgBinding>
  a2:Maybe  

;Represents each of the argument binding.
deftype ArgBinding

;Retrieve the optional type specifier of the binding.
defmulti name (b:ArgBinding) -> ?
defmulti type (b:ArgBinding) -> Maybe

;Example: c:Int = 30
;- optional-name: If a default value is provided, then it's a gensym to act
;  as the original name of the argmmmment.
defstruct PositionalArg <: ArgBinding :
  name with: (as-method => true)
  optional-name
  type:Maybe with: (as-method => true)
  optional?:True|False
  default:Maybe

;Example: param c:Int = 30
defstruct KeywordArg <: ArgBinding :
  name with: (as-method => true)
  optional-name
  type:Maybe with: (as-method => true)
  optional?:True|False
  default:Maybe

;Example: rest:Int ...
defstruct VarArg <: ArgBinding :
  name with: (as-method => true)
  type:Maybe with: (as-method => true)

;------------------------------------------------------------
;--------------------- Compilation --------------------------
;------------------------------------------------------------

;Example of simple function.
;
;  ($defn ($of myfunc T ($cap S)) (a, b, ($tuple a c)) (Int, String) ($none)
;    ($body1)
;    ($body2))
;
;Other argument specifiers.
;
;  ($optional a)
;  ($keyword a)
;  ($optional-keyword a)
;  ($rest a)
;

;Retrieved the compiled list of argument specifiers in the header.
defn compile-args (h:DefnHeader) -> List :
  to-list $ for arg in args(h) seq :
    match(arg) :
      (arg:PositionalArg) :
        if optional?(arg) : qquote($optional ~(optional-name(arg)))
        else : name(arg)
      (arg:KeywordArg) :
        if optional?(arg) : qquote($optional-keyword ~(name(arg)))
        else : qquote($keyword ~(name(arg)))
      (arg:VarArg) :
        qquote($rest ~(name(arg)))

;Retrieved the compiled list of argument types in the header.
defn compile-a1 (h:DefnHeader) -> List :
  to-list $ for arg in args(h) seq :
    if empty?(type(arg)) : `($none)
    else : value!(type(arg))

;Retrieve the compiled return type of the header.
defn compile-a2 (h:DefnHeader) -> ? :
  if empty?(a2(h)) : `($none)
  else : value!(a2(h))

;Retrieve the args, types, and return type.
defn compile-args-a1-a2-prelude (h:DefnHeader) -> [List, List, ?, ?] :
  [compile-args(h),
   compile-a1(h),
   compile-a2(h)
   compile-prelude(h)]

;Retrieve the args, types, and return type.
defn compile-args-a1-a2-ls-prelude (h:DefnHeader) -> [List, List, ?, ?] :
  [compile-args(h),
   compile-a1(h),
   compile-a2(h)
   compile-ls-prelude(h)]

;Retrieve just the args and types.
defn compile-args-a1-a2-no-prelude (h:DefnHeader) -> [List, List, ?] :
  for arg in args(h) do :
    match(arg:PositionalArg|KeywordArg) :
      if not empty?(default(arg)) :
        val info = match(value!(default(arg))) :
                     (t:Token) : info(t)
                     (t) : false
        CSE(info,
            "Default values are supported for methods, but not multis. Use 'arg = ?' to \
             indicate that a multi argument is optional.")
  [compile-args(h),
   compile-a1(h),
   compile-a2(h)]

;Compile the body prelude of the given header.
defn compile-prelude (h:DefnHeader) -> ? :
  val has-defaults? = for arg in args(h) any? :
    match(arg:PositionalArg|KeywordArg) :
      not empty?(default(arg))
  if not has-defaults? :
    `($begin)
  else :
    ;Define the template to use.
    val template = `(
      args{
        default-value?{
          destructure?{
            val tmp =
              if core/empty?(arg) : default-value
              else : core/value!(arg)
            ($def binding ($none) tmp)
          }{
            val binding =
              if core/empty?(arg) : default-value
              else : core/value!(arg)
          }
        }
      }
    )

    ;Compile the bindings.
    defn bindings (a:ArgBinding) :
      [
        `default-value? => nested? $
          match(a:PositionalArg|KeywordArg) :
            if empty?(default(a)) :
              None()
            else :
              One $ [
                `destructure? => choice(unwrap-token(name(a)) is-not Symbol)
                `binding => name(a)
                `arg => optional-name(a)
                `default-value => value!(default(a))
                `tmp => gensym(`tmp)]
          else :
            None()
      ]

    defn bindings (h:DefnHeader) :
      [`args => nested(map(bindings, args(h)))]

    val filled = fill-template(template, bindings(h))
    parse-syntax[core / #exp](List(filled))

;Compile the LoStanza prelude of the given header.
defn compile-ls-prelude (h:DefnHeader) -> ? :
  val has-defaults? = for arg in args(h) any? :
    match(arg:PositionalArg|KeywordArg) :
      not empty?(default(arg))
  if not has-defaults? :
    `($begin)
  else :
    ;Define the template to use.
    val template = `(
      args{
        default-value?{
          var tmp:type
          if core/empty?(arg) == true :
            tmp = default-value
          else :
            tmp = core/value!(arg)
          val name = tmp
        }
      }
    )

    ;Compile the bindings.
    defn bindings (a:ArgBinding) :
      [  
        `default-value? => nested? $
          match(a:PositionalArg|KeywordArg) :
            if empty?(default(a)) :
              None()
            else :
              One $ [
                `tmp => gensym(`tmp)
                `type => value!(type(a))
                `default-value => value!(default(a))
                `arg => optional-name(a)
                `name => name(a)]
          else :
            None()
      ]

    defn bindings (h:DefnHeader) :
      [`args => nested(map(bindings, args(h)))]

    val filled = fill-template(template, bindings(h))
    println("FILLED: %_" % [filled])
    val result = parse-syntax[core / #ls-stmt](List(filled))
    println("RESULT: %_"% [result])
    result

;Helper: Create an optional nested binding.
defn nested? (xs:Maybe<Tuple<KeyValue<Symbol,?>>>) -> Nested :
  if empty?(xs) :
    nested([])
  else :
    nested([value!(xs)])

;============================================================
;==================== Enum Compilation ======================
;============================================================

defstruct EnumDef :
  name
  parent: Maybe
  args: Tuple

defn compile (def:EnumDef) :
  defn compile-arg (arg, index:Int) :
    [`Name => arg
     `to-string-Name => to-string(arg)
     `index => index]
  defn compile-args (args:Tuple) :
    nested $ to-tuple $ seq(compile-arg, args, 0 to false)  

  ;Compile Pattern
  val template = `((
    deftype Enum <: Equalable & Hashable parent?{& parent}{}
    args{
      deftype Name <: Enum
      val Name = new Name
    }
    defmethod equal? (a:Enum, b:Enum) : to-int(a) == to-int(b)
    defmethod hash (x:Enum) : to-int(x)

    defn to-int (x:Enum) -> Int :
      match(x) :
        args{
          (x:Name) : index
        }

    defmethod print (o:OutputStream, x:Enum) :
      match(x) :
        args{
          (x:Name) : print(o, to-string-Name)
        }

    val Enum-length = num-args
    val enum-vals = [args{Name}]
    defn Enum? (i:Int) -> Enum|False :
      enum-vals[i] when i >= 0 and i < num-args
    defn Enum (i:Int) -> Enum :
      if i >= 0 and i < num-args : enum-vals[i]
      else : fatal("Cannot convert int %_ into enum %_." % [i, to-string-Enum])))
  fill-template(template, [
    ;Place holders
    `Enum => name(def)
    `Enum? => symbol-join([name(def), "?"])
    `Enum-length => symbol-join([name(def), "-length"])
    `to-string-Enum => to-string(name(def))
    `parent? => choice(not empty?(parent(def)))
    `parent => value?(parent(def))
    `args => compile-args(args(def))
    `num-args => length(args(def))
    ;Unique
    `enum-vals => gensym(`enum-vals)    
    ;Core Qualified
    `False => `core/False
    `Equalable => `core/Equalable
    `Hashable => `core/Hashable
    `print => `core/print
    `OutputStream => `core/OutputStream
    `equal? => `core/equal?
    `hash => `core/hash])

;============================================================
;================= Core Syntax Package ======================
;============================================================
defsyntax core :
   ;               Tags
   ;               ====

   val TAG-TABLE = HashSet<Symbol>()
   for tag in `(
      $package $import $prefix-of $prefix $public $protected $private $doc $deftype $defchild $def
      $defvar $defn $defn* $defmulti $defmethod $defmethod* $fn $fn*
      $multi $begin $let $match $branch $new $as $as? $set $do
      $prim $tuple $quote $none $of $and $or $->
      $cap $void $? $ls-new $ls-struct $ls-addr $ls-addr! $ls-deref
      $ls-slot $ls-field $ls-do $ls-call-c $ls-prim $ls-sizeof $ls-tagof $ls-as
      $ls-letexp $ls-and $ls-or $ls-set $ls-labels $ls-block $ls-goto $ls-return
      $ls-let $ls-if $ls-match $ls-branch $ls-func $ls-def $ls-defvar $ls-deftype $ls-deffield
      $ls-defn $ls-defn* $ls-defmethod $ls-defmethod* $ls-extern $ls-extern-fn $ls-byte $ls-int
      $ls-long $ls-float $ls-double $ls-? $ls-of $ls-ptr $ls-ref $ls-fn) do :
      add(TAG-TABLE, tag)

   public defproduction stanza-tag: Symbol|Token
   defn stanza-tag? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : TAG-TABLE[x]
         (x) : false
   defrule stanza-tag = (?x) when stanza-tag?(x)

   ;                Lexer Tags
   ;                ==========

   val LEXER-TAG-TABLE = HashSet<Symbol>()
   for tag in `(@do @do-afn @afn @get @tuple @of @cap @quote :) do :
      add(LEXER-TAG-TABLE, tag)
   defn lexer-tag? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : LEXER-TAG-TABLE[x]
         (x) : false
   public defproduction lexer-tag: Symbol|Token      
   defrule lexer-tag = (?x) when lexer-tag?(x)

   ;                   Primitives
   ;                   ==========
   defproduction bool : Token|True|False
   defrule bool = (?v:true)
   defrule bool = (?v:false)

   defproduction string : Token|String
   defrule string = (?x) when unwrap-token(x) is String

   defproduction symbol : Token|Symbol
   defrule symbol = (?x) when unwrap-token(x) is Symbol

   ;                Error Handling
   ;                ==============

   defproduction bool! : Token|True|False
   defrule bool! = (?v:#bool)
   fail-if bool! = () : CSE(closest-info(), "Expected a true/false value here.")

   public defproduction type!
   public defproduction type$
   public defproduction types!
   defrule type! = (?x:#type)
   fail-if type! = () : CSE(closest-info(), "Type expected here.")
   defrule type$ = (?x:#type! (! _))
   fail-if type$ = () : CSE(closest-info(), "Expected a single type here.")      
   defrule types! = (?x:#type! ...)

   public defproduction id!
   public defproduction id$
   public defproduction ids!
   defrule id! = (?x:#id)
   fail-if id! = () : CSE(closest-info(), "Identifier expected here.")
   defrule id$ = (?x:#id! (! _))
   fail-if id$ = () : CSE(closest-info(), "Expected an identifier here.")
   defrule ids! = (?x:#id! ...)

   public defproduction exp!
   public defproduction exp$
   public defproduction exps!
   defrule exp! = (?x:#exp)
   fail-if exp! = () : CSE(closest-info(), "Expression expected here.")
   defrule exp$ = (?x:#exp! (! _))
   fail-if exp$ = () : CSE(closest-info(), "Expected a single expression here.")
   defrule exps! = (?x:#exp! ...)

   public defproduction :!
   defrule :! = (?x: ~ :)
   fail-if :! = () : CSE(closest-info(), "Colon expected here.")

   defproduction type1!
   defrule type1! = (?x:#type1)
   fail-if type1! = () : CSE(closest-info(), "Expected a type here.")

   defproduction exp0!
   defrule exp0! = (?x:#exp0)
   fail-if exp0! = () : CSE(closest-info(), "Expected an expression here.")

   defproduction exp1!
   defrule exp1! = (?x:#exp1)
   fail-if exp1! = () : CSE(closest-info(), "Expected an expression here.")

   defproduction exp2!
   defrule exp2! = (?x:#exp2)
   fail-if exp2! = () : CSE(closest-info(), "Expected an expression here.")

   defproduction exp3!
   defrule exp3! = (?x:#exp3)
   fail-if exp3! = () : CSE(closest-info(), "Expected an expression here.")

   defproduction exp4!
   defrule exp4! = (?x:#exp4)
   fail-if exp4! = () : CSE(closest-info(), "Expected an expression here.")

   ;                Type Definitions
   ;                ================

   public defproduction type
   public defproduction type0
   public defproduction type1

   defrule type = (?x:#type0 -> ?y:#type!) : qquote($-> (~ x) ~ y)
   defrule type = (() -> ?y:#type!) : qquote($-> () ~ y)
   defrule type = ((?x0:#type ?xs:#types!) -> ?y:#type!) : qquote($-> (~ x0 ~@ xs) ~ y)
   defrule type = (?x:#type0)

   defrule type0 = (?x:#type0 & ?y:#type1!) : qquote($and ~ x ~ y)
   defrule type0 = (?x:#type0 ~ | ?y:#type1!) : qquote($or ~ x ~ y)
   defrule type0 = (?x:#type1)

   defrule type1 = (?x:(#stanza-tag _ ...))
   defrule type1 = ((~ @cap ?x:#id$)) : qquote($cap ~ x)
   defrule type1 = ([?xs:#types!]) : qquote($tuple ~@ xs)
   defrule type1 = ((?x:#type))
   defrule type1 = (?x:#id<?ys:#types!>) : qquote($of ~ x ~@ ys)
   defrule type1 = (Void) : `($void)
   defrule type1 = (?) : `($?)
   defrule type1 = (?x:#id)

   defrule id != (-> | & | ~ | | Void | ?)

   ;                Operator Definitions
   ;                ====================

   public defproduction exp  ; and / or
   public defproduction exp0 ; not, ==, !=, <, <=, >, >=
   public defproduction exp1 ; +, -, |
   public defproduction exp2 ; *, %, /, &, ^
   public defproduction exp3 ; <<, >>, >>>
   public defproduction exp4 ; others

   ;Logical Operators
   val and-template = CoreExp $ `(if ~x : ~y upcast-as core/True|core/False)
   defrule exp = (?x:#exp and ?y:#exp0!) :
      fill(and-template, [`x => x, `y => y])

   val or-template = CoreExp $ `(
     if ~x : true
     else : ~y upcast-as core/True|core/False)
   defrule exp = (?x:#exp or ?y:#exp0!) :
     fill(or-template, [
       `x => x
       `y => y])
   defrule exp = (?e:#exp0)

   ;Comparison Operators
   public defproduction op0 : Symbol
   defrule op0 = (==) : `equal?
   defrule op0 = (!=) : `not-equal?
   defrule op0 = (<) : `less?
   defrule op0 = (<=) : `less-eq?
   defrule op0 = (>) : `greater?
   defrule op0 = (>=) : `greater-eq?
   defrule exp0 = (?x:#exp0 ?f:#op0 ?y:#exp1!) : qquote($do ~ f ~ x ~ y)
   defrule exp0 = (not ?x:#exp0!) : qquote($do core/complement ~ x)
   defrule exp0 = (?x:#exp1)

   ;Additive Operators
   public defproduction op1 : Symbol
   defrule op1 = (+) : `plus
   defrule op1 = (-) : `minus
   defrule op1 = (~ |) : `bit-or
   defrule exp1 = (?x:#exp1 ?f:#op1 ?y:#exp2!) : qquote($do ~ f ~ x ~ y)
   defrule exp1 = (?x:#exp2)

   ;Multiplicative Operators
   public defproduction op2 : Symbol
   defrule op2 = (*) : `times
   defrule op2 = (%) : `modulo
   defrule op2 = (/) : `divide
   defrule op2 = (&) : `bit-and
   defrule op2 = (^) : `bit-xor
   defrule exp2 = (?x:#exp2 ?f:#op2 ?y:#exp3!) : qquote($do ~ f ~ x ~ y)
   defrule exp2 = (?x:#exp3)

   ;Shift Operators
   public defproduction op3 : Symbol
   defrule op3 = (<<) : `shift-left
   defrule op3 = (>>) : `shift-right
   defrule op3 = (>>>) : `arithmetic-shift-right
   defrule exp3 = (?x:#exp3 ?f:#op3 ?y:#exp4!) : qquote($do ~ f ~ x ~ y)
   defrule exp3 = (?x:#exp4)

   defrule id != (and | or | not | #op0 | #op1 | #op2 | #op3)

   ;               Expressions
   ;               ===========
   defrule exp4 = (?x:(#stanza-tag _ ...))

   ;          User Defined Expressions
   ;          ========================
   import exp4 rules as user-exp4
   defrule exp4 = inline #user-exp4

   ;                 Tuple Call
   ;                 ==========
   ;Not yet implemented
   

   ;                Doc String
   ;                ==========

   defproduction doc-string
   defrule doc-string = (doc : ?x:#string) : qquote($doc ~ x)

   defproduction doc-string? : Maybe
   defrule doc-string? = (?x:#doc-string) : One(x)
   defrule doc-string? = () : None()

   defrule exp4 = (?x:#doc-string)

   ;                Function Call
   ;                =============
   defrule exp4 = (?x:#exp4(?ys:#callarg! ...)) : qquote($do ~ x ~@ ys)

   ;Named Arguments.
   defproduction callarg!
   defrule callarg! = (?keyword:#id = ?e:#exp!) : qquote($keywordarg ~ keyword ~ e)
   defrule callarg! = (?e:#exp!)

   ;               Type Application
   ;               ================
   defrule exp4 = (?x:#exp4<?ys:#types!>) : qquote($of ~ x ~@ ys)

   ;                 Curried Functions
   ;                 =================
   defrule exp4 = (?x:#exp4{?body ...}) :
      parse-syntax[core + current-overlays / #exp](qquote({~ x(~@ body)}))

   ;                  Set and Get
   ;                  ===========
   defrule exp4 = (?x:#exp4[?es:#exps!] = ?v:#exp!) : qquote($do set ~ x ~@ es ~ v)
   defrule exp4 = (?x:#exp4[?es:#exps!]) : qquote($do get ~ x ~@ es)

   ;                   Casts
   ;                   =====
   val as-template = CoreExp $ `(
     (match(~x) :
       (~r : ~type) : ~r
       (~r) : core/fail()) as ~type)

   defrule exp4 = (?x:#exp4 as? ?t:#type!) :
     fill(as-template, [
       `x => x
       `r => gensym(`r)
       `type => t])

   defrule exp4 = (?x:#exp4 as ?t:#type!) : qquote($as ~ x ~ t)
   defrule exp4 = (?x:#exp4 upcast-as ?t:#type!) : qquote($as? ~ x ~ t)
   defrule id != (as | upcast-as | as?)

   ;                 Defn Headers
   ;                 ============

   ;Represents the name of an argument.
   ;Cannot be 'param'. Allowed to be a tuple.
   defproduction argbinder
   defrule argbinder = (?x:#$binder)
   defrule argbinder != (param)

   ;Represents the name of an argument.
   ;Cannot be 'param'. Cannot be a tuple.
   defproduction argname
   defrule argname = (?x:#id)
   defrule argname != (param)

   ;Represents the optional type following an argument.
   defproduction argtype?: Maybe
   defrule argtype? = (: ?t:#type!) : One(t)
   defrule argtype? = () : None()

   ;Represents the default value following an argument.
   defproduction arg-default?: Maybe
   defrule arg-default? = (= void) : One(`void)
   defrule arg-default? = (= ?e:#exp!) : One(e)
   defrule arg-default? = () : None()

   ;Represents a single argument binding.
   defproduction fnargbinding: ArgBinding
   defrule fnargbinding = (?name:#argname ?type:#argtype? ~ ...) :
     VarArg(name, type)
   defrule fnargbinding = (param ?name:#argname ?type:#argtype? ?arg-default:#arg-default?) :
     val optional? = not empty?(arg-default)
     val default-value = None() when value?(arg-default) == `void else arg-default
     val opt-name = name when empty?(default-value) else gensym(`arg)
     KeywordArg(name, opt-name, type, optional?, default-value)
   defrule fnargbinding = (?name:#argbinder ?type:#argtype? ?arg-default:#arg-default?) :
     val optional? = not empty?(arg-default)
     val default-value = None() when value?(arg-default) == `void else arg-default
     val opt-name = name when empty?(default-value) else gensym(`arg)
     PositionalArg(name, opt-name, type, optional?, default-value)

   ;Represents an optional return type.
   defproduction return-type?: Maybe
   defrule return-type? = (-> ?t:#type!) : One(t)
   defrule return-type? = () : None()

   ;Error production.
   defproduction fnargbinding!: ArgBinding
   defrule fnargbinding! = (?x:#fnargbinding)
   fail-if fnargbinding! = () : CSE(closest-info(), "Invalid argument specifier.")
     
   ;Represents the entire defn header.
   defproduction defnheader:DefnHeader
   defrule defnheader = ((?args:#fnargbinding! ...) ?a2:#return-type?) :
     DefnHeader(to-tuple(args), a2)

   ;Error production
   defproduction defnheader!:DefnHeader
   fail-if defnheader! = ((@do _ ...)) : CSE(closest-info(), BAD-ARGLIST-MSG)
   defrule defnheader! = (?x:#defnheader)
   fail-if defnheader! = () : CSE(closest-info(), "Invalid syntax for function arguments.")

   ;                 LoStanza Defn Headers
   ;                 =====================

   ;Represents the default value following an argument.
   defproduction ls-arg-default?: Maybe
   defrule ls-arg-default? = (= void) : One(`void)
   defrule ls-arg-default? = (= ?e:#ls-exp!) : One(e)
   defrule ls-arg-default? = () : None()

   ;Represents a single argument binding.
   defproduction lsfnargbinding: ArgBinding
   defrule lsfnargbinding = (?name:#id : ?type:#ls-type! ~ ...) :
     VarArg(name, One(type))
   defrule lsfnargbinding = (param ?name:#id : ?type:#ls-type! ?arg-default:#ls-arg-default?) :
     val optional? = not empty?(arg-default)
     val default-value = None() when value?(arg-default) == `void else arg-default
     val opt-name = name when empty?(default-value) else gensym(`arg)
     KeywordArg(name, opt-name, One(type), optional?, default-value)
   defrule lsfnargbinding = (?name:#id : ?type:#ls-type! ?arg-default:#ls-arg-default?) :
     val optional? = not empty?(arg-default)
     val default-value = None() when value?(arg-default) == `void else arg-default
     val opt-name = name when empty?(default-value) else gensym(`arg)
     PositionalArg(name, opt-name, One(type), optional?, default-value)

   ;Error production.
   defproduction lsfnargbinding!: ArgBinding
   defrule lsfnargbinding! = (?x:#lsfnargbinding)
   fail-if lsfnargbinding! = () : CSE(closest-info(), "Invalid argument specifier.")
     
   ;Represents the entire defn header.
   defproduction lsdefnheader:DefnHeader
   defrule lsdefnheader = ((?args:#lsfnargbinding! ...) #->! ?a2:#ls-type!) :
     DefnHeader(to-tuple(args), One(a2))

   ;Error production
   defproduction lsdefnheader!:DefnHeader
   fail-if lsdefnheader! = ((@do _ ...)) : CSE(closest-info(), BAD-ARGLIST-MSG)
   defrule lsdefnheader! = (?x:#lsdefnheader)
   fail-if lsdefnheader! = () : CSE(closest-info(), "Invalid syntax for function arguments.")
   

   ;                   Functions
   ;                   =========
   defproduction $binder!
   defrule $binder! = (?x:#$binder)
   fail-if $binder! = (?x:#symbol) : CSE(closest-info(), "'%~' is a reserved keyword or an invalid identifier and cannot be used as an argument name." % [x])
   fail-if $binder! = () : CSE(closest-info(), "Expected a binder here.")

   defproduction $binder
   defrule $binder = (?x:#id)
   defrule $binder = ([?xs:#$binder! ...]) : qquote($tuple ~@ xs)

   defproduction argbinding : KeyValue
   defrule argbinding = (?x:#$binder : ?t:#type!) : x => t
   defrule argbinding = (?x:#$binder) : x => `($none)
   fail-if argbinding = (?x:#symbol) : CSE(closest-info(), "'%~' is a reserved keyword or an invalid identifier and cannot be used as an argument name." % [x])
   fail-if argbinding = () : CSE(closest-info(), "Expected an argument declaration here.")

   defproduction arglist : [? ?]
   defrule arglist = ((?xs:#argbinding ...)) : [map(key, xs), map(value, xs)]

   defproduction fnheader! : [List List ?]
   fail-if fnheader! = ((@do _ ...)) : 
      CSE(closest-info(), BAD-ARGLIST-MSG)
   defrule fnheader! = (?args:#arglist -> ?a2:#type!) :
      val [xs, a1] = args
      [xs, a1, a2]
   defrule fnheader! = (?args:#arglist) :
      val [xs, a1] = args
      [xs, a1, `($none)]
   fail-if fnheader! = () :
      CSE(closest-info(), "Expected argument list here.")

   defproduction fn-tag: Symbol
   defrule fn-tag = (fn) : `$fn
   defrule fn-tag = (fn*) : `$fn*
   defrule exp4 = (?tag:#fn-tag ?header:#fnheader! #:! ?body:#exp!) :
      val [xs, a1, a2] = header
      qquote(~ tag ~ xs ~ a1 ~ a2 ~ body)

   defproduction type-arg
   defrule type-arg = ((~ @cap ?x:#id$)) : qquote($cap ~ x)
   defrule type-arg = (?x:#id)

   defproduction type-arg!
   defrule type-arg! = (?x:#type-arg)
   fail-if type-arg! = () : CSE(closest-info(), "Type argument expected here.")
   
   defproduction fn-name!   
   defrule fn-name! = (?x:#id<?ts:#type-arg! ...>) : qquote($of ~ x ~@ ts)
   defrule fn-name! = (?x:#id)
   fail-if fn-name! = () : CSE(closest-info(), "Expected a function name here.")   

   defproduction defn-tag: Symbol
   defrule defn-tag = (defn) : `$defn
   defrule defn-tag = (defn*) : `$defn*
   defrule exp4 = (?tag:#defn-tag ?name:#fn-name! ?header:#defnheader! #:! ?body:#exp!) :
     val [xs, a1, a2, prelude] = compile-args-a1-a2-prelude(header)
     qquote(~ tag ~ name ~ xs ~ a1 ~ a2 ($begin ~ prelude ~ body))

   defproduction defmethod-tag: Symbol
   defrule defmethod-tag = (defmethod) : `$defmethod
   defrule defmethod-tag = (defmethod*) : `$defmethod*
   defproduction defmethod
   defrule defmethod = (?tag:#defmethod-tag ?name:#fn-name! ?header:#defnheader! #:! ?body:#exp!) :
      val [xs, a1, a2, prelude] = compile-args-a1-a2-prelude(header)
      qquote(~ tag ~ name ~ xs ~ a1 ~ a2 ($begin ~ prelude ~ body))
   defrule exp4 = inline #defmethod

   defrule exp4 = (defmulti ?name:#fn-name! ?header:#defnheader! : ?body:#exp!) :
      val [xs, a1, a2] = compile-args-a1-a2-no-prelude(header)
      qquote($begin
        ($defmulti ~ name ~ a1 ~ a2 ~ xs)
        ($defmethod ~ name ~ xs ~ a1 ~ a2 ~ body))

   defrule exp4 = (defmulti ?name:#fn-name! ?header:#defnheader!) :
      val [xs, a1, a2] = compile-args-a1-a2-no-prelude(header)
      qquote($defmulti ~ name ~ a1 ~ a2 ~ xs)

   defproduction multifn-tag
   defrule multifn-tag = (multifn) : `$fn
   defrule multifn-tag = (multifn*) : `$fn*
   defrule exp4 = (?tag:#multifn-tag #:! ((?headers:#fnheader! #:! ?bodies:#exp!) @...)) :
      val template =
         `($multi
            funcs{
               ($fn xs a1 a2 body)
            })
      fill-template(template, [
         `$fn => tag
         `funcs => nested $
            for ([xs, a1, a2] in headers, body in bodies) map :
               [`a1 => a1
                `a2 => a2
                `xs => xs
                `body => body]])
   fail-if exp4 = (?tag:#multifn-tag #:! ?rest ...) :
      CSE(closest-info(rest), "Expected a list of function branches here.")

   defrule id != (#fn-tag | #defn-tag | defmulti | #multifn-tag) 

   ;              Variables
   ;              =========
   defrule exp4 = (var ?name:#$binder : ?type:#type! = ?value:#exp!) :
      qquote($defvar ~ name ~ type ~ value)
   defrule exp4 = (var ?name:#$binder : ?type:#type!) :
      qquote($defvar ~ name ~ type ($none))
   defrule exp4 = (var ?name:#$binder = ?value:#exp!) :
      qquote($defvar ~ name ($none) ~ value)
   defrule exp4 = (var ?name:#$binder) :
      qquote($defvar ~ name ($none) ($none))
   fail-if exp4 = (var) :
      CSE(closest-info(), "Expected variable name after var keyword.")
      
   defrule id != (var)

   ;                Values
   ;                ======
   defrule exp4 = (val ?name:#$binder : ?type:#type! = ?value:#exp!) :
      qquote($def ~ name ~ type ~ value)
   fail-if exp4 = (val ?name:#$binder : #type! ?rest ...) :
      CSE(closest-info(rest), "No initializing value given to val %_." % [name])
   defrule exp4 = (val ?name:#$binder = ?value:#exp!) :
      qquote($def ~ name ($none) ~ value)
   fail-if exp4 = (val ?name:#$binder) :
      CSE(closest-info(), "No initializing value given to val %_." % [name])
   fail-if exp4 = (val) :
      CSE(closest-info(), "Expected value name after val keyword.")

   defrule id != (val)

   ;               Set Variable
   ;               ============
   defrule exp4 = (?x:#exp4 = ?y:#exp!) : qquote($set ~ x ~ y)
   defrule id != (=)

   ;               Visibilities
   ;               ============
   defproduction visibility
   defrule visibility = (public) : `$public
   defrule visibility = (protected) : `$protected
   defrule visibility = (private) : `$private
   
   defrule exp4 = (?tag:#visibility : ?e:#exp!) :
      List(tag, e)
   defrule exp4 = (?tag:#visibility ?e:#exp!) :
      List(tag, e)
      
   defrule id != (#visibility)   

   ;                Conditional Visibility
   ;                ======================
   defproduction visibility-when
   defrule visibility-when = (public-when) : `$public
   defrule visibility-when = (protected-when) : `$protected
   defrule visibility-when = (private-when) : `$private
   
   defrule exp4 = (?tag:#visibility-when(?flag:#id$) : ?e:#exp!) :
     if flag-defined?(unwrap-token(flag)) : List(tag, e)
     else : e
   defrule exp4 = (?tag:#visibility-when(?flag:#id$) ?e:#exp!) :
     if flag-defined?(unwrap-token(flag)) : List(tag, e)
     else : e   

   ;                   New Objects
   ;                   ===========
   defproduction defmethod!
   defrule defmethod! = (?x:#defmethod)
   fail-if defmethod! = () : CSE(closest-info(), "Expected a defmethod statement here.")
   
   defrule exp4 = (new ?t:#type! : (?methods:#defmethod! ...)) : qquote($new ~ t ~@ methods)
   fail-if exp4 = (new ?t:#type! : ?rest ...) :
      CSE(closest-info(rest), "Expected a list of defmethod statements following new keyword.")
   defrule exp4 = (new ?t:#type!) : qquote($new ~ t)

   defrule id != (new)

   ;                    DefType
   ;                    =======
   defproduction type-name!
   defrule type-name! = (?x:#id<?ts:#ids!>) : qquote($of ~ x ~@ ts)
   defrule type-name! = (?x:#id)
   fail-if type-name! = () : CSE(closest-info(), "Expected the name of a type here.")

   defproduction defchild!
   defrule defchild! = (?a:#type-name! <: ?b:#type!) : qquote($defchild ~ a ~ b)
   fail-if defchild! = () : CSE(closest-info(), "Invalid syntax for child type declaration.")
      
   defrule exp4 = (deftype ?t:#type-name! <: ?p:#type!) :
      qquote($deftype ~ t ~ p)
   defrule exp4 = (deftype ?t:#type-name! : (?cs:#defchild! ...)) :
      qquote($deftype ~ t ($none) ~@ cs)
   defrule exp4 = (deftype ?t:#type-name!) :
      qquote($deftype ~ t ($none))
      
   defrule id != (deftype)   

   ;                    Type Objects
   ;                    ============

   val typeobject-template = CoreExp $ `(
     new ~TypeObject<~T> :
       defmethod ~typeof? (~x, this) : ~x is ~T
       defmethod ~name (this) : ~type-name)
       
   defrule exp4 = (TypeObject<?type-form ...>()) :
     val type = parse-syntax[core + current-overlays / #type$](type-form)
     val type-name = string-join(type-form)
     fill(typeobject-template, [
       `x => gensym(`x)
       `T => type
       `TypeObject => `core/TypeObject
       `typeof? => `core/typeof?
       `name => `core/name
       `type-name => type-name])

   ;                    Tuples
   ;                    ======
   defrule exp4 = ([?es:#exps!]) :
      qquote($tuple ~@ es)

   ;                 Quick Match
   ;                 ===========
   defproduction match-alt
   defrule match-alt = (else #:! ?alt:#exp!) : alt
   defrule match-alt = () : false
   
   ;QuickMatch using identifiers
   defrule exp4 = (match((?es:#exp! : ?ts:#type!) @...) #:! ?conseq:#exp! ?alt:#match-alt) :
      val template = `(
         match(args{e}) :
            (args{x : t}) : conseq
            (args{#x}) : alt)
      defn id? (e) :
         match(unwrap-token(e)) :
           (x:Symbol) : e
           (x) : gensym(`x)
      parse-syntax[core / #exp](      
         fill-template(template, [
            `args => repeated $ [
               `e => es
               `t => ts
               `x => map(id?, es)
               `#x => map(gensym{}, es)]
            `conseq => conseq
            `alt => alt]))      

   ;                    Match
   ;                    =====
   defproduction match-clause! : [[? ?] ?]
   defrule match-clause! = (?arglist:#arglist #:! ?body:#exp!) : [arglist, body]
   fail-if match-clause! = () : CSE(closest-info(), "Expected match clause here.")
   
   defrule exp4 = (match(?xs:#exps!) #:! (?cs:#match-clause! ...)) :
      val template =
         `($match xs
              branch{
                 ($branch args types body)
              })
      fill-template(template, [
         `xs => xs
         `branch => nested $
            for [[xs, ts] b] in cs map :
               [`types => ts
                `args => xs
                `body => b]])
   fail-if exp4 = (match (_ ...)) :
      CSE(closest-info(), BAD-MATCH-MSG)
   fail-if exp4 = (match) :
      CSE(closest-info(), "Invalid syntax for match expression.")
      
   defrule id != (match)

   ;                    If
   ;                    ==
   defproduction if-exp
   
   ;Alternate branch
   defproduction if-alt
   defrule if-alt = (else : ?alt:#exp!)
   defrule if-alt = (else ?alt:#if-exp)
   defrule if-alt = () : false
   
   ;General case with generic predicate
   val if-template = CoreExp $ `(
     match(~pred upcast-as core/True|core/False) :
       (~x : core/True) : ~conseq
       (~x : core/False) : ~alt)
   defrule if-exp = (if ?pred:#exp! #:! ?conseq:#exp! ?alt:#if-alt) :
     fill(if-template, [
       `x => gensym(`x)
       `pred => pred
       `conseq => conseq
       `alt => alt])

   defrule exp4 = inline #if-exp
   defrule id != (if | else)

   ;                 #For
   ;                 ====
   defproduction for-binding : ForBinding
   defrule for-binding = (?x:#id in [?vs ...]) :
     ForBinding(unwrap-token(x), vs)
   defrule for-binding = (?x:#id in splice([?vs ...])) :
     ForBinding(unwrap-token(x), map(splice, vs))
   fail-if for-binding = (?x:#id in) :
     CSE(closest-info(), "Expected a list of expressions for binding.")

   defproduction for-binding! : ForBinding
   defrule for-binding! = (?x:#for-binding)
   fail-if for-binding! = () : CSE(closest-info(), "Binding expected here.")

   defproduction for-bindings : List<ForBinding>
   defrule for-bindings = (?b:#for-binding) : List(b)
   defrule for-bindings = ((?bs:#for-binding! ...))
   fail-if for-bindings = () : CSE(closest-info(), "For bindings expected here.")

   defrule exp4 = (~ #for ?bs:#for-bindings #:! ?body) :
     val vals = map(to-seq{values(_)}, bs)
     val body* = to-list $ repeat-while $ fn () :
       if all?(empty?, vals) :
         None()
       else :
         One{fill-template(body, _)} $
           for (b in bs, v in vals) map :
             name(b) => next(v)
     parse-syntax[core + current-overlays / #exp](List(body*))

   ;                Named Let
   ;                =========
   defproduction let-binding! : KeyValue ;arg => init
   defrule let-binding! = (?x:#binder : ?t:#type! #=! ?v:#exp!) : splice(List(x, `:, t)) => v
   defrule let-binding! = (?x:#binder #=! ?v:#exp!) : x => v
   fail-if let-binding! = () : CSE(closest-info(), "Expected a let binding here.")

   defproduction let-bindings! : List<KeyValue>
   defrule let-bindings! = ((?bs:#let-binding! ...))
   fail-if let-bindings! = () : CSE(closest-info(), "Expected a let binding here.")
   
   defrule exp4 = (let ?f:#id ?bs:#let-bindings! #:! ?body:#exp!) :
      val template = `(
         f(vs) where :
            defn* f args : body)
      parse-syntax[core / #exp](      
         fill-template(template, [
            `f => f
            `args => map(key,bs)
            `body => body
            `vs => splice(map(value,bs))]))

   ;                   Let
   ;                   ===
   defrule exp4 = (let #:! ?body:#exp!) :
      qquote($let ~ body)
   defrule id != (let)     

   ;                   Where
   ;                   =====
   defrule exp4 = (?x:#exp4 where #:! ?defs:#exp!) :
      parse-syntax[core / #exp](
         qquote(let : (~ defs ~ x)))
   defrule id != (where)

   ;                     For
   ;                     ===
   defproduction in!
   defrule in! = (?x:in)
   fail-if in! = () : CSE(closest-info(), "Expected the in keyword here.")

   defproduction binder!
   defrule binder! = (?x:#binder)
   fail-if binder! = () : CSE(closest-info(), "Expected a binder here.")
   
   defproduction binder
   defrule binder = (?x:#id)
   defrule binder = (?x:[#binder! ...])

   defproduction binders : List
   defrule binders = ((?xs:#binder ...))
   defrule binders = (?x:#binder) : List(x)

   public defproduction fnarg: Splice
   defrule fnarg = (?b:#binder : ?t:#type!) : splice(List(b, `: t))
   defrule fnarg = (?b:#binder) : splice(List(b))

   defproduction in-binding : KeyValue ;arg => collection
   defrule in-binding = (?x:#binder : ?t:#type! #in! ?y:#exp!) : splice(List(x `: t)) => y
   defrule in-binding = (?x:#binder #in! ?y:#exp!) : x => y

   defproduction in-binding! : KeyValue
   defrule in-binding! = (?x:#in-binding)
   fail-if in-binding! = () : CSE(closest-info(), "Expected a binding form here for the for expression.")

   defproduction in-bindings! : List<KeyValue>
   defrule in-bindings! = ((?b0:#in-binding ?bn:#in-binding! ...)) : cons(b0, bn)
   defrule in-bindings! = (?b:#in-binding!) : List(b)
   
   fail-if exp4 = (for #in-binding :) :
      CSE(closest-info(), BAD-FOR-MSG)         
   defrule exp4 = (for ?bs:#in-bindings! ?f:#exp! #:! ?body:#exp!) :
      val template = `(f(fn xs : body, ys))
      parse-syntax[core / #exp](
         fill-template(template, [
            `f => f
            `xs => map(key, bs)
            `body => body
            `ys => splice(map(value, bs))]))
      
   defrule id != (for)

   ;                   Within
   ;                   ======
   defproduction within-lhs:List<Splice>
   defrule within-lhs = ((?bs:#fnarg ...) =)
   defrule within-lhs = (?b:#binder =) : List(splice(List(b)))
   defrule within-lhs = () : List()
   
   defrule exp4 = (within ?bs:#within-lhs ?e:#exp! #:! ?body:#exp!) :
     ;Split expression into function call form, so that we
     ;can insert the closure as the first argument.
     if not tagged-list?(e, `$do) :
       throw(CSE(closest-info(e), "Expected a function call form."))
     val f = unwrap-token(e)[1]
     val args = tailn(unwrap-token(e), 2)

     ;Create and fill the template.
     val template = `(
       func(
         fn (binders{b}) : body
         args))
     val filled = fill-template(template, [
       `func => f
       `binders => repeated $ [
         `b => bs]
       `body => body
       `args => splice(args)])

     ;Parse as core expression.
     parse-syntax[core / #exp](filled)

   ;                   While
   ;                   =====
   val while-template = CoreExp $ `(
     let :
       defn* ~loop () :
         if (~pred upcast-as core/True|core/False) :
           ~body
           ~loop()
       ~loop())
   defrule exp4 = (while ?pred:#exp! #:! ?body:#exp!) :
     fill(while-template, [
       `loop => gensym(`loop)
       `pred => pred
       `body => body])

   defrule id != (while)

   ;                   When
   ;                   ====         
   ;General case for general predicate.   
   defrule exp4 = (?x:#exp4 when ?pred:#exp! else ?y:#exp!) :
     fill(if-template, [
       `x => gensym(`x)
       `pred => pred
       `conseq => x
       `alt => y])
       
   defrule exp4 = (?x:#exp4 when ?pred:#exp!) :
     fill(if-template, [
       `x => gensym(`x)
       `pred => pred
       `conseq => x
       `alt => false])

   defrule id != (when)

   ;                Filter-By
   ;                =========
   val filter-by-template = CoreExp $ `(core/filter({_ is ~T}, ~e) as core/Seq<~T>)
   defrule exp4 = (filter-by<?T:#type$>(?e:#exp$)) :
     fill(filter-by-template, [
       `T => T
       `e => e])
   fail-if exp4 = (filter-by<?T:#type$> ?rest ...) :
      CSE(closest-info(rest), "Expected a single argument here for filter-by form.")
   fail-if exp4 = (filter-by ?rest ...) :
      CSE(closest-info(rest), "Expected a single type argument here for filter-by form.")

   ;                  Find-By
   ;                  =======
   val find-by-template = CoreExp $ `(core/find({_ is ~T}, ~e) as ~T|False)
   defrule exp4 = (find-by<?T:#type$>(?e:#exp$)) :
     fill(find-by-template, [
       `T => T,
       `e => e])
   fail-if exp4 = (find-by<?T:#type$> ?rest ...) :
      CSE(closest-info(rest), "Expected a single argument here for find-by form.")
   fail-if exp4 = (find-by ?rest ...) :
      CSE(closest-info(rest), "Expected a single type argument here for find-by form.")

   val find-by!-template = CoreExp $ `(core/find!({_ is ~T}, ~e) as ~T)
   defrule exp4 = (find-by!<?T:#type$>(?e:#exp$)) :
     fill(find-by!-template, [
       `T => T
       `e => e])
   fail-if exp4 = (find-by!<?T:#type$> ?rest ...) :
      CSE(closest-info(rest), "Expected a single argument here for find-by! form.")
   fail-if exp4 = (find-by! ?rest ...) :
      CSE(closest-info(rest), "Expected a single type argument here for find-by! form.")
      

   ;                    To/Through
   ;                    ==========
   defproduction range-op
   defrule range-op = (to) : false
   defrule range-op = (through) : true

   val range-template = CoreExp $ `(core/Range(~start, ~end, ~step, ~inc))
   val simple-range-template = CoreExp $ `(core/SimpleRange(~start, ~end))
   defrule exp4 = (?start:#exp4 ?inc:#range-op ?end:#exp! by ?step:#exp!) :
     fill(range-template, [
       `start => start
       `end => end
       `step => step
       `inc => inc])
   defrule exp4 = (?start:#exp4 ?inc:#range-op ?end:#exp!) :
     if not inc :
       fill(simple-range-template, [
         `start => start
         `end => end])
     else :
       fill(range-template, [
         `start => start
         `end => end
         `step => 1
         `inc => inc])
   defrule id != (#range-op)

   ;                 Function Application
   ;                 ====================
   defrule exp4 = (?f:#exp4 $ ?v:#exp!) :
      qquote($do ~ f ~ v)
      
   defrule id != ($)

   ;See notes on ChainedFn for an explanation of why
   ;this trick is necessary, and its implementation.
   defproduction chained-fn
   defrule chained-fn = (?tag:#supported-chained-fn-tag ?args:_ : ?body $> ?tail:#chained-fn) :
     val fnform = qquote(~ tag ~ args : ~ body)
     ChainedFn(fnform, tail)
   defrule chained-fn = (?e:#exp4!)

   ;These are the function tags that are supported by the
   ;chained function operator.
   defproduction supported-chained-fn-tag
   defrule supported-chained-fn-tag = (?x:fn)
   defrule supported-chained-fn-tag = (?x:fn*)
   defrule supported-chained-fn-tag = (?x:multifn)
   defrule supported-chained-fn-tag = (?x:multifn*)

   defrule exp3 = (?v:#exp3 $> ?f:#chained-fn) :
      if f is ChainedFn :
         val expanded = compile(v, f)
         parse-syntax[core + current-overlays / #exp](expanded)
      else :
         qquote($do ~ f ~ v)

   defrule id != ($>)

   ;                  Anonymous Functions
   ;                  ===================
   defrule exp4 = ({?body ...}) :
     compile-afn-body(closest-info(), body)

   ;                       Is/Is-Not
   ;                       =========
   val is-template = CoreExp $ `(
     match(~value) :
       (x: ~t) : true
       (x) : false)
   defrule exp4 = (?x:#exp4 is ?t:#type!) :
     fill(is-template, [
       `value => x
       `t => t])
               
   val is-not-template = CoreExp $ `(
     match(~value) :
       (x: ~t) : false
       (x) : true)
   defrule exp4 = (?x:#exp4 is-not ?t:#type!) :
     fill(is-not-template, [
       `value => x
       `t => t])

   defrule id != (is | is-not)

   ;                        Label
   ;                        =====
   val label-ret-template = CoreExp $ `(
     core/LabeledScope<~T>((fn (~break) -> ~T : ~body)))
   defrule exp4 = (label<?t:#type$> ?break:#id! #:! ?body:#exp!) :
     fill(label-ret-template, [
       `T => t
       `break => break
       `body => body])

   val label-template = CoreExp $ `(
     core/LabeledScope*(fn (~break) : ~body))
   defrule exp4 = (label ?break:#id! #:! ?body:#exp!) :
     fill(label-template, [
       `break => break
       `body => body])
         
   defrule id != (label)      

   ;                      Generate
   ;                      ========
   val generate-template = CoreExp $ `(
     core/Generator<~T>((fn (yield, break) : ~body)))
   defrule exp4 = (generate<?t:#type$> #:! ?body:#exp!) :
     fill(generate-template, [
       `T => t
       `body => body])

   val generate-untyped-template = CoreExp $ `(
     generate<?> : ~body)
   defrule exp4 = (generate #:! ?body:#exp!) :
     fill(generate-untyped-template, [
       `body => body])
         
   defrule id != (generate)      

   ;                      KeyValue
   ;                      ========
   val keyvalue-template = CoreExp $ `(
     core/KeyValue(~k, ~v))
   defrule exp4 = (?k:#exp4 => ?v:#exp!) :
     fill(keyvalue-template, [
       `k => k
       `v => v])

   defrule id != (=>)

   ;           Switch Using Equality Predicate
   ;           ===============================
   ;Switch clauses
   defproduction switch-clause! : [? ?]
   defrule switch-clause! = ((! else) ?v:#exp! #:! ?body:#exp!) :
      [v, body]
      
   ;Special case using equality predicate
   defn gen-switch-equal-exp (x, clauses:List, alt) -> ? :
      if empty?(clauses) :
         alt
      else :
         val [v, body] = head(clauses)
         val rest = gen-switch-equal-exp(x, tail(clauses), alt)
         qquote(if ~ x == ~ v : ~ body else : ~ rest)

   defrule exp4 = (switch(?form:#exp$) #:! (
                      ?cs:#switch-clause! ...
                      else #:! ?alt:#exp$)) :
      val template = `(let : (val x = form upcast-as core/Equalable, exp))
      val x = gensym(`x)
      parse-syntax[core / #exp](
         fill-template(template, [
            `x => x
            `form => form
            `exp => gen-switch-equal-exp(x, cs, alt)]))
            
   defrule exp4 = (switch(?form:#exp$) #:! (
                      ?cs:#switch-clause! ...)) :
      val alt = qquote(core/fatal("No appropriate switch clause."))                
      val template = `(let : (val x = form upcast-as core/Equalable, exp))
      val x = gensym(`x)
      parse-syntax[core / #exp](
         fill-template(template, [
            `x => x
            `form => form
            `exp => gen-switch-equal-exp(x, cs, alt)]))         


   ;           Switch Using General Predicate
   ;           ==============================
   defn gen-switch-exp (pred, clauses:List, alt) -> ? :
      if empty?(clauses) :
         alt
      else :
         val [v, body] = head(clauses)
         val rest = gen-switch-exp(pred, tail(clauses), alt)
         qquote(if ~ pred(~ v) : ~ body else : ~ rest)

   defrule exp4 = (switch ?pred:#exp! #:! (
                      ?cs:#switch-clause! ...
                      else #:! ?alt:#exp$)) :
      parse-syntax[core / #exp](                
         gen-switch-exp(pred, cs, alt))

   defrule exp4 = (switch ?pred:#exp! #:! (
                      ?cs:#switch-clause! ...)) :
      val alt = qquote(core/fatal("No appropriate switch clause."))
      parse-syntax[core / #exp](
         gen-switch-exp(pred, cs, alt))

   defrule id != (switch)

   ;                     Let-Var
   ;                     =======
   val let-var-template = CoreExp $ `(
     let :
       var ~oldv:?
       val ~v = ~e
       core/dynamic-wind(
         fn () :
           ~oldv = ~x
           ~x = ~v
         fn () :
           ~body
         fn () :
           ~x = ~oldv))
   defrule exp4 = (let-var ?x:#id! = ?e:#exp! #:! ?body:#exp!) :
     fill(let-var-template, [
       `x => x
       `e => e
       `v => gensym(`v)
       `oldv => gensym(`oldv)
       `body => body])

   defrule id != (let-var)

   ;                      Resource
   ;                      ========
   val resource-template = CoreExp $ `(
     core/with-resource(
        fn (~x : ~type) : ~body
        ~value))        
   defrule exp4 = (resource ?name:#id! : ?type:#type! = ?value:#exp! ?rest:#exps!) :
     fill(resource-template, [
       `x => name
       `type => type
       `value => value
       `body => qquote($begin ~@ rest)])       

   val resource-untyped-template = CoreExp $ `(
     core/with-resource(
        fn (~x) : ~body
        ~value))
   defrule exp4 = (resource ?name:#id! = ?value:#exp! ?rest:#exps!) :
     fill(resource-untyped-template, [
       `x => name
       `value => value
       `body => qquote($begin ~@ rest)])
            
   defrule id != (resource)

   ;                      Try
   ;                      ===
   defproduction catch-clause: CatchClause
   fail-if catch-clause = (catch (@do _ ...)) :
      CSE(closest-info(), "Invalid catch clause. Did you forget a space between the catch keyword and the argument list?")
   defrule catch-clause = (catch (?x:#binder! : ?type:#type!) #:! ?body:#exp!) :
      CatchClause(x, One(type), body)
   defrule catch-clause = (catch (?x:#binder!) #:! ?body:#exp!) :
      CatchClause(x, None(), body)
   fail-if catch-clause = (catch) :
      CSE(closest-info(), "Invalid syntax for catch clause.")

   defn compile-catch-clauses (clauses:Seqable<CatchClause>) :
      nested $ to-tuple $
         for (c in clauses, i in 0 to false) seq :
            [`x => binder(c)
             `type => value?(type(c), `core/Exception)
             `first? => choice(i == 0)
             `body => body(c)]
      
   defrule exp4 = (try #:! ?body:#exp!
                   ?clauses:#catch-clause ...
                   finally #:! ?fbody:#exp!) :
      val template = `(
         core/with-finally(
            fn () :
               catch{
                  body
               }{
                  core/with-exception-handler(
                     fn () :
                        body
                     fn (e) :
                        e is clauses{first?{}{|} type}
                     fn (e) :
                        match(e) :
                           clauses{(x:type) : body})
               }
            fn () :
               fbody))
      parse-syntax[core / #exp](         
         fill-template(template, [
            `body => body
            `e => gensym(`e)
            `catch => choice(empty?(clauses))
            `clauses => compile-catch-clauses(clauses)
            `fbody => fbody]))

   defrule exp4 = (try #:! ?body:#exp! ?clauses0:#catch-clause ?clausesn:#catch-clause ...) :
      val template = `(
         core/with-exception-handler(
            fn () :
               body
            fn (e) :
               e is clauses{first?{}{|} type}
            fn (e) :
               match(e) :
                  clauses{(x:type) : body}))
      val clauses = cons(clauses0, clausesn)
      parse-syntax[core / #exp](
         fill-template(template, [
            `body => body
            `e => gensym(`e)
            `clauses => compile-catch-clauses(clauses)]))
   fail-if exp4 = (try #:! #exp!) :
      CSE(closest-info(), "Try expression without any catch or finally clauses.")

   defrule id != (try)

   ;                      Attempt
   ;                      =======
   val attempt-template = CoreExp $ `(
     core/with-attempt(
       fn () : ~conseq,
       fn () : ~alt))
   defn compile-attempt (conseq, alt) :
     fill(attempt-template, [
       `conseq => conseq
       `alt => alt])

   defproduction attempt-exp
   defrule attempt-exp = (attempt #:! ?conseq:#exp! else : ?alt:#exp!) :
      compile-attempt(conseq, alt)
   defrule attempt-exp = (attempt #:! ?conseq:#exp! else ?alt:#attempt-exp) :
      compile-attempt(conseq, alt)
   defrule attempt-exp = (attempt #:! ?conseq:#exp!) :
      compile-attempt(conseq, false)
   defrule exp4 = inline #attempt-exp

   defrule id != (attempt)

   ;                      DefPackage
   ;                      ==========
   defproduction prefix-clause!
   defrule prefix-clause! = (prefix => ?p:#id!) :
      qquote($prefix ~ p)
   defrule prefix-clause! = (prefix(?xs:#id! ...) => ?p:#id!) :
      qquote($prefix-of ~ xs ~ p)
   fail-if prefix-clause! = () :
      CSE(closest-info(), "Expected prefix clause here.")

   defproduction import-clause!
   defrule import-clause! = (import ?name:#id! with #:! (?ps:#prefix-clause! ...)) :
      qquote($import ~ name ~@ ps)
   defrule import-clause! = (import ?name:#id!) :
      qquote($import ~ name)
   fail-if import-clause! = () :
      CSE(closest-info(), "Expected import clause here.")

   defrule exp4 = (defpackage ?name:#id! : (?imports:#import-clause! ...)) :
      qquote($package ~ name ~@ imports)
   defrule exp4 = (defpackage ?name:#id!) :
      qquote($package ~ name)

   defrule id != (defpackage)

   ;                      DefStruct
   ;                      =========
   defrule exp4 = (defstruct ?name:#id! ?targs:#struct-targs ?parent:#struct-parent
                   ?fields:#struct-fields ?options:#struct-options) :
     val constructor = lookup?(options, `constructor, None())
     val printer = unwrap-token(value?(lookup?(options, `printer, None())))
     val writer = unwrap-token(value?(lookup?(options, `writer, None())))
     val equalable = unwrap-token(value?(lookup?(options, `equalable, None())))
     val hashable = unwrap-token(value?(lookup?(options, `hashable, None())))
     val meta-utils = unwrap-token(value?(lookup?(options, `meta-utils, None())))
     parse-syntax[core / #exp](
       gen-defstruct(name, targs, parent, fields, constructor, printer, writer, equalable, hashable, meta-utils))

   defproduction struct-targs:List
   defrule struct-targs = ((@of ?xs:#id! ...))
   defrule struct-targs = () : List()

   defproduction struct-fields:List<StructField>
   defrule struct-fields = (: (?fs:#struct-field! ...))
   defrule struct-fields = () : List()

   defproduction struct-parent:Maybe
   defrule struct-parent = (<: ?p:#type!) : One(p)
   defrule struct-parent = () : None()

   defproduction struct-options:List<KeyValue<Symbol,?>>
   defrule struct-options = (with: (?options:#struct-option! ...)) :
     ensure-no-duplicate-entries!(closest-info(), options)
     options
   defrule struct-options = () :
     List()

   defproduction struct-option!:KeyValue<Symbol,?>
   defrule struct-option! = (constructor => ?name:#id!) : `constructor => One(name)
   defrule struct-option! = (printer => ?v:#bool!) : `printer => One(v)
   defrule struct-option! = (writer => ?v:#bool!) : `writer => One(v)
   defrule struct-option! = (equalable => ?v:#bool!) : `equalable => One(v)
   defrule struct-option! = (hashable => ?v:#bool!) : `hashable => One(v)
   defrule struct-option! = (meta-utils => ?v:#bool!) : `meta-utils => One(v)
   fail-if struct-option! = () : CSE(closest-info(), "Expected struct option declaration here.")

   defproduction struct-field!:StructField
   defrule struct-field! = (?ds:#doc-string? ?name:#id! ?t:#field-type ?ops:#field-options) :
     val init = lookup?(ops, `init, None())
     val default = lookup?(ops, `default, None())
     val setter = lookup?(ops, `setter, None())
     val updater = lookup?(ops, `updater, None())
     defn void? (x:Maybe) : unwrap-token(value?(x)) == `void
     match(init:One, default:One) :
       throw(CSE(closest-info(), "Field '%~' cannot have both an initialization and a default value." % [name]))
     if void?(init) and empty?(setter) and empty?(updater) :
       throw(CSE(closest-info(), "Field '%~' is uninitialized and has no setter or updater." % [name]))     
     StructField(name, ds, t,
       lookup?(ops, `as-method),
       setter,
       updater,
       lookup?(ops, `ensure, None()),
       init, default)
   fail-if struct-field! = () : CSE(closest-info(), "Expected a field declaration here.")

   defproduction field-type
   defrule field-type = (: ?t:#type!)
   defrule field-type = () : `?

   defproduction field-options:List<KeyValue<Symbol,?>>
   defrule field-options = (with: (?options:#field-option! ...)) :
     ensure-no-duplicate-entries!(closest-info(), options)
     options
   defrule field-options = () :
     List()

   defproduction field-option!:KeyValue<Symbol,?>
   defrule field-option! = (as-method => ?v:#bool!) : `as-method => unwrap-token(v)
   defrule field-option! = (setter => ?v:#id!) : `setter => One(v)
   defrule field-option! = (updater => ?v:#id!) : `updater => One(v)
   defrule field-option! = (init => ?v:#exp!) : `init => One(v)
   defrule field-option! = (default => ?v:#exp!) : `default => One(v)
   defrule field-option! = (ensure => ?v:#exp!) : `ensure => One(v)
   fail-if field-option! = () : CSE(closest-info(), "Expected a field option declaration here.")

   defrule id != (defstruct)

   ;                      defenum
   ;                      =======
   defrule exp4 = (defenum ?name:#id! ?parent:#struct-parent #:! (?args:#id! ...)) :
     val def = EnumDef(name, parent, to-tuple(args))
     parse-syntax[core / #exp!](compile(def))
   defrule id != (defenum)

   ;                      #define
   ;                      #======
   defrule exp4 = (~ #define(?flag:#id$)) :
      add-flag(unwrap-token(flag))
      `($begin)
   fail-if exp4 = (~ #define) :
      CSE(closest-info(), "Incorrect syntax for #define.")

   defrule id != (~ #define)

   ;               #if-defined/#if-not-defined
   ;               ===========================
   defproduction list!
   defrule list! = ((?xs ...))
   fail-if list! = () : CSE(closest-info(), "Expected a list here.")

   defrule exp4 = (~ #if-defined(?flag:#id$) #:! ?conseq:#list! ~ #else #:! ?alt:#list!) :
      val body = if flag-defined?(unwrap-token(flag)) : conseq
                 else : alt
      parse-syntax[core + current-overlays / #exp](List(body))
   defrule exp4 = (~ #if-defined(?flag:#id$) #:! ?conseq:#list!) :
      if flag-defined?(unwrap-token(flag)) : parse-syntax[core + current-overlays / #exp](List(conseq))
      else : `($begin)
   fail-if exp4 = (~ #if-defined) :
      CSE(closest-info(), "Incorrect syntax for #if-defined.")

   defrule exp4 = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list! ~ #else #:! ?alt:#list!) :
      val body = if not flag-defined?(unwrap-token(flag)) : conseq
                 else : alt
      parse-syntax[core + current-overlays / #exp](List(body))
   defrule exp4 = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list!) :
      if not flag-defined?(unwrap-token(flag)) : parse-syntax[core + current-overlays / #exp](List(conseq))
      else : `($begin)
   fail-if exp4 = (~ #if-not-defined) :
      CSE(closest-info(), "Incorrect syntax for #if-not-defined.")

   defrule id != (~ #if-defined | ~ #if-not-defined)

   ;                      Quasiquote
   ;                      ==========
   defrule exp4 = (qquote(?sexp ...)) :
      defn fill (sexp:List) -> List :
         match-syntax(sexp) :
            (~ ~ ?x ?rest ...) :
               qquote(core/cons(~ x, ~ (fill(rest))))
            (~@ ?x ?rest ...) :
               qquote(core/append(~ x, ~ (fill(rest))))
            ((?fs ...) ?rest ...) :
               qquote(core/cons(~ (fill(fs)), ~ (fill(rest))))
            (?x ?rest ...) :
               qquote(core/cons((@quote ~ x), ~ (fill(rest))))
            () :
               qquote(core/List())
      parse-syntax[core + current-overlays / #exp](fill(sexp))         
   fail-if exp4 = (qquote) :
      CSE(closest-info(), "Incorrect syntax for qquote.")
      
   defrule id != (qquote)


   ;                      DefSyntax
   ;                      =========
   import syntax-exp from defsyntax-syntax
   defrule exp4 = inline #syntax-exp
   
   ;Failif rule
   defproduction =!
   defrule =! = (?x : =)
   fail-if =! = () : CSE(closest-info(), "Expected the = operator here.")

   ;                 Negation Operators
   ;                 ==================
   defrule exp4 = ((- ?x:#exp$)) : qquote($do negate ~ x)
   defrule exp4 = ((~ ~ ?x:#exp$)) : qquote($do bit-not ~ x)
   defrule id != (~ ~)

   ;                  Quote Syntax
   ;                  ============
   defrule exp4 = ((@quote ?rest ...)) :
      if length(rest) == 1 : qquote($quote ~ (head(rest)))
      else : CSE(closest-info(rest), "Expected a single form here.")

   ;                   #FILEINFO
   ;                   =========
   val fileinfo-template = CoreExp $ `(
     core/FileInfo(~filename, ~line, ~column))
   defrule exp4 = (~ #FILEINFO) :
     match(closest-info()) :
       (info:FileInfo) :
         fill(fileinfo-template, [
           `filename => filename(info),
           `line => line(info),
           `column => column(info)])
       (f:False) :
         false
         
   defrule id != (~ #FILEINFO)

   ;                  Begin Expression
   ;                  ================
   defrule exp4 = ((?x:#exp ?xs:#exps!)) :
      if empty?(xs) : x
      else : qquote($begin ~ x ~@ xs)
   defrule exp4 = (()) : wrap-info(closest-info(), `($begin))

   ;                        LoStanza Externs
   ;                        ================
   defproduction ->!
   defrule ->! = (?x: ->)
   fail-if ->! = () : CSE(closest-info(), "Expected -> operator here.")
   
   defrule exp4 = (extern defn ?name:#id! ((?xs:#id! #:! ?ts:#ls-type!) @...) #->! ?rt:#ls-type! #:! ?c:#ls-stmt!) :
      qquote($ls-extern-fn ~ name ~ xs ~ ts ~ rt ~ c)
   defrule exp4 = (extern ?name:#id! #:! ?t:#ls-type!) :
      qquote($ls-extern ~ name ~ t)

   ;                      LoStanza DefType
   ;                      ================
   defproduction ls-deffield-mut
   defrule ls-deffield-mut = (var) : true
   defrule ls-deffield-mut = () :    false

   defproduction ls-deffield!
   defrule ls-deffield! = ((! ~ ...) ?mut:#ls-deffield-mut ?name:#id! #:! ?t:#ls-type!) :
      qquote($ls-deffield ~ mut ~ t ~ name)

   defproduction ls-type-name
   defrule ls-type-name = (?name:#id!<?targs:#ids!>) : qquote($ls-of ~ name ~@ targs)
   defrule ls-type-name = (?name:#id!)

   defproduction ls-type-parent
   defrule ls-type-parent = (<: ?t:#type!)
   defrule ls-type-parent = () : `($none)

   fail-if exp4 = (lostanza deftype ?name:#ls-type-name ?p:#ls-type-parent : ?x:(~ ...)) :
      CSE(closest-info(x), "Rest field ellipsis must be preceded by field declaration.")
   defrule exp4 = (lostanza deftype ?name:#ls-type-name ?p:#ls-type-parent :
                     ?fields:#ls-deffield! ... ~ ...) :
      qquote($ls-deftype ~ name ~ p ~ (but-last(fields)) ~ (last(fields)))
   defrule exp4 = (lostanza deftype ?name:#ls-type-name ?p:#ls-type-parent :
                     ?fields:#ls-deffield! ...) :
      qquote($ls-deftype ~ name ~ p ~ fields ($none))
   defrule exp4 = (lostanza deftype ?name:#ls-type-name ?p:#ls-type-parent) :
      qquote($ls-deftype ~ name ~ p () ($none))

   defrule id != (~ ...)

   
   ;                        LoStanza Defn
   ;                        =============

   defproduction ls-defn-tag : Symbol
   defrule ls-defn-tag = (defn) : `$ls-defn
   defrule ls-defn-tag = (defn*) : `$ls-defn*
   
   defrule exp4 = (lostanza ?tag:#ls-defn-tag ?name:#id!<?targs:#type-arg! ...> ?header:#lsdefnheader! #:!
                     ?c:#ls-stmt!) :
      val [xs, a1, a2, prelude] = compile-args-a1-a2-ls-prelude(header)
      qquote(~ tag ($ls-of ~ name ~@ targs) ~ xs ~ a1 ~ a2 ($begin ~ prelude ~ c))
   defrule exp4 = (lostanza ?tag:#ls-defn-tag ?name:#id! ?header:#lsdefnheader! #:!
                     ?c:#ls-stmt!) :
      val [xs, a1, a2, prelude] = compile-args-a1-a2-ls-prelude(header)
      qquote(~ tag ~ name ~ xs ~ a1 ~ a2 ($begin ~ prelude ~ c))

   ;                        LoStanza Defmethod
   ;                        ==================
   defproduction ls-defmethod-tag : Symbol
   defrule ls-defmethod-tag = (defmethod) : `$ls-defmethod
   defrule ls-defmethod-tag = (defmethod*) : `$ls-defmethod*
   
   defrule exp4 = (lostanza ?tag:#ls-defmethod-tag ?multi:#id!<?targs:#type-arg! ...> ?header:#lsdefnheader! #:!
                     ?c:#ls-stmt!) :
      val [xs, a1, a2, prelude] = compile-args-a1-a2-ls-prelude(header)
      qquote(~ tag ($ls-of ~ multi ~@ targs) ~ xs ~ a1 ~ a2 ($begin ~ prelude ~ c))

   defrule exp4 = (lostanza ?tag:#ls-defmethod-tag ?multi:#id! ?header:#lsdefnheader! #:!
                     ?c:#ls-stmt!) :
      val [xs, a1, a2, prelude] = compile-args-a1-a2-ls-prelude(header)
      qquote(~ tag ~ multi ~ xs ~ a1 ~ a2 ($begin ~ prelude ~ c))

   ;                        LoStanza Vars
   ;                        =============
   defrule exp4 = (lostanza var ?name:#id! : ?type:#ls-type! = ?e:#ls-exp!) :
      qquote($ls-defvar ~ name ~ type ~ e)
   defrule exp4 = (lostanza var ?name:#id! : ?type:#ls-type!) :
      qquote($ls-defvar ~ name ~ type ($none))

   ;                        LoStanza Vals
   ;                        =============
   defrule exp4 = (lostanza val ?name:#id! : ?type:#ls-type! = ?e:#ls-exp!) :
      qquote($ls-def ~ name ~ type ~ e)
   defrule exp4 = (lostanza val ?name:#id! = ?e:#ls-exp!) :
      qquote($ls-def ~ name ($none) ~ e)

   ;                        LoStanza Let
   ;                        ============   
   defrule exp4 = (lostanza let #:! ?c:#ls-stmt!) :
      qquote($ls-let ~ c)   

   ;                    Atoms
   ;                    =====
   defrule exp4 = (?x:#literal)
   defrule exp4 = (?x:#id)

   ;                      LoStanza Error Handling
   ;                      =======================
   public defproduction ls-type!
   public defproduction ls-type$
   public defproduction ls-types!
   defrule ls-type! = (?x:#ls-type)
   fail-if ls-type! = () : CSE(closest-info(), "LoStanza type expected here.")
   defrule ls-type$ = (?x:#ls-type! (! _))
   fail-if ls-type$ = () : CSE(closest-info(), "Expected a single LoStanza type here.")
   defrule ls-types! = (?x:#ls-type! ...)

   public defproduction ls-exp!
   public defproduction ls-exp$
   public defproduction ls-exps!
   defrule ls-exp! = (?x:#ls-exp)
   fail-if ls-exp! = () : CSE(closest-info(), "LoStanza expression expected here.")
   defrule ls-exp$ = (?x:#ls-exp! (! _))
   fail-if ls-exp$ = () : CSE(closest-info(), "Expected a single LoStanza expression here.")
   defrule ls-exps! = (?x:#ls-exp! ...)

   public defproduction ls-stmt!
   public defproduction ls-stmt$
   public defproduction ls-stmts!
   defrule ls-stmt! = (?x:#ls-stmt)
   fail-if ls-stmt! = () : CSE(closest-info(), "LoStanza statement expected here.")
   defrule ls-stmt$ = (?x:#ls-stmt! (! _))
   fail-if ls-stmt$ = () : CSE(closest-info(), "Expected a single LoStanza statement here.")
   defrule ls-stmts! = (?x:#ls-stmt! ...)

   defproduction ls-exp0!
   defrule ls-exp0! = (?x:#ls-exp0)
   fail-if ls-exp0! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp1!
   defrule ls-exp1! = (?x:#ls-exp1)
   fail-if ls-exp1! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp2!
   defrule ls-exp2! = (?x:#ls-exp2)
   fail-if ls-exp2! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp3!
   defrule ls-exp3! = (?x:#ls-exp3)
   fail-if ls-exp3! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp4!
   defrule ls-exp4! = (?x:#ls-exp4)
   fail-if ls-exp4! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp5!
   defrule ls-exp5! = (?x:#ls-exp5)
   fail-if ls-exp5! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   ;                      LoStanza Types
   ;                      ==============
   public defproduction ls-type
   public defproduction ls-type0

   ;Precedence level 0      
   defrule ls-type = (?a:#ls-type0 -> ?b:#ls-type!) : qquote($ls-fn (~ a) ($none) ~ b)
   defrule ls-type = ((((! ~ ...) ?xs:#ls-type) @... ~ ...) -> ?b:#ls-type!) :
      val a = but-last(xs)
      val r = last(xs)
      qquote($ls-fn ~ a ~ r ~ b)
   defrule ls-type = ((?a:#ls-type-list) -> ?b:#ls-type!) : qquote($ls-fn ~ a ($none) ~ b)
   defrule ls-type = (?x:#ls-type0)

   defproduction ls-type-list:List
   defrule ls-type-list = ((?t:#ls-type ?ts:#ls-types!)) : cons(t,ts)
   defrule ls-type-list = (()) : List()

   ;Precedence level 0
   defrule ls-type0 = (?x:(#stanza-tag _ ...))
   defrule ls-type0 = (byte) : wrap-info(closest-info(), `($ls-byte))
   defrule ls-type0 = (int) : wrap-info(closest-info(), `($ls-int))
   defrule ls-type0 = (long) : wrap-info(closest-info(), `($ls-long))
   defrule ls-type0 = (float) : wrap-info(closest-info(), `($ls-float))
   defrule ls-type0 = (double) : wrap-info(closest-info(), `($ls-double))
   defrule ls-type0 = (?) : wrap-info(closest-info(), `($ls-?))
   defrule ls-type0 = (ptr<?x:#ls-type$>) : qquote($ls-ptr ~ x)
   defrule ls-type0 = (ref<?x:#type$>) : qquote($ls-ref ~ x)
   defrule ls-type0 = (?x:#id<?ts:#types!>) : qquote($ls-of ~ x ~@ ts)
   defrule ls-type0 = (?x:#id)
   defrule ls-type0 = ((?x:#ls-type))

   ;                      LoStanza Expressions
   ;                      ====================
   public defproduction ls-exp  ; and / or
   public defproduction ls-exp0 ; ==, !=, <, <=, >, >=
   public defproduction ls-exp1 ; +, -
   public defproduction ls-exp2 ; *, %, /
   public defproduction ls-exp3 ; <<, >>, >>>
   public defproduction ls-exp4 ; others
   public defproduction ls-exp5

   defproduction ls-op0 : Symbol
   defproduction ls-op1 : Symbol
   defproduction ls-op2 : Symbol
   defproduction ls-op3 : Symbol
   defproduction ls-op4 : Symbol

   defrule ls-op0 = (<) : `lt
   defrule ls-op0 = (<=) : `le
   defrule ls-op0 = (>) : `gt
   defrule ls-op0 = (>=) : `ge
   defrule ls-op0 = (!=) : `ne
   defrule ls-op0 = (==) : `eq

   defrule ls-op1 = (+) : `add
   defrule ls-op1 = (-) : `sub
   defrule ls-op1 = (~ |) : `or

   defrule ls-op2 = (*) : `mul
   defrule ls-op2 = (/) : `div
   defrule ls-op2 = (%) : `mod
   defrule ls-op2 = (&) : `and
   defrule ls-op2 = (^) : `xor

   defrule ls-op3 = (<<) : `shl
   defrule ls-op3 = (>>) : `shr
   defrule ls-op3 = (>>>) : `ashr

   defrule ls-exp = (?x:#ls-exp and ?y:#ls-exp0!) : qquote($ls-and ~ x ~ y)
   defrule ls-exp = (?x:#ls-exp or ?y:#ls-exp0!) : qquote($ls-or ~ x ~ y)
   defrule ls-exp = (?x:#ls-exp0)

   defrule ls-exp0 = (?x:#ls-exp0 ?f:#ls-op0 ?y:#ls-exp1!) : qquote($ls-prim ~ f ~ x ~ y)
   defrule ls-exp0 = (?x:#ls-exp1)
   defrule ls-exp1 = (?x:#ls-exp1 ?f:#ls-op1 ?y:#ls-exp2!) : qquote($ls-prim ~ f ~ x ~ y)
   defrule ls-exp1 = (?x:#ls-exp2)
   defrule ls-exp2 = (?x:#ls-exp2 ?f:#ls-op2 ?y:#ls-exp3!) : qquote($ls-prim ~ f ~ x ~ y)
   defrule ls-exp2 = (?x:#ls-exp3)
   defrule ls-exp3 = (?x:#ls-exp3 ?f:#ls-op3 ?y:#ls-exp4!) : qquote($ls-prim ~ f ~ x ~ y)
   defrule ls-exp3 = (?x:#ls-exp4)

   ;                      Suffix Operators
   ;                      ================
   defrule ls-exp4 = (?x:#ls-exp4 as ?t:#ls-type!) : qquote($ls-as ~ x ~ t)
   defrule ls-exp4 = (?x:#ls-exp4[?i:#ls-exp!]) : qquote($ls-slot ~ x ~ i)
   defrule ls-exp4 = (?x:#ls-exp4 . ?f:#id!) : qquote($ls-field ~ x ~ f)
   defrule ls-exp4 = (?x:#ls-exp4(?ys:#ls-callarg! ...)) : qquote($ls-do ~ x ~@ ys)
   defrule ls-exp4 = (?x:#ls-exp4<?ts:#types!>(?ys:#ls-callarg! ...)) : qquote($ls-do ($ls-of ~ x ~@ ts) ~@ ys)
   defrule ls-exp4 = (?x:#ls-exp5)

   ;Named Arguments.
   defproduction ls-callarg!
   defrule ls-callarg! = (?keyword:#id = ?e:#ls-exp!) : qquote($keywordarg ~ keyword ~ e)
   defrule ls-callarg! = (?e:#ls-exp!)

   ;                    Prefix Operators
   ;                    ================
   defrule ls-exp5 = (?x:(#stanza-tag _ ...))

   defrule ls-exp5 = (sizeof(?t:#ls-type$)) : qquote($ls-sizeof ~ t)
   
   defrule ls-exp5 = (tagof(?tag:#id$)) : qquote($ls-tagof ~ tag)
   
   defrule ls-exp5 = (new ?name:#id!{?xs:#ls-exps!}) : qquote($ls-new ~ name ~@ xs)
   defrule ls-exp5 = (new ?name:#id!<?ts:#types!>{?xs:#ls-exps!}) : qquote($ls-new ($ls-of ~ name ~@ ts) ~@ xs)
   
   defrule ls-exp5 = (addr(?e:#ls-exp$)) : qquote($ls-addr ~ e)
   defrule ls-exp5 = (addr!(?e:#ls-exp$)) : qquote($ls-addr! ~ e)
   fail-if ls-exp5 = (?x:(addr | addr!)) : CSE(closest-info(), "Expected one argument after %_ operator." % [x])

   defproduction end!
   defrule end! = (! _) : true
   fail-if end! = () : CSE(closest-info(), "Unexpected symbol here.")   

   defrule ls-exp5 = (?name:#id{?xs:#ls-exps!}) : qquote($ls-struct ~ name ~@ xs)
   defrule ls-exp5 = (?name:#id<?ts:#types!>{?xs:#ls-exps!}) : qquote($ls-struct ($ls-of ~ name ~@ ts) ~@ xs)
   
   defrule ls-exp5 = (call-c ?f:#ls-exp5!(?ys:#ls-exps!)) : qquote($ls-call-c ~ f ~@ ys)
   fail-if ls-exp5 = (call-c) : CSE(closest-info(), "Expected function call after call-c keyword.")
   
   defrule ls-exp5 = (call-prim ?f:#id!(?ys:#ls-exps!)) : qquote($ls-prim ~ f ~@ ys)
   fail-if ls-exp5 = (call-prim) : CSE(closest-info(), "Expected function call after call-prim keyword.")
   
   defrule ls-exp5 = (fn(?x:#id$)) : qquote($ls-func ~ x)
   fail-if ls-exp5 = (fn) : CSE(closest-info(), "Expected identifier of referenced function after fn keyword.")
   
   defrule ls-exp5 = (let #:! ?c:#ls-stmt! in ?e:#ls-exp!) : qquote($ls-letexp ~ c ~ e)
   fail-if ls-exp5 = (let #:! ?c:#ls-stmt! ?rest ...) : CSE(closest-info(rest), "Expected the in keyword here.")

   defrule ls-exp5 = ([?x:#ls-exp$]) : qquote($ls-deref ~ x)
   defrule ls-exp5 = ((- ?x:#ls-exp$)) : qquote($ls-prim neg ~ x)
   defrule ls-exp5 = ((~ ~ ?x:#ls-exp$)) : qquote($ls-prim not ~ x)      
   defrule ls-exp5 = ((?x:#ls-exp))
   defrule ls-exp5 = (?x:#literal)
   defrule ls-exp5 = (?x:#id)


   ;                     LoStanza Statements
   ;                     ===================
   public defproduction ls-stmt

   ;                        Block Tags
   ;                        ==========
   defrule ls-stmt = (?x:(#stanza-tag _ ...))

   ;                        Values
   ;                        ======
   defrule ls-stmt = (val ?x:#id! : ?t:#ls-type! = ?e:#ls-exp!) :
      qquote($ls-def ~ x ~ t ~ e)
   defrule ls-stmt = (val ?x:#id! : ?t:#ls-type!) :
      CSE(closest-info(), "Missing initialization value for val %_." % [x])
   defrule ls-stmt = (val ?x:#id! = ?e:#ls-exp!) :
      qquote($ls-def ~ x ($none) ~ e)
   defrule ls-stmt = (val ?x:#id!) :
      CSE(closest-info(), "Missing initialization value for val %_." % [x])
      
   ;                        Variables
   ;                        =========
   defrule ls-stmt = (var ?x:#id! #:! ?t:#ls-type! = ?e:#ls-exp!) :
      qquote($ls-defvar ~ x ~ t ~ e)
   defrule ls-stmt = (var ?x:#id! #:! ?t:#ls-type!) :
      qquote($ls-defvar ~ x ~ t ($none))

   ;                        Return
   ;                        ======
   defrule ls-stmt = (return ?e:#ls-exp!) : qquote($ls-return ~ e)

   ;                        Labels
   ;                        ======
   defproduction ls-block
   defrule ls-block = (?name:#id! ((?xs:#id! #:! ?ts:#ls-type!) @...) #:! ?body:#ls-stmt!) :
      qquote($ls-block ~ name ~ xs ~ ts ~ body)
   defrule ls-block = (?name:#id! #:! ?body:#ls-stmt!) :
      qquote($ls-block ~ name () () ~ body)         
   defrule ls-stmt = (labels #:! (?bs:#ls-block ...)) :
      qquote($ls-labels ~@ bs)

   ;                        Goto
   ;                        ====
   defrule ls-stmt = (goto ?x:#id!(?args:#ls-exps!)) : qquote($ls-goto ~ x ~@ args)
   defrule ls-stmt = (goto ?x:#id!) : qquote($ls-goto ~ x)
   
   ;                        Let
   ;                        ===
   defrule ls-stmt = (let #:! ?c:#ls-stmt!) : qquote($ls-let ~ c)

   ;                        If
   ;                        ==
   defproduction ls-if
   defrule ls-if = (if ?pred:#ls-exp! #:! ?conseq:#ls-stmt! else : ?alt:#ls-stmt!) :
      qquote($ls-if ~ pred ~ conseq ~ alt)
   defrule ls-if = (if ?pred:#ls-exp! #:! ?conseq:#ls-stmt! else ?alt:#ls-if) :
      qquote($ls-if ~ pred ~ conseq ~ alt)
   defrule ls-if = (if ?pred:#ls-exp! #:! ?conseq:#ls-stmt!) :
      qquote($ls-if ~ pred ~ conseq ($begin))
   defrule ls-stmt = (?c:#ls-if) : c

   ;                        While
   ;                        =====
   val ls-while-template = CoreLSStmt $ `(
     labels :
       ~loop :
         if ~pred :
           ~body
           goto ~loop)
   defrule ls-stmt = (while ?pred:#ls-exp! #:! ?body:#ls-stmt!) :
     fill(ls-while-template, [
       `pred => pred
       `body => body
       `loop => gensym(`loop)])

   ;                        Match
   ;                        =====
   defproduction branch-arg : KeyValue
   defrule branch-arg = (?x:#id! : ?t:#ls-type!) : x => t
   defrule branch-arg = (?x:#id!) : x => `($none)
   defrule ls-stmt = (match(?es:#ls-exps!) #:! (
                         ((?argss:#branch-arg ...) #:! ?bodies:#ls-stmt!) @...)) :
      val template =
         `($ls-match args
            branches{
               ($ls-branch xs ts body)
            })
      fill-template(template, [
         `args => es
         `branches => nested $ for (args in argss, body in bodies) map : [
            `xs => map(key, args)
            `ts => map(value, args)
            `body => body]])
   fail-if ls-stmt = (match) :
      CSE(closest-info(), "Expected list of arguments after match keyword.")

   
   ;                        For
   ;                        ===
   val ls-for-template = CoreLSStmt $ `(
     let :
       ~def
       labels :
         ~loop :
           if ~pred :
             ~body
             ~step
             goto ~loop)
   defrule ls-stmt = (for (?def:#ls-stmt!, ?pred:#ls-exp!, ?step:#ls-stmt!) #:!
                         ?body:#ls-stmt!) :
     fill(ls-for-template, [
       `def => def
       `loop => gensym(`loop)
       `pred => pred
       `body => body
       `step => step])

   fail-if ls-stmt = (for) :
      CSE(closest-info(), "Expected list after for keyword.")   

   ;                        Set
   ;                        ===
   defrule ls-stmt = (?x:#ls-exp = ?y:#ls-exp!) : qquote($ls-set ~ x ~ y)

   ;              Side-Effecting Expressions
   ;              ==========================
   defrule ls-stmt = (?x:#ls-exp)

   ;                   Statement Groups
   ;                   ================
   defrule ls-stmt = ((?c:#ls-stmt ?cs:#ls-stmts!)) : qquote($begin ~ c ~@ cs)
   defrule ls-stmt = (()) : `($begin)

   ;                    Switch
   ;                    ======
   defproduction ls-switch-clause! : [? ?]
   defrule ls-switch-clause! = ((! else) ?v:#ls-exp! #:! ?body:#ls-stmt!) :
      [v, body]
   defrule ls-stmt = (switch(?form:#ls-exp!) #:! (
                        ?cs:#ls-switch-clause! ...
                        else #:! ?alt:#ls-stmt!)) :
      val template = `(let : (val x = form, exp))
      val x = gensym(`x)
      parse-syntax[core + current-overlays / #ls-stmt](
         fill-template(template, [
            `x => x
            `form => form
            `exp => gen-switch-equal-exp(x, cs, alt)]))

   defrule ls-stmt = (switch(?form:#ls-exp!) #:! (
                        ?cs:#ls-switch-clause! ...)) :
      val alt = qquote(core/fatal("No appropriate switch clause."))
      val template = `(let : (val x = form, exp))
      val x = gensym(`x)
      parse-syntax[core + current-overlays / #ls-stmt](
         fill-template(template, [
            `x => x
            `form => form
            `exp => gen-switch-equal-exp(x, cs, alt)]))

   ;                    #if-defined/#if-not-defined
   ;                    ===========================
   defrule ls-stmt = (~ #if-defined(?flag:#id$) #:! ?conseq:#list! ~ #else #:! ?alt:#list!) :
      val body = 
         if flag-defined?(unwrap-token(flag)) : conseq
         else : alt
      parse-syntax[core + current-overlays / #ls-stmt](List(body))   
   defrule ls-stmt = (~ #if-defined(?flag:#id$) #:! ?conseq:#list!) :
      if flag-defined?(unwrap-token(flag)) : parse-syntax[core + current-overlays / #ls-stmt](List(conseq))   
      else : `($begin)
   fail-if ls-stmt = (~ #if-defined) :
      CSE(closest-info(), "Incorrect syntax for #if-defined.")

   defrule ls-stmt = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list! ~ #else #:! ?alt:#list!) :
      val body = 
         if not flag-defined?(unwrap-token(flag)) : conseq
         else : alt
      parse-syntax[core + current-overlays / #ls-stmt](List(body))   
   defrule ls-stmt = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list!) :
      if not flag-defined?(unwrap-token(flag)) : parse-syntax[core + current-overlays / #ls-stmt](List(conseq))   
      else : `($begin)
   fail-if ls-stmt = (~ #if-not-defined) :
      CSE(closest-info(), "Incorrect syntax for #if-not-defined.")

   ;                   Literal
   ;                   =======
   public defproduction literal : Token|Char|String|Byte|Int|Long|Float|Double|True|False
   defrule literal = (?x) when unwrap-token(x) is Char|String|Byte|Int|Long|Float|Double|True|False

   ;                Identifier
   ;                ==========
   public defproduction id : Symbol|Token
   defrule id != (#stanza-tag)
   defrule id != (#lexer-tag)
   defrule id = (?x) when unwrap-token(x) is Symbol


;============== Error Messages ============================
val BAD-ARGLIST-MSG = "Incorrect syntax for argument list. Did you forget to put a space between the function name and the argument list?"
val BAD-MATCH-MSG = "Incorrect syntax for match expression. Is there an extra space between match and the argument list?"
val BAD-FOR-MSG = "Missing operating function in for expression. Did you forget to put a do after the bindings?"

