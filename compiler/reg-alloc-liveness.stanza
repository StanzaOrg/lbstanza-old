defpackage stz/reg-alloc-liveness :
  import core
  import collections
  import stz/reg-alloc-engine
  import stz/reg-alloc-ir
  import stz/reg-alloc-checks

;Compute the live variables. 
public defn compute-live (e:RegAllocEngine) -> False :
  ;Preconditions.
  for b in e each-block :
    no-inputs!(b)
    no-outputs!(b)
    no-defs!(b)

  ;Compute the defs and ports for all blocks from
  ;local usages.
  for b in blocks(e) do :
    compute-from-local-usages(e,b)

;Compute defs and ports from local usages.
defn compute-from-local-usages (e:RegAllocEngine, b:Block) -> False :
  val defs = IntSet()
  val uses = IntSet()
  within op = operations-in-reverse(e, b) :
    ;Mark the results as defined.
    ;If they were expecting to be used, that is now satisfied.
    for v in results(op) do :
      add(defs,v)
      remove(uses,v)
    ;Mark the arguments as now expecting to be used.
    for v in args(op) do :
      add(uses,v)
      
  ;Write the calculated quantities to the block.
  set-contents(/defs(b), defs)
  set-contents(/inputs(b), seq(Port,uses))

  ;Ensure quantities are in sorted order.
  qsort!(/defs(b))
  qsort!(id, /inputs(b))

;Helper: Set the contents of the given vector.
defn set-contents<?T> (vs:Vector<?T>, xs:Seqable<T>) :
  clear(vs)
  add-all(vs,xs)      

;Helper: Iterate through all OperationStmt in the block in reverse order.
defn operations-in-reverse (f:OperationStmt -> ?, e:RegAllocEngine, b:Block) -> False :
  val indices = reverse(start(b) to start(b) + length(b))
  val stmts = stmts(program(e))
  for i in indices do :
    val stmt = stmts[i]
    match(stmt:OperationStmt) :
      f(stmt)