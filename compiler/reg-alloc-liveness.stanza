defpackage stz/reg-alloc-liveness :
  import core
  import collections
  import stz/reg-alloc-engine
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-checks
  import stz/reg-alloc-liveness-scanner
  import stz/reg-alloc-block-processing

;Compute the live variables. 
public defn compute-live (program:Program, blocks:Vector<Block>) -> False :
  ;Preconditions.
  for b in blocks do :
    no-inputs!(b)
    no-outputs!(b)
    no-defs!(b)

  ;Compute the defs and ports for all blocks from
  ;local usages.
  for b in blocks do :
    compute-defs-and-inputs(program,b)

  ;Propagate outputs to inputs.
  propagate-inputs-and-outputs(blocks)

;Compute defs and ports from local usages.
defn compute-defs-and-inputs (program:Program, b:Block) -> False :
  ;Analyze the block using the liveness scanner.
  val scanner = LivenessScanner()
  within (i, op) = operations-in-reverse(program, b) :
    scan-stmt(scanner, i, op)

  ;Write the calculated quantities to the block.
  set-contents(/defs(b), defs(scanner))
  set-contents(/inputs(b), input-ports) where :
    val input-ports = for entry in live-vars(scanner) seq :
      val v = key(entry)
      Port(v, value(entry))

;Compute outputs and update inputs.
;Returns true if the input ports changed.
defn compute-outputs-and-update-inputs (blocks:Vector<Block>,
                                        b:Block) -> True|False :
  val inputs = PortSet(inputs(b))
  val defs = to-intset(defs(b))
  val outputs = PortSet(outputs(b))
  var inputs-changed?:True|False = false

  ;Add an output port with the given usage-position.  
  defn add-output-port (id:Int, usage-position:Int) :
    ;First, check whether there is already an output port with the
    ;same usage-position. If so, then don't do anything. If not,
    ;then register the output port.
    ;Next, check whether the block contains a def that kills
    ;this usage. If not, then we will reach the input.
    ;Check whether there is already an input port with the same
    ;usage-position. If so, then don't do anything. If not,
    ;then register the output port.
    ;Finally, flag that the inputs have changed if they have.

    if not exists?(outputs, id, usage-position) :
      add(outputs, Port(id, usage-position))
      if not defs[id] :
        if not exists?(inputs, id, usage-position) :
          add(inputs, Port(id, usage-position))
          inputs-changed? = true

  ;The output ports of this block are the union
  ;of the inputs of all its successors.
  for succ in succs(b) do :
    val succ-block = blocks[succ]
    for succ-input in /inputs(succ-block) do :
      val succ-usage = length(b) + usage-position(succ-input)
      add-output-port(id(succ-input), succ-usage)

  ;Return true if the inputs have changed.
  inputs-changed?
  
;Propagate inputs and outputs across blocks.
defn propagate-inputs-and-outputs (blocks:Vector<Block>) -> False :
  within (block) = iterative-block-analysis(blocks, reverse-order(blocks)) :
    compute-outputs-and-update-inputs(blocks, block)

;Helper: Set the contents of the given vector.
defn set-contents<?T> (vs:Vector<?T>, xs:Seqable<T>) :
  clear(vs)
  add-all(vs,xs)      

;============================================================
;=================== Utility ================================
;============================================================

deftype PortSet

defmulti exists? (s:PortSet, id:Int, usage:Int) -> True|False

defmulti add (s:PortSet, p:Port) -> False

defn PortSet (ps:Vector<Port>) -> PortSet :
  val index-table = to-inttable<Int> $
    for (p in ps, i in 0 to false) seq :
      id(p) => i
  
  new PortSet :
    defmethod exists? (this, id:Int, usage:Int) :
      match(get?(index-table, id)) :
        (i:Int) : usage-position(ps[i]) <= usage
        (f:False) : false

    defmethod add (this, p:Port) :
      match(get?(index-table, id(p))) :
        (i:Int) :
          ps[i] = p
        (f:False) :
          index-table[id(p)] = length(ps)
          add(ps, p)

