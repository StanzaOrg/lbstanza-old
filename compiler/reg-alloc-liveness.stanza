defpackage stz/reg-alloc-liveness :
  import core
  import collections
  import stz/reg-alloc-engine
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-checks
  import stz/reg-alloc-liveness-scanner

;Compute the live variables. 
public defn compute-live (e:RegAllocEngine) -> False :
  ;Preconditions.
  for b in e each-block :
    no-inputs!(b)
    no-outputs!(b)
    no-defs!(b)

  ;Compute the defs and ports for all blocks from
  ;local usages.
  for b in blocks(e) do :
    compute-defs-and-inputs(e,b)
  propagate-inputs-and-outputs(e)

;Compute defs and ports from local usages.
defn compute-defs-and-inputs (e:RegAllocEngine, b:Block) -> False :
  ;Analyze the block using the liveness scanner.
  val scanner = LivenessScanner()
  within (i, op) = operations-in-reverse(e, b) :
    scan-stmt(scanner, i, op)

  ;Write the calculated quantities to the block.
  set-contents(/defs(b), defs(scanner))
  set-contents(/inputs(b), input-ports) where :
    val input-ports = for entry in live-vars(scanner) seq :
      val v = key(entry)
      Port(v, value(entry))

  ;Ensure quantities are in sorted order.
  qsort!(/defs(b))
  qsort!(id, /inputs(b))

;Compute outputs and update inputs.
;Returns true if the input ports changed.
defn compute-outputs-and-update-inputs (e:RegAllocEngine, b:Block) -> True|False :
  val inputs = PortSet(e, inputs(b))
  val defs = to-intset(defs(b))
  val outputs = PortSet(e, outputs(b))
  var inputs-changed?:True|False = false

  ;Add an output port with the given usage-position.  
  defn add-output-port (id:Int, usage-position:Int) :
    ;First, check whether there is already an output port with the
    ;same usage-position. If so, then don't do anything. If not,
    ;then register the output port.
    ;Next, check whether the block contains a def that kills
    ;this usage. If not, then we will reach the input.
    ;Check whether there is already an input port with the same
    ;usage-position. If so, then don't do anything. If not,
    ;then register the output port.
    ;Finally, flag that the inputs have changed if they have.

    if not exists?(outputs, id, usage-position) :
      add(outputs, Port(id, usage-position))
      if not defs[id] :
        if not exists?(inputs, id, usage-position) :
          add(inputs, Port(id, usage-position))
          inputs-changed? = true

  ;The output ports of this block are the union
  ;of the inputs of all its successors.
  for succ in succs(b) do :
    val succ-block = blocks(e)[succ]
    for succ-input in /inputs(succ-block) do :
      val succ-usage = length(b) + usage-position(succ-input)
      add-output-port(id(succ-input), succ-usage)

  ;Return true if the inputs have changed.
  inputs-changed?
  

;Propagate inputs and outputs across blocks.
defn propagate-inputs-and-outputs (e:RegAllocEngine) -> False :
  val processed-blocks = IntSet()
  val worklist = Queue<Int>()
  defn mark-processed (block-id:Int, inputs-changed?:True|False) :
    add(processed-blocks, block-id)
    if inputs-changed? :
      val block = blocks(e)[block-id]
      for pred-id in preds(block) do :
        remove(processed-blocks, pred-id)
        add(worklist, pred-id)

  for b in blocks(e) do :
    add(worklist, index(b))
  let loop () :
    if not empty?(worklist) :
      val block-id = pop(worklist)
      if not processed-blocks[block-id] :
        val block = blocks(e)[block-id]
        val inputs-changed? = compute-outputs-and-update-inputs(e, block)
        mark-processed(block-id, inputs-changed?)
      loop()

;Helper: Set the contents of the given vector.
defn set-contents<?T> (vs:Vector<?T>, xs:Seqable<T>) :
  clear(vs)
  add-all(vs,xs)      

;Helper: Iterate through all OperationStmt in the block in reverse order.
defn operations-in-reverse (f:(Int, OperationStmt) -> ?, e:RegAllocEngine, b:Block) -> False :
  val indices = reverse(start(b) to start(b) + length(b))
  val stmts = stmts(program(e))
  for i in indices do :
    val stmt = stmts[i]
    match(stmt:OperationStmt) :
      f(i - start(b), stmt)

;============================================================
;=================== Utility ================================
;============================================================

deftype PortSet

defmulti exists? (s:PortSet, id:Int, usage:Int) -> True|False

defmulti add (s:PortSet, p:Port) -> False

defn PortSet (e:RegAllocEngine, ps:Vector<Port>) -> PortSet :
  val index-table = to-inttable<Int> $
    for (p in ps, i in 0 to false) seq :
      id(p) => i
  
  new PortSet :
    defmethod exists? (this, id:Int, usage:Int) :
      match(get?(index-table, id)) :
        (i:Int) : usage-position(ps[i]) <= usage
        (f:False) : false

    defmethod add (this, p:Port) :
      match(get?(index-table, id(p))) :
        (i:Int) :
          ps[i] = p
        (f:False) :
          index-table[id(p)] = length(ps)
          add(ps, p)

