defpackage stz/reg-alloc-liveness :
  import core
  import collections
  import stz/reg-alloc-engine
  import stz/reg-alloc-ir
  import stz/reg-alloc-checks

;Compute the live variables. 
public defn compute-live (e:RegAllocEngine) -> False :
  ;Preconditions.
  for b in e each-block :
    no-inputs!(b)
    no-outputs!(b)
    no-defs!(b)

  ;Compute the defs and ports for all blocks from
  ;local usages.
  for b in blocks(e) do :
    compute-defs-and-inputs(e,b)
  update-input-ports(e)

;Compute defs and ports from local usages.
defn compute-defs-and-inputs (e:RegAllocEngine, b:Block) -> False :
  val defs = IntSet()
  val uses = IntSet()  
  within op = operations-in-reverse(e, b) :
    ;Mark the results as defined.
    ;If they were expecting to be used, that is now satisfied.
    for v in results(op) do :
      add(defs,v)
      remove(uses,v)
    ;Mark the arguments as now expecting to be used.
    for v in args(op) do :
      add(uses,v)
      
  ;Write the calculated quantities to the block.
  set-contents(/defs(b), defs)
  set-contents(/inputs(b), seq(Port,uses))

  ;Ensure quantities are in sorted order.
  qsort!(/defs(b))
  qsort!(id, /inputs(b))

;Compute block liveness
;
;For each of my successors, I now have their input ports.
;This means that I can compute my output ports (by unioning
;all of the input ports).
;
;During this calculation, every time I add a *new* output port,
;I can check whether it is one of the defs. If it is not
;one of the defs, I can also add it as one of the input ports.
;If I add it to an input port, and its a new input port, then this
;means that my input ports have been updated. And the function
;should return true at the end.

defn update-input-ports (e:RegAllocEngine, b:Block) -> True|False :
  val inputs = wrapped-set(e, inputs(b))
  val defs = to-intset(defs(b))
  val outputs = wrapped-set(e, outputs(b))
  var inputs-changed?:True|False = false

  defn add-output (id:Int) :
    if not outputs[id] :
      add(outputs, Port(id))
      if not defs[id] :
        if not inputs[id] :
          add(inputs, Port(id))
          inputs-changed? = true

  for succ in succs(b) do :
    val succ-block = blocks(e)[succ]
    for succ-input in /inputs(succ-block) do :
      add-output(id(succ-input))

  inputs-changed?      

defn update-input-ports (e:RegAllocEngine) -> False :
  val processed-blocks = IntSet()
  val worklist = Queue<Int>()
  defn mark-processed (block-id:Int, inputs-changed?:True|False) :
    add(processed-blocks, block-id)
    if inputs-changed? :
      val block = blocks(e)[block-id]
      for pred-id in preds(block) do :
        remove(processed-blocks, pred-id)
        add(worklist, pred-id)

  for b in blocks(e) do :
    add(worklist, index(b))
  let loop () :
    if not empty?(worklist) :
      val block-id = pop(worklist)
      if not processed-blocks[block-id] :
        val block = blocks(e)[block-id]
        val inputs-changed? = update-input-ports(e, block)
        mark-processed(block-id, inputs-changed?)
      loop()


;Helper: Set the contents of the given vector.
defn set-contents<?T> (vs:Vector<?T>, xs:Seqable<T>) :
  clear(vs)
  add-all(vs,xs)      

;Helper: Iterate through all OperationStmt in the block in reverse order.
defn operations-in-reverse (f:OperationStmt -> ?, e:RegAllocEngine, b:Block) -> False :
  val indices = reverse(start(b) to start(b) + length(b))
  val stmts = stmts(program(e))
  for i in indices do :
    val stmt = stmts[i]
    match(stmt:OperationStmt) :
      f(stmt)

;============================================================
;=================== Utility ================================
;============================================================

deftype WrappedSet<T>

defmulti get (s:WrappedSet, x:Int) -> True|False
defmulti add<?T> (s:WrappedSet<?T>, x:T) -> True|False

defn wrapped-set (e:RegAllocEngine, vs:Vector<Int>) -> WrappedSet<Int> :
  val intset = to-intset(vs)
  new WrappedSet<Int> :
    defmethod add (this, v:Int) :
      val added? = add(intset, v)
      add(vs,v) when added?
      added?
    defmethod get (this, v:Int) :
      intset[v]

defn wrapped-set (e:RegAllocEngine, vs:Vector<Port>) -> WrappedSet<Port> :
  val intset = to-intset(seq(id,vs))
  new WrappedSet<Port> :
    defmethod add (this, v:Port) :
      val added? = add(intset, id(v))
      add(vs,v) when added?
      added?
    defmethod get (this, v:Int) :
      intset[v]