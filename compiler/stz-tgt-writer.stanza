defpackage stz/tgt-writer :
   import core
   import collections
   import stz/tgt-ir

;============================================================
;================= Serialize DefFns =========================
;============================================================

public defn serialize-defns (fns:List<DefFn>, filename:String) :
   val f = FileOutputStream(filename)   
   try: serialize(f, DefFns(fns))
   finally: close(f)

public defn deserialize-defns (filename:String) :
   val f = FileInputStream(filename)
   try: fns(deserialize-deffns(f))
   finally: close(f)

defstruct DefFns :
   fns: List<DefFn>

#with-overlay(stz/serializer-lang) :
   defserializer (out:FileOutputStream, in:FileInputStream) :
      defunion deffns (DefFns) :
         DefFns: (fns:list(deffn))

      defunion deffn (DefFn) :
         DefFn: (n:int, defs:vec(defvar), body:vec(ins))

      defunion defvar (DefVar) :
         DefVar: (n:int, type:tgt-type)

      defunion ins (Ins) :
         ArgsIns: (xs:slist(imm as Var))
         Return: (xs:slist(imm))
         CArgsIns: (xs:slist(imm as Var))
         CReturn: (xs:slist(imm))
         SetIns: (x:imm as Var, y:imm)
         ConvertIns: (x:imm as Var, y:imm)
         InterpretIns: (x:imm as Var, y:imm)
         BinOp: (x:imm as Var, op:tgt-op, y:imm, z:imm)
         UnaOp: (x:imm as Var, op:tgt-op, y:imm)
         Load: (x:imm as Var, y:imm, offset:int)
         Store: (x:imm, y:imm, offset:int)
         Addr: (x:imm as Var, n:int)
         Call: (arity:int, xs:slist(imm as Var), f:imm, ys:slist(imm), new-stack?:bool, info:opt<FileInfo>(info))
         CallStack: (xs:slist(imm as Var), f:imm, ys:slist(imm), info:opt<FileInfo>(info))
         TCall: (arity:int, f:imm, ys:slist(imm), new-stack?:bool)
         TCallStack: (f:imm, ys:slist(imm))
         CallC: (n:int, xs:slist(imm as Var), f:imm, ys:slist(imm))
         Label: (n:int)
         Goto: (n:int)
         Branch: (n:int, op:tgt-op, x:imm, y:imm)
         SpecialBranch: (n:int, op:tgt-op)
         SpecialOp: (op:tgt-op)

      defunion imm (Imm) :
         ByteImm: (value:byte)
         IntImm: (value:int)
         LongImm: (value:long)
         RSP: ()
         Var: (n:int)
         Mem: (n:int, offset:int)
         ExMem: (name:symbol, offset:int)

      defatom tgt-type (x:TgtType) :
         writer :
            write-byte $ switch {x == _} :
               BYTE-TYPE : 0Y
               INT-TYPE : 1Y
               LONG-TYPE : 2Y
               FLOAT-TYPE : 3Y
               DOUBLE-TYPE : 4Y
               REF-TYPE : 5Y
         reader :
            val tag = read-byte()
            switch {tag == _} :
               0Y : BYTE-TYPE
               1Y : INT-TYPE
               2Y : LONG-TYPE
               3Y : FLOAT-TYPE
               4Y : DOUBLE-TYPE
               5Y : REF-TYPE

      defatom tgt-op (x:TgtOp) :
         writer :
            switch {x == _} :
               ADD-OP : write-byte(0Y)
               SUB-OP : write-byte(1Y)
               MUL-OP : write-byte(2Y)
               DIV-OP : write-byte(3Y)
               MOD-OP : write-byte(4Y)
               AND-OP : write-byte(5Y)
               OR-OP : write-byte(6Y)
               XOR-OP : write-byte(7Y)
               SHL-OP : write-byte(8Y)
               SHR-OP : write-byte(9Y)
               ASHR-OP : write-byte(10Y)
               EQ-OP : write-byte(11Y)
               NE-OP : write-byte(12Y)
               LT-OP : write-byte(13Y)
               GT-OP : write-byte(14Y)
               LE-OP : write-byte(15Y)
               GE-OP : write-byte(16Y)
               ULE-OP : write-byte(17Y)
               ULT-OP : write-byte(18Y)
               UGT-OP : write-byte(19Y)
               UGE-OP : write-byte(20Y)
               NOT-OP : write-byte(21Y)
               NEG-OP : write-byte(22Y)
               SWITCH-STACK-OP : write-byte(23Y)
               STACK-HAS-SPACE : write-byte(24Y)
               ENTER-FROM-C : write-byte(25Y)
               else : match(x) :
                  (x:ArityNEqOp) :
                     write-byte(26Y)
                     write-byte(to-byte(arity(x)))
         reader :
            val tag = read-byte()
            switch {tag == _} :
               0Y : ADD-OP
               1Y : SUB-OP
               2Y : MUL-OP
               3Y : DIV-OP
               4Y : MOD-OP
               5Y : AND-OP
               6Y : OR-OP
               7Y : XOR-OP
               8Y : SHL-OP
               9Y : SHR-OP
               10Y : ASHR-OP
               11Y : EQ-OP
               12Y : NE-OP
               13Y : LT-OP
               14Y : GT-OP
               15Y : LE-OP
               16Y : GE-OP
               17Y : ULE-OP
               18Y : ULT-OP
               19Y : UGT-OP
               20Y : UGE-OP
               21Y : NOT-OP
               22Y : NEG-OP
               23Y : SWITCH-STACK-OP
               24Y : STACK-HAS-SPACE
               25Y : ENTER-FROM-C
               26Y : ArityNEqOp(to-int(read-byte()))

      reader defn read-slist<?T> (f: () -> ?T) :
         val n = read-byte()
         to-list(repeatedly(f, to-int(n)))

      writer defn write-slist<?T> (f: T -> False, xs:List<?T>) :
         write-byte(to-byte(length(xs)))
         do(f, xs)

      reader defn read-vec<?T> (f: () -> ?T) :
         val n = read-int()
         to-vector<T>(repeatedly(f, n))

      writer defn write-vec<?T> (f: T -> False, xs:Vector<?T>) :
         write-int(length(xs))
         do(f, xs)

      reader defn read-list<?T> (f: () -> ?T) :
         val n = read-int()
         to-list(repeatedly(f, n))

      writer defn write-list<?T> (f: T -> False, xs:List<?T>) :
         write-int(length(xs))
         do(f, xs)

      reader defn read-opt<T> (f: () -> T) :
         val n = read-byte()
         f() when n == 1Y

      writer defn write-opt<T> (f: T -> False, x:T|False) :
         if x is False :
            write-byte(0Y)
         else :
            write-byte(1Y)
            f(x as T)
            
      defatom bool (x:True|False) :
         writer :
            write-byte(1Y when x else 0Y)
         reader :
            true when read-byte() == 1Y

      defunion info (FileInfo) :
         FileInfo: (filename:string, line:int, column:int)

      defatom int (x:Int) :
         writer :
            put(out, x)
         reader :
            match(get-int(in)) :
               (x:Int) : x
               (x:False) : throw(FileReadException())

      defatom long (x:Long) :
         writer :
            put(out, x)
         reader :
            match(get-long(in)) :
               (x:Long) : x
               (x:False) : throw(FileReadException())

      defatom float (x:Float) :
         writer :
            put(out, x)
         reader :
            match(get-float(in)) :
               (x:Float) : x
               (x:False) : throw(FileReadException())

      defatom double (x:Double) :
         writer :
            put(out, x)
         reader :
            match(get-double(in)) :
               (x:Double) : x
               (x:False) : throw(FileReadException())

      defatom byte (x:Byte) :
         writer :
            put(out, x)
         reader :
            match(get-byte(in)) :
               (x:Byte) : x
               (x:False) : throw(FileReadException())

      defatom char (x:Char) :
         writer :
            print(out, x)
         reader :
            match(get-char(in)) :
               (x:Char) : x
               (x:False) : throw(FileReadException())

      defatom string (x:String) :
         writer :
            write-int(length(x))
            print(out, x)
         reader :
            val n = read-int()
            String(repeatedly(read-char, n))

      defatom symbol (x:Symbol) :
         writer : write-string(to-string(x))
         reader : to-symbol(read-string())