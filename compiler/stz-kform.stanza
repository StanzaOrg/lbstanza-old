defpackage stz/kform :
   import core
   import verse
   import stz/kl-ir
   import stz/ids
   import stz/utils
   import stz/lexer
   import stz/padder
   import stz/tgt-ir with: (prefix => tgt-)
   import stz/tgt with: (prefix => tgt-)


;                           Driver
;                           ======

public defn compile (prog:KProg, filename:String) :
   val gt = global-table(prog)
   val tt = type-table(prog)
   
   headline("Transform")
   val p2 = transform(prog, gt)
   println(p2)

   headline("Compile to Tgt IR")
   val p3 = compile(p2, tt, gt)
   println(p3)
   
   tgt-compile(p3, filename)
   


;                       Stanza Machine State
;                       ====================

val HEAP-PTR-LBL = fresh-id()
val HEAP-LIM-LBL = fresh-id()

val FLOAT-ZERO-LBL = fresh-id()
val DOUBLE-ZERO-LBL = fresh-id()

val REF-TAG = 1
val MARKER-TAG = 2
val VOID-TAG = (-1 << 3) + MARKER-TAG


;                     Type Analysis
;                     =============

;     Type Table Interface
;     --------------------
defclass TypeTable
defmulti expand (tt:TypeTable, t:KLSType) -> List<tgt-TgtType> 
defmulti pad+expand (tt:TypeTable, t:KLSType) -> List<tgt-TgtType> 
defmulti offsets (tt:TypeTable, t:KLSType) -> List<Int>      
defmulti size (tt:TypeTable, t:KLSType) -> Int               
defmulti alignment (tt:TypeTable, t:KLSType) -> Int
defmulti field-offset (tt:TypeTable, f:Int) -> Int           
defmulti field-index (tt:TypeTable, f:Int) -> Int            
defmulti field-type (tt:TypeTable, f:Int) -> KLSType         
defmulti rfield (tt:TypeTable, n:Int) -> Int                 
defmulti tag (tt:TypeTable, n:Int) -> Int                    

;     Analysis
;     --------
defn type-table (prog:KProg) :
   ;     Search through all types
   ;     ------------------------
   val lstypes = HashTable<Int, KLSDefType>({_})
   val types = HashTable<Int, KDefType>({_})
   for c in comms(prog) do :
      match(c) :
         (c:KDefType) :
            error("Untested.")
            types[n(c)] = c
         (c:KLSDefType) : lstypes[n(c)] = c
         (c) : false

   ;     Compute Expansions
   ;     ------------------
   val struct-expansions = HashTable<Int, List<tgt-TgtType>>({_})
   defn expand (t:KLSType) :
      defn expand-struct (n:Int) :
         for f in fields(lstypes[n]) map-append :
            expand(type(f))
      match(t) :
         (t:KByteT) : list(tgt-BYTE-TYPE)
         (t:KIntT) : list(tgt-INT-TYPE)
         (t:KLongT) : list(tgt-LONG-TYPE)
         (t:KFloatT) : list(tgt-FLOAT-TYPE)
         (t:KDoubleT) : list(tgt-DOUBLE-TYPE)
         (t:KPtrT) : list(tgt-LONG-TYPE)
         (t:KRefT) : list(tgt-REF-TYPE)
         (t:KStructT) :
            if not key?(struct-expansions, n(t)) :
               struct-expansions[n(t)] = expand-struct(n(t))
            struct-expansions[n(t)]
         (t) : error("No expansion for ~." % [t])

   ;     Compute Field Types and Indices
   ;     -------------------------------
   val field-structs = HashTable<Int,Int>({_})
   val field-indices = HashTable<Int,Int>({_})
   val field-types = HashTable<Int,KLSType>({_})
   for def in values(lstypes) do :
      for (f in fields(def), i in 0 to false) do :
         field-structs[n(f)] = n(def)
         field-indices[n(f)] = i
         field-types[n(f)] = type(f)
      if rfield(def) != false :
         val f = rfield(def) as StructField
         field-structs[n(f)] = n(def)
         field-indices[n(f)] = length(fields(def))
         field-types[n(f)] = type(f)

   ;     Compute Alignments, Padding, and Size
   ;     -------------------------------------
   val pad+expansions = HashTable<Int, List<tgt-TgtType>>({_})
   val struct-alignments = HashTable<Int, Int>({_})
   val type-sizes = HashTable<Int,Int>({_})
   val field-offsets = HashTable<Int,Int>({_})

   defn type-size (t:KLSType) :
      match(t) :
         (t:KByteT) : 1
         (t:KIntT) : 4
         (t:KLongT) : 8
         (t:KFloatT) : 4
         (t:KDoubleT) : 8
         (t:KPtrT) : 8
         (t:KRefT) : 8
         (t:KUnknownT) : error("No size.")
         (t:KFnT) : error("No size.")
         (t:KStructT) :
            compute-struct(n(t)) when not key?(type-sizes, n(t))
            type-sizes[n(t)]

   defn type-alignment (t:KLSType) :
      match(t) :
         (t:KStructT) :
            compute-struct(n(t)) when not key?(struct-alignments, n(t))
            struct-alignments[n(t)]
         (t) : type-size(t)

   defn pad+expand (t:KLSType) :
      match(t) :
         (t:KStructT) :
            compute-struct(n(t)) when not key?(pad+expansions, n(t))
            pad+expansions[n(t)]
         (t) : expand(t)

   defn field-offset (f:Int) :
      if not key?(field-offsets, f) :
         compute-struct(field-structs[f])
      field-offsets[f]

   defn compute-struct (sn:Int) :
      ;Pad struct fields
      val def = lstypes[sn]
      val items = for f in fields(def) stream :
         Item(type-alignment(type(f)), n(f))         
      val [items*, aln] = match(rfield(def)) :
         (rf:False) : pad(items, 1)
         (rf:StructField) : pad(items, type-alignment(type(rf)))

      ;Compute struct alignment, field offsets, type sizes, and padded expansions
      var accum = 0
      val expansion = Vector<tgt-TgtType>()
      for x in items* do :
         match(x) :
            (x:Item) :
               val f = data(x) as Int
               val ft = field-types[f]
               field-offsets[f] = accum
               do(add{expansion, _}, pad+expand(ft))
               accum = accum + type-size(ft)
            (x:Padding) :
               switch {size(x) == _} :
                  1 : add(expansion, tgt-BYTE-TYPE)
                  4 : add(expansion, tgt-INT-TYPE)
               accum = accum + size(x)

      ;Record Rest Field offset
      if rfield(def) != false :
         val rf = rfield(def) as StructField
         field-offsets[n(rf)] = accum

      ;Record Size, Expansion, and Alignment
      type-sizes[sn] = accum         
      pad+expansions[sn] = to-list(expansion)
      struct-alignments[sn] = aln      


   ;     Compute Struct Tags
   ;     -------------------
   val tag-table = HashTable<Int,Int>({_})
   val tag-types = Vector<Int>()
   for def in values(lstypes) do :
      tag-table[n(def)] = length(tag-types)
      add(tag-types, n(def))
   for def in values(types) do :
      tag-table[n(def)] = length(tag-types)
      add(tag-types, n(def))

   
   ;     Return Table
   ;     ------------
   new TypeTable :
      defmethod expand (this, t:KLSType) :
         expand(t)
      defmethod pad+expand (this, t:KLSType) :
         pad+expand(t)
      defmethod offsets (this, t:KLSType) :
         match(t) :
            (t:KStructT) :
               for f in fields(lstypes[n(t)]) map :
                  field-offset(n(f))
            (t) : list(0)
      defmethod size (this, t:KLSType) :
         type-size(t)
      defmethod alignment (this, t:KLSType) :
         type-alignment(t)
      defmethod field-offset (this, f:Int) :
         field-offset(f)
      defmethod field-type (this, f:Int) :
         field-types[f]
      defmethod field-index (this, f:Int) :
         field-indices[f]
      defmethod rfield (this, s:Int) :
         n(rfield(lstypes[s]) as StructField)
      defmethod tag (this, n:Int) :
         tag-table[n]


;                   Command Buffer
;                   ==============

;     Emission of DefIns Structures
;     -----------------------------
var DEF-INS-VECTOR : False|Vector<tgt-DefIns> = false
defn emit (i:tgt-DefIns) : add(DEF-INS-VECTOR as Vector<tgt-DefIns>, i)


;     Emission of Ins Structures
;     --------------------------
var INSTRUCTION-VECTOR : False|Vector<tgt-Ins> = false
defn emit (i:tgt-Ins) : add(INSTRUCTION-VECTOR as Vector<tgt-Ins>, i)
defn args (xs:List<tgt-Var>) : emit(tgt-ArgsIns(xs))
defn set (x:tgt-Var, y:tgt-Imm) : emit(tgt-SetIns(x, y))
defn conv (x:tgt-Var, y:tgt-Imm) : emit(tgt-ConvertIns(x, y))
defn binop (x:tgt-Var, op:tgt-TgtOp, y:tgt-Imm, z:tgt-Imm) : emit(tgt-BinOp(x, op, y, z))
defn add (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : binop(x, tgt-ADD-OP, y, z)
defn mul (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : binop(x, tgt-MUL-OP, y, z)
defn shl (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : binop(x, tgt-SHL-OP, y, z)
defn bit-and (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : emit(tgt-BinOp(x, tgt-AND-OP, y, z))
defn load (x:tgt-Var, y:tgt-Imm, o:Int) : emit(tgt-Load(x, y, o))
defn store (x:tgt-Imm, y:tgt-Imm, o:Int) : emit(tgt-Store(x, y, o))
defn addr (x:tgt-Var, y:tgt-Imm, o:Int) : emit(tgt-Addr(x, y, o))
defn call (a:Int, xs:List<tgt-Var>, f:tgt-Imm, ys:List<tgt-Imm>) : emit(tgt-Call(a, xs, f, ys))
defn ffi-call (xs:List<tgt-Var>, f:tgt-Imm, ys:List<tgt-Imm>) : emit(tgt-CallC(xs, f, ys))
defn tcall (a:Int, f:tgt-Imm, ys:List<tgt-Imm>) : emit(tgt-TCall(a, f, ys))
defn return (xs:List<tgt-Imm>) : emit(tgt-Return(xs))
defn tlabel (n:Int) : emit(tgt-Label(n))
defn goto (n:Int) : emit(tgt-Goto(n))
defn jne (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-NE-OP, x, y))
defn jeq (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-EQ-OP, x, y))
defn jlt (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-LT-OP, x, y))
defn jle (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-LE-OP, x, y))
defn jult (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-ULT-OP, x, y))
defn jule (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-ULE-OP, x, y))
defn byte (v:Int) : tgt-ByteImm(v)
defn int (v:Int) : tgt-IntImm(v)
defn long (v:Int) : tgt-LongImm(v)
defn mem (n:Int) : tgt-Mem(n)
defn xmem (name:Symbol) : tgt-ExMem(name)

;     Heap Instructions
;     -----------------
defn heap-ptr () :
   val p = make-var(tgt-LONG-TYPE)
   load(p, mem(HEAP-PTR-LBL), 0)
   p

defn heap-lim () :
   val p = make-var(tgt-LONG-TYPE)
   load(p, mem(HEAP-LIM-LBL), 0)
   p
   
defn extend-heap (sz:tgt-Imm) :
   val endL = fresh-id()
   val p = heap-ptr()
   add(p, p, sz)
   jule(endL, p, heap-lim())
   call(1, List(), mem(EXTEND-HEAP-ID), list(sz))
   tlabel(endL)

defn extend-heap (sz:Int) :
   extend-heap(long(sz))

defn inc-heap-ptr (sz:tgt-Imm) :
   val p = heap-ptr()
   add(p, p, sz)
   store(mem(HEAP-PTR-LBL), p, 0)

defn inc-heap-ptr (sz:Int) :
   inc-heap-ptr(long(sz))

;     Compound Value Instructions
;     ---------------------------
defn value-lbl (ins:tgt-DefIns) :
   val n = fresh-id()
   emit(tgt-TLabel(n))
   emit(ins)
   n   
defn float-lbl (f:Float) : value-lbl(tgt-DefFloat(f))
defn double-lbl (f:Float) : value-lbl(tgt-DefDouble(f))
defn string-lbl (s:String) : value-lbl(tgt-DefString(s))

;     Conversion of Primitive Operators
;     ---------------------------------
defn to-tgt-op (op:KLSOp) :
   switch {op == _} :
      ADD-OP : tgt-ADD-OP
      SUB-OP : tgt-SUB-OP
      MUL-OP : tgt-MUL-OP
      DIV-OP : tgt-DIV-OP
      MOD-OP : tgt-MOD-OP
      AND-OP : tgt-AND-OP
      OR-OP : tgt-OR-OP
      XOR-OP : tgt-XOR-OP
      SHL-OP : tgt-SHL-OP
      SHR-OP : tgt-SHR-OP
      ASHR-OP : tgt-ASHR-OP
      EQ-OP : tgt-EQ-OP
      NE-OP : tgt-NE-OP
      LT-OP : tgt-LT-OP
      GT-OP : tgt-GT-OP
      LE-OP : tgt-LE-OP
      GE-OP : tgt-GE-OP
      ULT-OP : tgt-ULT-OP
      UGT-OP : tgt-UGT-OP
      ULE-OP : tgt-ULE-OP
      UGE-OP : tgt-UGE-OP

;                  Variable Management
;                  ===================

;     Definition of VarTable
;     ----------------------
defclass VarTable <: Gettable<Int,List<tgt-Var>> &
                     Settable<Int,List<tgt-Var>>
defmulti make-var (v:VarTable, t:tgt-TgtType) -> tgt-Var
defmulti types (v:VarTable, n:Int) -> List<tgt-TgtType>
defmulti defs (v:VarTable) -> Vector<tgt-DefVar>

defn VarTable () :
   val defs = Vector<tgt-DefVar>()
   val table = HashTable<Int,List<tgt-Var>>({_})
   val type-table = HashTable<Int,tgt-TgtType>({_})
   
   new VarTable :
      defmethod make-var (this, t:tgt-TgtType) :
         val n = fresh-id()
         add(defs, tgt-DefVar(n, t))
         type-table[n] = t
         tgt-Var(n)
      defmethod set (this, n:Int, vs:List<tgt-Var>) :
         table[n] = vs
      defmethod get (this, n:Int) :
         table[n]
      defmethod types (this, x:Int) :
         for v in this[x] map :
            type-table[tgt-n(v)]
      defmethod defs (this) :
         defs

defn get (v:VarTable, ns:List<Int>) :
   map-append({v[_]}, ns)
defn get (t:VarTable, v:KLSVar) :
   t[n(v)]
defn get (t:VarTable, vs:List<KLSVar>) :
   t[map(n,vs)]

defn make-vars (v:VarTable, ts:List<tgt-TgtType>) :
   for t in ts map :
      make-var(v, t)

;     Implicit VarTable
;     -----------------
var VAR-TABLE : False|VarTable = false
defn VAR-TABLE! () : VAR-TABLE as VarTable
defn make-var (t:tgt-TgtType) : make-var(VAR-TABLE!(), t)
defn make-vars (ts:List<tgt-TgtType>) : map(make-var, ts)
defn tgt-vars (n:Int) : VAR-TABLE!()[n]
defn tgt-vars (ns:List<Int>) : VAR-TABLE!()[ns]
defn tgt-vars (v:KLSVar) : VAR-TABLE!()[v]
defn tgt-vars (vs:List<KLSVar>) : VAR-TABLE!()[vs]
defn tgt-types (n:Int) : types(VAR-TABLE!(), n)
defn tgt-types (v:KLSVar) : types(VAR-TABLE!(), n(v))


;                    Global Table
;                    ============

defclass GlobalTable
defmulti global? (t:GlobalTable, n:Int) -> True|False
defmulti global-lbl (t:GlobalTable, n:Int) -> Int|Symbol
defmulti global-type (t:GlobalTable, n:Int) -> KLSType
defmulti function? (t:GlobalTable, n:Int) -> True|False
defmulti function-lbl (t:GlobalTable, n:Int) -> Int|Symbol

defn global-table (prog:KProg) :
   val globals = HashTable<Int, Int|Symbol>({_})
   val global-types = HashTable<Int, KLSType>({_})
   val functions = HashTable<Int,Int|Symbol>({_})
   
   for c in comms(prog) do :
      defn mark-global (n:Int, lbl:Int|Symbol, t:KLSType) :
         globals[n] = lbl
         global-types[n] = t
      defn mark-function (n:Int, lbl:Int|Symbol, t:KLSType) :
         mark-global(n, lbl, t)
         functions[n] = lbl
      
      match(c) :
         (c:KDef|KDefVar) : error("Not yet implemented.")
         (c:KDefn) : error("Not yet implemented.")
         (c:KDefmulti) : error("Not yet implemented.")
         (c:KLSDef) : mark-global(n(c), n(c), type(c))
         (c:KLSDefn) : mark-function(n(c), n(c), KFnT(a1(c), false, a2(c)))
         (c:KExtern) : mark-global(n(c), name(c), type(c))
         (c:KExternFn) : mark-function(n(c), name(c), type(c))
         (c) : false

   new GlobalTable :
      defmethod global? (this, n:Int) : key?(globals, n)
      defmethod global-lbl (this, n:Int) : globals[n]
      defmethod global-type (this, n:Int) : global-types[n]
      defmethod function? (this, n:Int) : key?(functions, n)
      defmethod function-lbl (this, n:Int) : functions[n]



;               LoStanza Function Normalization
;               ===============================

defn in-reverse<?T> (xs:Vector<?T>) :
   for i in (length(xs) - 1) through 0 by -1 stream :
      xs[i]

defn normalize (comm:KLSComm) :
   defn norm-scope (c:KLSComm) :
      val def-vector = Vector<KeyValue<Int,KLSExp|KLSType>>()
      defn fresh-var (value:KLSExp) :
         val n = fresh-id()
         add(def-vector, n => value)
         KLSVar(n)

      defn force-var (e:KLSExp) :
         match(e) :
            (e:KLSVar) : e
            (e:KLSExp) : fresh-var(norm-exp(e))

      defn norm-exp (e:KLSExp) :
         map(force-var, e)

      defn norm-comm (c:KLSComm) :
         match(c) :
            (c:KLSCall) :
               map(norm-exp, c)
            (c:KLSTCall) :
               map(norm-exp, c)
            (c:KLSSet) :
               KLSSet(map(force-var, exp(c)),
                      force-var(value(c)))                     
            (c:KLSReturn) :
               map(force-var, c)
            (c:KLSLet) :
               add(def-vector, n(c) => norm-exp(value(c)))
               norm-comm(body(c))
            (c:KLSLetVar) :
               add(def-vector, n(c) => type(c))
               norm-comm(body(c))
            (c:KLSSeq) :
               KLSSeq(norm-comm(a(c))
                      norm-scope(b(c)))
            (c:KLSIf) :
               KLSIf(force-var(pred(c))
                     norm-scope(conseq(c))
                     norm-scope(alt(c)))
            (c:KLSMatch) :
               error("Untested.")
               KLSMatch(map(force-var, args(c)),
                        map(map{norm-scope, _}, branches(c)))
            (c:KLSPrimComm) :
               map(force-var, c)
            (c) : c   

      var ret = norm-comm(c)
      for entry in in-reverse(def-vector) do :
         ret = match(value(entry)) :
            (v:KLSExp) : KLSLet(key(entry), v, ret)
            (t:KLSType) : KLSLetVar(key(entry), t, ret)
      ret

   ;Return result
   norm-scope(comm)


;                 LoStanza Call Conversion
;                 ========================

defn convert-calls (c:KLSComm, gt:GlobalTable) :
   defn direct (f:KLSVar) :
      if function?(gt, n(f)) : n(f)
      else : f
   defn conv-comm (c:KLSComm) :
      map(conv-comm, map(conv-exp, c))
   defn conv-exp (e:KLSExp) :
      match(map(conv-exp, e)) :
         (e:KLSDo) :
            KLSWDo(length(args(e)), direct(func-var(e)), args(e), type(e))
         (e:KLSCallC) :
            KLSWCallC(direct(func-var(e)), args(e), type(e))
         (e:KLSCallS) :
            error("Convert Stanza call.")               
         (e) : e

   conv-comm(c)


;                   LoStanza Global Access
;                   ======================

defn make-global-readers (c:KLSComm, gt:GlobalTable) :
   defn add-loc-readers (l:KLoc) -> KLoc :
      match(l) :
         (l:Value) :
            if exp(l) not-typeof KLSVar :
               error("Not in normalized form.")
            val n = n(exp-var(l))   
            if global?(gt, n) : Global(n)
            else : Local(n)
         (l:Field) : Field(add-loc-readers(base(l)), n(l))
         (l) : map(add-exp-readers, l)
   defn add-exp-readers (e:KLSExp) :
      match(e) :
         (e:KLSVar) :
            if global?(gt, n(e)) : KLSRead(Global(n(e)))
            else : e
         (e:KLSPtr) : KLSPtr(add-loc-readers(exp(e)))
         (e:KLSRead) : KLSRead(add-loc-readers(exp(e)))
         (e) : map(add-exp-readers, e)
   defn add-comm-readers (c:KLSComm) :
      match(c) :
         (c:KLSSet) :
            KLSSet(add-loc-readers(exp(c))
                   add-exp-readers(value(c)))
         (c) :
            map(add-comm-readers, map(add-exp-readers, c))

   normalize(add-comm-readers(c))


;                   Transformations
;                   ===============

defn transform (prog:KProg, gt:GlobalTable) :
   val cs = for c in comms(prog) map :
      match(c) :
         (c:KLSDefn) :
            var body* = convert-calls(body(c), gt)
            body* = make-global-readers(body*, gt)
            KLSDefn(n(c), targs(c), a1(c), a2(c), args(c), body*)
         (c:KLSInit) :
            var comm* = convert-calls(comm(c), gt)
            comm* = make-global-readers(comm*, gt)
            KLSInit(comm*)
         (c) : c
   KProg(cs)      
      

;                      Compilation
;                      ===========

defn global-mem (t:GlobalTable, n:Int) :
   match(global-lbl(t, n)) :
      (l:Int) : mem(l)
      (l:Symbol) : xmem(l)

defn function-mem (t:GlobalTable, n:Int) :
   match(function-lbl(t, n)) :
      (l:Int) : mem(l)
      (l:Symbol) : xmem(l)

definterface CResult
defmulti assign (xs:List<tgt-Var>, r:CResult) -> False
defmulti imms (r:CResult) -> List<tgt-Imm>
defmulti vars (r:CResult) -> List<tgt-Var>

defn compile (prog:KProg, tt:TypeTable, gt:GlobalTable) -> tgt-Program :
   ;     Overall Compiler
   ;     ----------------
   val globals = Vector<KeyValue<Int,KLSType>>()
   
   defn compile (c:KComm) :
      match(c) :
         (c:KDef) : error("Compile KDef command.")
         (c:KDefVar) : error("Compile KDefVar command.")
         (c:KDefn) : error("Compile KDefn command.")
         (c:KDefmulti) : error("Compile KDefmulti command.")
         (c:KDefmethod) : error("Compile KDefmethod command.")
         (c:KDefType) : error("Compile KDefType command.")
         (c:KExpComm) : error("Compile KExpComm command.")
         (c:KLSDef) : add(globals, n(c) => type(c))
         (c:KLSDefn) : compile-lsdefn(c)
         (c:KLSDefType) : false
         (c:KExtern) : false
         (c:KExternFn) : false
         (c:KLSInit) : false


   ;     Table Compiler
   ;     --------------
   defn compile-tables () :
      ;Floating Point Zeros
      emit(tgt-TLabel(FLOAT-ZERO-LBL))
      emit(tgt-DefFloat(0.0))
      emit(tgt-TLabel(DOUBLE-ZERO-LBL))
      emit(tgt-DefDouble(0.0))
      ;Heap Labels
      emit(tgt-DefData())
      emit(tgt-TLabel(HEAP-PTR-LBL))
      emit(tgt-DefLong(0))
      emit(tgt-TLabel(HEAP-LIM-LBL))
      emit(tgt-DefLong(0))
      emit(tgt-DefText())
      

   ;     Global Labels Compiler
   ;     ----------------------
   defn compile-globals () :
      ;Sort all globals by alignment for packing
      sort-by-key!(globals, alignment{tt, value(_)})
      ;Pad all the items to ensure structures are aligned
      val items = for e in globals stream :
         Item(alignment(tt, value(e)), e)
      val [items*, aln] = pad(items, 1)
      ;Start emission of table
      emit(tgt-DefData())
      for x in items* do :
         match(x) :
            (x:Item) :
               val entry = data(x) as KeyValue<Int,KLSType>
               val n = key(entry)
               val type = value(entry)
               emit(tgt-TLabel(n))
               for t in pad+expand(tt, type) do :
                  emit $ switch {t == _} :
                     tgt-BYTE-TYPE : tgt-DefByte(0)
                     tgt-INT-TYPE : tgt-DefInt(0)
                     tgt-LONG-TYPE : tgt-DefLong(0)
                     tgt-FLOAT-TYPE : tgt-DefFloat(0.0)
                     tgt-DOUBLE-TYPE : tgt-DefDouble(0.0)
                     tgt-REF-TYPE : tgt-DefLong(VOID-TAG)
            (x:Padding) :
               emit(tgt-DefSpace(size(x)))
      emit(tgt-DefText())
   

   ;     Entry Function Compiler
   ;     -----------------------
   defn compile-entry () :
      val var-table = VarTable()
      val ins-vector = Vector<tgt-Ins>()
      
      let-var INSTRUCTION-VECTOR = ins-vector :
         let-var VAR-TABLE = var-table :
            ;Compile initializing expressions
            for c in comms(prog) do :
               match(c) :
                  (c:KLSInit) : compile-comm(comm(c))
                  (c) : false
            ;Return zero
            return(list(long(0)))

            ;Create entry function, and return label
            val n = fresh-id()
            emit(tgt-DefFn(n, defs(var-table), ins-vector))
            n

   ;     Compiling a LoStanza Function
   ;     -----------------------------
   defn compile-lsdefn (c:KLSDefn) :
      val var-table = VarTable()
      val ins-vector = Vector<tgt-Ins>()

      ;Driver
      let-var INSTRUCTION-VECTOR = ins-vector :
         let-var VAR-TABLE = var-table :

            ;Compile function prelude
            for (v in args(c), t in a1(c)) do :
               var-table[v] = make-vars(expand(tt, t))
            args(var-table[args(c)])
         
            ;Compile function body
            compile-comm(body(c))

      ;Emit function definition
      emit(tgt-DefFn(n(c), defs(var-table), ins-vector))


   ;     Compiling LoStanza Constructs
   ;     -----------------------------
   ;Compile function body
   defn compile-comm (c:KLSComm) :      
      match(c) :
         (c:KLSCall) :
            assign(List(), compile-exp(exp(c)))
         (c:KLSTCall) :
            compile-tail-exp(exp(c))
         (c:KLSSet) :            
            defn value-offsets () :
               val t = match(exp(c)) :
                  (l:Global) : global-type(gt, n(l))
                  (l:Deref|Deptr|Slot) : type(l)
                  (l:Field) : field-type(tt, n(l))
               offsets(tt, t)
                  
            defn* loop (l:KLoc, off:Int, base-n:Int) :
               match(l) :
                  (l:Global) :
                     val p = global-mem(gt, n(l))
                     val ys = imms(compile-exp(value(c)))
                     for (o in value-offsets(), y in ys) do :
                        store(p, y, off + o)
                  (l:Local) :
                     val xs = tgt-vars(n(l))
                     val r = compile-exp(value(c))
                     assign(tailn(xs,base-n), r)
                  (l:Deref) :
                     error("Untested.")
                     val p = head(tgt-vars(exp-var(l)))
                     val ys = imms(compile-exp(value(c)))
                     for (o in value-offsets(), y in ys) do :
                        store(p, y, off + o + 8 - REF-TAG)
                  (l:Deptr) :
                     val p = head(tgt-vars(exp-var(l)))
                     val ys = imms(compile-exp(value(c)))
                     for (o in value-offsets(), y in ys) do :
                        store(p, y, off + o)
                  (l:Slot) :
                     val i = head(tgt-vars(index-var(l)))
                     val b = head(tgt-vars(exp-var(l)))
                     val ys = imms(compile-exp(value(c)))
                     val p = make-var(tgt-LONG-TYPE)
                     mul(p, long(size(tt, type(l))), i)
                     add(p, p, b)                        
                     for (o in value-offsets(), y in ys) do :
                        store(p, y, off + o)
                  (l:Field) :
                     loop(base(l),
                          off + field-offset(tt, n(l)),
                          base-n + field-index(tt, n(l)))
            loop(exp(c), 0, 0)
         (c:KLSLabel) :
            tlabel(n(c))
         (c:KLSGoto) :
            goto(n(c))
         (c:KLSReturn) :
            return(tgt-vars(exp-var(c)))
         (c:KLSLet) :
            VAR-TABLE!()[n(c)] = vars(compile-exp(value(c)))
            compile-comm(body(c))
         (c:KLSLetVar) :
            val ts = expand(tt, type(c))
            val vs = make-vars(ts)
            for (v in vs, t in ts) do :
               switch {t == _} :
                  tgt-BYTE-TYPE : set(v, byte(0))
                  tgt-INT-TYPE : set(v, int(0))
                  tgt-LONG-TYPE : set(v, long(0))
                  tgt-FLOAT-TYPE : load(v, mem(FLOAT-ZERO-LBL), 0)
                  tgt-DOUBLE-TYPE : load(v, mem(DOUBLE-ZERO-LBL), 0)
                  tgt-REF-TYPE : set(v, long(VOID-TAG))
            VAR-TABLE!()[n(c)] = vs
            compile-comm(body(c))
         (c:KLSIf) :
            val altL = fresh-id()
            val endL = fresh-id()
            val p = head(tgt-vars(pred-var(c)))
            jeq(altL, p, long(0))
            compile-comm(conseq(c))
            goto(endL)
            tlabel(altL)
            compile-comm(alt(c))
            tlabel(endL)
         (c:KLSSeq) :
            compile-comm(a(c))
            compile-comm(b(c))
         (c:KLSMatch) :
            error("Compile KLSMatch command.")
         (c:KLSPrimComm) :
            switch {op(c) == _} :
               SET-HEAP-PTR :
                  val x = head(tgt-vars(arg-vars(c)))
                  store(mem(HEAP-PTR-LBL), x, 0)
               SET-HEAP-LIM :
                  val x = head(tgt-vars(arg-vars(c)))
                  store(mem(HEAP-LIM-LBL), x, 0)
         (c:KLSSkip) :
            false

   defn compile-exp (e:KLSExp) -> CResult :
      ;Return immediates ys with given types ts
      defn ret-imms (ts:List<tgt-TgtType>, ys:List<tgt-Imm>) :
         new CResult :
            defmethod imms (this) : ys
            defmethod assign (xs:List<tgt-Var>, this) : do(set, xs, ys)                  
            defmethod vars (this) :
               val xs = make-vars(ts)
               assign(xs, this)
               xs
      ;Return single immediate y with type t         
      defn ret-imm (t:tgt-TgtType, y: tgt-Imm) :
         ret-imms(list(t), list(y))
      ;Return value of LSType t
      defn ret-type (t:KLSType, f: List<tgt-Var> -> False) :
         new CResult :
            defmethod imms (this) : vars(this)
            defmethod assign (xs:List<tgt-Var>, this) : f(xs)
            defmethod vars (this) :
               val vs = make-vars(expand(tt, t))
               assign(vs, this)
               vs
      ;Return value of Target type t
      defn ret-prim (t:tgt-TgtType, f: tgt-Var -> False) :
         new CResult :
            defmethod imms (this) : vars(this) 
            defmethod assign (xs:List<tgt-Var>, this) : f(head(xs))
            defmethod vars (this) :
               val vs = list(make-var(t))
               assign(vs, this)
               vs
               
      match(e) :
         (e:KLSVar) :
            ret-imms(tgt-types(e), tgt-vars(e))
         (e:KLSRef) :
            val st = KStructT(n(e))
            val sz = 8 + ceil8(size(tt, st))
            ret-prim{tgt-REF-TYPE, _} $ fn* (x) :
               if sz > 0 :
                  extend-heap(sz)
                  add(x, heap-ptr(), long(REF-TAG))
                  inc-heap-ptr(sz)
                  store(x, long(tag(tt, n(e))), neg(REF-TAG))
                  for (o in offsets(tt, st), v in tgt-vars(arg-vars(e))) do :
                     store(x, v, o + 8 - REF-TAG)
               else :
                  error("Untested.")
                  shl(x, long(tag(tt, n(e))), long(3))
                  add(x, x, long(MARKER-TAG))
         (e:KLSRefArray) :
            val st = KStructT(n(e))
            val rf = rfield(tt, n(e))
            val rft = field-type(tt, rf)
            ret-prim{tgt-REF-TYPE, _} $ fn* (x) :
               ;Compute size and extend heap
               val sz = make-var(tgt-LONG-TYPE)
               val len = head(tgt-vars(length-var(e)))
               mul(sz, long(size(tt, rft)), len)
               add(sz, sz, long(size(tt, st) + 8 + 7))
               bit-and(sz, sz, long(-8))
               extend-heap(sz)
               ;Store into heap
               add(x, heap-ptr(), long(REF-TAG))
               inc-heap-ptr(sz)
               store(x, long(tag(tt, n(e))), neg(REF-TAG))
               for (o in offsets(tt, st), v in tgt-vars(arg-vars(e))) do :
                  store(x, v, o + 8 - REF-TAG)
         (e:KLSStruct) :
            ret-imms(expand(tt, KStructT(n(e))),
                     tgt-vars(arg-vars(e)))
         (e:KLSPtr) :            
            ret-prim{tgt-LONG-TYPE, _} $ fn* (x) :
               defn* loop (l:KLoc, off:Int) :
                  match(l) :
                     (l:Global) :
                        val p = global-mem(gt, n(l))
                        addr(x, p, off)
                     (l:Local) :
                        error("Untested.")
                        val p = head(tgt-vars(n(l)))
                        addr(x, p, off)                        
                     (l:Deref) :
                        val p = head(tgt-vars(exp-var(l)))
                        add(x, p, long(off + 8 - REF-TAG))
                     (l:Deptr) :
                        val p = head(tgt-vars(exp-var(l)))
                        if off > 0 : add(x, p, long(off))
                        else : set(x, p)
                     (l:Slot) :
                        error("Untested.")
                        val i = head(tgt-vars(index-var(l)))
                        val p = head(tgt-vars(exp-var(l)))
                        mul(x, long(size(tt, type(l))), i)
                        add(x, x, p)
                        add(x, x, long(off)) when off > 0
                     (l:Field) :
                        loop(base(l),
                             off + field-offset(tt, n(l)))
               loop(exp(e), 0)
         (e:KLSRead) :            
            ;Offsets to load from
            defn value-offsets () :
               val t = match(exp(e)) :
                  (l:Global) : global-type(gt, n(l))
                  (l:Deref|Deptr|Slot) : type(l)
                  (l:Field) : field-type(tt, n(l))
               offsets(tt, t)

            ;Value type
            val ts = match(exp(e)) :
               (l:Global) : expand(tt, global-type(gt, n(l)))
               (l:Local) : tgt-types(n(l))
               (l:Deref|Deptr|Slot) : expand(tt, type(l))
               (l:Field) : expand(tt, field-type(tt, n(l)))

            ;Load into given variables
            defn ret-load (p:tgt-Imm, off:Int) :
               new CResult :
                  defmethod imms (this) :
                     vars(this)
                  defmethod vars (this) :
                     val xs = make-vars(ts)
                     assign(xs, this)
                     xs
                  defmethod assign (xs:List<tgt-Var>, this) :
                     for (x in xs, o in value-offsets()) do :
                        load(x, p, off + o)
               
            defn* loop (l:KLoc, off:Int, base-n:Int) -> CResult :
               match(l) :
                  (l:Global) :
                     val p = global-mem(gt, n(l))
                     ret-load(p, off)
                  (l:Local) :
                     val ys = tgt-vars(n(l))
                     val sub-ys = headn(tailn(ys, base-n), length(ts))
                     ret-imms(ts, sub-ys)
                  (l:Deref) :
                     val p = head(tgt-vars(exp-var(l)))
                     ret-load(p, off + 8 - REF-TAG)
                  (l:Deptr) :
                     val p = head(tgt-vars(exp-var(l)))
                     ret-load(p, off)
                  (l:Slot) :
                     val b = head(tgt-vars(exp-var(l)))
                     val i = head(tgt-vars(index-var(l)))
                     val p = make-var(tgt-LONG-TYPE)
                     mul(p, long(size(tt, type(l))), i)
                     add(p, p, b)
                     ret-load(p, off)
                  (l:Field) :
                     loop(base(l),
                          off + field-offset(tt, n(l)),
                          base-n + field-index(tt, n(l)))
            loop(exp(e), 0, 0)
         (e:KLSWDo) :
            ret-type{type(e), _} $ fn* (xs) :
               val ys = tgt-vars(arg-vars(e))
               val f = match(func-var(e)) :
                  (f:Int) : function-mem(gt, f)
                  (f:KLSVar) : head(tgt-vars(f))
               call(arity(e), xs, f, ys)
         (e:KLSWCallC) :
            ret-type{type(e), _} $ fn* (xs) :
               val ys = tgt-vars(arg-vars(e))
               val f = match(func-var(e)) :
                  (f:Int) : function-mem(gt, f)
                  (f:KLSVar) : head(tgt-vars(f))
               ffi-call(xs, f, ys)
         (e:KLSWCallClosure) :
            error("Untested.")
            ret-type{type(e), _} $ fn* (xs) :
               val ys = tgt-vars(arg-vars(e))
               val f = head(tgt-vars(func-var(e)))
               val code = make-var(tgt-LONG-TYPE)
               load(code, f, 8 - REF-TAG)
               call(arity(e), xs, code, List(f, ys))
         (e:KLSSizeof) :
            ret-imm(tgt-LONG-TYPE, long(size(tt, type(e))))
         (e:KLSTagof) :
            ret-imm(tgt-LONG-TYPE, long(tag(tt, n(e))))
         (e:KLSConv) :
            ret-type{type(e), _} $ fn* (xs) :
               val y = head(tgt-vars(exp-var(e)))
               conv(head(xs), y)
         (e:KLSPrim) :
            ret-type{type(e), _} $ fn* (xs) :
               switch {op(e) == _} :
                  GET-HEAP-LIM :
                     load(head(xs), mem(HEAP-LIM-LBL), 0)
                  GET-HEAP-PTR :
                     load(head(xs), mem(HEAP-PTR-LBL), 0)
                  else :
                     val ys = tgt-vars(arg-vars(e))
                     val op = to-tgt-op(op(e))
                     binop(head(xs), op, ys[0], ys[1])
         (e:KLSLitByte) :
            ret-imm(tgt-BYTE-TYPE, byte(value(e)))
         (e:KLSLitInt) :
            ret-imm(tgt-INT-TYPE, int(value(e)))
         (e:KLSLitLong) :
            ret-imm(tgt-LONG-TYPE, long(value(e)))
         (e:KLSLitFloat) :
            ret-prim{tgt-FLOAT-TYPE, _} $ fn* (x) :
               load(x, mem(float-lbl(value(e))), 0)
         (e:KLSLitDouble) :
            ret-prim{tgt-DOUBLE-TYPE, _} $ fn* (x) :
               load(x, mem(double-lbl(value(e))), 0)
         (e:KLSLitString) :
            ret-prim{tgt-LONG-TYPE, _} $ fn* (x) :
               addr(x, mem(string-lbl(value(e))), 0)
         (e) :
            error("No branch defined for ~" % [e])

   defn compile-tail-exp (e:KLSExp) -> False :
      match(e) :
         (e:KLSWDo) :
            val ys = tgt-vars(arg-vars(e))
            val f = match(func-var(e)) :
               (f:Int) :
                  match(function-lbl(gt, f)) :
                     (f:Int) : mem(f)
                     (f:Symbol) : xmem(f)
               (f:KLSVar) : head(tgt-vars(f))
            tcall(arity(e), f, ys)
         (e:KLSWCallClosure) :
            error("Untested.")
            val ys = tgt-vars(arg-vars(e))
            val f = head(tgt-vars(func-var(e)))
            val code = make-var(tgt-LONG-TYPE)
            load(code, f, 8 - REF-TAG)
            tcall(arity(e), code, List(f, ys))
         (e) :
            error("Not a legal tail expression: ~" % [e])

   ;     Driver
   ;     ------
   val def-ins-vector = Vector<tgt-DefIns>()
   let-var DEF-INS-VECTOR = def-ins-vector :
      do(compile, comms(prog))
      compile-tables()
      compile-globals()
      val entry = compile-entry()
      tgt-Program(def-ins-vector, entry)


