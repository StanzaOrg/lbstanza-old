#include<"core/stringeater.stanza">
#include<"compiler/stz-algorithms.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">
#include("compiler/stz-utils.stanza")
#include("compiler/stz-kl-ir.stanza")

defpackage stz/kform :
   import core
   import verse
   import stz/kl-ir
   import stz/utils
   import stz/lexer


;                          Parser
;                          ======

defsyntax kl-ir :
   val ut = unwrap-token

   defn seqs (xs:List<KExp>) :
      if empty?(xs) : error("Empty Begin Expression")
      else if empty?(tail(xs)) : head(xs)
      else : KSeq(head(xs), seqs(tail(xs)), false)
      
   defn seqs (xs:List<KLSComm>) :
      if empty?(xs) : error("Empty Begin Expression")
      else if empty?(tail(xs)) : head(xs)
      else : KLSSeq(head(xs), seqs(tail(xs)))

   defrule :
      sym = (?x) when ut(x) typeof Symbol : ut(x)
      int = (?x) when ut(x) typeof Int : ut(x)

      ;     KTypes
      ;     ------
      type = (($var ?n:#int)) : KTVar(n)
      type = (($and ?a:#type ?b:#type)) : KAnd(a, b)
      type = (($or ?a:#type ?b:#type)) : KAnd(a, b)
      type = (top) : KTop()
      type = (bot) : KBot()
      type = (($of ?n:#int)) : KOf(n)

      ;     KCommands
      ;     ---------
      comm = (($def ?x:#int ?v:#exp)) : KDef(x, v)
      comm = (($defvar ?x:#int)) : KDefVar(x, false)
      comm = (($defvar ?x:#int ?v:#exp)) : KDefVar(x, v)
      comm = (($defn ?x:#int (?targs:#int ...) (?a1:#type ...) (?args:#int ...) ?body:#exp)) :
         KDefn(x, KFn(false, targs, a1, args, body))
      comm = (($defn* ?x:#int (?targs:#int ...) (?a1:#type ...) (?args:#int ...) ?body:#exp)) :
         KDefn(x, KFn(true, targs, a1, args, body))
      comm = (($defmulti ?x:#int (?targs:#int ...) (?a1:#type ...))) :
         KDefmulti(x, targs, a1)         
      this = (($this ?x:#int)) : x
      this = () : false
      comm = (($defmethod ?m:#int ?t:#this (?targs:#int ...) (?a1:#type ...) (?args:#int ...) ?body:#exp)) :
         KDefmethod(fresh-id(), m, t, KFn(false, targs, a1, args, body))
      comm = (($defmethod* ?m:#int ?t:#this (?targs:#int ...) (?a1:#type ...) (?args:#int ...) ?body:#exp)) :
         KDefmethod(fresh-id(), m, t, KFn(true, targs, a1, args, body))
      comm = (($deftype ?x:#int)) : KDefType(x, false)   
      comm = (($deftype ?x:#int ?p:#type)) : KDefType(x, p)
      comm = (($lsdef ?x:#int ?t:#lstype ?v:#exp)) : KLSDef(x, t, v)
      comm = (($lsdefvar ?x:#int ?t:#lstype)) : KLSDefVar(x, t, false)
      comm = (($lsdefvar ?x:#int ?t:#lstype ?v:#exp)) : KLSDefVar(x, t, v)
      comm = (($lsdefn ?x:#int (?targs:#int ...) (?a1:#lstype ...) ?a2:#lstype (?args:#int ...) ?body:#lscomm)) :
         KLSDefn(x, targs, a1, a2, args, body)
      lsparent = (($parent ?p:#lstype)) : p
      lsparent = () : false
      lsfield = ((?x:#int ?t:#lstype)) : StructField(x, t)
      lsfield? = (?f:#lsfield) : f
      lsfield? = () : false
      comm = (($lsdeftype ?x:#int ?p:#lsparent (?f:#lsfield ...) ?rf:#lsfield?)) :
         KLSDefType(x, p, f, rf)
      comm = (($extern ?x:#int ?t:#lstype ?n:#sym)) : KExtern(x, t, n)
      comm = (($externfn ?x:#int ?t:#lstype ?n:#sym)) : KExternFn(x, t, n)
      comm = (?e:#exp) : KExpComm(e)

      ;     KForm Expressions
      ;     -----------------
      exp = (($set ?x:#int ?v:#var)) : KSet(x, v, false)
      exp = (($cast ?x:#var ?t:#type)) : KCast(x, t, false)
      exp = (($checkvoid ?x:#var)) : KCheckVoid(x, false)
      exp = (($checklength ?x:#var ?length:#int)) : KCheckLength(x, length, false)
      exp = (($let ?def:#comm ?body:#exp)) : KLet(def, body, false)
      exp = (($letrec (?defs:#comm ...) ?body:#exp)) : KLetRec(defs, body, false)
      exp = (($begin ?es:#exp ...)) : seqs(es as List<KExp>)
      exp = (($dispatch (?xs:#var ...) ?bs:#branch ...)) : KDispatch(xs, bs, false)
      exp = (($match (?xs:#var ...) ?bs:#branch ...)) : KMatch(xs, bs, false)
      exp = (($new ?c:#type ?m:#comm ...)) : KNew(c, m, false)
      exp = (($do ?f:#var (?targs:#var ...) ?args:#var ...)) : KDo(f, targs, args, false)
      exp = (($call-ls ?f:#var (?targs:#var ...) ?args:#var ...)) : KCallLS(f, targs, args, false)
      exp = (($tuple ?es:#var ...)) : KTuple(es, false)
      exp = (($tuple-get ?v:#var ?i:#int)) : KTupleGet(v, i, false)
      exp = (($value ?v)) : KLiteral(ut(v), false)
      exp = (?v:#var) : v
      var = (($var ?n:#int)) : KVar(n, false)

      ;     KLSTypes
      ;     --------
      lstype = (byte) : KByteT()
      lstype = (int) : KIntT()
      lstype = (long) : KLongT()
      lstype = (float) : KFloatT()
      lstype = (double) : KDoubleT()
      lstype = (uk) : KUnknownT()
      lstype = (($ptr ?t:#lstype)) : KPtrT(t)
      lstype = (($ref ?t:#type)) : KRefT(t)
      lstype = (($fn (?a:#lstype ...) ?r:#lstype ?b:#lstype)) : KFnT(a, r, b)
      lstype = (($fn (?a:#lstype ...) ?b:#lstype)) : KFnT(a, false, b)
      lstype = (($struct ?x:#int)) : KStructT(x)
      
      ;     KLocs
      ;     -----
      loc = (($deref ?e:#lsvar)) : Deref(e)
      loc = (($deptr ?e:#lsvar)) : Deptr(e)
      loc = (($slot ?e:#lsvar ?t:#lstype ?i:#lsvar)) : Slot(e, t, i)
      loc = (($field ?b:#loc ?x:#int)) : Field(b, x)
      loc = (?e:#lsvar) : Binder(e)

      ;     LoStanza Commands
      ;     -----------------
      lscomm = (($jump ?e:#lsexp)) : KLSTCall(e)
      lscomm = (($set ?e:#loc ?v:#lsvar)) : KLSSet(e, v)
      lscomm = (($label ?x:#int)) : KLSLabel(x)
      lscomm = (($goto ?x:#int)) : KLSGoto(x)
      lscomm = (($return ?x:#lsvar)) : KLSReturn(x)
      lscomm = (($let ?def:#comm ?body:#lscomm)) : KLSLet(def, body)
      lscomm = (($begin ?cs:#lscomm ...)) : seqs(cs as List<KLSComm>)
      lscomm = (($if ?p:#lsvar ?c:#lscomm ?a:#lscomm)) : KLSIf(p, c, a)
      lscomm = (($if ?p:#lsvar ?c:#lscomm)) : KLSIf(p, c, KLSSkip())
      lscomm = (($match (?a:#args ...) ?b:#lsbranch ...)) : KLSMatch(a, b)
      lscomm = (?e:#lsexp) : KLSCall(e)

      ;     LoStanza Expressions
      ;     --------------------
      lsexp = (($ref ?x:#int ?args:#lsvar ...)) : KLSRef(x, args)
      lsexp = (($refarray ?x:#int ?len:#lsvar ?args:#lsvar ...)) : KLSRefArray(x, len, args)
      lsexp = (($struct ?x:#int ?args:#lsvar ...)) : KLSStruct(x, args)
      lsexp = (($ptr ?e:#lsvar)) : KLSPtr(e)
      lsexp = (($read ?e:#loc)) : KLSRead(e)
      lsexp = (($do ?t:#lstype ?f:#lsvar (?ts:#type ...) ?args:#lsvar ...)) : KLSDo(f, ts, args, t)
      lsexp = (($call-c ?t:#lstype ?f:#lsvar ?args:#lsvar ...)) : KLSCallC(f, args, t)
      lsexp = (($call-s ?t:#lstype ?f:#lsvar (?ts:#type ...) ?args:#lsvar ...)) : KLSCallS(f, ts, args, t)
      lsexp = (($sizeof ?t:#lstype)) : KLSSizeof(t)
      lsexp = (($tagof ?x:#int)) : KLSTagof(x)
      lsexp = (($conv ?x:#lsvar ?src:#lstype ?dst:#lstype)) : KLSConv(x, src, dst)
      lsexp = (($value ?v)) : KLSValue(ut(v))
      lsexp = (?v:#lsvar) : v
      lsvar = (($var ?x:#int)) : KLSVar(x)

defn parse-kl-ir (file:String) -> KComm :
   val lexed = lex-file(file)
   with-syntax(kl-ir) :
      match-syntax(lexed) :
         (?c:#comm) :
            c


;                      Testing
;                      =======

defn headline (str:String) :
   val n = length(str)
   val m = 30 - n / 2
   println()
   do(print{" "}, 0 to m)
   println(str)
   do(print{" "}, 0 to m)
   do(print{"="}, 0 to n)
   println()
      
defn main () :
   val filename = commandline-arguments()[1]
   val program = parse-kl-ir(filename)
   
   headline("KForm Program")
   println(program)

main()