defpackage stz/kform :
   import core
   import collections
   import stz/namemap
   import stz/tl-ir
   import stz/type-calculus
   import stz/kl-ir
   import stz/ids
   import stz/utils
   import stz/padder
   import stz/params
   import stz/tgt-ir with: (prefix => tgt-)
   import stz/primitives with: (prefix => prim-)
   import stz/algorithms


;                           Driver
;                           ======

public defn compile (program:TProg, nm:NameMap) :
   vheader("KForm Conversion")
   var prog:KProg = to-kform(program, nm)
   ;println(prog)

   vheader("Intersection Object Conversion")
   prog = remove-intersection-objects(prog)
   ;println(prog)

   vheader("Void Check Insertion")
   prog = void-check-insertion(prog)
   ;println(prog)

   vheader("Box Mutables")
   prog = box-mutables(prog)
   ;println(prog)

   vheader("Constant Lifting")
   prog = constant-lifting(prog)
   ;println(prog)

   vheader("Method Mapping")
   prog = method-targ-mapping(prog)
   ;println(prog)

   vheader("Callsite Normalization")
   prog = callsite-normalization(prog)
   ;println(prog)

   vheader("Closure Creation")
   prog = closure-creation(prog)
   ;println(prog)

   vheader("Mix Conversion")
   prog = mix-conversion(prog)
   ;println(prog)

   vheader("Boundary Guard Insertion")
   prog = boundary-guard-insertion(prog)
   ;println(prog)

   vheader("Detect Loops")
   prog = detect-loops(prog)
   ;println(prog)

   vheader("Simple Inlining")
   prog = simple-inlining(prog)
   ;println(prog)

   vheader("Type Inference")
   prog = infer-types(prog)
   ;println(prog)

   vheader("Cast Elision")
   prog = elide-casts(prog)
   ;println(prog)

   if flag-defined?(`OPTIMIZE) :
      vheader("Remove Checks")
      prog = remove-checks(prog)
      ;println(prog)
      
      vheader("Inlining")
      prog = inline(prog)
      ;println(prog)

      vheader("Type Erasure")
      prog = type-erasure(prog)
      ;println(prog)

      vheader("Lambda Lift")
      prog = lambda-lift(prog)
      ;println(prog)

   vheader("Type Reification")
   prog = type-reification(prog)
   ;println(prog)

   vheader("Automatic Primitive Tagging")
   prog = primitive-tagging(prog)
   ;println(prog)

   vheader("Freevar Calculation")
   var freetable = freevar-table(prog)
   ;println(freetable)

   vheader("Object Lifting")
   prog = lift-objects(prog, freetable)
   ;println(prog)

   vheader("Multi Conversion")
   prog = convert-multis(prog)
   ;println(prog)

   vheader("Dispatch Conversion")
   prog = dispatch-conversion(prog)
   ;println(prog)

   if flag-defined?(`OPTIMIZE) :
      vheader("Type Inference")
      prog = infer-types(prog)
      ;println(prog)
      
      vheader("Inlining")
      prog = inline(prog)
      ;println(prog)

   vheader("Freevar Calculation After Objects")
   freetable = freevar-table(prog)
   ;println(freetable)

   vheader("Closure Lifting")
   prog = lift-closures(prog, freetable)
   ;println(prog)

   ;vheader("Global closures")
   prog = make-global-closures(prog)
   ;println(prog)

   vheader("Call Conversion")
   prog = convert-calls(prog)
   ;println(prog)

   vheader("Code Conversion")
   prog = convert-code(prog)
   ;println(prog)

   vheader("Cast Conversion")
   prog = cast-conversion(prog)
   ;println(prog)

   vheader("Compilation")
   compile(prog)
   ;println(compiled)

;============================================================
;=================== Utilities ==============================
;============================================================

defn global-fn? (nm:NameMap, n:Int) :
   if key?(nm, n) :
      val e = nm[n]
      (type(e) is FnE|MultiE|LFnE) and
      (visibility(e) is-not Local)

;============================================================
;=================== Conversion =============================
;============================================================

defn to-kform (prog:TProg, nm:NameMap) :
   ;        Track Expected Return Type
   ;        ==========================
   var current-return-type : False|LSType = false

   ;    Type Specific Conversion Functions
   ;    ==================================
   defn to-comm (c:TComm) -> KComm :
      match(c) :
         (c:TDef) :
            val value* = KCast(to-exp(value(c)), to-type!(type(c)), info(c), false)
            ;TODO: Cast should be moved to boundary insertion.
            KDef(n(c), value*)
         (c:TDefVar) :
            ;TODO: Cast should be moved to boundary insertion.
            val t* = to-type!(type(c))
            val v* = match(value(c)) :
               (v:False) : false
               (v:TExp) : KCast(to-exp(v), to-type!(type(c)), info(c), false)
            KDefVar(n(c), t*, v*)
         (c:TDefn) :
            val f = KFn(
               fresh-id(),
               tail?(c),
               append(targs(c), cargs(c)),
               map(to-type!, a1(c)),
               to-type!(a2(c)),
               false,
               args(c),
               to-exp(body(c))
               info(c))
            KDefn(n(c), f)
         (c:TDefmulti) :
            KDefmulti(
               n(c),
               append(targs(c), cargs(c)),
               map(to-type!, a1(c)),
               to-type!(a2(c)),
               info(c))
         (c:TDefmethod) :
            val f = KFn(
               fresh-id(),
               tail?(c),
               append(targs(c), cargs(c))
               map(to-type!, a1(c))
               to-type!(a2(c))
               false,
               args(c),
               to-exp(body(c)),
               info(c))
            val [multi, multi-targs] = to-multi(multi(c))
            KDefmethod(fresh-id(), multi, multi-targs, thisn(c), f)
         (c:TInit) :
            KInit(to-exp(exp(c)))
         (c:TLDef) :
            KLSDef(
               n(c),
               to-ls-type(type(c)),
               to-ls-exp-upcast(value(c), type(c)))
         (c:TLDefVar) :
            KLSDefVar(
               n(c),
               to-ls-type(type(c)),
               to-ls-exp-upcast(value(c), type(c)))
         (c:TLDefn) :
            let-var current-return-type = a2(c) :
               KLSDefn(
                  tail?(c),
                  n(c),
                  append(targs(c), cargs(c)),
                  map(to-ls-type, a1(c)),
                  to-ls-type(a2(c)),
                  args(c),
                  to-ls-comm(body(c)),
                  info(c))
         (c:TLExternFn) :
            let-var current-return-type = a2(c) :
               KLSExternFn(
                  n(c),
                  name(nm[n(c)]),
                  map(to-ls-type, a1(c)),
                  to-ls-type(a2(c)),
                  args(c),
                  to-ls-comm(body(c)),
                  info(c))
         (c:TLDefmethod) :
            let-var current-return-type = a2(c) :
               val [multi, multi-targs] = to-multi(multi(c))
               KLSDefmethod(
                  tail?(c),
                  n(c),
                  multi,
                  multi-targs,
                  append(targs(c), cargs(c)),
                  map(to-ls-type, a1(c)),
                  to-ls-type(a2(c)),
                  args(c),
                  to-ls-comm(body(c)),
                  info(c))
         (c:TExtern) :
            KExtern(
               n(c),
               to-ls-type(type(c)),
               name(nm[n(c)]))
         (c:TLInit) :
            KLSInit(to-ls-comm(comm(c)))

   defn to-comms (c:TComm) -> List<KComm> :
      match(c) :
         (c:TDefTuple) :
            val n* = fresh-id()
            val arity = length(ns(c))
            val value* = KCast(to-exp(value(c)), KOf(TUPLE-TYPE-ID), info(c), false)
            val def1 = KDef(n*, KCheckLength(value*, arity, info(c), false))
            val def2 = for (n in ns(c), t in types(c), i in 0 to arity) map :
               val v = KTupleGet(KVar(n*,info(c),false), i, info(c), false)
               KDef(n, KCast(v, to-type!(t), info(c), false))
            cons(def1, def2)

   defn to-comms (h:THierarchy) -> List<KComm> :
      defn to-parent (t:False|Type) :
         to-type(t as Type) when t is-not False
      defn to-field (f:False) :
         false
      defn to-field (f:stz/tl-ir/Field) :
         StructField(n(f), to-ls-type(type(f)))

      to-list $ for e in h seq :
         match(e) :
            (e:HSHEntry) :
               KDefType(n(e), to-parent(parent(e)))
            (e:LSHEntry) :
               KLSDefType(
                  n(e),
                  to-parent(parent(e)),
                  map(to-field, fields(e)),
                  to-field(rfield(e)))

   defn to-multi (e:TExp) -> [Int, List<KType>] :
      match(e) :
         (e:TRef) : [n(e), List()]
         (e:TCurry) : [n(ref(e)), map(to-type!, append(targs(e), cargs(e)))]
         (e:TMix) : to-multi(select-1(sel(e), exps(e)))

   defn to-exp (e:TExp) -> KExp :
      match(e) :
         (e:TLet) :
            val value* = KCast(to-exp(value(e)), to-type!(ntype(e)), info(e), false)
            KLet(
               KDef(n(e), value*)
               to-exp(body(e)),
               false)
         (e:TLetVar) :
            ;TODO: Cast should be moved to boundary insertion.
            val t* = to-type!(ntype(e))
            val v* = match(value(e)) :
               (v:TExp) : KCast(to-exp(v), to-type!(ntype(e)), info(e), false)
               (v) : false
            KLet(
               KDefVar(n(e), t*, v*)
               to-exp(body(e)),
               false)
         (e:TLetTuple) :
            defn wrap (defs:List<KComm>) :
               if empty?(defs) :
                  to-exp(body(e))
               else :
                  val def = head(defs) as KDefn|KDef|KDefVar
                  KLet(def, wrap(tail(defs)), false)
            wrap(to-comms(TDefTuple(ns(e), ntypes(e), value(e), info(e))))
         (e:TLetRec) :
            KLetRec(
               map(to-comm, defns(e)) as List<KDefn>,
               to-exp(body(e)),
               info(e),
               false)
         (e:TSeq) :
            KSeq(to-exp(a(e)), to-exp(b(e)), false)
         (e:TMatch) :
            val branches* = for b in branches(e) map :
               KBranch(
                  args(b),
                  map(to-type!, atypes(b)),
                  to-exp(body(b)),
                  info(b))
            KMatch(
               map(to-exp, args(e))
               branches*,
               info(e),
               false)
         (e:TFn|TMulti) :
            defn to-fn (e:TFn) -> KFn :
               KFn(fresh-id(),
                   tail?(e),
                   List(),
                   map(to-type!, a1(e)),
                   to-type!(a2(e)),
                   false,
                   args(e),
                   to-exp(body(e)),
                   info(e))
            defn to-fn (e:TMulti) -> KMultifn :
               KMultifn(fresh-id(), map(to-fn, funcs(e)), info(e))
            val n* = fresh-id()
            KLet(KDefn(n*, to-fn(e)), KVar(n*,info(e),false), false)
         (e:TNew) :
            KNew(
               to-type(class(e)),
               map(to-comm, methods(e)) as List<KDefmethod>,
               info(e),
               false)
         (e:TRef) :
            KVar(n(e), info(e), false)
         (e:TCast|TUpCast) :
            KCast(
               to-exp(exp(e)),
               to-type(targ(e)),
               info(e),
               false)
         (e:TSet) :
            ;TODO: Cast should be moved to boundary insertion.
            val t = to-type!(type(ref(e)))
            val value* = KCast(to-exp(value(e)), t, info(e), false)
            KSet(n(ref(e)), value*, false)
         (e:TDo) :
            val a1* = map(to-type!{type(ctxt(_) as CExp)}, args(e))
            val a2* = to-type!(type(e))
            val f* = to-exp(func(e))
            val args* = map(to-exp, args(e))
            KDo(f*, args*, a1*, a2*, info(e), false)
         (e:TPrim) :
            val args* = map(to-exp, args(e))
            val op* = switch {op(e) == _} :
               prim-ADD-OP : INT-ADD-OP
               prim-SUB-OP : INT-SUB-OP
               prim-MUL-OP : INT-MUL-OP
               prim-DIV-OP : INT-DIV-OP
               prim-MOD-OP : INT-MOD-OP
               prim-AND-OP : INT-AND-OP
               prim-OR-OP : INT-OR-OP
               prim-XOR-OP : INT-XOR-OP
               prim-SHL-OP : INT-SHL-OP
               prim-SHR-OP : INT-SHR-OP
               prim-ASHR-OP : INT-ASHR-OP
               prim-EQ-OP : INT-EQ-OP
               prim-NE-OP : INT-NE-OP
               prim-LT-OP : INT-LT-OP
               prim-GT-OP : INT-GT-OP
               prim-LE-OP : INT-LE-OP
               prim-GE-OP : INT-GE-OP
               prim-NOT-OP : INT-NOT-OP
               prim-NEG-OP : INT-NEG-OP
               prim-IDENTICAL-OP : IDENTICAL-OP
               prim-AGET-OP : AGET-OP
               prim-ASET-OP : ASET-OP
               prim-ALEN-OP : ALEN-OP
               prim-CHAR-AGET-OP : CHAR-AGET-OP
               prim-CHAR-ASET-OP : CHAR-ASET-OP
               prim-STRING-GET-OP : STRING-GET-OP
               prim-STRING-LEN-OP : STRING-LEN-OP
            KPrim(op*, args*, false)
         (e:TLiteral) :
            KLiteral(value(e), false)
         (e:TTupleExp) :
            KTuple(map(to-exp, exps(e)), info(e), false)
         (e:TMix) :
            val exps* = map(to-curry, select-all(sel(e), exps(e)))
            if length(exps*) == 1 : head(exps*)
            else : KMix(exps*, info(e), false)
         (e:TCurry) :
            to-curry(e)

   defn to-curry (e:TExp) :
      val a1 = types(a(type(e) as TArrow) as TTuple)
      val a2 = b(type(e) as TArrow)
      val a1* = map(to-type, a1)
      val a2* = to-type(a2)
      match(e) :
         (e:TCurry) :
            val targs = append(targs(e), cargs(e))
            KCurry(n(ref(e)), map(to-type!, targs), a1*, a2*, info(e), false)
         (e:TRef) :
            KCurry(n(e), List(), a1*, a2*, info(e), false)

   defn to-type! (t:False|Type) -> KType :
      to-type(t as Type)

   defn to-ls-type! (t:False|LSType) -> KLSType :
      to-ls-type(t as LSType)

   defn to-type (t:Type) -> KType :
      match(t) :
         (t:TCap) : KTVar(n(t))
         (t:TOf) : KOf(n(t))
         (t:TTuple) : KOf(TUPLE-TYPE-ID)
         (t:TOr) : KOr(to-type(a(t)), to-type(b(t)))
         (t:TAnd) : KAnd(to-type(a(t)), to-type(b(t)))
         (t:TVar) : KTVar(n(t))
         (t:TArrow) : KOf(FN-TYPE-ID)
         (t:TGradual) : KTop()
         (t:TBot) : KBot()
         (t) : fatal("Type cannot be converted to KType: %~" % [t])

   defn to-ls-type (t:LSType) -> KLSType :
      match(t) :
         (t:ByteT) : KByteT()
         (t:IntT) : KIntT()
         (t:LongT) : KLongT()
         (t:FloatT) : KFloatT()
         (t:DoubleT) : KDoubleT()
         (t:UnknownT) : KUnknownT()
         (t:PtrT) : KPtrT(to-ls-type(type(t)))
         (t:RefT) : KRefT(to-type(type(t)))
         (t:FnT) :
            defn to-rest-type (t:False|LSType) :
               to-ls-type(t as LSType) when t is-not False
            KFnT(map(to-ls-type,a(t)), to-rest-type(r(t)), to-ls-type(b(t)))
         (t:StructT) : KStructT(n(t))
         (t) : fatal("Type cannot be converted to KLSType: %~" % [t])

   defn to-ls-exp (e:LSExp) -> KLSExp :
      match(e) :
         (e:LSVar) :
            KLSVar(n(e))
         (e:LSNew) :
            val fts = field-types!(n(e), targ(e))
            KLSRef(n(e), map(to-ls-exp-upcast, args(e), fts), info(e))
         (e:LSArray) :
            val fts = field-types!(n(e), targ(e))
            KLSRefArray(
               n(e),
               to-ls-exp-upcast(length(e), LongT()),
               map(to-ls-exp-upcast, args(e), fts)
               info(e))
         (e:LSStruct) :
            val fts = field-types!(n(e), targ(e))
            KLSStruct(n(e), map(to-ls-exp-upcast, args(e), fts))
         (e:LSAddr) :
            KLSPtr(to-loc(exp(e)))
         (e:LSDeref|LSSlot|LSField) :
            match(to-loc(e)) :
               (v:Value) : exp(v)
               (v) : KLSRead(v)
         (e:LSDo) :
            val f* = to-ls-exp(func(e))
            val ft = type(func(e)) as FnT
            val args* = to-ls-args(args(e), ft)
            KLSCall(f*, args*, to-ls-type!(type(e)), false, info(e))
         (e:LSDoInStack) :
            val f* = to-ls-exp(func(e))
            val ft = type(func(e)) as FnT
            val args* = to-ls-args(args(e), ft)
            KLSCall(f*, args*, to-ls-type(ret(e)), true, info(e))
         (e:LSDoStack) :
            val f* = to-ls-exp(func(e))
            val arg* = to-ls-exp(arg(e))
            KLSSwitchStack(f*, arg*, to-ls-type(ret(e)), info(e))
         (e:LSCallC) :
            val f* = to-ls-exp(func(e))
            val ft = type(func(e)) as FnT
            val args* = to-ls-args(args(e), ft)
            KLSCallC(f*, args*, to-ls-type!(type(e)), info(e))
         (e:LSPrim) :
            if op(e) == prim-LS-BITS-OP :
               val v = to-ls-exp(head(args(e)))
               val t = match(type(head(args(e)))) :
                  (t:FloatT) : KIntT()
                  (t:DoubleT) : KLongT()
               KLSInterpret(v, t)
            else if op(e) == prim-LS-FNUM-OP :
               val v = to-ls-exp(head(args(e)))
               val t = match(type(head(args(e)))) :
                  (t:IntT) : KFloatT()
                  (t:LongT) : KDoubleT()
               KLSInterpret(v, t)
            else :
               defn args-cast (t:LSType) :
                  List(to-ls-exp-upcast(head(args(e)), t))
               defn args-any () :
                  map(to-ls-exp, args(e))
               defn args-max () :
                  defn max-type (x:LSType, y:LSType) :
                     y when implicit-upcast?(x, y) else x
                  val t = reduce(max-type, seq({type(_) as LSType}, args(e)))
                  map(to-ls-exp-upcast{_, t}, args(e))
               defn args-max-or-ptr () :
                  if any?({type(_) is PtrT|RefT}, args(e)) :
                     for a in args(e) map :
                        match(type(a)) :
                           (t:PtrT|RefT) : to-ls-exp(a)
                           (t) : to-ls-exp-upcast(a, LongT())
                  else : args-max()
               defn arg0-byte-or-ptr? (conseq:KLSOp, alt:KLSOp) :
                  match(type(head(args(e)))) :
                     (t:ByteT|PtrT) : conseq
                     (t) : alt

               val t* = to-ls-type!(type(e))
               val [op*, args*] = match(op(e)) :
                  (op:prim-GetterPrimitive|prim-SetterPrimitive) :
                     [prim-op(op), args-any()]
                  (op) :
                     switch {op == _} :
                        prim-LS-ADD-OP : [ADD-OP, args-max-or-ptr()]
                        prim-LS-SUB-OP : [SUB-OP, args-max-or-ptr()]
                        prim-LS-MUL-OP : [MUL-OP, args-max()]
                        prim-LS-DIV-OP : [DIV-OP, args-max()]
                        prim-LS-MOD-OP : [MOD-OP, args-max()]
                        prim-LS-AND-OP : [AND-OP, args-max()]
                        prim-LS-OR-OP : [OR-OP, args-max()]
                        prim-LS-XOR-OP : [XOR-OP, args-max()]
                        prim-LS-SHL-OP : [SHL-OP, args-max()]
                        prim-LS-SHR-OP : [SHR-OP, args-max()]
                        prim-LS-ASHR-OP : [ASHR-OP, args-max()]
                        prim-LS-EQ-OP : [EQ-OP, args-max-or-ptr()]
                        prim-LS-NE-OP : [NE-OP, args-max-or-ptr()]
                        prim-LS-LT-OP : [arg0-byte-or-ptr?(ULT-OP, LT-OP), args-max()]
                        prim-LS-GT-OP : [arg0-byte-or-ptr?(UGT-OP, GT-OP), args-max()]
                        prim-LS-LE-OP : [arg0-byte-or-ptr?(ULE-OP, LE-OP), args-max()]
                        prim-LS-GE-OP : [arg0-byte-or-ptr?(UGE-OP, GE-OP), args-max()]
                        prim-LS-ULT-OP : [ULT-OP, args-max()]
                        prim-LS-UGT-OP : [UGT-OP, args-max()]
                        prim-LS-ULE-OP : [ULE-OP, args-max()]
                        prim-LS-UGE-OP : [UGE-OP, args-max()]
                        prim-LS-NOT-OP : [NOT-OP, args-any()]
                        prim-LS-NEG-OP : [NEG-OP, args-any()]
               KLSPrim(op*, args*, t*)
         (e:LSSizeof) :
            KLSSizeof(to-ls-type(targ(e)))
         (e:LSTagof) :
            KLSTagof(n(e))
         (e:LSCast) :
            KLSConv(to-ls-exp(exp(e)), to-ls-type(targ(e)), info(e))
         (e:LSLiteral) :
            match(value(e)) :
               (v:Byte) : KLSLitByte(v)
               (v:Char) : KLSLitByte(to-byte(v))
               (v:Int) : KLSLitInt(v)
               (v:Long) : KLSLitLong(v)
               (v:Float) : KLSLitFloat(v)
               (v:Double) : KLSLitDouble(v)
               (v:String) : KLSLitString(v)
               (v:True) : KLSRef(TRUE-TYPE-ID, List(), info(e))
               (v:False) : KLSRef(FALSE-TYPE-ID, List(), info(e))
         (e:LSAnd) :
            val a* = to-ls-exp-upcast(a(e), LongT())
            val b* = to-ls-exp-upcast(b(e), LongT())
            val r = fresh-id()
            val r-var = KLSVar(r)
            KLSLet(
               KLSSeq(
                  KLSDefLocalVar(r, KLongT(), a*)
                  KLSIf(r-var
                        KLSSet(Value(r-var), b*)
                        KLSSkip()))
               r-var)
         (e:LSOr) :
            val a* = to-ls-exp-upcast(a(e), LongT())
            val b* = to-ls-exp-upcast(b(e), LongT())
            val r = fresh-id()
            val r-var = KLSVar(r)
            KLSLet(
               KLSSeq(
                  KLSDefLocalVar(r, KLongT(), a*)
                  KLSIf(r-var
                        KLSSkip()
                        KLSSet(Value(r-var), b*)))
               r-var)
         (e:LSLetExp) :
            KLSLet(to-ls-comm(comm(e)), to-ls-exp(exp(e)))
         (e:LSMix) :
            val exps* = map(to-curry, select-all(sel(e), exps(e)))
            if length(exps*) == 1 : head(exps*)
            else : KLSMix(exps*)
         (e:LSCurry) :
            to-curry(e)
         (e:LSFn) :
            KLSFn(to-exp(ref(e)))

   defn to-curry (e:LSExp) :
      val a1 = a(type(e) as FnT)
      val a2 = b(type(e) as FnT)
      val a1* = map(to-ls-type, a1)
      val a2* = to-ls-type(a2)
      match(e) :
         (e:LSCurry) :
            val targs = append(targs(e), cargs(e))
            KLSCurry(n(ref(e)), map(to-type!, targs), a1*, a2*)
         (e:LSVar) :
            KLSCurry(n(e), List(), a1*, a2*)

   defn to-ls-args (es:List<LSExp>, t:FnT) :
      defn ex (ts:List<LSType>, r:False|LSType) : cat(ts, repeat(r))
      map(to-ls-exp-upcast, es, ex(a(t), r(t)) as Seqable<LSType>)

   defn to-ls-exp-upcast (f:False, t:LSType) :
      false
   defn to-ls-exp-upcast (e:LSExp, t:LSType) -> KLSExp :
      val et = type(e) as LSType
      val e* = to-ls-exp(e)
      if implicit-upcast?(et, t) : KLSConv(e*, to-ls-type(t), info(e))
      else : e*

   defn to-ls-comm (c:LSComm) -> KLSComm :
      match(c) :
         (c:LSCall) :
            KLSIgnoreComm(to-ls-exp(exp(c)))
         (c:LSSet) :
            val et = type(exp(c)) as LSType
            KLSSet(
               to-loc(exp(c))
               to-ls-exp-upcast(value(c), et))
         (c:LSLabels) :
            to-ls-comm(body(c))
         (c:LSLabel) :
            KLSLabel(n(c))
         (c:LSGoto) :
            KLSGoto(n(c))
         (c:LSReturn) :
            val ret = current-return-type as LSType
            KLSReturn(to-ls-exp-upcast(exp(c), ret))
         (c:LSDef) :
            val dt = type(c) as LSType
            KLSDefLocal(n(c), to-ls-exp-upcast(value(c), dt))
         (c:LSDefVar) :
            KLSDefLocalVar(
               n(c),
               to-ls-type(type(c))
               to-ls-exp-upcast(value(c), type(c)))
         (c:LSSeq) :
            KLSSeq(
               to-ls-comm(a(c))
               to-ls-comm(b(c)))
         (c:LSIf) :
            defn loop (pred:LSExp, conseq:KLSComm, alt:KLSComm) :
               match(pred) :
                  (pred:LSAnd) :
                     val alt-lbl = fresh-id()
                     loop(
                        a(pred),
                        loop(b(pred), conseq, KLSGoto(alt-lbl))
                        KLSSeq(KLSLabel(alt-lbl), alt))
                  (pred:LSOr) :
                     val con-lbl = fresh-id()
                     loop(a(pred),
                          KLSSeq(KLSLabel(con-lbl), conseq)
                          loop(b(pred), KLSGoto(con-lbl), alt))
                  (pred) :
                     KLSIf(to-ls-exp-upcast(pred, LongT()), conseq, alt)
            loop(pred(c), to-ls-comm(conseq(c)), to-ls-comm(alt(c)))
         (c:LSMatch) :
            val branches* = for b in branches(c) map :
               val ts = map(type{_ as RefT}, atypes(b))
               KLSBranch(args(b),
                         map(to-type, ts)
                         to-ls-comm(body(b)))
            KLSMatch(map(to-ls-exp, args(c)), branches*, info(c))
         (c:LSSkip) :
            KLSSkip()

   defn to-loc (e:LSExp) -> KLoc :
      match(e) :
         (e:LSDeref) :
            match(type(exp(e))) :
               (et:PtrT) : Deptr(to-ls-exp(exp(e)), to-ls-type!(type(e)))
               (et:RefT) : Deref(to-ls-exp(exp(e)), to-ls-type!(type(e)))
         (e:LSSlot) :
            Slot(to-ls-exp(exp(e)),
                 to-ls-type!(type(e)),
                 to-ls-exp-upcast(index(e), LongT()))
         (e:LSField) :
            val base = deref-all(exp(e))
            val n = n(type(base) as StructT)
            val f = Field(to-loc(base), field-n(n, name(e)))
            if rest-field?(n, name(e)) : Value(KLSPtr(f))
            else : f
         (e) :
            Value(to-ls-exp(e))

   ;Utilities
   ;---------
   defn* deref-all (e:LSExp) :
      match(type(e)) :
         (et:PtrT) :
            deref-all(LSDeref(e, type(et), false, false, info(e)))
         (et:RefT) :
            val t = type(et) as TOf
            val t* = StructT(n(t), type(t))
            deref-all(LSDeref(e, t*, false, false, info(e)))
         (et) : e

   defn field-n (sn:Int, fname:Symbol) :
      label<Int> return :
         val e = current-hierarchy()[sn] as LSHEntry
         for f in fields(e) do :
            return(n(f)) when name(f) == fname
         match(rfield(e)) :
            (rf:stz/tl-ir/Field) : return(n(rf)) when name(rf) == fname
            (rf) : false
         fatal("No field %~ in struct %~." % [fname, sn])


   defn select-1<?T> (s:False|Selection, xs:List<?T>) -> T :
      val ss = sels(s as SSel)
      for (x in xs, s in ss) find! :
         s is-not False

   defn select-all<?T> (s:False|Selection, xs:List<?T>) -> List<T> :
      val ss = sels(s as SSel)
      to-list $
      for (x in xs, s in ss) filter :
         s is-not False

   ;Driver
   ;------
   val comm-list = Vector<KComm>()
   set-current-hierarchy(hier(prog))
   do(add{comm-list, _}, to-comms(current-hierarchy()))
   for c in comms(prog) do :
      match(c) :
         (c:TDefTuple) : do(add{comm-list, _}, to-comms(c))
         (c) : add(comm-list, to-comm(c))
   KProg(to-list(comm-list))


;============================================================
;=================== Normalization ==========================
;============================================================
defn callsite-normalization (prog:KProg) :
   ;     HiStanza Normalization
   ;     ----------------------
   defn normalizable? (e:KExp) :
      e is KLet|KLetRec|KSeq|KDispatch|KMatch|KMix

   defn normalize-func (f:KExp, return:KExp -> KExp) :
      defn loop (f:KExp) :
         match(f) :
            (f:KLet) :
               KLet(def(f), loop(body(f)), false)
            (f:KLetRec) :
               KLetRec(defs(f), loop(body(f)), info(f), false)
            (f:KSeq) :
               KSeq(a(f), loop(b(f)), false)
            (f:KDispatch) :
               val branches* = for b in branches(f) map : map(loop, b)
               KDispatch(args(f), branches*, info(f), false)
            (f:KMatch) :
               val branches* = for b in branches(f) map : map(loop, b)
               KMatch(args(f), branches*, info(f), false)
            (f) :
               return(f)
      loop(f)

   defn normalize-args (xs:List<KExp>, return:List<KExp> -> KExp) :
      if empty?(xs) :
         return(List())
      else if head(xs) is KVar|KLiteral :
         normalize-args{tail(xs), _} $ fn* (xs*) :
            return(cons(head(xs), xs*))
      else :
         val n = fresh-id()
         val body = normalize-args{tail(xs), _} $ fn* (xs*) :
            return(cons(KVar(n), xs*))
         KLet(KDef(n, head(xs)), body, false)

   defn convert-exp (e:KExp) :
      match(mapr(convert-exp, e)) :
         (e:KDo) :
            if normalizable?(func(e)) :
               normalize-args{args(e), _} $ fn* (args*) :
                  normalize-func{func(e), _} $ fn* (func*) :
                     KDo(func*, args*, a1(e), a2(e), info(e), false)
            else : e
         (e) : e

   ;     LoStanza Expression Normalization
   ;     ---------------------------------
   defn normalizable? (e:KLSExp) :
      e is KLSLet|KLSMix

   defn normalize-func (f:KLSExp, return:KLSExp -> KLSExp) -> KLSExp :
      match(f) :
         (f:KLSLet) : KLSLet(comm(f), normalize-func(exp(f), return))
         (f) : return(f)

   defn normalize-args (xs:List<KLSExp>, return:List<KLSExp> -> KLSExp) -> KLSExp :
      if empty?(xs) :
         return(List())
      else if head(xs) is KLSVar|KLSLitByte|KLSLitInt|KLSLitLong|
                              KLSLitFloat|KLSLitDouble|KLSLitString|KLSSizeof|KLSTagof :
         normalize-args{tail(xs), _} $ fn* (xs*) :
            return(cons(head(xs), xs*))
      else :
         val n = fresh-id()
         val body = normalize-args{tail(xs), _} $ fn* (xs*) :
            return(cons(KLSVar(n), xs*))
         KLSLet(KLSDefLocal(n, head(xs)), body)

   defn convert-ls-exp (e:KLSExp) -> KLSExp :
      match(map(convert-ls-comm, map(convert-ls-comm, e))) :
         (e:KLSCall) :
            if normalizable?(func(e)) :
               normalize-args{args(e), _} $ fn* (args*) :
                  normalize-func{func(e), _} $ fn* (func*) :
                     KLSCall(func*, args*, type(e), new-stack?(e), info(e))
            else : e
         (e:KLSCallC) :
            if normalizable?(func(e)) :
               normalize-args{args(e), _} $ fn* (args*) :
                  normalize-func{func(e), _} $ fn* (func*) :
                     KLSCallC(func*, args*, type(e), info(e))
            else : e
         (e) : e

   ;     LoStanza Command Normalization
   ;     ------------------------------
   defn normalize-exp (e:KLSExp, return:KLSExp -> KLSComm) -> KLSComm :
      match(e) :
         (e:KLSLet) :
            KLSSeq(comm(e), return(exp(e)))
         (e) : return(e)
   defn normalize-exp (f:False, return:False -> KLSComm) -> KLSComm :
      return(false)

   defn convert-ls-comm (c:KLSComm) -> KLSComm :
      match(map(convert-ls-comm, map(convert-ls-comm, c))) :
         (c:KLSIgnoreComm) : normalize-exp(exp(c), KLSIgnoreComm)
         (c:KLSReturn) : normalize-exp(exp(c), KLSReturn)
         (c:KLSDefLocal) : normalize-exp(value(c), KLSDefLocal{n(c), _})
         (c:KLSDefLocalVar) : normalize-exp(value(c), KLSDefLocalVar{n(c), type(c), _:False|KLSExp})
         (c) : c

   ;     Driver
   ;     ------
   map(convert-exp, convert-ls-exp, prog)



;============================================================
;================== Transformations =========================
;============================================================

;                     Program Mappers
;                     ===============

defn map (f: KExp -> KExp, prog:KProg) :
   KProg $ for c in comms(prog) map :
      map(f, c)

defn map (f: KComm -> KComm, prog:KProg) :
   KProg(map(f, comms(prog)))

defn map (fle: KLSExp -> KLSExp, prog:KProg) :
   defn flc (c:KLSComm) : mapr(fle, c)
   KProg $ for c in comms(prog) map :
      map{flc, _} $
      map(fle, c)

defn map (fe: KExp -> KExp, fle: KLSExp -> KLSExp, prog:KProg) :
   defn flc (c:KLSComm) : mapr(fle, c)
   KProg $ for c in comms(prog) map :
      map{flc, _} $
      map{fle, _} $
      map(fe, c)

defn map (fe: KExp -> KExp, flc: KLSComm -> KLSComm, prog:KProg) :
   defn fle (e:KLSExp) : mapr(flc, e)
   KProg $ for c in comms(prog) map :
      map{flc, _} $
      map{fle, _} $
      map(fe, c)

defn map (fe: KExp -> KExp, fle: KLSExp -> KLSExp, flc: KLSComm -> KLSComm, prog:KProg) :
   KProg $ for c in comms(prog) map :
      map{flc, _} $
      map{fle, _} $
      map(fe, c)

defn prepend (cs: Seqable<KComm>, p:KProg) :
   KProg(to-list(cat(cs, comms(p))))

;============================================================
;============== Remove Intersection Objects =================
;============================================================

defn remove-intersection-objects (prog:KProg) :
   ;Holds new deftypes
   val accum = Vector<KDefType>()

   defn make-type (c:KAnd) :
      val n* = fresh-id()
      add(accum, KDefType(n*, c))
      KOf(n*)

   defn remove-exp (e:KExp) :
      match(mapr(remove-exp, e)) :
         (e:KNew) :
            match(class(e)) :
               (c:KOf) : e
               (c:KAnd) : KNew(make-type(c), methods(e), info(e), type(e))
         (e) : e

   val comms* = for c in comms(prog) map :
      map(remove-exp, c)
   KProg(append(accum, comms*))   

;============================================================
;================== Void Check Insertion ====================
;============================================================

defn void-check-insertion (prog:KProg) :
   ;Find all global variables that may be void.
   val void-var = HashTable<Int,True>()
   for c in comms(prog) do :
      match(c) :
         (c:KDef) : void-var[n(c)] = true
         (c:KDefVar) : void-var[n(c)] = true
         (c:KLSDef) : void-var[n(c)] = true
         (c) : false

   ;Retrieve voidable variable if it exists
   defn void-var-n (def:KComm) :
      match(def) :
         (def:KDefVar) :
            match(value(def)) :
               (v:KExp) : n(def)
               (v:False) : fail()
         (def) : fail()

   ;Insert void checks when necessary
   defn check-void (e:KExp) :
      match(e) :
         (e:KLet) :
            attempt: void-var[void-var-n(def(e))] = true
            mapr(check-void, e)
         (e:KVar) :
            if key?(void-var, n(e)) : KCheckVoid(e, info(e), false)
            else : e
         (e:KTupleGet) : KCheckVoid(mapr(check-void, e), info(e), false)
         (e) : mapr(check-void, e)

   ;Insert void checks for all HiStanza constructs
   map(check-void, prog)


;                    Mutable Variables Boxing
;                    ========================

defn box-mutables (prog:KProg) :
   val mtable = HashTable<Int, KType>()
   defn box! (v:Int, t:KType) : mtable[v] = t
   defn box? (v:Int) : key?(mtable, v)
   defn var-type (v:Int) : mtable[v]

   defn box (e:KExp) :
      match(e) :
         (e:KLet) :
            match(def(e)) :
               (d:KDefVar) :
                  box!(n(d), type(d))
                  val d* = map(box, d) as KDefVar
                  val body* = box(body(e))
                  KLet(KDef(n(d), KBox(value(d*), false)),
                       body*,
                       false)
               (d) :
                  mapr(box, e)
         (e:KSet) :
            val v* = box(value(e))
            if box?(n(e)) : KBoxSet(KVar(n(e)), v*, false)
            else : KSet(n(e), v*, false)
         (e:KVar) :
            if box?(n(e)) : KBoxGet(e, var-type(n(e)))
            else : e
         (e) :
            mapr(box, e)

   ;Driver
   map(box, prog)


;                     Constant Lifting
;                     ================

defn constant-lifting (prog:KProg) :
   ;Conversion
   val accum = Vector<KComm>()
   defn make-const (v) :
      val n = fresh-id()
      add(accum, KDefConst(n, v))
      KVar(n)

   defn conv-exp (e:KExp) :
      match(mapr(conv-exp, e)) :
         (e:KLiteral) :
            match(value(e)) :
               (v:Long|Double|String|Symbol|List) : make-const(v)
               (v) : e
         (e) : e

   ;Driver
   for c in comms(prog) do :
      add{accum, _} $
      map(conv-exp, c)
   KProg(to-list(accum))


;                    Method TArg Mapping
;                    ===================

defn sub (t:KType, env:List<KeyValue<Int,KType>>) :
   match(t) :
      (t:KTVar) :
         val e = for e in env find : key(e) == n(t)
         match(e) :
            (e:KeyValue<Int,KType>) : value(e)
            (e) : t
      (t) :
         map(sub{_, env}, t)

defn method-targ-mapping (prog:KProg) :
   ;Compute current type table, and multi types
   val tt = TypeTable()
   val multis = HashTable<Int, KDefmulti>()
   for c in comms(prog) do :
      match(c) :
         (c:KDefType) : add-type(tt, c)
         (c:KLSDefType) : add-ls-type(tt, c)
         (c:KDefmulti) : multis[n(c)] = c
         (c) : false
   end-adds(tt)

   ;Given xs = ts where ts contains references to ys
   ;Solve for ys in terms of xs
   defn solve-inverse (xs:List<Int>, ts:List<KType>, ys:List<Int>) :
      ;Find solutions
      val xs-table = HashTable<Int, KType>()
      val solns = HashTable<Int, List<Int>>()
      defn find-soln (x:Int, t:KType) :
         match(t) :
            (t:KTVar) : solns[n(t)] = cons(x, get?(solns,n(t),List()))
            (t:KOr) : (find-soln(x, a(t)), find-soln(x, b(t)))
            (t) : false
      for (x in xs, t in ts) do :
         xs-table[x] = t
         find-soln(x, t)

      ;Find minimal solutions
      for y in ys map :
         if key?(solns, y) :
            val xs = minima(solns[y], subtype?{tt, xs-table[_], xs-table[_]})
            reduce(KAnd, seq(KTVar, xs))
         else : KTop()

   ;Replace type arguments in function
   defn replace-targs (def:KDefmethod, targs*:List<Int>, env:List<KeyValue<Int, KType>>) :
      if empty?(env) :
         val f = func(def)
         val func* = KFn(n(f), tail?(f), targs*, a1(f), a2(f), closure(f), args(f), body(f), info(f))
         KDefmethod(n(def), multi(def), targs(def), thisn(def), func*)
      else :
         val f = func(def)
         val a1* = for t in a1(f) map : sub(t, env)
         val a2* = sub(a2(f), env)
         val body* = mapr(sub{_, env}, body(f))
         val func* = KFn(n(f), tail?(f), targs*, a1*, a2*, closure(f), args(f), body*, info(f))
         KDefmethod(n(def), multi(def), targs(def), thisn(def), func*)

   ;Replace type arguments in function
   defn replace-targs (f:KLSDefmethod, targs*:List<Int>, env:List<KeyValue<Int,KType>>) :
      if empty?(env) :
         KLSDefmethod(tail?(f), n(f), multi(f), multi-targs(f), targs*, a1(f), a2(f), args(f), body(f), info(f))
      else :
         val a1* = for t in a1(f) map : mapr(sub{_, env}, t)
         val a2* = mapr(sub{_, env}, a2(f))
         val body* = for t in body(f) mapr : sub(t, env)
         KLSDefmethod(tail?(f), n(f), multi(f), multi-targs(f), targs*, a1*, a2*, args(f), body*, info(f))

   ;Map methods over commands
   defn map-methods-comm (c:KComm) :
      match(map(map-methods-exp, c)) :
         (c:KDefmethod) :
            val f = func(c)
            if empty?(targs(f)) :
               val xs = map(fresh-id{}, targs(c))
               replace-targs(c, xs, List())
            else :
               ;Invert mapping
               val xs = map(fresh-id{}, targs(c))
               val ys = targs(f)
               val ts* = solve-inverse(xs, targs(c), ys)
               ;Replace occurences within function
               replace-targs(c, xs, map(KeyValue, ys, ts*))
         (c:KLSDefmethod) :
            if empty?(targs(c)) :
               val xs = map(fresh-id{}, multi-targs(c))
               replace-targs(c, xs, List())
            else :
               ;Invert mapping
               val xs = map(fresh-id{}, multi-targs(c))
               val ys = targs(c)
               val ts* = solve-inverse(xs, multi-targs(c), ys)
               ;Replace occurences within function
               replace-targs(c, xs, map(KeyValue, ys, ts*))
         (c) : c
   defn map-methods-exp (e:KExp) :
      map(map-methods-exp, map(map-methods-comm, e))

   ;Driver
   KProg $ for c in comms(prog) map :
      map-methods-comm(c)


;============================================================
;================ Closure Creation ==========================
;============================================================

defn closure-creation (prog:KProg) :
   defn create-closures (e:KExp) :
      defn afn (f:Func) :
         val n = fresh-id()
         KLet(KDefn(n, f), KVar(n), false)
      match(e) :
         (e:KMix) :
            afn(mix-fn(exps(e)))
         (e:KCurry) :
            afn(mix-fn(List(e)))
         (e:KDo) :
            match(func(e)) :
               (f:KMix|KCurry) :
                  KDo(func(e),
                      map(create-closures,args(e)),
                      a1(e), a2(e), info(e), type(e))
               (f) : mapr(create-closures, e)
         (e) : mapr(create-closures, e)

   defn create-closures (e:KLSExp) :
      match(e) :
         (e:KLSFn) :
            FuncExp $ match(ref(e)) :
               (r:KCurry) : mix-fn(List(r))
               (r:KMix) : mix-fn(exps(r))
         (e) : mapr(create-closures, e)

   defn mix-fn (fs:List<KCurry>) :
      ;Group by arity
      val groups = HashTable<Int, List<KCurry>>()
      for f in fs do :
         val n = length(a1(f))
         groups[n] = cons(f, get?(groups, n, List()))

      ;Make multi function
      val funcs* = to-list $ for entry in groups seq :
         defn KTops (n:Int) : map(KTop{}, 0 to n)
         val [n, fs] = [key(entry), value(entry)]
         val args* = map(fresh-id{}, 0 to n)
         val f = let :
            val f0 = head(fs)
            if length(fs) == 1 : f0
            else : KMix(fs,info(f0),false)
         val body = KDo(f, map(KVar,args*), KTops(n), KTop(), info(f), false)
         KFn(fresh-id(), true, List(), KTops(n), KTop(), false, args*, body, info(f))

      ;Group functions
      if length(funcs*) == 1 : head(funcs*)
      else : KMultifn(fresh-id(), funcs*, info(head(funcs*)))

   map(create-closures, create-closures, prog)

;============================================================
;================ KMix/KCurry Conversion ====================
;============================================================

deftype AbsCall
defmulti func (x:AbsCall) -> KLSMix
defmulti args (x:AbsCall) -> List<KLSExp>
defmulti info (x:AbsCall) -> False|FileInfo
defmulti call (x:AbsCall, f:KLSExp, args:List<KLSExp>) -> KLSComm


defn mix-conversion (prog:KProg) :
   ;     Remove mixed calls from expression position
   ;     ===========================================
   defn mixed-call? (e:KLSExp) :
      match(e) :
         (e:KLSCall|KLSCallC) : func(e) is KLSMix
         (e) : false
   defn mixed-call? (f:False) :
      false

   defn move-mixed-calls-comm (c:KLSComm) :
      defn recur (c:KLSComm) :
         map(move-mixed-calls-comm, map(move-mixed-calls-exp, c))
      match(c) :
         (c:KLSDefLocal) :
            if mixed-call?(value(c)) :
               val t = type(value(c) as KLSCall|KLSCallC)
               KLSSeq(
                  KLSDefLocalVar(n(c), t, false)
                  KLSSet(Value(KLSVar(n(c))), value(c)))
            else : recur(c)
         (c:KLSDefLocalVar) :
            if mixed-call?(value(c)) :
               KLSSeq(
                  KLSDefLocalVar(n(c), type(c), false)
                  KLSSet(Value(KLSVar(n(c))), value(c) as KLSExp))
            else : recur(c)
         (c:KLSSet) :
            if mixed-call?(value(c)) :
               val exp* = mapr(move-mixed-calls-exp, exp(c))
               KLSSet(exp*, value(c))
            else : recur(c)
         (c) :
            recur(c)

   defn move-mixed-calls-exp (e:KLSExp) :
      defn recur (e:KLSExp) :
         map(move-mixed-calls-comm, map(move-mixed-calls-exp, e))
      if mixed-call?(e) :
         val n = fresh-id()
         val t = type(e as KLSCall|KLSCallC)
         KLSLet(
            KLSSeq(
               KLSDefLocalVar(n, t, false)
               KLSSet(Value(KLSVar(n)), e))
            KLSVar(n))
      else : recur(e)

   ;     Generating the dispatch branches for a mixed call
   ;     =================================================
   defn mix-call (e:KDo) :
      val fs = exps(func(e) as KMix)
      val branches* = for f in fs map :
         val branch-args = map(fresh-id{}, args(e))
         val body = KDo(f, map(KVar, branch-args), a1(f), a2(f), info(e), false)
         KBranch(branch-args, a1(f), body, info(e))
      KDispatch(args(e), branches*, info(e), false)

   defn mix-call (c:AbsCall) :
      val fs = exps(func(c))
      val match-arg? = map({_ is KRefT}, a1(head(fs)))
      val match-args = select(match-arg?, args(c))
      val branches* = for f in fs map :
         val branch-args = map(fresh-id{}, match-args)
         val branch-types = map(type, select(match-arg?, a1(f)) as List<KRefT>)
         val call-args = select(match-arg?, map(KLSVar, branch-args), args(c))
         KLSBranch(branch-args, branch-types, call(c, f, call-args))
      KLSDispatch(match-args, branches*, info(c))

   ;     Conversion to Abstract Calls
   ;     ============================
   defn AbsCall (e:KLSExp, return: KLSExp -> KLSComm) :
      fail() when not mixed-call?(e)
      match(e) :
         (e:KLSCall) :
            new AbsCall :
               defmethod func (this) : func(e) as KLSMix
               defmethod args (this) : args(e)
               defmethod info (this) : info(e)
               defmethod call (this, f:KLSExp, args:List<KLSExp>) :
                  return(KLSCall(f, args, type(e), new-stack?(e), info(e)))
         (e:KLSCallC) :
            new AbsCall :
               defmethod func (this) : func(e) as KLSMix
               defmethod args (this) : args(e)
               defmethod info (this) : info(e)
               defmethod call (this, f:KLSExp, args:List<KLSExp>) :
                  return(KLSCallC(f, args, type(e), info(e)))

   defn AbsCall (c:KLSComm) :
      match(c) :
         (c:KLSIgnoreComm) : AbsCall(exp(c), KLSIgnoreComm)
         (c:KLSSet) : AbsCall(value(c), KLSSet{exp(c), _})
         (c:KLSReturn) : AbsCall(exp(c), KLSReturn)
         (c) : fail()

   ;     Mix Calls
   ;     =========
   defn mix-exp (e:KExp) :
      match(mapr(mix-exp, e)) :
         (e:KDo) :
            if func(e) is KMix : mix-call(e)
            else : e
         (e) : e

   defn mix-ls-exp (e:KLSExp) :
      map(mix-exp, map(mix-comm, map(mix-exp,e)))

   defn mix-comm (c:KLSComm) :
      val c* = map(mix-comm, map(mix-ls-exp, c))
      attempt : mix-call(AbsCall(c*))
      else : c*

   ;     Driver
   ;     ======
   val prog2 = map({_}, move-mixed-calls-exp, move-mixed-calls-comm, prog)
   map(mix-exp, mix-comm, prog2)


defn select<?T> (ps:List<True|False>, xs:List<?T>) -> List<T> :
   if empty?(ps) : List()
   else if head(ps) : cons(head(xs), select(tail(ps), tail(xs)))
   else : select(tail(ps), tail(xs))

defn select<?T,?S> (ps:List<True|False>, xs:List<?T>, ys:List<?S>) -> List<T|S> :
   if empty?(ps) : List()
   else if head(ps) : cons(head(xs), select(tail(ps), tail(xs), tail(ys)))
   else : cons(head(ys), select(tail(ps), tail(xs), tail(ys)))


;============================================================
;================= Boundary Guards ==========================
;============================================================

defn boundary-guard-insertion (prog:KProg) :
   ;Which functions have guards?
   val functions = HashTable<Int, True>()
   val args-guarded = HashTable<Int, True>()
   val ret-guarded = HashTable<Int, True>()
   defn function! (n:Int) : functions[n] = true
   defn function? (n:Int) : key?(functions, n)
   defn args-guarded! (n:Int) : args-guarded[n] = true
   defn args-guarded? (n:Int) : key?(args-guarded, n)
   defn ret-guarded! (n:Int) : ret-guarded[n] = true
   defn ret-guarded? (n:Int) : key?(ret-guarded, n)

   ;          Annotate all Guard Information
   ;          ==============================
   defn annotate-exp (e:KExp) :
      do(annotate-exp, e)
      do(annotate-comm, e)

   defn annotate-comm (c:KComm) :
      match(c) :
         (c:KDefn) :
            function!(n(c))
            args-guarded!(n(c))
            match(value(c)) :
               (f:KFn) : ret-guarded!(n(c)) when not tail?(f)
               (f:KMultifn) : ret-guarded!(n(c)) when none?(tail?, funcs(f) as List<KFn>)
         (c:KDefmulti) :
            function!(n(c))
            args-guarded!(n(c))
            ret-guarded!(n(c))
         (c:KLSDefn) :
            function!(n(c))
         (c) : false
      do(annotate-exp, c)

   ;Scan through top-level functions
   do(annotate-comm, comms(prog))

   ;           Map over Calls and Functions
   ;           ============================
   defn map-conv (fe:KDo -> KExp,
                  ff:(KFn, True|False) -> KFn,
                  fm:KLSDefmethod -> KLSDefmethod,
                  fb:KBranch -> KBranch,
                  prog:KProg) :

      defn conv-fn<?T> (func:?T&Func, m?:True|False) :
         {_ as T&Func} $ match(map(conv-exp, func)) :
            (func:KFn) :
               ff(func, m?)
            (func:KMultifn) :
               val fs = for f in funcs(func) map :
                  ff(f as KFn, m?)
               KMultifn(n(func), fs, info(func))
      defn conv-exp (e:KExp) :
         match(map(conv-exp, map(conv-comm, e))) :
            (e:KDo) : fe(e)
            (e:KDispatch) : KDispatch(args(e), map(fb, branches(e)), info(e), type(e))
            (e:KMatch) : KMatch(args(e), map(fb, branches(e)), info(e), type(e))
            (e) : e
      defn conv-ls-exp (e:KLSExp) :
         match(e) :
            (e:FuncExp) : FuncExp(conv-fn(func(e), false))
            (e) : mapr(conv-ls-exp, e)
      defn conv-ls-comm (c:KLSComm) :
         mapr(conv-ls-exp, c)
      defn conv-comm (c:KComm) :
         match(c) :
            (c:KDefn) :
               KDefn(n(c), conv-fn(value(c), false))
            (c:KDefmethod) :
               KDefmethod(n(c), multi(c), targs(c), thisn(c), conv-fn(func(c), true))
            (c:KLSDefmethod) :
               fm(c)
            (c) :
               map(conv-ls-comm, map(conv-exp, c))
      KProg(map(conv-comm, comms(prog)))

   ;              Guard Insertion
   ;              ===============
   ;Cast expression to type
   defn cast (info:False|FileInfo, e:KExp, t:KType) :
      match(t) :
         (t:KTop) : e
         (t) : KCast(e, t, info, false)

   ;Guarding Call Expressions
   defn guard-call (e:KDo) :
      defn guard-func () :
         cast(info(e), func(e), KOf(FN-TYPE-ID))
      defn guard-args (f:KExp) :
         val args* = map(cast{info(e), _, _}, args(e), a1(e))
         KDo(f, args*, a1(e), a2(e), info(e), false)
      defn guard-ret (exp:KExp) :
         cast(info(e), exp, a2(e))

      match(func(e)) :
         (f:KVar|KCurry) :
            val n = n(f)
            val e* = if function?(n) :
                        if args-guarded?(n) : e
                        else : guard-args(f)
                     else : guard-args(guard-func())
            if ret-guarded?(n) : e*
            else : guard-ret(e*)
         (f) :
            guard-ret(guard-args(guard-func()))

   ;Guarding Function Boundaries
   defn guard-fn (f:KFn, method?:True|False) :
      defn tail-cast (b:KBranch, t:KType) :
         KBranch(args(b), types(b), tail-cast(body(b), t), info(b))
      defn tail-cast (e:KExp, t:KType) :
         match(e) :
            (e:KCast) : tail-cast(exp(e), type-intersection(t, targ(e)))
            (e:KLet) : KLet(def(e), tail-cast(body(e), t), false)
            (e:KLetRec) : KLetRec(defs(e), tail-cast(body(e), t), info(e), false)
            (e:KSeq) : KSeq(a(e), tail-cast(b(e), t), false)
            (e:KMatch) : KMatch(args(e), map(tail-cast{_, t}, branches(e)), info(e), false)
            (e:KDispatch) : KDispatch(args(e), map(tail-cast{_, t}, branches(e)), info(e), false)
            (e:KDo) : e
            (e) : cast(info(f), e, t)

      ;Guard arguments
      var body*:KExp = body(f)
      for (a in args(f), t in a1(f)) do :
         body* = KSeq(cast(info(f), KVar(a), t), body*, false)

      ;Guard return
      body* =
         if tail?(f) : tail-cast(body*, a2(f))
         else : cast(info(f), body*, a2(f))

      ;New input argument types
      val a1* =
         if method? : map(remove-vars, a1(f))
         else : map(KTop{}, a1(f))

      ;Return new function
      KFn(n(f), tail?(f), targs(f), a1*, KTop(), closure(f), args(f), body*, info(f))

   ;Guarding LoStanza Method Boundaries
   defn guard-method (f:KLSDefmethod) :
      var body* = body(f)
      val casts = for (arg in args(f), type in a1(f)) seq :
         KLSIgnoreComm(KLSConv(KLSVar(arg), type, info(f)))
      body* = KLSSeq(cat(casts, [body*]))
      val a1* = map(remove-vars, a1(f))
      KLSDefmethod(tail?(f), n(f), multi(f), multi-targs(f), targs(f),
                   a1*, KRefT(KTop()), args(f), body*, info(f))

   ;Guarding Branches
   defn guard-branch (b:KBranch) :
      val ts* = map(simplify{remove-vars(_)}, types(b))
      var body* = body(b)
      for (arg in args(b), type in types(b)) do :
         if contains-vars?(type) :
            val cast = KCast(KVar(arg), type, info(b), false)
            body* = KSeq(cast, body*, false)
      KBranch(args(b), ts*, body*, info(b))

   ;                  Driver
   ;                  ======
   map-conv(guard-call, guard-fn, guard-method, guard-branch, prog)

;============================================================
;================= KForm Utilities ==========================
;============================================================

;               Return Calculated Type
;               ======================

defn type! (e:KExp) :
   type(e) as KType

;                 Type Argument Substitution
;                 ==========================

defn sub-targs (body:KExp, xs:List<Int>, vs:List<KType>) :
   if empty?(xs) :
      body
   else :
      val env = map(KeyValue, xs, vs)
      mapr(sub{_, env}, body)

;                     Alpha Renaming
;                     ==============

defn alpha-rename (e:KExp, env:List<KeyValue<Int,Int>>) -> KExp :
   val table = HashTable<Int,Int>()
   for e in env do : table[key(e)] = value(e)
   alpha-rename(e, table)

defn alpha-rename (exp:KExp, table:HashTable<Int,Int>) -> KExp :
   val e = map(alpha-rename{_:KType, table}, exp)
   match(e) :
      (e:KVar) : KVar(get?(table, n(e), n(e)), info(e), type(e))
      (e) : mapr(alpha-rename{_:KExp, table}, e)

defn alpha-rename (t:KType, table:HashTable<Int,Int>) -> KType :
   match(t) :
      (t:KTVar) : KTVar(get?(table, n(t), n(t)))
      (t) : map(alpha-rename{_, table}, t)

;                     Parallel KLet
;                     =============

defn KLet (xs:List<Int>, vs:List<KExp>, body:KExp) -> KExp :
   if empty?(xs) :
      body
   else :
      KLet(KDef(head(xs), head(vs)),
           KLet(tail(xs), tail(vs), body),
           type(body))


;============================================================
;================= Simple Inlining ==========================
;============================================================

defn count-usages (block:KExp) -> IntTable<Int> :
   val num-usages = IntTable<Int>()

   defn inc-usage (n:Int) :
      num-usages[n] = get?(num-usages, n, 0) + 1

   defn count-exp (e:KExp) :
      match(e) :
         (e:KVar) : inc-usage(n(e))
         (e:KCurry) : inc-usage(n(e))
         (e) : dor(count-exp, e)

   count-exp(block)
   num-usages

defn simple-inlining (block:KExp) -> KExp :

   ;       Inline Simple Patterns
   ;       ======================
   val num-usages = count-usages(block)
   val func-table = IntTable<Func>()

   defn record-func (c:KComm) :
      match(c) :
         (c:KDefn) : func-table[n(c)] = value(c)
         (c) : false

   defn inline? (n:Int) :
      match(get?(func-table, n, false)) :
         (f:Func) : f when get?(num-usages, n, 0) <= 1
         (f:False) : false

   defn inline? (f:KExp) :
      match(f) :
         (f:KVar) : inline?(n(f))
         (f:KCurry) : inline?(n(f))
         (f) : false

   defn inline-call (f:Func, c-targs:List<KType>, c-args:List<KExp>) -> KExp|False :
      match(f) :
         (f:KFn) :
            if (length(c-args) == length(args(f))) and
               (length(c-targs) == length(targs(f))) :
               KLet(args(f), map(inline, c-args)
                  sub-targs(body(f), targs(f), c-targs))
         (f:KMultifn) :
            val f* = for f in funcs(f) find :
               length(args(f as KFn)) == length(c-args)
            inline-call(f* as KFn, c-targs, c-args) when f* is KFn

   defn inline (e:KExp) -> KExp :
      defn type-args (e:KExp) :
         match(e) :
            (e:KVar) : List()
            (e:KCurry) : targs(e)
      match(e) :
         (e:KDo) :
            match(inline?(func(e))) :
               (f:Func) :
                  match(inline-call(f, type-args(func(e)), args(e))) :
                     (e:KExp) : e
                     (_:False) : map(inline ,e)
               (f:False) : map(inline, e)
         (e:KLet) :
            val def* = map(inline, def(e))
            record-func(def*)
            val body* = inline(body(e))
            KLet(def*, body*, false)
         (e:KLetRec) :
            val defs* = for d in defs(e) map :
               map(inline, d)
            do(record-func, defs*)
            val body* = inline(body(e))
            KLetRec(defs*, body*, info(e), false)
         (e) :
            mapr(inline, e)

   ;       Cull Unused Functions
   ;       =====================
   defn cull (block:KExp) :
      val num-usages = count-usages(block)

      defn keep? (c:KComm) :
         match(c) :
            (c:KDefn) : get?(num-usages, n(c), 0) > 0
            (c) : true

      defn loop (e:KExp) :
         match(e) :
            (e:KLet) :
               if keep?(def(e)) : mapr(loop, e)
               else : loop(body(e))
            (e:KLetRec) :
               val defs* = to-list(filter(keep?, defs(e)))
               if empty?(defs*) : loop(body(e))
               else : mapr(loop, KLetRec(defs*, body(e), info(e), false))
            (e) :
               mapr(loop, e)

      loop(block)

   ;Driver
   cull(inline(block))


defn simple-inlining (prog:KProg) -> KProg :
   map(simple-inlining, prog)


;============================================================
;================= Type Inference ===========================
;============================================================

;Extended types for use during solving
deftype IType
defstruct IArrow <: IType :
   targs: List<Int>
   arity: Int
   a2: KType
defstruct IMulti <: IType :
   types: List<IArrow>
defstruct IGround <: IType :
   type: KType

defmethod print (o:OutputStream, it:IType) :
   defn cms (xs) : join(xs, ", ")
   print{o, _} $
   match(it) :
      (it:IArrow) : "<%*> . (%~) -> %~" % [cms(targs(it)), arity(it), a2(it)]
      (it:IMulti) : "{%*}" % [cms(types(it))]
      (it:IGround) : type(it)

;Constraints used for solving
deftype IConstraint
defstruct EqualConstraint <: IConstraint :
   n: Int
   type: KType
defstruct SubConstraint <: IConstraint :
   n: Int
   type: KType
   env: List<KeyValue<Int,KType>>

public defn map (f:KType -> KType, c:IConstraint) :
   match(c) :
      (c:EqualConstraint) :
         EqualConstraint(n(c), f(type(c)))
      (c:SubConstraint) :
         val env* = for entry in env(c) map :
            key(entry) => f(value(entry))
         SubConstraint(n(c), f(type(c)), env*)

defmethod print (o:OutputStream, c:IConstraint) :
   print{o, _} $ match(c) :
      (c:EqualConstraint) : "%~ = %~" % [n(c), type(c)]
      (c:SubConstraint) : "%~ = %~[%*]" % [n(c), type(c), join(env(c), ", ")]

defn get-type-table (prog:KProg) :
   val tt = TypeTable()
   for c in comms(prog) do :
      match(c) :
         (c:KDefType) : add-type(tt, c)
         (c:KLSDefType) : add-ls-type(tt, c)
         (c) : false
   end-adds(tt)
   tt

;               Constraint generation
;               =====================

defn gen-constraints (tt:TypeTable, prog:KProg) :
   ;State
   val env = IntTable<IType>()
   val constraints = Vector<IConstraint>()

   ;Helper Functions
   defn fn-type (c:KDefn|KDefmulti|KDefmethod|KLSDefn|KLSExternFn) :
      defn record (n:Int, t:IType) :
         env[n] = t
         t
      defn type (f:Func) :   
         match(f) :
            (f:KFn) :
               val t = IArrow(targs(f), length(a1(f)), fresh-uvar())
               record(n(f), t)
            (f:KMultifn) :
               val ts = map(type, funcs(f) as List<KFn>)
               record(n(f), IMulti(ts as List<IArrow>))
               
      match(c) :
         (c:KDefn) :
            type(value(c))   
         (c:KDefmethod) :
            type(func(c))
         (c:KDefmulti) :
            IArrow(targs(c), length(a1(c)), a2(c))
         (c:KLSDefn) :
            IArrow(targs(c), length(a1(c)), KTop())
         (c:KLSExternFn) :   
            IArrow(List(), length(a1(c)), KTop())

   defn lit-type (v) :
      KOf $ match(v) :
         (v:Byte) : BYTE-TYPE-ID
         (v:Char) : CHAR-TYPE-ID
         (v:Int) : INT-TYPE-ID
         (v:Long) : LONG-TYPE-ID
         (v:Float) : FLOAT-TYPE-ID
         (v:Double) : DOUBLE-TYPE-ID
         (v:String) : STRING-TYPE-ID
         (v:Symbol) : SYMBOL-TYPE-ID
         (v:True) : TRUE-TYPE-ID
         (v:False) : FALSE-TYPE-ID
         (v:List) : LIST-TYPE-ID
         (v) : fatal("Not supported during type inference: %~" % [v])

   defn fresh-uvar () :
      KUVar(fresh-id())

   defn hs-type? (t:KLSType) :
      t is KRefT

   defn env-type? (e:KExp) -> IType|False :
      match(e) :
         (e:KVar) : get?(env, n(e), false)
         (e:KCurry) : get?(env, n(e), false)
         (e:KLet) : env-type?(body(e))
         (e:KLetRec) : env-type?(body(e))
         (e:KSeq) : env-type?(b(e))
         (e) : false

   defn env-type? (e:KLSExp) -> IType|False :
      match(e) :
         (e:KLSVar) : get?(env, n(e), false)
         (e:KLSCurry) : get?(env, n(e), false)
         (e:KLSLet) : env-type?(exp(e))
         (e) : false

   defn to-ktype (t:IType) :
      match(t) :
         (t:IGround) : type(t)
         (t:IArrow|IMulti) : KOf(FN-TYPE-ID)

   defn prim-type (op:KOp) :
      switch {op == _} :
         INT-ADD-OP : KOf(INT-TYPE-ID)
         INT-SUB-OP : KOf(INT-TYPE-ID)
         INT-MUL-OP : KOf(INT-TYPE-ID)
         INT-DIV-OP : KOf(INT-TYPE-ID)
         INT-MOD-OP : KOf(INT-TYPE-ID)
         INT-AND-OP : KOf(INT-TYPE-ID)
         INT-OR-OP : KOf(INT-TYPE-ID)
         INT-XOR-OP : KOf(INT-TYPE-ID)
         INT-SHL-OP : KOf(INT-TYPE-ID)
         INT-SHR-OP : KOf(INT-TYPE-ID)
         INT-ASHR-OP : KOf(INT-TYPE-ID)
         INT-NOT-OP : KOf(INT-TYPE-ID)
         INT-NEG-OP : KOf(INT-TYPE-ID)
         INT-EQ-OP : KOr(KOf(TRUE-TYPE-ID), KOf(FALSE-TYPE-ID))
         INT-NE-OP : KOr(KOf(TRUE-TYPE-ID), KOf(FALSE-TYPE-ID))
         INT-LE-OP : KOr(KOf(TRUE-TYPE-ID), KOf(FALSE-TYPE-ID))
         INT-LT-OP : KOr(KOf(TRUE-TYPE-ID), KOf(FALSE-TYPE-ID))
         INT-GT-OP : KOr(KOf(TRUE-TYPE-ID), KOf(FALSE-TYPE-ID))
         INT-GE-OP : KOr(KOf(TRUE-TYPE-ID), KOf(FALSE-TYPE-ID))
         IDENTICAL-OP : KOr(KOf(TRUE-TYPE-ID), KOf(FALSE-TYPE-ID))
         AGET-OP : KTop()
         ASET-OP : KOf(FALSE-TYPE-ID)
         ALEN-OP : KOf(INT-TYPE-ID)
         CHAR-AGET-OP : KOf(CHAR-TYPE-ID)
         CHAR-ASET-OP : KOf(FALSE-TYPE-ID)
         STRING-GET-OP : KOf(CHAR-TYPE-ID)
         STRING-LEN-OP : KOf(INT-TYPE-ID)

   ;Constraint Construction Functions
   defn #equal (a:IType|KType|KLSType, b:KType) -> False :
      match(a) :
         (a:IGround) : #equal(type(a), b)
         (a:KRefT) : #equal(type(a), b)
         (a:KUVar) : add(constraints, EqualConstraint(n(a), b))
         (a) : false

   defn #sub (a:KType, env:List<KeyValue<Int,KType>>) -> KType :
      if empty?(env) :
         a
      else :   
         val n = fresh-id()
         add(constraints, SubConstraint(n, a, env))
         KUVar(n)   

   ;Functions
   defn build-environment (prog:KProg) :
      do(build-environment, comms(prog))
   defn build-environment (c:KComm) :
      match(c) :
         (c:KDef) : env[n(c)] = IGround(fresh-uvar()) ;TODO: Should include types in KDef
         (c:KDefVar) : env[n(c)] = IGround(type(c))
         (c:KDefn) : env[n(c)] = fn-type(c)
         (c:KDefmulti) : env[n(c)] = fn-type(c)
         (c:KDefmethod) : fn-type(c)
         (c:KDefType) : false
         (c:KInit) : false
         (c:KLSDef) : (env[n(c)] = IGround(KTop())) when hs-type?(type(c))
         (c:KLSDefVar) : (env[n(c)] = IGround(KTop())) when hs-type?(type(c))
         (c:KLSDefn) : (env[n(c)] = fn-type(c)) when hs-type?(a2(c))
         (c:KLSExternFn) : (env[n(c)] = fn-type(c)) when hs-type?(a2(c))
         (c:KLSDefmethod) : false
         (c:KLSDefType) : false
         (c:KLSInit) : false
         (c:KDefConst) : env[n(c)] = IGround(lit-type(value(c)))
         (c:KExtern) : (env[n(c)] = IGround(KTop())) when hs-type?(type(c))

   ;Generate constraints
   defn gen-exp (e:KExp) -> KExp :
      match(e) :
         (e:KSet) :
            val v* = gen-exp(value(e))
            KSet(n(e), v*, KOf(FALSE-TYPE-ID))
         (e:KCast) :
            val e* = gen-exp(exp(e))
            val t* = KAnd(type!(e*), targ(e))
            KCast(e*, targ(e), info(e), t*)
         (e:KCheckLength) :
            val e* = gen-exp(exp(e))
            KCheckLength(e*, length(e), info(e), type!(e*))
         (e:KLet) :
            build-environment(def(e))
            val def* = gen-comm(def(e)) as KDefn|KDef|KDefVar
            val body* = gen-exp(body(e))
            KLet(def*, body*, type!(body*))
         (e:KLetRec) :
            do(build-environment, defs(e))
            val defs* = map(gen-comm, defs(e)) as List<KDefn>
            val body* = gen-exp(body(e))
            KLetRec(defs*, body*, info(e), type!(body*))
         (e:KLetLoop) :
            val args* = map(gen-exp, arg-values(e))
            env[n(e)] = IGround(KTop())
            for a in args(e) do :
               env[a] = IGround(KTop())
            val body* = gen-exp(body(e))
            KLetLoop(n(e), targs(e), args(e),
               targ-values(e), args*, body*, type!(body*))
         (e:KGoto) :
            val args* = map(gen-exp, args(e))
            KGoto(loop(e), args*, KBot())
         (e:KSeq) :
            val a* = gen-exp(a(e))
            val b* = gen-exp(b(e))
            KSeq(a*, b*, type!(b*))
         (e:KDispatch) :
            val args* = map(gen-exp, args(e))
            val branches* = map(gen-branch, branches(e))
            val t* = reduce(KOr, seq(type!{body(_)}, branches*))
            KDispatch(args*, branches*, info(e), t*)
         (e:KMatch) :
            val args* = map(gen-exp, args(e))
            val branches* = map(gen-branch, branches(e))
            val t* = reduce(KOr, seq(type!{body(_)}, branches*))
            KMatch(args*, branches*, info(e), t*)
         (e:KNew) :
            do(build-environment, methods(e))
            val methods* = map(gen-comm, methods(e)) as List<KDefmethod>
            KNew(class(e), methods*, info(e), class(e))
         (e:KDo) :
            val func* = gen-exp(func(e))
            val args* = map(gen-exp, args(e))
            val a2* = match(env-type?(func(e))) :
               (f:IArrow|IMulti) : gen-call(f, func(e), length(args*))
               (f) : KTop()
            KDo(func*, args*, a1(e), a2(e), info(e), a2*)
         (e:KCall) :
            val args* = map(gen-exp, args(e))
            KCall(tail?(e), arity(e), func(e), args*, info(e), KTop())   ;TODO: Shouldn't be necessary in a good iR
         (e:KCallDeref) :
            val func* = gen-exp(func(e))
            val args* = map(gen-exp, args(e))
            KCallDeref(tail?(e), arity(e), func*, args*, info(e), KTop()) ;TODO: Shouldn't be necessary in a good iR         
         (e:KVar) :
            val t* = to-ktype(env[n(e)])
            KVar(n(e), info(e), t*)
         (e:KPrim) :
            val t* = prim-type(op(e))
            val args* = map(gen-exp, args(e))
            KPrim(op(e), args*, t*)
         (e:KLiteral) :
            val t* = lit-type(value(e))
            KLiteral(value(e), t*)
         (e:KTuple) :
            val exps* = map(gen-exp, exps(e))
            val t* = KOf(TUPLE-TYPE-ID)
            KTuple(exps*, info(e), t*)
         (e:KTupleGet) :
            val exp* = gen-exp(exp(e))
            KTupleGet(exp*, index(e), info(e), KTop())
         (e:KCheckVoid) :
            val exp* = gen-exp(exp(e))
            KCheckVoid(exp*, info(e), type!(exp*))
         (e:KObject) :
            val args* = map(gen-exp, args(e))
            KObject(n(e), args*, info(e), KOf(n(e)))
         (e:KObjectGet) :
            val obj* = gen-exp(object(e))
            KObjectGet(obj*, index(e), KTop())
         (e:KTypeObject) :
            val args* = map(gen-exp, args(e))
            val t* = KOf(TYPE-TYPE-ID)
            KTypeObject(n(e), args*, info(e), t*)
         (e:KClosure) :
            val args* = map(gen-exp, args(e))
            val t* = KOf(FN-TYPE-ID)
            KClosure(n(e), args*, info(e), t*)
         (e:KClosureGet) :
            val exp* = gen-exp(exp(e))
            KClosureGet(exp*, index(e), KTop())
         (e:KBox) :
            val value* = match(value(e)) :
               (v:KExp) : gen-exp(v)
               (v:False) : v
            val t* = KOf(BOX-TYPE-ID)
            KBox(value*, t*)
         (e:KBoxGet) :
            val box* = gen-exp(box(e))
            KBoxGet(box*, type(e))
         (e:KBoxSet) :
            val box* = gen-exp(box(e))
            val val* = gen-exp(value(e))
            val t* = KOf(FALSE-TYPE-ID)
            KBoxSet(box*, val*, t*)
         (e:KBranchError) :
            KBranchError(amb?(e), info(e), KBot())
         (e:KCurry) :
            KCurry(n(e), targs(e), a1(e), a2(e), info(e), KTop())
         (e) :
            fatal("Not supported during type inference: %~" % [e])

   defn gen-branch (b:KBranch) -> KBranch :
      for (a in args(b), t in types(b)) do :
         env[a] = IGround(t)
      val body* = gen-exp(body(b))
      KBranch(args(b), types(b), body*, info(b))

   defn gen-call (ft:IType, type-args:List<KType>, num-args:Int) -> KType :
      match(ft) :
         (ft:IArrow) :
            if empty?(type-args) :
               a2(ft)
            else :
               val env = map(KeyValue, targs(ft), type-args)
               #sub(a2(ft), env)
         (ft:IMulti) :
            val ft* = for t in types(ft) find! :
               arity(t) == num-args
            gen-call(ft*, type-args, num-args)
            
   defn gen-call (ft:IType, func:KExp, num-args:Int) :            
      match(func) :
         (func:KVar) : gen-call(ft, List(), num-args)
         (func:KCurry) : gen-call(ft, targs(func), num-args)
         (func:KLet) : gen-call(ft, body(func), num-args)
         (func:KLetRec) : gen-call(ft, body(func), num-args)
         (func:KSeq) : gen-call(ft, b(func), num-args)

   defn gen-comm (c:KComm) -> KComm :
      match(c) :
         (c:KDef) :
            val val* = gen-exp(value(c))
            #equal(env[n(c)], type!(val*))
            KDef(n(c), val*)
         (c:KDefVar) :
            match(value(c)) :
               (v:KExp) : KDefVar(n(c), type(c), gen-exp(v))
               (v:False) : c
         (c:KDefn) :
            val func* = gen-func(value(c))
            KDefn(n(c), func*)
         (c:KDefmethod) :
            val func* = gen-func(func(c)) as KFn
            KDefmethod(n(c), multi(c), targs(c), thisn(c), func*)
         (c:KDefType) :
            c
         (c:KInit) :
            val e* = gen-exp(exp(c))
            KInit(e*)
         (c:KLSDef) : c
         (c:KLSDefVar) : c
         (c:KLSDefn) : c
         (c:KLSExternFn) : c
         (c:KLSDefmethod) : c
         (c:KLSInit) : c
         (c:KLSDefType) : c
         (c:KExtern) : c
         (c:KDefmulti) : c
         (c:KDefConst) : c
         (c:KDefTypeObject) : c
         (c) : fatal("Not supported during type inference: %~" % [c])

   defn gen-func (f:Func) :
      match(f) :
         (f:KFn) :
            for (a in args(f), t in a1(f)) do :
               env[a] = IGround(t)
            val body* = gen-exp(body(f))
            val a2* = a2(env[n(f)] as IArrow)
            #equal(a2*, type!(body*))
            KFn(n(f), tail?(f), targs(f), a1(f), a2*, closure(f), args(f), body*, info(f))
         (f:KMultifn) :
            val funcs* = map(gen-func, funcs(f)) as List<KFn>
            KMultifn(n(f), funcs*, info(f))

   ;Driver
   build-environment(prog)
   val prog* = map(gen-comm, prog)
   [constraints, prog*]


defn solve-constraints (tt:TypeTable, constraints:Vector<IConstraint>) :
   ;                 State
   ;                 =====
   val solved = IntTable<KType>()

   ;                Helpers
   ;                =======
   defn sub-known (t:KType) -> KType :
      defn cache (n:Int, t:KType) :
         solved[n] = t
         t
      match(t) :
         (t:KUVar) :
            match(get?(solved, n(t), false)) :
               (t*:KType) : cache(n(t), sub-known(t*))
               (f:False) : t
         (t) : map(sub-known, t)

   defn sub-known (c:IConstraint) :
      map(simplify{tt, sub-known(_)}, c)

   defn remove-cycles (id:Int, t:KType) :
      match(t) :
         (t:KUVar) :
            if n(t) == id : KBot()
            else : t
         (t) : map(remove-cycles{id, _}, t)

   ;         Phase 2: Dataflow Solver
   ;         ========================
   defn set-solved (n:Int, t:KType) :
      val t* = simplify(tt, remove-cycles(n, sub-known(t)))
      solved[n] = t*

   for c in constraints do :
      match(sub-known(c)) :
         (c:SubConstraint) : set-solved(n(c), sub(type(c), env(c)))
         (c:EqualConstraint) : set-solved(n(c), type(c))

   ;          Phase 3: Filling Solutions
   ;          ==========================
   defn resolved? (t:KType) :
      match(t) :
         (t:KUVar) : false
         (t) : all?(resolved?, children(t))

   for entry in solved do :
      val [n, t] = [key(entry), value(entry)]
      val t* = simplify(tt, sub-known(t))
      if not resolved?(t*) :
         fatal("Could not solve for ktype %~ = %~" % [n, t*])
      solved[n] = t*
      
   solved

defn fill-types (tt:TypeTable, prog:KProg, solved:IntTable<KType>) :
   defn sub-known (t:KType) -> KType :
      match(t) :
         (t:KUVar) : solved[n(t)]
         (t) : map(sub-known, t)         
   defn fill-t (t:KType) -> KType :
      simplify(tt, sub-known(t))      
   defn fill-c (c:KComm) :
      mapr(fill-t, c)
   map(fill-c, prog)   
            
defn infer-types (prog:KProg) :
   val tt = get-type-table(prog)
   val [cs, prog*] = gen-constraints(tt, prog)
   val solved = solve-constraints(tt, cs)
   fill-types(tt, prog*, solved)

;============================================================
;==================== Cast Elision ==========================
;============================================================

defn elide-casts (prog:KProg) :
   val tt = get-type-table(prog)

   ;Branch filtering
   defn subtypes? (xs:List<KType>, ys:List<KType>) :
      all?(subtype?{tt, _, _}, xs, ys)
   defn overlaps? (xs:List<KType>, ys:List<KType>) :
      all?(overlap?{tt, _, _}, xs, ys)      
   defn selected-branches (bs:List<KBranch>, ts:List<KType>) -> List<KBranch> :
      if empty?(bs) :
         List()
      else :
         val b = head(bs)
         if subtypes?(ts, types(b)) : List(b)
         else if overlaps?(ts, types(b)) : overlapping-branches(bs, ts)
         else : selected-branches(tail(bs), ts)
   defn overlapping-branches (bs:List<KBranch>, ts:List<KType>) -> List<KBranch> :
      to-list $ for b in bs filter :
         overlaps?(ts, types(b))

   defn elide-exp (e:KExp) :
      match(mapr(elide-exp, e)) :
         (e:KCast) :
            val et = type(exp(e)) as KType
            if subtype?(tt, et, targ(e)) : exp(e)
            else : e
         (e:KMatch) :
            val arg-ts = map(type!, args(e))
            val branches* = selected-branches(branches(e), arg-ts)
            if empty?(branches*) :
               KBranchError(false, info(e), KBot())
            else if empty?(tail(branches*)) :
               val b = head(branches*)
               KLet(args(b), args(e), body(b))
            else :
               KMatch(args(e), branches*, info(e), type(e))
         (e:KDispatch) :
            val arg-ts = map(type!, args(e))
            val branches* = overlapping-branches(branches(e), arg-ts)
            if empty?(branches*) :
               KBranchError(false, info(e), KBot())
            else if empty?(tail(branches*)) :
               val b = head(branches*)
               KLet(args(b), args(e), body(b))
            else :
               KDispatch(args(e), branches*, info(e), type(e))
         (e) : e
   map(elide-exp, prog)

;============================================================
;==================== Remove Checks =========================
;============================================================

defn remove-checks (prog:KProg) :
   defn remove-exp (e:KExp) :
      match(mapr(remove-exp, e)) :
         (e:KCheckVoid) : exp(e)
         (e:KCheckLength) : exp(e)
         (e) : e
   map(remove-exp, prog)      

;============================================================
;=================== Loop Detection =========================
;============================================================

defn detect-loops (prog:KProg) :
   ;State of current function
   var current-loop:False|Int = false
   var has-loop:True|False = false

   defn detect-comm (c:KComm) -> KComm :
      defn de (e:KExp) : detect-exp(e, false, 0, 0)
      match(c) :
         (c:KDefn) :
            KDefn(n(c), detect-func(n(c), value(c)))
         (c:KDefmethod) :
            val func* = detect-func(false, func(c))
            KDefmethod(n(c), multi(c), targs(c), thisn(c), func*)
         (c) : map(de, c)

   defn detect-func<?T> (f-id:False|Int, f:?T&Func) -> T :
      {_ as T&Func} $ match(f) :
         (f:KFn) :
            if tail?(f) :
               let-var current-loop = fresh-id() :
                  let-var has-loop = false :
                     val body* = detect-exp(body(f), f-id, length(args(f)), length(targs(f)))
                     if has-loop :
                        val targs* = map(fresh-id{}, targs(f))
                        val args* = map(fresh-id{}, args(f))
                        val tenv = map({_ => KTVar(_)}, targs(f), targs*)
                        val a1* = map(sub{_, tenv}, a1(f))
                        val a2* = sub(a2(f), tenv)
                        val body* = KLetLoop(current-loop as Int, targs(f), args(f),
                                             map(KTVar,targs*), map(KVar,args*), body*, false)
                        KFn(n(f), tail?(f), targs*, a1*, a2*,
                            closure(f), args*, body*, info(f))
                     else :
                        KFn(n(f), tail?(f), targs(f), a1(f), a2(f),
                            closure(f), args(f), body*, info(f))
            else :
               map(detect-exp{_, false, 0, 0}, f)
         (f:KMultifn) :
            val funcs* = map(detect-func{f-id, _}, funcs(f))
            KMultifn(n(f), funcs*, info(f))

   defn detect-exp (e:KExp, f:False|Int, arity:Int, tarity:Int) -> KExp :
      defn dl (e:KExp) : detect-exp(e, f, arity, tarity)
      defn de (e:KExp) : detect-exp(e, false, arity, tarity)
      defn db (e:KBranch) : KBranch(args(e), types(e), dl(body(e)), info(e))
      defn dc (c:KComm) : detect-comm(c)

      match(e) :
         (e:KDo) :
            match(func(e)) :
               (v:KVar) :
                  if (n(v) == f) and (length(args(e)) == arity) and (tarity == 0) :
                     has-loop = true
                     val args* = map(de, args(e))
                     val f* = KVar(current-loop as Int)
                     KGoto(f*, args*, false)
                  else : map(de, e)
               (v:KCurry) :
                  if (n(v) == f) and (length(args(e)) == arity) and (length(targs(v)) == tarity) :
                     has-loop = true
                     val args* = map(de, args(e))
                     val f* = KCurry(current-loop as Int, targs(v), a1(v), a2(v), info(v), false)
                     KGoto(f*, args*, false)
                  else : map(de, e)
               (v) : map(de, e)
         (e:KCall) :
            if (func(e) == f) and (length(args(e)) == arity) and (tarity == 0) :
               val args* = map(de, args(e))
               KGoto(KVar(current-loop as Int), args*, false)
            else : map(de, e)
         (e:KLet) :
            val def* = dc(def(e)) as KDef|KDefn|KDefVar
            val body* = dl(body(e))
            KLet(def*, body*, false)
         (e:KLetRec) :
            val defs* = map(dc, defs(e)) as List<KDef|KDefn>
            val body* = dl(body(e))
            KLetRec(defs*, body*, info(e), false)
         (e:KLetLoop) :
            val body* = dl(body(e))
            val args* = map(de, arg-values(e))
            KLetLoop(n(e), targs(e), args(e),
                     targ-values(e), args*, body*, false)
         (e:KSeq) :
            KSeq(de(a(e)), dl(b(e)), false)
         (e:KMatch) :
            val bs* = map(db, branches(e))
            KMatch(map(de, args(e)), bs*, info(e), false)
         (e:KDispatch) :
            val bs* = map(db, branches(e))
            KDispatch(map(de, args(e)), bs*, info(e), false)
         (e:KNew) :
            val ms* = map(dc, methods(e)) as List<KDefmethod>
            KNew(class(e), ms*, info(e), false)
         (e) :
            map(de, e)

   ;Driver
   val comms* = map(detect-comm, comms(prog))
   KProg(comms*)

;============================================================
;==================== Beta Reduce ===========================
;============================================================

defstruct LetReplace :
   n: Int
   v: KExp
   body: KExp

defn beta-reduce (prog:KProg) :

   ;     Find global mutable variables
   ;     =============================
   val global-mutable = HashTable<Int,True>()
   for c in comms(prog) do :
      match(c) :
         (c:KDefVar) : global-mutable[n(c)] = true
         (c:KLSDefVar) : global-mutable[n(c)] = true
         (c) : false

   ;        Substitute Variables
   ;        ====================
   val table = HashTable<Int,KExp>()
   defn save (x:Int, v:KExp) :
      table[x] = v
      v
   defn sub? (x:KExp) :
      match(x) :
         (x:KVar) :
            match(get?(table, n(x), false)) :
               (v:KExp) : save(n(x), sub?(v))
               (v:False) : x
         (x) : x
   defn sub? (id:Int) :
      if key?(table, id) : n(table[id] as KVar)
      else : id

   defn reduce? (e:KExp) :
      match(e) :
         (e:KLet) :
            match(def(e)) :
               (def:KDef) :
                  match(value(def)) :
                     (v:KLiteral) :
                        LetReplace(n(def), v, body(e))
                     (v:KVar) :
                        if key?(global-mutable, n(v)) : e
                        else : LetReplace(n(def), v, body(e))
                     (v) : e
               (def) : e
         (e) : e

   defn reduce-exp (e:KExp) :
      match(reduce?(e)) :
         (e:LetReplace) :
            save(n(e), v(e))
            reduce-exp(body(e))
         (e:KExp) :
            match(mapr(reduce-exp, e)) :
               (e:KVar) : sub?(e)
               (e:KCurry) : KCurry(sub?(n(e)), targs(e), a1(e), a2(e), info(e), type(e))
               (e:KCall) : KCall(tail?(e), arity(e), sub?(func(e)), args(e), info(e), type(e))
               (e:KExp) : e
   ;Driver
   map(reduce-exp, prog)


;============================================================
;==================== Flattening ============================
;============================================================

defstruct LetFlatten :
   n: Int
   value: KLet|KLetRec|KSeq
   body: KExp

defn flatten (prog:KProg) :
   ;Calls f on all sub-expressions that are not Let/LetRec/Seq
   defn get-value (e:KExp, f: KExp -> KExp, return: KExp -> KExp) :
      match(e) :
         (e:KLet) :
            match(def(e)) :
               (def:KDef) :
                  get-value{value(def), f, _} $ fn (v) :
                     KLet(KDef(n(def), f(v)), get-value(body(e), f, return), false)
               (def) :
                  KLet(map(f, def), get-value(body(e), f, return), false)
         (e:KLetRec) :
            val defs* = for def in defs(e) map :
               map(f, def)
            KLetRec(defs*, get-value(body(e), f, return), info(e), false)
         (e:KSeq) :
            get-value{a(e), f, _} $ fn (a*) :
               KSeq(f(a*), get-value(b(e), f, return), false)
         (e) : return(e)

   defn flatten (e:KExp) :
      get-value(e, flatten, mapr{flatten, _})

   map(flatten, prog)

;============================================================
;==================== Elimination ===========================
;============================================================

defn eliminate-dead-code (prog:KProg) :
   ;     Side Effect Analysis
   ;     ====================
   defn side-effect? (e:KExp) :
      match(e) :
         (e:KLet) :
            side-effect?(def(e)) or side-effect?(body(e))
         (e:KLetRec) :
            side-effect?(body(e))
         (e:KSeq|KBox|KBoxGet|KTuple|KTupleGet|KObject|
            KObjectGet|KTypeObject|KClosure|KClosureGet) :
            any?(side-effect?, subexps(e))
         (e:KVar|KCurry|KLiteral|KNew) :
            false
         (e:KPrim) :
            if any?(side-effect?, subexps(e)) : true
            else : contains?([ASET-OP, CHAR-ASET-OP], op(e))   
         (e) :
            true
   defn side-effect? (c:KComm) :
      match(c) :
         (c:KDef) :
            side-effect?(value(c))
         (c:KDefVar) :
            side-effect?(value(c) as KExp) when value(c) is-not False
         (c) : false

   ;     Dead Code Elimination
   ;     =====================
   val used = HashTable<Int,True>()
   defn elim-exp (e:KExp) :
      match(e) :
         (e:KLet) :
            val body* = elim-exp(body(e))
            if key?(used, n(def(e))) :
               val def* = map(elim-exp, def(e))
               KLet(def*, body*, false)
            else :
               if side-effect?(def(e)) :
                  val v = value(def(e) as KDef|KDefVar) as KExp
                  KSeq(elim-exp(v), body*, false)
               else : body*
         (e:KLetRec) :
            val body* = elim-exp(body(e))
            val cur-defs = to-vector<KDef|KDefn>(defs(e))
            val new-defs = Vector<KComm>()
            fixpoint $ fn (progress) :
               for def in cur-defs remove-when :
                  if key?(used, n(def)) :
                     add(new-defs, map(elim-exp, def))
                     progress()
                     true
            if empty?(new-defs) :
               body*
            else :
               val defs* = to-list(new-defs) as List<KDef|KDefn>
               KLetRec(defs*, body*, info(e), false)
         (e:KSeq) :
            if side-effect?(a(e)) : map(elim-exp, e)
            else : elim-exp(b(e))
         (e:KExp) :
            val result = mapr(elim-exp, e)
            match(e) :
               (e:KVar) : used[n(e)] = true
               (e:KCurry) : used[n(e)] = true
               (e:KCall) : used[func(e)] = true
               (e) : false
            result

   map(elim-exp, prog)

;============================================================
;==================== Copy Rename ===========================
;============================================================

defn copy-rename<?T> (e:?T&(KExp|KComm|Func|KType)) -> T :
   val env = HashTable<Int,Int>()
   defn sub? (n:Int) :
      get?(env, n, n)
   defn copy-id (n:Int) :
      val n* = fresh-id()
      env[n] = n*
      n*
   defn copy-exp (e:KExp) :
      ;Create fresh ids for local definitions
      match(e) :
         (e:KLet) : copy-id(n(def(e)))
         (e:KLetRec) : do(copy-id{n(_)}, defs(e))
         (e:KLetLoop) :
            copy-id(n(e))
            do(copy-id, targs(e))
            do(copy-id, args(e))
         (e) : false
      ;Rename subcomponents
      val e* = map(copy-type, map(copy-comm, e))
      match(e*) :
         (e:KVar) : KVar(sub?(n(e)), info(e), type(e))
         (e:KCurry) : KCurry(sub?(n(e)), targs(e), a1(e), a2(e), info(e), type(e))
         (e:KMatch) : KMatch(map(copy-exp, args(e)), map(copy-branch, branches(e)), info(e), type(e))
         (e:KDispatch) : KDispatch(map(copy-exp, args(e)), map(copy-branch, branches(e)), info(e), type(e))
         (e:KLetLoop) :
            val targs* = map(copy-type, targ-values(e))
            val args* = map(copy-exp, arg-values(e))
            val body* = copy-exp(body(e))
            KLetLoop(sub?(n(e)), map(sub?, targs(e)), map(sub?, args(e)), targs*, args*, body*, type(e))
         (e) : map(copy-exp, e)
   defn copy-exp (f:False) :
      false
   defn copy-type (t:KType) :
      match(t) :
         (t:KTVar) : KTVar(get?(env, n(t), n(t)))
         (t) : map(copy-type, t)
   defn copy-comm (c:KComm) :
      match(c) :
         (c:KDef) :
            val v* = copy-exp(value(c))
            KDef(env[n(c)], v*)
         (c:KDefVar) :
            val t* = copy-type(type(c))
            val v* = copy-exp(value(c))
            KDefVar(env[n(c)], t*, v*)
         (c:KDefn) :
            val func* = copy-func(value(c))
            KDefn(env[n(c)], func*)
         (c:KDefmethod) :
            val n* = copy-id(n(c))
            val targs* = map(copy-type, targs(c))
            val func* = copy-func(func(c))
            val thisn* =
               match(thisn(c)) :
                  (thisn:Int) :
                     val i = index-of!(args(func(c)), thisn)
                     args(func*)[i]
                  (thisn:False) :
                     false
            KDefmethod(n*, multi(c), targs*, thisn*, func*)       
   defn copy-branch (c:KBranch) :
      val args* = map(copy-id, args(c))
      val types* = map(copy-type, types(c))
      val body* = copy-exp(body(c))
      KBranch(args*, types*, body*, info(c))
   defn copy-func<?T> (f:?T&Func) -> T :
      {_ as T&Func} $ match(f) :
         (f:KFn) :
            val n* = copy-id(n(f))
            val targs* = map(copy-id, targs(f))
            val a1* = map(copy-type, a1(f))
            val a2* = copy-type(a2(f))
            val closure* = copy-id(closure(f) as Int) when closure(f) is Int
            val args* = map(copy-id, args(f))
            val body* = copy-exp(body(f))
            KFn(n*, tail?(f), targs*, a1*, a2*, closure*, args*, body*, info(f))
         (f:KMultifn) :
            val funcs* = map(copy-func, funcs(f))
            KMultifn(copy-id(n(f)), funcs*, info(f))

   {_ as T&(KExp|KComm|Func|KType)} $ match(e) :
      (e:KExp) : copy-exp(e)
      (e:KComm) : copy-comm(e)
      (e:KType) : copy-type(e)
      (e:Func) : copy-func(e)

;============================================================
;======================= Inlining ===========================
;============================================================

;                   Simple Inline Entry
;                   ===================
defstruct ILEntry :
   cached-size: Int|False with: (setter => set-cached-size)
   targs: List<Int>
   args: List<Int>
   body: KExp
with :
   constructor => #ILEntry

defn ILEntry (targs:List<Int>, args:List<Int>, body:KExp) :
   #ILEntry(false, targs, args, body)

defn size (e:ILEntry) :
   defn exp-size (e:KExp) :
      ;Count number of subexpressions
      var sz:Int = 0
      defn add-size (se:KExp) :
         sz = sz + exp-size(se) ;not an issue with the new type system
      dor(add-size, e)
      ;Decide whether current expression counts
      match(e) :
         (e:KLet|KLetRec|KSeq|KDispatch|KMatch|KVar|KLiteral) :
            sz
         (e:KCast) :
            if flag-defined?(`OPTIMIZE) : sz
            else : sz + 1
         (e:KNew) :
            if empty?(methods(e)) : sz + 1
            else : sz + 20
         (e) : sz + 1
   if cached-size(e) is False :
      set-cached-size(e, exp-size(body(e)))
   cached-size(e) as Int

defmethod print (o:OutputStream, il:ILEntry) :
   val [ta, xs, b] = [targs(il), args(il), body(il)]
   if empty?(ta) : print(o, "ILEntry [%_] (%,) : %~" % [size(il), xs, b])
   else : print(o, "ILEntry [%_] <%,> . (%,) : %~" % [size(il), ta, xs, b])

;               Type Directed Inline Entry
;               ==========================

defstruct ILMEntry :
   idx: List<False|Int>
   types: List<List<KType>>
   entries: List<ILEntry>
with :
   constructor => #ILMEntry

defn ILMEntry (idx:List<False|Int>, types:List<List<KType>>, entries:List<ILEntry>) :
   for ts in types do :
      if any?(contains-vars?, ts) :
         fatal("ILMEntry assumes no type variables in match types.")
   #ILMEntry(idx, types, entries)

defn get (e:ILMEntry, tt:TypeTable, arg-ts:List<KType>, tarity:Int) -> False|ILEntry :
   defn subtypes? (xs:List<KType>, ys:List<KType>) :
      all?(subtype?{tt, _, _}, xs, ys)
   defn overlaps? (xs:List<KType>, ys:List<KType>) :
      all?(overlap?{tt, _, _}, xs, ys)
   label<False|ILEntry> return :
      val match-args = for i in idx(e) map :
         match(i) :
            (i:Int) : arg-ts[i]
            (i:False) : KTop()
      for (e in entries(e), ts in types(e)) do :
         if subtypes?(match-args, ts) : return(e when length(targs(e)) == tarity)
         else if overlaps?(match-args, ts) : return(false)

defmethod print (o:OutputStream, il:ILMEntry) :
   val es = for (ts in types(il), e in entries(il)) seq :
      "((%,) => %~)" % [ts, e]
   print(o, "ILMEntry(%,)(%@)" % [idx(il), es])

;                      ILTable
;                      =======

deftype ILTable
defmulti get (t:ILTable, tt:TypeTable, n:Int, ts:List<KType>, tarity:Int) -> False|ILEntry
defmulti set (t:ILTable, n:Int, e:ILEntry|ILMEntry) -> False

defn ILTable () :
   ;table[n, arity]
   val table = DualIntTable<ILMEntry|ILEntry>()
   new ILTable :
      defmethod get (this, tt:TypeTable, n:Int, ts:List<KType>, tarity:Int) :
         val arity = length(ts)
         match(get?(table, n, arity, false)) :
            (e:ILEntry) : e when length(targs(e)) == tarity
            (e:ILMEntry) : e[tt, ts, tarity]
            (e:False) : false
      defmethod set (this, n:Int, e:ILEntry|ILMEntry) :
         val arity = match(e) :
            (e:ILEntry) : length(args(e))
            (e:ILMEntry) : length(args(head(entries(e))))
         table[n, arity] = e
      defmethod print (o:OutputStream, this) :
         val lines = for entry in table seq :
            val [n,arity] = key(entry)
            val e = value(entry)
            "ENTRY %~ : %~" % [n, e]
         print-all(o, join(lines, "\n"))   

;                 Building ILTable
;                 ================

defn get-il-entry (f:KFn) :
   ;Which argument does the given expressions refer to?
   defn args-idx (xs:List<KExp>) :
      for x in xs map :
         match(x) :
            (x:KVar) : index-of(args(f), n(x))
            (x) : false
   defn any-int? (xs:List<False|Int>) :
      any?({_ is Int}, xs)

   ;Should we create an ilmentry?
   defn ilm-entry? (e:KExp) :
      match(e) :
         (e:KMatch) : any-int?(args-idx(args(e)))
         (e:KCast) : ilm-entry?(exp(e))
         (e:KLet) : ilm-entry?(body(e))
         (e:KLetRec) : ilm-entry?(body(e))
         (e:KSeq) : ilm-entry?(b(e))
         (e) : false

   ;Retrieve the argument indices, argument types, and bodies
   ;for creating an ILMEntry.
   defn il-bodies (e:KExp) -> List<[List<False|Int>, List<KType>, KExp]> :
      match(e) :
         (e:KMatch) :
            val idx = args-idx(args(e))
            for b in branches(e) map :
               val body* = KLet(args(b), args(e),
                                body(b))
               [idx, types(b), body*]
         (e:KCast) :
            for [idx, ts, b] in il-bodies(exp(e)) map :
               [idx, ts, KCast(b, targ(e), info(e), type(e))]            
         (e:KLet) :
            for [idx, ts, b] in il-bodies(body(e)) map :
               [idx, ts, KLet(def(e), b, type(b))]
         (e:KLetRec) :
            for [idx, ts, b] in il-bodies(body(e)) map :
               [idx, ts, KLetRec(defs(e), b, info(e), type(b))]
         (e:KSeq) :
            for [idx, ts, b] in il-bodies(b(e)) map :            
               [idx, ts, KSeq(a(e), b, type(b))]            

   ;Create appropriate inline entry      
   if ilm-entry?(body(f)) :
      defn fst<?T> ([x, y, z]:[?T, ?, ?]) : x
      defn snd<?T> ([x, y, z]:[?, ?T, ?]) : y
      defn thd<?T> ([x, y, z]:[?, ?, ?T]) : z
      
      val bodies = il-bodies(body(f))
      val idx = fst(head(bodies))
      val types = map(snd, bodies)
      val entries = map(ILEntry{targs(f), args(f), thd(_)}, bodies)
      ILMEntry(idx, types, entries)
   else :
      ILEntry(targs(f), args(f), body(f))    

defn build-il-table (prog:KProg) :
   val table = ILTable()
   defn scan-comm (c:KComm) :
      dor(scan-comm, c)
      match(c) :
         (c:KDefn) :
            match(value(c)) :
               (f:KFn) :
                  table[n(c)] = get-il-entry(f)
               (f:KMultifn) :
                  for f in funcs(f) do :
                     table[n(c)] = get-il-entry(f as KFn)
         (c) : false
   do(scan-comm, comms(prog))
   table


;                Perform Inlining
;                ================

defn inline (prog:KProg, tt:TypeTable, progress: () -> ?) :
   ;Build inline table
   val il-table = build-il-table(prog)
   
   ;Retrieve calling function, arguments, and type arguments if possible
   defn do-params (e:KExp) -> False|[Int, List<KExp>, List<KType>] :
      match(e) :
         (e:KDo) :
            match(func(e)) :
               (f:KVar) : [n(f), args(e), List()]
               (f:KCurry) : [n(f), args(e), targs(f)]
               (f) : false
         (e:KCall) : ;TODO: Not necessary in better IR
            [func(e), args(e), List()]
         (e) : false
         
   ;Inline a single call
   defn inline-call (e:ILEntry, arg-exps:List<KExp>, targ-exps:List<KType>) :
      var body* = copy-rename(body(e))
      body* = sub-targs(body*, targs(e), targ-exps)
      val args* = map(fresh-id{}, args(e))
      body* = alpha-rename(body*, map(KeyValue, args(e), args*))
      KLet(args*, arg-exps, body*)

   ;Inline all opportunities within given expression
   defn il-exp (#e:KExp) :
      val e = mapr(il-exp, #e)
      match(do-params(e)) :
         ([n, args, targs]:[Int, List<KExp>, List<KType>]) :
            val ts = map(type!, args)
            match(il-table[tt, n, ts, length(targs)]) :
               (ile:ILEntry) :
                  if size(ile) <= 5 :
                     progress()
                     inline-call(ile, args, targs)
                  else : e
               (f:False) : e
         (f:False) : e
            
   ;Driver
   map(il-exp, prog)

defn inline (prog:KProg) :
   val tt = get-type-table(prog)
   var prog* = prog
   var num-iter = 0
   fixpoint $ fn (progress) :
      if flag-defined?(`VERBOSE) :
         println("[=== Iteration %_ ===]" % [num-iter])
      if num-iter < 5 :
         vheader("INLINE")
         prog* = inline(prog*, tt, progress)
         ;println(prog*)

         vheader("DEAD CODE ELIMINATION")
         prog* = eliminate-dead-code(prog*)
         ;println(prog*)

         vheader("FLATTEN")
         prog* = flatten(prog*)
         ;println(prog*)

         vheader("BETA REDUCE")
         prog* = beta-reduce(prog*)
         ;println(prog*)

         vheader("DETECT LOOPS")
         prog* = detect-loops(prog*)
         ;println(prog*)
         
         vheader("INFER TYPES")
         prog* = infer-types(prog*)
         ;println(prog*)

         vheader("ELIDE CASTS")
         prog* = elide-casts(prog*)
         ;println(prog*)

         num-iter = num-iter + 1
   prog*      

;============================================================
;================== Closure Usage Table =====================
;============================================================

defn usage-table (prog:KProg) -> HashTable<Int,True> :
   ;                Scan for Globals
   ;                ================
   val globals = HashTable<Int, True>()
   defn global? (n:Int) : key?(globals, n)

   for c in comms(prog) do :
      match(c) :
         (c:KDef|KDefVar|KDefn|KDefmulti|KLSDef|KLSDefVar|KLSDefn|KDefConst|KLSExternFn|KExtern) :
            globals[n(c)] = true
         (c) : false
         
   ;           Calculate Closure Usages
   ;           ========================
   val used = HashTable<Int,True>()
   
   defn scan-exp (e:KExp) :
      match(e) :
         (e:KVar) :
            used[n(e)] = true
         (e:KDo) :
            scan-exp(func(e)) when func(e) is-not KVar
            do(scan-exp, args(e))
         (e) :
            dor(scan-exp, e)   

   for c in comms(prog) do :
      do(scan-exp, c)

   ;Return computed table
   used      

;============================================================
;================== Lambda Lifting ==========================
;============================================================

;                  Compute Lifts
;                  =============

defstruct LiftEntry :
   targs: List<Int>
   args: List<Int>

defmethod print (o:OutputStream, le:LiftEntry) :
   print(o, "<%,> (%,)" % [targs(le), args(le)])

defn compute-lifts (fvtable:HashTable<Int,FVEntry>, usage-table:HashTable<Int,True>) :
   ;Anchors are functions that cannot be lifted.
   ;Initially empty.
   val anchors = HashTable<Int,True>()
   val lift-args = fixpoint $ fn (progress) :
      ;Compute lifting args
      val argss = bipartite-closure $
         for entry in fvtable seq? :
            val [f, fv] = [key(entry), value(entry)]
            if key?(anchors, f) : None()
            else : One(f => args(fv))
      ;Lifting args
      for entry in argss map :
         val [f, args] = [key(entry), value(entry)]
         val fv = fvtable[f]
         if key?(usage-table, f) :
            if not empty?(free(fv)) :
               anchors[f] = true
               progress()
         f => LiftEntry(targs(fv), args)
       
   ;Store in table
   val lift-table = HashTable<Int,LiftEntry>()
   for e in lift-args do :
      val fv = value(e)
      lift-table[key(e)] = LiftEntry(targs(fv), args(fv))
   lift-table


;                   Lambda Lifting
;                   ==============

defn lambda-lift (prog:KProg, lift-table:HashTable<Int,LiftEntry>) :
   val bindings = Vector<KDefn>()
   
   defn lift? (f:Int) :
      key?(lift-table, f)
      
   defn lift-fn<?T> (le:LiftEntry, func:?T&Func) -> T :
      {_ as T&Func} $ match(func) :
         (func:KFn) :
            val targs* = append(targs(le), targs(func))
            val args* = append(args(le), args(func))
            val a1* = append(seq(KTop{}, args(le)), a1(func))
            copy-rename(KFn(n(func), tail?(func), targs*, a1*, a2(func), closure(func), args*, body(func), info(func)))
         (func:KMultifn) :
            val funcs* = map(lift-fn{le, _}, funcs(func))
            KMultifn(n(func), funcs*, info(func))

   defn lift-fn (def:KDefn) :
      val [n,f] = [n(def), value(def)]
      val f* = lift-fn(lift-table[n], f)
      add(bindings, KDefn(n, f*))
      
   defn lift-call (n:Int, type-args:List<KType>, call-args:List<KExp>, inf:False|FileInfo) :
      val le = lift-table[n]
      val targs* = append(seq(KTVar,targs(le)), type-args)
      val args* = append(seq(KVar,args(le)), call-args)
      val f* = if empty?(targs*) : KVar(n)
               else : KCurry(n, targs*, map(KTop{}, args*), KTop(), inf, false)
      KDo(f*, args*, map(KTop{}, args*), KTop(), inf, false)
      
   ;Retrieve calling function, arguments, and type arguments if possible
   defn do-params (e:KExp) -> False|[Int, List<KExp>, List<KType>, False|FileInfo] :
      match(e) :
         (e:KDo) :
            match(func(e)) :
               (f:KVar) : [n(f), args(e), List(), info(e)]
               (f:KCurry) : [n(f), args(e), targs(f), info(e)]
               (f) : false
         (e) : false
         
   defn lift-exp (e:KExp) -> KExp :
      match(mapr(lift-exp, e)) :
         (e:KLetRec) :
            val defs* = Vector<KDefn>()
            for def in defs(e) as List<KDefn> do :
               if lift?(n(def)) : lift-fn(def)
               else : add(defs*, def)
            if empty?(defs*) : body(e)
            else : KLetRec(to-list(defs*), body(e), info(e), type(body(e)))
         (e:KLet) :
            match(def(e)) :
               (def:KDefn) :
                  if lift?(n(def)) :
                     lift-fn(def)
                     body(e)
                  else : e
               (def) : e
         (e) :
            match(do-params(e)) :
               ([n, args, targs, inf]:[Int, List<KExp>, List<KType>, FileInfo]) :
                  if lift?(n) : lift-call(n, targs, args, inf)
                  else : e
               (f:False) : e

   val comms* = for c in comms(prog) map :
      map(lift-exp, c)
   KProg(append(bindings, comms*))

;                   Driver
;                   ======

defn lambda-lift (prog:KProg) :
   val fv-table = freevar-table(prog)
   val usage-table = usage-table(prog)
   val lift-table = compute-lifts(fv-table, usage-table)
   lambda-lift(prog, lift-table)

;============================================================
;================== PRIMITIVE TAGGING =======================
;============================================================

defstruct Detag :
   value: KLSExp
   type: Int

defstruct Tag :
   value: KLSExp
   type: Int

defn primitive-tagging (prog:KProg) :
   ;Pattern match KLSExp against [e].value
   defn detag? (e:KLSExp) :
      val loc = match(e) :
         (e:KLSRead) : exp(e)
         (e) : fail()
      val [base, field] = match(loc) :
         (loc:stz/kl-ir/Field) : [base(loc), n(loc)]
         (loc) : fail()
      val value = match(base) :
         (base:Deref) : exp(base)
         (base) : fail()
      val type = switch {field == _} :
         BYTE-VALUE-FIELD-ID : BYTE-TYPE-ID
         CHAR-VALUE-FIELD-ID : CHAR-TYPE-ID
         INT-VALUE-FIELD-ID : INT-TYPE-ID
         FLOAT-VALUE-FIELD-ID : FLOAT-TYPE-ID
         else : fail()
      Detag(value, type)

   ;Pattern match KLSExp against ref<T>(e)
   defn tag? (e:KLSExp) :
      val [type, args] = match(e) :
         (e:KLSRef) : [n(e), args(e)]
         (e) : fail()
      val types = [BYTE-TYPE-ID, CHAR-TYPE-ID, INT-TYPE-ID, FLOAT-TYPE-ID]
      fail() when not contains?(types, type)
      Tag(head(args), type)

   ;Convert Detag
   defn detag (e:Detag) :
      val [conv, shift, type] : [(KLSExp, KLSType) -> KLSExp, Int, KLSType] =
         switch {type(e) == _} :
            BYTE-TYPE-ID : [KLSConv{_, _, false}, 3, KByteT()]
            CHAR-TYPE-ID : [KLSConv{_, _, false}, 3, KByteT()]
            INT-TYPE-ID : [KLSConv{_, _, false}, 32, KIntT()]
            FLOAT-TYPE-ID : [KLSInterpret{KLSConv(_, KIntT(), false), _}, 3, KFloatT()]
      val v = value(e)
      val shf-v = KLSPrim(ASHR-OP, List(v, KLSLitLong(to-long(shift))), KLongT())
      conv(shf-v, type)

   ;Convert tag
   defn tag (e:Tag) :
      val [conv, shift, tag] : [KLSExp -> KLSExp, Int, Int] =
         switch {type(e) == _} :
            BYTE-TYPE-ID : [KLSConv{_, KLongT(), false}, 3, BYTE-TAG-BITS]
            CHAR-TYPE-ID : [KLSConv{_, KLongT(), false}, 3, CHAR-TAG-BITS]
            INT-TYPE-ID : [KLSConv{_, KLongT(), false}, 32, INT-TAG-BITS]
            FLOAT-TYPE-ID : [KLSConv{KLSInterpret(_, KIntT()), KLongT(), false}, 3, FLOAT-TAG-BITS]
      val v = value(e)
      val long-v = conv(v)
      val shf-v = KLSPrim(SHL-OP, List(long-v, KLSLitLong(to-long(shift))), KLongT())
      if tag == 0 : shf-v
      else : KLSPrim(ADD-OP, List(shf-v, KLSLitLong(to-long(tag))), KLongT())

   ;Convert all LSExpressions
   defn conv-ls-exp (e:KLSExp) :
      val e* =
         attempt :
            detag(detag?(e))
         else attempt :
            tag(tag?(e))
         else :
            e
      mapr(conv-ls-exp, e*)

   ;Driver
   map(conv-ls-exp, prog)

;============================================================
;================== Type Erasure ============================
;============================================================

defn type-erasure (prog:KProg) :
   defn erase-exp (exp:KExp) :
      val e = map{remove-vars, _} $
              map{erase-exp, _} $
              map{erase-comm, _} $
              exp
      match(e) :
         (e:KCurry) : KVar(n(e))
         (e:KLetLoop) : KLetLoop(n(e), List(), args(e), List(), arg-values(e), body(e), false)
         (e) : e
   defn erase-ls-exp (exp:KLSExp) :
      val e = map{remove-vars{_:KLSType}, _} $
              map{remove-vars{_:KType}, _} $
              map{erase-ls-comm, _} $
              map{erase-exp, _} $
              map(erase-ls-exp, exp)
      match(e) :
         (e:KLSCurry) : KLSVar(n(e))
         (e) : e
   defn erase-ls-comm (c:KLSComm) :
      map{erase-ls-exp, _} $
      map{erase-ls-comm, _} $
      map{remove-vars{_:KLSType}, _} $
      c
   defn erase-func (f:Func) :
      defn erase-fn (func:KFn) :
         val f = map{erase-exp, _} $
                 map{remove-vars, _} $
                 func
         KFn(n(f), tail?(f), List(), a1(f), a2(f), closure(f), args(f), body(f), info(f))
      match(f) :
         (f:KFn) : erase-fn(f)
         (f:KMultifn) : KMultifn(n(f), map(erase-fn, funcs(f) as List<KFn>), info(f))
   defn erase-comm (comm:KComm) -> KComm :
      val c = map{remove-vars{_:KType}, _} $
              map{erase-ls-exp, _} $
              map{erase-ls-comm, _} $
              map{erase-exp, _} $
              comm
      match(c) :
         (c:KDefn) : KDefn(n(c), erase-func(value(c)))
         (c:KDefmulti) : KDefmulti(n(c), List(), a1(c), a2(c), info(c))
         (c:KDefmethod) : KDefmethod(n(c), multi(c), List(), thisn(c), erase-func(func(c)) as KFn)
         (c:KLSDefn) : KLSDefn(tail?(c), n(c), List(), a1(c), a2(c), args(c), body(c), info(c))
         (c:KLSDefmethod) : KLSDefmethod(tail?(c), n(c), multi(c), List(), List(), a1(c), a2(c), args(c), body(c), info(c))
         (c) : c
   KProg(map(erase-comm, comms(prog)))


;============================================================
;================== Type Reification ========================
;============================================================

defn list-hash (xs:List<Int>) :
   if empty?(xs) : 0
   else : head(xs) + 31 * list-hash(tail(xs))

defn type-hash (t:KType) :
   match(t) :
      (x:KOf) : 1 * 31 + n(x)
      (x:KTVar) : 2 * 31 + n(x)
      (x:KAnd) : 3 * 31 * 31 + 31 * type-hash(a(x)) + type-hash(b(x))
      (x:KOr) : 4 * 31 * 31 + 31 * type-hash(a(x)) + type-hash(b(x))
      (x:KTop) : 5 * 31
      (x:KBot) : 6 * 31
      (x:KTags) : 7 * 31 + list-hash(tags(x))

defn type-reification (prog:KProg) :
   ;            Scan for Global Functions
   ;            =========================
   val global-fns = HashTable<Int, True>()
   defn global-fn? (n:Int) : key?(global-fns, n)

   for c in comms(prog) do :
      match(c) :
         (c:KDefn|KDefmulti|KLSDefn|KLSExternFn) :
            global-fns[n(c)] = true
         (c) : false

   ;              Create type objects
   ;              ===================
   val accum = Vector<KComm>()
   val type-cache = HashTable<KType, Int>(type-hash)

   ;Normalize: And ignore equivalent types.
   defn def-type-obj (t:KType, vs:List<Int>) :
      val n = fresh-id()
      val vs* = map(fresh-id{}, vs)
      val t* = sub(t, map({_ => KTVar(_)}, vs, vs*))
      add(accum, KDefTypeObject(n, vs*, t*))
      n
   defn make-type-obj (t:KType) :
      defn freevars (t:KType) :
         generate<Int> :
            defn loop (t:KType) :
               match(t) :
                  (t:KTVar) : yield(n(t))
                  (t) : do(loop, t)
            loop(t)
      val t* = simplify(t)
      val vs = unique $ freevars(t*)
      val n = def-type-obj(t*, vs)
      [n, vs]
   defn type-obj (info:False|FileInfo, t:KType) :
      if t is KTVar :
         KVar(n(t as KTVar))
      else if key?(type-cache, t) :
         KVar(type-cache[t])
      else :
         val [n, vs] = make-type-obj(t)
         if empty?(vs) :
            val v = fresh-id()
            type-cache[t] = v
            add(accum, KDefConst(v, KTypeObject(n, List(), info, false)))
            KVar(v)
         else :
            KTypeObject(n, map(KVar, vs), info, false)
   defn ls-type-obj (info:False|FileInfo, t:KType) :
      if t is KTVar :
         KLSVar(n(t as KTVar))
      else if key?(type-cache, t) :
         KLSVar(type-cache[t])
      else :
         val [n, vs] = make-type-obj(t)
         if empty?(vs) :
            val v = fresh-id()
            type-cache[t] = v
            add(accum, KDefConst(v, KTypeObject(n, List(), info, false)))
            KLSVar(v)
         else :
            KLSTypeObject(n, map(KLSVar, vs), info)

   ;           Convert all expressions
   ;           =======================
   defn conv-exp (e:KExp) :
      match(mapr(conv-exp, e)) :
         (e:KLetLoop) :
            val args* = append(targs(e), args(e))
            val targ-values* = map(type-obj{false, _}, targ-values(e))
            val arg-values* = append(targ-values*, arg-values(e))
            KLetLoop(n(e), List(), args*, List(), arg-values*, body(e), false)
         (e:KGoto) :
            match(loop(e)) :
               (f:KCurry) :
                  val targs* = map(type-obj{info(f), _}, targs(f))
                  val args* = append(targs*, args(e))
                  KGoto(KVar(n(f)), args*, false)
               (f:KVar) :
                  KGoto(f, args(e), false)
         (e:KDo) :
            val arity = length(args(e))
            match(func(e)) :
               (f:KCurry) :
                  val args* = append(map(type-obj{info(e), _}, targs(f)), args(e))
                  if global-fn?(n(f)) : KCall(false, arity, n(f), args*, info(e), false)
                  else : KCallDeref(false, arity, KVar(n(f)), args*, info(e), false)
               (f:KVar) :
                  if global-fn?(n(f)) : KCall(false, arity, n(f), args(e), info(e), false)
                  else : KCallDeref(false, arity, KVar(n(f)), args(e), info(e), false)
               (f) :
                  KCallDeref(false, arity, f, args(e), info(e), false)
         (e) : e

   ;      Convert all lostanza expressions
   ;      ================================
   defn conv-ls-exp (e:KLSExp) :
      match(mapr(conv-ls-exp, e)) :
         (e:FuncExp) :
            val f* = map(conv-exp, func(e))
            FuncExp(f*)
         (e:KLSCall) :
            val arity = length(args(e))
            match(func(e)) :
               (f:KLSVar) :
                  KLSWCall(false, arity, n(f), args(e), type(e), new-stack?(e), info(e))  
               (f:KLSCurry) :
                  val args* = append(map(ls-type-obj{info(e), _}, targs(f)), args(e))
                  KLSWCall(false, arity, n(f), args*, type(e), new-stack?(e), info(e))
               (f:KLSRead) :
                  match(exp(f)) :
                     (f:Deref) : KLSWCallDeref(false, arity, exp(f), args(e), type(e), new-stack?(e), info(e))
                     (f:Deptr) : KLSWCallDeptr(false, arity, exp(f), args(e), type(e), new-stack?(e), info(e))
         (e:KLSCallC) :
            match(func(e)) :
               (f:KLSVar) :
                  KLSWCallC(n(f), args(e), type(e))
               (f:KLSCurry) :
                  KLSWCallC(n(f), args(e), type(e))
               (f:KLSRead) :
                  val f* = exp(f) as Deptr
                  KLSWCallCDeptr(exp(f*), args(e), type(e))
         (e:KLSSwitchStack) :
            KLSWSwitchStack(false, func(e), List(arg(e)), type(e), info(e))
         (e) :
            e

   ;                  Driver
   ;                  ======
   val prog* = map(conv-exp, conv-ls-exp, prog)
   prepend(accum, prog*)


;============================================================
;============== Free Variable Computation ===================
;============================================================

defstruct FVEntry :
   args: List<Int>
   targs: List<Int>

defn free (e:FVEntry) :
   append(args(e), targs(e))

defmethod print (o:OutputStream, fv:FVEntry) :
   print(o, "FV<%,>{%,}" % [targs(fv), args(fv)])

defn freevar-table (prog:KProg) :

   ;                Scan for Globals
   ;                ================
   val globals = HashTable<Int, True>()
   defn global? (n:Int) : key?(globals, n)

   for c in comms(prog) do :
      match(c) :
         (c:KDef|KDefVar|KDefn|KDefmulti|KLSDef|KLSDefVar|KLSDefn|KDefConst|KLSExternFn|KExtern) :
            globals[n(c)] = true
         (c) : false

   ;           Calculate Freevars of Functions
   ;           ===============================
   ;table[i] = fv implies function i has free variables fv
   val table = HashTable<Int, FVEntry>()

   ;Get the freevars in a given function
   defn freevars (f:Func) -> FVEntry :
      val arg-vars = HashTable<Int,True|False>()
      val targ-vars = HashTable<Int,True|False>()

      defn mark-free (t:KType) :
         match(t) :
            (t:KTVar) : targ-vars[n(t)] = true
            (t) : do(mark-free, t)

      defn mark-func (f:Func) :
         val fv = freevars(f)
         for x in args(fv) do :
            arg-vars[x] = true
         for x in targs(fv) do :
            targ-vars[x] = true

      defn mark-free (e:KExp) :
         defn mark-branch (b:KBranch) :
            mark-free(body(b))
            for x in args(b) do :
               arg-vars[x] = false

         match(e) :
            (e:KLet) :
               mark-free(body(e))
               match(def(e)) :
                  (d:KDef|KDefVar) :
                     do(mark-free, d)
                     arg-vars[n(d)] = false
                  (d:KDefn) :
                     mark-func(value(d))
                     arg-vars[n(d)] = false
            (e:KLetRec) :
               mark-free(body(e))
               for d in defs(e) do :
                  mark-func(value(d as KDefn))
               for d in defs(e) do :
                  arg-vars[n(d)] = false
            (e:KLetLoop) :
               mark-free(body(e))
               for x in args(e) do :
                  arg-vars[x] = false
               for x in targs(e) do :
                  arg-vars[x] = false
                  targ-vars[x] = false
               arg-vars[n(e)] = false
               do(mark-free, targ-values(e))
               do(mark-free, arg-values(e))
            (e:KDispatch) :
               do(mark-free, args(e))
               do(mark-branch, branches(e))
            (e:KMatch) :
               do(mark-free, args(e))
               do(mark-branch, branches(e))
            (e:KNew) :
               for m in methods(e) do :
                  mark-func(func(m))
            (e:KVar) :
               if not global?(n(e)) :
                  arg-vars[n(e)] = true
            (e:KCurry) :
               if not global?(n(e)) :
                  arg-vars[n(e)] = true
               do(mark-free, targs(e))   
            (e:KCast) :
               do(mark-free, e)
               mark-free(targ(e))
            (e) :
               do(mark-free, e)

      match(f) :
         (f:KFn) :
            mark-free(body(f))
            ;Bound arguments are not free
            for x in args(f) do :
               arg-vars[x] = false
            ;Bound type arguments are not free.
            ;Affects arg-vars because of reified type variables.
            for x in targs(f) do :
               arg-vars[x] = false
               targ-vars[x] = false
            if closure(f) is-not False :
               arg-vars[closure(f) as Int] = false
         (f:KMultifn) :
            do(mark-func, funcs(f))
            
      defn grab (t:HashTable<Int, True|False>) :
         to-list(seq(key, filter(value, t)))
      val fv = FVEntry(grab(arg-vars), grab(targ-vars))
      table[n(f)] = fv
      fv

   ;  Compute freevars for every function in every expression
   ;  =======================================================
   defn scan-exp (e:KExp) :
      do(scan-comm, e)
      do(scan-exp, e)
   defn scan-comm (c:KComm) :
      match(c) :
         (c:KDefn) : table[n(c)] = freevars(value(c))
         (c:KDefmethod) : table[n(c)] = freevars(func(c))
         (c) : do(scan-exp, c)
   defn scan-ls-exp (e:KLSExp) :
      match(e) :
         (e:FuncExp) : freevars(func(e))
         (e) : dor(scan-ls-exp, e)
   defn scan-ls-comm (c:KLSComm) :
      dor(scan-ls-exp, c)

   ;                      Driver
   ;                      ======
   for c in comms(prog) do :
      do(scan-ls-comm, c)
      do(scan-ls-exp, c)
      do(scan-exp, c)
   table


;============================================================
;=================== Object Lifting =========================
;============================================================

defn lift-objects (prog:KProg, freetable: HashTable<Int,FVEntry>) :
   ;New top level forms
   val accum = Vector<KComm>()
   defn lift-top (c:KComm) : add(accum, c)   

   val marker-types = HashTable<KType, Int>(type-hash)
   defn make-marker (parent:KType) :
      if not key?(marker-types, parent) :
         val id = fresh-id()
         lift-top(KLSDefType(id, parent, List(), false))
         marker-types[parent] = id
      marker-types[parent]
   defn make-type (parent:KType, num-fields:Int) :
      val id = fresh-id()
      val fs = for i in 0 to num-fields map :
         StructField(fresh-id(), KRefT(KTop()))
      lift-top(KLSDefType(id, parent, fs, false))
      id

   defn lift (e:KExp) :
      match(mapr(lift,e)) :
         (e:KNew) :
            ;Free variables
            val fvs = unique $
               for m in methods(e) seq-cat :
                  free(freetable[n(func(m))])
            ;Names of free variables
            val venv = map({_ => fresh-id()}, fvs)
            ;Create struct for object
            val newtype =
               if empty?(methods(e)) : make-marker(class(e))
               else : make-type(class(e), length(fvs))
            ;Pull methods out to top-level
            for m in methods(e) do :
               ;Function in method
               val f = func(m)
               ;Argument name for object
               val obj = thisn(m) as Int
               ;Update body of method
               var body* = alpha-rename(body(f), venv)
               for (entry in venv, i in 0 to false) do :
                  body* = KLet(KDef(value(entry), KObjectGet(KVar(obj), i, false)),
                               body*,
                               false)
               ;Update types for method
               val tenv = map({_ => KTop()}, fvs)
               defn erase-free-type (t:KType) : sub(t, tenv)
               ;Update input types of method
               val a1* = for (t in a1(f), a in args(f)) map :
                  if a == obj : KOf(newtype)
                  else : erase-free-type(t)
               val a2* = erase-free-type(a2(f))
               ;Pull out to top-level method
               lift-top $ KDefmethod(n(m), multi(m), targs(m), false,
                  KFn(fresh-id(), tail?(f), targs(f),
                      a1*, a2*, closure(f), args(f), body*, info(f)))
            ;Change New to Object
            KObject(newtype, map(KVar, fvs), info(e), false)
         (e) :
            e

   ;Lift all object expressions and push to accum
   for c in comms(prog) do :
      lift-top(map(lift, c))

   ;Return new program
   KProg(to-list(accum))


;============================================================
;================== Multi Conversion ========================
;============================================================

defn convert-multis (prog:KProg) :
   ;Find all methods in program
   val method-table = HashTable<Int, List<KDefmethod|KLSDefmethod>>()
   defn methods (n:Int) : get?(method-table, n, List())
   defn find-methods (c:KComm) :
      match(c) :
         (c:KDefmethod|KLSDefmethod) :
            method-table[multi(c)] = cons(c, methods(multi(c)))
         (c) : false
   do(find-methods, comms(prog))

   ;Conversion
   defn convert (c:KComm) :
      match(c) :
         (c:KDefmulti) :
            val args* = map(fresh-id{}, a1(c))
            val branches* = for m in methods(n(c)) map :
               defn deref (t:KLSType) : type(t as KRefT)
               val ts = match(m) :
                  (m:KDefmethod) : map(remove-vars, a1(func(m)))
                  (m:KLSDefmethod) : map(remove-vars{deref(_)}, a1(m))
               val xs = map(fresh-id{}, a1(c))
               val args* = append(map(KVar, targs(c)), map(KVar, xs))
               val body = KCall(false, length(a1(c)), n(m), args*, info(c), false)
               KBranch(xs, ts, body, info(c))
            val guarded-args* = map(KCast{KVar(_), _, info(c), false}, args*, a1(c))
            val body* = KDispatch(guarded-args*, branches*, info(c), false)
            val guarded-body* = KCast(body*, a2(c), info(c), false)
            val func* = KFn(fresh-id(), false, targs(c), a1(c), a2(c), false, args*, guarded-body*, info(c))
            KDefn(n(c), func*)
         (c:KDefmethod) :
            KDefn(n(c), func(c))
         (c:KLSDefmethod) :
            KLSDefn(tail?(c), n(c), targs(c), a1(c), a2(c), args(c), body(c), info(c))
         (c) :
            c

   ;Return program
   KProg(map(convert, comms(prog)))


;============================================================
;================== Dispatch Conversion =====================
;============================================================

defn dispatch-conversion (prog:KProg) :
   val tt = get-type-table(prog)
   defn conv-exp (e:KExp) :
      match(mapr(conv-exp, e)) :
         (e:KDispatch) : convert-dispatch(tt, e)
         (e) : e
   map(conv-exp, prog)  

;============================================================
;=================== Closure Lifting ========================
;============================================================

defn lift-closures (prog:KProg, freetable:HashTable<Int,FVEntry>) :
   val accum = Vector<KComm>()

   ;     Lift a function to the top-level.
   ;     ---------------------------------
   ;Returns the identifier of the Defn representing the code for the function.
   defn lift-func (f:Func) -> Int :
      ;Lift function, given free variables fvs at indices idx
      defn lift (f:KFn, fvs:List<Int>, idx:List<Int>) :
         ;Names of free variables
         val venv = for v in fvs map :
            v => fresh-id()
         ;Name of closure object
         val clo = fresh-id()
         ;Pull function to top-level
         var body* = alpha-rename(body(f), venv)
         for (entry in venv, i in idx) do :
            val v* = value(entry)
            body* = KLet(KDef(v*, KClosureGet(KVar(clo), i, false)),
                         body*,
                         false)
         ;Update input types and arguments of method
         val tenv = map({_ => KTop()}, fvs)
         defn erase-free-type (t:KType) : sub(t, tenv)
         val a1* = map(erase-free-type, a1(f))
         val a2* = erase-free-type(a2(f))
         ;Return updated func
         KFn(fresh-id(), tail?(f), targs(f), a1*, a2*, clo, args(f), body*, info(f))

      ;Lift function under default free variable mapping
      defn lift (f:KFn) :
         val fv = free(freetable[n(f)])
         val idx = for (v in fv, i in 0 to false) map : i
         lift(f, fv, idx)

      ;Lift multi function
      defn lift (f:KMultifn) :
         val mfv = free(freetable[n(f)])
         val funcs* = for f in funcs(f) as List<KFn> map :
            val fv = free(freetable[n(f)])
            val idx = for v in fv map : index-of!(mfv, v)
            lift(f, fv, idx)
         KMultifn(n(f), funcs*, info(f))

      val f* = lift(f as KFn|KMultifn)
      val n* = fresh-id()
      add(accum, KDefn(n*, f*))
      n*

   ;     Lift all functions within expression
   ;     ------------------------------------
   defn lift-exp (e:KExp) :
      defn lift-def (c:KDefn|KDef|KDefVar) :
         match(c) :
            (c:KDefn) :
               val fvs = free(freetable[n(value(c))])
               val code = lift-func(value(c))
               if flag-defined?(`VERBOSE) :
                  println("Lifted closure %~ to %~" % [n(c), code])
               KDef(n(c), KClosure(code, map(KVar, fvs), info(value(c)), false))
            (c) : c

      match(mapr(lift-exp, e)) :
         (e:KLet) :
            KLet(lift-def(def(e)), body(e), false)
         (e:KLetRec) :
            val defs* = map({lift-def(_) as KDef}, defs(e))
            KLetRec(defs*, body(e), info(e), false)
         (e) :
            e

   ;     Lift all functions within ls expression
   ;     ---------------------------------------
   defn lift-ls-exp (e:KLSExp) :
      match(mapr(lift-ls-exp, e)) :
         (e:FuncExp) :
            val f = func(e)
            val fvs = free(freetable[n(f)])
            fatal("Untested") when not empty?(fvs)
            val code = lift-func(f)
            KLSClosure(code, map(KLSVar, fvs), info(f))
         (e) : e
   defn lift-ls-comm (c:KLSComm) :
      mapr(lift-ls-exp, c)

   val prog* = map(lift-exp, lift-ls-exp, prog)
   prepend(accum, prog*)

;============================================================
;================== Make Global Closures ====================
;============================================================

defn make-global-closures (prog:KProg) :
   ;Compute usage table 
   val usage-table = usage-table(prog)

   ;Create forwarding functions
   defn forward (c:KDefn) -> Func :
      defn forward-fn (f:KFn) :
         val arity = length(args(f))
         val targs* = map(fresh-id{}, targs(f))
         val args* = map(fresh-id{}, args(f))
         val a1* = map(KTop{}, args*)
         val call-args* = map(KVar, append(targs*, args*))
         val body* = KCall(false, arity, n(c), call-args*, info(f), false)
         KFn(fresh-id(), true, targs*, a1*, KTop(), fresh-id(), args*, body*, info(f))
      match(value(c)) :
         (f:KFn) :
            forward-fn(f)
         (f:KMultifn) :
            val funcs* = map(forward-fn, funcs(f) as List<KFn>)
            KMultifn(fresh-id(), funcs*, info(f))
   defn forward (c:KLSDefn) -> KFn :
      val arity = length(args(c))
      val targs* = map(fresh-id{}, targs(c))
      val args* = map(fresh-id{}, args(c))
      val a1* = map(KTop{}, args*)
      val call-args* = map(KVar, append(targs*, args*))
      val body* = KCall(false, arity, n(c), call-args*, info(c), false)
      KFn(fresh-id(), true, targs*, a1*, KTop(), fresh-id(), args*, body*, info(c))      

   ;Create closures
   val accum = Vector<KComm>()
   val closure-table = HashTable<Int,Int>()
   for c in comms(prog) do :
      match(c) :
         (c:KDefn) :
            if key?(usage-table, n(c)) :
               val code = KDefn(fresh-id(), forward(c))
               val closure = KDefConst(fresh-id(), KClosure(n(code), List(), info(value(c)), false))
               add(accum, code)
               add(accum, closure)
               closure-table[n(c)] = n(closure)
         (c:KLSDefn) :
            if key?(usage-table, n(c)) :
               val code = KDefn(fresh-id(), forward(c))
               val closure = KDefConst(fresh-id(), KClosure(n(code), List(), info(c), false))
               add(accum, code)
               add(accum, closure)
               closure-table[n(c)] = n(closure)
         (c) : false
   var prog* = KProg(append(accum, comms(prog)))

   ;Rename usages
   defn rename-usages (e:KExp) :
      match(e) :
         (e:KVar) :
            match(get?(closure-table, n(e), false)) :
               (n:Int) : KVar(n)
               (f:False) : e
         (e) :
            mapr(rename-usages, e)

   defn rename-usages (e:KLSExp) :
      match(e) :
         (e:KLSVar) :
            match(get?(closure-table, n(e), false)) :
               (n:Int) : KLSVar(n)
               (f:False) : e
         (e:FuncExp) :
            val func* = map(rename-usages, func(e))
            FuncExp(func*)
         (e) :
            mapr(rename-usages, e)

   ;Driver
   map(rename-usages, rename-usages, prog*)




;                    Converting Calls
;                    ================

defn convert-calls (prog:KProg) :
   val codetable = HashTable<Int,Int>()
   defn conv-exp (e:KExp) :
      defn recur (e:KExp) :
         mapr(conv-exp, e)
      defn record-code (d) :
         match(d) :
            (d:KDef) :
               match(value(d)) :
                  (v:KClosure) :
                     codetable[n(d)] = n(v)
                  (v) : false
            (d) : false
      match(e) :
         (e:KCallDeref) :
            match(func(e)) :
               (f:KVar) :
                  val args* = map(conv-exp, args(e))
                  if key?(codetable, n(f)) :
                     KCall(tail?(e), arity(e), codetable[n(f)], cons(f, args*), info(e), false)
                  else : recur(e)
               (f) : recur(e)
         (e:KLet) :
            record-code(def(e))
            recur(e)
         (e:KLetRec) :
            do(record-code, defs(e))
            recur(e)
         (e) :
            recur(e)

   ;     Driver
   ;     ------
   KProg $ for c in comms(prog) map :
      map(conv-exp, c)

;                    Code Conversion
;                    ===============

defn convert-code (prog:KProg) :
   ;Inserting tail calls
   defn insert-tail-calls (b:KBranch) :
      KBranch(args(b), types(b), insert-tail-calls(body(b)), info(b))
   defn insert-tail-calls (e:KExp) :
      match(e) :
         (e:KLet) : KLet(def(e), insert-tail-calls(body(e)), false)
         (e:KLetRec) : KLetRec(defs(e), insert-tail-calls(body(e)), info(e), false)
         (e:KLetLoop) : KLetLoop(n(e), targs(e), args(e), targ-values(e), arg-values(e), insert-tail-calls(body(e)), false)
         (e:KMatch) :
            val branches* = map(insert-tail-calls, branches(e))
            KMatch(args(e), branches*, info(e), false)
         (e:KDispatch) :
            val branches* = map(insert-tail-calls, branches(e))
            KDispatch(args(e), branches*, info(e), false)
         (e:KSeq) : KSeq(a(e), insert-tail-calls(b(e)), type(e))
         (e:KCall) : KCall(true, arity(e), func(e), args(e), info(e), type(e))
         (e:KCallDeref) : KCallDeref(true, arity(e), func(e), args(e), info(e), type(e))
         (e) : e

   defn insert-tail-calls (c:KLSComm) :
      match(mapr(insert-tail-calls, c)) :
         (c:KLSReturn) :
            val e* = match(exp(c)) :
               (e:KLSWCall) :
                  KLSWCall(true, arity(e), func(e), args(e), type(e), new-stack?(e), info(e))
               (e:KLSWCallDeptr) :
                  KLSWCallDeptr(true, arity(e), func(e), args(e), type(e), new-stack?(e), info(e))
               (e:KLSWCallDeref) :
                  KLSWCallDeref(true, arity(e), func(e), args(e), type(e), new-stack?(e), info(e))
               (e:KLSWSwitchStack) :
                  KLSWSwitchStack(true, func(e), args(e), type(e), info(e))
               (e) : e
            KLSReturn(e*)
         (c) : c

   ;Convert functions
   defn conv-fn (f:Func) :
      match(f) :
         (f:KFn) :
            ;Create arguments
            var args* = args(f)
            ;Include reified type arguments
            args* = append(targs(f), args*)
            ;Include closure argument
            if closure(f) is-not False :
               args* = cons(closure(f) as Int, args*)
            ;Compute body with tailcalls
            val body* = insert-tail-calls(body(f)) when tail?(f) else body(f)
            ;Compute arity of function
            val arity = length(args(f))
            ;Create code
            KCode(fresh-id(), arity, args*, body*, info(f))
         (f:KMultifn) :
            val fs* = map(conv-fn, funcs(f))
            KMultifn(n(f), fs* as List<KCode>, info(f))

   defn conv-ls-fn (f:KLSDefn) :
      ;Create arguments
      var args* = args(f)
      var types* = a1(f)
      ;Include reified type arguments
      for t in targs(f) do :
         args* = cons(t, args*)
         types* = cons(KRefT(KTop()), types*)
      ;Compute body with tailcalls
      val body* = insert-tail-calls(body(f)) when tail?(f) else body(f)
      ;Compute arity of function
      val arity = length(args(f))
      ;Create code
      KLSDefCode(n(f), arity, args*, types*, body*, info(f))

   ;Driver
   KProg $ for c in comms(prog) map :
      match(c) :
         (c:KDefn) :
            defn ns (f:Func) :
               match(f) :
                  (f:KCode) : List(n(f))
                  (f:KMultifn) : seq-append(ns, funcs(f))
            val codes = conv-fn(value(c))
            if flag-defined?(`VERBOSE) :
               println("Codes for %~ = %*" % [n(c), join(ns(codes), ", ")])
            KDefn(n(c), codes)
         (c:KLSDefn) : conv-ls-fn(c)
         (c) : c

;                    Cast Conversion
;                    ===============

defn cast-conversion (prog:KProg) :
   defn conv-exp (e:KLSExp) :
      match(mapr(conv-exp, e)) :
         (e:KLSConv) :
            match(type(e)) :
               (t:KRefT) : KLSCast(exp(e), type(t), info(e))
               (t) : e
         (e) : e
   defn conv-comm (c:KLSComm) :
      mapr(conv-exp, c)

   KProg $ for c in comms(prog) map :
      map(conv-comm, c)


;============================================================
;==================== Compilation ===========================
;============================================================


;                    Tag Bit Utilities
;                    =================

defn tag-as-marker (n:Int) :
   n << 3 + MARKER-TAG-BITS
defn tag-as-byte (v:Byte) :
   to-int(v) << 3 + BYTE-TAG-BITS
defn tag-as-char (v:Char) :
   to-int(v) << 3 + CHAR-TAG-BITS
defn tag-as-int (v:Int) :
   to-long(v) << to-long(32) + to-long(INT-TAG-BITS)
defn tag-as-float (v:Float) :
   to-long(bits(v)) << to-long(3) + to-long(FLOAT-TAG-BITS)
defn tag-as-tag (n:Int) :
   n << 3 + TAG-TAG-BITS
defn tag-as-header (n:Int) :
   n << 3 + HEADER-TAG-BITS


;============================================================
;================== Match Trie Conversion ===================
;============================================================

deftype MTrie
defmulti type (t:MTrie) -> KType

defstruct TrieArg <: MTrie :
   type: KType with: (as-method => true)
   children: List<MTrie>
defstruct TrieEnd <: MTrie :
   type: KType with: (as-method => true)
   lbl: Int

defmethod print (o:OutputStream, tr:MTrie) :
   print{o,_} $
   match(tr) :
      (tr:TrieArg) : "(%~ => %*)" % [type(tr), join(children(tr), " or ")]
      (tr:TrieEnd) : "(%~ => %~)" % [type(tr), lbl(tr)]

defn to-trie (branches:List<List<KType>>, lbls:List<Int>) -> List<MTrie> :
   ;Add a list of types ending with a branch to the given list of tries
   defn add (trs:List<MTrie>, types:List<KType>, branch-lbl:Int) -> List<MTrie> :
      val [t, rest] = [head(types), tail(types)]
      ;Case: Path is unreachable
      if bottom?(t) :
         trs
      ;Case: There are currently no tries.
      else if empty?(trs) :
         if empty?(rest) : List(TrieEnd(t, branch-lbl))
         else : List(TrieArg(t, add(trs, rest, branch-lbl)))
      else :
         val [tr, tr-rest] = [head(trs), tail(trs)]
         ;Case: Head of trie is covered completely by path
         if type-subset?(type(tr), t) :
            val tr* = match(tr) :
               (tr:TrieArg) : TrieArg(type(tr), add(children(tr), rest, branch-lbl))
               (tr:TrieEnd) : tr
            val types* = cons(type-subtraction(t, type(tr)), rest)
            cons(tr*, add(tr-rest, types*, branch-lbl))
         ;Case: Path is covered completely by head of trie
         else if type-subset?(t, type(tr)) :
            match(tr) :
               (tr:TrieArg) :
                  cons(TrieArg(t, add(children(tr), rest, branch-lbl))
                  cons(TrieArg(type-subtraction(type(tr), t), children(tr))
                       tr-rest))
               (tr:TrieEnd) :
                  trs
         ;Case: Trie needs to be split more finely.
         else :
            val t1 = type-intersection(type(tr), t)
            if bottom?(t1) :
               cons(tr, add(tr-rest, types, branch-lbl))
            else :
               val t2 = type-subtraction(t, t1)
               val types1 = cons(t1, rest)
               val types2 = cons(t2, rest)
               val trs* = add(trs, types1, branch-lbl)
               add(trs*, types2, branch-lbl)

   ;Driver
   var accum:List<MTrie> = List()
   for (b in branches, lbl in lbls) do :
      accum = add(accum, b, lbl)
   accum

;============================================================
;================== Dispatch Conversion =====================
;============================================================

defstruct DispatchTree :
   branch: KBranch|KLSBranch
   children: List<DispatchTree>

defmethod print (o:OutputStream, t:DispatchTree) :
   defn cms (xs) : join(xs, ", ")
   if empty?(children(t)) :
      print(o, "(%* => END)" % [cms(types(branch(t)))])
   else :
      print(o, "(%* => %*)" % [cms(types(branch(t))), cms(children(t))])

defn TreeList (tt:TypeTable, bs:List<KBranch|KLSBranch>) -> List<DispatchTree> :
   ;Forming the Dispatch Tree
   defn less-eq? (a:KBranch|KLSBranch, b:KBranch|KLSBranch) :
      all?(subtype?{tt, _, _}, types(a), types(b))
   defn cmp (a:KBranch|KLSBranch, b:KBranch|KLSBranch) :
      match(a <= b, b <= a) :
         (x:True, y:False) : -1
         (x:False, y:True) : 1
         (x, y) : 0
   defn tlist (a:DispatchTree, bs:List<DispatchTree>) -> List<DispatchTree> :
      if empty?(bs) :
         List(a)
      else :
         val b = head(bs)
         val r = cmp(branch(a), branch(b))
         switch {r == _} :
            -1 :
               val b* = DispatchTree(branch(b), tlist(a, children(b)))
               cons(b*, tail(bs))
            0 :
               cons(b, tlist(a, tail(bs)))
            1 :
               val a* = DispatchTree(branch(a), tlist(b, children(a)))
               tlist(a*, tail(bs))

   ;Driver
   if empty?(bs) :
      List()
   else :
      val t = DispatchTree(head(bs), List())
      tlist(t, TreeList(tt, tail(bs)))

defn ambiguity-list (tt:TypeTable, arglists: List<List<KType>>) -> List<List<KType>> :
   ;Compute all pair-wise couples
   defn all-pairs<?T> (xs:Seqable<?T>) :
      val xs* = to-tuple(xs)
      generate<[T, T]> :
         for i in 0 to length(xs*) do :
            for j in (i + 1) to length(xs*) do :
               yield([xs*[i], xs*[j]])

   ;Compute all intersections
   val intersections = Vector<List<KType>>()
   for [a, b] in all-pairs(arglists) do :
      val c = map(type-intersection, a, b)
      add(intersections, c) when none?(bottom?, c)

   ;Keep only minimum couples
   defn covers? (a:List<KType>, b:List<KType>) :
      all?(subtype?{tt, _, _}, b, a)
   minima(to-list(intersections), covers?)

defn dispatch-branches (tt: TypeTable,
                        branches: List<KBranch|KLSBranch>
                        AmbBranch: List<KType> -> KBranch|KLSBranch) :
   ;Computing the ambiguity branches
   defn amb-branches (bs:List<KBranch|KLSBranch>) -> List<KBranch|KLSBranch> :
      if length(bs) > 1 :
         val arglists = for b in bs map :
            map(dispatch-type{tt, _}, types(b))
         val amblists = ambiguity-list(tt, arglists)
         map(AmbBranch, amblists)
      else :
         List()

   to-list $ generate<KBranch|KLSBranch> :
      defn loop (ts:List<DispatchTree>) :
         do(yield, amb-branches(map(branch, ts)))
         for t in ts do :
            loop(children(t))
            yield(branch(t))
      loop(TreeList(tt, branches))

defn convert-dispatch (tt:TypeTable, e:KDispatch) :
   defn AmbBranch (ts:List<KType>) :
      val xs = map(fresh-id{}, ts)
      KBranch(xs, ts, KBranchError(true, info(e), false), info(e))
   if empty?(branches(e)) :
      KBranchError(false, info(e), false)
   else if empty?(args(e)) :
      if length(branches(e)) == 1 : body(head(branches(e)))
      else : KBranchError(true, info(e), false)
   else :
      val bs = dispatch-branches(tt, branches(e), AmbBranch)
      KMatch(args(e), bs as List<KBranch>, info(e), false)

defn convert-ls-dispatch (tt:TypeTable, e:KLSDispatch) :
   defn AmbBranch (ts:List<KType>) :
      val xs = map(fresh-id{}, ts)
      KLSBranch(xs, ts, KLSBranchError(true, info(e)))
   if empty?(branches(e)) :
      KLSBranchError(false, info(e))
   else if empty?(args(e)) :
      if length(branches(e)) == 1 : body(head(branches(e)))
      else : KLSBranchError(false, info(e))
   else :
      val bs = dispatch-branches(tt, branches(e), AmbBranch)
      KLSMatch(args(e), bs as List<KLSBranch>, info(e))


;                   Command Buffer
;                   ==============

;     Emission of DefIns Structures
;     -----------------------------
var DEF-INS-VECTOR : False|Vector<tgt-DefIns> = false
defn emit (i:tgt-DefIns) : add(DEF-INS-VECTOR as Vector<tgt-DefIns>, i)


;     Emission of Ins Structures
;     --------------------------
var INSTRUCTION-VECTOR : False|Vector<tgt-Ins> = false
defn emit (i:tgt-Ins) : add(INSTRUCTION-VECTOR as Vector<tgt-Ins>, i)
defn args (xs:List<tgt-Var>) : emit(tgt-ArgsIns(xs))
defn set (x:tgt-Var, y:tgt-Imm) : emit(tgt-SetIns(x, y))
defn conv (x:tgt-Var, y:tgt-Imm) : emit(tgt-ConvertIns(x, y))
defn interpret (x:tgt-Var, y:tgt-Imm) : emit(tgt-InterpretIns(x, y))
defn unaop (x:tgt-Var, op:tgt-TgtOp, y:tgt-Imm) : emit(tgt-UnaOp(x, op, y))
defn binop (x:tgt-Var, op:tgt-TgtOp, y:tgt-Imm, z:tgt-Imm) : emit(tgt-BinOp(x, op, y, z))
defn add (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : binop(x, tgt-ADD-OP, y, z)
defn sub (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : binop(x, tgt-SUB-OP, y, z)
defn mul (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : binop(x, tgt-MUL-OP, y, z)
defn shl (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : binop(x, tgt-SHL-OP, y, z)
defn shr (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : binop(x, tgt-SHR-OP, y, z)
defn bit-and (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : emit(tgt-BinOp(x, tgt-AND-OP, y, z))
defn load (x:tgt-Var, y:tgt-Imm, o:Int) : emit(tgt-Load(x, y, o))
defn store (x:tgt-Imm, y:tgt-Imm, o:Int) : emit(tgt-Store(x, y, o))
defn addr (x:tgt-Var, n:Int) : emit(tgt-Addr(x, n))
defn call (info:False|FileInfo, a:Int, xs:List<tgt-Var>, f:tgt-Imm, ys:List<tgt-Imm>, ns?:True|False) :
   emit(tgt-Call(a, xs, f, ys, ns?, info))
defn call (info:False|FileInfo, a:Int, xs:List<tgt-Var>, f:tgt-Imm, ys:List<tgt-Imm>) :
   call(info, a, xs, f, ys, false)
defn callstack (info:False|FileInfo, xs:List<tgt-Var>, f:tgt-Imm, ys:List<tgt-Imm>) :
   emit(tgt-CallStack(xs, f, ys, info))
defn ffi-call (xs:List<tgt-Var>, f:tgt-Imm, ys:List<tgt-Imm>) : emit(tgt-CallC(xs, f, ys))
defn tcall (a:Int, f:tgt-Imm, ys:List<tgt-Imm>, ns?:True|False) : emit(tgt-TCall(a, f, ys, ns?))
defn tcall (a:Int, f:tgt-Imm, ys:List<tgt-Imm>) : tcall(a, f, ys, false)
defn tcallstack (f:tgt-Imm, ys:List<tgt-Imm>) : emit(tgt-TCallStack(f, ys))
defn return (xs:List<tgt-Imm>) : emit(tgt-Return(xs))
defn tlabel (n:Int) : emit(tgt-Label(n))
defn goto (n:Int) : emit(tgt-Goto(n))
defn jne (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-NE-OP, x, y))
defn jeq (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-EQ-OP, x, y))
defn jlt (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-LT-OP, x, y))
defn jle (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-LE-OP, x, y))
defn jult (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-ULT-OP, x, y))
defn jule (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-ULE-OP, x, y))
defn jgt (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-GT-OP, x, y))
defn jge (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-GE-OP, x, y))
defn jugt (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-UGT-OP, x, y))
defn juge (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-UGE-OP, x, y))
defn byte (v:Byte) : tgt-ByteImm(v)
defn byte (v:Int) : tgt-ByteImm(to-byte(v)) ;TODO: No longer necessary with literals
defn int (v:Int) : tgt-IntImm(v)
defn long (v:Int) : tgt-LongImm(to-long(v)) ;TODO: No longer necessary with literals
defn long (v:Long) : tgt-LongImm(v)
defn mem (n:Int, offset:Int) : tgt-Mem(n, offset)
defn xmem (name:Symbol, offset:Int) : tgt-ExMem(name, offset)
defn mem (n:Int) : tgt-Mem(n, 0)
defn xmem (name:Symbol) : tgt-ExMem(name, 0)

defn jstack-has-space (n:Int) : emit(tgt-SpecialBranch(n, tgt-STACK-HAS-SPACE))
defn jarity-neq (n:Int, arity:Int) : emit(tgt-SpecialBranch(n, tgt-ArityNEqOp(arity)))
defn switch-stack () : emit(tgt-SpecialOp(tgt-SWITCH-STACK-OP))

;     Heap Instructions
;     -----------------
defn heap-ptr () :
   val p = make-var(tgt-LONG-TYPE)
   load(p, mem(HEAP-PTR-LBL), 0)
   p

defn heap-lim () :
   val p = make-var(tgt-LONG-TYPE)
   load(p, mem(HEAP-LIM-LBL), 0)
   p

defn extend-heap (info:False|FileInfo, sz:tgt-Imm) :
   val endL = fresh-id()
   val p = heap-ptr()
   add(p, p, sz)
   jule(endL, p, heap-lim())
   call(info, 1, List(), mem(EXTEND-HEAP-ID), List(sz))
   tlabel(endL)

defn extend-heap (info:False|FileInfo, sz:Int) :
   extend-heap(info, long(sz))

defn inc-heap-ptr (sz:tgt-Imm) :
   val p = heap-ptr()
   add(p, p, sz)
   store(mem(HEAP-PTR-LBL), p, 0)

defn inc-heap-ptr (sz:Int) :
   inc-heap-ptr(long(sz))

;     Compound Value Instructions
;     ---------------------------
defn value-lbl (ins:tgt-DefIns) :
   val n = fresh-id()
   emit(tgt-TLabel(n))
   emit(ins)
   n
defn double-lbl (f:Double) : value-lbl(tgt-DefDouble(f))
defn string-lbl (s:String) : value-lbl(tgt-DefString(s))

;     Conversion of Primitive Operators
;     ---------------------------------
defn to-tgt-op (op:KLSOp) :
   switch {op == _} :
      ADD-OP : tgt-ADD-OP
      SUB-OP : tgt-SUB-OP
      MUL-OP : tgt-MUL-OP
      DIV-OP : tgt-DIV-OP
      MOD-OP : tgt-MOD-OP
      AND-OP : tgt-AND-OP
      OR-OP : tgt-OR-OP
      XOR-OP : tgt-XOR-OP
      SHL-OP : tgt-SHL-OP
      SHR-OP : tgt-SHR-OP
      ASHR-OP : tgt-ASHR-OP
      EQ-OP : tgt-EQ-OP
      NE-OP : tgt-NE-OP
      LT-OP : tgt-LT-OP
      GT-OP : tgt-GT-OP
      LE-OP : tgt-LE-OP
      GE-OP : tgt-GE-OP
      ULT-OP : tgt-ULT-OP
      UGT-OP : tgt-UGT-OP
      ULE-OP : tgt-ULE-OP
      UGE-OP : tgt-UGE-OP
      NOT-OP : tgt-NOT-OP
      NEG-OP : tgt-NEG-OP

;                  Variable Management
;                  ===================

;     Definition of VarTable
;     ----------------------
deftype VarTable
defmulti get (t:VarTable, i:Int) -> List<tgt-Var>
defmulti set (t:VarTable, i:Int, x:List<tgt-Var>) -> False
defmulti make-var (v:VarTable, t:tgt-TgtType) -> tgt-Var
defmulti types (v:VarTable, n:Int) -> List<tgt-TgtType>
defmulti defs (v:VarTable) -> Vector<tgt-DefVar>

defn VarTable () :
   val defs = Vector<tgt-DefVar>()
   val table = HashTable<Int,List<tgt-Var>>()
   val type-table = HashTable<Int,tgt-TgtType>()

   new VarTable :
      defmethod make-var (this, t:tgt-TgtType) :
         val n = fresh-id()
         add(defs, tgt-DefVar(n, t))
         type-table[n] = t
         tgt-Var(n)
      defmethod set (this, n:Int, vs:List<tgt-Var>) :
         table[n] = vs
      defmethod get (this, n:Int) :
         table[n]
      defmethod types (this, x:Int) :
         for v in this[x] map :
            type-table[tgt-n(v)]
      defmethod defs (this) :
         defs

defn make-vars (v:VarTable, ts:List<tgt-TgtType>) :
   for t in ts map :
      make-var(v, t)

;     Implicit VarTable
;     -----------------
var VAR-TABLE : False|VarTable = false
defn VAR-TABLE! () : VAR-TABLE as VarTable
defn make-var (t:tgt-TgtType) : make-var(VAR-TABLE!(), t)
defn make-ref () : make-var(tgt-REF-TYPE)
defn make-long () : make-var(tgt-LONG-TYPE)
defn make-vars (ts:List<tgt-TgtType>) : map(make-var, ts)
defn env-vars (n:Int) : VAR-TABLE!()[n]
defn var-types (n:Int) : types(VAR-TABLE!(), n)


;                    Global Table
;                    ============

deftype GlobalTable
defmulti get (t:GlobalTable, i:Int) -> GEntry
defmulti add-global (gt:GlobalTable, n:Int) -> False
defmulti add-function (gt:GlobalTable, n:Int) -> False
defmulti add-type-object (gt:GlobalTable, n:Int) -> False
defmulti add-const (gt:GlobalTable, n:Int, v) -> False
defmulti add-ls-global (gt:GlobalTable, n:Int, t:KLSType) -> False
defmulti add-ls-function (gt:GlobalTable, n:Int) -> False
defmulti add-ls-extern (gt:GlobalTable, n:Int, t:KLSType, lbl:Symbol) -> False
defmulti global-var? (t:GlobalTable, n:Int) -> True|False
defmulti global-lbl (t:GlobalTable, n:Int) -> Int|Symbol
defmulti global-var-type (t:GlobalTable, n:Int) -> KLSType
defmulti root-vars (t:GlobalTable) -> Seqable<Int>
defmulti global-consts (t:GlobalTable) -> Seqable<Int>

defn global-var? (gt:GlobalTable, e:KLSExp) :
   match(e) :
      (e:KLSVar) : global-var?(gt, n(e))
      (e) : false

;Values: Globals, Consts, Externs
;Functions: Functions, Types
deftype GEntry
defstruct HiGlobal <: GEntry
defstruct HiFunction <: GEntry
defstruct HiType <: GEntry
defstruct GConst <: GEntry : (value)
defstruct LoGlobal <: GEntry : (type:KLSType)
defstruct LoFunction <: GEntry
defstruct GExtern <: GEntry : (type:KLSType, lbl:Symbol)

defn GlobalTable () :
   val entries = HashTable<Int, GEntry>()
   val root-vars = Vector<Int>()
   val consts = Vector<Int>()

   new GlobalTable :
      defmethod add-global (this, n:Int) -> False :
         entries[n] = HiGlobal()
         add(root-vars, n)
      defmethod add-function (this, n:Int) -> False :
         entries[n] = HiFunction()
      defmethod add-type-object (this, n:Int) -> False :
         entries[n] = HiType()
      defmethod add-const (this, n:Int, v) -> False :
         entries[n] = GConst(v)
         add(consts, n)
      defmethod add-ls-global (this, n:Int, t:KLSType) -> False :
         entries[n] = LoGlobal(t)
         add(root-vars, n)
      defmethod add-ls-function (this, n:Int) -> False :
         entries[n] = LoFunction()
      defmethod add-ls-extern (this, n:Int, t:KLSType, lbl:Symbol) -> False :
         entries[n] = GExtern(t, lbl)
      defmethod global-var? (this, n:Int) -> True|False :
         get?(entries, n, false) is HiGlobal|GConst|LoGlobal|GExtern
      defmethod global-lbl (this, n:Int) -> Int|Symbol :
         match(entries[n]) :
            (e:GExtern) : symbol-join(["_", lbl(e)])
            (e) : n
      defmethod global-var-type (this, n:Int) -> KLSType :
         match(entries[n]) :
            (e:LoGlobal|GExtern) : type(e)
            (e:HiGlobal|GConst) : KRefT(KTop())
      defmethod get (this, n:Int) :
         entries[n]
      defmethod root-vars (this) :
         root-vars
      defmethod global-consts (this) :
         consts


;                     Type Analysis
;                     =============

;     Type Table Interface
;     --------------------
deftype TypeTable
defmulti add-type (tt:TypeTable, c:KDefType) -> False
defmulti add-ls-type (tt:TypeTable, c:KLSDefType) -> False
defmulti end-adds (tt:TypeTable) -> False

defmulti expand (tt:TypeTable, t:KLSType) -> List<tgt-TgtType>
defmulti pad+expand (tt:TypeTable, t:KLSType) -> List<tgt-TgtType>
defmulti offsets (tt:TypeTable, t:KLSType) -> List<Int>
defmulti size (tt:TypeTable, t:KLSType) -> Int
defmulti count (tt:TypeTable, t:KLSType) -> Int
defmulti alignment (tt:TypeTable, t:KLSType) -> Int
defmulti field-offset (tt:TypeTable, f:Int) -> Int
defmulti field-index (tt:TypeTable, f:Int) -> Int
defmulti field-type (tt:TypeTable, f:Int) -> KLSType
defmulti rfield (tt:TypeTable, n:Int) -> Int
defmulti tag (tt:TypeTable, n:Int) -> Int
defmulti dispatch-type (tt:TypeTable, t:KType) -> KTags|KTop
defmulti cast-type (tt:TypeTable, t:KType) -> KType
defmulti primitive? (tt:TypeTable, n:Int) -> True|False
defmulti marker? (tt:TypeTable, n:Int) -> True|False
defmulti subtype? (tt:TypeTable, a:KType, b:KType) -> True|False
defmulti overlap? (tt:TypeTable, a:KType, b:KType) -> True|False
defmulti tagged-types (tt:TypeTable) -> Seqable<KLSDefType>


;     Type Arithmetic
;     ---------------
defn set-subtraction (a:List<Int>, b:List<Int>) :
   to-list(for x in a filter : not contains?(b, x))
defn set-union (a:List<Int>, b:List<Int>) :
   unique(append(a, b))
defn set-intersection (a:List<Int>, b:List<Int>) :
   to-list(for x in a filter : contains?(b, x))
defn set-overlap? (a:List<Int>, b:List<Int>) :
   for x in a any? : contains?(b, x)
defn type-subtraction (a:KType, b:KType) :
   match(a, b) :
      (a:KTop, b) : a
      (a, b:KTop) : KTags(List())
      (a:KTags, b:KTags) : KTags(set-subtraction(tags(a), tags(b)))

defn type-union (a:KType, b:KType) :
   match(a, b) :
      (a:KTags, b:KTags) : KTags(set-union(tags(a), tags(b)))
      (a:KBot, b) : b
      (a, b:KBot) : a
      (a, b:KTop) : b
      (a:KTop, b) : a
      (a, b) :
         if a == b : a
         else : KOr(a, b)
defn type-intersection (a:KType, b:KType) :
   match(a, b) :
      (a:KTags, b:KTags) : KTags(set-intersection(tags(a), tags(b)))
      (a:KBot, b) : a
      (a, b:KBot) : b
      (a, b:KTop) : a
      (a:KTop, b) : b
      (a, b) :
         if a == b : a
         else : KAnd(a, b)
defn type-subset? (a:KType, b:KType) :
   match(a, b) :
      (a:KTags, b:KTags) : for x in tags(a) all? : contains?(tags(b), x)
      (a, b:KTop) : true
      (a:KTop, b) : false
defn bottom? (t:KType) :
   match(t) :
      (t:KBot) : true
      (t:KTags) : empty?(tags(t))
      (t) : false
defn simplify (t:KType) :
   match(t) :
      (t:KAnd) : type-intersection(simplify(a(t)), simplify(b(t)))
      (t:KOr) : type-union(simplify(a(t)), simplify(b(t)))
      (t) : t
defn remove-vars (t:KType) :
   match(t) :
      (t:KTVar) : KTop()
      (t) : map(remove-vars, t)
defn remove-vars (t:KLSType) :
   map(remove-vars{_:KType}, t)

defn contains-vars? (t:KType) :
   match(t) :
      (t:KTVar) : true
      (t) : any?(contains-vars?, children(t))

defn simplify (tt:TypeTable, t:KType) -> KType :
   defn* or-ts (t:KType, accum:List<KType>) :
      match(t) :
         (t:KOr) : or-ts(b(t), or-ts(a(t), accum))
         (t) : cons(t, accum)
   defn* and-ts (t:KType, accum:List<KType>) :
      match(t) :
         (t:KAnd) : and-ts(b(t), and-ts(a(t), accum))
         (t) : cons(t, accum)
   defn #supertype? (a:KType, b:KType) : #subtype?(b, a)
   defn #subtype? (a:KType, b:KType) : subtype?(tt, a, b)
   defn st (t:KType) -> KType :
      match(t) :
         (t:KOr) :
            reduce(KOr, ts*) where :
               val ts = minima(or-ts(t, List()), #supertype?)
               val ts* = seq(st, ts)
         (t:KAnd) :
            reduce(KAnd, ts*) where :
               val ts = minima(and-ts(t, List()), #subtype?)
               val ts* = seq(st, ts)
         (t) :
            map(st, t)
   st(t)

;     Analysis
;     --------
defn TypeTable () :
   ;     Search through all types
   ;     ------------------------
   val lstypes = HashTable<Int, KLSDefType>()
   val types = HashTable<Int, KDefType>()

   ;     Compute Expansions
   ;     ------------------
   val struct-expansions = HashTable<Int, List<tgt-TgtType>>()
   defn expand (t:KLSType) :
      defn expand-struct (n:Int) :
         for f in fields(lstypes[n]) seq-append :
            expand(type(f))
      match(t) :
         (t:KByteT) : List(tgt-BYTE-TYPE)
         (t:KIntT) : List(tgt-INT-TYPE)
         (t:KLongT) : List(tgt-LONG-TYPE)
         (t:KFloatT) : List(tgt-FLOAT-TYPE)
         (t:KDoubleT) : List(tgt-DOUBLE-TYPE)
         (t:KPtrT) : List(tgt-LONG-TYPE)
         (t:KRefT) : List(tgt-REF-TYPE)
         (t:KStructT) :
            if not key?(struct-expansions, n(t)) :
               struct-expansions[n(t)] = expand-struct(n(t))
            struct-expansions[n(t)]
         (t) : fatal("No expansion for %~." % [t])

   ;     Compute Field Types and Indices
   ;     -------------------------------
   val field-structs = HashTable<Int,Int>()
   val field-indices = HashTable<Int,Int>()
   val field-types = HashTable<Int,KLSType>()
   defn compute-field-stats () :
      for def in values(lstypes) do :
         for (f in fields(def), i in 0 to false) do :
            field-structs[n(f)] = n(def)
            field-indices[n(f)] = i
            field-types[n(f)] = type(f)
         if rfield(def) is-not False :
            val f = rfield(def) as StructField
            field-structs[n(f)] = n(def)
            field-indices[n(f)] = length(fields(def))
            field-types[n(f)] = type(f)

   ;     Compute Struct Tags
   ;     -------------------
   val tag-table = HashTable<Int,Int>()
   val tag-types = Vector<Int>()
   defn compute-struct-tags () :
      defn assign-next-tag (n:Int) :
         if not key?(tag-table, n) :
            if flag-defined?(`VERBOSE) :
               println("Assigned tag %~ to %~" % [length(tag-types), n])
            tag-table[n] = length(tag-types)
            add(tag-types, n)
      assign-next-tag(FALSE-TYPE-ID)
      assign-next-tag(TRUE-TYPE-ID)
      for def in values(lstypes) do :
         assign-next-tag(n(def))

   ;     Compute All Subclasses
   ;     ----------------------
   val subclass-table = HashTable<Int, List<Int>>()
   defn class-parent (n:Int) -> False|KType :
      if key?(lstypes, n) : parent(lstypes[n])
      else if key?(types, n) : parent(types[n])
      else : fatal("Not a type: %~" % [n])

   defn class-parents (t:KOf, class:Int) -> List<KOf> :
      defn loop (t:False|KType) -> List<KOf> :
         match(t) :
            (t:KOf) :
               if n(t) == class : List(t)
               else : loop(class-parent(n(t)))
            (t:KAnd) : append(loop(a(t)), loop(b(t)))
            (t:False) : List()
      loop(t)

   defn subclasses (n:Int) :
      get?(subclass-table, n, List())

   defn ls-subclasses (n:Int) :
      to-list $ for n in subclasses(n) filter :
         key?(lstypes, n)

   defn compute-subclasses () :
      defn do-classes (f: Int -> ?, t:False|KType) :
         match(t) :
            (t:KOf) : f(n(t))
            (t:KAnd) : (do-classes(f, a(t)), do-classes(f, b(t)))
            (t:False) : false
      defn add-child (p:Int, n:Int) :
         subclass-table[p] = cons(n, subclasses(p))
         for p in class-parent(p) do-classes :
            add-child(p, n)
      for t in keys(types) do : add-child(t, t)
      for t in keys(lstypes) do : add-child(t, t)

   defn dispatch-type (t:KType) -> KTags|KTop :
      match(t) :
         (t:KOf) : KTags(ls-subclasses(n(t)))
         (t:KTVar) : KTop()
         (t:KAnd) : type-intersection(dispatch-type(a(t)), dispatch-type(b(t))) as KTags|KTop
         (t:KOr) : type-union(dispatch-type(a(t)), dispatch-type(b(t))) as KTags|KTop
         (t:KTop) : t
         (t:KBot) : KTags(List())
         (t:KTags) : t

   defn cast-type (t:KType) :
      match(t) :
         (t:KOf) : KTags(ls-subclasses(n(t)))
         (t:KTVar) : t
         (t:KAnd) : type-intersection(cast-type(a(t)), cast-type(b(t)))
         (t:KOr) : type-union(cast-type(a(t)), cast-type(b(t)))
         (t:KTop) : t
         (t:KBot) : KTags(List())
         (t:KTags) : t

   defn subtype? (x:False, y:KType) :
      false
   defn subtype? (x:KType, y:KType) :
      match(x, y) :
         ;3. Fast Path
         (x:KBot, y) : true
         (x, y:KTop) : true
         ;2. Combinatory Types
         (x:KOr, y) : subtype?(a(x), y) and subtype?(b(x), y)
         (x, y:KAnd) : subtype?(x, a(y)) and subtype?(x, b(y))
         (x:KAnd, y:KOr) : subtype?(x, a(y)) or subtype?(x, b(y)) or
                           subtype?(a(x), y) or subtype?(b(x), y)
         (x, y:KOr) : subtype?(x, a(y)) or subtype?(x, b(y))
         (x:KAnd, y) : subtype?(a(x), y) or subtype?(b(x), y)
         ;1. Ground Types
         (x:KOf, y:KOf) :
            if n(x) == n(y) : true
            else : subtype?(class-parent(n(x)), y)
         (x:KTVar, y:KTVar) : n(x) == n(y)
         ;5. Unification Variables
         (x:KUVar, y:KUVar) : n(x) == n(y)
         ;4. Tag Types
         (x:KTags, y:KTags) : type-subset?(x, y)
         (x:KTags, y:KOf) : type-subset?(x, dispatch-type(y))
         (x:KOf, y:KTags) : contains?(tags(y), n(x))
         ;Fall Through
         (x, y) : false

   ;Two types overlap if there exists a value that is a subtype of both x and y
   defn overlap? (x:KType, y:KType) :
      fatal("Invalid type: %~" % [x]) when x is-not KBot|KTop|KOr|KAnd|KOf|KTVar|KTags
      fatal("Invalid type: %~" % [y]) when y is-not KBot|KTop|KOr|KAnd|KOf|KTVar|KTags
      match(x, y) :
         ;1. Bottom fast path
         (x:KBot, y) : false
         (x, y:KBot) : false
         ;2. Top fast path
         (x:KTop|KTVar, y) : true
         (x, y:KTop|KTVar) : true
         ;3. Combinatory types
         (x:KOr|KAnd, y) : overlap?(a(x), y) or overlap?(b(x), y)
         (x, y:KOr|KAnd) : overlap?(x, a(y)) or overlap?(x, b(y))
         ;4. Ground types
         (x:KOf, y:KOf) : set-overlap?(subclasses(n(x)), subclasses(n(y)))
         ;6. Tag Types
         (x:KTags, y:KTags) : set-overlap?(tags(x), tags(y))
         (x:KTags, y:KOf) : set-overlap?(tags(x), ls-subclasses(n(y)))
         (x:KOf, y:KTags) : set-overlap?(ls-subclasses(n(x)), tags(y))
         ;5. Fall through          
         (x, y) : false

   ;     Compute Alignments, Padding, and Size
   ;     -------------------------------------
   val pad+expansions = HashTable<Int, List<tgt-TgtType>>()
   val struct-alignments = HashTable<Int, Int>()
   val type-sizes = HashTable<Int,Int>()
   val field-offsets = HashTable<Int,Int>()

   defn type-size (t:KLSType) :
      match(t) :
         (t:KByteT) : 1
         (t:KIntT) : 4
         (t:KLongT) : 8
         (t:KFloatT) : 4
         (t:KDoubleT) : 8
         (t:KPtrT) : 8
         (t:KRefT) : 8
         (t:KUnknownT) : fatal("No size.")
         (t:KFnT) : fatal("No size.")
         (t:KStructT) :
            compute-struct(n(t)) when not key?(type-sizes, n(t))
            type-sizes[n(t)]

   defn type-alignment (t:KLSType) :
      match(t) :
         (t:KStructT) :
            compute-struct(n(t)) when not key?(struct-alignments, n(t))
            struct-alignments[n(t)]
         (t) : type-size(t)

   defn pad+expand (t:KLSType) :
      match(t) :
         (t:KStructT) :
            compute-struct(n(t)) when not key?(pad+expansions, n(t))
            pad+expansions[n(t)]
         (t) : expand(t)

   defn field-offset (f:Int) :
      if not key?(field-offsets, f) :
         compute-struct(field-structs[f])
      field-offsets[f]

   defn compute-struct (sn:Int) :
      ;Pad struct fields
      val def = lstypes[sn]

      ;Accumulated size and expansion
      var accum = 0
      val expansion = Vector<tgt-TgtType>()

      ;Alignment items
      val fields = match(rfield(def)) :
         (rf:False) : fields(def)
         (rf:StructField) : cat(fields(def), [rf])
      val items = for f in fields seq :
         Item(type-alignment(type(f)), n(f))
      val [items*, aln] = pad(items, 1)   
      label break :
         for x in items* do :
            match(x) :
               (x:Item) :
                  val f = data(x) as Int
                  val ft = field-types[f]
                  field-offsets[f] = accum
                  if rfield(def) is StructField :
                     break(false) when f == n(rfield(def) as StructField)
                  do(add{expansion, _}, pad+expand(ft))
                  accum = accum + type-size(ft)
               (x:Padding) :
                  val sz = size(x)
                  add(expansion, tgt-IntType(sz))
                  accum = accum + size(x)      

      ;Record Size, Expansion, and Alignment
      type-sizes[sn] = accum
      pad+expansions[sn] = to-list(expansion)
      struct-alignments[sn] = aln


   ;     Return Table
   ;     ------------
   new TypeTable :
      defmethod add-type (this, c:KDefType) :
         types[n(c)] = c
      defmethod add-ls-type (this, c:KLSDefType) :
         lstypes[n(c)] = c
      defmethod end-adds (this) :
         compute-field-stats()
         compute-struct-tags()
         compute-subclasses()
      defmethod expand (this, t:KLSType) :
         expand(t)
      defmethod count (this, t:KLSType) :
         length(expand(t))
      defmethod pad+expand (this, t:KLSType) :
         pad+expand(t)
      defmethod offsets (this, t:KLSType) :
         match(t) :
            (t:KStructT) :
               for f in fields(lstypes[n(t)]) map :
                  field-offset(n(f))
            (t) : List(0)
      defmethod size (this, t:KLSType) :
         type-size(t)
      defmethod alignment (this, t:KLSType) :
         type-alignment(t)
      defmethod field-offset (this, f:Int) :
         field-offset(f)
      defmethod field-type (this, f:Int) :
         field-types[f]
      defmethod field-index (this, f:Int) :
         field-indices[f]
      defmethod rfield (this, s:Int) :
         n(rfield(lstypes[s]) as StructField)
      defmethod tag (this, n:Int) :
         tag-table[n]
      defmethod dispatch-type (this, t:KType) :
         dispatch-type(t)
      defmethod cast-type (this, t:KType) :
         cast-type(t)
      defmethod primitive? (this, n:Int) :
         contains?([BYTE-TYPE-ID, CHAR-TYPE-ID, INT-TYPE-ID, FLOAT-TYPE-ID], n)
      defmethod marker? (this, n:Int) :
         match(get?(lstypes, n, false)) :
            (t:KLSDefType) : empty?(fields(t)) and (rfield(t) is False)
            (t:False) : false
      defmethod subtype? (this, a:KType, b:KType) :
         subtype?(a, b)
      defmethod overlap? (this, a:KType, b:KType) :
         overlap?(a, b)
      defmethod tagged-types (this) :
         for n in tag-types seq :
            lstypes[n]

;============================================================
;====================== COMPILATION =========================
;============================================================

deftype Linkage
defstruct ReturnLink <: Linkage
defstruct IgnoreLink <: Linkage
defstruct AssignLink <: Linkage :
   loc: tgt-Var

defmethod print (o:OutputStream, l:Linkage) :
   print{o, _} $ match(l) :
      (l:ReturnLink) : "return"
      (l:IgnoreLink) : "ignore"
      (l:AssignLink) : "assign(%~)" % [loc(l)]

deftype LSLinkage
defstruct LSAssignLink <: LSLinkage :
   locs: List<tgt-Var>
defstruct LSIgnoreLink <: LSLinkage
defstruct LSReturnLink <: LSLinkage
defstruct LSArgLink <: LSLinkage

defstruct CResult :
   types: List<tgt-TgtType>
   imms: List<tgt-Imm>

deftype CLoc
defstruct PtrLoc <: CLoc :
   base: tgt-Imm
   offset: Int
   type: KLSType
defstruct ExpLoc <: CLoc :
   exp: KLSExp
defstruct SubExpLoc <: CLoc :
   exp: KLSExp
   index: Int
   count: Int
   type: KLSType

defn sublist<?T> (xs:List<?T>, i:Int, n:Int) :
   headn(tailn(xs, i), n)

defn compile (prog:KProg) -> tgt-Program :
   ;     Analysis
   ;     ========
   val gt = GlobalTable()
   val tt = TypeTable()
   val loop-table = HashTable<Int, List<tgt-Var>>()

   for c in comms(prog) do :
      match(c) :
         (c:KDef) : add-global(gt, n(c))
         (c:KDefVar) : add-global(gt, n(c))
         (c:KDefn) : add-function(gt, n(c))
         (c:KDefTypeObject) : add-type-object(gt, n(c))
         (c:KDefConst) : add-const(gt, n(c), value(c))
         (c:KDefType) : add-type(tt, c)
         (c:KInit) : false
         (c:KLSDef) : add-ls-global(gt, n(c), type(c))
         (c:KLSDefVar) : add-ls-global(gt, n(c), type(c))
         (c:KLSDefCode) : add-ls-function(gt, n(c))
         (c:KLSExternFn) : add-ls-function(gt, n(c))
         (c:KExtern) : add-ls-extern(gt, n(c), type(c), lbl(c))
         (c:KLSDefType) : add-ls-type(tt, c)
         (c:KLSInit) : false

   end-adds(tt)

   ;Retrieving the immediates for a global
   defn global-mem (n:Int, offset:Int) :
      match(global-lbl(gt, n)) :
         (l:Int) : mem(l, offset)
         (l:Symbol) : xmem(l, offset)
   defn global-mem (n:Int) :
      global-mem(n, 0)


   ;     Compiling Tables
   ;     ================
   defn compile-machine-state () :
      emit(tgt-DefData())

      ;Floating Point Zeros
      emit(tgt-TLabel(FLOAT-ZERO-LBL))
      emit(tgt-DefFloat(0.0f))
      emit(tgt-TLabel(DOUBLE-ZERO-LBL))
      emit(tgt-DefDouble(0.0))

      ;Heap Labels
      emit(tgt-TLabel(HEAP-PTR-LBL))
      emit(tgt-DefLong(0L))
      emit(tgt-TLabel(HEAP-LIM-LBL))
      emit(tgt-DefLong(0L))

      ;Stack Labels
      emit(tgt-TLabel(STACK-PTR-LBL))
      emit(tgt-DefLong(0L))
      emit(tgt-TLabel(STACK-LIM-LBL))
      emit(tgt-DefLong(0L))
      emit(tgt-TLabel(STACK-POOL-LBL))
      emit(tgt-DefLong(0L))
      emit(tgt-TLabel(NUM-FREE-STACKS-LBL))
      emit(tgt-DefLong(0L))
      emit(tgt-TLabel(FREE-STACKS-LBL))
      emit(tgt-DefLong(0L))
      emit(tgt-TLabel(STACK-LBL))
      emit(tgt-DefLong(0L))

      emit(tgt-DefText())

   ;     Compiling Object Tables
   ;     =======================
   defn compile-object-table () :
      ;Create table
      val obj-table = Vector<[Int, KLSDefType]>()
      for t in tagged-types(tt) do :
         add(obj-table, [fresh-id(), t])

      ;Emit Table
      emit(tgt-DefData())
      emit(tgt-TLabel(OBJECT-TABLE-LBL))
      for [lbl, t] in obj-table do :
         emit(tgt-DefLabel(lbl))

      ;Emit Table Entries
      for [lbl, t] in obj-table do :
         ;Compute bit masks for base and tail
         defn bitmask (t:KLSType) :
            tgt-to-bitmask(tgt-ref-mask(pad+expand(tt, t)))
         val base-size = size(tt, KStructT(n(t)))
         val base-bits = bitmask(KStructT(n(t)))
         val [tail-size, tail-bits] = match(rfield(t)) :
            (rf:False) :
               [0, List()]
            (rf:StructField) :
               [size(tt, type(rf)),
                bitmask(type(rf))]

         ;Emit mask entry
         emit(tgt-TLabel(lbl))
         emit(tgt-DefInt(base-size))
         emit(tgt-DefInt(tail-size))
         do(emit{tgt-DefLong(_)}, base-bits)
         do(emit{tgt-DefLong(_)}, tail-bits)
      emit(tgt-DefText())

   ;     Compiling Globals
   ;     =================
   defn compile-globals () :
      ;Sort all variables by alignment for packing
      val entries = Vector<Int>()
      do(add{entries, _}, root-vars(gt))
      qsort!(alignment{tt, global-var-type(gt, _)}, entries)

      ;Pad all variables to ensure structures are aligned
      val items = let :
         val xs = for e in entries seq :
            Item(alignment(tt, global-var-type(gt, e)), e)
         val [padded-xs, aln] = pad(xs, 8)
         padded-xs

      ;Compute the globals table
      ;[Consts ... Global Vars ...]
      val globals = Vector<Int|tgt-TgtType>()
      for n in global-consts(gt) do :
         add(globals, n)
         add(globals, tgt-REF-TYPE)
      for x in items do :
         match(x) :
            (x:Item) :
               val n = data(x) as Int
               val ts = pad+expand(tt, global-var-type(gt, n))
               add(globals, n)
               do(add{globals, _}, ts)
            (x:Padding) :
               add(globals, tgt-IntType(size(x)))

      ;Emit the globals mask table
      ;[Length, Bits ...]
      let :
         val refs = tgt-ref-mask{_ as Seqable<tgt-TgtType>} $
            filter({_ is tgt-TgtType}, globals)
         val mask = tgt-to-bitmask(refs)
         emit(tgt-TLabel(GLOBAL-MAP-LBL))
         emit(tgt-DefLong(to-long(length(refs))))
         do(emit{tgt-DefLong(_)}, mask)

      ;Emit the globals table
      ;[Data ...]
      emit(tgt-DefData())
      emit(tgt-TLabel(GLOBAL-TABLE-LBL))
      for g in globals do :
         emit $ match(g) :
            (g:Int) :
               tgt-TLabel(g)
            (g:tgt-TgtType) :
               switch {g == _} :
                  tgt-BYTE-TYPE : tgt-DefByte(0Y)
                  tgt-INT-TYPE : tgt-DefInt(0)
                  tgt-LONG-TYPE : tgt-DefLong(0L)
                  tgt-FLOAT-TYPE : tgt-DefFloat(0.0f)
                  tgt-DOUBLE-TYPE : tgt-DefDouble(0.0)
                  tgt-REF-TYPE : tgt-DefLong(to-long(VOID-TAG))
      emit(tgt-DefText())

   ;     Compiling Constant Table
   ;     ========================
   defn compile-constant-table () :
      defn emit-const (v) :
         defn emit-tag (n:Int) :
            emit(tgt-DefInt(n))
         match(v) :
            (v:Byte) :
               emit-tag(BYTE-CONST-TAG)
               emit(tgt-DefByte(v))
            (v:Char) :
               emit-tag(CHAR-CONST-TAG)
               emit(tgt-DefByte(to-byte(v)))
            (v:Int) :
               emit-tag(INT-CONST-TAG)
               emit(tgt-DefInt(v))
            (v:Long) :
               emit-tag(LONG-CONST-TAG)
               emit(tgt-DefLong(v))
            (v:Float) :
               emit-tag(FLOAT-CONST-TAG)
               emit(tgt-DefFloat(v))
            (v:Double) :
               emit-tag(DOUBLE-CONST-TAG)
               emit(tgt-DefDouble(v))
            (v:String) :
               val n = length(v)
               emit-tag(STRING-CONST-TAG)
               emit(tgt-DefLong(to-long(n)))
               emit(tgt-DefString(v))
            (v:Symbol) :
               val chars = to-string(v)
               val n = length(chars)
               emit-tag(SYMBOL-CONST-TAG)
               emit(tgt-DefLong(to-long(n)))
               emit(tgt-DefString(chars))
            (v:List) :
               emit-tag(LIST-CONST-TAG)
               emit(tgt-DefInt(length(v)))
               do(emit-const, v)
            (v:True) :
               emit-tag(TRUE-CONST-TAG)
            (v:False) :
               emit-tag(FALSE-CONST-TAG)
            (v:KTypeObject) :
               emit-tag(TYPE-CONST-TAG)
               emit(tgt-DefLabel(n(v)))
            (v:KClosure) :
               emit-tag(FN-CONST-TAG)
               emit(tgt-DefLabel(n(v)))
            (v) :
               fatal("Unrecognized constant: %~" % [v])

      ;Collect all constants
      val consts = Vector<?>()
      for n in global-consts(gt) do :
         add(consts, value(gt[n] as GConst))

      ;Emit constant table
      emit(tgt-DefData())
      emit(tgt-TLabel(CONSTANT-TABLE-LBL))
      emit(tgt-DefInt(length(consts)))
      do(emit-const, consts)
      emit(tgt-DefText())

   ;     Compiling Entry Function
   ;     ========================
   defn compile-entry () :
      val var-table = VarTable()
      val ins-vector = Vector<tgt-Ins>()
      let-var INSTRUCTION-VECTOR = ins-vector :
         let-var VAR-TABLE = var-table :
            args(List())
            for c in comms(prog) do :
               match(c) :
                  (c:KDef) :
                     val exp = KSet(n(c), value(c), false)
                     compile-exp(exp, IgnoreLink())
                  (c:KDefVar) :
                     if value(c) is-not False :
                        val exp = KSet(n(c), value(c) as KExp, false)
                        compile-exp(exp, IgnoreLink())
                  (c:KInit) :
                     compile-exp(exp(c), IgnoreLink())
                  (c:KLSDef) :
                     val comm = KLSSet(Value(KLSVar(n(c))), value(c))
                     compile-comm(comm)
                  (c:KLSDefVar) :
                     if value(c) is-not False :
                        val comm = KLSSet(Value(KLSVar(n(c))), value(c) as KLSExp)
                        compile-comm(comm)
                  (c:KLSInit) :
                     compile-comm(comm(c))
                  (c) : false
            return(List(long(0)))
            val n = fresh-id()
            emit(tgt-DefFn(n, defs(var-table), ins-vector))
            n

   ;     Compiling a HiStanza Function
   ;     =============================
   defn compile-func (c:KDefn) :
      defn compile-codes (inf:False|FileInfo, codes:List<KCode>) :
         compile-function{inf, n(c), _} $ fn* (compile-prelude) :
            for code in codes do :
               ;Check arity
               val failL = fresh-id()
               jarity-neq(failL, arity(code))
               ;Define arguments
               val vs = map(make-ref{}, args(code))
               for (a in args(code), v in vs) do :
                  VAR-TABLE!()[a] = List(v)
               ;Compile prelude
               compile-prelude(vs)
               ;Compile body
               compile-exp(body(code), ReturnLink())
               ;Failed arity check
               tlabel(failL)

            ;Arity Error
            compile-prelude(List())
            call(inf, 0, List(), mem(ARITY-ERROR-ID), List())
            return(List())

      ;Dispatch based on arity of function
      match(value(c)) :
         (code:KCode) : compile-codes(info(code), List(code))
         (code:KMultifn) : compile-codes(info(code), funcs(code) as List<KCode>)

   ;     Compiling a Type Object
   ;     =======================
   defn compile-type-object (c:KDefTypeObject) :
      compile-function{false, n(c), _} $ fn* (compile-prelude) :
         ;Compile prelude
         val t = make-ref()
         val x = make-ref()
         compile-prelude(List(t, x))

         ;Retrieve closed over type variables
         for (a in args(c), i in 0 to false) do :
            val v = make-ref()
            VAR-TABLE!()[a] = List(v)
            load(v, t, 8 + 8 + (8 * i) - REF-TAG-BITS) ;TAG, CODE, TARGS ...

         ;Compile body
         match(cast-type(tt, type(c))) :
            (t:KTop) :
               return(List(long(1)))
            (t) :
               val safeL = fresh-id()
               val failL = fresh-id()
               compile-is(x, t, safeL, failL)
               tlabel(safeL)
               return(List(long(1)))
               tlabel(failL)
               return(List(long(0)))

   ;     Compiling Is Operator
   ;     =====================
   defn compile-is (x:tgt-Imm, t:KType, true-lbl:Int, false-lbl:Int) :
      ;t must be a cast-type
      defn* loop (t:KType, true-lbl:Int, false-lbl:Int) :
         match(t) :
            (t:KAnd) :
               val next-lbl = fresh-id()
               loop(a(t), next-lbl, false-lbl)
               tlabel(next-lbl)
               loop(b(t), true-lbl, false-lbl)
            (t:KOr) :
               val next-lbl = fresh-id()
               loop(a(t), true-lbl, next-lbl)
               tlabel(next-lbl)
               loop(b(t), true-lbl, false-lbl)
            (t:KTop) :
               goto(true-lbl)
            (t:KTags) :
               compile-dispatch(false, List(t, KTop()), x, List(true-lbl, false-lbl))
            (t:KTVar) :
               val code = make-long()
               val r = make-long()
               val obj = head(VAR-TABLE!()[n(t)])
               load(code, obj, 8 - REF-TAG-BITS)
               call(false, 1, List(r), code, List(obj, x))
               jeq(false-lbl, r, long(0))
               goto(true-lbl)
      loop(t, true-lbl, false-lbl)

   ;     Compiling a Trie
   ;     ================
   defn jump-member (lbl:Int, x:tgt-Imm, ns:List<Int>) :
      fatal("Empty labels") when empty?(ns)

      defn jump-bit-set (low:Int, word:Long) :
         ;Range check
         val fail-lbl = fresh-id()
         val y = make-long()
         sub(y, x, long(low))
         juge(fail-lbl, y, long(64))

         ;Compute bit index
         val bit-idx = make-long()
         bit-and(bit-idx, y, long(63))

         ;Extract bit
         val bit = make-long()
         shr(bit, long(word), bit-idx)
         bit-and(bit, bit, long(1))
         jeq(lbl, bit, long(1))

         ;Failure label
         tlabel(fail-lbl)

      val sorted-ns = to-array<Int>(ns)
      qsort!(sorted-ns)

      defn jump-member (start:Int, num:Int) :
         if num <= 3 :
            for i in 0 to num do :
               jeq(lbl, x, long(sorted-ns[start + i]))
         else :
            var word:Long = to-long(0)
            val low = sorted-ns[start]
            for i in 0 to num do :
               val bit = sorted-ns[start + i] - low
               word = bit-or(word, to-long(1) << to-long(bit))
            jump-bit-set(low, word)

      defn loop (start:Int, low:Int) :
         match(find({sorted-ns[_] >= low + 64}, (start + 1) to length(sorted-ns))) :
            (i:Int) :
               jump-member(start, i - start)
               loop(i, sorted-ns[i])
            (i:False) :
               jump-member(start, length(sorted-ns) - start)

      loop(0, sorted-ns[0])

   ;Group all keys with the same value in hashtable
   defn group-keys (t:HashTable<Int,Int>) :
      val ret = HashTable<Int,List<Int>>()
      for entry in t do :
         val [k,v] = [key(entry), value(entry)]
         ret[v] = cons(k, get?(ret, v, List()))
      ret

   ;Compile a single dispatch
   defn compile-dispatch (info:False|FileInfo, types:List<KType>, x:tgt-Imm, lbls:List<Int>) :
      val prim-lbls = HashTable<Int,Int>()
      val mark-lbls = HashTable<Int,Int>()
      val ref-lbls = HashTable<Int,Int>()
      var default-lbl = fresh-id()
      var default? = false

      ;Update table
      defn update (table:HashTable<Int,Int>, k:Int, v:Int) :
         if not key?(table, k) : table[k] = v

      ;Classify types
      for (t in types, l in lbls) do :
         match(t) :
            (t:KTags) :
               for tag in tags(t) do :
                  update{_, tag, l} $
                     if primitive?(tt, tag) : prim-lbls
                     else if marker?(tt, tag) : mark-lbls
                     else : ref-lbls
            (t:KTop) :
               if default? is False :
                  default-lbl = l
                  default? = true

      ;Convert type to bit tag
      defn prim-bit-tag (n:Int) :
         switch {n == _} :
            BYTE-TYPE-ID : long(BYTE-TAG-BITS)
            CHAR-TYPE-ID : long(CHAR-TAG-BITS)
            INT-TYPE-ID : long(INT-TAG-BITS)
            FLOAT-TYPE-ID : long(FLOAT-TAG-BITS)
            else : fatal("Not a primitive: %~" % [n])

      ;Primitive Dispatch
      val ptag = make-long()
      bit-and(ptag, x, long(7))
      for entry in prim-lbls do :
         jeq(value(entry), ptag, prim-bit-tag(key(entry)))

      ;Marker Dispatch
      val not-markerL = fresh-id()
      jne(not-markerL, ptag, long(MARKER-TAG-BITS))
      val grouped-marks = group-keys(mark-lbls)
      val mark-tag = make-long()
      shr(mark-tag, x, long(3))
      for entry in grouped-marks do :
         val tags = map(tag{tt, _}, value(entry))
         jump-member(key(entry), mark-tag, tags)
      goto(default-lbl)
      tlabel(not-markerL)

      ;Reference Dispatch
      val not-refL = fresh-id()
      jne(not-refL, ptag, long(REF-TAG-BITS))
      val classtag = make-long()
      load(classtag, x, 0 - REF-TAG-BITS)
      shr(classtag, classtag, long(3))
      val grouped-refs = group-keys(ref-lbls)
      for entry in grouped-refs do :
         val tags = map(tag{tt, _}, value(entry))
         jump-member(key(entry), classtag, tags)
      tlabel(not-refL)

      ;Emit Default Branch if there is one
      if default? :
         goto(default-lbl)
      else :
         tlabel(default-lbl)
         call(info, 0, List(), mem(NO-BRANCH-ERROR-ID), List())

   ;Compile a dispatch tree
   defn compile-trie (info:False|FileInfo, tries:List<MTrie>, args:List<tgt-Imm>) :
      val [x, rest] = [head(args), tail(args)]
      if empty?(rest) :
         val tries = tries as List<TrieEnd>
         compile-dispatch(info, map(type, tries), x, map(lbl, tries))
      else :
         val tries = tries as List<TrieArg>
         val lbls = map(fresh-id{}, tries)
         compile-dispatch(info, map(type, tries), x, lbls)
         for (lbl in lbls, trie in tries) do :
            tlabel(lbl)
            compile-trie(info, children(trie), tail(args))

   ;     Compiling a Function
   ;     ====================
   defn compile-function (info:False|FileInfo, n:Int, compile-body: (List<tgt-Var> -> False) -> ?) :
      if flag-defined?(`VERBOSE) :
         println("KForm compiling function: %~" % [n])
      val var-table = VarTable()
      val ins-vector = Vector<tgt-Ins>()
      let-var INSTRUCTION-VECTOR = ins-vector :
         let-var VAR-TABLE = var-table :
            defn compile-prelude (vs:List<tgt-Var>) :
               ;No stack extension
               ;args(vs)

               ;Automatic stack extension
               val defaultL = fresh-id()
               val bodyL = fresh-id()
               val num-free = make-long()
               jstack-has-space(defaultL)
               switch-stack()
               args(vs)
               load(num-free, mem(NUM-FREE-STACKS-LBL), 0)
               jgt(bodyL, num-free, long(2)) ;Running GC requires two stacks (One for GC, one for handling stack overflow)
               call(info, 0, List(), mem(EXTEND-STACK-ID), List())
               goto(bodyL)
               tlabel(defaultL)
               args(vs)
               tlabel(bodyL)

            ;Compile function body
            compile-body(compile-prelude)

            ;Emit function definition
            emit(tgt-DefFn(n, defs(var-table), ins-vector))


   ;     Allocating Objects
   ;     ==================
   defn make-object (info:False|FileInfo, x:tgt-Var, n:Int, args:List<tgt-Imm>) :
      ;Increment heap
      val sz = 8 + 8 * length(args)
      extend-heap(info, sz)
      add(x, heap-ptr(), long(REF-TAG-BITS))
      inc-heap-ptr(sz)
      ;Store into heap
      val tagword = tag-as-tag(tag(tt, n))
      store(x, long(tagword), (- REF-TAG-BITS))
      for (i in 0 to false, v in args) do :
         store(x, v, 8 + (8 * i) - REF-TAG-BITS)

   defn store-array-object (x:tgt-Var, n:Int, len:Int, args:List<tgt-Imm>) :
      ;Store length word
      val lenword = tag-as-header(len)
      store(x, long(lenword), -8 - REF-TAG-BITS)
      ;Store tag word
      val tagword = tag-as-tag(tag(tt, n))
      store(x, long(tagword), 0 - REF-TAG-BITS)
      ;Store items
      for (i in 0 to false, v in args) do :
         store(x, v, 8 + (8 * i) - REF-TAG-BITS)

   defn make-array-object (info:False|FileInfo, x:tgt-Var, n:Int, len:Int, args:List<tgt-Imm>) :
      ;Increment heap; [Len, Tag, Args ...]
      val sz = 8 + 8 + 8 * length(args)
      extend-heap(info, sz)
      add(x, heap-ptr(), long(8 + REF-TAG-BITS))
      inc-heap-ptr(sz)
      ;Store object
      store-array-object(x, n, len, args)


   ;     Compiling a Stanza Expression
   ;     =============================
   defn compile-exp (e:KExp, link:Linkage) -> False :
      defn ret-imm (x:tgt-Imm) :
         match(link) :
            (link:ReturnLink) : return(List(x))
            (link:IgnoreLink) : false
            (link:AssignLink) : set(loc(link), x)
      defn ret-var (f: tgt-Var -> False) :
         match(link) :
            (link:ReturnLink) :
               val v = make-ref()
               f(v)
               return(List(v))
            (link:IgnoreLink) : f(make-ref())
            (link:AssignLink) : f(loc(link))
      defn compile-arg (e:KExp) :
         val x = make-ref()
         compile-exp(e, AssignLink(x))
         x

      match(e) :
         (e:KSet) :
            if global-var?(gt, n(e)) :
               store(global-mem(n(e)), compile-arg(value(e)), 0)
            else :
               val x = head(env-vars(n(e)))
               compile-exp(value(e), AssignLink(x))
            ret-imm(long(tag-as-marker(tag(tt, FALSE-TYPE-ID))))
         (e:KCast) :
            if flag-defined?(`OPTIMIZE) :
               ret-imm(compile-arg(exp(e)))
            else :
               match(cast-type(tt, targ(e))) :
                  (t:KTop) :
                     ret-imm(compile-arg(exp(e)))
                  (t) :
                     val safeL = fresh-id()
                     val failL = fresh-id()
                     val x = compile-arg(exp(e))
                     compile-is(x, t, safeL, failL)
                     tlabel(failL)
                     call(info(e), 0, List(), mem(CAST-ERROR-ID), List())
                     tlabel(safeL)
                     ret-imm(x)
         (e:KCheckVoid) :
            val safeL = fresh-id()
            val e* = compile-arg(exp(e))
            jne(safeL, e*, long(VOID-TAG))
            call(info(e), 0, List(), mem(VARIABLE-UNINITIALIZED-ERROR-ID), List())
            tlabel(safeL)
            ret-imm(e*)
         (e:KCheckLength) :
            val safeL = fresh-id()
            val e* = compile-arg(exp(e))
            val len = make-long()
            load(len, e*, -8 - REF-TAG-BITS)
            jeq(safeL, len, long(tag-as-header(length(e))))
            call(info(e), 0, List(), mem(TUPLE-LENGTH-ERROR-ID), List())
            tlabel(safeL)
            ret-imm(e*)
         (e:KLet) :
            val def = def(e) as KDef
            val [n, v] = [n(def), value(def)]
            VAR-TABLE!()[n] = List(compile-arg(v))
            compile-exp(body(e), link)
         (e:KLetRec) :
            ;Create variables representing closures
            val defs = defs(e) as List<KDef>
            val xs = map(make-ref{}, defs)
            ;Register variables in environment
            val ns = map(n, defs)
            for (n in ns, x in xs) do :
               VAR-TABLE!()[n] = List(x)
            ;Compile closure arguments
            val clos = map({value(_) as KClosure}, defs)
            val clo-args = for c in clos map :
               for a in args(c) map :
                  match(a) :
                     (a:KVar) :
                        if contains?(ns, n(a)) : head(VAR-TABLE!()[n(a)])
                        else : compile-arg(a)
                     (a) : compile-arg(a)
            ;Increment heap
            val szs = for c in clos map :
               ;[Len, Tag, Code, Free ...]
               8 + 8 + 8 + 8 * length(args(c))
            val sz = sum(szs)
            extend-heap(info(e), sz)
            ;Get pointers to closures
            var accum = 0
            for (x in xs, s in szs) do :
               add(x, heap-ptr(), long(accum + 8 + REF-TAG-BITS))
               accum = accum + s
            inc-heap-ptr(sz)
            ;Store closures
            for (x in xs, c in clos, args in clo-args) do :
               val code = mem(n(c))
               val len = length(args)
               store-array-object(x, FN-TYPE-ID, len, cons(code, args))
            ;Compile body
            compile-exp(body(e), link)
         (e:KLetLoop) :
            val vs = map(make-ref{}, args(e))
            for (a in args(e), v in vs) do :
               VAR-TABLE!()[a] = List(v)
            loop-table[n(e)] = vs
            for (v in vs, a in arg-values(e)) do :
               compile-exp(a, AssignLink(v))
            tlabel(n(e))
            compile-exp(body(e), link)
         (e:KGoto) :
            val loop-id = n(loop(e) as KVar)
            val args* = map(compile-arg, args(e))
            do(set, loop-table[loop-id], args*)
            goto(loop-id)
            ret-imm(long(0))
         (e:KSeq) :
            compile-exp(a(e), IgnoreLink())
            compile-exp(b(e), link)
         (e:KMatch) :
            ;Compile arguments
            val vs = map(compile-arg, args(e))
            ;Compile dispatch
            val lbls = map(fresh-id{}, branches(e))
            val branch-types = for b in branches(e) map :
               map(dispatch-type{tt, _}, types(b))
            compile-trie(info(e), to-trie(branch-types, lbls), vs)
            ;Compile branches
            val endL = fresh-id()
            for (lbl in lbls, b in branches(e)) do :
               tlabel(lbl)
               for (n in args(b), v in vs) do :
                  val v* = make-ref()
                  VAR-TABLE!()[n] = List(v*)
                  set(v*, v)
               compile-exp(body(b), link)
               goto(endL)
            tlabel(endL)
         (e:KDispatch) :
            compile-exp(convert-dispatch(tt, e), link)
         (e:KObject) :
            if marker?(tt, n(e)) :
               val mark = tag-as-marker(tag(tt, n(e)))
               ret-imm(long(mark))
            else :
               val vs = map(compile-arg, args(e))
               ret-var $ fn (x) :
                  make-object(info(e), x, n(e), vs)
         (e:KObjectGet) :
            ret-var $ fn (x) :
               val o = compile-arg(object(e))
               load(x, o, 8 + 8 * index(e) - REF-TAG-BITS)
         (e:KTypeObject) :
            ret-var $ fn (x) :
               val code = mem(n(e))
               val vs = map(compile-arg, args(e))
               val len = length(args(e))
               make-array-object(info(e), x, TYPE-TYPE-ID, len, cons(code,vs))
         (e:KPrim) :
            ret-var $ fn (x) :
               defn detag (x:tgt-Imm) :
                  val x* = make-var(tgt-LONG-TYPE)
                  binop(x*, tgt-ASHR-OP, x, long(32))
                  x*

               defn cmp-op (op:tgt-TgtOp, y:tgt-Imm, z:tgt-Imm) :
                  val x* = make-var(tgt-LONG-TYPE)
                  binop(x*, op, y, z)
                  binop(x*, tgt-SHL-OP, x*, long(3))
                  binop(x, tgt-ADD-OP, x*, long(MARKER-TAG-BITS))

               defn tag-as-char (x:tgt-Var, c:tgt-Imm) :
                  val l = make-long()
                  conv(l, c)
                  binop(l, tgt-SHL-OP, l, long(3))
                  binop(x, tgt-ADD-OP, l, long(CHAR-TAG-BITS))
                  
               defn detag-char (c:tgt-Imm) :
                  val l = make-long()
                  val b = make-var(tgt-BYTE-TYPE)
                  binop(l, tgt-SHR-OP, c, long(3))
                  conv(b, l)
                  b

               if length(args(e)) == 3 :
                  val y = compile-arg(args(e)[0])
                  val z = compile-arg(args(e)[1])
                  val w = compile-arg(args(e)[2])
                  switch {op(e) == _} :
                     ASET-OP :
                        val o = make-long()
                        binop(o, tgt-ASHR-OP, z, long(32 - 3))
                        binop(o, tgt-ADD-OP, o, y)
                        store(o, w, 8 + 8 - REF-TAG-BITS)                        
                        set(x, long(tag-as-marker(tag(tt, FALSE-TYPE-ID))))
                     CHAR-ASET-OP :   
                        val o = make-long()
                        binop(o, tgt-ASHR-OP, z, long(32))
                        binop(o, tgt-ADD-OP, o, y)
                        store(o, detag-char(w), 8 + 8 - REF-TAG-BITS)
                        set(x, long(tag-as-marker(tag(tt, FALSE-TYPE-ID))))
               else if length(args(e)) == 2 :
                  val y = compile-arg(args(e)[0])
                  val z = compile-arg(args(e)[1])
                  switch {op(e) == _} :
                     INT-ADD-OP :
                        binop(x, tgt-ADD-OP, y, z)
                     INT-SUB-OP :
                        binop(x, tgt-SUB-OP, y, z)
                     INT-MUL-OP :
                        binop(x, tgt-MUL-OP, detag(y), z)
                     INT-DIV-OP :
                        val x* = make-long()
                        binop(x*, tgt-DIV-OP, y, z)
                        binop(x, tgt-SHL-OP, x*, long(32))
                     INT-MOD-OP :
                        binop(x, tgt-MOD-OP, y, z)
                     INT-AND-OP :
                        binop(x, tgt-AND-OP, y, z)
                     INT-OR-OP :
                        binop(x, tgt-OR-OP, y, z)
                     INT-XOR-OP :
                        binop(x, tgt-XOR-OP, y, z)
                     INT-SHL-OP :
                        binop(x, tgt-SHL-OP, y, detag(z))
                     INT-SHR-OP :
                        val x* = make-long()
                        binop(x*, tgt-SHR-OP, y, detag(z))
                        binop(x*, tgt-SHR-OP, x*, long(32))
                        binop(x, tgt-SHL-OP, x*, long(32))
                     INT-ASHR-OP :
                        val x* = make-long()
                        binop(x*, tgt-ASHR-OP, y, detag(z))
                        binop(x*, tgt-SHR-OP, x*, long(32))
                        binop(x, tgt-SHL-OP, x*, long(32))
                     INT-EQ-OP :
                        cmp-op(tgt-EQ-OP, y, z)
                     INT-NE-OP :
                        cmp-op(tgt-NE-OP, y, z)
                     INT-LE-OP :
                        cmp-op(tgt-LE-OP, y, z)
                     INT-LT-OP :
                        cmp-op(tgt-LT-OP, y, z)
                     INT-GT-OP :
                        cmp-op(tgt-GT-OP, y, z)
                     INT-GE-OP :
                        cmp-op(tgt-GE-OP, y, z)
                     IDENTICAL-OP :
                        cmp-op(tgt-EQ-OP, y, z)
                     AGET-OP :
                        val o = make-long()
                        binop(o, tgt-ASHR-OP, z, long(32 - 3))
                        binop(o, tgt-ADD-OP, o, y)
                        load(x, o, 8 + 8 - REF-TAG-BITS)
                     CHAR-AGET-OP :   
                        val o = make-long()
                        val c = make-var(tgt-BYTE-TYPE)
                        binop(o, tgt-ASHR-OP, z, long(32))
                        binop(o, tgt-ADD-OP, o, y)
                        load(c, o, 8 + 8 - REF-TAG-BITS)
                        tag-as-char(x, c)
                     STRING-GET-OP :   
                        val o = make-long()
                        val c = make-var(tgt-BYTE-TYPE)
                        binop(o, tgt-ASHR-OP, z, long(32))
                        binop(o, tgt-ADD-OP, o, y)
                        load(c, o, 8 + 8 + 4 - REF-TAG-BITS)
                        tag-as-char(x, c)
                     else :
                        fatal("Unsupported binop: %~" % [op(e)])
               else if length(args(e)) == 1 :
                  val y = compile-arg(args(e)[0])
                  switch {op(e) == _} :
                     INT-NOT-OP :
                        val x* = make-long()
                        unaop(x*, tgt-NOT-OP, y)
                        binop(x*, tgt-SHR-OP, x*, long(32))
                        binop(x, tgt-SHL-OP, x*, long(32))
                     INT-NEG-OP :
                        unaop(x, tgt-NEG-OP, y)
                     ALEN-OP :
                        val x* = make-long()
                        load(x*, y, 8 - REF-TAG-BITS)
                        binop(x, tgt-SHL-OP, x*, long(32))
                     STRING-LEN-OP :
                        val x* = make-long()
                        load(x*, y, 8 - REF-TAG-BITS)
                        binop(x, tgt-SHL-OP, x*, long(32))
               else :
                  fatal("Unsupported op: %~" % [op(e)])
         (e:KCall) :
            if tail?(e) and link is-not ReturnLink :
               fatal("Tail expression without return link")
            match(link) :
               (link:ReturnLink) :
                  val ys = map(compile-arg, args(e))
                  tcall(arity(e), global-mem(func(e)), ys)
               (link:IgnoreLink) :
                  val ys = map(compile-arg, args(e))
                  call(info(e), arity(e), List(), global-mem(func(e)), ys)               
               (link) :
                  ret-var $ fn (x) :
                     val ys = map(compile-arg, args(e))
                     call(info(e), arity(e), List(x), global-mem(func(e)), ys)
         (e:KCallDeref) :
            if tail?(e) and link is-not ReturnLink :
               fatal("Tail expression without return link")
            match(link) :
               (link:ReturnLink) :
                  val ys = map(compile-arg, args(e))
                  val code = make-long()
                  val c = compile-arg(func(e))
                  load(code, c, 8 - REF-TAG-BITS)
                  tcall(arity(e), code, cons(c, ys))
               (link:IgnoreLink) :
                  val ys = map(compile-arg, args(e))
                  val code = make-long()
                  val c = compile-arg(func(e))
                  load(code, c, 8 - REF-TAG-BITS)
                  call(info(e), arity(e), List(), code, cons(c, ys))               
               (link) :
                  ret-var $ fn (x) :
                     val ys = map(compile-arg, args(e))
                     val code = make-long()
                     val c = compile-arg(func(e))
                     load(code, c, 8 - REF-TAG-BITS)
                     call(info(e), arity(e), List(x), code, cons(c, ys))

         (e:KVar) :
            if global-var?(gt, n(e)) :
               ret-var $ fn (x) :
                  load(x, global-mem(n(e)), 0)
            else :
               val vs = VAR-TABLE!()[n(e)]
               ret-imm(head(vs))
         (e:KLiteral) :
            match(value(e)) :
               (v:Byte) : ret-imm(int(tag-as-byte(v)))
               (v:Char) : ret-imm(int(tag-as-char(v)))
               (v:Int) : ret-imm(long(tag-as-int(v)))
               (v:Float) : ret-imm(long(tag-as-float(v)))
               (v:True) : ret-imm(long(tag-as-marker(tag(tt, TRUE-TYPE-ID))))
               (v:False) : ret-imm(long(tag-as-marker(tag(tt, FALSE-TYPE-ID))))
               (v) : fatal("Unsupported literal: %~" % [v])
         (e:KTuple) :
            ret-var $ fn (x) :
               val vs = map(compile-arg, exps(e))
               val len = length(exps(e))
               make-array-object(info(e), x, TUPLE-TYPE-ID, len, cons(long(len), vs))
         (e:KTupleGet) :
            ret-var $ fn (x) :
               val t = compile-arg(exp(e))
               load(x, t, 8 + 8 + 8 * index(e) - REF-TAG-BITS)
         (e:KBox) :
            ret-var $ fn (x) :
               match(value(e)) :
                  (v:KExp) :
                     val v* = compile-arg(v)
                     make-object(false, x, BOX-TYPE-ID, List(v*))
                  (v:False) :
                     make-object(false, x, BOX-TYPE-ID, List(long(VOID-TAG)))
         (e:KBoxGet) :
            ret-var $ fn (x) :
               val b = compile-arg(box(e))
               load(x, b, 8 - REF-TAG-BITS)
         (e:KBoxSet) :
            val b = compile-arg(box(e))
            val v = compile-arg(value(e))
            store(b, v, 8 - REF-TAG-BITS)
            ret-imm(long(tag-as-marker(tag(tt, FALSE-TYPE-ID))))
         (e:KClosure) :
            ret-var $ fn (x) :
               val code = mem(n(e))
               val vs = map(compile-arg, args(e))
               val len = length(args(e))
               make-array-object(info(e), x, FN-TYPE-ID, len, cons(code,vs))
         (e:KClosureGet) :
            ret-var $ fn (x) :
               val c = compile-arg(exp(e))
               load(x, c, 8 + 8 + 8 * index(e) - REF-TAG-BITS)
         (e:KBranchError) :
            val err = if amb?(e) : AMB-BRANCH-ERROR-ID
                      else : NO-BRANCH-ERROR-ID
            call(info(e), 0, List(), mem(err), List())
            ret-imm(long(0))
         (e) :
            fatal("Unsupported expression: %~" % [e])

   ;     Compiling a LoStanza Function
   ;     =============================
   defn compile-ls-func (c:KLSDefCode) :
      compile-function{info(c), n(c), _} $ fn* (compile-prelude) :
         ;Create argument variables
         val arg-vs = Vector<tgt-Var>()
         for (a in args(c), t in types(c)) do :
            val vs = make-vars(expand(tt, t))
            VAR-TABLE!()[a] = vs
            do(add{arg-vs, _}, vs)
         ;Compile the prelude
         compile-prelude(to-list(arg-vs))
         ;Compile the body
         compile-comm(body(c))

   ;     Compile a LoStanza Location
   ;     ===========================
   defn compile-loc (loc:KLoc) :
      defn loc-type (l:KLoc) :
         match(l) :
            (l:Value) :
               if global-var?(gt, exp(l)) :
                  val v = exp(l) as KLSVar
                  global-var-type(gt, n(v))
            (l:Deref|Deptr|Slot) : type(l)
            (l:stz/kl-ir/Field) : field-type(tt, n(l))

      defn* loop (l:KLoc, off:Int, idx:Int) :
         match(l) :
            (l:Value) :
               if global-var?(gt, exp(l)) :
                  val n = n(exp(l) as KLSVar)
                  PtrLoc(global-mem(n,off), 0, loc-type(loc) as KLSType)
               else :
                  match(loc-type(loc)) :
                     (t:KLSType) : SubExpLoc(exp(l), idx, count(tt, t), t)
                     (t:False) : ExpLoc(exp(l))
            (l:Deref) :
               val p = head(compile-arg(exp(l)))
               PtrLoc(p, off + 8 - REF-TAG-BITS, loc-type(loc) as KLSType)
            (l:Deptr) :
               val p = head(compile-arg(exp(l)))
               PtrLoc(p, off, loc-type(loc) as KLSType)
            (l:Slot) :
               val b = head(compile-arg(exp(l)))
               val i = head(compile-arg(index(l)))
               val p = make-var(tgt-LONG-TYPE)
               mul(p, long(size(tt, type(l))), i)
               add(p, p, b)
               PtrLoc(p, off, loc-type(loc) as KLSType)
            (l:stz/kl-ir/Field) :
               loop(base(l),
                    off + field-offset(tt, n(l)),
                    idx + field-index(tt, n(l)))
      loop(loc, 0, 0)


   ;     Compile a LoStanza Command
   ;     ==========================
   defn compile-comm (c:KLSComm) :
      match(c) :
         (c:KLSIgnoreComm) :
            compile-exp(exp(c), LSIgnoreLink())
         (c:KLSSet) :
            defn n! (e:KLSExp) : n(e as KLSVar)
            match(compile-loc(exp(c))) :
               (loc:PtrLoc) :
                  val ys = compile-arg(value(c))
                  for (o in offsets(tt, type(loc)), y in ys) do :
                     store(base(loc), y, offset(loc) + o)
               (loc:SubExpLoc) :
                  val xs = env-vars(n!(exp(loc)))
                  val sub-xs = sublist(xs, index(loc), count(loc))
                  compile-exp(value(c), LSAssignLink(sub-xs))
               (loc:ExpLoc) :
                  val xs = env-vars(n!(exp(loc)))
                  compile-exp(value(c), LSAssignLink(xs))
         (c:KLSLabel) :
            tlabel(n(c))
         (c:KLSGoto) :
            goto(n(c))
         (c:KLSReturn) :
            match(exp(c)) :
               (exp:KLSWCall|KLSWCallDeptr|KLSWCallDeref|KLSWSwitchStack) :
                  if tail?(exp) : compile-tail-exp(exp)
                  else : compile-exp(exp, LSReturnLink())
               (exp) : compile-exp(exp, LSReturnLink())
         (c:KLSDefLocal) :
            val r = compile-exp(value(c), LSArgLink()) as CResult
            val vs* = map(make-var, types(r))
            VAR-TABLE!()[n(c)] = vs*
            do(set, vs*, imms(r))
         (c:KLSDefLocalVar) :
            match(value(c)) :
               (v:KLSExp) :
                  compile-comm(KLSDefLocal(n(c), v))
               (v:False) :
                  val ts = expand(tt, type(c))
                  val vs = make-vars(ts)
                  for (v in vs, t in ts) do :
                     switch {t == _} :
                        tgt-BYTE-TYPE : set(v, byte(0))
                        tgt-INT-TYPE : set(v, int(0))
                        tgt-LONG-TYPE : set(v, long(0))
                        tgt-FLOAT-TYPE : load(v, mem(FLOAT-ZERO-LBL), 0)
                        tgt-DOUBLE-TYPE : load(v, mem(DOUBLE-ZERO-LBL), 0)
                        tgt-REF-TYPE : set(v, long(VOID-TAG))
                  VAR-TABLE!()[n(c)] = vs
         (c:KLSIf) :
            val altL = fresh-id()
            val endL = fresh-id()
            val p = head(compile-arg(pred(c)))
            jeq(altL, p, long(0))
            compile-comm(conseq(c))
            goto(endL)
            tlabel(altL)
            compile-comm(alt(c))
            tlabel(endL)
         (c:KLSSeq) :
            compile-comm(a(c))
            compile-comm(b(c))
         (c:KLSMatch) :
            ;Compile arguments
            val vs = seq-append(compile-arg, args(c))
            ;Compile dispatch
            val lbls = map(fresh-id{}, branches(c))
            val branch-types = for b in branches(c) map :
               map(dispatch-type{tt, _}, types(b))
            compile-trie(info(c), to-trie(branch-types, lbls), vs)
            ;Compile branches
            val endL = fresh-id()
            for (lbl in lbls, b in branches(c)) do :
               tlabel(lbl)
               for (n in args(b), v in vs) do :
                  val v* = make-ref()
                  VAR-TABLE!()[n] = List(v*)
                  set(v*, v)
               compile-comm(body(b))
               goto(endL)
            tlabel(endL)
         (c:KLSDispatch) :
            compile-comm(convert-ls-dispatch(tt, c))
         (c:KLSSkip) :
            false
         (c:KLSBranchError) :
            val err = if amb?(c) : AMB-BRANCH-ERROR-ID
                      else : NO-BRANCH-ERROR-ID
            call(info(c), 0, List(), mem(err), List())

   ;     Compile an Expression
   ;     =====================
   defn compile-arg (e:KLSExp) -> List<tgt-Imm> :
      imms(compile-exp(e, LSArgLink()) as CResult)

   defn compile-exp (e:KLSExp, link:LSLinkage) -> False|CResult :
      defn ret-imms (ts:List<tgt-TgtType>, xs:List<tgt-Imm>) :
         match(link) :
            (link:LSReturnLink) : return(xs)
            (link:LSIgnoreLink) : false
            (link:LSAssignLink) : do(set, locs(link), xs)
            (link:LSArgLink) : CResult(ts, xs)
            
      defn ret-vars (ts:List<tgt-TgtType>, f: List<tgt-Var> -> False) :
         match(link) :
            (link:LSReturnLink) :
               val vs = map(make-var, ts)
               f(vs)
               return(vs)
            (link:LSIgnoreLink) : f(map(make-var, ts))
            (link:LSAssignLink) : f(locs(link))
            (link:LSArgLink) :
               val vs = map(make-var, ts)
               f(vs)
               CResult(ts, vs)

      defn ret-imms (t:KLSType, xs:List<tgt-Imm>) : ret-imms(expand(tt, t), xs)
      defn ret-imm (t:tgt-TgtType, x:tgt-Imm) : ret-imms(List(t), List(x))
      defn ret-vars (t:KLSType, f: List<tgt-Var> -> False) : ret-vars(expand(tt, t), f)
      defn ret-var (t:tgt-TgtType, f:tgt-Var -> False) : ret-vars(List(t), f{head(_)})
      defn ret-ref (f:tgt-Var -> False) : ret-var(tgt-REF-TYPE, f)
      defn ret-long (f:tgt-Var -> False) : ret-var(tgt-LONG-TYPE, f)

      match(e) :
         (e:KLSVar) :
            if global-var?(gt, n(e)) :
               compile-exp(KLSRead(Value(e)), link)
            else :
               ret-imms(var-types(n(e)), env-vars(n(e)))
         (e:KLSLet) :
            compile-comm(comm(e))
            compile-exp(exp(e), link)
         (e:KLSRef) :
            if marker?(tt, n(e)) :
               val mark = tag-as-marker(tag(tt, n(e)))
               ret-imm(tgt-REF-TYPE, long(mark))
            else :
               ret-ref $ fn* (x) :
                  ;Compile arguments
                  val args = seq-append(compile-arg, args(e))
                  ;Extend heap
                  val st = KStructT(n(e))
                  val sz = 8 + ceil8(size(tt, st))
                  extend-heap(info(e), sz)
                  add(x, heap-ptr(), long(REF-TAG-BITS))
                  inc-heap-ptr(sz)
                  ;Store into heap
                  val tagword = tag-as-tag(tag(tt, n(e)))
                  store(x, long(tagword), (- REF-TAG-BITS))
                  for (o in offsets(tt, st), v in args) do :
                     store(x, v, o + 8 - REF-TAG-BITS)
         (e:KLSRefArray) :
            val st = KStructT(n(e))
            val rf = rfield(tt, n(e))
            val rft = field-type(tt, rf)
            ret-ref $ fn* (x) :
               ;     Compile length and arguments
               ;     ============================
               val len = head(compile-arg(length(e)))
               val args = seq-append(compile-arg, args(e))

               ;     Allocate on heap
               ;     ================
               val zeroL = fresh-id()
               val endL = fresh-id()
               ;Case: Length is not zero
               jeq(zeroL, len, long(0))
               let :
                  val sz = make-long()
                  mul(sz, long(size(tt, rft)), len)
                  add(sz, sz, long(8 + 8 + size(tt, st) + 7)) ;Len | Tag | Size | Items ...
                  bit-and(sz, sz, long(-8))
                  extend-heap(info(e), sz)
                  add(x, heap-ptr(), long(8 + REF-TAG-BITS))
                  inc-heap-ptr(sz)
                  goto(endL)
               ;Case : Length is zero
               tlabel(zeroL)
               let :
                  val sz = 8 + 8 + max(8, ceil8(size(tt, st)))
                  extend-heap(info(e), sz)
                  add(x, heap-ptr(), long(8 + REF-TAG-BITS))
                  inc-heap-ptr(sz)
                  tlabel(endL)

               ;     Store Object
               ;     ============
               ;Store length word
               val lenword = make-long()
               shl(lenword, len, long(3))
               add(lenword, lenword, long(HEADER-TAG-BITS))
               store(x, lenword, -8 - REF-TAG-BITS)
               ;Store tagword
               val tagword = tag-as-tag(tag(tt, n(e)))
               store(x, long(tagword), 0 - REF-TAG-BITS)
               ;Store items
               for (o in offsets(tt, st), v in args) do :
                  store(x, v, o + 8 - REF-TAG-BITS)
         (e:KLSStruct) :
            ;Compile arguments
            if length(args(e)) == 1 :
               compile-exp(head(args(e)), link)
            else :   
               ret-imms(KStructT(n(e)), seq-append(compile-arg, args(e)))
         (e:KLSPtr) :
            match(compile-loc(exp(e))) :
               (loc:PtrLoc) :
                  if offset(loc) == 0 :
                     ret-imm(tgt-LONG-TYPE, base(loc))
                  else :
                     ret-long $ fn* (x) :
                        add(x, base(loc), long(offset(loc)))
               (loc:SubExpLoc) :
                  val vs = env-vars(n(exp(loc) as KLSVar))
                  val v = head(tailn(vs, index(loc)))
                  ret-long $ fn* (x) :
                     addr(x, tgt-n(v))
               (loc:ExpLoc) :
                  val vs = env-vars(n(exp(loc) as KLSVar))
                  ret-long $ fn* (x) :
                     addr(x, tgt-n(head(vs)))
         (e:KLSRead) :
            match(compile-loc(exp(e))) :
               (loc:PtrLoc) :
                  ret-vars{type(loc), _} $ fn* (xs) :
                     for (x in xs, o in offsets(tt, type(loc))) do :
                        load(x, base(loc), offset(loc) + o)
               (loc:SubExpLoc) :
                  val xs = compile-arg(exp(loc))
                  val sub-xs = sublist(xs, index(loc), count(loc))
                  ret-imms(type(loc), sub-xs)
               (loc:ExpLoc) :
                  compile-exp(exp(loc), link)
         (e:KLSWCall) :
            ret-vars{type(e), _} $ fn* (xs) :
               val ys = seq-append(compile-arg, args(e))
               call(info(e), arity(e), xs, global-mem(func(e)), ys, new-stack?(e))
         (e:KLSWCallDeptr) :
            ret-vars{type(e), _} $ fn* (xs) :
               val ys = seq-append(compile-arg, args(e))
               val f = head(compile-arg(func(e)))
               call(info(e), arity(e), xs, f, ys, new-stack?(e))
         (e:KLSWCallDeref) :
            ret-vars{type(e), _} $ fn* (xs) :
               val ys = seq-append(compile-arg, args(e))
               val f = head(compile-arg(func(e)))
               val code = make-long()
               load(code, f, 8 - REF-TAG-BITS)
               call(info(e), arity(e), xs, code, cons(f, ys), new-stack?(e))
         (e:KLSWSwitchStack) :
            ret-vars{type(e), _} $ fn* (xs) :
               val ys = seq-append(compile-arg, args(e))
               val f = head(compile-arg(func(e)))
               callstack(info(e), xs, f, ys)
         (e:KLSWCallC) :
            ret-vars{type(e), _} $ fn* (xs) :
               val ys = seq-append(compile-arg, args(e))
               ffi-call(xs, global-mem(func(e)), ys)
         (e:KLSWCallCDeptr) :
            ret-vars{type(e), _} $ fn* (xs) :
               val ys = seq-append(compile-arg, args(e))
               val f = head(compile-arg(func(e)))
               ffi-call(xs, f, ys)
         (e:KLSSizeof) :
            ret-imm(tgt-LONG-TYPE, long(size(tt, type(e))))
         (e:KLSTagof) :
            ret-imm(tgt-LONG-TYPE, long(tag(tt, n(e))))
         (e:KLSConv) :
            ret-vars{type(e), _} $ fn* (xs) :
               val y = head(compile-arg(exp(e)))
               conv(head(xs), y)
         (e:KLSInterpret) :
            ret-vars{type(e), _} $ fn* (xs) :
               val y = head(compile-arg(exp(e)))
               interpret(head(xs), y)
         (e:KLSCast) :
            compile-exp(exp(e), link)
         (e:KLSTypeObject) :
            ret-ref $ fn* (x) :
               val code = mem(n(e))
               val vs = seq-append(compile-arg, args(e))
               val len = length(args(e))
               make-array-object(info(e), x, TYPE-TYPE-ID, len, cons(code,vs))
         (e:KLSPrim) :
            match(op(e)) :
               (op:GetAddrOp) :
                  ret-long $ fn* (x) :
                     addr(x, lbl(op))
               (op:GetterOp) :
                  ret-vars{type(e), _} $ fn* (xs) :
                     load(head(xs), mem(lbl(op)), 0)
               (op:SetterOp) :
                  val x = head(compile-arg(head(args(e))))
                  store(mem(lbl(op)), x, 0)
                  ret-imm(tgt-LONG-TYPE, long(0))
               (op) :
                  if op == SP-OP :
                     ret-vars{type(e), _} $ fn* (xs) :
                        set(head(xs), tgt-RSP())
                  else if length(args(e)) == 2 :
                     ret-vars{type(e), _} $ fn* (xs) :
                        val ys = seq-append(compile-arg, args(e))
                        binop(head(xs), to-tgt-op(op), ys[0], ys[1])
                  else if length(args(e)) == 1 :
                     ret-vars{type(e), _} $ fn* (xs) :
                        val ys = seq-append(compile-arg, args(e))
                        match(type(e)) :
                           (t:KByteT|KIntT|KLongT) :
                              unaop(head(xs), to-tgt-op(op), ys[0])
                           (t:KFloatT) :
                              val zero = make-var(tgt-FLOAT-TYPE)
                              conv(zero, int(0))
                              binop(head(xs), tgt-SUB-OP, zero, ys[0])
                           (t:KDoubleT) :
                              val zero = make-var(tgt-DOUBLE-TYPE)
                              conv(zero, int(0))
                              binop(head(xs), tgt-SUB-OP, zero, ys[0])
                  else :
                     fatal("Invalid primitive: %~" % [e])
         (e:KLSLitByte) :
            ret-imm(tgt-BYTE-TYPE, byte(value(e)))
         (e:KLSLitInt) :
            ret-imm(tgt-INT-TYPE, int(value(e)))
         (e:KLSLitLong) :
            ret-imm(tgt-LONG-TYPE, long(value(e)))
         (e:KLSLitFloat) :
            ret-var{tgt-FLOAT-TYPE, _} $ fn* (x) :
               interpret(x, int(bits(value(e))))
         (e:KLSLitDouble) :
            ret-var{tgt-DOUBLE-TYPE, _} $ fn* (x) :
               load(x, mem(double-lbl(value(e))), 0) ;TODO: Use bits directly.
         (e:KLSLitString) :
            ret-imm(tgt-LONG-TYPE, mem(string-lbl(value(e))))
         (e:KLSClosure) :
            ret-ref $ fn* (x) :
               val code = mem(n(e))
               val vs = seq-append(compile-arg, args(e))
               val len = length(args(e))
               make-array-object(info(e), x, FN-TYPE-ID, len, cons(code,vs))
         (e) :
            fatal("No branch defined for %~" % [e])

   ;     Compile a Tail Call
   ;     ===================
   defn compile-tail-exp (e:KLSExp) -> False :
      match(e) :
         (e:KLSWCall) :
            val ys = seq-append(compile-arg, args(e))
            tcall(arity(e), global-mem(func(e)), ys, new-stack?(e))
         (e:KLSWCallDeptr) :
            val ys = seq-append(compile-arg, args(e))
            val f = head(compile-arg(func(e)))
            tcall(arity(e), f, ys, new-stack?(e))
         (e:KLSWCallDeref) :
            val ys = seq-append(compile-arg, args(e))
            val f = head(compile-arg(func(e)))
            val code = make-long()
            load(code, f, 8 - REF-TAG-BITS)
            tcall(arity(e), code, cons(f, ys), new-stack?(e))
         (e:KLSWSwitchStack) :
            val ys = seq-append(compile-arg, args(e))
            val f = head(compile-arg(func(e)))
            tcallstack(f, ys)
         (e) :
            fatal("Not a legal tail expression: %~" % [e])

   ;     Compile Functions
   ;     =================
   defn compile-functions () :
      for c in comms(prog) do :
         match(c) :
            (c:KDefn) : compile-func(c)
            (c:KDefTypeObject) : compile-type-object(c)
            (c:KLSDefCode) : compile-ls-func(c)
            (c) : false

   ;     Driver
   ;     ======
   val def-ins-vector = Vector<tgt-DefIns>()
   let-var DEF-INS-VECTOR = def-ins-vector :
      compile-machine-state()
      compile-globals()
      compile-object-table()
      compile-constant-table()
      val entry = compile-entry()
      compile-functions()
      tgt-Program(def-ins-vector, entry)