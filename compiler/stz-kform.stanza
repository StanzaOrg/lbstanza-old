#include<"core/stringeater.stanza">
#include<"compiler/stz-algorithms.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">
#include("compiler/stz-utils.stanza")
#include("compiler/stz-kl-ir.stanza")
#include("compiler/stz-tgt-ir.stanza")

defpackage stz/kform :
   import core
   import verse
   import stz/kl-ir
   import stz/utils
   import stz/lexer
   import stz/padder
   import stz/tgt-ir with: (prefix => tgt-)


;                          Parser
;                          ======

defsyntax kl-ir :
   val ut = unwrap-token

   defn seqs (xs:List<KExp>) :
      if empty?(xs) : error("Empty Begin Expression")
      else if empty?(tail(xs)) : head(xs)
      else : KSeq(head(xs), seqs(tail(xs)), false)
      
   defn seqs (xs:List<KLSComm>) :
      if empty?(xs) : error("Empty Begin Expression")
      else if empty?(tail(xs)) : head(xs)
      else : KLSSeq(head(xs), seqs(tail(xs)))

   defrule :
      sym = (?x) when ut(x) typeof Symbol : ut(x)
      int = (?x) when ut(x) typeof Int : ut(x)

      ;     KTypes
      ;     ------
      type = (($var ?n:#int)) : KTVar(n)
      type = (($and ?a:#type ?b:#type)) : KAnd(a, b)
      type = (($or ?a:#type ?b:#type)) : KAnd(a, b)
      type = (top) : KTop()
      type = (bot) : KBot()
      type = (($of ?n:#int)) : KOf(n)

      ;     KCommands
      ;     ---------
      comm = (($def ?x:#int ?v:#exp)) : KDef(x, v)
      comm = (($defvar ?x:#int)) : KDefVar(x, false)
      comm = (($defvar ?x:#int ?v:#exp)) : KDefVar(x, v)
      comm = (($defn ?x:#int (?targs:#int ...) (?a1:#type ...) (?args:#int ...) ?body:#exp)) :
         KDefn(x, KFn(false, targs, a1, args, body))
      comm = (($defn* ?x:#int (?targs:#int ...) (?a1:#type ...) (?args:#int ...) ?body:#exp)) :
         KDefn(x, KFn(true, targs, a1, args, body))
      comm = (($defmulti ?x:#int (?targs:#int ...) (?a1:#type ...))) :
         KDefmulti(x, targs, a1)         
      this = (($this ?x:#int)) : x
      this = () : false
      comm = (($defmethod ?m:#int ?t:#this (?targs:#int ...) (?a1:#type ...) (?args:#int ...) ?body:#exp)) :
         KDefmethod(fresh-id(), m, t, KFn(false, targs, a1, args, body))
      comm = (($defmethod* ?m:#int ?t:#this (?targs:#int ...) (?a1:#type ...) (?args:#int ...) ?body:#exp)) :
         KDefmethod(fresh-id(), m, t, KFn(true, targs, a1, args, body))
      comm = (($deftype ?x:#int)) : KDefType(x, false)   
      comm = (($deftype ?x:#int ?p:#type)) : KDefType(x, p)
      comm = (($lsdef ?x:#int ?t:#lstype ?v:#exp)) : KLSDef(x, t, v)
      comm = (($lsdefvar ?x:#int ?t:#lstype)) : KLSDefVar(x, t, false)
      comm = (($lsdefvar ?x:#int ?t:#lstype ?v:#exp)) : KLSDefVar(x, t, v)
      comm = (($lsdefn ?x:#int (?targs:#int ...) (?a1:#lstype ...) ?a2:#lstype (?args:#int ...) ?body:#lscomm)) :
         KLSDefn(x, targs, a1, a2, args, body)
      lsparent = (($parent ?p:#lstype)) : p
      lsparent = () : false
      lsfield = ((?x:#int ?t:#lstype)) : StructField(x, t)
      lsfield? = (?f:#lsfield) : f
      lsfield? = () : false
      comm = (($lsdeftype ?x:#int ?p:#lsparent (?f:#lsfield ...) ?rf:#lsfield?)) :
         KLSDefType(x, p, f, rf)
      comm = (($extern ?x:#int ?t:#lstype ?n:#sym)) : KExtern(x, t, n)
      comm = (($externfn ?x:#int ?t:#lstype ?n:#sym)) : KExternFn(x, t, n)
      comm = (?e:#exp) : KExpComm(e)

      ;     KForm Expressions
      ;     -----------------
      exp = (($set ?x:#int ?v:#var)) : KSet(x, v, false)
      exp = (($cast ?x:#var ?t:#type)) : KCast(x, t, false)
      exp = (($checkvoid ?x:#var)) : KCheckVoid(x, false)
      exp = (($checklength ?x:#var ?length:#int)) : KCheckLength(x, length, false)
      exp = (($let ?def:#comm ?body:#exp)) : KLet(def, body, false)
      exp = (($letrec (?defs:#comm ...) ?body:#exp)) : KLetRec(defs, body, false)
      exp = (($begin ?es:#exp ...)) : seqs(es as List<KExp>)
      branch = (($branch (?xs:#int ...) (?ts:#type ...) ?body:#exp)) : KBranch(xs, ts, body)
      exp = (($dispatch (?xs:#var ...) ?bs:#branch ...)) : KDispatch(xs, bs, false)
      exp = (($match (?xs:#var ...) ?bs:#branch ...)) : KMatch(xs, bs, false)
      exp = (($new ?c:#type ?m:#comm ...)) : KNew(c, m, false)
      exp = (($do ?f:#var (?targs:#var ...) ?args:#var ...)) : KDo(f, targs, args, false)
      exp = (($call-ls ?f:#var (?targs:#var ...) ?args:#var ...)) : KCallLS(f, targs, args, false)
      exp = (($tuple ?es:#var ...)) : KTuple(es, false)
      exp = (($tuple-get ?v:#var ?i:#int)) : KTupleGet(v, i, false)
      exp = (($value ?v)) : KLiteral(ut(v), false)
      exp = (?v:#var) : v
      var = (($var ?n:#int)) : KVar(n, false)

      ;     KLSTypes
      ;     --------
      lstype = (byte) : KByteT()
      lstype = (int) : KIntT()
      lstype = (long) : KLongT()
      lstype = (float) : KFloatT()
      lstype = (double) : KDoubleT()
      lstype = (uk) : KUnknownT()
      lstype = (($ptr ?t:#lstype)) : KPtrT(t)
      lstype = (($ref ?t:#type)) : KRefT(t)
      lstype = (($fn (?a:#lstype ...) ?r:#lstype ?b:#lstype)) : KFnT(a, r, b)
      lstype = (($fn (?a:#lstype ...) ?b:#lstype)) : KFnT(a, false, b)
      lstype = (($struct ?x:#int)) : KStructT(x)
      
      ;     KLocs
      ;     -----
      loc = (($deref ?e:#lsvar)) : Deref(e)
      loc = (($deptr ?e:#lsvar)) : Deptr(e)
      loc = (($slot ?e:#lsvar ?t:#lstype ?i:#lsvar)) : Slot(e, t, i)
      loc = (($field ?b:#loc ?x:#int)) : Field(b, x)
      loc = (?e:#lsvar) : Binder(e)

      ;     LoStanza Commands
      ;     -----------------
      lscomm = (($jump ?e:#lsexp)) : KLSTCall(e)
      lscomm = (($set ?e:#loc ?v:#lsvar)) : KLSSet(e, v)
      lscomm = (($label ?x:#int)) : KLSLabel(x)
      lscomm = (($goto ?x:#int)) : KLSGoto(x)
      lscomm = (($return ?x:#lsvar)) : KLSReturn(x)
      lscomm = (($let ?def:#comm ?body:#lscomm)) : KLSLet(def, body)
      lscomm = (($begin ?cs:#lscomm ...)) : seqs(cs as List<KLSComm>)
      lscomm = (($if ?p:#lsvar ?c:#lscomm ?a:#lscomm)) : KLSIf(p, c, a)
      lscomm = (($if ?p:#lsvar ?c:#lscomm)) : KLSIf(p, c, KLSSkip())
      lsbranch = (($branch (?args:#int ...) (?ts:#type ...) ?body:#lscomm)) : KLSBranch(args, ts, body)
      lscomm = (($match (?args:#lsvar ...) ?b:#lsbranch ...)) : KLSMatch(args, b)
      lscomm = (?e:#lsexp) : KLSCall(e)

      ;     LoStanza Expressions
      ;     --------------------
      lsexp = (($ref ?x:#int ?args:#lsvar ...)) : KLSRef(x, args)
      lsexp = (($refarray ?x:#int ?len:#lsvar ?args:#lsvar ...)) : KLSRefArray(x, len, args)
      lsexp = (($struct ?x:#int ?args:#lsvar ...)) : KLSStruct(x, args)
      lsexp = (($ptr ?e:#lsvar)) : KLSPtr(e)
      lsexp = (($read ?e:#loc)) : KLSRead(e)
      lsexp = (($do ?t:#lstype ?f:#lsvar (?ts:#type ...) ?args:#lsvar ...)) : KLSDo(f, ts, args, t)
      lsexp = (($call-c ?t:#lstype ?f:#lsvar ?args:#lsvar ...)) : KLSCallC(f, args, t)
      lsexp = (($call-s ?t:#lstype ?f:#lsvar (?ts:#type ...) ?args:#lsvar ...)) : KLSCallS(f, ts, args, t)
      lsexp = (($sizeof ?t:#lstype)) : KLSSizeof(t)
      lsexp = (($tagof ?x:#int)) : KLSTagof(x)
      lsexp = (($conv ?x:#lsvar ?src:#lstype ?dst:#lstype)) : KLSConv(x, src, dst)
      lsexp = (($value ?v)) : KLSValue(ut(v))
      lsexp = (?v:#lsvar) : v
      lsvar = (($var ?x:#int)) : KLSVar(x)

defn parse-kl-ir (file:String) -> KComm :
   val lexed = lex-file(file)
   with-syntax(kl-ir) :
      match-syntax(lexed) :
         (?c:#comm) :
            c


;                       Stanza Machine State
;                       ====================

val HEAP-PTR-LBL = fresh-id()
val HEAP-LIM-LBL = fresh-id()
var EXTEND-HEAP-LBL : False|Int = false

val REF-TAG = 1
val MARK-TAG = 2

;                     Type Analysis
;                     =============

;     Type Table Interface
;     --------------------
defclass TypeTable
defmethod expand (t:TypeTable, t:KLSType) -> List<tgt-TgtType> 
defmethod offsets (t:TypeTable, t:KLSType) -> List<Int>      
defmethod size (t:TypeTable, t:KLSType) -> Int               
defmethod field-offset (t:TypeTable, f:Int) -> Int           
defmethod field-index (t:TypeTable, f:Int) -> Int            
defmethod field-type (t:TypeTable, f:Int) -> KLSType         
defmethod rfield (t:TypeTable, n:Int) -> Int                 
defmethod tag (t:TypeTable, n:Int) -> Int                    

;     Analysis
;     --------
defn analyze-types (prog:KComm) :
   ;     Search through all types
   ;     ------------------------
   val lstypes = HashTable<Int, KLSDefType>({_})
   val types = HashTable<Int, KDefType>({_})
   defn find-types (c:KComm) :
      match(c) :
         (c:KDefType) : types[n(c)] = c
         (c:KLSDefType) : lstypes[n(c)] = c
         (c) : false
   find-types(prog)

   ;     Compute Alignments
   ;     ------------------
   defn prim-type-size (t:KLSType) :
      match(t) :
         (t:KByteT) : 1
         (t:KIntT) : 4
         (t:KLongT) : 8
         (t:KFloatT) : 4
         (t:KDoubleT) : 8
         (t:KPtrT) : 8
         (t:KRefT) : 8
         (t:KUnknownT) : error("No size.")
         (t:KFnT) : error("No size.")
         (t:KStructT) : error("No size.")

   val alignment-table = HashTable<Int,Int>({_})
   defn alignment (t:KLSType) :
      defn struct-alignment (t:KStructT) :
         val def = lstypes[n(t)]
         maximum{_, stream(alignment{type(_)}, fields(def))} $
            match(rfield(def)) :
               (rf:StructField) : alignment(type(rf))
               (rf:False) : 0
      match(t) :
         (t:KUnknownT) : error("No alignment.")
         (t:KFnT) : error("No alignment.")
         (t:KStructT) :
            if not key?(alignment-table, n(t)) :
               alignment-table[n(t)] = struct-alignment(t)
            alignment-table[n(t)]
         (t) : prim-type-size(t)

   ;     Compute Sizes, Offsets, Indices
   ;     -------------------------------
   val type-sizes = HashTable<Int,Int>({_})
   val type-expansions = HashTable<Int,List<tgt-TgtType>>({_})
   val field-offsets = HashTable<Int,Int>({_})
   defn type-expansion (t:KLSType) -> [Int, List<tgt-TgtType>] :   
      defn struct-expansion (t:KStructT) -> [Int, List<tgt-TgtType>] :
         ;Helper: Assign field offsets according to padded items
         defn assign-offsets (padded:Streamable<PadItem>) :
            var accum = 0
            val expansion = Vector<tgt-TgtType>()
            for i in padded do :
               match(i) :
                  (i:Item) :
                     val f = data(i) as StructField
                     field-offsets[n(f)] = accum
                     val [sz, ts] = type-expansion(type(f))
                     do(add{expansion, _}, ts)
                     accum = accum + sz
                  (i:Padding) :
                     accum = accum + size(i)
            [accum, to-list(expansion)]
            
         val def = lstypes[n(t)]
         match(rfield(def)) :
            (rf:StructField) :
               val padded = pad{_, alignment(type(rf))} $
                  for f in fields(def) stream :
                     Item(alignment(type(f)), f)
               val [sz, ts] = assign-offsets(padded)
               field-offsets[n(rf)] = sz
               [sz, ts]
            (rf:False) :
               val padded = pad{_, 1} $
                  for f in fields(def) stream :
                     Item(alignment(type(f)), f)
               assign-offsets(padded)          

      defn prim-type-expansion (t:KLSType) :
         list $ match(t) :
            (t:KByteT) : tgt-BYTE-TYPE
            (t:KIntT) : tgt-INT-TYPE
            (t:KLongT) : tgt-LONG-TYPE
            (t:KFloatT) : tgt-FLOAT-TYPE
            (t:KDoubleT) : tgt-DOUBLE-TYPE
            (t:KPtrT) : tgt-LONG-TYPE
            (t:KRefT) : tgt-REF-TYPE
         
      match(t) :
         (t:KUnknownT) :
            error("No expansion.")
         (t:KFnT) :
            error("No expansion.")
         (t:KStructT) :
            if not key?(type-sizes, n(t)) :
               val [sz, ts] = struct-expansion(t)
               type-sizes[n(t)] = sz
               type-expansions[n(t)] = ts
            [type-sizes[n(t)], type-expansions[n(t)]]
         (t) :
            [prim-type-size(t), prim-type-expansion(t)]
         
   ;Force calculation for field-offsets
   do(type-expansion{KStructT(_)}, keys(lstypes))

   ;     Compute Field Types and Indices
   ;     -------------------------------
   val field-indices = HashTable<Int,Int>({_})
   val field-types = HashTable<Int,KLSType>({_})
   for def in values(lstypes) do :
      for (f in fields(def), i in 0 to false) do :
         field-indices[n(f)] = i
         field-types[n(f)] = type(f)
      if rfield(def) != false :
         val f = rfield(def) as StructField
         field-indices[n(f)] = length(fields(def))
         field-types[n(f)] = type(f)

   ;     Compute Struct Tags
   ;     -------------------
   val tag-table = HashTable<Int,Int>({_})
   val tag-types = Vector<Int>()
   for def in values(lstypes) do :
      tag-table[n(def)] = length(tag-types)
      add(tag-types, n(def))
   for def in values(types) do :
      tag-table[n(def)] = length(tag-types)
      add(tag-types, n(def))

   
   ;     Return Table
   ;     ------------
   new TypeTable :
      defmethod expand (this, t:KLSType) :
         val [sz, ts] = type-expansion(t)
         ts
      defmethod offsets (this, t:KLSType) :
         match(t) :
            (t:KStructT) :
               for f in fields(lstypes[n(t)]) map :
                  field-offset(this, n(f))
            (t) : list(0)
      defmethod size (this, t:KLSType) :
         val [sz, ts] = type-expansion(t)
         sz
      defmethod field-offset (this, f:Int) :
         field-offsets[f]
      defmethod field-type (this, f:Int) :
         field-types[f]
      defmethod field-index (this, f:Int) ;
         field-indices[f]
      defmethod rfield (this, s:Int) :
         n(rfield(lstypes[s]) as StructField)
      defmethod tag (this, n:Int) :
         tag-table[n]


;                   Command Buffer
;                   ==============

;     Emission of Ins Structures
;     --------------------------
var INSTRUCTION-VECTOR : False|Vector<tgt-Ins> = false
defn emit (i:tgt-Ins) : add(INSTRUCTION-VECTOR as Vector<tgt-Ins>, i)
defn args (xs:List<tgt-Var>) : emit(tgt-Args(xs))
defn set (x:tgt-Var, y:tgt-Imm) : emit(tgt-SetIns(x, y))
defn conv (x:tgt-Var, y:tgt-Imm, s?:True|false) : emit(tgt-ConvertIns(x, y, s?))
defn add (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : emit(tgt-BinOp(x, tgt-ADD-OP, y, z))
defn load (x:tgt-Var, y:tgt-Imm, o:Int) : emit(tgt-Load(x, y, o))
defn store (x:tgt-Imm, y:tgt-Imm, o:Int) : emit(tgt-Store(x, y, o))
defn addr (x:tgt-Var, y:tgt-Imm, o:Int) : emit(tgt-Addr(x, y, o))
defn call (a:Int, xs:List<tgt-Var>, f:tgt-Imm, ys:List<tgt-Imm>) : emit(tgt-Call(a, xs, f, ys))
defn tcall (a:Int, f:tgt-Imm, ys:List<tgt-Imm>) : emit(tgt-TCall(a, f, ys))
defn return (xs:List<Imm>) : emit(tgt-Return(xs))
defn tlabel (n:Int) : emit(tgt-Label(n))
defn goto (n:Int) : emit(tgt-Goto(n))
defn jnz (n:Int, x:tgt-Imm, zero:tgt-Imm) : emit(tgt-Branch(n, tgt-NEQ-OP, x, zero))
defn jlt (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-LT-OP, x, y))
defn jle (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-LE-OP, x, y))
defn jult (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-ULT-OP, x, y))
defn jule (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-ULE-OP, x, y))
defn byte (v:Int) : tgt-ByteImm(v)
defn int (v:Int) : tgt-IntImm(v)
defn long (v:Int) : tgt-LongImm(v)
defn mem (n:Int) : tgt-Mem(n)

;     Heap Instructions
;     -----------------
defn heap-ptr () :
   val p = make-var(tgt-LONG-TYPE)
   load(p, mem(HEAP-PTR-LBL), 0)
   p

defn heap-lim () :
   val p = make-var(tgt-LONG-TYPE)
   load(p, mem(HEAP-LIM-LBL), 0)
   p
   
defn extend-heap (sz:tgt-Imm) :
   val endL = fresh-id()
   val p = heap-ptr()
   add(p, p, sz)
   jule(endL, p, heap-lim())
   call(1, List(), EXTEND-HEAP-LBL, sz)
   tlabel(endL)

defn extend-heap (sz:Int) :
   extend-heap(long(sz))

defn inc-heap-ptr (sz:tgt-Imm) :
   val p = heap-ptr()
   add(p, p, sz)
   store(mem(HEAP-PTR-LBL), p, 0)

defn inc-heap-ptr (sz:Int) :
   inc-heap-ptr(long(sz))

;     Compound Value Instructions
;     ---------------------------
defn float-lbl (f:Float) :
   error("Create float label")

defn string-lbl (s:String) :
   error("Create string label")

;                  Variable Management
;                  ===================

;     Definition of VarTable
;     ----------------------
defclass VarTable <: Gettable<Int,List<tgt-Var>> &
                     Settable<Int,List<tgt-Var>>
defmethod make-var (v:VarTable, t:tgt-TgtType) -> tgt-Var
defmethod types (v:VarTable, n:Int) -> List<tgt-TgtType>

defn VarTable () :
   val defs = Vector<tgt-DefVar>()
   val table = HashTable<Int,List<tgt-Var>>({_})
   val type-table = HashTable<Int,tgt-TgtType>({_})
   
   new VarTable :
      defmethod make-var (this, t:tgt-TgtType) :
         val n = fresh-id()
         add(defs, tgt-DefVar(n, t))
         type-table[n] = t
         tgt-Var(n)
      defmethod set (this, n:Int, vs:List<tgt-Var>) :
         table[n] = vs
      defmethod get (this, n:Int) :
         table[n]
      defmethod types (this, x:Int) :
         for v in this[x] map :
            type-table[n(v)]

defn get (v:VarTable, ns:List<Int>) :
   stream-append({v[_]}, ns)

defn make-vars (v:VarTable, ts:List<tgt-TgtType>) :
   for t in ts map :
      make-var(v, t)

;     Implicit VarTable
;     -----------------
var VAR-TABLE : false|VarTable = false
defn VAR-TABLE! () : VAR-TABLE as VarTable
defn make-var (t:tgt-TgtType) : make-var(VAR-TABLE!(), t)
defn make-vars (ts:List<tgt-TgtType>) : map(make-var, ts)
      

;                      Compilation
;                      ===========

defn compile (prog:KComm, tt:TypeTable) -> tgt-Program :
   ;     Algorithm State
   ;     ---------------
   val output = Vector<tgt-DefIns>()
   
   defn emit-top (i:tgt-DefIns) :
      add(output, i)

   ;     Overall Compiler
   ;     ----------------
   defn compile (c:KComm) :
      match(c) :
         (c:KDef) : error("Compile KDef command.")
         (c:KDefVar) : error("Compile KDefVar command.")
         (c:KDefn) : error("Compile KDefn command.")
         (c:KDefmulti) : error("Compile KDefmulti command.")
         (c:KDefmethod) : error("Compile KDefmethod command.")
         (c:KDefType) : error("Compile KDefType command.")
         (c:KExpComm) : error("Compile KExpComm command.")
         (c:KLSDef) : error("Compile KLSDef command.")
         (c:KLSDefVar) : error("Compile KLSDefVar command.")
         (c:KLSDefn) : compile-lsdefn(c)
         (c:KLSDefType) : error("Compile KLSDefType command.")
         (c:KExtern) : error("Compile KExtern command.")
         (c:KExternFn) : error("Compile KExternFn command.")

   ;     Entry Function Compiler
   ;     -----------------------
   defn compile-entry () :
      error("Compile entry function")


   ;     Compiling a LoStanza Function
   ;     -----------------------------
   defn compile-lsdefn (c:KLSDefn) :
      val var-table = VarTable()
      val ins-vector = Vector<tgt-Ins>()

      ;Compile function prelude
      let :
         for (v in args(c), t in a1(c)) do :
            var-table[v] = make-vars(expand(tt, t))
         args(var-table[args(c)])

      ;Compile function body
      defn compile-comm (c:KLSComm) :
         match(c) :
            (c:KLSCall) :
               compile-exp(exp(e), List{})
            (c:KLSTCall) :
               compile-tail-exp(exp(e))
            (c:KLSSet) :
               val ts = compile-types(type(c))
               defn* loop (l:KLoc, off:Int, n:Int) :
                  match(l) :
                     (l:Binder) :
                        val xs = compile-vars(base(l))
                        val xs* = headn(length(ts), tailn(n, xs))
                        compile-exp(value(c), {xs*})
                     (l:Deref) :
                        val p = compile-var(exp(l))
                        val ys = compile-exp(value(c), make-var)
                        for (off in type-offsets(type(c)), y in ys) do :
                           tgt-store(p, y, tgt-long(8 + off - REF-TAG))
                     (l:Deptr) :
                        val p = compile-var(exp(l))
                        val ys = compile-exp(value(c), make-var)
                        for (off in type-offsets(type(c)), y in ys) do :
                           tgt-store(p, y, tgt-long(off))
                     (l:Slot) :
                        val p = make-var(tgt-LONG-TYPE)
                        val ys = compile-exp(value(c), make-var)
                        tgt-mul(p, tgt-long(type-size(type(l))), compile-var(index(l)))
                        tgt-add(p, p, compile-var(exp(l)))
                        for (off in type-offsets(type(c)), y in ys) do :
                           tgt-store(p, y, tgt-long(off))
                     (l:Field) :
                        loop(base(l), off + field-offset(n(l)), n + field-index(n(l)))
               loop(exp(c), 0, 0)
            (c:KLSLabel) :
               tgt-label(n(c))
            (c:KLSGoto) :
               tgt-goto(n(c))
            (c:KLSReturn) :
               tgt-return(compile-vars(exp(c)))
            (c:KLSLet) :
               match(def(c)) :
                  (def:KLSDef) :
                     val ys = compile-exp(value(c), make-var)
                     environment[n(def)] = ys
                  (def:KLSDefVar) :
                     match(value(def)) :
                        (v:KLSExp) :
                           val ys = compile-exp(v, make-var)
                           environment[n(def)] = ys
                        (v:False) :
                           val ts = compile-types(type(def))
                           environment[n(def)] = make-vars(ts)
               compile-comm(body(c))
            (c:KLSIf) :
               val conL = fresh-id()
               val endL = fresh-id()
               tgt-branch(compile-var(pred(c)), conL)
               compile-comm(alt(c))
               tgt-goto(endL)
               tgt-label(conL)
               compile-comm(conseq(c))
               tgt-label(endL)
            (c:KLSSeq) :
               compile-comm(a(c))
               compile-comm(b(c))
            (c:KLSMatch) :
               error("Compile KLSMatch command.")
            (c:KLSSkip) :
               false
   
      defn compile-exp (e:KLSExp, rets:List<tgt-TgtType> -> List<tgt-Var>) -> False :
         defn ret (t:tgt-TgtType) :
            head(rets(list(t)))
            
         match(e) :
            (e:KLSVar) :
               val xs = rets(types(var-table, n(e)))
               val ys = var-table[e]
               do(set, xs, ys)
            (e:KLSRef) :
               val st = KStructT(n(e))
               val sz = ceil8(size(tt, st))
               val x = ret(tgt-REF-TYPE)
               if sz > 0 :
                  extend-heap(sz)
                  add(x, heap-ptr(), long(REF-TAG))
                  inc-heap-ptr(sz)
                  store(x, long(tag(tt, n(e))), neg(REF-TAG))
                  for (o in offsets(n(e), st), v in var-table[args(e)]) do :
                     store(x, v, o + 8 - REF-TAG)
               else :
                  shl(x, long(tag(tt, n(e))), long(3))
                  add(x, x, long(MARKER-TAG))
            (e:KLSRefArray) :
               val st = KStructT(n(e))
               val rf = rfield(tt, n(e))
               val rft = field-type(tt, rf)
               val x = ret(tgt-REF-TYPE)
               ;Compute size and extend heap
               val sz = make-var(tgt-LONG-TYPE)
               val len = head(var-table[length(e)])
               mul(sz, long(size(tt, rft)), len)
               add(sz, sz, long(size(tt, st) + 7))
               and(sz, sz, long(-8))
               extend-heap(sz)
               ;Store into heap
               add(x, heap-ptr(), long(REF-TAG))
               inc-heap-ptr(sz)
               store(x, long(tag(tt, n(e))), neg(REF-TAG))
               for (o in offsets(tt, st), v in var-table[args(e)]) do :
                  store(x, v, o + 8 - REF-TAG)
            (e:KLSStruct) :
               val st = KStructT(n(e))
               val xs = rets(expand(tt, st))
               val ys = var-table[args(e)]
               do(set, xs, ys)
            (e:KLSPtr) :
               val x = ret(tgt-LONG-TYPE)
               defn* loop (l:KLoc, off:Int) :
                  match(l) :
                     (l:Binder) :
                        val p = head(var-table[exp(l)])
                        addr(x, p, off)
                     (l:Deref) :
                        val p = head(var-table[exp(l)])
                        add(x, p, long(off + 8 - REF-TAG))
                     (l:Deptr) :
                        val p = head(var-table[exp(l)])
                        if off > 0 : add(x, p, long(off))
                        else : set(x, p)
                     (l:Slot) :
                        val i = head(var-table[index(l)])
                        val p = head(var-table[exp(l)])
                        mul(x, long(size(tt, type(l))), i)
                        add(x, x, p)
                        add(x, x, long(off)) when off > 0
                     (l:Field) :
                        loop(base(l), off + field-offset(tt, n(l)))
               loop(exp(e), 0)
            (e:KLSRead) : 
               val xs = rets(expand(tt, type(e)))
               defn* loop (l:KLoc, off:Int, n:Int) :
                  match(l) :
                     (l:Binder) :
                        val ys = var-table[exp(l)]
                        do(set, xs, tailn(n, ys))
                     (l:Deref) :
                        val p = head(var-table[exp(l)])
                        for (x in xs, o in offsets(tt, type(e))) do :
                           load(x, p, off + o + 8 - REF-TAG)
                     (l:Deptr) :
                        val p = head(var-table[exp(l)])
                        for (x in xs, o in offsets(tt, type(e))) do :
                           load(x, p, off + o)
                     (l:Slot) :
                        val b = head(var-table[exp(l)])
                        val i = head(var-table[index(l)])
                        val p = make-var(tgt-LONG-TYPE)
                        mul(p, long(size(tt, type(l))), i)
                        add(p, p, b)
                        for (x in xs, o in offsets(tt, type(e))) do :
                           load(x, p, o + off)
                     (l:Field) :
                        loop(base(l),
                             off + field-offset(tt, n(l)),
                             n + field-index(tt, n(l)))
               loop(exp(e), 0, 0)
;            (e:KLSDo) :
;               val xs = rets(expand(tt, type(e)))
;               val ys = var-table(args(e))
;               val arity = length(args(e))
;               val f = if directfn?(func(e)) : tgt-Mem(n(func(e)))
;                       else : compile-var(func(e))
;               tgt-call(arity, xs, f, ys)
;            (e:KLSCallC) :
;               val xs = rets(compile-types(type(e)))
;               val ys = compile-vars(args(e))
;               val f = if directfn?(func(e)) : tgt-Mem(n(func(e)))
;                       else : compile-var(func(e))
;               tgt-call-c(xs, f, ys)
;            (e:KLSCallS) :
;               val xs = rets(compile-types(type(e)))
;               val ys = compile-vars(args(e))
;               val arity = length(args(e))
;               if directfn?(func(e)) :
;                  val f = tgt-Mem(n(func(e)))
;                  tgt-call(arity, xs, f, ys)
;               else :
;                  val f = compile-var(func(e))
;                  val code = make-var(tgt-LONG-TYPE)
;                  tgt-load(code, f, 8 - REF-TAG)
;                  tgt-call(arity, xs, code, List(f, ys))                  
            (e:KLSSizeof) :
               val x = ret(tgt-LONG-TYPE)
               set(x, long(size(tt, type(e))))
            (e:KLSTagof) :
               val x = ret(tgt-LONG-TYPE)
               tgt-set(x, tag(tt, n(e)))
            (e:KLSConv) :
               val x = ret(head(expand(tt, type(e))))
               val y = head(var-table[exp(e)])
               tgt-conv(x, y, false)
            (e:KLSValue) :
               match(value(e)) :
                  (v:Int) :
                     val x = ret(tgt-INT-TYPE)
                     tgt-set(x, int(v))
                  (v:Float) :
                     val x = ret(tgt-FLOAT-TYPE)
                     tgt-load(x, mem(float-lbl(v)))
                  (v:String) :
                     val x = ret(tgt-LONG-TYPE)
                     tgt-addr(x, mem(string-lbl(v)))

      defn compile-tail-exp (e:KLSExp) :
         match(e) :
            (e:KLSDo) :
               val ys = compile-vars(args(e))
               val arity = length(args(e))
               val f = if directfn?(func(e)) : tgt-Mem(n(func(e)))
                       else : compile-var(func(e))
               tgt-tcall(arity, f, ys)
            (e:KLSCallS) :
               val ys = compile-vars(args(e))
               val arity = length(args(e))
               if directfn?(func(e)) :
                  val f = tgt-Mem(n(func(e)))
                  tgt-tcall(arity, f, ys)
               else :
                  val f = compile-var(func(e))
                  val code = make-var(tgt-LONG-TYPE)
                  tgt-load(code, f, 8 - REF-TAG)
                  tgt-tcall(arity, code, List(f, ys))

      compile-comm(body(c))

      ;Emit Compiled Function
      error("Emit compiled function.")


   ;     Driver
   ;     ------
   compile(prog)
   val entry = compile-entry()
   tgt-Program(output, entry)


;                      Testing
;                      =======

defn headline (str:String) :
   val n = length(str)
   val m = 30 - n / 2
   println()
   do(print{" "}, 0 to m)
   println(str)
   do(print{" "}, 0 to m)
   do(print{"="}, 0 to n)
   println()
      
defn main () :
   val filename = commandline-arguments()[1]
   val program = parse-kl-ir(filename)
   
   headline("KForm Program")
   println(program)

main()