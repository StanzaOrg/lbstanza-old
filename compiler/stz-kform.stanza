defpackage stz/kform :
   import core
   import verse
   import stz/kl-ir
   import stz/ids
   import stz/utils
   import stz/lexer
   import stz/padder
   import stz/tgt-ir with: (prefix => tgt-)
   import stz/tgt with: (prefix => tgt-)


;                           Driver
;                           ======

public defn compile (program:KProg, filename:String) :
   ;headline("Box mutables")
   ;prog = box-mutables(prog)
   ;println(prog)
   ;
   ;headline("Reify Types")
   ;prog = reify-types(prog)
   ;println(prog)
   ;
   ;headline("Call Conversion")
   ;prog = convert-calls(prog)
   ;println(prog)
   
   headline("Compile")
   val compiled = compile(program)
   println(compiled)
   
   tgt-compile(compiled, filename)



;                    HiStanza Normalization
;                    ======================

;defn normalize (e:KExp) :
;   val def-vector = Vector<KDef|KDefVar|KDefn>()
;
;   defn force-var (e:KExp) :
;      match(norm-exp(e)) :
;         (e:KVar) : e
;         (e) :
;            val n = fresh-id()
;            add(def-vector, KDef(n, e))
;            KVar(n, false)
;
;   defn norm-exp (e:KExp) :
;      match(e) :
;         (e:KLet) :
;            add(def-vector, norm-comm(def(e)))
;            norm-exp(body(e))
;         (e:KLetRec) :
;            mapr(normalize, e)
;         (e:KSeq) :
;            KSeq(norm-exp(a(e))
;                 normalize(b(e)),
;                 type(e))
;         (e:KDispatch) :
;            val args* = map(force-var, args(e))
;            val branches* = for b in branches(e) map : map(normalize, b)
;            KDispatch(args*, branches*, type(e))
;         (e:KMatch) :
;            val args* = map(force-var, args(e))
;            val branches* = for b in branches(e) map : map(normalize, b)
;            KMatch(args*, branches*, type(e))
;         (e:KNew) :
;            map(norm-comm, e)
;         (e) :
;            map(force-var, e)
;
;   defn norm-comm<?T> (c:?T&KComm) -> T :
;      val c* = match(c) :
;         (c:KDef) : map(norm-exp, c)
;         (c:KDefVar) : map(force-var, c)
;         (c:KDefn) : map(normalize, c)
;         (c) : c
;      c* as T&KComm
;
;   var ret = norm-exp(e)
;   for def in in-reverse(def-vector) do :
;      ret = KLet(def, ret, type(ret))
;   ret
;         

;                    Box Mutable Variables
;                    =====================
;
;defn box-mutables (p:KProg) :
;   val mtable = HashTable<Int, True>({_})
;   defn box? (v:Int) : get?(mtable, v, false)
;
;   defn box (e:KExp) :
;      match(e) :
;         (e:KLet) :
;            match(def(e)) :
;               (d:KDefVar) :
;                  mtable[n(d)] = true
;                  val d* = map(box, d) as KDefVar
;                  val body* = box(body(e))
;                  KLet(KDef(n(d), KBox(value(d*), false)),
;                       body*,
;                       false)
;               (d) :
;                  mapr(box, e)
;         (e:KSet) :
;            val v* = box(value(e))
;            if box?(n(e)) : KBoxSet(KVar(n(e), false), v*, false)
;            else : KSet(n(e), v*, false)
;         (e:KVar) :
;            if box?(n(e)) : KBoxGet(KVar(n(e), false), false)
;            else : e
;         (e) :
;            mapr(box, e)
;
;   ;Driver
;   KProg $ for c in comms(p) map :
;      map(box, c)



;;                    Free Variable Computation
;;                    =========================
;
;defstruct FVEntry :
;   args: List<Int>
;   targs: List<Int>
;
;defn freevar-table (e:KComm) :
;   ;Table
;   val table = HashTable<Int, FVEntry>({_})
;
;   ;Get the freevars in a given function
;   defn freevars (f:Func) :
;      val arg-vars = HashTable<Int,True|False>({_})
;      val targ-vars = HashTable<Int,True|False>({_})
;      
;      defn mark-free (t:KType) :
;         match(t) :
;            (t:KTVar) : targ-vars[n(t)] = true
;            (t) : do(mark-free, t)
;      
;      defn mark-free (e:KExp) :
;         defn mark-func (n:Int, f:Func) :
;            val fvs = freevars(f)
;            table[n] = fvs
;            for x in fvs do :
;               arg-vars[x] = true               
;
;         defn mark-free (b:KBranch) :
;            mark-free(body(b))
;            for x in args(b) do :
;               arg-vars[x] = false               
;               
;         match(e) :
;            (e:KLet) :
;               mark-free(body(e))
;               match(def(e)) :
;                  (d:KDef|KDefVar) :
;                     do(mark-free, d)
;                     arg-vars[n(d)] = false
;                  (d:KDefn) :
;                     mark-func(n(d), value(d))
;                     arg-vars[n(d)] = false
;            (e:KLetRec) :
;               mark-free(body(e))
;               for d in defs(e) do :
;                  mark-func(n(d), value(d))
;               for d in defs(e) do :
;                  arg-vars[n(d)] = false
;            (e:KDispatch) :
;               do(mark-free, args(e))
;               do(mark-free, branches(e))
;            (e:KMatch) :
;               do(mark-free, args(e))
;               do(mark-free, branches(e))
;            (e:KNew) :
;               for m in methods(e) do :
;                  mark-func(n(m), func(m))
;            (e:KVar) :
;               if not global?(n(e)) :
;                  arg-vars[n(e)] = true
;            (e:KDo) :
;               do(mark-free, e)
;               do(mark-free, targs(e))
;            (e:KCast) :
;               do(mark-free, e)
;               mark-free(targ(e))
;            (e) :
;               do(mark-free, e)
;
;      defn mark (f:Func) :
;         match(f) :
;            (f:KFn) :
;               mark-free(body(f))
;               for x in args(f) do :
;                  arg-vars[x] = false
;               for x in targs(f) do :
;                  targ-vars[x] = false
;            (f:KMultifn) :
;               do(mark, funcs(f))
;
;      defn true-keys (t:HashTable<Int,True|False>) :
;         to-list $
;         stream{key, _} $
;         filter(value, t)
;         
;      mark(f)
;      FVEntry(true-keys(arg-vars), true-keys(targ-vars))
;
;   ;Compute freevars for every expression
;   defn compute-exp (e:KExp) :
;      do(compute-comm, e)
;      do(compute-exp, e)
;   defn compute-comm (c:KComm) :
;      match(c) :
;         (c:KDefn) : freevars(value(c))
;         (c:KDefmethod) : freevars(func(c))
;         (c) : do(compute-exp, c)
;
;   ;Driver
;   compute-comm(c)
;   table
;
;
;;                     Object Lifting
;;                     ==============
;
;defn lift-objects (prog:KProg, freetable: HashTable<Int,List<Int>>) :
;   ;New top level forms
;   val accum = Vector<KComm>()
;   defn lift-top (c:KComm) : add(accum, c)
;   
;   defn lift (e:KExp) :
;      match(mapr(lift,e)) :
;         (e:New) :
;            ;Free variables
;            val fvs = unique $
;               for m in methods(e) concat :
;                  freetable[n(m)]
;            ;Names of free variables      
;            val venv = for v in fvs map :
;               v => fresh-id()
;            ;Create struct for object
;            val newtype = fresh-id()
;            lift-top $ KLSDefType(newtype, type(e),
;               for v in venv map :
;                  StructField(fresh-id(), KRefT(KUnknownT())))
;            ;Pull methods out to top-level   
;            for m in methods(e) do :
;               ;Function in method
;               val f = func(m)
;               ;Argument name for object
;               val obj = thisn(m) as Int
;               ;Update body of method
;               var body* = alpha-rename(body(f), venv)
;               for (entry in venv, i in 0 to false) do :
;                  body* = KLet(Def(value(entry), ObjGet(KVar(obj), i)),
;                               body*)
;               ;Update input types of method
;               val a1* = for (t in a1(f), a in args(f)) map :
;                  if a == obj : KOf(newtype)
;                  else : t
;               ;Pull out to top-level method
;               lift-top $ Defmethod(n(m), multi(m), false,
;                  KFn(tail?(f), targs(f), a1*, a2(f), args(f), body*))
;            ;Change New to Object
;            Object(newtype, map(KVar, fvs))
;         (e) :
;            e
;
;   ;Lift all object expressions and push to accum
;   for c in comms(prog) do :
;      lift-top(map(lift, c))
;
;   ;Return new program
;   KProg(to-list(accum))
;
;
;;                   Multi Conversion
;;                   ================
;
;defn convert-multis (prog:KProg) :
;   ;Find all methods in program
;   val methods = HashTable<Int, List<KDefmethod>>({_})
;   defn find-methods (c:KComm) :
;      match(c) :
;         (c:KDefmethod) :
;            methods[multi(c)] = List(c, get?(methods, multi(c), List()))
;         (c) : false
;   do(find-methods, comms(prog))
;
;   ;Conversion
;   defn convert (c:KComm) :
;      match(c) :
;         (c:KDefmulti) :
;            val args* = map(fresh-id{}, args(c))
;            val branches* = for m in get?(methods, n(c), List()) map :
;               val xs = map(fresh-id{}, args(c))
;               val ts = a1(func(m))
;               val body = KDo(KVar(n(m)), map(KTVar, targs(c)), map(KVar, xs))               
;               KBranch(xs, ts, body)
;            val body* = KDispatch(map(KVar, args*), branches*)
;            val func* = KFn(true, targs(c), a1(c), false, args*, body*)
;            KDefn(n(c), func*)               
;         (c:KDefmethod) :
;            KDefn(n(c), value(c))
;         (c) :
;            c
;
;   ;Return program
;   KProg(map(convert, comms(prog)))
;
;
;;                  Dispatch Conversion
;;                  ===================
;
;defstruct DispatchTree :
;   branch: Branch
;   children: List<DispatchTree>
;
;defn convert-dispatches (prog:KProg) :
;   defn convert-dispatch (e:KDispatch) :
;      defn less-eq? (a:KBranch, b:KBranch) :
;         all?(subtype?{erase(_), erase(_)}, types(a), types(b))
;      defn less? (a:Branch, b:Branch) :
;         (a <= b) and not (b <= a)
;      defn split (x:Branch, xs:List<Branch>) :
;         partition({_ < x}, xs)
;      defn intersect (xs:List<Type>, ys:List<Type>) :
;         map(intersection{erase(_), erase(_)}, xs, ys)
;         
;      defn form-tree (bs:List<Branch>) -> List<DispatchTree> :
;         if empty?(bs) :
;            List()
;         else :
;            val x = head(bs)
;            val [alpha, beta] = split(x, tail(bs))
;            val y = form-tree(alpha)
;            val z = form-tree(beta)
;            List(DispatchTree(x, y), z)
;      defn amb-branches (bs:List<Branch>) :
;         if length(bs) > 1 :
;            val ebs = Vector<Branch>()
;            var t1 = map(lower, types(head(bs))
;            for b in tail(bs) do :
;               val t2 = map(lower, types(b))
;               val xs = map(fresh-id{}, args(e))
;               val ts = map(intersect, t1, t2)
;               if none?(bottom?, ts) :
;                  add(ebs, Branch(xs, ts, Error(`amb-dispatch)))
;               t1 = map(lower{KOr(_, _)}, t1, t2)
;            to-list(ebs)
;         else : List()
;      val ordered = generate<Branch> :
;         defn loop (ts:List<DispatchTree>) :
;            do(yield, amb-branches(map(branch, ts)))
;            for t in ts do :
;               loop(children(t))
;               yield(branch(t))
;         loop(form-tree(branches(e)))
;      Match(args(e), to-list(ordered))
;
;   ;Convert all dispatches within e to matches
;   defn convert-exp (e:KExp) :
;      match(mapr(convert-exp, e)) :
;         (e:KDispatch) : convert-dispatch(e)
;         (e) : e
;
;   ;Driver
;   val comms* = for c in comms(prog) map :         
;      mapr(convert-exp, c)
;   KProg(comms*)   
;
;
;                   Type Reification
;                   ================

;defn reify-types (prog:KProg) :
;   val accum = Vector<KComm>()
;
;   ;     Tail Call Insertion
;   ;     -------------------
;   defn insert-tail-calls (e:KExp) :
;      match(e) :
;         (e:KLet) : KLet(def(e), insert-tail-calls(body(e)), false)
;         (e:KLetRec) : KLetRec(defs(e), insert-tail-calls(body(e)), false)
;         (e:KMatch) :
;            val branches* = for b in branches(e) map :
;               KBranch(args(b), types(b), insert-tail-calls(body(b)))
;            KMatch(args(e), branches*, false)
;         (e:KCall) : KCall(true, arity(e), func(e), args(e), type(e))
;         (e) : e         
;   
;   defn lift-type (t:KType) :
;      error("Not yet implemented.")
;;      val idx-counter = to-stream(0 to false)
;;      val vs = Vector<KTVar>()
;;      defn lift (t:KType) :
;;         match(t) :
;;            (t:KTVar) :
;;               add(vs, t)
;;               KTArg(next(idx-counter))
;;            (t) : map(lift, t)
;;      val t* = lift(t)
;;      val n = fresh-id()
;;      add(accum, DefTypeObject(n, next(idx-counter), t*))
;;      KTObj(n, to-list(vs))
;
;   ;     HiStanza Type Reification
;   ;     -------------------------
;   defn reify-exp (exp:KExp) :
;      val e = mapr(reify-exp, map(reify-comm, exp))
;      match(e) :
;         (e:KDo) :
;            val targs* = map(lift-type, targs(e))
;            val args* = append(targs*, args(e))
;            KCall(false, length(args(e)), func(e), args*, false)
;         (e) : e
;   defn reify-comm (c:KComm) :
;      match(c) :
;         (c:KDefn) : KDefn(n(c), reify-func(value(c)))
;         (c) : map(reify-exp, c)
;   defn reify-func (f:Func) :
;      match(f) :
;         (f:KFn) :
;            ;Get new body
;            var body* = reify-exp(body(f))
;            for (t in a1(f), x in args(f)) do :
;               body* = KSeq(KCast(KVar(x,false), t, false), body*, false)
;            if tail?(f) : body* = insert-tail-calls(body*)
;            ;Get new arguments
;            val args* = append(targs(f), args(f))
;            ;Create code object
;            KCode(0, length(args(f)), args*, body*)
;         (f:KMultifn) :
;            KMultifn $ for func in funcs(f) map :
;               reify-func(func) as KCode
;
;   ;     LoStanza Type Reification
;   ;     -------------------------
;   defn reify-exp (exp:KLSExp) :
;      match(map(reify-exp, exp)) :
;         (e:KLSCall) :
;            val targs* = map(lift-type, targs(e))
;            val args* = append(targs*, args(e))            
;            KLSWCall(length(args(e)), func(e), args*, type(e))
;         (e:KLSCallClosure) :
;            val targs* = map(lift-type, targs(e))
;            val args* = append(targs*, args(e))
;            KLSWCallClosure(length(args(e)), func(e), args*, type(e))
;         (e) : e
;   defn reify-func (f:KLSDefn) :
;      ;Get new body
;      var body* = mapr(reify-exp, body(f))
;      for (t in a1(f), x in args(f)) do :
;         if t typeof KRefT :
;            body* = KLSSeq(KLSConv(KLSVar(x), t), body*)
;      ;Get new arguments
;      val args* = append(targs(f), args(f))
;      val types* = append(map(KRefT{KTop()}, targs(f)), a1(f))
;      ;Create code
;      KLSDefCode(n(f), length(args(f)), args*, types*, body*)
;
;   ;Driver
;   for c in comms(prog) do :
;      add(accum, reify-comm(c))
;   KProg(to-list(accum))

;;                   Closure Lifting
;;                   ===============
;
;defn lift-closures (prog:KProg, freetable:HashTable<Int,List<Int>>) :
;   val accum = Vector<KComm>()
;
;   ;Lift a function with the given free variables to the top-level.
;   ;Returns the identifier of the Defn representing the code for the function.
;   defn lift-func (f:Func, fvs:List<Int>) :
;      defn lift (f:Func) :
;         match(f) :
;            (f:KFn) :
;               ;Names of free variables
;               val venv = for v in fvs map :
;                  v => fresh-id()
;               ;Name of closure object
;               val clo = fresh-id()
;               ;Pull function to top-level
;               var body* = alpha-rename(body(f), venv)
;               for (entry in venv, i in 0 to false) do :
;                  body* = KLet(Def(value(entry), ClosureGet(KVar(clo), i)),
;                               body*)
;               ;Update input types and arguments of method
;               val a1* = List(KOf(FN-TYPE-ID), a1(f))
;               val args* = List(clo, args(f))
;               ;Return updated func
;               KFn(tail?(f), targs(f), a1*, a2(f), args*, body*)
;            (f:KMulti) :
;               KMulti(map(lift, funcs(f)))
;      val f* = lift(f)
;      val n* = fresh-id()
;      add(accum, KDefn(n*, f*))
;      n*
;
;   ;Lift all functions within expression
;   defn lift-exp (e:KExp) :
;      defn lift-def (c:KComm) :
;         match(c) :
;            (c:KDefn) :
;               val fvs = freetable[n(c)]
;               val code = lift-func(value(c), fvs)
;               KClosure(code, map(KVar, fvs))
;            (c) : c
;            
;      match(mapr(lift-exp, e)) :
;         (e:KLet) :
;            KLet(lift-def(def(e)), body(e))
;         (e:KLetRec) :
;            KLetRec(map(lift-def, defs(e)), body(e))
;         (e) :
;            e
;
;   ;Driver
;   for c in comms(prog) do :
;      add(accum, mapr(lift-exp, c))
;   KProg(to-list(accum))
;
;


;                    Converting Calls
;                    ================

;definterface FSummary
;defstruct FuncSummary <: FSummary :
;   arity: Int
;   num-args: Int
;defstruct MultiSummary <: FSummary :
;   funcs: List<FuncSummary>
;   
;defn convert-calls (prog:KProg) :
;   ;     Analysis
;   ;     --------
;   val global-funcs = HashTable<Int, FSummary>({_})
;   defn global-func? (n:Int) : key?(global-funcs, n)
;   
;   for c in comms(prog) do :
;      match(c) :
;         (c:KDefn) :
;            defn to-summary (f:Func) :
;               match(f) :
;                  (f:KCode) : FuncSummary(arity(f), length(args(f)))
;                  (f:KMultifn) : MultiSummary(map({to-summary(_) as FuncSummary}, funcs(f)))                  
;            global-funcs[n(c)] = to-summary(value(c))
;         (c:KLSDefCode) :
;            global-funcs[n(c)] = FuncSummary(arity(c), length(args(c)))
;         (c) : false
;         
;   ;     Transformation
;   ;     --------------
;   val accum = Vector<KComm>()
;   val codetable = HashTable<Int,Int>({_})
;   val closure-cache = HashTable<Int,Int>({_})
;
;   defn make-closure (n:Int, f:FSummary) :
;      defn make-first-class (n:Int, f:FSummary) :
;         match(f) :
;            (f:FuncSummary) :
;               val args* = to-list(stream(fresh-id{}, 0 to num-args(f)))
;               val argvs = map(KVar{_, false}, args*)
;               val body* = KCall(true, arity(f), n, argvs, false)
;               KCode(0, arity(f), List(fresh-id(), args*), body*)
;            (f:MultiSummary) :
;               KMultifn $ for func in funcs(f) map :
;                  make-first-class(n, func) as KCode
;      if not key?(closure-cache, n) :            
;         val code = fresh-id()
;         add(accum, KDefn(code, make-first-class(n, f)))
;         val clo = fresh-id()
;         add(accum, KDef(clo, KClosure(code, List(), false)))
;         closure-cache[n] = clo
;      closure-cache[n]   
;
;   ;     Transforming HiStanza expressions
;   ;     ---------------------------------
;   defn conv-exp (e:KExp) :
;      defn record-code (d) :
;         match(d) :
;            (d:KDef) :
;               match(value(d)) :
;                  (v:KClosure) : codetable[n(d)] = n(v)
;                  (v) : false
;            (d) : false            
;      match(e) :
;         (e:KCall) :
;            match(func(e)) :
;               (f:KVar) :
;                  val args* = map(conv-exp, args(e))
;                  if global-func?(n(f)) :
;                     KCall(tail?(e), arity(e), n(f), args*, false)
;                  else if key?(codetable, n(f)) :
;                     KCall(tail?(e), arity(e), codetable[n(f)], List(f, args*), false)
;                  else :
;                     KCall(tail?(e), arity(e), f, args*, false)                  
;               (f:Int) :
;                  map(conv-exp, e)
;         (e:KLet) :
;            record-code(def(e))
;            mapr(conv-exp, e)
;         (e:KLetRec) :
;            do(record-code, defs(e))
;            mapr(conv-exp, e)
;         (e:KVar) :
;            if global-func?(n(e)) :
;               val clo = make-closure(n(e), global-funcs[n(e)])
;               KVar(clo, false)
;            else : e
;         (e) :
;            map(conv-exp, e)
;
;   ;     Transforming LoStanza expressions
;   ;     ---------------------------------
;   defn conv-ptr-loc (l:KLoc) :
;      match(l) :
;         (l:Value) : l
;         (l:Field) : Field(conv-ptr-loc(base(l)), n(l))
;         (l) : map(conv-ls-exp, l)      
;               
;   defn conv-ls-exp (e:KLSExp) :
;      match(e) :
;         (e:KLSPtr) :
;            KLSPtr(conv-ptr-loc(exp(e)))
;         (e:KLSVar) :
;            if global-func?(n(e)) :
;               val clo = make-closure(n(e), global-funcs[n(e)])
;               KVar(clo, false)
;            else : e
;         (e) : map(conv-ls-exp, e)
;
;   defn conv-ls-comm (c:KLSComm) :
;      mapr(conv-ls-exp, c)
;
;   ;     Driver
;   ;     ------
;   for c in comms(prog) do :
;      add{accum, _} $ match(c) :
;         (c:KDef|KDefVar|KDefn|KExpComm) :
;            for e in c map :
;               conv-exp(normalize(e))
;         (c:KLSDef|KLSDefCode|KLInit) :
;            map(conv-ls-comm, c)
;         (c) : c
;   KProg(to-list(accum))


;============================================================
;==================== Compilation ===========================
;============================================================



;;                  Match Trie Conversion
;;                  =====================
;
;definterface MTrie
;defmulti type (t:MTrie) -> Type
;
;defstruct TrieArg <: MTrie :
;   type: Type with: (as-method => true)
;   children: List<MTrie>
;defstruct TrieEnd <: MTrie :
;   type: Type with: (as-method => true)
;   i: Int
;
;defmethod print (o:OutputStream, tr:MTrie) :
;   print{o,_} $
;   match(tr) :
;      (tr:TrieArg) : "(~ => ~@)" << [type(tr), join(children(tr), " or ")]
;      (tr:TrieEnd) : "(~ => ~)" << [type(tr), i(tr)]
;
;defn to-trie (branches:List<List<Type>>) -> List<MTrie> :
;
;   defn add (trs:List<MTrie>, types:List<Type>, branch:Int) -> List<MTrie> :
;      val [t, rest] = [head(types), tail(types)]
;      ;Case: Path is unreachable
;      if bottom?(t) :
;         trs
;      ;Case: There are currently no tries.
;      else if empty?(trs) :
;         if empty?(rest) : list(TrieEnd(t, branch))
;         else : TrieArg(t, add(trs, rest, branch))      
;      else :
;         val tr = head(trs)
;         ;Case: Head of trie is covered completely by path
;         if subtype?(type(tr), t) :
;            val tr* = match(tr) :
;               (tr:TrieArg) : TrieArg(type(tr), add(children(tr), rest, branch))
;               (tr:TrieEnd) : tr
;            val types* = List(t - type(tr), tail(types))
;            List(tr*, add(tail(trs), types*, branch))
;         ;Case: Path is covered completely by head of trie   
;         else if subtype?(t, type(tr)) :
;            match(tr) :
;               (tr:TrieArg) :
;                  List(TrieArg(t, add(children(tr), rest, branch))
;                  List(TrieArg(type(tr) - t, children(tr))
;                       tail(trs)))
;               (tr:TrieEnd) :
;                  List(TrieEnd(t, branch),
;                  List(TrieEnd(type(tr) - t, branch(tr)),
;                       tail(trs)))
;         ;Case: Trie needs to be split more finely.
;         else :
;            val t1 = intersect(type(tr), t)
;            val t2 = t - t1
;            val trs* = add(trs, List(t1, tail(types)), branch)
;            add(trs*, List(t2, tail(types)), branch)
;         
;   ;Driver
;   var accum:List<MTrie> = List()
;   for (b in branches, i in 0 to false) do :
;      add(accum, b, i)
;   accum



;                   Command Buffer
;                   ==============

;     Emission of DefIns Structures
;     -----------------------------
var DEF-INS-VECTOR : False|Vector<tgt-DefIns> = false
defn emit (i:tgt-DefIns) : add(DEF-INS-VECTOR as Vector<tgt-DefIns>, i)


;     Emission of Ins Structures
;     --------------------------
var INSTRUCTION-VECTOR : False|Vector<tgt-Ins> = false
defn emit (i:tgt-Ins) : add(INSTRUCTION-VECTOR as Vector<tgt-Ins>, i)
defn args (xs:List<tgt-Var>) : emit(tgt-ArgsIns(xs))
defn set (x:tgt-Var, y:tgt-Imm) : emit(tgt-SetIns(x, y))
defn conv (x:tgt-Var, y:tgt-Imm) : emit(tgt-ConvertIns(x, y))
defn binop (x:tgt-Var, op:tgt-TgtOp, y:tgt-Imm, z:tgt-Imm) : emit(tgt-BinOp(x, op, y, z))
defn add (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : binop(x, tgt-ADD-OP, y, z)
defn mul (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : binop(x, tgt-MUL-OP, y, z)
defn shl (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : binop(x, tgt-SHL-OP, y, z)
defn bit-and (x:tgt-Var, y:tgt-Imm, z:tgt-Imm) : emit(tgt-BinOp(x, tgt-AND-OP, y, z))
defn load (x:tgt-Var, y:tgt-Imm, o:Int) : emit(tgt-Load(x, y, o))
defn store (x:tgt-Imm, y:tgt-Imm, o:Int) : emit(tgt-Store(x, y, o))
defn addr (x:tgt-Var, n:Int) : emit(tgt-Addr(x, n))
defn call (a:Int, xs:List<tgt-Var>, f:tgt-Imm, ys:List<tgt-Imm>) : emit(tgt-Call(a, xs, f, ys))
defn ffi-call (xs:List<tgt-Var>, f:tgt-Imm, ys:List<tgt-Imm>) : emit(tgt-CallC(xs, f, ys))
defn tcall (a:Int, f:tgt-Imm, ys:List<tgt-Imm>) : emit(tgt-TCall(a, f, ys))
defn return (xs:List<tgt-Imm>) : emit(tgt-Return(xs))
defn tlabel (n:Int) : emit(tgt-Label(n))
defn goto (n:Int) : emit(tgt-Goto(n))
defn jne (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-NE-OP, x, y))
defn jeq (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-EQ-OP, x, y))
defn jlt (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-LT-OP, x, y))
defn jle (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-LE-OP, x, y))
defn jult (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-ULT-OP, x, y))
defn jule (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-ULE-OP, x, y))
defn jgt (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-GT-OP, x, y))
defn jge (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-GE-OP, x, y))
defn jugt (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-UGT-OP, x, y))
defn juge (n:Int, x:tgt-Imm, y:tgt-Imm) : emit(tgt-Branch(n, tgt-UGE-OP, x, y))
defn byte (v:Int) : tgt-ByteImm(v)
defn int (v:Int) : tgt-IntImm(v)
defn long (v:Int) : tgt-LongImm(v)
defn mem (n:Int, offset:Int) : tgt-Mem(n, offset)
defn xmem (name:Symbol, offset:Int) : tgt-ExMem(name, offset)
defn mem (n:Int) : tgt-Mem(n, 0)
defn xmem (name:Symbol) : tgt-ExMem(name, 0)

defn jstack-has-space (n:Int) : emit(tgt-SpecialBranch(n, tgt-STACK-HAS-SPACE))
defn switch-stack () : emit(tgt-SpecialOp(tgt-SWITCH-STACK-OP))

;     Heap Instructions
;     -----------------
defn heap-ptr () :
   val p = make-var(tgt-LONG-TYPE)
   load(p, mem(HEAP-PTR-LBL), 0)
   p

defn heap-lim () :
   val p = make-var(tgt-LONG-TYPE)
   load(p, mem(HEAP-LIM-LBL), 0)
   p
   
defn extend-heap (sz:tgt-Imm) :
   val endL = fresh-id()
   val p = heap-ptr()
   add(p, p, sz)
   jule(endL, p, heap-lim())
   call(1, List(), mem(EXTEND-HEAP-ID), list(sz))
   tlabel(endL)

defn extend-heap (sz:Int) :
   extend-heap(long(sz))

defn inc-heap-ptr (sz:tgt-Imm) :
   val p = heap-ptr()
   add(p, p, sz)
   store(mem(HEAP-PTR-LBL), p, 0)

defn inc-heap-ptr (sz:Int) :
   inc-heap-ptr(long(sz))

;     Compound Value Instructions
;     ---------------------------
defn value-lbl (ins:tgt-DefIns) :
   val n = fresh-id()
   emit(tgt-TLabel(n))
   emit(ins)
   n   
defn float-lbl (f:Float) : value-lbl(tgt-DefFloat(f))
defn double-lbl (f:Float) : value-lbl(tgt-DefDouble(f))
defn string-lbl (s:String) : value-lbl(tgt-DefString(s))

;     Conversion of Primitive Operators
;     ---------------------------------
defn to-tgt-op (op:KLSOp) :
   switch {op == _} :
      ADD-OP : tgt-ADD-OP
      SUB-OP : tgt-SUB-OP
      MUL-OP : tgt-MUL-OP
      DIV-OP : tgt-DIV-OP
      MOD-OP : tgt-MOD-OP
      AND-OP : tgt-AND-OP
      OR-OP : tgt-OR-OP
      XOR-OP : tgt-XOR-OP
      SHL-OP : tgt-SHL-OP
      SHR-OP : tgt-SHR-OP
      ASHR-OP : tgt-ASHR-OP
      EQ-OP : tgt-EQ-OP
      NE-OP : tgt-NE-OP
      LT-OP : tgt-LT-OP
      GT-OP : tgt-GT-OP
      LE-OP : tgt-LE-OP
      GE-OP : tgt-GE-OP
      ULT-OP : tgt-ULT-OP
      UGT-OP : tgt-UGT-OP
      ULE-OP : tgt-ULE-OP
      UGE-OP : tgt-UGE-OP


;                  Variable Management
;                  ===================

;     Definition of VarTable
;     ----------------------
defclass VarTable <: Gettable<Int,List<tgt-Var>> &
                     Settable<Int,List<tgt-Var>>
defmulti make-var (v:VarTable, t:tgt-TgtType) -> tgt-Var
defmulti types (v:VarTable, n:Int) -> List<tgt-TgtType>
defmulti defs (v:VarTable) -> Vector<tgt-DefVar>

defn VarTable () :
   val defs = Vector<tgt-DefVar>()
   val table = HashTable<Int,List<tgt-Var>>({_})
   val type-table = HashTable<Int,tgt-TgtType>({_})
   
   new VarTable :
      defmethod make-var (this, t:tgt-TgtType) :
         val n = fresh-id()
         add(defs, tgt-DefVar(n, t))
         type-table[n] = t
         tgt-Var(n)
      defmethod set (this, n:Int, vs:List<tgt-Var>) :
         table[n] = vs
      defmethod get (this, n:Int) :
         table[n]
      defmethod types (this, x:Int) :
         for v in this[x] map :
            type-table[tgt-n(v)]
      defmethod defs (this) :
         defs

defn make-vars (v:VarTable, ts:List<tgt-TgtType>) :
   for t in ts map :
      make-var(v, t)

;     Implicit VarTable
;     -----------------
var VAR-TABLE : False|VarTable = false
defn VAR-TABLE! () : VAR-TABLE as VarTable
defn make-var (t:tgt-TgtType) : make-var(VAR-TABLE!(), t)
defn make-vars (ts:List<tgt-TgtType>) : map(make-var, ts)
defn env-vars (n:Int) : VAR-TABLE!()[n]
defn var-types (n:Int) : types(VAR-TABLE!(), n)






;               LoStanza Function Normalization
;               ===============================

;defn in-reverse<?T> (xs:Vector<?T>) :
;   for i in (length(xs) - 1) through 0 by -1 stream :
;      xs[i]
;
;defn normalize (comm:KLSComm) :
;   val def-vector = Vector<KeyValue<Int,KLSExp|KLSType>>()
;   defn fresh-var (value:KLSExp) :
;      val n = fresh-id()
;      add(def-vector, n => value)
;      KLSVar(n)
;
;   defn force-var (e:KLSExp) :
;      match(e) :
;         (e:KLSVar) : e
;         (e:KLSExp) : fresh-var(norm-exp(e))
;
;   defn norm-exp (e:KLSExp) :
;      map(force-var, e)
;
;   defn norm-comm (c:KLSComm) :
;      match(c) :
;         (c:KLSCall) :
;            map(norm-exp, c)
;         (c:KLSTCall) :
;            map(norm-exp, c)
;         (c:KLSSet) :
;            KLSSet(map(force-var, exp(c)),
;                   force-var(value(c)))                     
;         (c:KLSReturn) :
;            map(force-var, c)
;         (c:KLSLet) :
;            add(def-vector, n(c) => norm-exp(value(c)))
;            norm-comm(body(c))
;         (c:KLSLetVar) :
;            add(def-vector, n(c) => type(c))
;            norm-comm(body(c))
;         (c:KLSSeq) :
;            KLSSeq(norm-comm(a(c))
;                   normalize(b(c)))
;         (c:KLSIf) :
;            KLSIf(force-var(pred(c))
;                  normalize(conseq(c))
;                  normalize(alt(c)))
;         (c:KLSMatch) :
;            error("Untested.")
;            KLSMatch(map(force-var, args(c)),
;                     map(map{normalize, _}, branches(c)))
;         (c:KLSPrimComm) :
;            map(force-var, c)
;         (c) : c
;
;   var ret = norm-comm(comm)
;   for entry in in-reverse(def-vector) do :
;      ret = match(value(entry)) :
;         (v:KLSExp) : KLSLet(key(entry), v, ret)
;         (t:KLSType) : KLSLetVar(key(entry), t, ret)
;   ret


;                 LoStanza Call Conversion
;                 ========================

;defn convert-calls (c:KLSComm, gt:GlobalTable) :
;   defn direct (f:KLSVar) :
;      if function?(gt, n(f)) : n(f)
;      else : f
;   defn conv-comm (c:KLSComm) :
;      map(conv-comm, map(conv-exp, c))
;   defn conv-exp (e:KLSExp) :
;      match(map(conv-exp, e)) :
;         (e:KLSDo) :
;            KLSWDo(length(args(e)), direct(func-var(e)), args(e), type(e))
;         (e:KLSCallC) :
;            KLSWCallC(direct(func-var(e)), args(e), type(e))
;         (e:KLSCallS) :
;            error("Convert Stanza call.")               
;         (e) : e
;
;   conv-comm(c)


;                    Global Table
;                    ============

defclass GlobalTable <: Gettable<Int, GEntry>
defmulti add-global (gt:GlobalTable, n:Int) -> False
defmulti add-function (gt:GlobalTable, n:Int) -> False
defmulti add-type-object (gt:GlobalTable, n:Int) -> False
defmulti add-const (gt:GlobalTable, n:Int, v) -> False
defmulti add-ls-global (gt:GlobalTable, n:Int, t:KLSType) -> False
defmulti add-ls-function (gt:GlobalTable, n:Int) -> False
defmulti add-ls-extern (gt:GlobalTable, n:Int, t:KLSType, lbl:Symbol) -> False
defmulti global-var? (t:GlobalTable, n:Int) -> True|False
defmulti global-lbl (t:GlobalTable, n:Int) -> Int|Symbol
defmulti global-var-type (t:GlobalTable, n:Int) -> KLSType
defmulti root-vars (t:GlobalTable) -> Streamable<Int>
defmulti global-consts (t:GlobalTable) -> Streamable<Int>

defn global-var? (gt:GlobalTable, e:KLSExp) :
   match(e) :
      (e:KLSVar) : global-var?(gt, n(e))
      (e) : false

;Values: Globals, Consts, Externs
;Functions: Functions, Types
definterface GEntry
defstruct HiGlobal <: GEntry
defstruct HiFunction <: GEntry
defstruct HiType <: GEntry
defstruct GConst <: GEntry : (value)
defstruct LoGlobal <: GEntry : (type:KLSType)
defstruct LoFunction <: GEntry
defstruct GExtern <: GEntry : (type:KLSType, lbl:Symbol)

defn GlobalTable () :
   val entries = HashTable<Int, GEntry>({_})
   new GlobalTable :      
      defmethod add-global (this, n:Int) -> False :
         entries[n] = HiGlobal()
      defmethod add-function (this, n:Int) -> False :
         entries[n] = HiFunction()
      defmethod add-type-object (this, n:Int) -> False :
         entries[n] = HiType()
      defmethod add-const (this, n:Int, v) -> False :
         entries[n] = GConst(v)
      defmethod add-ls-global (this, n:Int, t:KLSType) -> False :
         entries[n] = LoGlobal(t)
      defmethod add-ls-function (this, n:Int) -> False :
         entries[n] = LoFunction()
      defmethod add-ls-extern (this, n:Int, t:KLSType, lbl:Symbol) -> False :
         entries[n] = GExtern(t, lbl)
      defmethod global-var? (this, n:Int) -> True|False :
         get?(entries, n, false) typeof HiGlobal|GConst|LoGlobal|GExtern
      defmethod global-lbl (this, n:Int) -> Int|Symbol :
         match(entries[n]) :
            (e:GExtern) : lbl(e)
            (e) : n
      defmethod global-var-type (this, n:Int) -> KLSType :
         match(entries[n]) :
            (e:LoGlobal|GExtern) : type(e)
            (e:HiGlobal|GConst) : KRefT(KTop())
      defmethod get (this, n:Int) :
         entries[n]      
      defmethod root-vars (this) :
         stream{key, _} $
         for e in entries filter :
            value(e) typeof HiGlobal|LoGlobal
      defmethod global-consts (this) :
         stream{key, _} $
         for e in entries filter :
            value(e) typeof GConst



;                     Type Analysis
;                     =============

;     Type Table Interface
;     --------------------
defclass TypeTable
defmulti add-type (tt:TypeTable, c:KDefType) -> False
defmulti add-ls-type (tt:TypeTable, c:KLSDefType) -> False
defmulti end-adds (tt:TypeTable) -> False

defmulti expand (tt:TypeTable, t:KLSType) -> List<tgt-TgtType> 
defmulti pad+expand (tt:TypeTable, t:KLSType) -> List<tgt-TgtType> 
defmulti offsets (tt:TypeTable, t:KLSType) -> List<Int>      
defmulti size (tt:TypeTable, t:KLSType) -> Int
defmulti count (tt:TypeTable, t:KLSType) -> Int
defmulti alignment (tt:TypeTable, t:KLSType) -> Int
defmulti field-offset (tt:TypeTable, f:Int) -> Int           
defmulti field-index (tt:TypeTable, f:Int) -> Int            
defmulti field-type (tt:TypeTable, f:Int) -> KLSType         
defmulti rfield (tt:TypeTable, n:Int) -> Int                 
defmulti tag (tt:TypeTable, n:Int) -> Int                    

;     Analysis
;     --------
defn TypeTable () :
   ;     Search through all types
   ;     ------------------------
   val lstypes = HashTable<Int, KLSDefType>({_})
   val types = HashTable<Int, KDefType>({_})

   ;     Compute Expansions
   ;     ------------------
   val struct-expansions = HashTable<Int, List<tgt-TgtType>>({_})
   defn expand (t:KLSType) :
      defn expand-struct (n:Int) :
         for f in fields(lstypes[n]) map-append :
            expand(type(f))
      match(t) :
         (t:KByteT) : list(tgt-BYTE-TYPE)
         (t:KIntT) : list(tgt-INT-TYPE)
         (t:KLongT) : list(tgt-LONG-TYPE)
         (t:KFloatT) : list(tgt-FLOAT-TYPE)
         (t:KDoubleT) : list(tgt-DOUBLE-TYPE)
         (t:KPtrT) : list(tgt-LONG-TYPE)
         (t:KRefT) : list(tgt-REF-TYPE)
         (t:KStructT) :
            if not key?(struct-expansions, n(t)) :
               struct-expansions[n(t)] = expand-struct(n(t))
            struct-expansions[n(t)]
         (t) : error("No expansion for ~." % [t])

   ;     Compute Field Types and Indices
   ;     -------------------------------
   val field-structs = HashTable<Int,Int>({_})
   val field-indices = HashTable<Int,Int>({_})
   val field-types = HashTable<Int,KLSType>({_})
   defn compute-field-stats () :
      for def in values(lstypes) do :
         for (f in fields(def), i in 0 to false) do :
            field-structs[n(f)] = n(def)
            field-indices[n(f)] = i
            field-types[n(f)] = type(f)
         if rfield(def) != false :
            val f = rfield(def) as StructField
            field-structs[n(f)] = n(def)
            field-indices[n(f)] = length(fields(def))
            field-types[n(f)] = type(f)

   ;     Compute Struct Tags
   ;     -------------------
   val tag-table = HashTable<Int,Int>({_})
   val tag-types = Vector<Int>()
   defn compute-struct-tags () :
      defn assign-next-tag (n:Int) :
         tag-table[n] = length(tag-types)
         add(tag-types, n)      
      assign-next-tag(FALSE-TYPE-ID)
      assign-next-tag(TRUE-TYPE-ID)
      for def in values(lstypes) do :
         assign-next-tag(n(def))
      for def in values(types) do :
         assign-next-tag(n(def))

   ;     Compute Alignments, Padding, and Size
   ;     -------------------------------------
   val pad+expansions = HashTable<Int, List<tgt-TgtType>>({_})
   val struct-alignments = HashTable<Int, Int>({_})
   val type-sizes = HashTable<Int,Int>({_})
   val field-offsets = HashTable<Int,Int>({_})

   defn type-size (t:KLSType) :
      match(t) :
         (t:KByteT) : 1
         (t:KIntT) : 4
         (t:KLongT) : 8
         (t:KFloatT) : 4
         (t:KDoubleT) : 8
         (t:KPtrT) : 8
         (t:KRefT) : 8
         (t:KUnknownT) : error("No size.")
         (t:KFnT) : error("No size.")
         (t:KStructT) :
            compute-struct(n(t)) when not key?(type-sizes, n(t))
            type-sizes[n(t)]

   defn type-alignment (t:KLSType) :
      match(t) :
         (t:KStructT) :
            compute-struct(n(t)) when not key?(struct-alignments, n(t))
            struct-alignments[n(t)]
         (t) : type-size(t)

   defn pad+expand (t:KLSType) :
      match(t) :
         (t:KStructT) :
            compute-struct(n(t)) when not key?(pad+expansions, n(t))
            pad+expansions[n(t)]
         (t) : expand(t)

   defn field-offset (f:Int) :
      if not key?(field-offsets, f) :
         compute-struct(field-structs[f])
      field-offsets[f]

   defn compute-struct (sn:Int) :
      ;Pad struct fields
      val def = lstypes[sn]
      val items = for f in fields(def) stream :
         Item(type-alignment(type(f)), n(f))         
      val [items*, aln] = match(rfield(def)) :
         (rf:False) : pad(items, 1)
         (rf:StructField) : pad(items, type-alignment(type(rf)))

      ;Compute struct alignment, field offsets, type sizes, and padded expansions
      var accum = 0
      val expansion = Vector<tgt-TgtType>()
      for x in items* do :
         match(x) :
            (x:Item) :
               val f = data(x) as Int
               val ft = field-types[f]
               field-offsets[f] = accum
               do(add{expansion, _}, pad+expand(ft))
               accum = accum + type-size(ft)
            (x:Padding) :
               switch {size(x) == _} :
                  1 : add(expansion, tgt-BYTE-TYPE)
                  4 : add(expansion, tgt-INT-TYPE)
               accum = accum + size(x)

      ;Record Rest Field offset
      if rfield(def) != false :
         val rf = rfield(def) as StructField
         field-offsets[n(rf)] = accum

      ;Record Size, Expansion, and Alignment
      type-sizes[sn] = accum         
      pad+expansions[sn] = to-list(expansion)
      struct-alignments[sn] = aln      

   
   ;     Return Table
   ;     ------------
   new TypeTable :
      defmethod add-type (this, c:KDefType) :
         types[n(c)] = c
      defmethod add-ls-type (this, c:KLSDefType) :
         lstypes[n(c)] = c
      defmethod end-adds (this) :
         compute-field-stats()
         compute-struct-tags()         
      defmethod expand (this, t:KLSType) :
         expand(t)
      defmethod count (this, t:KLSType) :
         length(expand(t))
      defmethod pad+expand (this, t:KLSType) :
         pad+expand(t)
      defmethod offsets (this, t:KLSType) :
         match(t) :
            (t:KStructT) :
               for f in fields(lstypes[n(t)]) map :
                  field-offset(n(f))
            (t) : list(0)
      defmethod size (this, t:KLSType) :
         type-size(t)
      defmethod alignment (this, t:KLSType) :
         type-alignment(t)
      defmethod field-offset (this, f:Int) :
         field-offset(f)
      defmethod field-type (this, f:Int) :
         field-types[f]
      defmethod field-index (this, f:Int) :
         field-indices[f]
      defmethod rfield (this, s:Int) :
         n(rfield(lstypes[s]) as StructField)
      defmethod tag (this, n:Int) :
         tag-table[n]
            

;                      Compilation
;                      ===========

definterface CResult
defmulti assign (xs:List<tgt-Var>, r:CResult) -> False
defmulti imms (r:CResult) -> List<tgt-Imm>
defmulti types (r:CResult) -> List<tgt-TgtType>
defn vars (r:CResult) -> List<tgt-Var> :
   val vs = make-vars(types(r))
   assign(vs, r)
   vs

definterface CSResult
defmulti assign (x:tgt-Var, r:CSResult) -> False
defmulti imm (r:CSResult) -> tgt-Imm
defn imm-var (r:CSResult) -> tgt-Var :
   val x = make-var(tgt-REF-TYPE)
   assign(x, r)
   x

definterface CLoc
defstruct PtrLoc <: CLoc :
   base: tgt-Imm
   offset: Int
   type: KLSType
defstruct ExpLoc <: CLoc :
   exp: KLSExp
defstruct SubExpLoc <: CLoc :
   exp: KLSExp
   index: Int
   count: Int
   type: KLSType

defn sublist<?T> (xs:List<?T>, i:Int, n:Int) :
   headn(tailn(xs, i), n)

defn compile (prog:KProg) -> tgt-Program :
   ;     Analysis
   ;     --------
   val gt = GlobalTable()
   val tt = TypeTable()

   for c in comms(prog) do :
      match(c) :
         (c:KDef) : add-global(gt, n(c))
         (c:KDefVar) : add-global(gt, n(c))
         (c:KDefn) : add-function(gt, n(c))
         (c:KDefTypeObject) : add-type-object(gt, n(c))
         (c:KDefConst) : add-const(gt, n(c), value(c))
         (c:KDefType) : add-type(tt, c)
         (c:KInit) : false
         (c:KLSDef) : add-ls-global(gt, n(c), type(c))
         (c:KLSDefCode) : add-ls-function(gt, n(c))
         (c:KExtern) : add-ls-extern(gt, n(c), type(c), lbl(c))
         (c:KLSDefType) : add-ls-type(tt, c)
         (c:KLSInit) : false
         
   end-adds(tt)         

   ;Retrieving the immediates for a global
   defn global-mem (n:Int, offset:Int) :
      match(global-lbl(gt, n)) :
         (l:Int) : mem(l, offset)
         (l:Symbol) : xmem(l, offset)
   defn global-mem (n:Int) :
      global-mem(n, 0)


   ;     Compiling Tables
   ;     ----------------
   defn compile-machine-state () :
      emit(tgt-DefData())
      
      ;Floating Point Zeros
      emit(tgt-TLabel(FLOAT-ZERO-LBL))
      emit(tgt-DefFloat(0.0))
      emit(tgt-TLabel(DOUBLE-ZERO-LBL))
      emit(tgt-DefDouble(0.0))
      
      ;Heap Labels
      emit(tgt-TLabel(HEAP-PTR-LBL))
      emit(tgt-DefLong(0))
      emit(tgt-TLabel(HEAP-LIM-LBL))
      emit(tgt-DefLong(0))
      
      ;Stack Labels
      emit(tgt-TLabel(STACK-PTR-LBL))
      emit(tgt-DefLong(0))
      emit(tgt-TLabel(STACK-LIM-LBL))
      emit(tgt-DefLong(0))

      emit(tgt-DefText())


   ;     Compiling Globals
   ;     -----------------
   defn compile-globals () :
      ;Sort all globals by alignment for packing
      val entries = Vector<Int>()
      do(add{entries, _}, root-vars(gt))
      sort-by-key!(entries, alignment{tt, global-var-type(gt, _)})

      ;Pad all items to ensure structures are aligned
      val items = let :      
         val xs = for e in entries stream :
            Item(alignment(tt, global-var-type(gt, e)), e)
         val [padded-xs, aln] = pad(xs, 1)
         padded-xs
         
      ;Start emission of table
      emit(tgt-DefData())
      for x in items do :
         match(x) :
            (x:Item) :
               val v = data(x) as Int
               emit(tgt-TLabel(v))
               for t in pad+expand(tt, global-var-type(gt, v)) do :
                  emit $ switch {t == _} :
                     tgt-BYTE-TYPE : tgt-DefByte(0)
                     tgt-INT-TYPE : tgt-DefInt(0)
                     tgt-LONG-TYPE : tgt-DefLong(0)
                     tgt-FLOAT-TYPE : tgt-DefFloat(0.0)
                     tgt-DOUBLE-TYPE : tgt-DefDouble(0.0)
                     tgt-REF-TYPE : tgt-DefLong(VOID-TAG)
            (x:Padding) :
               emit(tgt-DefSpace(size(x)))
      emit(tgt-DefText())
   

   ;     Compiling Entry Function
   ;     ------------------------
   defn compile-entry () :
      val var-table = VarTable()
      val ins-vector = Vector<tgt-Ins>()
      let-var INSTRUCTION-VECTOR = ins-vector :
         let-var VAR-TABLE = var-table :
            for c in comms(prog) do :
               match(c) :
                  (c:KDef) :
                     val exp = KSet(n(c), value(c), false)
                     imm(compile-exp(exp))
                  (c:KDefVar) :
                     if value(c) != false :
                        val exp = KSet(n(c), value(c) as KExp, false)
                        imm(compile-exp(exp))
                  (c:KInit) :
                     imm(compile-exp(exp(c)))
                  (c:KLSInit) :
                     compile-comm(comm(c))
                  (c) : false            
            return(list(long(0)))
            val n = fresh-id()
            emit(tgt-DefFn(n, defs(var-table), ins-vector))
            n

   ;     Compiling a HiStanza Function
   ;     -----------------------------
   defn compile-func (c:KDefn) :
      error("Not yet implemented.")

   ;     Compiling a Stanza Expression
   ;     -----------------------------
   defn compile-exp (e:KExp) -> CSResult :
      defn ret-imm (x:tgt-Imm) :
         new CSResult :
            defmethod imm (this) : x
            defmethod assign (x:tgt-Var, this) : set(x, imm(this))
      defn ret-to-var (f: tgt-Var -> False) :
         new CSResult :
            defmethod assign (x:tgt-Var, this) : f(x)
            defmethod imm (this) : imm-var(this)   
            
      match(e) :
         (e:KSet) :
            if global-var?(gt, n(e)) :
               store(global-mem(n(e)), imm(compile-exp(value(e))), 0)
            else :
               val x = head(env-vars(n(e)))
               assign(x, compile-exp(value(e)))
            ret-imm(long(tag(tt, FALSE-TYPE-ID) << 3 + MARKER-TAG))
         (e:KCast) : error("Not yet implemented.")
         (e:KCheckVoid) : error("Not yet implemented.")
         (e:KCheckLength) : error("Not yet implemented.")
         (e:KLet) :
            val def = def(e) as KDef
            val [n, v] = [n(def), value(def)]
            VAR-TABLE!()[n] = list(imm-var(compile-exp(v)))
            compile-exp(body(e))
         (e:KLetRec) : error("Not yet implemented.")
         (e:KSeq) : error("Not yet implemented.")
         (e:KMatch) : error("Not yet implemented.")
         (e:KObject) : error("Not yet implemented.")
         (e:KObjectGet) : error("Not yet implemented.")
         (e:KTypeObject) : error("Not yet implemented.")
         (e:KCall) :
            ret-to-var $ fn* (x) :
               val ys = map(imm{compile-exp(_)}, args(e))
               val f = match(func(e)) :
                  (f:Int) : global-mem(f)
                  (f:KExp) : imm(compile-exp(f))
               call(arity(e), list(x), f, ys)
         (e:KVar) :
            if global-var?(gt, n(e)) :
               ret-to-var $ fn* (x) :
                  load(x, global-mem(n(e)), 0)
            else :
               val vs = VAR-TABLE!()[n(e)]
               ret-imm(head(vs))
         (e:KPrim) : error("Not yet implemented.")
         (e:KLiteral) :
            match(value(e)) :
               (v:Int) : ret-imm(long(v << 3 + INT-TAG))
               (v) : error("Other literal types not yet implemented.")
         (e:KTuple) : error("Not yet implemented.")
         (e:KTupleGet) : error("Not yet implemented.")
         (e:KBox) : error("Not yet implemented.")
         (e:KBoxGet) : error("Not yet implemented.")
         (e:KBoxSet) : error("Not yet implemented.")
         (e:KClosure) : error("Not yet implemented.")
         (e:KBranchError) : error("Not yet implemented.")

   ;     Compiling a LoStanza Function
   ;     -----------------------------
   defn compile-ls-func (c:KLSDefCode) :
      val var-table = VarTable()
      val ins-vector = Vector<tgt-Ins>()

      ;Driver
      let-var INSTRUCTION-VECTOR = ins-vector :
         let-var VAR-TABLE = var-table :
         
            ;Add arguments to var table
            for (v in args(c), t in types(c)) do :
               var-table[v] = make-vars(expand(tt, t))

            ;Compile function prelude
            println("Stack switching untested.")
            args(map-append({var-table[_]}, args(c)))
            
            ;val defaultL = fresh-id()
            ;val bodyL = fresh-id()
            ;val num-free = make-var(tgt-LONG-TYPE)
            ;jstack-has-space(defaultL)
            ;switch-stack()
            ;args(var-table[args(c)])
            ;load(num-free, mem(NUM-FREE-STACKS-LBL), 0)
            ;jge(bodyL, num-free, long(1))
            ;call(0, List(), mem(EXTEND-STACK-ID), List())
            ;goto(bodyL)
            ;tlabel(defaultL)
            ;args(var-table[args(c)])
            ;tlabel(bodyL)
         
            ;Compile function body
            compile-comm(body(c))

            ;Emit function definition
            emit(tgt-DefFn(n(c), defs(var-table), ins-vector))

   ;     Compile a LoStanza Location
   ;     ---------------------------
   defn compile-loc (loc:KLoc) :
      defn loc-type (l:KLoc) :
         match(l) :
            (l:Value) :
               if global-var?(gt, exp(l)) :
                  val v = exp(l) as KLSVar
                  global-var-type(gt, n(v))
            (l:Deref|Deptr|Slot) : type(l)
            (l:Field) : field-type(tt, n(l))
            
      defn* loop (l:KLoc, off:Int, idx:Int) :
         match(l) :
            (l:Value) :
               if global-var?(gt, exp(l)) :
                  val n = n(exp(l) as KLSVar)
                  PtrLoc(global-mem(n,off), 0, loc-type(loc) as KLSType)
               else :
                  match(loc-type(loc)) :
                     (t:KLSType) : SubExpLoc(exp(l), idx, count(tt, t), t)
                     (t:False) : ExpLoc(exp(l))
            (l:Deref) :
               val p = head(imms(compile-exp(exp(l))))
               PtrLoc(p, off + 8 - REF-TAG, loc-type(loc) as KLSType)               
            (l:Deptr) :
               val p = head(imms(compile-exp(exp(l))))
               PtrLoc(p, off, loc-type(loc) as KLSType)               
            (l:Slot) :
               val b = head(imms(compile-exp(exp(l))))
               val i = head(imms(compile-exp(index(l))))
               val p = make-var(tgt-LONG-TYPE)
               mul(p, long(size(tt, type(l))), i)
               add(p, p, b)
               PtrLoc(p, off, loc-type(loc) as KLSType)
            (l:Field) :
               loop(base(l),
                    off + field-offset(tt, n(l)),
                    idx + field-index(tt, n(l)))
      loop(loc, 0, 0)              


   ;     Compile a LoStanza Command
   ;     --------------------------
   defn compile-comm (c:KLSComm) :      
      match(c) :
         (c:KLSCallComm) :
            assign(List(), compile-exp(exp(c)))
         (c:KLSTCallComm) :
            compile-tail-exp(exp(c))
         (c:KLSSet) :
            defn n! (e:KLSExp) : n(e as KLSVar)
            match(compile-loc(exp(c))) :
               (loc:PtrLoc) :
                  val ys = imms(compile-exp(value(c)))
                  for (o in offsets(tt, type(loc)), y in ys) do :
                     store(base(loc), y, offset(loc) + o)
               (loc:SubExpLoc) :
                  val xs = env-vars(n!(exp(loc)))
                  val sub-xs = sublist(xs, index(loc), count(loc))
                  assign(sub-xs, compile-exp(value(c)))
               (loc:ExpLoc) :
                  val xs = env-vars(n!(exp(loc)))
                  assign(xs, compile-exp(value(c)))
         (c:KLSLabel) :
            tlabel(n(c))
         (c:KLSGoto) :
            goto(n(c))
         (c:KLSReturn) :
            return(imms(compile-exp(exp(c))))
         (c:KLSLet) :
            VAR-TABLE!()[n(c)] = vars(compile-exp(value(c)))
            compile-comm(body(c))
         (c:KLSLetVar) :
            val ts = expand(tt, type(c))
            val vs = make-vars(ts)
            for (v in vs, t in ts) do :
               switch {t == _} :
                  tgt-BYTE-TYPE : set(v, byte(0))
                  tgt-INT-TYPE : set(v, int(0))
                  tgt-LONG-TYPE : set(v, long(0))
                  tgt-FLOAT-TYPE : load(v, mem(FLOAT-ZERO-LBL), 0)
                  tgt-DOUBLE-TYPE : load(v, mem(DOUBLE-ZERO-LBL), 0)
                  tgt-REF-TYPE : set(v, long(VOID-TAG))
            VAR-TABLE!()[n(c)] = vs
            compile-comm(body(c))
         (c:KLSIf) :
            val altL = fresh-id()
            val endL = fresh-id()
            val p = head(imms(compile-exp(pred(c))))
            jeq(altL, p, long(0))
            compile-comm(conseq(c))
            goto(endL)
            tlabel(altL)
            compile-comm(alt(c))
            tlabel(endL)
         (c:KLSSeq) :
            compile-comm(a(c))
            compile-comm(b(c))
         (c:KLSMatch) :
            error("Compile KLSMatch command.")
         (c:KLSPrimComm) :
            switch {op(c) == _} :
               SET-HEAP-PTR :
                  val x = head(imms(compile-exp(head(args(c)))))
                  store(mem(HEAP-PTR-LBL), x, 0)
               SET-HEAP-LIM :
                  val x = head(imms(compile-exp(head(args(c)))))
                  store(mem(HEAP-LIM-LBL), x, 0)
         (c:KLSSkip) :
            false

   ;     Compile an Expression
   ;     ---------------------
   defn compile-exp (e:KLSExp) -> CResult :
      ;Return immediates ys with given types ts
      defn ret-imms (ts:List<tgt-TgtType>, ys:List<tgt-Imm>) :
         new CResult :
            defmethod imms (this) : ys
            defmethod assign (xs:List<tgt-Var>, this) : do(set, xs, ys)
            defmethod types (this) : ts
      defn ret-imm (t:tgt-TgtType, y: tgt-Imm) :
         ret-imms(list(t), list(y))
      defn ret-imms (t:KLSType, ys:List<tgt-Imm>) :
         ret-imms(expand(tt, t), ys)

      ;Return to variables with given types ts
      defn ret-to-var (ts:List<tgt-TgtType>, f: List<tgt-Var> -> False) :
         new CResult :
            defmethod imms (this) : vars(this) 
            defmethod assign (xs:List<tgt-Var>, this) : f(xs)
            defmethod types (this) : ts
      defn ret-to-var (t:tgt-TgtType, f: tgt-Var -> False) :
         ret-to-var(list(t), f{head(_)})
      defn ret-to-var (t:KLSType, f: List<tgt-Var> -> False) :
         ret-to-var(expand(tt, t), f)
               
      match(e) :
         (e:KLSVar) :
            if global-var?(gt, n(e)) :
               compile-exp(KLSRead(Value(e)))
            else :
               ret-imms(var-types(n(e)), env-vars(n(e)))
         (e:KLSRef) :
            val st = KStructT(n(e))
            val sz = 8 + ceil8(size(tt, st))
            ret-to-var{tgt-REF-TYPE, _} $ fn* (x) :
               if sz > 0 :
                  ;Compile arguments
                  val args = map-append(imms{compile-exp(_)}, args(e))
                  ;Extend heap
                  extend-heap(sz)
                  add(x, heap-ptr(), long(REF-TAG))
                  inc-heap-ptr(sz)
                  ;Store into heap
                  store(x, long(tag(tt, n(e))), neg(REF-TAG))                  
                  for (o in offsets(tt, st), v in args) do :
                     store(x, v, o + 8 - REF-TAG)
               else :
                  error("Untested.")
                  shl(x, long(tag(tt, n(e))), long(3))
                  add(x, x, long(MARKER-TAG))
         (e:KLSRefArray) :
            val st = KStructT(n(e))
            val rf = rfield(tt, n(e))
            val rft = field-type(tt, rf)
            ret-to-var{tgt-REF-TYPE, _} $ fn* (x) :
               ;Compile length and arguments
               val len = head(imms(compile-exp(length(e))))
               val args = map-append(imms{compile-exp(_)}, args(e))               
               ;Extend heap
               val sz = make-var(tgt-LONG-TYPE)               
               mul(sz, long(size(tt, rft)), len)
               add(sz, sz, long(size(tt, st) + 8 + 7))
               bit-and(sz, sz, long(-8))
               extend-heap(sz)
               add(x, heap-ptr(), long(REF-TAG))
               inc-heap-ptr(sz)
               ;Store into heap
               store(x, long(tag(tt, n(e))), neg(REF-TAG))
               for (o in offsets(tt, st), v in args) do :
                  store(x, v, o + 8 - REF-TAG)
         (e:KLSStruct) :
            ;Compile arguments
            val args = map-append(imms{compile-exp(_)}, args(e))
            ret-imms(KStructT(n(e)), args)
         (e:KLSPtr) :         
            match(compile-loc(exp(e))) :
               (loc:PtrLoc) :
                  if offset(loc) == 0 :
                     ret-imm(tgt-LONG-TYPE, base(loc))
                  else :
                     ret-to-var{tgt-LONG-TYPE, _} $ fn* (x) :
                        add(x, base(loc), long(offset(loc)))                  
               (loc:SubExpLoc) :
                  val vs = env-vars(n(exp(loc) as KLSVar))
                  val v = head(tailn(vs, index(loc)))
                  ret-to-var{tgt-LONG-TYPE, _} $ fn* (x) :
                     addr(x, tgt-n(v))
               (loc:ExpLoc) :
                  val vs = env-vars(n(exp(loc) as KLSVar))
                  ret-to-var{tgt-LONG-TYPE, _} $ fn* (x) :
                     addr(x, tgt-n(head(vs)))
         (e:KLSRead) :
            match(compile-loc(exp(e))) :
               (loc:PtrLoc) :
                  ret-to-var{type(loc), _} $ fn* (xs) :
                     for (x in xs, o in offsets(tt, type(loc))) do :
                        load(x, base(loc), offset(loc) + o)
               (loc:SubExpLoc) :
                  val xs = imms(compile-exp(exp(loc)))
                  val sub-xs = sublist(xs, index(loc), count(loc))
                  ret-imms(type(loc), sub-xs)
               (loc:ExpLoc) :
                  compile-exp(exp(loc))
         (e:KLSWCall) :
            ret-to-var{type(e), _} $ fn* (xs) :
               val ys = map-append(imms{compile-exp(_)}, args(e))
               val f = match(func(e)) :
                  (f:Int) : global-mem(f)
                  (f:KLSExp) : head(imms(compile-exp(f)))
               call(arity(e), xs, f, ys)
         (e:KLSCallC) :
            ret-to-var{type(e), _} $ fn* (xs) :
               val ys = map-append(imms{compile-exp(_)}, args(e))
               val f = match(func(e)) :
                  (f:Int) : global-mem(f)
                  (f:KLSExp) : head(imms(compile-exp(f)))
               ffi-call(xs, f, ys)
         (e:KLSWCallClosure) :
            error("Untested.")
            ret-to-var{type(e), _} $ fn* (xs) :
               val ys = map-append(imms{compile-exp(_)}, args(e))
               val f = head(imms(compile-exp(func(e))))
               val code = make-var(tgt-LONG-TYPE)
               load(code, f, 8 - REF-TAG)
               call(arity(e), xs, code, List(f, ys))
         (e:KLSSizeof) :
            ret-imm(tgt-LONG-TYPE, long(size(tt, type(e))))
         (e:KLSTagof) :
            ret-imm(tgt-LONG-TYPE, long(tag(tt, n(e))))
         (e:KLSConv) :
            ret-to-var{type(e), _} $ fn* (xs) :
               val y = head(imms(compile-exp(exp(e))))
               conv(head(xs), y)
         (e:KLSPrim) :
            ret-to-var{type(e), _} $ fn* (xs) :
               switch {op(e) == _} :
                  GET-HEAP-LIM :
                     load(head(xs), mem(HEAP-LIM-LBL), 0)
                  GET-HEAP-PTR :
                     load(head(xs), mem(HEAP-PTR-LBL), 0)
                  else :
                     val ys = map-append(imms{compile-exp(_)}, args(e))
                     val op = to-tgt-op(op(e))
                     binop(head(xs), op, ys[0], ys[1])
         (e:KLSLitByte) :
            ret-imm(tgt-BYTE-TYPE, byte(value(e)))
         (e:KLSLitInt) :
            ret-imm(tgt-INT-TYPE, int(value(e)))
         (e:KLSLitLong) :
            ret-imm(tgt-LONG-TYPE, long(value(e)))
         (e:KLSLitFloat) :
            ret-to-var{tgt-FLOAT-TYPE, _} $ fn* (x) :
               load(x, mem(float-lbl(value(e))), 0)
         (e:KLSLitDouble) :
            ret-to-var{tgt-DOUBLE-TYPE, _} $ fn* (x) :
               load(x, mem(double-lbl(value(e))), 0)
         (e:KLSLitString) :
            ret-imm(tgt-LONG-TYPE, mem(string-lbl(value(e))))
         (e) :
            error("No branch defined for ~" % [e])


   ;     Compile a Tail Call
   ;     -------------------
   defn compile-tail-exp (e:KLSExp) -> False :
      match(e) :
         (e:KLSWCall) :
            val ys = map-append(imms{compile-exp(_)}, args(e))
            val f = match(func(e)) :
               (f:Int) : global-mem(f)
               (f:KLSExp) : head(imms(compile-exp(f)))
            tcall(arity(e), f, ys)
         (e:KLSWCallClosure) :
            error("Untested.")
            val ys = map-append(imms{compile-exp(_)}, args(e))
            val f = head(imms(compile-exp(func(e))))
            val code = make-var(tgt-LONG-TYPE)
            load(code, f, 8 - REF-TAG)
            tcall(arity(e), code, List(f, ys))
         (e) :
            error("Not a legal tail expression: ~" % [e])


   ;     Compile Functions
   ;     -----------------
   defn compile-functions () :
      for c in comms(prog) do :
         match(c) :
            (c:KDefn) : compile-func(c)
            (c:KDefTypeObject) : error("Not yet implemented.")
            (c:KLSDefCode) : compile-ls-func(c)
            (c) : false
      

   ;     Driver
   ;     ------
   val def-ins-vector = Vector<tgt-DefIns>()
   let-var DEF-INS-VECTOR = def-ins-vector :
      compile-machine-state()
      compile-globals()
      val entry = compile-entry()
      compile-functions()
      tgt-Program(def-ins-vector, entry)