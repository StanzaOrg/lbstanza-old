defpackage stz/test-reg-alloc-reader :
  import core
  import arg-parser
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-block-ir
  import stz/reg-alloc-reader  
  import stz/reg-alloc-errors
  import stz/reg-alloc-model-analysis
  import stz/reg-alloc-blocks
  import stz/reg-alloc-engine
  import stz/reg-alloc-block-engine
  import stz/reg-alloc-liveness
  import stz/reg-alloc-port-prefs
  import stz/reg-alloc-block-analysis
  import stz/reg-alloc-annotations
  import stz/reg-alloc-allocation
;  import stz/reg-alloc-assignment
;  import stz/reg-alloc-assignment-table
;  import stz/reg-alloc-shuffle
;  import stz/reg-alloc-datastructures  
  import stz/printing-utils

;============================================================
;================== For Development =========================
;============================================================

within (package,sig) = set-stack-trace-filter() :
  package != `core

;Analyze the models directly
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "analyze-models"
;  "testdata/reg-alloc-models01.txt"]

;Analyze an entire program
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "analyze-prog"
;  "testdata/reg-alloc-ex1.ir"]

;Analyze a block at a time
set-command-line-arguments $ [
  "dev-reg-alloc"
  "analyze-block"
  "testdata/reg-alloc-blocks01.txt"]

;Analyze some shuffle inputs
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "analyze-shuffle"
;  "testdata/reg-alloc-shuffle01.txt"]

;============================================================
;================== Analyze Block Action ====================
;============================================================

defn analyze-block-action (cmdargs:CommandArgs) :
  ;Retrieve filter on block names.
  val names = get?(cmdargs,"named",false)
  defn keep? (b:AnalyzeBlock) :
    match(names:Tuple<String>) : contains?(names, to-string(name(b)))
    else : true
  
  val filename = arg(cmdargs,0)
  val forms = reader/read-file(filename)
  val [blocks, models] = parse-blocks-and-models(forms)
  val model-props = analyze-models(models)
  val model-analyzer = ModelAnalyzer(models, model-props)
  for (b in blocks, i in 0 to false) do :
    if keep?(b) :
      println("\n") when i > 0
      analyze(b, models, model-props, model-analyzer)

defn analyze (b:AnalyzeBlock,
              models:Tuple<OperationModel>,
              mprops:Vector<ModelProperties>,
              manalyzer:ModelAnalyzer) :
  ;Load into block engine.
  val be = load-block(block(b), models, mprops, manalyzer)

  ;Display input.
  println("===== Block %_ =====" % [name(b)])
  println(be)

  ;Annotate block
  println("\n\n===== Annotation =====")
  annotate-block(be)
  println(be)

  ;Allocate registers
  println("\n\n===== Allocation =====")
  allocate-block(be, 6, 6)
  println(be)
  
  ;;Assign registers
  ;println("\n\n===== Assignment =====")
  ;val at = AssignmentTable(ResourceProvider(16,16,20))
  ;assign-registers(be, at)
  ;println(be)


;Parse a list of AnalyzeModel structures from the given forms.
defn parse-blocks-and-models (forms) -> [Tuple<AnalyzeBlock>, Tuple<OperationModel>] :
  match-syntax[reg-alloc-test-syntax](forms) :
    (?blocks:#analyze-block ...
     ?models:#model! ...) :
      [to-tuple(blocks), to-tuple(models)]
    (_ ...) :
      throw(RegAllocSyntaxError(false, "Invalid file."))
  
;============================================================
;================= Analyze Prog Action ======================
;============================================================

defn analyze-prog-action (cmdargs:CommandArgs) :
  val filename = arg(cmdargs,0)
  val forms = reader/read-file(filename)
  val [prog, models] = parse-prog-and-models(forms)

      
  println("===== Input =====")    
  println("%_\n" % [prog])
  for m in models do :
    println("%_\n" % [m])

  val engine = RegAllocEngine(prog, models)
  println("\n\n===== Engine =====")
  println(engine)

  println("\n\n==== Analyze Basic Blocks =====")
  analyze-basic-blocks(engine)
  println(engine)

  println("\n\n==== Compute Liveness =====")
  compute-live(engine)
  println(engine)

  println("\n\n===== Compute Port Preferences =====")
  compute-port-prefs(engine)
  println(engine)

  fatal("Not yet implemented")
  ;<comment>

  println("\n\n===== Block Analysis =====")
  analyze-blocks(engine)  
  ;<comment>

;Parse the given forms as a program combined with models.
defn parse-prog-and-models (forms:List) -> [Program, Tuple<OperationModel>] :
  match-syntax[reg-alloc-ir](forms) :
    (?prog:#prog
     ?models:#model! ...) :
      [prog, to-tuple(models)]
    (_ ...) :
      throw(RegAllocSyntaxError(false, "Invalid file."))  

;============================================================
;================ Analyze Model Action ======================
;============================================================

defn analyze-model-action (cmdargs:CommandArgs) :
  val filename = arg(cmdargs,0)
  val parsed = parse-models(reader/read-file(filename))
  for (am in parsed, i in 0 to false) do :
    println("\n") when i > 0
    analyze(am)

;Analyze a single model.
defn analyze (am:AnalyzeModel) :
  println("===== Model %_ =====" % [name(am)])
  println("Model:\n%_" % [Indented(model(am))])
  for (ctxt in contexts(am), i in 1 to false) do :
    println("Context %_: %_" % [i, ctxt])
    val result = used-registers(model(am), ctxt)
    within indented() :
      println("Result: %_" % [result])

;Parse a list of AnalyzeModel structures from the given forms.
defn parse-models (forms) -> Tuple<AnalyzeModel> :
  to-tuple $ parse-syntax[reg-alloc-test-syntax / #analyze-model ...](forms)  

;============================================================
;================= Analyze Shuffle Action ===================
;============================================================

defn analyze-shuffle-action (cmdargs:CommandArgs) :
  fatal("Not yet implemented")
  ;<comment>
  val filename = arg(cmdargs, 0)
  val parsed = parse-shuffles(reader/read-file(filename))
  val engine = dummy-shuffle-engine()
  for (item in parsed, i in 0 to false) do :
    println("\n") when i > 0
    analyze(engine, item)

;Create a dummy shuffle engine.
defn dummy-shuffle-engine () -> ShuffleEngine :
  ShuffleEngine(ResourceProvider(16,16,20))

;Analyze a single shuffle.
defn analyze (engine:ShuffleEngine,shuf:AnalyzeShuffle) :
  println("===== Shuffle %_ =====" % [name(shuf)])
  println(shuf)
  println("")
  
  val category = categorize(engine, inputs(shuf), outputs(shuf))
  println("Category: %_" % [category])
  println("")

  ;Load problem into engine.
  load-problem(engine,
               vars(shuf),
               inputs(shuf),
               saved(shuf),
               outputs(shuf))

  ;Print all registers to avoid.
  if any?({_ is AnyReg|AnyFReg}, outputs(shuf)) :
    println("Registers to avoid:")
    for (v in vars(shuf), output in outputs(shuf), i in 0 to false) do :
      if output is AnyReg|AnyFReg :
        val r = avoid(engine, i)
        println("  V%_ should avoid %_" % [v, r])
    println("")
    
  ;Perform the shuffle.
  else :
    println("Shuffle statements:")
    defn emit (stmt:ProgramStmt) :
      println(Indented(stmt))
    shuffle(engine,
            outputs(shuf) as Tuple<Reg|FReg>,
            free-reg(shuf),
            free-freg(shuf),
            emit)
    println("")        

;Parse a list of AnalyzeShuffle structures from the given forms.
defn parse-shuffles (forms) -> Tuple<AnalyzeShuffle> :
  to-tuple $ parse-syntax[reg-alloc-test-syntax / #analyze-shuffle ...](forms)
  ;<comment>

;============================================================
;==================== Testing Syntaxes ======================
;============================================================

;------------------------------------------------------------
;----------------------- Structures -------------------------
;------------------------------------------------------------

;Represents a model to analyze, and the contexts under
;which to analyze them.
defstruct AnalyzeModel :
  name: Symbol
  model: OperationModel
  contexts: Tuple<UsageContext>

;Represents a single block to analyze.
defstruct AnalyzeBlock :
  name:Symbol
  block:BlockStmts

;Represents a shuffle to analyze.
defstruct AnalyzeShuffle :
  name:Symbol
  vars:Tuple<Int>
  inputs:Tuple<Register>
  saved:Tuple<True|False>
  outputs:Tuple<Location>
  free-reg:Reg|False
  free-freg:FReg|False

defmethod print (o:OutputStream, s:AnalyzeShuffle) :
  defn input-str (v:Int, input:Register, saved:True|False) :
    val save-str = " (saved)" when saved else ""
    "V%_:%_%_" % [v, input, save-str]
  val items = [
    "inputs: (%,)" % [seq(input-str, vars(s), inputs(s), saved(s))]
    "outputs: (%,)" % [outputs(s)]
    falseable-field("free-reg", free-reg(s))
    falseable-field("free-freg", free-freg(s))]
  print(o, "analyze-shuffle %_%_" % [name(s), colon-field-list(items)])

;------------------------------------------------------------
;-------------------- Syntax Definition ---------------------
;------------------------------------------------------------

;Syntax for representing a model to analyze.
defsyntax reg-alloc-test-syntax :
  import (int!, symbol!, blockstmts!, register, reg, freg, varid, loc) from reg-alloc-ir
  public import model! from reg-alloc-ir

  public defproduction analyze-model: AnalyzeModel
  defrule analyze-model = (analyze ?name:#symbol! :
                             ?model:#model!
                             ?ctxts:#usage-ctxt! ...) :
    AnalyzeModel(name, model, to-tuple(ctxts))

  public defproduction analyze-block: AnalyzeBlock
  defrule analyze-block = (analyze-block ?name:#symbol! :
                             ?block:#blockstmts!) :
    AnalyzeBlock(name, block)

  public defproduction analyze-shuffle: AnalyzeShuffle
  defrule analyze-shuffle = (analyze-shuffle ?name:#symbol! :
                               inputs: (?shuf-inputs:#shuffle-input ...)
                               outputs: (?outputs:#loc ...)
                               ?free-reg:#free-reg?
                               ?free-freg:#free-freg?) :
    val vars = Vector<Int>()
    val inputs = Vector<Register>()
    val saved = Vector<True|False>()
    for [v, input, save] in shuf-inputs do :
      add(vars, v)
      add(inputs, input)
      add(saved, save)
    AnalyzeShuffle(name,
                   to-tuple(vars),
                   to-tuple(inputs),
                   to-tuple(saved),
                   to-tuple(outputs),
                   free-reg,
                   free-freg)

  defproduction shuffle-input: [Int, Register, True|False]
  defrule shuffle-input = (?v:#varid : ?r:#register ?s:#saved?) : [v, r, s]

  defproduction saved?: True|False
  defrule saved? = ((saved)) : true
  defrule saved? = () : false

  defproduction free-reg?: Reg|False
  defrule free-reg? = (free-reg: ?r:#reg)
  defrule free-reg? = () : false

  defproduction free-freg?: FReg|False
  defrule free-freg? = (free-freg: ?r:#freg)
  defrule free-freg? = () : false
  
  defproduction usage-ctxt: UsageContext
  defrule usage-ctxt = (UsageContext(args = [?args:#int! ...],
                                     killed = [?killed:#int! ...])) :
    UsageContext(to-tuple(args), to-tuple(killed))

  defproduction usage-ctxt!: UsageContext
  defrule usage-ctxt! = (?c:#usage-ctxt)
  fail-if usage-ctxt! = () :
    RegAllocSyntaxError(closest-info(), "Invalid usage context syntax.")

  

;============================================================
;==================== Launcher ==============================
;============================================================

;Launch!
simple-command-line-cli(false, commands, "analyze-models", false, false) where :
  val commands = [
    Command(
      "analyze-models", OneArg, "the models to analyze",
      [],
      "Analyze a text file containining operation models.",
      analyze-model-action)
    Command(
      "analyze-prog", OneArg, "the program to analyze",
      [],
      "Analyze a text file containing the regalloc program.",
      analyze-prog-action)
    Command(
      "analyze-block", OneArg, "the blocks to analyze",
      [Flag("named"
            AtLeastOneFlag,
            OptionalFlag,
            "A list of names of tests to execute.")],
      "Analyze a text file containing blocks to analyze."
      analyze-block-action)
    Command(
      "analyze-shuffle", OneArg, "the shuffle to analyze",
      []
      "Analyze a text fiel containing shuffle inputs."
      analyze-shuffle-action)]