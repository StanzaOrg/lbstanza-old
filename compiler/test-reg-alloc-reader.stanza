defpackage stz/test-reg-alloc-reader :
  import core
  import arg-parser
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-test-syntax
  import stz/reg-alloc-model-analysis
  import stz/reg-alloc-model-check
  import stz/reg-alloc-program-check
  import stz/reg-alloc-block
  import stz/reg-alloc-basic-blocks
  import stz/reg-alloc-liveness
  import stz/reg-alloc-port-prefs
  import stz/reg-alloc-annotations
  import stz/reg-alloc-allocation
  import stz/reg-alloc-assignment
  import stz/reg-alloc-model-env
  import stz/reg-alloc-simple-model-env
  import stz/reg-alloc-simple-stmt-processor
;  import stz/reg-alloc-shuffle
  import stz/reg-alloc-datastructures
  import stz/reg-alloc-add-temp-vars

;============================================================
;================== For Development =========================
;============================================================

within (package,sig) = set-stack-trace-filter() :
  package != `core

;Check models for errors
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "check-models"
;  "testdata/reg-alloc-models01.txt"]

;Analyze the models directly
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "analyze-models"
;  "testdata/reg-alloc-models01.txt"]

;Analyze an entire program
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "analyze-programs"
;  "testdata/reg-alloc-progs.ir"]

;Analyze a block at a time
set-command-line-arguments $ [
  "dev-reg-alloc"
  "analyze-block"
  "testdata/reg-alloc-blocks01.txt"]

;Analyze some shuffle inputs
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "analyze-shuffle"
;  "testdata/reg-alloc-shuffle01.txt"]

;Check program for errors
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "check-programs"
;  "testdata/reg-alloc-progs.ir"]

;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "preprocess-programs"
;  "testdata/reg-alloc-progs.ir"]

;============================================================
;=================== Check Model Action =====================
;============================================================

defn check-model-action (cmdargs:CommandArgs) :
  val filename = arg(cmdargs,0)
  val models = parse-models(reader/read-file(filename))
  do(check, models)

defn check (am:AnalyzeModel) :
  ;Print the model we're checking.
  println("===== Model %_ =====" % [name(am)])
  println(model(am))
  println("")
  
  val resources = ResourceProvider(num-regs(am), num-fregs(am), 0)
  val checker = ModelChecker(resources, num-regs(am), num-fregs(am))
  try :
    check-model(checker, model(am))
    println("Model is valid.")
  catch (e) :
    println(e)
  println("")

;============================================================
;================ Analyze Model Action ======================
;============================================================

defn analyze-model-action (cmdargs:CommandArgs) :
  val filename = arg(cmdargs,0)
  val models = parse-models(reader/read-file(filename))
  do(analyze, models)

;Analyze a single model.
defn analyze (am:AnalyzeModel) :
  label break :
    ;Print the model we're analyzing.
    println("===== Model %_ =====" % [name(am)])
    println(model(am))
    println("")

    val resources = ResourceProvider(num-regs(am), num-fregs(am), 0)
    val checker = ModelChecker(resources, num-regs(am), num-fregs(am))

    try :
      check-model(checker, model(am))
      println("Model is valid.\n")      
    catch (e) :
      println(e)
      println("")
      break()

    ;Analyze the model.
    val properties = analyze(model(am))
    println(properties)
    println("")

;============================================================
;=================== Check Program Action ===================
;============================================================

defn check-program-action (cmdargs:CommandArgs) :
  label break :
    val filename = arg(cmdargs,0)
    val programs-and-models = parse-progs-and-models(reader/read-file(filename))
    
    ;Confirm that models are okay.
    val models-okay? = check-all-models(num-regs(programs-and-models)
                                        num-fregs(programs-and-models)
                                        models(programs-and-models))
    break() when not models-okay?

    ;Check each program.
    val env = SimpleModelEnv(models(programs-and-models))
    for prog in programs(programs-and-models) do :
      check-program(num-regs(programs-and-models),
                    num-fregs(programs-and-models)
                    prog, env, true)

;Helper: Check all the models and return true if they are okay.
defn check-all-models (num-regs:Int
                       num-fregs:Int,
                       models:Seqable<OperationModel>) -> True|False :
  val resources = ResourceProvider(num-regs, num-fregs, 0)
  val checker = ModelChecker(resources, num-regs, num-fregs)
  var okay?:True|False = true
  for m in models do :
    try :
      check-model(checker,m)
    catch (e) :
      println(e)
      okay? = false
  okay?

;Helper: Check the program.
defn check-program (num-regs:Int,
                    num-fregs:Int,
                    prog:NameAndProgram,
                    env:ModelEnv,
                    forbid-repetition?:True|False)  -> [
                    Program,
                    ResourceProvider,
                    True|False] :
  val resources = ResourceProvider(num-regs,
                                   num-fregs,
                                   length(vars(program(prog))))

  println("===== Program %_ =====" % [name(prog)])
  println(program(prog))

  var okay?:True|False = true

  println("\nCheck Allowing Repetition:")
  try :
    check-program(program(prog), true, env, resources)
    println("Program is wellformed.\n")
  catch (e) :
    println("%_\n" % [e])    
    okay? = false

  if forbid-repetition? :
    println("\nCheck Forbidding Repetition:")
    try :
      check-program(program(prog), false, env, resources)
      println("Program is wellformed.\n")
    catch (e) :
      println("%_\n" % [e])
      okay? = false

  [program(prog), resources, okay?]

;============================================================
;================ Preprocess Program Action =================
;============================================================

defn preprocess-program-action (cmdargs:CommandArgs) :
  val filename = arg(cmdargs, 0)
  within (program, resources, env) = preprocess-programs(filename) :
    false

defn preprocess-programs (return: (Program, ResourceProvider, ModelEnv) -> ?
                          filename:String) -> False :
  label break :
    val programs-and-models = parse-progs-and-models(reader/read-file(filename))
    
    ;Confirm that models are okay.
    val models-okay? = check-all-models(num-regs(programs-and-models)
                                        num-fregs(programs-and-models)
                                        models(programs-and-models))
    break() when not models-okay?

    ;Compute the model properties, and create the model environment.
    val model-props = analyze-models(models(programs-and-models))
    val env = SimpleModelEnv(models(programs-and-models),
                             to-tuple(model-props))

    ;Check each program.
    for prog in programs(programs-and-models) do :
      label break :
        val [program, resources, okay?] = 
          check-program(num-regs(programs-and-models),
                        num-fregs(programs-and-models)
                        prog, env, false)
        break() when not okay?

        val tempvars = AddTempVars(resources)
        val new-program = process(tempvars, program, env)
        println("===== Preprocessed =====")
        println(new-program)
        println("")

        println("\nCheck Forbidding Repetition:")
        try :
          check-program(new-program, false, env, resources)
          println("Program is wellformed.\n")
        catch (e) :
          println("%_\n" % [e])

        return(new-program, resources, env)

;============================================================
;================= Analyze Prog Action ======================
;============================================================
defn analyze-prog-action (cmdargs:CommandArgs) :
  val filename = arg(cmdargs, 0)
  within (program, resources, env) = preprocess-programs(filename) :

    println("=== Basic Blocks ===")  
    val blocks = to-vector<Block> $ analyze-basic-blocks(program, env)
    do(println, blocks)

    println("=== Compute Liveness ===")
    compute-live(program, blocks)
    do(println, blocks)

    println("\n\n===== Compute Port Preferences =====")
    compute-port-prefs(program, env, blocks)
    do(println, blocks)
;
;  fatal("Not yet implemented")
;  ;<comment2>
;
;  println("\n\n===== Block Analysis =====")
;  analyze-blocks(engine)  
;  ;<comment2>

;============================================================
;================== Analyze Block Action ====================
;============================================================

defn analyze-block-action (cmdargs:CommandArgs) :
  ;Retrieve filter on block names.
  val names = get?(cmdargs,"named",false)
  defn keep? (b:NameAndBlock) -> True|False :
    match(names:Tuple<String>) : contains?(names, to-string(name(b)))
    else : true

  label break :
    val filename = arg(cmdargs,0)  
    val ablocks = parse-blocks-and-models(reader/read-file(filename))
    val okay? = check-all-models(num-regs(ablocks), num-fregs(ablocks), models(ablocks))
    break() when not okay?

    ;Create the model environment.
    val model-props = analyze-models(models(ablocks))
    val env = SimpleModelEnv(models(ablocks), to-tuple(model-props))

    ;Check and then analyze each block.
    for block in filter(keep?,blocks(ablocks)) do :
      val resources = ResourceProvider(num-regs(ablocks),
                                       num-fregs(ablocks),
                                       length(vars(block)))

      println("===== Block %_ =====" % [name(block)])
      println(block)
      val okay? =
        try :
          check-program-fragment(vars(block),
                                 stmts(block),
                                 env,
                                 resources)
          true
        catch (e) :
          println(e)
          false

      if okay? :
        analyze(block, env, resources, num-regs(ablocks), num-fregs(ablocks))

defn analyze (block:NameAndBlock,
              models:ModelEnv,
              resources:ResourceProvider,
              num-regs:Int,
              num-fregs:Int) :
  ;Create a testing statement processor.
  println("\n===== Annotated =====")
  var proc:SimpleStmtProcessor = SimpleStmtProcessor(block)
  annotate-block(proc, models)
  val annotated = processed-block(proc)
  println(annotated)

  println("\n===== Allocated =====")
  proc = SimpleStmtProcessor(annotated)
  allocate-block(proc, models, num-regs, num-fregs)
  val allocated = processed-block(proc)
  println(allocated)

  println("\n===== Assigned =====")
  proc = SimpleStmtProcessor(allocated)
  assign-registers(proc, models, resources)
  val assigned = processed-block(proc)
  println(assigned)

;============================================================
;================= Analyze Shuffle Action ===================
;============================================================
;<comment>
defn analyze-shuffle-action (cmdargs:CommandArgs) :

  val filename = arg(cmdargs, 0)
  val parsed = parse-shuffles(reader/read-file(filename))
  val engine = dummy-shuffle-engine()
  for (item in parsed, i in 0 to false) do :
    println("\n") when i > 0
    analyze(engine, item)

;Create a dummy shuffle engine.
defn dummy-shuffle-engine () -> ShuffleEngine :
  ShuffleEngine(ResourceProvider(16,16,20))

;Analyze a single shuffle.
defn analyze (engine:ShuffleEngine,shuf:AnalyzeShuffle) :
  println("===== Shuffle %_ =====" % [name(shuf)])
  println(shuf)
  println("")
  
  val category = categorize(engine, inputs(shuf), outputs(shuf))
  println("Category: %_" % [category])
  println("")

  ;Load problem into engine.
  load-problem(engine,
               vars(shuf),
               inputs(shuf),
               saved(shuf),
               outputs(shuf))

  ;Print all registers to avoid.
  if any?({_ is AnyReg|AnyFReg}, outputs(shuf)) :
    println("Registers to avoid:")
    for (v in vars(shuf), output in outputs(shuf), i in 0 to false) do :
      if output is AnyReg|AnyFReg :
        val r = avoid(engine, i)
        println("  V%_ should avoid %_" % [v, r])
    println("")
    
  ;Perform the shuffle.
  else :
    println("Shuffle statements:")
    defn emit (stmt:ProgramStmt) :
      println(Indented(stmt))
    shuffle(engine,
            outputs(shuf) as Tuple<Reg|FReg>,
            free-reg(shuf),
            free-freg(shuf),
            emit)
    println("")        
;<comment>

;============================================================
;==================== Launcher ==============================
;============================================================

;Launch!
simple-command-line-cli(false, commands, false, false, false) where :
  val commands = [
    Command(
      "check-models", OneArg, "the models to check",
      [],
      "Check all models in a text file containing models."
      check-model-action)
    Command(
      "analyze-models", OneArg, "the models to analyze",
      [],
      "Analyze a text file containining operation models.",
      analyze-model-action)
    Command(
      "check-programs", OneArg, "the prorams to check",
      [],
      "Check all programs in a text file."
      check-program-action)
    Command(
      "preprocess-programs", OneArg, "the programs to check",
      [],
      "Preprocess all programs in a text file."
      preprocess-program-action)
    Command(
      "analyze-programs", OneArg, "the programs to analyze",
      [],
      "Analyze a text file containing regalloc programs.",
      analyze-prog-action)
    Command(
      "analyze-block", OneArg, "the blocks to analyze",
      [Flag("named"
            AtLeastOneFlag,
            OptionalFlag,
            "A list of names of tests to execute.")],
      "Analyze a text file containing blocks to analyze."
      analyze-block-action)
    ;Command(
    ;  "analyze-shuffle", OneArg, "the shuffle to analyze",
    ;  []
    ;  "Analyze a text file containing shuffle inputs."
    ;  analyze-shuffle-action)

  ]