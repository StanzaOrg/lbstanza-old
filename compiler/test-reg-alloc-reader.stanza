defpackage stz/test-reg-alloc-reader :
  import core
  import arg-parser
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-test-syntax
  
;  import stz/reg-alloc-block-ir
;  import stz/reg-alloc-reader  
;  import stz/reg-alloc-errors
;  import stz/reg-alloc-model-analysis
;  import stz/reg-alloc-model-check
;  import stz/reg-alloc-program-check
;  import stz/reg-alloc-blocks
;  import stz/reg-alloc-engine
;  import stz/reg-alloc-block-engine
;  import stz/reg-alloc-liveness
;  import stz/reg-alloc-port-prefs
;  import stz/reg-alloc-block-analysis
;  import stz/reg-alloc-annotations
;  import stz/reg-alloc-allocation
;  import stz/reg-alloc-assignment
;  import stz/reg-alloc-assignment-table
;  import stz/reg-alloc-model-env
;  import stz/reg-alloc-simple-model-env
;  import stz/reg-alloc-shuffle
;  import stz/reg-alloc-datastructures
;  import stz/reg-alloc-model-properties
;  import stz/printing-utils


;============================================================
;================== For Development =========================
;============================================================

within (package,sig) = set-stack-trace-filter() :
  package != `core

;Analyze the models directly
set-command-line-arguments $ [
  "dev-reg-alloc"
  "analyze-models"
  "testdata/reg-alloc-models01.txt"]

;Analyze an entire program
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "analyze-prog"
;  "testdata/reg-alloc-ex1.ir"]

;Analyze a block at a time
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "analyze-block"
;  "testdata/reg-alloc-blocks01.txt"
;  "-named" "test11"]

;Analyze some shuffle inputs
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "analyze-shuffle"
;  "testdata/reg-alloc-shuffle01.txt"]

;Check models for errors
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "check-models"
;  "testdata/reg-alloc-models01.txt"]

;Check program for errors
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "check-programs"
;  "testdata/reg-alloc-progs.ir"]

;============================================================
;================== Analyze Block Action ====================
;============================================================
;<comment>
defn analyze-block-action (cmdargs:CommandArgs) :
  ;Retrieve filter on block names.
  val names = get?(cmdargs,"named",false)
  defn keep? (b:AnalyzeBlock) :
    match(names:Tuple<String>) : contains?(names, to-string(name(b)))
    else : true
  
  val filename = arg(cmdargs,0)
  val forms = reader/read-file(filename)
  val [blocks, models] = parse-blocks-and-models(forms)
  val model-props = analyze-models(models)
  val model-analyzer = ModelAnalyzer(models, model-props)
  for (b in blocks, i in 0 to false) do :
    if keep?(b) :
      println("\n") when i > 0
      analyze(b, models, model-props, model-analyzer)

defn analyze (b:AnalyzeBlock,
              models:Tuple<OperationModel>,
              mprops:Vector<ModelProperties>,
              manalyzer:ModelAnalyzer) :
  ;Load into block engine.
  val be = load-block(block(b), models, mprops, manalyzer)

  ;Display input.
  println("===== Block %_ =====" % [name(b)])
  println(be)

  ;Annotate block
  println("\n\n===== Annotation =====")
  annotate-block(be)
  println(be)

  ;Allocate registers
  println("\n\n===== Allocation =====")
  allocate-block(be, 6, 6)
  println(be)
  
  ;Assign registers
  println("\n\n===== Assignment =====")
  val at = AssignmentTable(ResourceProvider(16,16,20))
  assign-registers(be, at)
  println(be)
;<comment>

  
;============================================================
;================= Analyze Prog Action ======================
;============================================================
;<comment>
defn analyze-prog-action (cmdargs:CommandArgs) :
  val filename = arg(cmdargs,0)
  val forms = reader/read-file(filename)
  val [prog, models] = parse-prog-and-models(forms)
      
  println("===== Input =====")    
  println("%_\n" % [prog])
  for m in models do :
    println("%_\n" % [m])

  val engine = RegAllocEngine(prog, models)
  println("\n\n===== Engine =====")
  println(engine)

  println("\n\n==== Analyze Basic Blocks =====")
  analyze-basic-blocks(engine)
  println(engine)

  println("\n\n==== Compute Liveness =====")
  compute-live(engine)
  println(engine)

  println("\n\n===== Compute Port Preferences =====")
  compute-port-prefs(engine)
  println(engine)

  fatal("Not yet implemented")
  ;<comment2>

  println("\n\n===== Block Analysis =====")
  analyze-blocks(engine)  
  ;<comment2>
;<comment>

;============================================================
;================ Analyze Model Action ======================
;============================================================

defn analyze-model-action (cmdargs:CommandArgs) :
  val filename = arg(cmdargs,0)
  val models = parse-models(reader/read-file(filename))
  do(analyze, models)

;Analyze a single model.
defn analyze (am:AnalyzeModel) :
  ;val resources = ResourceProvider(16,16,20)
  ;val checker = ModelChecker(resources, 16, 16)
  println("===== Model %_ =====" % [name(am)])
  println(model(am))
  ;try :
  ;  check-model(checker, model(am))
  ;  for (ctxt in contexts(am), i in 1 to false) do :
  ;    println("Context %_: %_" % [i, ctxt])
  ;    val result = used-registers(model(am), ctxt)
  ;    within indented() :
  ;      println("Result: %_" % [result])
  ;catch (e) :
  ;  println(e)

;============================================================
;================= Analyze Shuffle Action ===================
;============================================================
;<comment>
defn analyze-shuffle-action (cmdargs:CommandArgs) :

  val filename = arg(cmdargs, 0)
  val parsed = parse-shuffles(reader/read-file(filename))
  val engine = dummy-shuffle-engine()
  for (item in parsed, i in 0 to false) do :
    println("\n") when i > 0
    analyze(engine, item)

;Create a dummy shuffle engine.
defn dummy-shuffle-engine () -> ShuffleEngine :
  ShuffleEngine(ResourceProvider(16,16,20))

;Analyze a single shuffle.
defn analyze (engine:ShuffleEngine,shuf:AnalyzeShuffle) :
  println("===== Shuffle %_ =====" % [name(shuf)])
  println(shuf)
  println("")
  
  val category = categorize(engine, inputs(shuf), outputs(shuf))
  println("Category: %_" % [category])
  println("")

  ;Load problem into engine.
  load-problem(engine,
               vars(shuf),
               inputs(shuf),
               saved(shuf),
               outputs(shuf))

  ;Print all registers to avoid.
  if any?({_ is AnyReg|AnyFReg}, outputs(shuf)) :
    println("Registers to avoid:")
    for (v in vars(shuf), output in outputs(shuf), i in 0 to false) do :
      if output is AnyReg|AnyFReg :
        val r = avoid(engine, i)
        println("  V%_ should avoid %_" % [v, r])
    println("")
    
  ;Perform the shuffle.
  else :
    println("Shuffle statements:")
    defn emit (stmt:ProgramStmt) :
      println(Indented(stmt))
    shuffle(engine,
            outputs(shuf) as Tuple<Reg|FReg>,
            free-reg(shuf),
            free-freg(shuf),
            emit)
    println("")        
;<comment>

;============================================================
;=================== Check Model Action =====================
;============================================================
;<comment>
defn check-model-action (cmdargs:CommandArgs) :
  val filename = arg(cmdargs,0)
  val parsed = parse-models(reader/read-file(filename))
  for (am in parsed, i in 0 to false) do :
    println("\n") when i > 0
    check(am)

defn check (am:AnalyzeModel) :
  println("===== Model %_ =====" % [name(am)])
  println("Model:\n%_" % [Indented(model(am))])
  val resources = ResourceProvider(16,16,20)
  val checker = ModelChecker(resources, 16, 16)
  try :
    check-model(checker, model(am))
    println("Model is valid.")
  catch (e) :
    println(e)
;<comment>

;============================================================
;=================== Check Model Action =====================
;============================================================
;<comment>
defn check-program-action (cmdargs:CommandArgs) :
  label break :
    val filename = arg(cmdargs,0)
    val [progs, models] = parse-progs-and-models(reader/read-file(filename))
    val resources = ResourceProvider(16,16,20)
    val checker = ModelChecker(resources,16,16)

    ;First ensure that all the models are okay.
    val models-okay? = for model in models all? :
      try :
        check-model(checker, model)
        true
      catch (e) :
        println(e)
        false
    break() when not models-okay?

    ;Then ensure that each program is okay.
    val env = SimpleModelEnv(models)
    for (prog in progs, i in 0 to false) do :
      println("===== Program =====")
      println(prog)
      
      println("\nCheck Allowing Repetition:")
      try :
        check-program(prog, true, env, resources)
        println("Program is wellformed.")
      catch (e) :
        println(e)

      println("\nCheck Forbidding Repetition:")
      try :
        check-program(prog, false, env, resources)
        println("Program is wellformed.")
      catch (e) :
        println(e)
;<comment>

;============================================================
;==================== Launcher ==============================
;============================================================

;Launch!
simple-command-line-cli(false, commands, "analyze-models", false, false) where :
  val commands = [
    Command(
      "analyze-models", OneArg, "the models to analyze",
      [],
      "Analyze a text file containining operation models.",
      analyze-model-action)
    ;Command(
    ;  "analyze-prog", OneArg, "the program to analyze",
    ;  [],
    ;  "Analyze a text file containing the regalloc program.",
    ;  analyze-prog-action)
    ;Command(
    ;  "analyze-block", OneArg, "the blocks to analyze",
    ;  [Flag("named"
    ;        AtLeastOneFlag,
    ;        OptionalFlag,
    ;        "A list of names of tests to execute.")],
    ;  "Analyze a text file containing blocks to analyze."
    ;  analyze-block-action)
    ;Command(
    ;  "analyze-shuffle", OneArg, "the shuffle to analyze",
    ;  []
    ;  "Analyze a text file containing shuffle inputs."
    ;  analyze-shuffle-action)
    ;Command(
    ;  "check-models", OneArg, "the models to check",
    ;  [],
    ;  "Check all models in a text file containing models."
    ;  check-model-action)
    ;Command(
    ;  "check-programs", OneArg, "the prorams to check",
    ;  [],
    ;  "Check all programs in a text file."
    ;  check-program-action)
  ]