defpackage stz/test-reg-alloc-reader :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-block-ir
  import stz/reg-alloc-reader  
  import stz/reg-alloc-errors
  import stz/reg-alloc-model-analysis
  import stz/reg-alloc-blocks
  import stz/reg-alloc-engine
  import stz/reg-alloc-block-engine
  import stz/reg-alloc-liveness
  import stz/reg-alloc-port-prefs
  import stz/reg-alloc-block-analysis
  import stz/reg-alloc-annotations
  import stz/reg-alloc-allocation
  import arg-parser

;============================================================
;================== For Development =========================
;============================================================

within (package,sig) = set-stack-trace-filter() :
  package != `core

;Analyze the models directly
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "analyze-models"
;  "testdata/reg-alloc-models01.txt"]

;Analyze an entire program
;set-command-line-arguments $ [
;  "dev-reg-alloc"
;  "analyze-prog"
;  "testdata/reg-alloc-ex1.ir"]

;Analyze a block at a time
set-command-line-arguments $ [
  "dev-reg-alloc"
  "analyze-block"
  "testdata/reg-alloc-blocks01.txt"]

;============================================================
;================== Analyze Block Action ====================
;============================================================

defn analyze-block-action (cmdargs:CommandArgs) :
  ;Retrieve filter on block names.
  val names = get?(cmdargs,"named",false)
  defn keep? (b:AnalyzeBlock) :
    match(names:Tuple<String>) : contains?(names, to-string(name(b)))
    else : true
  
  val filename = arg(cmdargs,0)
  val forms = reader/read-file(filename)
  val [blocks, models] = parse-blocks-and-models(forms)
  val model-props = analyze-models(models)
  val model-analyzer = ModelAnalyzer(models, model-props)
  for (b in blocks, i in 0 to false) do :
    if keep?(b) :
      println("\n") when i > 0
      analyze(b, model-props, model-analyzer)

defn analyze (b:AnalyzeBlock,
              mprops:Vector<ModelProperties>,
              manalyzer:ModelAnalyzer) :
  ;Load into block engine.
  val be = BlockEngine(mprops, manalyzer)
  load-block(block(b), be)

  ;Display input.
  println("===== Block %_ =====" % [name(b)])
  println(be)

  ;Annotate block
  println("\n\n===== Annotation =====")
  annotate-block(be)
  println(be)

  ;Allocate registers
  println("\n\n===== Allocation =====")
  allocate-block(be, 6, 6)
  println(be)


;Parse a list of AnalyzeModel structures from the given forms.
defn parse-blocks-and-models (forms) -> [Tuple<AnalyzeBlock>, Tuple<OperationModel>] :
  match-syntax[reg-alloc-test-syntax](forms) :
    (?blocks:#analyze-block ...
     ?models:#model! ...) :
      [to-tuple(blocks), to-tuple(models)]
    (_ ...) :
      throw(RegAllocSyntaxError(false, "Invalid file."))

;============================================================
;================= Analyze Prog Action ======================
;============================================================

defn analyze-prog-action (cmdargs:CommandArgs) :
  val filename = arg(cmdargs,0)
  val forms = reader/read-file(filename)
  val [prog, models] = parse-prog-and-models(forms)
      
  println("===== Input =====")    
  println("%_\n" % [prog])
  for m in models do :
    println("%_\n" % [m])

  val engine = RegAllocEngine(prog, models)
  println("\n\n===== Engine =====")
  println(engine)

  println("\n\n==== Analyze Basic Blocks =====")
  analyze-basic-blocks(engine)
  println(engine)

  println("\n\n==== Compute Liveness =====")
  compute-live(engine)
  println(engine)

  println("\n\n===== Compute Port Preferences =====")
  compute-port-prefs(engine)
  println(engine)

  println("\n\n===== Block Analysis =====")
  analyze-blocks(engine)  

;Parse the given forms as a program combined with models.
defn parse-prog-and-models (forms:List) -> [Program, Tuple<OperationModel>] :
  match-syntax[reg-alloc-ir](forms) :
    (?prog:#prog
     ?models:#model! ...) :
      [prog, to-tuple(models)]
    (_ ...) :
      throw(RegAllocSyntaxError(false, "Invalid file."))  

;============================================================
;================ Analyze Model Action ======================
;============================================================

defn analyze-model-action (cmdargs:CommandArgs) :
  val filename = arg(cmdargs,0)
  val parsed = parse-models(reader/read-file(filename))
  for (am in parsed, i in 0 to false) do :
    println("\n") when i > 0
    analyze(am)

;Analyze a single model.
defn analyze (am:AnalyzeModel) :
  println("===== Model %_ =====" % [name(am)])
  println("Model:\n%_" % [Indented(model(am))])
  for (ctxt in contexts(am), i in 1 to false) do :
    println("Context %_: %_" % [i, ctxt])
    val result = used-registers(model(am), ctxt)
    within indented() :
      println("Result: %_" % [result])

;Parse a list of AnalyzeModel structures from the given forms.
defn parse-models (forms) -> Tuple<AnalyzeModel> :
  to-tuple $ parse-syntax[reg-alloc-test-syntax / #analyze-model ...](forms)  

;============================================================
;==================== Testing Syntaxes ======================
;============================================================

;------------------------------------------------------------
;----------------------- Structures -------------------------
;------------------------------------------------------------

;Represents a model to analyze, and the contexts under
;which to analyze them.
defstruct AnalyzeModel :
  name: Symbol
  model: OperationModel
  contexts: Tuple<UsageContext>

;Represents a single block to analyze.
defstruct AnalyzeBlock :
  name:Symbol
  block:BlockStmts

;------------------------------------------------------------
;-------------------- Syntax Definition ---------------------
;------------------------------------------------------------

;Syntax for representing a model to analyze.
defsyntax reg-alloc-test-syntax :
  import (int!, symbol!, blockstmts!) from reg-alloc-ir
  public import model! from reg-alloc-ir


  public defproduction analyze-model: AnalyzeModel
  defrule analyze-model = (analyze ?name:#symbol! :
                             ?model:#model!
                             ?ctxts:#usage-ctxt! ...) :
    AnalyzeModel(name, model, to-tuple(ctxts))

  public defproduction analyze-block: AnalyzeBlock
  defrule analyze-block = (analyze-block ?name:#symbol! :
                             ?block:#blockstmts!) :
    AnalyzeBlock(name, block)

  defproduction usage-ctxt: UsageContext
  defrule usage-ctxt = (UsageContext(args = [?args:#int! ...],
                                     killed = [?killed:#int! ...])) :
    UsageContext(to-tuple(args), to-tuple(killed))

  defproduction usage-ctxt!: UsageContext
  defrule usage-ctxt! = (?c:#usage-ctxt)
  fail-if usage-ctxt! = () :
    RegAllocSyntaxError(closest-info(), "Invalid usage context syntax.")

  

;============================================================
;==================== Launcher ==============================
;============================================================

;Launch!
simple-command-line-cli(false, commands, "analyze-models", false, false) where :
  val commands = [
    Command(
      "analyze-models", OneArg, "the models to analyze",
      [],
      "Analyze a text file containining operation models.",
      analyze-model-action)
    Command(
      "analyze-prog", OneArg, "the program to analyze",
      [],
      "Analyze a text file containing the regalloc program.",
      analyze-prog-action)
    Command(
      "analyze-block", OneArg, "the blocks to analyze",
      [Flag("named"
            AtLeastOneFlag,
            OptionalFlag,
            "A list of names of tests to execute.")],
      "Analyze a text file containing blocks to analyze."
      analyze-block-action)]