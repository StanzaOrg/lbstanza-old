defpackage stz/namemap :
   import core
   import verse

public definterface VEntry
public defmulti n (v:VEntry) -> Int

public defstruct VarEntry <: VEntry :
   n: Int with: (as-method => true)
   package: Symbol
   name: Symbol
   visibility: Vis
   type: EType
   info: FileInfo
public defstruct CloneEntry <: VEntry :
   n: Int with: (as-method => true)
   clone: Int

public definterface Vis
public defstruct Private <: Vis
public defstruct Protected <: Vis
public defstruct Public <: Vis
public defstruct Local <: Vis

public definterface EType
public defstruct ValE <: EType
public defstruct VarE <: EType
public defstruct FnE <: EType
public defstruct TVarE <: EType
public defstruct CapVarE <: EType
public defstruct TypeE <: EType
public defstruct MultiE <: EType
public defstruct LVarE <: EType
public defstruct LFnE <: EType
public defstruct LTypeE <: EType
public defstruct LabelE <: EType

public definterface NameMap <: Gettable<Int,VEntry>
public defmulti register (n:NameMap, package:Symbol, name:Symbol, visibility:Vis, type:EType, info:FileInfo) -> Int
public defmulti clone (n:NameMap, n:Int) -> Int
public defmulti globals (n:NameMap) -> Streamable<VarEntry>

val COUNTER = to-stream(0 to false)
public defn fresh-n () :
   next(COUNTER)
   
public defn NameMap () :
   val globals = Vector<VarEntry>()
   val table = HashTable<Int,VEntry>({_})
   defn add-entry (e:VEntry) :
      table[n(e)] = e
      if e typeof VarEntry :
         val e = e as VarEntry
         add(globals, e) when visibility(e) not-typeof Local            

   new NameMap :
      defmethod register (this, package:Symbol, name:Symbol, visibility:Vis, type:EType, info:FileInfo) -> Int :
         val n = fresh-n()
         add-entry(VarEntry(n, package, name, visibility, type, info))
         n
      defmethod clone (this, old:Int) -> Int :
         val n = fresh-n()
         add-entry(CloneEntry(n, old))
         n
      defmethod get (this, n:Int) -> VEntry :
         table[n]
      defmethod globals (this) :
         globals   

public defn resolve-type (nm:NameMap, package-name:Symbol, type-name:Symbol) :
   for g in globals(nm) search :
      match(g) :
         (g:VarEntry) :
            if package(g) == package-name and
               name(g) == type-name and
               type(g) typeof TypeE :
               n(g)
         (g) :
            false