defpackage stz/namemap :
   import core
   import verse

public definterface VEntry
defmulti n (v:VEntry) -> Int

public defstruct VarEntry <: VEntry :
   n: Int with: (as-method => true)
   package: Symbol
   name: Symbol
   visibility: Vis
   type: EType
   info: FileInfo
public defstruct CloneEntry <: VEntry :
   n: Int with: (as-method => true)
   clone: Int

public definterface Vis
public defstruct Private <: Vis
public defstruct Protected <: Vis
public defstruct Public <: Vis

public definterface EType
public defstruct ValE <: EType
public defstruct VarE <: EType
public defstruct TypeE <: EType
public defstruct FnE <: EType
public defstruct MultiE <: EType
public defstruct TVarE <: EType

public definterface NameMap <: Gettable<Int,VEntry>
public defmulti register (n:NameMap, package:Symbol, name:Symbol, visibility:Vis, type:EType, info:FileInfo) -> Int
public defmulti clone (n:NameMap, n:Int) -> Int
   
public defn NameMap () :
   val table = HashTable<Int,VEntry>({_})
   defn add-entry (e:VEntry) :
      table[n(e)] = e

   var counter = to-stream(0 to false)
   new NameMap :
      defmethod register (this, package:Symbol, name:Symbol, visibility:Vis, type:EType, info:FileInfo) -> Int :
         val n = next(counter)
         add-entry(VarEntry(n, package, name, visibility, type, info))
         n
      defmethod clone (this, old:Int) -> Int :
         val n = next(counter)
         add-entry(CloneEntry(n, old))
         n
      defmethod get (this, n:Int) -> VEntry :
         table[n]