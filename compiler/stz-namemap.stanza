defpackage stz/namemap :
   import core
   import verse
   import stz/ids

public definterface VEntry
public defmulti n (v:VEntry) -> Int

public defstruct VarEntry <: VEntry :
   n: Int with: (as-method => true)
   package: Symbol
   name: Symbol
   visibility: Vis
   type: EType
   info: FileInfo
public defstruct CloneEntry <: VEntry :
   n: Int with: (as-method => true)
   clone: Int

public definterface Vis
public defstruct Private <: Vis
public defstruct Protected <: Vis
public defstruct Public <: Vis
public defstruct Local <: Vis

public definterface EType
public defstruct ValE <: EType
public defstruct VarE <: EType
public defstruct TVarE <: EType
public defstruct CapVarE <: EType
public defstruct TypeE <: EType
public defstruct MultiE <: EType
public defstruct FnE <: EType
public defstruct LValE <: EType
public defstruct LVarE <: EType
public defstruct LFnE <: EType
public defstruct LTypeE <: EType
public defstruct FieldE <: EType
public defstruct LabelE <: EType

defmethod equal? (a:EType, b:EType) :
   match(a, b) :
      (a:ValE, b:ValE) : true
      (a:VarE, b:VarE) : true
      (a:TVarE, b:TVarE) : true
      (a:CapVarE, b:CapVarE) : true
      (a:TypeE, b:TypeE) : true
      (a:MultiE, b:MultiE) : true
      (a:FnE, b:FnE) : true
      (a:LValE, b:LValE) : true
      (a:LVarE, b:LVarE) : true
      (a:LFnE, b:LFnE) : true
      (a:LTypeE, b:LTypeE) : true
      (a:FieldE, b:FieldE) : true
      (a:LabelE, b:LabelE) : true
      (a, b) : false

public definterface NameMap <: Gettable<Int,VEntry>
public defmulti register (n:NameMap, package:Symbol, name:Symbol, visibility:Vis, type:EType, info:FileInfo) -> Int
public defmulti clone (n:NameMap, n:Int) -> Int
public defmulti globals (n:NameMap) -> Streamable<VarEntry>
public defmulti key? (n:NameMap, i:Int) -> True|False
   
public defn NameMap () :
   val globals = Vector<VarEntry>()
   val table = HashTable<Int,VEntry>({_})
   defn add-entry (e:VEntry) :
      table[n(e)] = e
      if e typeof VarEntry :
         val e = e as VarEntry
         add(globals, e) when visibility(e) not-typeof Local

   defn retrieve-id (package:Symbol, name:Symbol, type:EType) :
      switch {_ == [package name type]} :
         ;Special Types
         [`core `Fn LTypeE()] : FN-TYPE-ID
         [`core `Int LTypeE()] : INT-TYPE-ID
         [`core `False LTypeE()] : FALSE-TYPE-ID
         [`core `True LTypeE()] : TRUE-TYPE-ID
         [`core `String LTypeE()] : STRING-TYPE-ID
         [`core `Symbol LTypeE()] : SYMBOL-TYPE-ID
         [`core `Tuple LTypeE()] : TUPLE-TYPE-ID
         [`core `Box LTypeE()] : BOX-TYPE-ID
         [`core `Type LTypeE()] : TYPE-TYPE-ID
         [`core `List TypeE()] : LIST-TYPE-ID
         ;Special Functions
         [`core `extend-heap LFnE()] : EXTEND-HEAP-ID
         [`core `extend-stack LFnE()] : EXTEND-STACK-ID
         [`core `variable-uninitialized-error LFnE()] : VARIABLE-UNINITIALIZED-ERROR-ID
         [`core `tuple-length-error LFnE()] : TUPLE-LENGTH-ERROR-ID
         [`core `branch-error LFnE()] : BRANCH-ERROR-ID
         [`core `cast-error LFnE()] : CAST-ERROR-ID
         [`core `arity-error LFnE()] : ARITY-ERROR-ID
         else : fresh-id()

   new NameMap :
      defmethod register (this, package:Symbol, name:Symbol, visibility:Vis, type:EType, info:FileInfo) -> Int :
         val n = retrieve-id(package, name, type)
         add-entry(VarEntry(n, package, name, visibility, type, info))
         n
      defmethod clone (this, old:Int) -> Int :
         val n = fresh-id()
         add-entry(CloneEntry(n, old))
         n
      defmethod get (this, n:Int) -> VEntry :
         table[n]
      defmethod globals (this) :
         globals
      defmethod key? (this, i:Int) :
         key?(table, i)

public defn resolve-type (nm:NameMap, package-name:Symbol, type-name:Symbol) :
   for g in globals(nm) search :
      match(g) :
         (g:VarEntry) :
            if package(g) == package-name and
               name(g) == type-name and
               type(g) typeof TypeE :
               n(g)
         (g) :
            false