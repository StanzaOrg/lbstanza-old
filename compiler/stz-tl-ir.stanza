defpackage stz/tl-ir :
   import core
   import verse

#use-overlay(stz/ast-lang, stz/printer-lang)

;======== Hierarchy ========
public defstruct HEntry :
   n: Int
   args: List<Int>
   parent: Type
   
public defclass THierarchy <: Gettable<Int,HEntry> & Streamable<HEntry>
public defmulti add (h:THierarchy, n:Int, args:List<Int>, p:Type) -> False
public defmulti False (h:THierarchy) -> Int
public defmulti Int (h:THierarchy) -> Int
public defmulti String (h:THierarchy) -> Int
public defmulti Symbol (h:THierarchy) -> Int
public defmulti List (h:THierarchy) -> Int
public defmulti Tuple (h:THierarchy) -> Int

public defn THierarchy (st:Tuple<KeyValue<Symbol,Int|False>>) :
   defn special-type! (name:Symbol) :
      match(lookup(st, name)) :
         (n:Int) : n
         (n:False) : error("Special type ~ is not defined." % [name])         
   val entries = HashTable<Int,HEntry>({_})
   new THierarchy :
      defmethod add (this, n:Int, args:List<Int>, p:Type) :
         entries[n] = HEntry(n, args, p)
      defmethod get (this, n:Int) :
         entries[n]
      defmethod to-stream (this) :
         to-stream(values(entries))
      defmethod False (this) : special-type!(`False)
      defmethod Int (this) : special-type!(`Int)
      defmethod String (this) : special-type!(`String)
      defmethod Symbol (this) : special-type!(`Symbol)
      defmethod List (this) : special-type!(`List)
      defmethod Tuple (this) : special-type!(`Tuple)

;======== Contexts ========
public defast :
   deftype Context
   defnodes Context :
      CDo: (args:List<Type>, ret:Type, exp:Type)
      CExp: (type: Type)
      CNone

defprinter (c:Context) :
   CNone :
      ($none)
   CExp :
      ($exp type)
   CDo :
      ($do (args ...) ret)

;======== Comparison ========
public defclass Unknown
public val unknown:Unknown = new Unknown
defmethod print (o:OutputStream, u:Unknown) :
   print(o, "unknown")

public defclass Maybe
public val maybe:Maybe = new Maybe
defmethod print (o:OutputStream, m:Maybe) :
   print(o, "maybe")

;======== Selection ========
public defast :
   deftype Selection
   defnodes Selection :
      SVar: (n:Int)
      SSel: (sels: List<True|False|Maybe|Unknown>)
      SNone

;======== Common Functions ========
public defmulti type (t:TExp) -> Type
public defmulti ctxt (t:TExp) -> Context

public defast :
   ;=== Language Commands ===
   deftype TComm
   defnodes TComm :
      ;=== Program ===
      TProg :
         hier: THierarchy
         comms: List<TComm>            

      ;=== Declaration Forms ===
      TDef :
         n: Int
         type: Type
         value: TExp
      TDefTuple :
         ns: List<Int>
         types: List<Type>
         value: TExp
      TDefVar :
         n: Int
         type: Type
         value: TExp
      TDefn :
         tail?: True|False
         n: Int
         targs: List<Int>
         cargs: List<Int>
         a1: List<Type>
         a2: Type
         args: List<Int>
         body: TExp
      TDefmulti :
         n: Int
         targs: List<Int>
         cargs: List<Int>
         a1: List<Type>
         a2: Type
      TDefmethod :         
         tail?: True|False
         n: Int
         multi: TExp
         thisn: False|Int
         targs: List<Int>
         cargs: List<Int>
         a1: List<Type>
         a2: Type
         args: List<Int>
         body: TExp
      TExpComm :
         exp: TExp
   
   ;=== Language Expressions ===
   deftype TExp :
      type:Type with: (as-method => true)
      ctxt:Context with: (as-method => true)

   defdo (f:TExp -> ?, t:TExp) -> ? :
      (x:TExp) : f(x)
      (x:TRef) : f(x)      
      (x:List<TFn>) : do(f, x)
      (x:List<TBranch>) : do(f, x)
      (x:List<TExp>) : do(f, x)
      (x:Type) : false      
      (x:Int) : false
      (x:List<Int>) : false
      (x:List<Type>) : false
      (x:List<TDefn>) : false
      (x:True|False) : false
      (x:List<TDefmethod>) : false
      (x:Symbol) : false
      (x:Selection) : false
      (x:Context) : false
      (x:?) : false
      
   defnodes TExp :            
      ;=== Stanza Forms ===
      TLet :
         n: Int
         ntype: Type
         value: TExp
         body: TExp
      TLetVar :
         n: Int
         ntype: Type
         value: TExp
         body: TExp
      TLetTuple :
         ns: List<Int>
         ntypes: List<Type>
         value: TExp
         body: TExp
      TLetRec :
         defns: List<TDefn>
         body: TExp
      TFn :
         tail?: True|False
         a1: List<Type>
         a2: Type
         args: List<Int>
         body: TExp
      TMulti :
         funcs: List<TFn>
      TSeq :
         a: TExp
         b: TExp
      TMatch :
         args: List<TExp>
         branches: List<TBranch>
      TBranch :
         args: List<Int>
         atypes: List<Type>
         body: TExp
      TNew :
         methods: List<TDefmethod>
      TRef :
         n: Int
      TCast :
         exp: TExp
      TSet :
         ref: TRef
         value: TExp
      TDo :
         func: TExp
         args: List<TExp>
      TPrim :
         function: Symbol
         args: List<TExp>
      TCallLS :
         function: Int
         targs: List<Type>
         args: List<TExp>
      TLiteral :
         value: ?
      TTupleExp :
         exps: List<TExp>
      TMix :
         sel: Selection
         exps: List<TExp>
      TArgExp :
         ref: TRef
         targs: List<Type>
         cargs: List<Type>
      TElide

   ;=== Type Expressions ===
   deftype Type

   defmap (f:Type -> Type, t:Type) -> Type :
      (x:Int) : x
      (x:List<Int>) : x
      (x:Type) : f(x)          
      (x:TArrow) : f(x) as TArrow
      (x:List<Type>) : map(f, x)
      
   defdo (f:Type -> ?, t:Type) -> ? :
      (x:Int) : false
      (x:List<Int>) : false
      (x:Type) : f(x)
      (x:TArrow) : f(x)
      (x:List<Type>) : do(f, x)         

   defnodes Type :
      TPoly : (targs:List<Int>, cargs:List<Int>, func:TArrow)
      TCap : (n:Int)
      TOf : (n:Int, type:Type)
      TTuple : (types:List<Type>)
      TOr : (a:Type, b:Type)
      TAnd : (a:Type, b:Type)
      TVar : (n:Int)
      TArrow : (a:Type, b:Type)
      TGradual : ()
      TBot : ()
      TNone: ()
      TUVar : (n:Int)

defprinter (e:TComm) :
   TProg :
      ($prog comms ...)
   TDef :
      ($def n type value)
   TDefTuple :
      ($deftuple (ns ...) (types ...) value)
   TDefVar :
      ($defvar n type value)
   TDefn :
      if tail?(e) : ($defn* n (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
      else : ($defn n (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
   TDefmulti :
      ($defmulti n (targs ...) (cargs ...) (a1 ...) a2)
   TDefmethod :
      if tail?(e) : ($defmethod* n multi thisn (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
      else : ($defmethod n multi thisn (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
   TExpComm :
      custom{exp(e)}

defprinter (e:TExp) :
   TLet :
      ($let n ntype value body)
   TLetVar :
      ($let-var n ntype value body)
   TLetTuple :
      ($let-tuple (ns ...) (ntypes ...) value body)
   TLetRec :
      ($let-rec (defns ...) body)
   TFn :
      if tail?(e) : ($fn* (a1 ...) a2 (args ...) body)
      else : ($fn (a1 ...) a2 (args ...) body)
   TMulti :
      ($multi funcs ...)
   TSeq :
      ($seq a b)
   TMatch :
      ($match (args ...) branches ...)
   TBranch :
      ($branch (args ...) (atypes ...) body)
   TNew :
      ($new type methods ...)
   TRef :
      custom{to-symbol("$v~" << [n(e)])}
   TCast :
      ($cast exp type)
   TSet :
      ($set ref value)
   TDo :
      ($do func args ...)
   TPrim :
      ($prim function args ...)
   TCallLS :
      ($call-ls function (targs ...) args ...)
   TLiteral :
      custom{value(e)}
   TTupleExp :
      ($tuple exps ...)
   TMix :
      ($mix exps ...)
   TArgExp :
      ($targ ref (targs ...) (cargs ...))
   TElide :
      ($elide)

defprinter (t:Type) :
   TCap :
      ($cap n)
   TOf :
      ($of n type)
   TTuple :
      ($tuple types ...)
   TOr :
      ($and a b)
   TAnd :
      ($and a b)
   TVar :
      custom{to-symbol("$t~" << [n(t)])}
   TArrow :
      ($-> a b)
   TGradual :
      custom{`?}
   TBot :
      custom{`void}
   TNone :
      custom{`none}
   TUVar :
      custom{to-symbol("$ut~" << [n(t)])}

public defn children (t:Type) -> Streamable<Type> :
   val ts = Vector<Type>(4)
   do(add{ts, _}, t)
   ts