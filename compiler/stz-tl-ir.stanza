defpackage stz/tl-ir :
   import core
   import verse

;======== Hierarchy ========
public defstruct HEntry :
   n: Int
   args: List<Int>
   parent: Type
   
public defclass THierarchy <: Gettable<Int,HEntry> & Streamable<HEntry>
public defmulti add (h:THierarchy, n:Int, args:List<Int>, p:Type) -> False

public defn THierarchy () :
   val entries = HashTable<Int,HEntry>({_})
   new THierarchy :
      defmethod add (this, n:Int, args:List<Int>, p:Type) :
         entries[n] = HEntry(n, args, p)
      defmethod get (this, n:Int) :
         entries[n]
      defmethod to-stream (this) :
         to-stream(values(entries))

;======== Common Functions ========
public defmulti type (t:TExp) -> Type

#with-overlay(stz/ast-lang) :
   public defast :
      ;=== Language Commands ===
      deftype TComm
      defnodes TComm :
         ;=== Program ===
         TProg :
            hier: THierarchy
            comms: List<TComm>            

         ;=== Declaration Forms ===
         TDef :
            n: Int
            type: Type
            value: TExp
         TDefTuple :
            ns: List<Int>
            types: List<Type>
            value: TExp
         TDefVar :
            n: Int
            type: Type
            value: TExp
         TDefn :
            tail?: True|False
            n: Int
            targs: List<Int>
            cargs: List<Int>
            a1: List<Type>
            a2: Type
            args: List<Int>
            body: TExp
         TDefmulti :
            n: Int
            targs: List<Int>
            cargs: List<Int>
            a1: List<Type>
            a2: Type
         TDefmethod :
            tail?: True|False
            multi: TExp
            thisn: False|Int
            targs: List<Int>
            cargs: List<Int>
            a1: List<Type>
            a2: Type
            args: List<Int>
            body: TExp
         TExpComm :
            exp: TExp
      
      ;=== Language Expressions ===
      deftype TExp :
         type:Type with: (as-method => true)
         
      defnodes TExp :            
         ;=== Stanza Forms ===
         TLet :
            n: Int
            ntype: Type
            value: TExp
            body: TExp
         TLetVar :
            n: Int
            ntype: Type
            value: TExp
            body: TExp
         TLetTuple :
            ns: List<Int>
            ntypes: List<Type>
            value: TExp
            body: TExp
         TLetRec :
            defns: List<TDefn>
            body: TExp
         TFn :
            tail?: True|False
            a1: List<Type>
            a2: Type
            args: List<Int>
            body: TExp
         TMulti :
            funcs: List<TExp>
         TSeq :
            a: TExp
            b: TExp
         TMatch :
            args: List<TExp>
            branches: List<TBranch>
         TBranch :
            args: List<Int>
            atypes: List<Type>
            body: TExp
         TNew :
            methods: List<TDefmethod>
         TRef :
            n: Int
         TCast :
            exp: TExp
         TSet :
            n: Int
            value: TExp
         TDo :
            func: TExp
            args: List<TExp>
         TPolyDo :
            func: TExp
            targs: List<Type>
            args: List<TExp>
         TPrim :
            function: Symbol
            args: List<TExp>
         TCallLS :
            function: Int
            targs: List<Type>
            args: List<TExp>
         TLiteral :
            value: ?
         TTupleExp :
            exps: List<TExp>
         TMix :
            exps: List<TExp>
         TCapExp :
            n: Int
            cargs: List<Type>
         TElide
            

      ;=== Type Expressions ===
      deftype Type

      defmap (f:Type -> Type, t:Type) -> Type :
         (x:Int) : x
         (x:Type) : f(x)
         (x:List<Type>) : map(f, x)
         
      defdo (f:Type -> ?, t:Type) -> ? :
         (x:Int) : x
         (x:Type) : f(x)
         (x:List<Type>) : do(f, x)         

      defnodes Type :
         TCap : (n:Int)
         TOf : (n:Int, type:Type)
         TTuple : (types:List<Type>)
         TOr : (a:Type, b:Type)
         TAnd : (a:Type, b:Type)
         TVar : (n:Int)
         TArrow : (a:Type, b:Type)
         TGradual : ()
         TBot : ()
         TNone: ()
         TUVar : (n:Int)

#with-overlay(stz/printer-lang) :
   defprinter (e:TComm) :
      TProg :
         ($prog comms ...)
      TDef :
         ($def n type value)
      TDefTuple :
         ($deftuple (ns ...) (types ...) value)
      TDefVar :
         ($defvar n type value)
      TDefn :
         if tail?(e) : ($defn* n (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
         else : ($defn n (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
      TDefmulti :
         ($defmulti n (targs ...) (cargs ...) (a1 ...) a2)
      TDefmethod :
         if tail?(e) : ($defmethod* multi thisn (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
         else : ($defmethod multi thisn (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
      TExpComm :
         custom{exp(e)}

#with-overlay(stz/printer-lang) :
   defprinter (e:TExp) :
      TLet :
         ($let n ntype value body)
      TLetVar :
         ($let-var n ntype value body)
      TLetTuple :
         ($let-tuple (ns ...) (ntypes ...) value body)
      TLetRec :
         ($let-rec (defns ...) body)
      TFn :
         if tail?(e) : ($fn* (a1 ...) a2 (args ...) body)
         else : ($fn (a1 ...) a2 (args ...) body)
      TMulti :
         ($multi funcs ...)
      TSeq :
         ($seq a b)
      TMatch :
         ($match (args ...) branches ...)
      TBranch :
         ($branch (args ...) (atypes ...) body)
      TNew :
         ($new type methods ...)
      TRef :
         custom{to-symbol("$v~" << [n(e)])}
      TCast :
         ($cast exp type)
      TSet :
         ($set n value)
      TDo :
         ($do func args ...)
      TPolyDo :
         ($do-poly func (targs ...) args ...)
      TPrim :
         ($prim function args ...)
      TCallLS :
         ($call-ls function (targs ...) args ...)
      TLiteral :
         custom{value(e)}
      TTupleExp :
         ($tuple exps ...)
      TMix :
         ($mix exps ...)
      TCapExp :
         ($cap n cargs ...)
      TElide :
         ($elide)

#with-overlay(stz/printer-lang) :
   defprinter (t:Type) :
      TCap :
         ($cap n)
      TOf :
         ($of n type)
      TTuple :
         ($tuple types ...)
      TOr :
         ($and a b)
      TAnd :
         ($and a b)
      TVar :
         custom{to-symbol("$t~" << [n(t)])}
      TArrow :
         ($-> a b)
      TGradual :
         custom{`?}
      TBot :
         custom{`void}
      TNone :
         custom{`none}
      TUVar :
         custom{to-symbol("$ut~" << [n(t)])}