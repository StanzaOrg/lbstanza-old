defpackage stz/tl-ir :
   import core
   import verse

;======== Hierarchy ========
public defstruct HEntry :
   n: Int
   args: List<Int>
   parent: Type
   
definterface THierarchy <: Gettable<Int,HEntry> & Streamable<HEntry>
defmulti add (h:THierarchy, n:Int, args:List<Int>, p:Type) -> False

public defn THierarchy () :
   val entries = HashTable<Int,HEntry>({_})
   new THierarchy :
      defmethod add (this, n:Int, args:List<Int>, p:Type) :
         entries[n] = HEntry(n, args, p)
      defmethod get (this, n:Int) :
         entries[n]
      defmethod to-stream (this) :
         to-stream(values(entries))

;======== Common Functions ========
public defmulti type (t:TExp) -> Type

#with-overlay(stz/ast-lang) :
   public defast :
      ;=== Language Commands ===
      deftype TComm
      defnodes TComm :
         ;=== Program ===
         TProg :
            hier: THierarchy
            comms: List<TComm>            

         ;=== Declaration Forms ===
         TDef :
            n: Int
            type: Type
            value: TExp
         TDefTuple :
            ns: List<Int>
            types: List<Type>
            value: TExp
         TDefVar :
            n: Int
            type: Type
            value: TExp
         TDefn :
            tail?: True|False
            n: Int
            targs: List<Int>
            cargs: List<Int>
            a1: List<Type>
            a2: Type
            args: List<Int>
            body: TExp
         TDefmulti :
            n: Int
            targs: List<Int>
            cargs: List<Int>
            a1: List<Type>
            a2: Type
         TDefmethod :
            tail?: True|False
            multi: TExp
            thisn: False|Int
            targs: List<Int>
            cargs: List<Int>
            a1: List<Type>
            a2: Type
            args: List<Int>
            body: TExp
         TExpComm :
            exp: TExp
      
      ;=== Language Expressions ===
      deftype TExp :
         type:Type with: (as-method => true)
         
      defnodes TExp :            
         ;=== Stanza Forms ===
         TLet :
            n: Int
            ntype: Type
            value: TExp
            body: TExp
         TLetVar :
            n: Int
            ntype: Type
            value: TExp
            body: TExp
         TLetTuple :
            ns: List<Int>
            ntypes: List<Type>
            value: TExp
            body: TExp
         TLetRec :
            defns: List<TDefn>
            body: TExp
         TFn :
            tail?: True|False
            a1: List<Type>
            a2: Type
            args: List<Int>
            body: TExp
         TMulti :
            funcs: List<TExp>
         TSeq :
            a: TExp
            b: TExp
         TMatch :
            args: List<TExp>
            branches: List<TBranch>
         TBranch :
            args: List<Int>
            atypes: List<Type>
            body: TExp
         TNew :
            class: Type
            methods: List<TDefmethod>
         TVar :
            n: Int
         TCast :
            exp: TExp
         TSet :
            n: Int
            value: TExp
         TDo :
            func: TExp
            args: List<TExp>
         TPolyDo :
            func: TExp
            targs: List<Type>
            args: List<TExp>
         TPrim :
            function: Symbol
            args: List<TExp>
         TCallLS :
            function: Int
            targs: List<Type>
            args: List<TExp>
         TLiteral :
            value: ?
         TTuple :
            exps: List<TExp>
         TMix :
            exps: List<TExp>
         TCap :
            n: Int
            cargs: List<Type>
         TElided
            

      ;=== Type Expressions ===
      deftype Type

      defmap (f:Type -> Type, t:Type) -> Type :
         (x:Int) : x
         (x:Type) : f(x)
         (x:List<Type>) : map(f, x)
         
      defdo (f:Type -> ?, t:Type) -> ? :
         (x:Int) : x
         (x:Type) : f(x)
         (x:List<Type>) : do(f, x)         

      defnodes Type :
         TCap : (n:Int)
         TOf : (n:Int, type:Type)
         TTuple : (types:List<Type>)
         TOr : (a:Type, b:Type)
         TAnd : (a:Type, b:Type)
         TVar : (n:Int)
         TArrow : (a:Type, b:Type)
         TGradual : ()
         TBot : ()
         TNone: ()
         TUVar : (n:Int)

#with-overlay(stz/printer-lang) :
   defprinter (t:Type) :
      TCap :
         ($cap n)
      TOf :
         ($of n type)
      TTuple :
         ($tuple types ...)
      TOr :
         ($and a b)
      TAnd :
         ($and a b)
      TVar :
         custom{to-symbol("$t~" << [n(t)])}
      TArrow :
         ($-> a b)
      TGradual :
         custom{`?}
      TBot :
         custom{`void}
      TNone :
         custom{`none}
      TUVar :
         custom{to-symbol("$ut~" << [n(t)])}