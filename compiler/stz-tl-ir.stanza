defpackage stz/tl-ir :
   import core
   import verse

#use-overlay(stz/ast-lang, stz/printer-lang)

;              Type Hierarchy Definition
;              =========================

public definterface HEntry
public defmulti n (h:HEntry) -> Int
public defmulti args (h:HEntry) -> List<Int>
public defmulti parent (h:HEntry) -> Type

public defstruct HSHEntry <: HEntry :
   n: Int with: (as-method => true)
   args: List<Int> with: (as-method => true)
   parent: Type with: (as-method => true)

public defstruct LSHEntry <: HEntry :
   n: Int with: (as-method => true)
   args: List<Int> with: (as-method => true)
   parent: Type with: (as-method => true)
   fields: List<Field>
   rfield: Field|False

public defstruct Field :
   n: Int
   name: Symbol
   type: LSType

public defclass THierarchy <: Gettable<Int,HEntry> & Streamable<HEntry>
public defmulti add (h:THierarchy, e:HEntry) -> False

public defn THierarchy () :
   val entries = HashTable<Int,HEntry>({_})
   new THierarchy :
      defmethod add (this, e:HEntry) :
         entries[n(e)] = e
      defmethod get (this, n:Int) :
         entries[n]
      defmethod to-stream (this) :
         to-stream(values(entries))

;     Comparison Values
;     -----------------
public defclass Unknown
public val unknown:Unknown = new Unknown
defmethod print (o:OutputStream, u:Unknown) :
   print(o, "unknown")

public defclass Maybe
public val maybe:Maybe = new Maybe
defmethod print (o:OutputStream, m:Maybe) :
   print(o, "maybe")

;     Common Functions
;     ----------------
public defmulti type (t:TExp) -> Type
public defmulti ctxt (t:TExp) -> Context
public defmulti type (t:LSExp) -> LSType
public defmulti ctxt (t:LSExp) -> Context

public defast :
   ;     Contexts
   ;     --------
   deftype Context
   defnodes Context :
      CDo: (args:List<Type>, ret:Type, exp:Type)
      CExp: (type:Type)
      CMulti: (type:Type)
      CLSDo: (args:List<LSType>, ret:LSType, exp:LSType)
      CLSExp: (type:LSType)
      CNone

   ;     Selections
   ;     ----------
   deftype Selection
   defnodes Selection :
      SVar: (n:Int)
      SSel: (sels: List<True|False|Maybe|Unknown>)
      SNone

   ;     Top Level Commands
   ;     ------------------
   deftype TComm
   defnodes TComm :
      TDef :
         n: Int
         type: Type
         value: TExp
      TDefTuple :
         ns: List<Int>
         types: List<Type>
         value: TExp
      TDefVar :
         n: Int
         type: Type
         value: False|TExp
      TDefn :
         tail?: True|False
         n: Int
         targs: List<Int>
         cargs: List<Int>
         a1: List<Type>
         a2: Type
         args: List<Int>
         body: TExp
      TDefmulti :
         n: Int
         targs: List<Int>
         cargs: List<Int>
         a1: List<Type>
         a2: Type
      TDefmethod :
         tail?: True|False
         n: Int              ;TODO: Is this necessary?
         multi: TExp
         thisn: False|Int
         targs: List<Int>
         cargs: List<Int>
         a1: List<Type>
         a2: Type
         args: List<Int>
         body: TExp
      TInit :
         exp: TExp

      TLDef :
         n: Int
         type: LSType
         exp: LSExp
      TLDefVar :
         n: Int
         type: LSType
         exp: False|LSExp
      TLDefn :
         tail?: True|False
         n: Int
         targs: List<Int>
         cargs: List<Int>
         a1: List<LSType>
         a2: LSType
         args: List<Int>
         body: LSComm
      TExtern :
         n: Int
         type: LSType
      TLInit :
         comm: LSComm


   ;     HiStanza Expressions
   ;     --------------------
   deftype TExp :
      type:Type with: (as-method => true)
      ctxt:Context with: (as-method => true)

   defnodes TExp :
      ;=== Stanza Forms ===
      TLet : (n:Int, ntype:Type, value:TExp, body:TExp)
      TLetVar : (n:Int, ntype:Type, value:False|TExp, body:TExp)
      TLetTuple : (ns:List<Int>, ntypes:List<Type>, value:TExp, body:TExp)
      TLetRec : (defns:List<TDefn>, body:TExp)
      TFn : (tail?:True|False, a1:List<Type>, a2:Type, args:List<Int>, body:TExp)
      TMulti : (funcs:List<TFn>)
      TSeq : (a:TExp, b: TExp)
      TMatch : (args:List<TExp>, branches:List<TBranch>)
      TBranch : (args:List<Int>, atypes:List<Type>, body:TExp)
      TNew : (class:Type, methods:List<TDefmethod>)
      TRef : (n:Int)
      TCast : (exp:TExp, targ:Type)
      TSet : (ref:TRef, value:TExp)
      TDo : (func:TExp, args:List<TExp>)
      TPrim : (function:Symbol, args:List<TExp>)
      TLiteral : (value:?)
      TTupleExp : (exps:List<TExp>)
      TMix : (sel:Selection, exps:List<TExp>)
      TCurry : (ref:TRef, targs:List<Type>, cargs:List<Type>)

   ;     Type Expressions
   ;     ----------------
   deftype Type
   defnodes Type :
      TPoly : (targs:List<Int>, cargs:List<Int>, func:TArrow)
      TCap : (n:Int)
      TOf : (n:Int, type:Type)
      TTuple : (types:List<Type>)
      TOr : (a:Type, b:Type)
      TAnd : (a:Type, b:Type)
      TVar : (n:Int)
      TArrow : (a:Type, b:Type)
      TGradual : ()
      TBot : ()
      TNone: ()
      TUVar : (n:Int)

   ;     LoStanza Types
   ;     --------------
   deftype LSType
   defnodes LSType :
      ByteT
      IntT
      LongT
      FloatT
      DoubleT
      UnknownT
      PtrT: (type:LSType)
      RefT: (type:Type)
      FnT: (a:List<LSType>, r:LSType, b:LSType)
      StructT: (n:Int, type:Type)
      NoneT: ()

   ;     LoStanza Commands
   ;     -----------------
   deftype LSComm
   defnodes LSComm :
      LSCall: (exp:LSExp)
      LSSet: (exp:LSExp, value:LSExp)
      LSLabels: (ns:List<Int>, body:LSComm)
      LSLabel: (n:Int)
      LSGoto: (n:Int)
      LSReturn: (exp:LSExp)
      LSDef: (n:Int, type:LSType, value:LSExp)
      LSDefVar: (n:Int, type:LSType, value:False|LSExp)      
      LSSeq: (a:LSComm, b:LSComm)
      LSIf: (pred:LSExp, conseq:LSComm, alt:LSComm)
      LSMatch: (args:List<LSExp>, branches:List<LSBranch>)
      LSBranch: (args:List<Int>, atypes:List<Type>, body:LSComm)


   ;     LoStanza Expressions
   ;     --------------------
   deftype LSExp :
      type: LSType with: (as-method => true)
      ctxt: Context with: (as-method => true)

   defnodes LSExp :
      LSVar: (n:Int)
      LSNew: (n:Int, targ:Type, args:List<LSExp>)
      LSArray: (n:Int, targ:Type, args:List<LSExp>, length:LSExp)
      LSStruct: (n:Int, targ:Type, args:List<LSExp>)
      LSAddr: (exp:LSExp)
      LSDeref: (exp:LSExp)
      LSSlot: (exp:LSExp, index:LSExp)
      LSField: (exp:LSExp, name:Symbol)
      LSDo: (func:LSExp, args:List<LSExp>)
      LSCallC: (func:LSExp, args:List<LSExp>)
      LSPrim: (op:Symbol, targs:List<Type>, args:List<LSExp>)
      LSSizeof: (targ:LSType)
      LSTagof: (n:Int)
      LSCast: (exp:LSExp, targ:LSType)
      LSLiteral: (value:?)
      LSAnd: (a:LSExp, b:LSExp)
      LSOr: (a:LSExp, b:LSExp)
      LSLetExp: (comm:LSComm, exp:LSExp)
      LSMix: (sel:Selection, exps:List<LSExp>)
      LSCurry: (ref:LSVar, targs:List<Type>, cargs:List<Type>)

   ;     Mappers and Doers
   ;     -----------------
   make-mapper(f: TExp -> TExp, c:TComm)
   make-mapper(f: LSComm -> LSComm, c:TComm)
   make-mapper(f: LSExp -> LSExp, c:TComm)
   make-mapper(f: Type -> Type, c:TComm)
;   make-doer(f: TExp -> ?, c:TComm)

   make-mapper(f: TExp -> TExp, e:TExp)
   make-mapper(f: TComm -> TComm, e:TExp)
;   make-mapper(f: Selection -> Selection, e:TExp)
   make-mapper(f: Type -> Type, e:TExp)
;   make-doer(f: TComm -> ?, e:TExp)
;   make-doer(f: TExp -> ?, e:TExp)
   
   make-mapper(f: LSExp -> LSExp, c:LSComm)
   make-mapper(f: LSComm -> LSComm, c:LSComm)
   make-mapper(f: LSExp -> LSExp, e:LSExp)
   make-mapper(f: LSComm -> LSComm, e:LSExp)

   make-mapper(f: Type -> Type, t:Type)
;   make-doer(f: Type -> ?, t:Type)

   defmapper (f:TExp -> TExp) :
      (x:TExp) : f(x)
      (x:False|TExp) : f(x as TExp) when x != false
      (x:List<TExp>) : map(f, x)
      ignore(Int)
      ignore(Type)
      ignore(List<Int>)
      ignore(List<Type>)
      ignore(True|False)
      ignore(False|Int)
      ignore(LSType)
      ignore(LSExp)
      ignore(False|LSExp)
      ignore(List<LSType>)
      ignore(LSComm)
      ignore(Context)
      ignore(List<TDefn>)
      ignore(List<TFn>)
      ignore(List<TBranch>)
      ignore(List<TDefmethod>)
      ignore(TRef)
      ignore(Symbol)
      ignore(?)
      ignore(Selection)

   defmapper (f:LSComm -> LSComm) :
      (x:LSComm) : f(x)
      (x:List<LSBranch>) : map({f(_) as LSBranch}, x)
      ignore(Int)
      ignore(Type)
      ignore(TExp)
      ignore(List<Int>)
      ignore(List<Type>)
      ignore(False|TExp)
      ignore(True|False)
      ignore(False|Int)
      ignore(LSType)
      ignore(LSExp)
      ignore(False|LSExp)
      ignore(List<LSType>)
      ignore(List<LSExp>)
      ignore(Context)
      ignore(Symbol)
      ignore(?)
      ignore(Selection)
      ignore(LSVar)

   defmapper (f:LSExp -> LSExp) :
      (x:LSExp) : f(x)
      (x:False|LSExp) : f(x as LSExp) when x != false
      (x:List<LSExp>) : map(f, x)
      (x:LSVar) : f(x) as LSVar
      ignore(Int)
      ignore(Type)
      ignore(TExp)
      ignore(List<Int>)
      ignore(List<Type>)
      ignore(False|TExp)
      ignore(True|False)
      ignore(False|Int)
      ignore(LSType)
      ignore(List<LSType>)
      ignore(LSComm)
      ignore(List<LSBranch>)
      ignore(Context)
      ignore(Symbol)
      ignore(?)
      ignore(Selection)

   defmapper (f:Type -> Type) : 
      (x:Type) : f(x)
      (x:List<Type>) : map(f, x)
      (x:TArrow) : f(x) as TArrow
      ignore(Int)
      ignore(TExp)
      ignore(List<Int>)
      ignore(False|TExp)
      ignore(True|False)
      ignore(False|Int)
      ignore(LSType)
      ignore(LSExp)
      ignore(False|LSExp)
      ignore(List<LSType>)
      ignore(LSComm)
      ignore(Context)
      ignore(List<TDefn>)
      ignore(List<TFn>)
      ignore(List<TExp>)
      ignore(List<TBranch>)
      ignore(List<TDefmethod>)
      ignore(TRef)
      ignore(Symbol)
      ignore(?)
      ignore(Selection)

   defmapper (f:TComm -> TComm) :
      (x:List<TDefn>) : map({f(_) as TDefn}, x)
      (x:List<TDefmethod>) : map({f(_) as TDefmethod}, x)
      ignore(Type)
      ignore(Context)
      ignore(Int)
      ignore(TExp)
      ignore(False|TExp)
      ignore(List<Int>)
      ignore(List<Type>)
      ignore(True|False)
      ignore(List<TFn>)
      ignore(List<TExp>)
      ignore(List<TBranch>)
      ignore(TRef)
      ignore(Symbol)
      ignore(?)
      ignore(Selection)


public defstruct TProg :
   hier: THierarchy
   comms: List<TComm>

defprinter (p:TProg) :
   TProg :
      ($prog comms ...)

defprinter (e:TComm) :
   TDef :
      ($def n type value)
   TDefTuple :
      ($deftuple (ns ...) (types ...) value)
   TDefVar :
      ($defvar n type value)
   TDefn :
      if tail?(e) : ($defn* n (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
      else : ($defn n (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
   TDefmulti :
      ($defmulti n (targs ...) (cargs ...) (a1 ...) a2)
   TDefmethod :
      if tail?(e) : ($defmethod* n multi thisn (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
      else : ($defmethod n multi thisn (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
   TInit :
      custom{exp(e)}

   TLDef :
      ($ls-def n type exp)
   TLDefVar :
      ($ls-defvar n type exp)
   TLDefn :
      if tail?(e) : ($ls-defn* n (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
      else : ($ls-defn n (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
   TExtern :
      ($ls-extern n type)
   TLInit :
      custom{comm(e)}
      

defprinter (e:TExp) :
   TLet :
      ($let n ntype value body)
   TLetVar :
      ($let-var n ntype value body)
   TLetTuple :
      ($let-tuple (ns ...) (ntypes ...) value body)
   TLetRec :
      ($let-rec (defns ...) body)
   TFn :
      if tail?(e) : ($fn* (a1 ...) a2 (args ...) body)
      else : ($fn (a1 ...) a2 (args ...) body)
   TMulti :
      ($multi funcs ...)
   TSeq :
      ($seq a b)
   TMatch :
      ($match (args ...) branches ...)
   TBranch :
      ($branch (args ...) (atypes ...) body)
   TNew :
      ($new class methods ...)
   TRef :
      custom{to-symbol("$v~:~" << [n(e), type(e)])}
   TCast :
      ($cast exp targ)
   TSet :
      ($set ref value)
   TDo :
      ($do func args ...)
   TPrim :
      ($prim function args ...)
   TLiteral :
      custom{value(e)}
   TTupleExp :
      ($tuple exps ...)
   TMix :
      ($mix sel exps ...)
   TCurry :
      ($targ ref (targs ...) (cargs ...))
      

defprinter (t:Type) :
   TCap :
      ($cap n)
   TOf :
      ($of n type)
   TTuple :
      ($tuple types ...)
   TOr :
      ($or a b)
   TAnd :
      ($and a b)
   TVar :
      custom{to-symbol("$t~" << [n(t)])}
   TPoly :
      ($poly targs cargs func)
   TArrow :
      ($-> a b)
   TGradual :
      custom{`?}
   TBot :
      custom{`void}
   TNone :
      custom{`none}
   TUVar :
      custom{to-symbol("$ut~" << [n(t)])}
      

defprinter (t:LSType) :
   ByteT :
      ($byte)
   IntT :
      ($int)
   LongT :
      ($long)
   FloatT :
      ($float)
   DoubleT :
      ($double)
   UnknownT :
      ($?)
   PtrT :
      ($ptr type)
   RefT :
      ($ref type)
   FnT :
      ($-> (a ...) r b)
   StructT :
      ($struct n type)
   NoneT :
      ($none)
      
defprinter (c:LSComm) :
   LSCall :
      custom{exp(c)}
   LSSet :
      ($set exp value)
   LSLabels :
      ($labels (ns ...) body)
   LSLabel :
      ($label n)
   LSGoto :
      ($goto n)
   LSReturn :
      ($return exp)
   LSDef :
      ($def n type value)
   LSDefVar :
      ($defvar n type value)
   LSSeq :
      ($seq a b)
   LSIf :
      ($if pred conseq alt)
   LSMatch :
      ($match (args ...) branches ...)
   LSBranch :
      ($branch (args ...) (atypes ...) body)


defprinter (e:LSExp) :
   LSVar :
      custom{"$v~" << [n(e)]}
   LSNew :
      ($new n targ args ...)
   LSArray :
      ($array n targ length args ...)
   LSStruct :
      ($struct n targ args ...)
   LSAddr :
      ($addr exp)
   LSDeref :
      ($deref exp)
   LSSlot :
      ($slot exp index)
   LSField :
      ($field exp name)
   LSDo :
      ($do func args ...)
   LSPrim :
      ($prim op (targs ...) args ...)
   LSCallC :
      ($callc func args ...)
   LSSizeof :
      ($sizeof targ)
   LSTagof :
      ($tagof n)
   LSCast :
      ($cast exp type)
   LSLiteral :
      ($value value)
   LSAnd :
      ($and a b)
   LSOr :
      ($or a b)


defprinter (c:Context) :
   CNone :
      ($none)
   CExp :
      ($exp type)
   CMulti :
      ($multi type)
   CDo :
      ($do (args ...) ret)
   CLSDo :
      ($ls-do (args ...) ret)
   CLSExp :
      ($ls-exp type)


defprinter (s:Selection) :
   SVar :
      custom{"$s~" << [n(s)]}
   SSel :
      ($sel sels ...)
   SNone :
      ($snone)
      

;public defn children (t:Type) -> Streamable<Type> :
;   val ts = Vector<Type>(4)
;   do(add{ts, _}, t)
;   ts