defpackage stz/tl-ir :
   import core
   import verse

#use-overlay(stz/ast-lang, stz/printer-lang)

;======== Hierarchy ========
public defstruct HEntry :
   n: Int
   args: List<Int>
   parent: Type
   
public defclass THierarchy <: Gettable<Int,HEntry> & Streamable<HEntry>
public defmulti add (h:THierarchy, n:Int, args:List<Int>, p:Type) -> False
public defmulti False (h:THierarchy) -> Int
public defmulti Int (h:THierarchy) -> Int
public defmulti String (h:THierarchy) -> Int
public defmulti Symbol (h:THierarchy) -> Int
public defmulti List (h:THierarchy) -> Int
public defmulti Tuple (h:THierarchy) -> Int

public defn THierarchy (st:Tuple<KeyValue<Symbol,Int|False>>) :
   defn special-type! (name:Symbol) :
      match(lookup(st, name)) :
         (n:Int) : n
         (n:False) : error("Special type ~ is not defined." % [name])         
   val entries = HashTable<Int,HEntry>({_})
   new THierarchy :
      defmethod add (this, n:Int, args:List<Int>, p:Type) :
         entries[n] = HEntry(n, args, p)
      defmethod get (this, n:Int) :
         entries[n]
      defmethod to-stream (this) :
         to-stream(values(entries))
      defmethod False (this) : special-type!(`False)
      defmethod Int (this) : special-type!(`Int)
      defmethod String (this) : special-type!(`String)
      defmethod Symbol (this) : special-type!(`Symbol)
      defmethod List (this) : special-type!(`List)
      defmethod Tuple (this) : special-type!(`Tuple)

;======== Contexts ========
public defast :
   deftype Context
   
   defmap (f:Type -> Type, c:Context) -> Context :
      (x:List<Type>) : map(f, x)
      (x:Type) : f(x)
      
   defnodes Context :
      CDo: (args:List<Type>, ret:Type, exp:Type)
      CExp: (type: Type)
      CMulti: (type: Type)
      CNone

defprinter (c:Context) :
   CNone :
      ($none)
   CExp :
      ($exp type)
   CMulti :
      ($multi type)
   CDo :
      ($do (args ...) ret)

;======== Comparison ========
public defclass Unknown
public val unknown:Unknown = new Unknown
defmethod print (o:OutputStream, u:Unknown) :
   print(o, "unknown")

public defclass Maybe
public val maybe:Maybe = new Maybe
defmethod print (o:OutputStream, m:Maybe) :
   print(o, "maybe")

;======== Selection ========
public defast :
   deftype Selection
   defnodes Selection :
      SVar: (n:Int)
      SSel: (sels: List<True|False|Maybe|Unknown>)
      SNone

defprinter (s:Selection) :
   SVar :
      custom{"$s~" << [n(s)]}
   SSel :
      ($sel sels ...)
   SNone :
      ($snone)

;======== Common Functions ========
public defmulti type (t:TExp) -> Type
public defmulti ctxt (t:TExp) -> Context
public defmulti type (t:LSExp) -> False|LSType

public defast :
   ;=== Language Commands ===
   deftype TComm

   defdo (f:TExp -> ?, t:TComm) -> False :
      (x:TExp) : f(x)      
      ignore(THierarchy)
      ignore(List<TComm>)
      ignore(Int)
      ignore(Type)
      ignore(List<Int>)
      ignore(List<Type>)
      ignore(True|False)
      ignore(False|Int)
      ignore(LSTComm)
   
   defmap (f:TExp -> TExp, t:TComm) -> TComm :
      (x:TExp) : f(x)
      ignore(THierarchy)
      ignore(List<TComm>)
      ignore(Int)
      ignore(Type)
      ignore(List<Int>)
      ignore(List<Type>)
      ignore(True|False)
      ignore(False|Int)
      ignore(LSTComm)

   defmap (f:Type -> Type, t:TComm) -> TComm :
      (x:Type) : f(x)
      (x:List<Type>) : map(f,x)
      ignore(THierarchy)
      ignore(List<TComm>)
      ignore(Int)      
      ignore(TExp)
      ignore(List<Int>)      
      ignore(True|False)
      ignore(False|Int)
      ignore(LSTComm)
   
   defnodes TComm :
      ;=== Program ===
      TProg :
         hier: THierarchy
         comms: List<TComm>            

      ;=== Declaration Forms ===
      TDef :
         n: Int
         type: Type
         value: TExp
      TDefTuple :
         ns: List<Int>
         types: List<Type>
         value: TExp
      TDefVar :
         n: Int
         type: Type
         value: TExp
      TDefn :
         tail?: True|False
         n: Int
         targs: List<Int>
         cargs: List<Int>
         a1: List<Type>
         a2: Type
         args: List<Int>
         body: TExp
      TDefmulti :
         n: Int
         targs: List<Int>
         cargs: List<Int>
         a1: List<Type>
         a2: Type
      TDefmethod :         
         tail?: True|False
         n: Int
         multi: TExp
         thisn: False|Int
         targs: List<Int>
         cargs: List<Int>
         a1: List<Type>
         a2: Type
         args: List<Int>
         body: TExp
      TExpComm :
         exp: TExp
      TLoStanza :
         comm: LSTComm
   
   ;=== Language Expressions ===
   deftype TExp :
      type:Type with: (as-method => true)
      ctxt:Context with: (as-method => true)

   defdo (f:TComm -> ?, t:TExp) -> False :
      (x:List<TDefn>) : do(f, x)
      (x:List<TDefmethod>) : do(f, x)
      ignore(TExp)
      ignore(TRef)
      ignore(List<TFn>)
      ignore(List<TBranch>)
      ignore(List<TExp>)
      ignore(Type)
      ignore(Int)
      ignore(List<Int>)
      ignore(List<Type>)      
      ignore(True|False)      
      ignore(Symbol)
      ignore(Selection)
      ignore(Context)
      ignore(?)

   defmap (f:TComm -> TComm, t:TExp) -> TExp :
      (x:List<TDefn>) : map(f, x) as List<TDefn>
      (x:List<TDefmethod>) : map(f, x) as List<TDefmethod>      
      ignore(TExp)
      ignore(TRef)
      ignore(List<TFn>)
      ignore(List<TBranch>)
      ignore(List<TExp>)
      ignore(Type)
      ignore(Int)
      ignore(List<Int>)
      ignore(List<Type>)
      ignore(True|False)
      ignore(Symbol)
      ignore(Selection)
      ignore(Context)
      ignore(?)

   defmap (f:Selection -> Selection, t:TExp) -> TExp :
      (x:Selection) : f(x)
      ignore(TExp)
      ignore(TRef)
      ignore(List<TFn>)
      ignore(List<TBranch>)
      ignore(List<TExp>)
      ignore(Type)
      ignore(Int)
      ignore(List<Int>)
      ignore(List<Type>)
      ignore(List<TDefn>)
      ignore(True|False)
      ignore(List<TDefmethod>)
      ignore(Symbol)
      ignore(Context)
      ignore(?)

   defmap (f:Type -> Type, t:TExp) -> TExp :
      (x:List<Type>) : map(f, x)
      (x:Context) : map(f, x)
      (x:Type) : f(x)      
      ignore(TExp)
      ignore(TRef)
      ignore(List<TFn>)
      ignore(List<TBranch>)
      ignore(List<TExp>)
      ignore(Int)
      ignore(List<Int>)
      ignore(List<TDefn>)
      ignore(True|False)
      ignore(List<TDefmethod>)
      ignore(Symbol)
      ignore(Selection)
      ignore(?)

   defmap (f:TExp -> TExp, t:TExp) -> TExp :
      (x:TExp) : f(x)
      (x:TRef) : f(x) as TRef      
      (x:List<TFn>) : map(f, x) as List<TFn>
      (x:List<TBranch>) : map(f, x) as List<TBranch>
      (x:List<TExp>) : map(f, x)
      ignore(Type)
      ignore(Int)
      ignore(List<Int>)
      ignore(List<Type>)
      ignore(List<TDefn>)
      ignore(True|False)
      ignore(List<TDefmethod>)
      ignore(Symbol)
      ignore(Selection)
      ignore(Context)
      ignore(?)

   defdo (f:TExp -> ?, t:TExp) -> ? :
      (x:TExp) : f(x)
      (x:TRef) : f(x)      
      (x:List<TFn>) : do(f, x)
      (x:List<TBranch>) : do(f, x)
      (x:List<TExp>) : do(f, x)      
      ignore(Type)
      ignore(Int)
      ignore(List<Int>)
      ignore(List<Type>)
      ignore(List<TDefn>)
      ignore(True|False)
      ignore(List<TDefmethod>)
      ignore(Symbol)
      ignore(Selection)
      ignore(Context)
      ignore(?)
      
   defnodes TExp :            
      ;=== Stanza Forms ===
      TLet :
         n: Int
         ntype: Type
         value: TExp
         body: TExp
      TLetVar :
         n: Int
         ntype: Type
         value: TExp
         body: TExp
      TLetTuple :
         ns: List<Int>
         ntypes: List<Type>
         value: TExp
         body: TExp
      TLetRec :
         defns: List<TDefn>
         body: TExp
      TFn :
         tail?: True|False
         a1: List<Type>
         a2: Type
         args: List<Int>
         body: TExp
      TMulti :
         funcs: List<TFn>
      TSeq :
         a: TExp
         b: TExp
      TMatch :
         args: List<TExp>
         branches: List<TBranch>
      TBranch :
         args: List<Int>
         atypes: List<Type>
         body: TExp
      TNew :
         methods: List<TDefmethod>
      TRef :
         n: Int
      TCast :
         exp: TExp
      TSet :
         ref: TRef
         value: TExp
      TDo :
         func: TExp
         args: List<TExp>
      TPrim :
         function: Symbol
         args: List<TExp>
      TCallLS :
         function: Int
         targs: List<Type>
         args: List<TExp>
      TLiteral :
         value: ?
      TTupleExp :
         exps: List<TExp>
      TMix :
         sel: Selection
         exps: List<TExp>
      TArgExp :
         ref: TRef
         targs: List<Type>
         cargs: List<Type>
      TElide

   ;=== Type Expressions ===
   deftype Type

   defmap (f:Type -> Type, t:Type) -> Type :
      (x:Type) : f(x)
      (x:TArrow) : f(x) as TArrow
      (x:List<Type>) : map(f, x)
      ignore(Int)
      ignore(List<Int>)      
      
   defdo (f:Type -> ?, t:Type) -> ? :
      (x:Type) : f(x)
      (x:TArrow) : f(x)
      (x:List<Type>) : do(f, x)         
      ignore(Int)
      ignore(List<Int>)

   defnodes Type :
      TPoly : (targs:List<Int>, cargs:List<Int>, func:TArrow)
      TCap : (n:Int)
      TOf : (n:Int, type:Type)
      TTuple : (types:List<Type>)
      TOr : (a:Type, b:Type)
      TAnd : (a:Type, b:Type)
      TVar : (n:Int)
      TArrow : (a:Type, b:Type)
      TGradual : ()
      TBot : ()
      TNone: ()
      TUVar : (n:Int)

   ;=== LoStanza Types ===
   deftype LSType

   defnodes LSType :
      ByteT
      IntT
      LongT
      FloatT
      DoubleT
      UnknownT
      PtrT: (type:LSType)
      RefT: (type:StructT|UnknownT)
      FnT: (a:List<LSType>, r:False|LSType, b:LSType)
      StructT: (n:Int)

   ;=== LoStanza TopLevel Commands ===
   deftype LSTComm
   
   defnodes LSTComm :
      LSDefVar: (n:Int, type:LSType, value:False|LSExp)
      LSDefStruct: (n:Int, parents:List<Int>, fields:List<StructField>, rfield:False|StructField)
      LSExtern: (n:Int, type:LSType, name:Symbol)
      LSExternFn: (n:Int, type:LSType, name:Symbol)
      LSDefn: (n:Int, a1:List<LSType>, a2:LSType, args:List<Int>, body:LSComm)
      LSTopComm: (comm:LSComm)

   ;=== LoStanza Commands ===
   deftype LSComm

   defnodes LSComm :
      LSCall: (exp:LSExp)
      LSTCall: (exp:LSExp)
      LSSet: (exp:LSExp, value:LSExp)
      LSLabel: (n:Int)
      LSGoto: (n:Int)
      LSReturn: (exp:LSExp)
      LSLetVar: (n:Int, type:False|LSType, value:False|LSExp, body:LSComm)
      LSSeq: (a:LSComm, b:LSComm)
      LSIf: (pred:LSExp, conseq:LSComm, alt:LSComm)
      LSMatch: (arg:LSExp, branches:List<LSBranch>)

   ;=== LoStanza Expressions ===
   deftype LSExp :
      type: False|LSType with: (as-method => true)

   defnodes LSExp :
      LSVar: (n:Int)
      LSRef: (n:Int, args:List<LSExp>)
      LSRefArray: (n:Int, length:LSExp, args:List<LSExp>)
      LSStruct: (n:Int, args:List<LSExp>)
      LSPtr: (exp:LSExp)
      LSDeref: (exp:LSExp)
      LSSlot: (exp:LSExp, index:LSExp)
      LSField: (exp:LSExp, name:Symbol)
      LSDo: (func:LSExp, args:List<LSExp>)
      LSCallC: (func:LSExp, args:List<LSExp>)
      LSSizeof: (argtype:LSType)
      LSTagof: (n:Int)
      LSCast: (exp:LSExp)
      LSValue: (value:?)
      LSAnd: (a:LSExp, b:LSExp)
      LSOr: (a:LSExp, b:LSExp)

   ;=== Mappers and Doers ===
   defmap (f:LSExp -> LSExp, t:LSTComm) -> LSTComm :
      (x:False|LSExp) : f(x as LSExp) when x != false
      ignore(Int)
      ignore(LSType)
      ignore(List<LSType>)
      ignore(List<Int>)
      ignore(List<StructField>)
      ignore(False|StructField)
      ignore(Symbol)
      ignore(LSComm)

   defmap (f:LSComm -> LSComm, t:LSTComm) -> LSTComm :
      (x:LSComm) : f(x)
      ignore(Int)
      ignore(LSType)
      ignore(List<LSType>)
      ignore(False|LSExp)
      ignore(List<Int>)
      ignore(List<StructField>)
      ignore(False|StructField)
      ignore(Symbol)

   defmap (f:LSExp -> LSExp, c:LSComm) -> LSComm :
      (x:LSExp) : f(x)
      (x:False|LSExp) : f(x as LSExp) when x != false
      ignore(Int)
      ignore(False|LSType)
      ignore(LSComm)
      ignore(List<LSBranch>)

   defmap (f:LSComm -> LSComm, c:LSComm) -> LSComm :
      (x:LSComm) : f(x)
      (x:List<LSBranch>) :
         for b in x map :
            LSBranch(n(b), type(b), f(body(b)))
      ignore(LSExp)
      ignore(False|LSExp)
      ignore(Int)
      ignore(False|LSType)

   defmap (f:LSExp -> LSExp, e:LSExp) -> LSExp :
      (x:List<LSExp>) : map(f, x)
      (x:LSExp) : f(x)
      ignore(Int)
      ignore(Symbol)
      ignore(?)
      ignore(False|LSType)
      ignore(LSType)

public defstruct StructField :
   name: Symbol
   type: LSType

public defstruct LSBranch :
   n: Int
   type: RefT
   body: LSComm

defprinter (e:TComm) :
   TProg :
      ($prog comms ...)
   TDef :
      ($def n type value)
   TDefTuple :
      ($deftuple (ns ...) (types ...) value)
   TDefVar :
      ($defvar n type value)
   TDefn :
      if tail?(e) : ($defn* n (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
      else : ($defn n (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
   TDefmulti :
      ($defmulti n (targs ...) (cargs ...) (a1 ...) a2)
   TDefmethod :
      if tail?(e) : ($defmethod* n multi thisn (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
      else : ($defmethod n multi thisn (targs ...) (cargs ...) (a1 ...) a2 (args ...) body)
   TExpComm :
      custom{exp(e)}
   TLoStanza :
      ($lostanza comm)

defprinter (e:TExp) :
   TLet :
      ($let n ntype value body)
   TLetVar :
      ($let-var n ntype value body)
   TLetTuple :
      ($let-tuple (ns ...) (ntypes ...) value body)
   TLetRec :
      ($let-rec (defns ...) body)
   TFn :
      if tail?(e) : ($fn* (a1 ...) a2 (args ...) body)
      else : ($fn (a1 ...) a2 (args ...) body)
   TMulti :
      ($multi funcs ...)
   TSeq :
      ($seq a b)
   TMatch :
      ($match (args ...) branches ...)
   TBranch :
      ($branch (args ...) (atypes ...) body)
   TNew :
      ($new type methods ...)
   TRef :
      custom{to-symbol("$v~:~" << [n(e), type(e)])}
   TCast :
      ($cast exp type)
   TSet :
      ($set ref value)
   TDo :
      ($do func args ...)
   TPrim :
      ($prim function args ...)
   TCallLS :
      ($call-ls function (targs ...) args ...)
   TLiteral :
      custom{value(e)}
   TTupleExp :
      ($tuple exps ...)
   TMix :
      ($mix sel exps ...)
   TArgExp :
      ($targ ref (targs ...) (cargs ...))
   TElide :
      ($elide)

defprinter (t:Type) :
   TCap :
      ($cap n)
   TOf :
      ($of n type)
   TTuple :
      ($tuple types ...)
   TOr :
      ($or a b)
   TAnd :
      ($and a b)
   TVar :
      custom{to-symbol("$t~" << [n(t)])}
   TPoly :
      ($poly targs cargs func)
   TArrow :
      ($-> a b)
   TGradual :
      custom{`?}
   TBot :
      custom{`void}
   TNone :
      custom{`none}
   TUVar :
      custom{to-symbol("$ut~" << [n(t)])}

defprinter (t:LSType) :
   ByteT :
      ($byte)
   IntT :
      ($int)
   LongT :
      ($long)
   FloatT :
      ($float)
   DoubleT :
      ($double)
   UnknownT :
      ($?)
   PtrT :
      ($ptr type)
   RefT :
      ($ref type)
   FnT :
      ($-> (a ...) r b)
   StructT :
      ($struct n)

defprinter (c:LSTComm) :
   LSDefVar :
      ($defvar n type value)
   LSDefStruct :
      ($defstruct n (parents ...) (fields ...) rfield)
   LSExtern :
      ($extern n type name)
   LSExternFn :
      ($externfn n type name)
   LSDefn :
      ($defn n (a1 ...) a2 (args ...) body)
   LSTopComm :
      custom{comm(c)}

defprinter (c:LSComm) :
   LSCall :
      custom{exp(c)}
   LSTCall :
      ($tcall exp)
   LSSet :
      ($set exp value)
   LSLabel :
      ($label n)
   LSGoto :
      ($goto n)
   LSReturn :
      ($return exp)
   LSLetVar :
      ($letvar n type value body)
   LSSeq :
      ($seq a b)
   LSIf :
      ($if pred conseq alt)
   LSMatch :
      ($match arg branches ...)

defprinter (b:LSBranch) :
   LSBranch :
      ($branch n type body)

defprinter (e:LSExp) :
   LSVar :
      custom{"$v~" << [n]}
   LSRef :
      ($ref n args ...)
   LSRefArray :
      ($refarray n length args ...)
   LSStruct :
      ($struct n args ...)
   LSPtr :
      ($ptr exp)
   LSDeref :
      ($deref exp)
   LSSlot :
      ($slot exp index)
   LSField :
      ($field exp name)
   LSDo :
      ($do func args ...)
   LSCallC :
      ($callc func args ...)
   LSSizeof :
      ($sizeof argtype)
   LSTagof :
      ($tagof n)
   LSCast :
      ($cast exp type)
   LSValue :
      ($value value type)
   LSAnd :
      ($and a b)
   LSOr :
      ($or a b)

public defn children (t:Type) -> Streamable<Type> :
   val ts = Vector<Type>(4)
   do(add{ts, _}, t)
   ts