defpackage stz/vm-normalize :
  import core
  import collections
  import stz/vm-ir
  import stz/basic-ops
  import stz/backend
  import stz/dl-ir
  import stz/call-records with:
    prefix(StdArg, ShadowArg, ArgType, CallLoc, CallRecord) => Stz

;- HighStanza IntOps need to be lowered to sequences of primitive ops.
;- Call commands need to be broken up into register and memory arguments.
;- Large immediates need to be pushed to the constant tables.
;- Alloc instructions need to be broken into a test instruction and an action instruction.
;- Load/Store instructions need to be expressed with a single base and offset.
;- Stack extension needs to be lowered.
;- Multifns need to be lowered.
;- CallClosures need to be lowered.
;- External Memory Locations 

;============================================================
;==================== Driver ================================
;============================================================

public defstruct NormVMPackage :
  vmpackage: VMPackage
  datas: Tuple<VMData>

public defn packageio (p:NormVMPackage) :
  packageio(vmpackage(p))

public defn name (p:NormVMPackage) :
  name(vmpackage(p))

public defn normalize (prog:VMPackage, backend:Backend) -> NormVMPackage :
  val iotable = IOTable(packageio(prog))
  val extern-table = to-intset(seq(fid, extern-defns(prog)))
  val databuffer = DataBuffer(prog)
  val funcs* = for f in funcs(prog) map :
    val func* = normalize(func(f), databuffer, backend, iotable, extern-table[id(f)])
    sub-func(f, func*)
  NormVMPackage(sub-funcs(prog, funcs*), datas(databuffer))

;============================================================
;=================== Main Algorithm =========================
;============================================================

defn normalize (f0:VMFunction, databuffer:DataBuffer, backend:Backend, iotable:IOTable, extern?:True|False) :
  ;Make all ids and labels unique
  ;if it is a multifn
  val f = match(f0) :
    (f:VMMultifn) : rename-ids(f)
    (f) : f

  ;Create instruction buffer
  val buffer = InsBuffer(f)

  ;Create a false marker
  defn false-marker () :
    Marker(n(iotable, CORE-FALSE-ID))

  ;Load instructions for an extern defn function
  defn load-extern-instructions (f:VMFunc) :
    ;Create temporary argument to store C-RSP
    val c-rsp-arg = make-local(buffer, VMLong())

    ;Save the C Context
    ;Save the preserved registers.
    ;Put RSP into C-RSP-ARG register
    emit(buffer, SaveCContextIns())
    
    ;Check stack extension
    val has-stack-lbl = make-label(buffer)
    val no-stack-lbl = make-label(buffer)
    load-instruction(Branch0Ins(has-stack-lbl, no-stack-lbl, HasStackOp()))
    load-instruction(LabelIns(no-stack-lbl))
    load-instruction(ExtendStackIns())
    load-instruction(GotoIns(has-stack-lbl))
    load-instruction(LabelIns(has-stack-lbl))    

    ;Get arguments
    val arg-rec = arg-extern-records(buffer, args(f), c-rsp-arg, backend)
    within ret = normalize-arg-extern(arg-rec, c-rsp-arg) :
      load-instruction(ArgIns(ret, CArg()))

    ;Store crsp
    val old-crsp = make-local(buffer, VMLong())
    load-instruction(CRSPIns(old-crsp))
    load-instruction(StoreCRSPIns(c-rsp-arg))

    ;Load instructions
    for i in ins(f) do :
      match(i:ReturnIns) :
        load-instruction(StoreCRSPIns(old-crsp))
        val ret-rec = normalize(ret-extern-records(buffer, xs(i), c-rsp-arg, backend))
        emit(buffer, ReturnRecordIns(ret-rec, CCall(0)))
      else :
        load-instruction(i)

  ;Load instructions for a single standard function
  defn load-instructions (f:VMFunc) :
    load-prelude(f)
    do(load-instruction, ins(f))

  ;Load instructions for a multi
  defn load-multi-instructions (f:VMFunc) :
    ;Emit normalized dispatch instruction
    val f-ins = to-seq(ins(f))
    val dispatch-ins = next(f-ins) as MethodDispatchIns
    val default-dispatch = default(dispatch-ins)
    val amb-dispatch = amb(dispatch-ins)
    emit(buffer, MethodDispatchIns(multi(dispatch-ins), ys(dispatch-ins), zs(dispatch-ins),
                                   default-dispatch, amb-dispatch))
    for i in f-ins do :
      load-instruction(i)
      match(i:LabelIns) :
        if n(i) == default-dispatch or n(i) == amb-dispatch :
          load-prelude(f)

  ;Load instructions for a variable-arity multifn
  defn load-instructions (f:VMMultifn) :
    for entry in funcs(f) do :
      val arity = key(entry)
      val func = value(entry)
      val right-arity-lbl = make-label(buffer)
      val wrong-arity-lbl = make-label(buffer)
      emit(buffer, Branch0Ins(right-arity-lbl, wrong-arity-lbl, ArgEqOp(arg(f), arity)))
      emit(buffer, LabelIns(right-arity-lbl))
      load-instructions(func)
      emit(buffer, LabelIns(wrong-arity-lbl))
    load-instructions(default(f))

  ;Load prelude to a function
  defn load-prelude (f:VMFunc) :
    ;Check stack extension
    val has-stack-lbl = make-label(buffer)
    val no-stack-lbl = make-label(buffer)
    load-instruction(Branch0Ins(has-stack-lbl, no-stack-lbl, HasStackOp()))
    load-instruction(LabelIns(no-stack-lbl))
    load-instruction(ExtendStackIns())
    load-instruction(GotoIns(has-stack-lbl))
    load-instruction(LabelIns(has-stack-lbl))

    ;Get arguments
    within ret = normalize(ret-records(buffer, args(f), backend)) :
      load-instruction(ArgIns(ret, StanzaArg()))

  ;Size of an object on heap
  defn object-size-on-heap (sz:Int) :
    max((sz + 8 + 7) & -8, 16)
  defn object-size-on-heap (x:VMImm) :
    object-size-on-heap(value(x as NumConst) as Int)

  ;Retrieve byte array representin long
  defn binary-data (x:Long) :
    val a = ByteArray(8)
    a[0] = to-byte((x >> 0L) & 0xFFL)
    a[1] = to-byte((x >> 8L) & 0xFFL)
    a[2] = to-byte((x >> 16L) & 0xFFL)
    a[3] = to-byte((x >> 24L) & 0xFFL)
    a[4] = to-byte((x >> 32L) & 0xFFL)
    a[5] = to-byte((x >> 40L) & 0xFFL)
    a[6] = to-byte((x >> 48L) & 0xFFL)
    a[7] = to-byte((x >> 56L) & 0xFFL)
    a
  defn binary-data (x:Double) :
    binary-data(bits(x))

  ;Force into temporary
  defn ensure (f:VMImm -> True|False, x:VMImm) :
    if f(x) :
      x
    else :
      val x* = make-local(buffer, type(buffer,x))
      if large-immediate?(x) :
        emit(buffer, SetIns(x*, x))
      else :
        match(value(x as NumConst)) :
          (v:Long|Double) :
            val id = make-data(databuffer, binary-data(v))
            emit(buffer, LoadIns(x*, DataId(id), false, 0))
          (v:Float) :
            norm-interpret-op(x*, NumConst(bits(v)))        
      x*

  ;Ensure shorthands
  defn #F (x:VMImm) : ensure(function-immediate?, x)
  defn #S (x:VMImm) : ensure(small-immediate?, x)
  defn #L (x:VMImm) : ensure(large-immediate?, x)
  defn #V (x:VMImm) : ensure(local-immediate?, x)
  defn #M (x:VMImm) : ensure(storage-immediate?, x)
  defn #V* (x:VMImm) : ensure({false}, x)

  ;Convert byte to an integer
  defn conv-to-int (x:VMImm) :
    val ix = make-local(buffer, VMInt())
    emit(buffer, Op1Ins(ix, ConvOp(), #S(x)))
    ix
  defn conv-to-long (x:VMImm) :
    val ix = make-local(buffer, VMLong())
    emit(buffer, Op1Ins(ix, ConvOp(), #S(x)))
    ix
  ;Convert arguments to int, perform operation, and cast down again.
  defn byte-op-as-int-op (f: (Local, VMImm, VMImm) -> False, x:Local, y:VMImm, z:VMImm) :
    val ix = make-local(buffer, VMInt())
    f(ix, conv-to-int(y), conv-to-int(z))
    emit(buffer, Op1Ins(x, ConvOp(), ix))
  ;Convert arguments to int, perform operation, and cast down again.
  defn byte-op-as-int-op (f: (Local, VMImm) -> False, x:Local, y:VMImm) :
    val ix = make-local(buffer, VMInt())
    f(ix, conv-to-int(y))
    emit(buffer, Op1Ins(x, ConvOp(), ix))

  ;Normalize a division operation
  defn norm-div-op (x:Local, y:VMImm, z:VMImm) :
    match(type(buffer, x)) :
      (t:VMByte) :
        within (x, y, z) = byte-op-as-int-op(x, y, z) :
          val tmp = make-local(buffer, VMInt())
          val y* = #V(y)
          val z* = #V(z)
          emit(buffer, DualOp2Ins(x, tmp, DivModOp(), y*, z*))
          emit(buffer, LiveIns([z*]))
      (t:VMType&IntegerT) :
        val tmp = make-local(buffer, t)
        val y* = #V(y)
        val z* = #V(z)
        emit(buffer, DualOp2Ins(x, tmp, DivModOp(), y*, z*))
        emit(buffer, LiveIns([z*]))
      (t:VMType&RealT) :
        val y* = #S(y)
        val z* = #S(z)
        emit(buffer, Op2Ins(x, DivOp(), y*, z*))
        emit(buffer, LiveIns([z*]))

  ;Normalize a modulo operation
  defn norm-mod-op (x:Local, y:VMImm, z:VMImm) :
    match(type(buffer, x)) :
      (t:VMByte) :
        within (x, y, z) = byte-op-as-int-op(x, y, z) :
          val tmp = make-local(buffer, VMInt())
          val y* = #V(y)
          val z* = #V(z)
          emit(buffer, DualOp2Ins(tmp, x, DivModOp(), y*, z*))
          emit(buffer, LiveIns([z*]))
      (t:VMType&IntegerT) :
        val tmp = make-local(buffer, t)
        val y* = #V(y)
        val z* = #V(z)
        emit(buffer, DualOp2Ins(tmp, x, DivModOp(), y*, z*))
        emit(buffer, LiveIns([z*]))

  ;Normalize a commutative operation
  defn norm-comm-op (x:Local, op:VMOp, y:VMImm, z:VMImm) :
    emit(buffer, Op2Ins(x, op, #S(y), #S(z)))

  ;Normalize a non-commutative operation
  ;Second operand must be kept live after initial 3-address operation.
  defn norm-noncomm-op (x:Local, op:VMOp, y:VMImm, z:VMImm) :
    val y* = #S(y)
    val z* = #S(z)
    emit(buffer, Op2Ins(x, op, y*, z*))
    emit(buffer, LiveIns([z*]))

  ;Normalize a multiplication operation
  ;Can't be done for bytes (must be casted first.)
  defn norm-mul-op (x:Local, y:VMImm, z:VMImm) :
    match(type(buffer,x)) :
      (t:VMByte) :
        within (x, y, z) = byte-op-as-int-op(x, y, z) :
          emit(buffer, Op2Ins(x, MulOp(), #S(y), #S(z)))
      (t) :
        emit(buffer, Op2Ins(x, MulOp(), #S(y), #S(z)))

  ;Normalize a comparison operation
  ;Ensure that at least one of the arguments is a local
  defn norm-cmp-op (x:Local, op:VMOp, y:VMImm, z:VMImm) :
    match(op, type(buffer,x)) :
      (op:EqOp|NeOp, t:VMRef) :
        lower(x, op, y, z)
      (op, t) :      
        val any-var? = y is Local or z is Local
        if any-var? : emit(buffer, Op2Ins(x, op, #S(y), #S(z)))
        else : emit(buffer, Op2Ins(x, op, #V(y), #S(z)))

  ;Normalize a unary operation
  ;Cannot be done for bytes.
  defn norm-unary-op (x:Local, op:VMOp, y:VMImm) :
    match(type(buffer,x)) :
      (t:VMByte) :
        within (x, y) = byte-op-as-int-op(x, y) :
          emit(buffer, Op1Ins(x, op, #S(y)))
      (t) :
        emit(buffer, Op1Ins(x, op, #S(y)))

  ;Normalize a GC op
  defn norm-gc-op (x:Local, y:VMImm) :
    emit(buffer, Op1Ins(x, GCOp(), #V(y)))

  ;Normalize a negation operation.
  ;Must be converted to (0 - y) for real operations.
  defn norm-neg-op (x:Local, y:VMImm) :
    match(type(buffer,x)) :    
      (t:VMType&RealT) :
        val zero = make-local(buffer, t)
        norm-conv-op(zero, NumConst(0))
        norm-noncomm-op(x, SubOp(), zero, y)
      (t) :
        norm-unary-op(x, NegOp(), y)

  ;Normalize a conversion operation
  ;Operand must be a local.
  defn norm-conv-op (x:Local, y0:VMImm) :
    val y = #V(y0)
    match(type(buffer,x), type(buffer,y)) :
      ;Int to int conversions can be done directly
      (xt:VMType&IntegerT, yt:VMType&IntegerT) :
        emit(buffer, Op1Ins(x, ConvOp(), y))
      ;Real to real conversions can be done directly
      (xt:VMType&RealT, yt:VMType&RealT) :
        emit(buffer, Op1Ins(x, ConvOp(), y))
      ;Real to byte conversions must go to a long first
      (xt:VMByte, yt:VMType&RealT) :
        norm-conv-op(x, conv-to-long(y))
      ;Byte to real conversions must go through an int first
      (xt:VMType&RealT, yt:VMByte) :
        norm-conv-op(x, conv-to-int(y))
      ;Otherwise, conversion can be done directly
      (xt, yt) :
        emit(buffer, Op1Ins(x, ConvOp(), y))

  ;Normalize an interpret operation.
  ;Operand must be a local
  defn norm-interpret-op (x:Local, y0:VMImm) :
    val y = #V(y0)
    emit(buffer, Op1Ins(x, InterpretOp(), y))

  ;Normalize a tagging operation
  defn norm-tag-op (x:Local, y0:VMImm, typeid:Int) :
    val y = #V(y0)
    val type = id(iotable[typeid]) as TypeId
    switch(type) : 
      CORE-CHAR-ID : tag-with-bits(4)
      CORE-BYTE-ID : tag-with-bits(3)
      CORE-INT-ID : tag-with-bits(0)
      CORE-FLOAT-ID : tag-float-with-bits(5)
      else : fatal("Type not supported: %_" % [type])
    where :
      defn tag-with-bits (tagbits:Int) :
        val tmp = make-local(buffer, VMLong())
        norm-conv-op(tmp, y)
        if tagbits == 0 :
          emit(buffer, Op2Ins(x, ShlOp(), tmp, NumConst(32L)))
        else :
          emit(buffer, Op2Ins(tmp, ShlOp(), tmp, NumConst(32L)))
          emit(buffer, Op2Ins(x, AddOp(), tmp, NumConst(tagbits)))
      defn tag-float-with-bits (tagbits:Int) :
        val tmp = make-local(buffer, VMLong())
        val tmp-int = make-local(buffer, VMInt())
        norm-interpret-op(tmp-int, y)
        norm-conv-op(tmp, tmp-int)
        emit(buffer, Op2Ins(tmp, ShlOp(), tmp, NumConst(32L)))
        emit(buffer, Op2Ins(x, AddOp(), tmp, NumConst(tagbits)))
        
  ;Detag a primitive
  defn norm-detag-op (x:Local, y0:VMImm, typeid:Int) :
    val y = #V(y0)
    val type = id(iotable[typeid]) as TypeId
    switch(type) : 
      CORE-CHAR-ID : detag-int()
      CORE-BYTE-ID : detag-int()
      CORE-INT-ID : detag-int()
      CORE-FLOAT-ID : detag-float()
      else : fatal("Type not supported: %_" % [type])
    where :  
      defn detag-int () :
        val tmp = make-local(buffer, VMLong())
        emit(buffer, Op2Ins(tmp, ShrOp(), y, NumConst(32L)))
        norm-conv-op(x, tmp)
        
      defn detag-float () :
        val tmp = make-local(buffer, VMLong())
        val tmp-int = make-local(buffer, VMInt())
        emit(buffer, Op2Ins(tmp, ShrOp(), y, NumConst(32L)))
        norm-conv-op(tmp-int, tmp)
        norm-interpret-op(x, tmp-int)

  ;Deref a pointer
  defn norm-deref-op (x:Local, y:VMImm) :
    emit(buffer, Op2Ins(x, AddOp(), #S(y), NumConst(7)))

  ;Return the int type with the same number of bits
  ;as the given real type.
  defn to-int-type (t:VMType) :
    match(t) :
      (t:VMFloat) : VMInt()
      (t:VMDouble) : VMLong()

  ;Normalize call record
  defn normalize (r:CallRecords) :
    val [mem-records, reg-records] = split!({loc(_) is CallMemArg}, records(r))
    val reg-records* = to-tuple $
      for r in reg-records seq :
        val a = arg(r) as VMImm
        CallRecord(#V*(a), loc(r))
    for r in mem-records do :
      val l = loc(r) as CallMemArg
      val a = arg(r) as VMImm
      emit(buffer, StoreArgIns(index(l), #S(a)))
    CallRecords(to-tuple(reg-records*))

  ;Normalize C-call record
  defn normalize-c (r:CallRecords) :
    val [mem-records, reg-records] = split!({loc(_) is CallMemArg}, records(r))
    val reg-records* = to-tuple $
      for r in reg-records seq :
        match(arg(r)) :
          (a:ShadowArg) :
            ;Get corresponding int-type
            val v = value(a)
            val int-type = to-int-type(type(buffer,v))
            val a* = make-local(buffer, int-type)
            emit(buffer, Op1Ins(a*, InterpretOp(), #S(v)))
            CallRecord(a*, loc(r))
          (a:VMImm) :
            CallRecord(#V*(a), loc(r))
    val num-mem-args = length(mem-records)
    if num-mem-args > 0 :
      val crsp = make-local(buffer, VMLong())
      emit(buffer, CRSPIns(crsp))
      for r in mem-records do :
        val l = loc(r) as CallMemArg
        val a = arg(r) as VMImm
        emit(buffer, StoreCArgIns(index(l), crsp, #S(a), num-mem-args))
    [CallRecords(to-tuple(reg-records*)), num-mem-args]

  ;Normalize arg extern record
  defn normalize-arg-extern (return:RetRecords -> ?, r:RetRecords, crsp:Local) :
    val [mem-records, reg-records] = split!({loc(_) is CallMemArg}, records(r))
    val num-mem-args = length(mem-records)
    return(RetRecords(to-tuple(reg-records)))
    for r in mem-records do :
      val l = loc(r) as CallMemArg
      emit(buffer, LoadCArgIns(x(r), crsp, index(l), num-mem-args))

  defn normalize (return:RetRecords -> ?, r:RetRecords) :
    val [mem-records, reg-records] = split!({loc(_) is CallMemArg}, records(r))
    return(RetRecords(to-tuple(reg-records)))
    for r in mem-records do :
      val l = loc(r) as CallMemArg
      emit(buffer, LoadArgIns(x(r), index(l)))

  ;Lower HiStanza primitive operation
  defn lower (x:Local, op:VMOp, y:VMImm, z:VMImm) :
    defn L (x:Local, op:VMOp, y:VMImm, z:VMImm) :
      load-instruction(Op2Ins(x, op, y, z))
    defn detag-int (x:VMImm) :
      val x* = make-local(buffer, VMLong())
      L(x*, ShrOp(), x, NumConst(32L))
      x*
    defn tag-as-bool (x:Local, y:VMImm) :
      L(x, ShlOp(), y, NumConst(3L))
      L(x, AddOp(), x, NumConst(2L))
    match(op) :
      (op:EqOp|NeOp) :
        val tmp = make-local(buffer, VMLong())
        L(tmp, op, y, z)
        tag-as-bool(x, tmp)
      (op:IntAddOp) :
        L(x, AddOp(), y, z)
      (op:IntSubOp) :
        L(x, SubOp(), y, z)
      (op:IntMulOp) :
        L(x, MulOp(), detag-int(y), z)
      (op:IntDivOp) :
        val tmp = make-local(buffer, VMLong())
        L(tmp, DivOp(), y, z)
        L(x, ShlOp(), tmp, NumConst(32L))
      (op:IntModOp) :
        L(x, ModOp(), y, z)
      (op:IntAndOp) :
        L(x, AndOp(), y, z)
      (op:IntOrOp) :
        L(x, OrOp(), y, z)      
      (op:IntXorOp) :
        L(x, XorOp(), y, z)      
      (op:IntShlOp) :
        L(x, ShlOp(), y, detag-int(z))
      (op:IntShrOp) :
        val tmp = make-local(buffer, VMLong())
        L(tmp, ShrOp(), y, detag-int(z))
        L(tmp, ShrOp(), tmp, NumConst(32L))
        L(x, ShlOp(), tmp, NumConst(32L))
      (op:IntAshrOp) :
        val tmp = make-local(buffer, VMLong())
        L(tmp, AshrOp(), y, detag-int(z))
        L(tmp, ShrOp(), tmp, NumConst(32L))
        L(x, ShlOp(), tmp, NumConst(32L))
      (op:IntLtOp) :
        L(x, LtOp(), y, z)
        tag-as-bool(x, x)
      (op:IntGtOp) :
        L(x, GtOp(), y, z)
        tag-as-bool(x, x)
      (op:IntLeOp) :
        L(x, LeOp(), y, z)
        tag-as-bool(x, x)
      (op:IntGeOp) :
        L(x, GeOp(), y, z)
        tag-as-bool(x, x)
      (op:EqOp) :
        match(type(buffer,x)) :
          (t:VMRef) :
            L(x, op, y, z)
            tag-as-bool(x, x)
          (t) :
            L(x, op, y, z)
  defn lower (x:Local, op:VMOp, y:VMImm) :
    defn L (x:Local, op:VMOp, y:VMImm, z:VMImm) :
      load-instruction(Op2Ins(x, op, y, z))
    defn L (x:Local, op:VMOp, y:VMImm) :
      load-instruction(Op1Ins(x, op, y))
    match(op) :
      (op:IntNotOp) :
        val tmp = make-local(buffer, VMLong())
        L(tmp, NotOp(), y)
        L(tmp, ShrOp(), tmp, NumConst(32L))
        L(x, ShlOp(), tmp, NumConst(32L))        
      (op:IntNegOp) :
        L(x, NegOp(), y)

  ;Load single instruction
  ;[normalize each instruction]
  defn load-instruction (i:VMIns) :
    match(i) :
      (i:CallIns) :
        val args = normalize(call-records(buffer, ys(i), backend))
        within ret = normalize(ret-records(buffer, xs(i), backend)) :
          emit(buffer, CallRecordIns(ret, /f(i), args, info(i), StanzaCall()))
      (i:TCallIns) :
        val args = normalize(call-records(buffer, ys(i), backend))
        val ret = RetRecords([])
        emit(buffer, CallRecordIns(ret, /f(i), args, false, StanzaTCall()))
      (i:CallCIns) :
        val [args, num-mem-args] = normalize-c(callc-records(buffer, ys(i), backend))
        val ret = retc-records(buffer, xs(i) backend)
        emit(buffer, CallRecordIns(ret, /f(i), args, info(i), CCall(num-mem-args)))
      (i:CallClosureIns) :
        val args = normalize(call-records(buffer, ys(i), backend))
        within ret = normalize(ret-records(buffer, xs(i), backend)) :
          val code = make-local(buffer, VMLong())
          emit(buffer, LoadIns(code, /f(i), false, 16 - 1))
          emit(buffer, CallRecordIns(ret, code, args, info(i), StanzaCall()))
      (i:TCallClosureIns) :
        val args = normalize(call-records(buffer, ys(i), backend))
        val ret = RetRecords([])
        val code = make-local(buffer, VMLong())
        emit(buffer, LoadIns(code, /f(i), false, 16 - 1))
        emit(buffer, CallRecordIns(ret, code, args, false, StanzaTCall()))
      (i:ReturnIns) :
        val args = normalize(call-records(buffer, xs(i), backend))
        emit(buffer, ReturnRecordIns(args, StanzaCall()))
      (i:MatchIns) :        
        val args = normalize(call-records(buffer, ys(i), backend))
        emit(buffer, MatchRecordIns(false, args, branches(i), default(i), false))
      (i:DispatchIns) :
        val args = normalize(call-records(buffer, ys(i), backend))
        emit(buffer, MatchRecordIns(true, args, branches(i), default(i), amb(i)))        
      (i:YieldIns) :
        val args = normalize(call-records(buffer, ys(i), backend))
        within ret = normalize(ret-records(buffer, xs(i), backend)) :
          emit(buffer, CallRecordIns(ret, #F(/f(i)), args, info(i), YieldCall(enter?(i))))
      (i:AllocIns) :
        if all?({_ is NumConst}, sizes(i)) :
          val sizes-on-heap = map(object-size-on-heap, sizes(i))
          val size-on-heap = NumConst(to-long(sum(sizes-on-heap)))
          val has-space-lbl = make-label(buffer)
          val no-space-lbl = make-label(buffer)
          emit(buffer, Branch1Ins(has-space-lbl, no-space-lbl, HasHeapOp(), size-on-heap))
          emit(buffer, LabelIns(no-space-lbl))
          val extend-heap = CodeId(n(iotable, CORE-EXTEND-HEAP-ID))
          val call-ins = CallIns([], extend-heap, [false-marker(), NumConst(1), size-on-heap], info(i))
          load-instruction(call-ins)          
          emit(buffer, GotoIns(has-space-lbl))
          emit(buffer, LabelIns(has-space-lbl))
          for (x in xs(i), type in types(i), size-on-heap in sizes-on-heap) do :
            emit(buffer, AllocOnHeap(x, NumConst(size-on-heap)))
            emit(buffer, StoreIns(x, false, -1, Tag(type)))
        else :
          fatal("Multiple variable-sized allocations.") when length(sizes(i)) > 1
          val x = xs(i)[0]
          val type = types(i)[0]
          val size = ensure(small-immediate?, sizes(i)[0])
          val size-on-heap = make-local(buffer, VMLong())
          emit(buffer, Op2Ins(size-on-heap, AddOp(), size, NumConst(15L)))
          emit(buffer, Op2Ins(size-on-heap, AndOp(), size-on-heap, NumConst(-8L)))
          val has-space-lbl = make-label(buffer)
          val no-space-lbl = make-label(buffer)
          emit(buffer, Branch1Ins(has-space-lbl, no-space-lbl, HasHeapOp(), size-on-heap))
          emit(buffer, LabelIns(no-space-lbl))
          val extend-heap = CodeId(n(iotable, CORE-EXTEND-HEAP-ID))
          val call-ins = CallIns([], extend-heap, [false-marker(), NumConst(1), size-on-heap], info(i))
          load-instruction(call-ins)          
          emit(buffer, GotoIns(has-space-lbl))
          emit(buffer, LabelIns(has-space-lbl))
          emit(buffer, AllocOnHeap(x, size-on-heap))
          emit(buffer, StoreIns(x, false, -1, Tag(type)))
      (i:StoreIns) :
        ;Compute new offset after factoring in ref tag
        val offset* = (offset(i) + 8 - 1) when type(buffer,x(i)) is VMRef
                 else offset(i)
        match(y(i)) :
          (y:False) :
            val x* = ensure(storage-immediate?,x(i))
            val z* = ensure(small-immediate?,z(i))
            emit(buffer, StoreIns(x*, false, offset*, z*, class(i)))
          (y:VMImm) :
            val base = make-local(buffer, VMLong())
            val x* = ensure(small-immediate?,x(i))
            val y* = ensure(small-immediate?,y)
            val z* = ensure(small-immediate?,z(i))
            emit(buffer, Op2Ins(base, AddOp(), x*, y*))
            emit(buffer, StoreIns(base, false, offset*, z*, class(i)))
      (i:LoadIns) :
        ;Compute new offset after factoring in ref tag
        val offset* = (offset(i) + 8 - 1) when type(buffer,y(i)) is VMRef
                 else offset(i)
        match(z(i)) :
          (z:False) :
            val y* = ensure(storage-immediate?, y(i))
            emit(buffer, LoadIns(x(i), y*, false, offset*, class(i)))
          (z:VMImm) :
            val base = make-local(buffer, VMLong())
            val y* = ensure(storage-immediate?, y(i))
            val z* = ensure(small-immediate?, z)
            emit(buffer, Op2Ins(base, AddOp(), y*, z*))
            emit(buffer, LoadIns(x(i), base, false, offset*, class(i)))
      (i:Op1Ins) :
        match(op(i)) :
          (op:VMOp&HiStanza) : lower(x(i), op, y(i))
          (op:ConvOp) : norm-conv-op(x(i), y(i))
          (op:InterpretOp) : norm-interpret-op(x(i), y(i))
          (op:NegOp) : norm-neg-op(x(i), y(i))
          (op:TagOp) : norm-tag-op(x(i), y(i), type(op))
          (op:DetagOp) : norm-detag-op(x(i), y(i), type(op))
          (op:DerefOp) : norm-deref-op(x(i), y(i))
          (op:GCOp) : norm-gc-op(x(i), y(i))
          (op:PrintStackTraceOp) :
            val pst-func = CodeId(n(iotable, CORE-PRINT-STACK-TRACE-ID))
            load-instruction(CallIns([x(i)], pst-func, [false-marker(), NumConst(1), y(i)], false))
          (op:ClassNameOp) :
            val cn-func = CodeId(n(iotable, CORE-CLASS-NAME-ID))
            load-instruction(CallIns([x(i)], cn-func, [false-marker(), NumConst(1), y(i)], false))
          (op) : norm-unary-op(x(i), op, y(i))
      (i:Op2Ins) :
        match(op(i)) :
          (op:VMOp&HiStanza) : lower(x(i), op, y(i), z(i))
          (op:DivOp) : norm-div-op(x(i), y(i), z(i))
          (op:ModOp) : norm-mod-op(x(i), y(i), z(i))
          (op:MulOp) : norm-mul-op(x(i), y(i), z(i))
          (op:VMOp&Commutative) : norm-comm-op(x(i), op, y(i), z(i))
          (op:VMOp&NonCommutative) : norm-noncomm-op(x(i), op, y(i), z(i))
          (op:VMOp&Comparison) : norm-cmp-op(x(i), op, y(i), z(i))
          (op) : fatal("Not yet supported: %_" % [op])
      (i:Branch1Ins) :
        match(op(i)) :
          (op:InstanceofOp) :
            val args = normalize(call-records(buffer, [x(i)], backend))
            val true-branch = VMBranch([type(op)], n1(i))
            emit(buffer, MatchRecordIns(false, args, [true-branch], n2(i), false))
          (op:False) :
            emit(buffer, Branch2Ins(n1(i), n2(i), NeOp(), #S(x(i)), NumConst(0)))
          (op) :            
            emit(buffer, i)
      (i:SetIns) :
        emit(buffer, SetIns(x(i), #L(y(i))))
      (i) :
        emit(buffer, i)

  ;A multi starts with a method-dispatch instruction
  defn multi? (f:VMFunc) :
    not empty?(ins(f)) and ins(f)[0] is MethodDispatchIns

  ;Load instructions  
  match(f) :
    (f:VMFunc) :
      if multi?(f) : load-multi-instructions(f)
      else if extern? : load-extern-instructions(f)
      else : load-instructions(f)
    (f:VMMultifn) :
      load-instructions(f)
  
  ;Convert buffer to function
  val func = to-func(buffer)

  ;Ensure we did normalization correctly
  ensure-normalized(func, backend)

  ;Return normalized function
  func

;============================================================
;==================== New Instructions ======================
;============================================================

public defstruct SaveCContextIns <: VMIns 
with: (printer => true)

public defstruct CallRecordIns <: VMIns :
  ret: RetRecords
  f: VMImm
  args: CallRecords
  info: False|FileInfo with: (as-method => true)
  type: CallType
with: (printer => true)

public defstruct ArgIns <: VMIns :
  ret: RetRecords
  type: ArgType
with: (printer => true)

public defstruct ReturnRecordIns <: VMIns :
  args: CallRecords
  type: CallType
with: (printer => true)

public defstruct MatchRecordIns <: VMIns :
  dispatch?: True|False
  args: CallRecords
  branches: Tuple<VMBranch>
  default: Int
  amb: Int|False
with: (printer => true)

public defstruct AllocOnHeap <: VMIns :
  x: Local
  size: VMImm
with: (printer => true)

public defstruct ExtendStackIns <: VMIns
with: (printer => true)

public defstruct LoadArgIns <: VMIns :
  x: Local
  index: Int
with: (printer => true)

public defstruct StoreArgIns <: VMIns :  
  index: Int
  y: VMImm
with: (printer => true)

public defstruct StoreCArgIns <: VMIns :
  index: Int
  crsp: VMImm
  y: VMImm
  num-mem-args: Int
with: (printer => true)

public defstruct CRSPIns <: VMIns :
  x: Local
with: (printer => true)

public defstruct StoreCRSPIns <: VMIns :
  y: VMImm
with: (printer => true)

public defstruct LoadCArgIns <: VMIns :
  x: Local
  crsp: VMImm
  index: Int
  num-mem-args: Int
with: (printer => true)

public defstruct DualOp2Ins <: VMIns :
  x: Local
  y: Local
  op: VMOp
  z: VMImm
  w: VMImm
with: (printer => true)

public defstruct HasHeapOp <: VMOp
with: (printer => true)

public defstruct HasStackOp <: VMOp
with: (printer => true)

public defstruct ArgEqOp <: VMOp :
  arg: Int
  value: Int
with: (printer => true)

public defstruct DivModOp <: VMOp
with: (printer => true)  

public deftype CallType
public defstruct StanzaCall <: CallType with: (printer => true)
public defstruct StanzaTCall <: CallType with: (printer => true)
public defstruct CCall <: CallType :
  num-mem-args: Int
with: (printer => true)
public defstruct YieldCall <: CallType :
  enter?: True|False
with: (printer => true)

public deftype ArgType
public defstruct StanzaArg <: ArgType with: (printer => true)
public defstruct CArg <: ArgType with: (printer => true)

;============================================================
;================== Operator Classification =================
;============================================================

deftype HiStanza :
  IntAddOp <: HiStanza
  IntSubOp <: HiStanza
  IntMulOp <: HiStanza
  IntDivOp <: HiStanza
  IntModOp <: HiStanza
  IntAndOp <: HiStanza
  IntOrOp <: HiStanza
  IntXorOp <: HiStanza
  IntNotOp <: HiStanza
  IntShlOp <: HiStanza
  IntShrOp <: HiStanza
  IntAshrOp <: HiStanza
  IntLtOp <: HiStanza
  IntGtOp <: HiStanza
  IntLeOp <: HiStanza
  IntGeOp <: HiStanza
  IntNegOp <: HiStanza

public deftype Commutative :
  AddOp <: Commutative
  AndOp <: Commutative
  OrOp <: Commutative
  XorOp <: Commutative

public deftype NonCommutative :
  SubOp <: NonCommutative
  DivOp <: NonCommutative
  ModOp <: NonCommutative
  ShlOp <: NonCommutative
  ShrOp <: NonCommutative
  AshrOp <: NonCommutative

public deftype Comparison :  
  EqOp <: Comparison
  NeOp <: Comparison
  LtOp <: Comparison
  GtOp <: Comparison
  LeOp <: Comparison
  GeOp <: Comparison
  UleOp <: Comparison
  UltOp <: Comparison
  UgtOp <: Comparison
  UgeOp <: Comparison

public deftype Binary :
  MulOp <: Binary
  EqOp <: Binary
  NeOp <: Binary
  LtOp <: Binary
  GtOp <: Binary
  LeOp <: Binary
  GeOp <: Binary
  UleOp <: Binary
  UltOp <: Binary
  UgtOp <: Binary
  UgeOp <: Binary
  SubOp <: Binary
  DivOp <: Binary
  ModOp <: Binary
  ShlOp <: Binary
  ShrOp <: Binary
  AshrOp <: Binary
  AddOp <: Binary
  AndOp <: Binary
  OrOp <: Binary
  XorOp <: Binary

public deftype Unary :
  NotOp <: Unary
  NegOp <: Unary

;============================================================
;================== Unique-ify Labels =======================
;============================================================

defn rename-ids (f:VMMultifn) -> VMMultifn :
  val label-counter = to-seq(0 to false)
  val id-counter = to-seq(0 to false)

  defn rename (f:VMFunc) :
    val label-table = IntTable-init<Int>(next{label-counter})
    val id-table = IntTable-init<Int>(next{id-counter})
    val args* = for a in args(f) map :
      match(a:Local) : Local(id-table[index(a)])
      else : a
    val defs* = for d in defs(f) map :
      VMDef(id-table[id(d)], type(d), local(d))
    val ins* = for i in ins(f) map :
      defn rename-local (x:VMItem) :
        match(x:Local) : Local(id-table[index(x)])
        else : x
      map-label({label-table[_]}, vm-map(rename-local, i))
    VMFunc(args*, defs*, ins*)

  val funcs* = for f in funcs(f) map : key(f) => rename(value(f))
  val default* = rename(default(f))
  VMMultifn(arg(f), funcs*, default*)

;============================================================
;============== Classification of Immediates ================
;============================================================

;x is a large immediate if it can fit directly in a x86 set instruction.
defn large-immediate? (x:VMImm) :
  val max = 1 << 16
  val min = -1 << 16
  defn small? (v:Long) : v >= to-long(min) and v <= to-long(max)
  
  match(x) :
    (x:NumConst) :
      match(value(x)) :
        (v:Float|Double) : false
        (v:Long) : small?(v)
        (v) : true
    (x) : true

;x is a small immediate if it can fit as an x86 immediate operand.
defn small-immediate? (x:VMImm) :
  val max = 1 << 16
  val min = -1 << 16
  defn small? (v:Int) : v >= min and v <= max
  defn small? (v:Long) : v >= to-long(min) and v <= to-long(max)
  match(x) :
    (x:NumConst) :
      match(value(x)) :
        (x:Byte) : true
        (x:Int|Long) : small?(x)
        (x) : false
    (x:CodeId) : false
    (x:ExternId) : false
    (x:ExternDefnId) : false
    (x:GlobalId) : false
    (x:DataId) : false
    (x:ConstId) : false
    (x) : true

;x is a function immediate if it can be used directly in an x86 call
;instruction.
defn function-immediate? (x:VMImm) :
  match(x) :
    (x:CodeId) : true
    (x:ExternId) : true
    (x:ExternDefnId) : true
    (x) : small-immediate?(x)

;x is a local immediate if it is a Local
defn local-immediate? (x:VMImm) :
  x is Local

;x is a storage immediate if it can be used directly in an x86
;load/store instruction as the location address.
defn storage-immediate? (x:VMImm) :
  x is Local|GlobalId|DataId

;============================================================
;================== Calling Convention ======================
;============================================================
public deftype CallLoc
public defstruct CallReg <: CallLoc :
  index: Int
with: (printer => true)
public defstruct CallFReg <: CallLoc :
  index: Int
with: (printer => true)
public defstruct CallMemArg <: CallLoc :
  index: Int
with: (printer => true)

public deftype CallArg :
  VMImm <: CallArg
public defstruct ShadowArg <: CallArg :
  value: VMImm
with: (printer => true)

public defstruct CallRecords :
  records: Tuple<CallRecord>
with: (printer => true)

public defstruct CallRecord :
  arg: CallArg
  loc: CallLoc
with: (printer => true)

public defstruct RetRecords :
  records: Tuple<RetRecord>
with: (printer => true)

public defstruct RetRecord :
  x: Local
  loc: CallLoc
with: (printer => true)

;Straightforward translation from CallLoc in stz/call-records package
;to CallLoc in this package.
defn to-call-loc (l:StzCallLoc) -> CallLoc :
  match(l) :
    (l:RegLoc) : CallReg(id(l))
    (l:FRegLoc) : CallFReg(id(l))
    (l:MemLoc) : CallMemArg(index(l))

defn arg-extern-records (b:InsBuffer, xs:Tuple<Local|VMType>, crsp:Local, backend:Backend) -> RetRecords :
  ;First compute whether each argument is an integer or real arg.
  val arg-types = for x in xs map :
    val t = match(x) :
      (x:Local) : type(b,x)
      (x:VMType) : x
    IntArg() when integral?(t) else RealArg()
  ;Compute the records
  ;Use IntArg as the dummy return result.
  val records = callc-records(arg-types, IntArg(), backend)
  ;Translate into structure needed.
  val records* = Vector<RetRecord>()
  for arg in args(records) do :
    val loc* = to-call-loc(loc(arg))
    val value* = match(value(arg)) :
      (v:StzStdArg) :      
        match(xs[index(v)]) :
          (x:Local) : x
          (x:VMType) : false
      (v:StzShadowArg) :
        false
    match(value*:Local) :
      add(records*, RetRecord(value*, loc*))
  add(records*, RetRecord(crsp, CallReg(c-rsp-arg(backend))))
  ;Return RetRecords
  RetRecords(to-tuple(records*))

defn ret-extern-records (b:InsBuffer, xs0:Seqable<VMImm>, crsp:Local, backend:Backend) -> CallRecords :
  val records = Vector<CallRecord>()
  val xs = to-seq(xs0)
  val x = next(xs)
  match(type(b,x)) :
    (t:VMType&IntegerT) :
      add(records, CallRecord(x, CallReg(0)))
    (t:VMType&RealT) :
      add(records, CallRecord(x, CallFReg(0)))
  add(records, CallRecord(crsp, CallReg(c-rsp-arg(backend))))
  CallRecords(to-tuple(records))

defn ret-records (b:InsBuffer, xs:Seqable<Local|VMType>, backend:Backend) -> RetRecords :
  val records = Vector<RetRecord>()
  val regs = seq(CallReg, call-regs(backend))
  val fregs = seq(CallFReg, call-fregs(backend))
  val mems = seq(CallMemArg, 0 to false)
  for x in xs do :
    val t = match(x:Local) : type(b,x)
            else : x as VMType
    val loc = 
      if integral?(t) :
        if empty?(regs) : next(mems)
        else : next(regs)      
      else :
        if empty?(fregs) : next(mems)
        else : next(fregs)
    match(x:Local) :
      add(records, RetRecord(x, loc))
  RetRecords(to-tuple(records))

defn retc-records (b:InsBuffer, xs0:Seqable<Local|VMType>, backend:Backend) -> RetRecords :
  val records = Vector<RetRecord>()
  val xs = to-seq(xs0)
  if not empty?(xs) :
    val x = next(xs)
    match(x:Local) :
      val t = type(b,x)
      if integral?(t) : add(records, RetRecord(x, CallReg(0)))
      else : add(records, RetRecord(x, CallFReg(0)))
  if not empty?(xs) :
    fatal("More than a single C return value!")
  RetRecords(to-tuple(records))      

defn call-records (b:InsBuffer, xs:Seqable<VMImm>, backend:Backend) -> CallRecords :
  val records = Vector<CallRecord>()
  val regs = seq(CallReg, call-regs(backend))
  val fregs = seq(CallFReg, call-fregs(backend))
  val mems = seq(CallMemArg, 0 to false)
  for x in xs do :
    val t = type(b,x)
    val loc = 
      if integral?(t) :
        if empty?(regs) : next(mems)
        else : next(regs)      
      else :
        if empty?(fregs) : next(mems)
        else : next(fregs)
    add(records,CallRecord(x, loc))
  CallRecords(to-tuple(records))

defn callc-records (b:InsBuffer, xs:Tuple<VMImm>, backend:Backend) -> CallRecords :
  ;First compute whether each argument is an integer or real arg.
  val arg-types = for x in xs map :
    val t = type(b,x)
    IntArg() when integral?(t) else RealArg()
  ;Compute the records
  ;Use IntArg as the dummy return result.
  val records = callc-records(arg-types, IntArg(), backend)
  ;Translate into structure needed.
  CallRecords $ for arg in args(records) map :
    val loc* = to-call-loc(loc(arg))
    val value* = match(value(arg)) :
      (v:StzStdArg) : xs[index(v)]
      (v:StzShadowArg) : ShadowArg(xs[index(v)])
    CallRecord(value*, loc*)

defn match-records (xs:Seqable<VMImm>, backend:Backend) -> CallRecords :
  val records = Vector<CallRecord>()
  defn rec (x:CallArg, l:CallLoc) :
    add(records, CallRecord(x,l))
    
  val regs = seq(CallReg, call-regs(backend))
  val mems = seq(CallMemArg, 0 to false)
  for x in xs do :
    if empty?(regs) : rec(x, next(mems))
    else : rec(x, next(regs))

  CallRecords(to-tuple(records))

defn num-mem-args (r:CallRecords) :
  for r in records(r) count :
    loc(r) is CallMemArg

public deftype IntegerT :
  VMInt <: IntegerT
  VMByte <: IntegerT
  VMLong <: IntegerT
  VMRef <: IntegerT
  
public deftype RealT :
  VMFloat <: RealT
  VMDouble <: RealT
  
defn integral? (t:VMType) :
  t is VMType&IntegerT
  
;============================================================
;=================== Normalization Check ====================
;============================================================

defn ensure-normalized (f0:VMFunction, backend:Backend) :
  ;Ensure that function is a VMFunc
  val function = f0 as VMFunc
  val buffer = InsBuffer(function)
  
  ;Check that no arguments are remaining
  fatal("Arguments remaining in function!") when not empty?(args(function))

  ;Check that operand sizes are okay
  defn ensure-operand-sizes (i:VMIns) :
    defn ensure-function-immediate (f:VMImm) :
      fatal("Not a function immediate: %_" % [f]) when not function-immediate?(f)
    defn ensure-large-immediate (f:VMImm) :
      fatal("Not a large immediate: %_" % [f]) when not large-immediate?(f)
    defn ensure-small-immediate (f:VMImm) :
      fatal("Not a small immediate: %_" % [f]) when not small-immediate?(f)
    defn ensure-storage-immediate (f:VMImm) :
      fatal("Not a storage immediate: %_" % [f]) when not storage-immediate?(f)
    match(i) :
      (i:CallRecordIns) :
        ensure-function-immediate(f(i))
        for r in records(args(i)) do :
          ensure-large-immediate(arg(r) as VMImm)
      (i:ReturnRecordIns) :
        for r in records(args(i)) do :
          ensure-large-immediate(arg(r) as VMImm)
      (i:MatchRecordIns) :
        for r in records(args(i)) do :
          ensure-large-immediate(arg(r) as VMImm)      
      (i:Op1Ins) :
        ensure-small-immediate(y(i))
      (i:Op2Ins) :
        ensure-small-immediate(y(i))
        ensure-small-immediate(z(i))
      (i:DualOp2Ins) :
        ensure-small-immediate(y(i))
        ensure-small-immediate(z(i))
      (i:Branch1Ins) :
        ensure-small-immediate(x(i))
      (i:Branch2Ins) :
        ensure-small-immediate(x(i))
        ensure-small-immediate(y(i))
      (i:MatchIns|DispatchIns) :
        do(ensure-large-immediate, ys(i))
      (i:StoreIns) :
        ensure-storage-immediate(x(i))
        ensure-small-immediate(z(i))
      (i:LoadIns) :
        ensure-storage-immediate(y(i))        
      (i:StoreArgIns) :
        ensure-small-immediate(y(i))
      (i:StoreCArgIns) :
        ensure-storage-immediate(crsp(i))
        ensure-small-immediate(y(i))
      (i:SetIns) :
        ensure-large-immediate(y(i))
      (i) :
        false

  ;Checks on calling records
  defn ensure-no-mem-locs (r:CallRecords) :
    for r in records(r) do :
      if loc(r) is CallMemArg :
        fatal("Memory argument remaining.")
  defn ensure-no-mem-locs (r:RetRecords) :
    for r in records(r) do :
      if loc(r) is CallMemArg :
        fatal("Memory argument remaining.")
  defn ensure-no-shadows (r:CallRecords) :
    for r in records(r) do :
      if arg(r) is ShadowArg :
        fatal("Shadowed argument remaining.")
  defn ensure-args-in-locals (r:CallRecords) :
    for r in records(r) do :
      ensure-local(arg(r) as VMImm)

  ;Checks on primitive operations
  defn ensure-lowlevel-ops (i:VMIns) :
    defn ensure-lowlevel (op:VMOp) :
      match(op:VMOp&HiStanza) :
        fatal("High-level op %_ remaining." % [op])
    match(i:Op0Ins|Op1Ins|Op2Ins|DualOp2Ins) :
      ensure-lowlevel(op(i))

  ;Ensure that the given local does not have type byte
  defn ensure-not-byte (x:Local) :
    fatal("Local %_ has type byte." % [x]) when type(buffer,x) is VMByte
  defn ensure-not-real (x:Local) :
    fatal("Local %_ has a real type." % [x]) when type(buffer,x) is VMType&RealT

  ;Ensure that the given operand is a local 
  defn ensure-local (f:VMImm) :
    fatal("Not a local: %_" % [f]) when not local-immediate?(f)
  defn ensure-one-local (a:VMImm, b:VMImm) :
    fatal("No locals: %_, %_" % [a, b]) when not local-immediate?(a) and not local-immediate?(b)

  ;Check each instruction
  for i in ins(function) do :
    ;Forbidden instructions
    match(i) :
      (i:CallClosureIns|TCallClosureIns|CallIns|TCallIns|CallCIns) :
        fatal("Unnormalized Call remaining")
      (i:ReturnIns) :
        fatal("Unnormalized return remaining")
      (i:AllocIns) :
        fatal("Alloc instruction remaining")
      (i:CommentIns) :
        fatal("Comment instruction remaining")
      (i:MatchIns) :
        fatal("Match instruction remaining")
      (i:DispatchIns) :
        fatal("Dispatch instruction remaining")
      (i:YieldIns) :
        fatal("Yield instruction remaining")
      (i) :
        false       

    ;Instruction specific constraints
    match(i) :
      (i:ArgIns) :
        ensure-no-mem-locs(ret(i))
      (i:CallRecordIns) :
        ensure-no-mem-locs(ret(i))
        ensure-no-mem-locs(args(i))
        ensure-no-shadows(args(i))
        ensure-args-in-locals(args(i))
      (i:ReturnRecordIns) :
        ensure-no-mem-locs(args(i))
        ensure-no-shadows(args(i))
        ensure-args-in-locals(args(i))
      (i:MatchIns|DispatchIns) :
        ensure-no-mem-locs(match-records(ys(i), backend))
      (i:StoreIns) :
        fatal("Variable offset remaining") when y(i) is VMImm
      (i:LoadIns) :
        fatal("Variable offset remaining") when z(i) is VMImm
      (i:Op1Ins) :
        match(op(i)) :
          (op:ConvOp|InterpretOp) : ensure-local(y(i))
          (op:NotOp) : ensure-not-byte(x(i))
          (op:NegOp) :
            ensure-not-byte(x(i))
            ensure-not-real(x(i))
          (op) : false
      (i:Op2Ins) :
        match(op(i)) :
          (op:DivOp|ModOp) :
            if integral?(type(buffer, x(i))) :
              fatal("Integral div/mod op remaining.")
          (op:MulOp) :
            ensure-not-byte(x(i))
          (op:VMOp&Comparison) :
            ensure-one-local(y(i), z(i))
          (op) :
            false
      (i:DualOp2Ins) :
        match(op(i)) :
          (op:DivModOp) :
            ensure-not-byte(x(i))
            ensure-not-byte(y(i))            
            ensure-local(z(i))
            ensure-local(w(i))
          (op) : false          
      (i) :
        false

    ;General checks
    ensure-operand-sizes(i)
    ensure-lowlevel-ops(i)

;============================================================
;================== Data Buffer =============================
;============================================================

deftype DataBuffer
defmulti make-data (b:DataBuffer, data:ByteArray) -> Int
defmulti datas (b:DataBuffer) -> Tuple<VMData>

defn DataBuffer (p:VMPackage) :
  val ids = IntSet()
  defn take-ids<?T> (id:T -> Int, xs:Seqable<?T>) :
    add-all(ids, seq(id, xs))
  take-ids(id, globals(p))
  take-ids(id, datas(p))
  take-ids(id, consts(p))
  take-ids(id, classes(p))
  take-ids(id, funcs(p))
  take-ids(id, externs(p))  

  val id-counter = to-seq(0 to false)
  defn* make-id () :
    val id = next(id-counter)
    if ids[id] : make-id()
    else : id

  val datas = Vector<VMData>()
  new DataBuffer :
    defmethod make-data (this, data:ByteArray) :
      val id = make-id()
      add(datas, VMData(id, data))
      id
    defmethod datas (this) :
      to-tuple(datas)

;============================================================
;=================== Instruction Buffer =====================
;============================================================

deftype InsBuffer
defmulti type (b:InsBuffer, x:VMImm) -> VMType
defmulti emit (b:InsBuffer, i:VMIns) -> False
defmulti to-func (b:InsBuffer) -> VMFunc
defmulti make-label (b:InsBuffer) -> Int
defmulti make-local (b:InsBuffer, t:VMType) -> Local

defn InsBuffer (function:VMFunction) :
  val def-table = IntTable<VMDef>()
  val label-set = IntSet()
  val buffer = Vector<VMIns>()
  val def-counter = to-seq(0 to false)
  val label-counter = to-seq(0 to false)
  
  defn do-functions (f:VMFunc -> ?) :
    match(function) :
      (func:VMFunc) :
        f(func)
      (func:VMMultifn) :
        do(f{value(_)}, funcs(func))
        f(default(func))  
  defn load-defs (f:VMFunc) :  
    for d in defs(f) do : def-table[id(d)] = d
  defn load-labels (f:VMFunc) :
    for i in filter-by<LabelIns>(ins(f)) do :
      add(label-set, n(i))    
  do-functions(load-defs)
  do-functions(load-labels)

  new InsBuffer :
    defmethod type (this, x:VMImm) :
      match(x:Local) : type(def-table[index(x)])
      else : type(x)
    defmethod emit (this, i:VMIns) :
      add(buffer, i)
    defmethod to-func (this) :
      val all-defs = to-tuple(values(def-table))
      VMFunc([], all-defs, to-tuple(buffer))
    defmethod make-label (this) :
      let loop () :
        val n = next(label-counter)
        if label-set[n] : loop()
        else : n
    defmethod make-local (this, t:VMType) :
      val n = let loop () :
        val i = next(def-counter)
        if key?(def-table, i) : loop()
        else : i
      def-table[n] = VMDef(n, t)
      Local(n)