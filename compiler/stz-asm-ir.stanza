defpackage stz/asm-ir :
   import core
   import verse

;======== Utilities ========
val id-counter = to-stream(0 to false)

;======== Assembly Operations ========
public defstruct AsmOp :
   id:Int
   name:Symbol
   
defmethod equal? (a:AsmOp, b:AsmOp) :
   id(a) == id(b)

defn AsmOp (name:Symbol) : AsmOp(next(id-counter), name)
public val ADD-OP = AsmOp(`ADD)
public val SUB-OP = AsmOp(`SUB)
public val MUL-OP = AsmOp(`MUL)
public val DIV-OP = AsmOp(`DIV)
public val MOD-OP = AsmOp(`MOD)
public val DIVMOD-OP = AsmOp(`DIVMOD)
public val AND-OP = AsmOp(`AND)
public val OR-OP = AsmOp(`OR)
public val XOR-OP = AsmOp(`XOR)
public val SHL-OP = AsmOp(`SHL)
public val SHR-OP = AsmOp(`SHR)
public val ASHR-OP = AsmOp(`ASHR)
public val EQ-OP = AsmOp(`EQ)
public val NE-OP = AsmOp(`NE)
public val LT-OP = AsmOp(`LT)
public val GT-OP = AsmOp(`GT)
public val LE-OP = AsmOp(`LE)
public val GE-OP = AsmOp(`GE)
public val ULE-OP = AsmOp(`ULE)
public val ULT-OP = AsmOp(`ULT)
public val UGT-OP = AsmOp(`UGT)
public val UGE-OP = AsmOp(`UGE)
public val NOT-OP = AsmOp(`NOT)
public val NEG-OP = AsmOp(`NEG)

;======== Assembly Types ========
public defstruct AsmType :
   id: Int
   name: Symbol
   
defmethod equal? (a:AsmType, b:AsmType) :
   id(a) == id(b)

defn AsmType (name:Symbol) : AsmType(next(id-counter), name)   
public val BYTE-TYPE = AsmType(`BYTE)
public val INT-TYPE = AsmType(`INT)
public val LONG-TYPE = AsmType(`LONG)
public val FLOAT-TYPE = AsmType(`FLOAT)
public val DOUBLE-TYPE = AsmType(`DOUBLE)

;======== Assembly Instructions ========
public definterface Ins
public defstruct XchgIns <: Ins :
   x: Loc
   y: Loc
public defstruct SetIns <: Ins :
   type: AsmType
   x: Loc
   y: Imm
public defstruct ConvertIns <: Ins :
   xtype: AsmType
   x: Loc
   ytype: AsmType
   y: Imm
public defstruct ReinterpretIns <: Ins :
   xtype: AsmType
   x: Loc
   ytype: AsmType
   y: Imm
public defstruct UnaOp <: Ins :
   type: AsmType
   x: Loc
   op: AsmOp
   y: Imm
public defstruct BinOp <: Ins :
   type: AsmType
   x: Loc
   op: AsmOp
   y: Imm
   z: Imm
public defstruct DualOp <: Ins :
   type: AsmType
   x1: Loc
   x2: Loc
   op: AsmOp
   y: Imm
   z: Imm
public defstruct Load <: Ins :
   type: AsmType
   x: Loc
   y: Imm
   offset: Int
public defstruct Store <: Ins :
   type: AsmType
   x: Imm
   y: Imm
   offset: Int
public defstruct Call <: Ins :
   x: Imm
public defstruct Return <: Ins
public defstruct Goto <: Ins :
   x: Imm
public defstruct Branch <: Ins :
   type: AsmType
   x: Imm
   op: AsmOp
   y: Imm
   z: Imm   
public defstruct Label <: Ins :
   n: Int
public defstruct ExLabel <: Ins :
   name: Symbol

;======== Data Instructions ========
public defstruct DefData <: Ins
public defstruct DefText <: Ins
public defstruct DefByte <: Ins :
   value: Int
public defstruct DefInt <: Ins :
   value: Int
public defstruct DefLong <: Ins :
   value: Long
public defstruct DefFloat <: Ins :
   value: Float
public defstruct DefDouble <: Ins :
   value: Float
public defstruct DefString <: Ins :
   value: String
public defstruct DefSpace <: Ins :
   size: Int
public defstruct DefLabel <: Ins :
   n: Int

;======== Assembly Immediates ========
public definterface Imm
public defstruct IntImm <: Imm :
   value: Int|Long

public definterface Loc <: Imm
public defstruct Reg <: Loc : (n:Int)
public defstruct FReg <: Loc : (n:Int)
public defstruct RegSP <: Loc
public defstruct Mem <: Loc : (n:Int, offset:Int)
public defstruct ExMem <: Loc : (name:Symbol, offset:Int)

defmethod equal? (a:Imm, b:Imm) :
   match(a, b) :
      (a:Reg, b:Reg) : n(a) == n(b)
      (a:FReg, b:FReg) : n(a) == n(b)
      (a:RegSP, b:RegSP) : true
      (a:Mem, b:Mem) : (n(a) == n(b)) and (offset(a) == offset(b))
      (a:ExMem, b:ExMem) : (name(a) == name(b)) and (offset(a) == offset(b))
      (a:IntImm, b:IntImm) : value(a) == value(b)
      (a, b) : false

;======== Printer =========
defmethod print (o:OutputStream, op:AsmOp) :
   print(o, name(op)) 

defmethod print (o:OutputStream, t:AsmType) :
   print(o, name(t))

defmethod print (o:OutputStream, i:Ins) :
   print{o, _} $ match(i) :
      (i:XchgIns) : "   ~ <=> ~" << [x(i), y(i)]
      (i:SetIns) : "   ~: ~ = ~" << [type(i), x(i), y(i)]
      (i:ConvertIns) : "   ~:~ = ~:~" << [xtype(i), x(i), ytype(i), y(i)]
      (i:ReinterpretIns) : "   ~:~ = reinterpret ~:~" << [xtype(i), x(i), ytype(i), y(i)]
      (i:UnaOp) : "   ~: ~ = ~ ~" << [type(i), x(i), op(i), y(i)]
      (i:BinOp) : "   ~: ~ = ~ ~ ~" << [type(i), x(i), y(i), op(i), z(i)]
      (i:DualOp) : "   ~: ~, ~ = ~ ~ ~" << [type(i), x1(i), x2(i), y(i), op(i), z(i)]
      (i:Load) : "   ~: ~ = [~ + ~]" << [type(i), x(i), y(i), offset(i)]
      (i:Store) : "   ~: [~ + ~] = ~" << [type(i), x(i), offset(i), y(i)]
      (i:Call) : "   call ~" << [x(i)]
      (i:Return) : "   return"
      (i:Goto) : "   goto ~" << [x(i)]
      (i:Branch) : "   ~: branch ~ when ~ ~ ~" << [type(i), x(i), y(i), op(i), z(i)]
      (i:Label) : "L<~>" << [n(i)]
      (i:ExLabel) : "L<~>" << [name(i)]
      (i:DefData) : "   .data"
      (i:DefText) : "   .text"
      (i:DefByte) : "   .byte ~" << [value(i)]
      (i:DefInt) : "   .int ~" << [value(i)]
      (i:DefLong) : "   .long ~" << [value(i)]
      (i:DefFloat) : "   .float ~" << [value(i)]
      (i:DefDouble) : "   .double ~" << [value(i)]
      (i:DefString) : "   .string ~" << [value(i)]
      (i:DefSpace) : "   .space ~" << [size(i)]
      (i:DefLabel) : "   .label L<~>" << [n(i)]

defmethod print (o:OutputStream, i:Imm) :
   print{o, _} $ match(i) :
      (i:IntImm) : value(i)
      (i:Reg) : "R~" << [n(i)]
      (i:FReg) : "F~" << [n(i)]
      (i:RegSP) : "RSP"
      (i:Mem) : "L<~ + ~>" << [n(i), offset(i)]
      (i:ExMem) : "L<~ + ~>" << [name(i), offset(i)]
      