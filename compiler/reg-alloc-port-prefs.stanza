defpackage stz/reg-alloc-port-prefs :
  import core
  import collections
  import stz/reg-alloc-engine
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-pref-scanner
  import stz/reg-alloc-model-env
  import stz/reg-alloc-block-processing

public defn compute-port-prefs (program:Program, models:ModelEnv, blocks:Vector<Block>) -> False :
  do(compute-local-port-prefs{program, models, _}, blocks)
  propagate-prefs(blocks)
  for block in blocks do :
    do(ensure-valid-pref!{prefs(_) as PortPref}, inputs(block))
    do(ensure-valid-pref!{prefs(_) as PortPref}, outputs(block))

;============================================================
;==================== Postconditions ========================
;============================================================

;Ensure that the computed preference is valid.
defn ensure-valid-pref! (pref:PortPref) -> False :
  if save-pref(pref) is PreferSaveIfSuccessor :
    fatal("Unexpected remaining PreferSaveIfSuccessor.")
  if load-pref(pref) is PreferUnloadIfSuccessor :
    fatal("Unexpected remaining PreferUnloadIfSuccessor.")
  if load-pref(pref) is PreferUnload and
     save-pref(pref) is NoPreferSave :
    fatal("Unexpected load/save combination. A port both prefers \
           to be unloaded and unsaved.")

;============================================================
;================== Local Analysis ==========================
;============================================================

;After computing local prefs, these are the states:
;1) Vx enters this block, and this block requires it
;   to be saved. I.e. this block calls a function which
;   clears all registers.
;2) Vx enters this block, and this block prefers it
;   to be loaded. I.e. this block immediately uses
;   Vx as an argument to an operation.
;3) Vx enters this block, but doesn't have any
;   local preference for how Vx is treated. That
;   depends upon successors.

;Compute local port preferences.
defn compute-local-port-prefs (program:Program, models:ModelEnv, b:Block) -> False :
  ;Scan through statements using the PrefScanner.
  val pref-scanner = PrefScanner(models)
  scan-output-ports(pref-scanner, outputs(b))
  within (i, op) = operations-in-reverse(program, b) :
    scan-stmt(pref-scanner, i, op)

  ;Write the calculated quantities to the block.
  val new-input-ports = to-tuple $ for p in inputs(b) seq :
    sub-prefs(p, preference(pref-scanner, id(p)))
  set-contents(inputs(b), new-input-ports)

;============================================================
;================== Propagation Analysis ====================
;============================================================

;Returns true if the input preferences have changed.
defn compute-output-prefs (blocks:Vector<Block>,
                           b:Block) -> True|False :
  ;Compute list of all merged preferences.
  val merged-prefs = IntTable<List<PortPref>>(List())
  for succ in succ-blocks(blocks,b) do :
    ;First record the default preference for all outputs
    ;of the original block: PortPref(NoPreferSave, NoPreferUnload)
    for p in outputs(b) do :
      val default-pref = PortPref(NoPreferSave, NoPreferUnload, false)
      update(merged-prefs, cons{default-pref, _}, id(p))
    ;Then overwrite the default preference by the preference
    ;of the input.
    for p in inputs(succ) do :
      val prefs = prefs(p) as PortPref
      update(merged-prefs, sub-head{_, prefs}, id(p))
      
  ;Update output ports.
  for p in outputs(b) update :
    val new-prefs = merge(merged-prefs[id(p)])
    One(sub-prefs(p, new-prefs))
  ;Update input ports.
  inherit-prefs(inputs(b), outputs(b))
  
;Inherit the preferences of output-ports into input-ports,
;if preferences are specified to be inherited from successors.
defn inherit-prefs (input-ports:Vector<Port>,
                    output-ports:Vector<Port>) -> True|False :
  var inputs-changed?:True|False = false
  val output-prefs = to-inttable<PortPref> $
    for p in output-ports seq : id(p) => prefs(p) as PortPref
  for p in input-ports update :
    val prefs = prefs(p) as PortPref
    val output-prefs = get?(output-prefs, id(p))
    val new-save-pref = match(save-pref(prefs)) :
      (p:PreferSaveIfSuccessor) : save-pref(output-prefs as PortPref)
      (p) : p
    val new-load-pref = match(load-pref(prefs)) :
      (p:PreferUnloadIfSuccessor) : load-pref(output-prefs as PortPref)
      (p) : p
    val new-prefs = PortPref(new-save-pref, new-load-pref, false)
    if new-prefs != prefs :
      inputs-changed? = true
    One(sub-prefs(p, new-prefs))
  inputs-changed?

;Compute the merged port preferences.
defn merge (prefs:List<PortPref>) -> PortPref :

  defn rank-load (p:LoadPref) -> Int :
    switch(p) :
      ;Always opt to do the least work. If one successor
      ;does not prefer for the variable to be unloaded, then do not
      ;eagerly unload the variable.
      NoPreferUnload: 0
      ;If we don't know yet what the successor dires, then
      ;keep this so we can continue calculating.
      PreferUnloadIfSuccessor: 1
      ;Finally, if we know all the successors prefer for the
      ;variable to be eagerly unloaded, then unload it.
      PreferUnload: 2

  defn rank-save (p:SavePref) -> Int :
    switch(p) :
      ;Always opt to do the least work. If one
      ;of the successors don't require the variable to be saved,
      ;then don't eagerly force a variable to be saved.
      NoPreferSave: 0
      ;If we don't know yet what the successor desired, then
      ;keep this so we continue calculating.
      PreferSaveIfSuccessor: 1
      ;Finally, if we know all the successors prefer to save,
      ;then we know we want to save.
      PreferSave: 2

  ;Sanity check:
  if empty?(prefs) :
    fatal("Unexpected empty merge.")
  PortPref(
    minimum(rank-save, seq(save-pref, prefs))
    minimum(rank-load, seq(load-pref, prefs))
    false)

;============================================================
;=============== Propagate until Convergence ================
;============================================================

;Propagate inputs and outputs across blocks.
defn propagate-prefs (blocks:Vector<Block>) -> False :
  within (block) = iterative-block-analysis(blocks, reverse-order(blocks)) :
    compute-output-prefs(blocks, block)    

;============================================================
;==================== Helpers ===============================
;============================================================

;Helper: Return all the successors block of the given block.
defn succ-blocks (blocks:Vector<Block>, b:Block) -> Seqable<Block> :
  for succ in succs(b) seq :
    blocks[succ]

;Helper: Set the contents of the given vector.
defn set-contents<?T> (vs:Vector<?T>, xs:Seqable<T>) :
  clear(vs)
  add-all(vs,xs)      

;Replace the head of a list.
defn sub-head<?T> (xs:List<?T>, head:T) -> List<T> :
  cons(head, tail(xs))