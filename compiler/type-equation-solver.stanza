defpackage stz/type-equation-solver :
  import core
  import collections
  import stz/types
  import stz/type-locs
  import stz/type-solver
  import stz/type-variance
  import stz/type-equations
  import stz/type-hierarchy
  import stz/type-formatter

;============================================================
;====================== SolverState =========================
;============================================================

;Complete state of the solver in-between iterations.
;- solved: Each entry, V => VAL, means that the variable V
;  has been solved and has value VAL.
;- blocked: Each entry, V => (E1, E2, E3 ...), means that the
;  equations E1, E2, E3 cannot make progress, and that V is
;  one of the variables that could be holding it up. An equation
;  E is allowed to appear under multiple V, and even under the same
;  V multiple times.
;- eqns: The list of active equations to solve until queue
;  is empty.
;- num-solved: The number of variables in 'solved' that holds
;  a SolvedType.
public defstruct SolverState :
  hierarchy: TypeHierarchy
  solved: IntTable<SolverValue> with:
    init => IntTable<SolverValue>()
  blocked: IntTable<List<TypeEqn>> with:
    init => IntTable<List<TypeEqn>>(List())
  eqns: Queue<TypeEqn> with:
    init => Queue<TypeEqn>()
  num-solved:Int with:
    init => 0
    setter => set-num-solved

;============================================================
;===================== Solver Values ========================
;============================================================

;The possible values that a solver variable can take on.
public deftype SolverValue

;Fill status: Indicates the properties of a solved type.
deftype FillStatus

;The type contains no TUVar anymore.
defstruct FilledCompletely <: FillStatus
with:
  printer => true

;The type contains no TUVar to an already-solved
;variable, at the time when 'num-solved' variables
;were solved.
defstruct FilledWithSolved <: FillStatus :
  num-solved:Int
with:
  printer => true

;The type may contain TUVar to an already-solved
;variable.
defstruct Unfilled <: FillStatus
with:
  printer => true

;The variable was solved.
public defstruct SolvedType <: SolverValue :
  value:Type
  variance:Variance
  fill-status:FillStatus
with:
  printer => true

;The variable cannot be solved because the constraints are
;unsatisfiable.
public defstruct Unsatisfiable <: SolverValue
with:
  printer => true

;The variable cannot be solved because it depends upon a
;variable that is either unsatisfiable or unprogressable.
public defstruct Unprogressable <: SolverValue
with:
  printer => true

;============================================================
;======================= Formatting =========================
;============================================================

public defn format (f:TypeFormatter, v:SolverValue) :
  match(v) :
    (v:SolvedType) : "SolvedType(%_, %_)" % [format(f,value(v)), fill-status(v)]
    (v) : v

;============================================================
;===================== Public API ===========================
;============================================================

;Create a new SolverState primed with the given equations.
public defn SolverState (eqns:Seqable<TypeEqn>,
                         hier:TypeHierarchy) -> SolverState :
  val state = SolverState(hier)
  do(push-eqn{state, _}, eqns)
  state

;Solve as many equations as possible.
public defn solve (s:SolverState) -> False :
  solve-until-empty(solve-eqn, s)

;Return the solution for the given variable.
public defn get (s:SolverState, v:Int) -> SolverValue :
  fatal("Not yet implemented")

;Return all the solutions.
public defn solutions (s:SolverState) -> Tuple<KeyValue<Int,SolverValue>> :
  to-tuple(solved(s))

;============================================================
;======================== Solve =============================
;============================================================

;Return true if there are no more equations to solve.
defn empty? (s:SolverState) -> True|False :
  empty?(eqns(s))

;Return the next equation to solve.
defn next-eqn (s:SolverState) -> TypeEqn :
  pop(eqns(s))

;Returns the current number of equations in the active queue.
defn num-eqns (s:SolverState) -> Int :
  length(eqns(s))

;Returns all the blocked equations in the solver.
defn blocked-eqns (s:SolverState) -> Seqable<TypeEqn> :
  cat-all(values(blocked(s)))

;Push another equation to the solver.
defn push-eqn (s:SolverState, e:TypeEqn) -> False :
  add(eqns(s), e)

;Return true if the given variable has already been solved.
defn solved? (s:SolverState, v:Int) -> True|False :
  key?(solved(s), v)

;Indicate that the equation is blocked on a set of
;variables.
defn blocked (s:SolverState, eqn:TypeEqn, vars:Collection<Int>) -> False :
  debugln("blocked on (%,): %_" % [debugfmt(vars), debugfmt(eqn)])
  for v in vars do :
    update(blocked(s), cons{eqn, _}, v)

;Set the status of a variable.
defn set-var (s:SolverState, v:Int, variance:Variance|False, given-value:SolverValue) -> False :
  ;Trace the message.
  debugln("set-var %_ = %_" % [debugfmt(v), debugfmt(given-value)])
  
  ;Sanity check: Ensure that the given variable hasn't already been solved.
  if solved?(s,v) :
    fatal("Variable V%_ has already been solved." % [v])

  ;First preprocess the given value by removing cycles.
  val value =
    match(given-value:SolvedType)  :
      val variance = variance as Variance
      match(remove-cycle(v, variance, value(given-value))) :
        (new-t:Type) : SolvedType(new-t, variance, fill-status(given-value))
        (f:False) : Unsatisfiable()
    else :
      given-value

  ;Set the variable as solved.
  solved(s)[v] = value

  ;Increment the number of solved
  if value is SolvedType :
    set-num-solved(s, num-solved(s) + 1)

  ;Retrieve any equations that are blocked by the given variable.
  val blocked-eqns = blocked(s)[v]
  if remove(blocked(s),v) :

    ;Either put the blocked equations onto the queue, or
    ;mark their output variables as unprogressable.
    within debug-indent() :
      match(value) :
        (value:Unsatisfiable|Unprogressable) :
          ;If value is unsatisfiable/unprogressable than all equations
          ;blocked on this variable is unprogressable.
          for e in blocked-eqns do :
            for v in e do-output-vars :
              set-var(s, v, false, Unprogressable()) when not solved?(s,v)
        (value) :
          ;Otherwise, all equations blocked on this variable gets
          ;pushed back onto the queue.
          for e in blocked-eqns do :
            push-eqn(s, e)

;Main loop.
defn solve-until-empty (solve:(TypeEqn, SolverState) -> False,
                        s:SolverState) -> False :    
  ;Preprocess the equations.
  preprocess-eqns(s)
  
  ;Begin dataflow solving.
  while not empty?(s) :
    val e = next-eqn(s)
    debugln("solve-until-empty %_" % [debugfmt(e)])
    within debug-indent() :
      val filled-e = fill-solved(fill-solved-type{_, s}, e)
      debugln("filled: %_" % [debugfmt(filled-e)])
      solve-eqn(filled-e, s)
      
  ;Indicate that blocked equations can no longer
  ;make progress.
  for e in blocked-eqns(s) do :
    debugln("remaining eqn: %_" % [debugfmt(e)])
    for v in e do-output-vars :
      set-var(s, v, false, Unprogressable())

  ;Perform backsubstitution.
  val solved-entries = to-tuple(solved(s))
  for e in solved-entries do :
    debugln("backsubstitution for %_ = %_ :" % [debugfmt(key(e)), debugfmt(value(e))])
    within debug-indent() :
      get-filled-solved(key(e), s)

;============================================================
;================ Cycle Removal/Detection ===================
;============================================================

;Remove a cycle around uvar from the given type.
;Returns false if the cycle cannot be removed.
defn remove-cycle (uvar:Int, variance:Variance, t:Type) -> Type|False :
  switch(variance) :
    Covariant : remove-covariant-cycle(uvar, t)
    Contravariant : remove-contravariant-cycle(uvar, t)

;Perform the covariant case of cycle removal.
defn remove-covariant-cycle (uvar:Int, t:Type) -> Type|False :
  label<Type|False> return :
    val ts = Vector<Type>()
    let loop (t:Type = simplify(t)) :
      match(t) :
        (t:TOr) :
          loop(a(t))
          loop(b(t))
        (t:TUVar) :
          add(ts,t) when n(t) != uvar
        (t) :
          if occurs?(uvar,t) : return(false)
          else : add(ts, t)
    if empty?(ts) : TBot()
    else : reduce(TOr,ts)

;Perform the contravariant case of cycle removal.
defn remove-contravariant-cycle (uvar:Int, t:Type) -> Type|False :
  label<Type|False> return :
    val ts = Vector<Type>()
    let loop (t:Type = simplify(t)) :
      match(t) :
        (t:TAnd) :
          loop(a(t))
          loop(b(t))
        (t:TUVar) :
          add(ts,t) when n(t) != uvar
        (t) :
          if occurs?(uvar,t) : return(false)
          else : add(ts, t)
    if empty?(ts) : TGradual()
    else : reduce(TAnd,ts)
  
;Return true if the given type contains the given unification
;variable.
defn occurs? (uvar:Int, t:Type) -> True|False :
  match(t:TUVar) :
    n(t) == uvar
  else :
    any?(occurs?{uvar, _ as Type}, t)

;============================================================
;================== Output Variables ========================
;============================================================

;Retrieve the output variables for the given equation.
defn do-output-vars (f:Int -> False, e:TypeEqn) -> False :
  match(e) :
    (e:CaptureEqn) :
      fatal("Not yet implemented")
    (e:InferEqn) :
      fatal("Not yet implemented")
    (e:OverloadExpEqn) :
      fatal("Not yet implemented")
    (e:OverloadCallEqn) :
      fatal("Not yet implemented")
    (e:SubEqn) :
      fatal("Not yet implemented")
    (e:SuperEqn) :
      fatal("Not yet implemented")

;============================================================
;==================== Fill Solved Type ======================
;============================================================

;Based upon the unalready solved variables, fill in the missing
;TUVars.
defn fill-solved (type:Type, s:SolverState) -> [Type, FillStatus] :
  ;Status variables
  
  ;Turns to true if output is not the same as the
  ;input type.
  var changed?:True|False = false
  
  ;Turns to true if output contains at least one TUVar.
  var has-tuvar?:True|False = false

  ;Compute the filled type, and adjust the status
  ;variables appropriately.
  defn fill (t:Type) -> Type :
    match(t:TUVar) :
      match(get-filled-solved(n(t), s)) :
        (t:SolvedType) :
          ;Successfully filled the TUVar.
          changed? = true
          match(fill-status(t)) :
            (s:FilledCompletely) :
              value(t)
            (s:FilledWithSolved) :
              ;Still contains some remaining TUVar.
              has-tuvar? = true
              value(t)
        (f:Unsatisfiable|False) :
          ;Couldn't fill the TUVar, so set the flag.
          has-tuvar? = true
          t
    else :
      map(fill{_ as Type}, t)

  ;Compute the new filled type.
  val new-type = let :
    val filled = fill(type)
    simplify(filled) when changed? else type

  ;Compute the new status.
  val new-status =
    if has-tuvar? : FilledWithSolved(num-solved(s))
    else : FilledCompletely()

  ;Return the bundled result.
  [new-type, new-status]

;Retrieve the solved type for variable v.
;Or false if v is not solved.
defn get-filled-solved (v:Int, state:SolverState) -> SolverValue|False :
  match(get?(solved(state), v)) :
    (t:SolvedType) :
      ;Compute whether we need to continue recursively
      ;filling the returned type.
      val done? = match(fill-status(t)) :
        (s:FilledCompletely) : true
        (s:Unfilled) : false
        (s:FilledWithSolved) : num-solved(s) == num-solved(state)
        
      ;Either continue or return.
      if done? :
        t
      else :
        val [new-t, new-fill] = fill-solved(value(t),state)
        val processed-t = remove-cycle(v, variance(t), new-t)
        val new-value = 
          match(processed-t:Type) : SolvedType(processed-t, variance(t), new-fill)
          else : Unsatisfiable()
        debugln("update variable: %_ = %_" % [debugfmt(v), debugfmt(new-value)])
        solved(state)[v] = new-value
        new-value
    (f) :
      false

;Extract the type of a fill result.
defn fill-solved-type (type:Type, s:SolverState) -> Type :
  val [new-type, fill-status] = fill-solved(type,s)
  new-type

;============================================================
;================= Fill Solved Equation =====================
;============================================================

;Fill the solved variables in the given equation.
defn fill-solved (f:Type -> Type, e:TypeEqn) -> TypeEqn :
  defn g (t:Type) : f(t)
  defn g (x:InferLoc) : x
  defn g (x:Tuple<TFunction>) : map({f(_) as TFunction},x)
  defn g (x:Tuple<TArrow>) : map({f(_) as TArrow},x)
  defn g (x:FArg) : map(f{_ as Type}, x)
  defn g (x:Tuple<FArg>) : map(g, x)
  defn g (e:KeyValue<Int,Type>) : key(e) => f(value(e))
  defn g (e:Tuple<KeyValue<Int,Type>>) : map(g,e)
  match(e) :
    (e:CaptureEqn) : CaptureEqn(n(e), variance(e), f(a(e)), b(e))
    (e:InferEqn) : InferEqn(n(e), g(a(e)), g(b(e)))
    (e:OverloadExpEqn) : OverloadExpEqn(n(e), sel(e), g(xs(e)), f(y(e)))
    (e:OverloadCallEqn) : OverloadCallEqn(n(e), sel(e), g(xs(e)), g(args(e)))
    (e:SubEqn) : SubEqn(n(e), g(x(e)), g(ys(e)))
    (e:EqualEqn) : EqualEqn(n(e), g(type(e)))
    (e) : fatal("%_ equation is not part of main solver loop." % [object-type(e)])

;============================================================
;=================== Preprocessing Stage ====================
;============================================================

;Preprocess the CaptureAllEqn and SuperEqn equations.
defn preprocess-eqns (s:SolverState) -> False :
  ;Gather all the super constraints.
  val super-table = IntTable<List<Type>>(List())

  ;Iterate through equations and preprocess each in turn.
  for i in 0 to num-eqns(s) do :
    match(next-eqn(s)) :
      ;Convert CaptureAllEqn into individual CaptureEqn.
      (e:CaptureAllEqn) :
        val entries = capture-variance(ns(e), b(e))
        for entry in entries do :
          val n = key(entry)
          val variance = value(entry)
          push-eqn(s, CaptureEqn(n, variance, a(e), b(e)))
      ;Gather SuperEqn and output as equal eqn.
      (e:SuperEqn) :
        update(super-table, cons{x(e), _}, n(e))
      ;All other equations are unprocessed.
      (e) :
        push-eqn(s,e)
        
  ;Push the new super constraints.
  for entry in super-table do :
    val n = key(entry)
    val t = reduce(TOr, value(entry))
    push-eqn(s, EqualEqn(n,t))

;============================================================
;====================== Solve ===============================
;============================================================

defmulti solve-eqn (e:TypeEqn, s:SolverState) -> False

defmethod solve-eqn (e:CaptureEqn, s:SolverState) -> False :
  match(capture(n(e), variance(e), a(e), b(e), hierarchy(s))) :
    (b:Blocked) : blocked(s, e, tvars(b))
    (f:False) : set-var(s, n(e), false, Unsatisfiable())
    (t:Type) : set-var(s, n(e), variance(e), SolvedType(t, variance(e), Unfilled()))

defmethod solve-eqn (e:EqualEqn, s:SolverState) -> False :
  set-var(s, n(e), Covariant, SolvedType(type(e), Covariant, Unfilled()))

defmethod solve-eqn (e:InferEqn, s:SolverState) -> False :
  match(infer(a(e), b(e), hierarchy(s))) :
    (b:Blocked) : blocked(s, e, tvars(b))
    (f:False) : set-var(s, n(e), false, Unsatisfiable())
    (t:Type) :
      val variance = capture-variance(a(e),b(e))
      set-var(s, n(e), variance, SolvedType(t, variance, Unfilled()))

defmethod solve-eqn (e:SubEqn, s:SolverState) -> False :
  match(remove-cycle(n(e), Covariant, x(e))) :
    (xtype:Type) :
      val ys-table = to-inttable<Type>(ys(e))
      val uvars = Vector<Int>()
      val new-x = let loop (t:Type = xtype) :
        match(t) :
          (t:TUVar) : (add(uvars,n(t)), t)
          (t:TVar) : get?(ys-table, n(t), t)
          (t) : map(loop{_ as Type}, t)
      if empty?(uvars) : set-var(s, n(e), Covariant, SolvedType(new-x, Covariant, Unfilled()))
      else : blocked(s, e, uvars)
    (f:False) :
      set-var(s, n(e), false, Unsatisfiable())  
    

;============================================================
;====================== Debugging ===========================
;============================================================

var DEBUG-TRACE:True|False = true
var DEBUG-FORMATTER:TypeFormatter|False = false

public defn set-debug-formatter (f:TypeFormatter) -> False :
  DEBUG-FORMATTER = f

defn debug-indent<?T> (body:() -> ?T) -> T :
  if DEBUG-TRACE :
    indented(body)
  else :
    body()

defn debugfmt (x:TypeEqn) :   
  match(DEBUG-FORMATTER:TypeFormatter) : format(DEBUG-FORMATTER,x)
  else : x

defn debugfmt (x:Int) :   
  match(DEBUG-FORMATTER:TypeFormatter) : format(DEBUG-FORMATTER,TVar(x,false))
  else : x

defn debugfmt (xs:Collection<Int>) :
  seq(debugfmt, xs)

defn debugfmt (x:Type) :   
  match(DEBUG-FORMATTER:TypeFormatter) : format(DEBUG-FORMATTER,x)
  else : x

defn debugfmt (v:SolverValue) :
  match(DEBUG-FORMATTER:TypeFormatter) : format(DEBUG-FORMATTER,v)
  else : x  

defn debugln (msg) :
  println(msg)

