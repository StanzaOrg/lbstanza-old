defpackage stz/type-equation-solver :
  import core
  import collections
  import stz/types
  import stz/type-solver
  import stz/type-equations

;============================================================
;====================== SolverState =========================
;============================================================

;Complete state of the solver in-between iterations.
;- solved: Each entry, V => VAL, means that the variable V
;  has been solved and has value VAL.
;- blocked: Each entry, V => (E1, E2, E3 ...), means that the
;  equations E1, E2, E3 cannot make progress, and that V is
;  one of the variables that could be holding it up. An equation
;  E is allowed to appear under multiple V, and even under the same
;  V multiple times.
;- eqns: The list of active equations to solve until queue
;  is empty.
;- num-solved: The number of variables in 'solved' that holds
;  a SolvedType.
public defstruct SolverState :
  solved: IntTable<SolverValue> with:
    init => IntTable<SolverValue>()
  blocked: IntTable<List<TypeEqn>> with:
    init => IntTable<List<TypeEqn>>(List())
  eqns: Queue<TypeEqn> with:
    init => Queue<TypeEqn>()
  num-solved:Int with:
    init => 0
    setter => set-num-solved

;============================================================
;===================== Solver Values ========================
;============================================================

;The possible values that a solver variable can take on.
public deftype SolverValue

;Fill status: Indicates the properties of a solved type.
deftype FillStatus

;The type contains no TUVar anymore.
defstruct FilledCompletely <: FillStatus

;The type contains no TUVar to an already-solved
;variable, at the time when 'num-solved' variables
;were solved.
defstruct FilledWithSolved <: FillStatus :
  num-solved:Int

;The type may contain TUVar to an already-solved
;variable.
defstruct Unfilled <: FillStatus

;The variable was solved.
public defstruct SolvedType <: SolverValue :
  value:Type
  fill-status:FillStatus

;The variable cannot be solved because the constraints are
;unsatisfiable.
public defstruct Unsatisfiable <: SolverValue

;The variable cannot be solved because it depends upon a
;variable that is either unsatisfiable or unprogressable.
public defstruct Unprogressable <: SolverValue

;============================================================
;===================== Public API ===========================
;============================================================

;Create a new SolverState primed with the given equations.
public defn SolverState (eqns:Seqable<TypeEqn>) -> SolverState :
  val state = SolverState()
  do(push-eqn{state, _}, eqns)
  state

;Solve as many equations as possible.
public defn solve (s:SolverState) -> False :
  solve-until-empty(solve-eqn, s)

;Return the solution for the given variable.
public defn get (s:SolverState, v:Int) -> SolverValue :
  fatal("Not yet implemented")

;Return all the solutions.
public defn solutions (s:SolverState) -> Tuple<KeyValue<Int,SolverValue>> :
  to-tuple(solved(s))

;============================================================
;======================== Solve =============================
;============================================================

;Return true if there are no more equations to solve.
defn empty? (s:SolverState) -> True|False :
  empty?(eqns(s))

;Return the next equation to solve.
defn next-eqn (s:SolverState) -> TypeEqn :
  pop(eqns(s))

;Push another equation to the solver.
defn push-eqn (s:SolverState, e:TypeEqn) -> False :
  add(eqns(s), e)

;Return true if the given variable has already been solved.
defn solved? (s:SolverState, v:Int) -> True|False :
  key?(solved(s), v)

;Indicate that the equation is blocked on a set of
;variables.
defn blocked (s:SolverState, eqn:TypeEqn, vars:Collection<Int>) -> False :
  debugln("blocked on (%,): %_" % [vars, eqn])
  for v in vars do :
    update(blocked(s), cons{eqn, _}, v)

;Set the status of a variable.
defn set-var (s:SolverState, v:Int, value:SolverValue) -> False :
  ;Trace the message.
  debugln("set-var %_ = %_" % [v, value])
  
  ;Sanity check: Ensure that the given variable hasn't already been solved.
  if solved?(s,v) :
    fatal("Variable V%_ has already been solved." % [v])

  ;Set the variable as solved.
  solved(s)[v] = value

  ;Retrieve any equations that are blocked by the given variable.
  val blocked-eqns = blocked(s)[v]
  if remove(blocked(s),v) :

    ;Either put the blocked equations onto the queue, or
    ;mark their output variables as unprogressable.
    within indented() :
      match(value) :
        (value:Unsatisfiable|Unprogressable) :
          ;If value is unsatisfiable/unprogressable than all equations
          ;blocked on this variable is unprogressable.
          for e in blocked-eqns do :
            for v in e do-output-vars :
              set-var(s, v, Unprogressable()) when not solved?(s,v)
        (value) :
          ;Otherwise, all equations blocked on this variable gets
          ;pushed back onto the queue.
          for e in blocked-eqns do :
            push-eqn(s, e)

;Main loop.
defn solve-until-empty (solve:(TypeEqn, SolverState) -> False,
                        s:SolverState) -> False :
  while not empty?(s) :
    val e = next-eqn(s)
    debugln("solve-until-empty %_" % [e])
    within indented() :
      solve(e, s)

;============================================================
;================== Output Variables ========================
;============================================================

;Retrieve the output variables for the given equation.
defn do-output-vars (f:Int -> False, e:TypeEqn) -> False :
  match(e) :
    (e:CaptureEqn) :
      fatal("Not yet implemented")
    (e:InferEqn) :
      fatal("Not yet implemented")
    (e:OverloadExpEqn) :
      fatal("Not yet implemented")
    (e:OverloadCallEqn) :
      fatal("Not yet implemented")
    (e:SubEqn) :
      fatal("Not yet implemented")
    (e:SuperEqn) :
      fatal("Not yet implemented")

;============================================================
;==================== Fill Solved Type ======================
;============================================================

;Based upon the unalready solved variables, fill in the missing
;TUVars.
defn fill-solved (type:Type, s:SolverState) -> SolvedType :
  ;Status variables
  
  ;Turns to true if output is not the same as the
  ;input type.
  var changed?:True|False = false
  
  ;Turns to true if output contains at least one TUVar.
  var has-tuvar?:True|False = false

  ;Compute the filled type, and adjust the status
  ;variables appropriately.
  defn fill (t:Type) -> Type :
    match(t:TUVar) :
      match(get-filled-solved(n(t), s)) :
        (t:SolvedType) :
          ;Successfully filled the TUVar.
          changed? = true
          match(fill-status(t)) :
            (s:FilledCompletely) :
              value(t)
            (s:FilledWithSolved) :
              ;Still contains some remaining TUVar.
              has-tuvar? = true
              value(t)
        (f:False) :
          ;Couldn't fill the TUVar, so set the flag.
          has-tuvar? = true
          t
    else :
      map(fill{_ as Type}, t)

  ;Compute the new filled type.
  val new-type = let :
    val filled = fill(type)
    simplify(filled) when changed? else type

  ;Compute the new status.
  val new-status =
    if has-tuvar? : FilledWithSolved(num-solved(s))
    else : FilledCompletely()

  ;Return the bundled result.
  SolvedType(new-type, new-status)

;Retrieve the solved type for variable v.
;Or false if v is not solved.
defn get-filled-solved (v:Int, state:SolverState) -> SolvedType|False :
  match(get?(solved(state), v)) :
    (t:SolvedType) :
      ;Compute whether we need to continue recursively
      ;filling the returned type.
      val done? = match(fill-status(t)) :
        (s:FilledCompletely) : true
        (s:Unfilled) : false
        (s:FilledWithSolved) : num-solved(s) == num-solved(state)
        
      ;Either continue or return.
      if done? :
        t
      else :
        val new-t = fill-solved(value(t),state)
        solved(s)[v] = new-t
        new-t
    (f) :
      false

;============================================================
;===================== Fill Solved ==========================
;============================================================

;Fill the solved variables in the given equation.
;defn fill-solved (solved?:Int -> Type|False, eqn:TypeEqn) -> TypeEqn :
;
;  ;Fill the given type with any solved variables.
;  defn fill (t:Type) -> Type :
;    var filled?:True|False = false
;    val filled = let loop (t:Type = t) :
;      match(t:TUVar) :
;        match(solved?(n(t))) :
;          (new-t:Type) :
;            filled? = true
;            new-t
;          (f:False) :
;            t
;      else :
;        map(loop,t)
;    simplify(filled) when filled? else t
;
;  match(eqn) :
;    (e:CaptureEqn) :
;    (e:InferEqn) :
;    (e:OverloadExpEqn) :
;    (e:OverloadCallEqn) :
;    (e:SubEqn) :
;    (e:SuperEqn) :
;    (e:EqualEqn) :

;============================================================
;====================== Solve ===============================
;============================================================

defn solve-eqn (e:TypeEqn, s:SolverState) -> False :
  fatal("Not yet implemnened")

;============================================================
;====================== Debugging ===========================
;============================================================

var DEBUG-TRACE:True|False = true

defn debugln (msg) :
  println(msg)