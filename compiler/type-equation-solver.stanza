defpackage stz/type-equation-solver :
  import core
  import collections
  import stz/types
  import stz/type-locs
  import stz/type-solver
  import stz/type-variance
  import stz/type-equations
  import stz/type-hierarchy
  import stz/type-formatter

;============================================================
;====================== SolverState =========================
;============================================================

;Complete state of the solver in-between iterations.
;- eqns: Tuple of all equations.
;- sel-eqns: Fast access to selection equations.
;- solved: Each entry, V => VAL, means that the variable V
;  has been solved and has value VAL.
;- blocked: Each entry, V => (E1, E2, E3 ...), means that the
;  equations E1, E2, E3 cannot make progress, and that V is
;  one of the variables that could be holding it up. An equation
;  E is allowed to appear under multiple V, and even under the same
;  V multiple times.
;- eqns: The list of active equations to solve until queue
;  is empty.
;- num-solved: The number of variables in 'solved' that holds
;  a SolvedType.
public defstruct SolverState :
  hierarchy: TypeHierarchy
  eqns: Tuple<TypeEqn>
  sel-eqns: IntTable<TypeEqn>
  solved: IntTable<SolverValue> with:
    init => IntTable<SolverValue>()
  guesses: IntTable<Tuple<True|False>> with:
    init => IntTable<Tuple<True|False>>()
  blocked: IntTable<List<TypeEqn>> with:
    init => IntTable<List<TypeEqn>>(List())
  active-eqns: Queue<TypeEqn> with:
    init => Queue<TypeEqn>()
  num-solved:Int with:
    init => 0
    setter => set-num-solved

;============================================================
;====================== Checkpoint ==========================
;============================================================

;The solver needs to backtrack to a safe point before it
;can try out a different set of guesses for the overloaded
;equations. 

defstruct Checkpoint :
  solved:Tuple<KeyValue<Int,SolverValue>>
  eqns:Tuple<TypeEqn>
  num-solved:Int

;Save the current state of the solver state in a checkpoint.
defn save-checkpoint (state:SolverState) -> Checkpoint :
  Checkpoint(
    to-tuple(solved(state))
    to-tuple(cat(active-eqns(state),
                 blocked-eqns(state)))
    num-solved(state))

;Restore the solver to the given state.
defn restore-checkpoint (state:SolverState, cp:Checkpoint) :
  clear(solved(state))
  clear(blocked(state))
  clear(active-eqns(state))
  for entry in solved(cp) do :
    solved(state)[key(entry)] = value(entry)
  for e in eqns(cp) do :
    push-eqn(state,e)
  set-num-solved(state, num-solved(cp))

;============================================================
;===================== Solver Values ========================
;============================================================

;The possible values that a solver variable can take on.
public deftype SolverValue

;Fill status: Indicates the properties of a solved type.
deftype FillStatus

;The type contains no TUVar anymore.
defstruct FilledCompletely <: FillStatus
with:
  printer => true

;The type contains no TUVar to an already-solved
;variable, at the time when 'num-solved' variables
;were solved.
defstruct FilledWithSolved <: FillStatus :
  num-solved:Int
with:
  printer => true

;The type may contain TUVar to an already-solved
;variable.
defstruct Unfilled <: FillStatus
with:
  printer => true

;The variable was solved.
public defstruct SolvedType <: SolverValue :
  value:Type
  variance:Variance
  fill-status:FillStatus
with:
  printer => true

;The selection was solved.
public defstruct SolvedSel <: SolverValue :
  values:Tuple<True|False>
with:
  printer => true

;The variable cannot be solved because the constraints are
;unsatisfiable.
public defstruct Unsatisfiable <: SolverValue
with:
  printer => true

;The variable cannot be solved because it depends upon a
;variable that is either unsatisfiable or unprogressable.
public defstruct Unprogressable <: SolverValue
with:
  printer => true

;============================================================
;======================== Guesses ===========================
;============================================================

;Represents a guessed selection value.
;- eqn: The equation with the selection variable that is being
;  guessed.
defstruct Guess :
  values:Maybe<Tuple<True|False>>
  eqn:TypeEqn

;============================================================
;======================= Formatting =========================
;============================================================

public defn format (f:TypeFormatter, v:SolverValue) :
  match(v) :
    (v:SolvedType) : "SolvedType(%_, %_)" % [format(f,value(v)), fill-status(v)]
    (v) : v

;============================================================
;===================== Public API ===========================
;============================================================

;Create a new SolverState primed with the given equations.
public defn SolverState (input-eqns:Seqable<TypeEqn>,
                         hier:TypeHierarchy) -> SolverState :
  val eqns = to-tuple(input-eqns)
  val sel-eqns = to-inttable<TypeEqn> $
    for e in eqns seq? :
      match(e) :
        (e:OverloadExpEqn) : One(sel(e) => e)
        (e:OverloadCallEqn) : One(sel(e) => e)
        (e) : None()
  SolverState(hier, eqns, sel-eqns)

;Solve as many equations as possible.
public defn solve (s:SolverState) -> False :
  solve-until-empty(solve-eqn, s)

;Return the solution for the given variable.
public defn get (s:SolverState, v:Int) -> SolverValue :
  fatal("Not yet implemented")

;Return all the solutions.
public defn solutions (s:SolverState) -> Tuple<KeyValue<Int,SolverValue>> :
  to-tuple(solved(s))

;============================================================
;======================== Solve =============================
;============================================================

;Return true if there are no more equations to solve.
defn empty? (s:SolverState) -> True|False :
  empty?(active-eqns(s))

;Return the next equation to solve.
defn next-eqn (s:SolverState) -> TypeEqn :
  pop(active-eqns(s))

;Returns all the blocked equations in the solver.
defn blocked-eqns (s:SolverState) -> Seqable<TypeEqn> :
  cat-all(values(blocked(s)))

;Push another equation to the solver.
defn push-eqn (s:SolverState, e:TypeEqn) -> False :
  add(active-eqns(s), e)

;Return true if the given variable has already been solved.
defn solved? (s:SolverState, v:Int) -> True|False :
  key?(solved(s), v)

;Return true if all output variables in the given equation are solved.
defn solved? (s:SolverState, e:TypeEqn) -> True|False :
  var solved:True|False = true
  for v in e do-output-vars :
    (solved = false) when not solved?(s,v)
  solved

;Indicate that the equation is blocked on a set of
;variables.
defn blocked (s:SolverState, eqn:TypeEqn, vars:Collection<Int>) -> False :
  debugln("blocked on (%,): %_" % [debugfmt(vars), debugfmt(eqn)])
  for v in to-intset(vars) do :
    update(blocked(s), cons{eqn, _}, v)

;Set the status of a variable.
defn set-var (s:SolverState, v:Int, given-value:SolverValue) -> False :
  ;Trace the message.
  debugln("set-var %_ = %_" % [debugfmt(v), debugfmt(given-value)])

  ;Sanity check: Ensure that the given variable hasn't already been solved.
  if solved?(s,v) :
    fatal("Variable V%_ has already been solved." % [v])

  ;First preprocess the given value by removing cycles.
  val value =
    match(given-value:SolvedType)  :
      match(remove-cycle(v, variance(given-value), value(given-value))) :
        (new-t:Type) : SolvedType(new-t, variance(given-value), fill-status(given-value))
        (f:False) : Unsatisfiable()
    else :
      given-value

  ;Set the variable as solved.
  solved(s)[v] = value

  ;Increment the number of solved
  if value is SolvedType :
    set-num-solved(s, num-solved(s) + 1)

  ;Retrieve any equations that are blocked by the given variable.
  val blocked-eqns = blocked(s)[v]
  if remove(blocked(s),v) :

    ;Either put the blocked equations onto the queue, or
    ;mark their output variables as unprogressable.
    within debug-indent() :
      match(value) :
        (value:Unsatisfiable|Unprogressable) :
          ;If value is unsatisfiable/unprogressable than all equations
          ;blocked on this variable is unprogressable.
          for e in blocked-eqns do :
            for v in e do-output-vars :
              set-var(s, v, Unprogressable()) when not solved?(s,v)
        (value) :
          ;Otherwise, all equations blocked on this variable gets
          ;pushed back onto the queue.
          for e in blocked-eqns do :
            push-eqn(s, e)

;Fill the solved variables in the given equation.
defn fill-solved (e:TypeEqn, s:SolverState) -> TypeEqn :
  fill-solved(fill-solved-type{_, s}, e)

;Main loop.
defn solve-until-empty (solve:(TypeEqn, SolverState) -> False,
                        s:SolverState) -> False :
  ;Preprocess the equations.
  preprocess-eqns(s)

  ;Store our current checkpoint.
  var checkpoint:False|Checkpoint = false

  ;Iteratively solve equations until the active
  ;queue is empty.
  defn* solve-all-equations-in-active-queue () :
    ;Solve all equations in active queue.
    while not empty?(s) :
      val e = next-eqn(s)
      if not solved?(s,e) :
        debugln("solve-until-empty %_" % [debugfmt(e)])
        within debug-indent() :
          val filled-e = fill-solved(e,s)
          debugln("filled: %_" % [debugfmt(filled-e)])
          solve-eqn(filled-e, s)
          
    ;After solving the equations, take guesses to make
    ;progress
    guess-selection-variables()

  ;For any blocked selection variables, take a guess
  ;at them.
  defn* guess-selection-variables () :
    ;Save the solver state if it hasn't been saved already.
    if checkpoint is False :
      checkpoint = save-checkpoint(s)
      
    ;Make the guesses
    val guessed? = make-guesses(s)

    ;If guesses were made, then continue solving
    ;the equations.
    if guessed? : solve-all-equations-in-active-queue()
    else : check-and-update-guesses()

  ;We finished solving as much as possible with the
  ;current set of guesses. Check and update them.
  defn* check-and-update-guesses () :
    val updated? = update-guesses(s)

    ;If guesses are all good, then we're done.
    ;Otherwise, backtrack to the checkpoint and
    ;try solving again.
    if updated? :
      debugln("restart solver from checkpoint.")
      restore-checkpoint(s, checkpoint as Checkpoint)
      solve-all-equations-in-active-queue()

  ;Mark any equations that are still blocked as unprogressable.
  defn* give-up-on-blocked-eqns () :
    for e in blocked-eqns(s) do :
      debugln("remaining eqn: %_" % [debugfmt(e)])
      for v in e do-output-vars :
        if not solved?(s,v) :
          set-var(s, v, Unprogressable())

  ;Backsubstitute all the solved variables.
  defn* backsubstitute-knowns () :
    val solved-vars = to-tuple(keys(solved(s)))
    for v in solved-vars do :
      val value = solved(s)[v]
      debugln("backsubstitution for %_ = %_ :" % [debugfmt(v), debugfmt(value)])
      within debug-indent() :
        get-filled-solved(v, s)

  ;Launch!
  solve-all-equations-in-active-queue()
  give-up-on-blocked-eqns()
  backsubstitute-knowns()

;============================================================
;================ Cycle Removal/Detection ===================
;============================================================

;Remove a cycle around uvar from the given type.
;Returns false if the cycle cannot be removed.
defn remove-cycle (uvar:Int, variance:Variance, t:Type) -> Type|False :
  switch(variance) :
    Covariant : remove-covariant-cycle(uvar, t)
    Contravariant : remove-contravariant-cycle(uvar, t)

;Perform the covariant case of cycle removal.
defn remove-covariant-cycle (uvar:Int, t:Type) -> Type|False :
  label<Type|False> return :
    val ts = Vector<Type>()
    let loop (t:Type = simplify(t)) :
      match(t) :
        (t:TOr) :
          loop(a(t))
          loop(b(t))
        (t:TUVar) :
          add(ts,t) when n(t) != uvar
        (t) :
          if occurs?(uvar,t) : return(false)
          else : add(ts, t)
    if empty?(ts) : TBot()
    else : reduce(TOr,ts)

;Perform the contravariant case of cycle removal.
defn remove-contravariant-cycle (uvar:Int, t:Type) -> Type|False :
  label<Type|False> return :
    val ts = Vector<Type>()
    let loop (t:Type = simplify(t)) :
      match(t) :
        (t:TAnd) :
          loop(a(t))
          loop(b(t))
        (t:TUVar) :
          add(ts,t) when n(t) != uvar
        (t) :
          if occurs?(uvar,t) : return(false)
          else : add(ts, t)
    if empty?(ts) : TGradual()
    else : reduce(TAnd,ts)

;Return true if the given type contains the given unification
;variable.
defn occurs? (uvar:Int, t:Type) -> True|False :
  match(t:TUVar) :
    n(t) == uvar
  else :
    any?(occurs?{uvar, _ as Type}, t)

;============================================================
;================== Output Variables ========================
;============================================================

;Retrieve the output variables for the given equation.
defn do-output-vars (f:Int -> False, e:TypeEqn) -> False :
  match(e) :
    (e:CaptureEqn) : f(n(e))
    (e:InferEqn) : f(n(e))
    (e:OverloadExpEqn) : f(n(e)) ;(f(n(e)), f(sel(e)))
    (e:OverloadCallEqn) : f(n(e)) ;(f(n(e)), f(sel(e)))
    (e:SubEqn) : f(n(e))
    (e:EqualEqn) : f(n(e))
    (e) : fatal("%_ is not part of main solver loop." % [object-type(e)])

;============================================================
;==================== Fill Solved Type ======================
;============================================================

;Based upon the unalready solved variables, fill in the missing
;TUVars.
defn fill-solved (type:Type, s:SolverState) -> [Type, FillStatus] :
  ;Status variables

  ;Turns to true if output is not the same as the
  ;input type.
  var changed?:True|False = false

  ;Turns to true if output contains at least one TUVar.
  var has-tuvar?:True|False = false

  ;Compute the filled type, and adjust the status
  ;variables appropriately.
  defn fill (t:Type) -> Type :
    match(t:TUVar) :
      match(get-filled-solved(n(t), s)) :
        (t:SolvedType) :
          ;Successfully filled the TUVar.
          changed? = true
          match(fill-status(t)) :
            (s:FilledCompletely) :
              value(t)
            (s:FilledWithSolved) :
              ;Still contains some remaining TUVar.
              has-tuvar? = true
              value(t)
        (f:Unsatisfiable|False) :
          ;Couldn't fill the TUVar, so set the flag.
          has-tuvar? = true
          t
    else :
      map(fill{_ as Type}, t)

  ;Compute the new filled type.
  val new-type = let :
    val filled = fill(type)
    simplify(filled) when changed? else type

  ;Compute the new status.
  val new-status =
    if has-tuvar? : FilledWithSolved(num-solved(s))
    else : FilledCompletely()

  ;Return the bundled result.
  [new-type, new-status]

;Retrieve the solved type for variable v.
;Or false if v is not solved.
defn get-filled-solved (v:Int, state:SolverState) -> SolverValue|False :
  match(get?(solved(state), v)) :
    (t:SolvedType) :
      ;Compute whether we need to continue recursively
      ;filling the returned type.
      val done? = match(fill-status(t)) :
        (s:FilledCompletely) : true
        (s:Unfilled) : false
        (s:FilledWithSolved) : num-solved(s) == num-solved(state)

      ;Either continue or return.
      if done? :
        t
      else :
        val [new-t, new-fill] = fill-solved(value(t),state)
        val processed-t = remove-cycle(v, variance(t), new-t)
        val new-value =
          match(processed-t:Type) : SolvedType(processed-t, variance(t), new-fill)
          else : Unsatisfiable()
        debugln("update variable: %_ = %_" % [debugfmt(v), debugfmt(new-value)])
        solved(state)[v] = new-value
        new-value
    (f) :
      false

;Extract the type of a fill result.
defn fill-solved-type (type:Type, s:SolverState) -> Type :
  val [new-type, fill-status] = fill-solved(type,s)
  new-type

;============================================================
;================= Fill Solved Equation =====================
;============================================================

;Fill the solved variables in the given equation.
defn fill-solved (f:Type -> Type, e:TypeEqn) -> TypeEqn :
  defn g (t:Type) : f(t)
  defn g (x:InferLoc) : x
  defn g (x:Tuple<TFunction>) : map({f(_) as TFunction},x)
  defn g (x:Tuple<TArrow>) : map({f(_) as TArrow},x)
  defn g (x:FArg) : map(f{_ as Type}, x)
  defn g (x:Tuple<FArg>) : map(g, x)
  defn g (e:KeyValue<Int,Type>) : key(e) => f(value(e))
  defn g (e:Tuple<KeyValue<Int,Type>>) : map(g,e)
  match(e) :
    (e:CaptureEqn) : CaptureEqn(n(e), variance(e), f(a(e)), b(e))
    (e:InferEqn) : InferEqn(n(e), g(a(e)), g(b(e)))
    (e:OverloadExpEqn) : OverloadExpEqn(n(e), sel(e), g(xs(e)), f(y(e)))
    (e:OverloadCallEqn) : OverloadCallEqn(n(e), sel(e), g(xs(e)), g(args(e)))
    (e:SubEqn) : SubEqn(n(e), g(x(e)), g(ys(e)))
    (e:EqualEqn) : EqualEqn(n(e), g(type(e)))
    (e) : fatal("%_ equation is not part of main solver loop." % [object-type(e)])

;============================================================
;=================== Preprocessing Stage ====================
;============================================================

;Preprocess the CaptureAllEqn and SuperEqn equations.
defn preprocess-eqns (s:SolverState) -> False :
  ;Gather all the super constraints.
  val super-table = IntTable<List<Type>>(List())

  ;Iterate through equations and preprocess each in turn.
  for e in eqns(s) do :
    match(e) :
      ;Convert CaptureAllEqn into individual CaptureEqn.
      (e:CaptureAllEqn) :
        val entries = capture-variance(ns(e), b(e))
        for entry in entries do :
          val n = key(entry)
          val variance = value(entry)
          push-eqn(s, CaptureEqn(n, variance, a(e), b(e)))
      ;Gather SuperEqn and output as equal eqn.
      (e:SuperEqn) :
        update(super-table, cons{x(e), _}, n(e))
      ;All other equations are unprocessed.
      (e) :
        push-eqn(s,e)

  ;Push the new super constraints.
  for entry in super-table do :
    val n = key(entry)
    val t = reduce(TOr, value(entry))
    push-eqn(s, EqualEqn(n,t))

;============================================================
;====================== Solve ===============================
;============================================================

defmulti solve-eqn (e:TypeEqn, s:SolverState) -> False

defmethod solve-eqn (e:CaptureEqn, s:SolverState) -> False :
  match(capture(n(e), variance(e), a(e), b(e), hierarchy(s))) :
    (b:Blocked) : blocked(s, e, tvars(b))
    (f:False) : set-var(s, n(e), Unsatisfiable())
    (t:Type) : set-var(s, n(e), SolvedType(t, variance(e), Unfilled()))

defmethod solve-eqn (e:EqualEqn, s:SolverState) -> False :
  set-var(s, n(e), SolvedType(type(e), Covariant, Unfilled()))

defmethod solve-eqn (e:InferEqn, s:SolverState) -> False :
  match(infer(a(e), b(e), hierarchy(s))) :
    (b:Blocked) : blocked(s, e, tvars(b))
    (f:False) : set-var(s, n(e), Unsatisfiable())
    (t:Type) :
      val variance = capture-variance(a(e),b(e))
      set-var(s, n(e), SolvedType(t, variance, Unfilled()))

defmethod solve-eqn (e:SubEqn, s:SolverState) -> False :
  match(remove-cycle(n(e), Covariant, x(e))) :
    (xtype:Type) :
      val ys-table = to-inttable<Type>(ys(e))
      val uvars = Vector<Int>()
      val new-x = let loop (t:Type = xtype) :
        match(t) :
          (t:TUVar) : (add(uvars,n(t)), t)
          (t:TVar) : get?(ys-table, n(t), t)
          (t) : map(loop{_ as Type}, t)
      if empty?(uvars) : set-var(s, n(e), SolvedType(new-x, Covariant, Unfilled()))
      else : blocked(s, e, uvars)
    (f:False) :
      set-var(s, n(e), Unsatisfiable())

defmethod solve-eqn (e:OverloadExpEqn, s:SolverState) -> False :
  ;If the selection was guessed, then use the guessed
  ;value.
  if key?(guesses(s), sel(e)) :
    val values = guesses(s)[sel(e)]
    val ts = to-tuple(filter({_1}, xs(e), values))
    val mixed = mix-functions(ts)
    set-var(s, n(e), SolvedType(mixed, Covariant, Unfilled()))

  ;Otherwise, compute the selection ourselves.
  else :
    ;Compute which of the overloads are good.
    val selections = for x in xs(e) map :
      select-overload(x, y(e), hierarchy(s))
    debugln("selections: %," % [seq(debugfmt,selections)])
    ;Determine how many are remaining.
    switch(count({_ is-not False}, selections)) :
      ;Case: none of the overloads are appropriate.
      0 :
        set-var(s, n(e), Unsatisfiable())
      ;Case: exactly one overload is appropriate.
      1 :
        val t = find!({_1 is-not False}, xs(e), selections)
        set-var(s, n(e), SolvedType(t, Covariant, Unfilled()))
      ;Case: more than one overload is appropriate.
      else :
        ;Case: Some selections are blocked.
        if any?({_ is Blocked}, selections) :
          val uvars = to-tuple(seq-cat(tvars, filter-by<Blocked>(selections)))
          blocked(s, e, uvars)
        ;Case: No selections are blocked.
        else :
          val ts = to-tuple(filter({_1 is True}, xs(e), selections))
          val mixed = mix-functions(ts)
          set-var(s, n(e), SolvedType(mixed, Covariant, Unfilled()))

;============================================================
;======================== Guess =============================
;============================================================

;Make guesses for overload equations.
;These are intentionally conservative and need to be updated
;after iterative process is over.
defn make-guesses (s:SolverState) -> True|False :
  ;Retrieve all the blocked overload equations.
  val overload-eqns = to-tuple $
    filter-by<OverloadExpEqn>(blocked-eqns(s))

  ;Track whether any guesses were made.
  var guesses-made:True|False = false

  for e in overload-eqns do :
    if not solved?(s,e) :
      ;Compute the selection.
      val sel = for x in xs(e) map :
        select-overload(x, y(e), hierarchy(s))
      ;If there are any 'true' selections, then we
      ;can generate a guess.
      if any?({_ is True}, sel) :
        ;Indicate that we are generating a guess for this equation.
        debugln("guess: %_" % [debugfmt(e)])
        ;Generate and store the guess.
        val guess = map({_ is True}, sel)
        guesses(s)[/sel(e)] = guess
        guesses-made = true
        ;Indicate the guess.
        debugln("value: %_" % [guess])
        ;Solve the resulting equation using the generated selection.
        solve-eqn(e, s)

  ;Return true if any guesses were made.
  guesses-made

;Check and update the previously made guesses.
defn update-guesses (s:SolverState) -> True|False :
  ;Track whether any guesses were updated.
  var guesses-updated:True|False = false

  for guess in to-tuple(guesses(s)) do :
    val eqn = fill-solved(sel-eqns(s)[key(guess)], s)
    match(eqn) :
      (eqn:OverloadExpEqn) :
        ;Compute the new selection.
        val sel = for x in xs(eqn) map :
          select-overload(x, y(eqn), hierarchy(s))
        ;Merge with the previous guess.
        val new-values = to-tuple $
          for (new-v in sel, old-v in value(guess)) seq :
            old-v or (new-v is True)
        ;If the new values are different, then update the guess.
        if new-values != value(guess) :
          debugln("update-guess: %_" % [debugfmt(eqn)])
          within debug-indent() :
            debugln("old-guess: %_" % [value(guess)])
            debugln("new-guess: %_" % [new-values])
          guesses(s)[key(guess)] = new-values
          guesses-updated = true

  ;Returns true if any guesses were updated.
  guesses-updated

;============================================================
;====================== Debugging ===========================
;============================================================

var DEBUG-TRACE:True|False = true
var DEBUG-FORMATTER:TypeFormatter|False = false

public defn set-debug-formatter (f:TypeFormatter) -> False :
  DEBUG-FORMATTER = f

defn debug-indent<?T> (body:() -> ?T) -> T :
  if DEBUG-TRACE :
    indented(body)
  else :
    body()

defn debugfmt (x:TypeEqn) :
  match(DEBUG-FORMATTER:TypeFormatter) : format(DEBUG-FORMATTER,x)
  else : x

defn debugfmt (x:Int) :
  match(DEBUG-FORMATTER:TypeFormatter) : format(DEBUG-FORMATTER,TVar(x,false))
  else : x

defn debugfmt (xs:Collection<Int>) :
  seq(debugfmt, xs)

defn debugfmt (x:Type) :
  match(DEBUG-FORMATTER:TypeFormatter) : format(DEBUG-FORMATTER,x)
  else : x

defn debugfmt (v:SolverValue) :
  match(DEBUG-FORMATTER:TypeFormatter) : format(DEBUG-FORMATTER,v)
  else : x

defn debugfmt (v:PredResult) :
  match(DEBUG-FORMATTER:TypeFormatter) :
    match(v) :
      (v:True|False) : v
      (v:Blocked) : format(DEBUG-FORMATTER,v)
  else :
    v

defn debugln (msg) :
  println(msg)
