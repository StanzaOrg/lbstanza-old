defpackage stz/type-equation-solver :
  import core
  import collections
  import stz/types
  import stz/type-solver
  import stz/type-equations

;============================================================
;====================== SolverState =========================
;============================================================

;Complete state of the solver in-between iterations.
public defstruct SolverState :
  solved: IntTable<SolverValue> with:
    init => IntTable<SolverValue>()
  blocked: IntTable<List<TypeEqn>> with:
    IntTable<List<TypeEqn>>(List())
  eqns: Queue<TypeEqn> with:
    Queue<TypeEqn>()

;============================================================
;===================== Solver Values ========================
;============================================================

;The possible values that a solver variable can take on.
public deftype SolverValue :
  ;Types are the solutions to most equations.
  Type <: SolverValue

;The variable cannot be solved because the constraints are
;unsatisfiable.
public defstruct Unsatisfiable <: SolverValue

;The variable cannot be solved because it depends upon a
;variable that is either unsatisfiable or unprogressable.
public defstruct Unprogressable <: SolverValue

;============================================================
;========================= API ==============================
;============================================================

;Create a new SolverState primed with the given equations.
public defn SolverState (eqns:Seqable<TypeEqn>) -> SolverState :
  val state = SolverState()
  do(push-eqn{s, _}, eqns)
  state

;Solve as many equations as possible.
public defn solve (s:SolverState) -> False :
  fatal("Not yet implemented")

;Return the solution for the given variable.
public defn get (s:SolverState, v:Int) -> SolverValue :
  fatal("Not yet implemented")

;============================================================
;======================== Solve =============================
;============================================================

;Return true if there are no more equations to solve.
defn empty? (s:SolverState) -> True|False :
  empty?(eqns(s))

;Return the next equation to solve.
defn next-eqn (s:SolverState) -> TypeEqn :
  pop(eqns(s))

;Push another equation to the solver.
defn push-eqn (s:SolverState, e:TypeEqn) -> False :
  add(eqns(s), e)

;Return true if the given variable has already been solved.
defn solved? (s:SolverState, v:Int) -> True|False :
  key?(solved(s), v)

;Indicate that the equation is blocked on a set of
;variables.
defn blocked (s:SolverState, eqn:TypeEqn, vars:Seqable<Int>) -> False :
  for v in vars do :
    update(blocked(s), cons{eqn, _}, v)

;Set the status of a variable.
defn set-var (s:SolverState, v:Int, value:SolverValue) -> False :
  ;Sanity check: Ensure that the given variable hasn't already been solved.
  if solved?(s,v) :
    fatal("Variable V%_ has already been solved." % [v])

  ;Set the variable as solved.
  solved(s)[v] = value

  ;Retrieve any equations that are blocked by the given variable.
  val blocked = blocked(s)[v]
  if remove(blocked(s),v) :

    ;Either put the blocked equations onto the queue, or
    ;mark their output variables as unprogressable.
    match(value) :
      (value:Unsatisfiable|Unprogressable) :
        ;If value is unsatisfiable/unprogressable than all equations
        ;blocked on this variable is unprogressable.
        for e in blocked do :
          for v in e do-output-vars :
            set-var(s, v, Unprogressable()) when not solved?(s,v)
      (value) :
        ;Otherwise, all equations blocked on this variable gets
        ;pushed back onto the queue.
        for e in blocked do :
          push-eqn(s, e)

;Main loop.
defn solve-until-empty (solve:TypeEqn -> False, s:SolverState) -> False :
  while not empty?(s) :
    solve(next-eqn(s), s)

;============================================================
;================== Output Variables ========================
;============================================================

;Retrieve the output variables for the given equation.
defn do-output-vars (f:Int -> False, e:TypeEqn) -> False :
  match(e) :
    (e:CaptureEqn) :
      fatal("Not yet implemented")
    (e:InferEqn) :
      fatal("Not yet implemented")
    (e:OverloadExpEqn) :
      fatal("Not yet implemented")
    (e:OverloadCallEqn) :
      fatal("Not yet implemented")
    (e:SubEqn) :
      fatal("Not yet implemented")
    (e:SuperEqn) :
      fatal("Not yet implemented")

;============================================================
;============================================================
;============================================================