defpackage stz/bb-ir :
   import core
   import verse
   import stz/tgt-ir with :
      prefix => tgt-

;                        Operation Definition
;                        ====================
   
public definterface BBOp 
public defstruct ComOp <: BBOp : (op:tgt-TgtOp)
public defstruct NComOp <: BBOp : (op:tgt-TgtOp)
public defstruct DivOp <: BBOp : (op:tgt-TgtOp)
public defstruct ShfOp <: BBOp : (op:tgt-TgtOp)
public defstruct CmpOp <: BBOp : (op:tgt-TgtOp)
public defstruct DivModOp <: BBOp
public defstruct LoadOp <: BBOp : (offset: Int)
public defstruct StoreOp <: BBOp : (offset: Int)
public defstruct AddrOp <: BBOp : (y:Imm, offset: Int)
public defstruct ConvOp <: BBOp : (signed?:True|False)
public defstruct NOp <: BBOp 


;                        Location Definition
;                        ===================

public definterface Loc
public defstruct NoLoc <: Loc
public defstruct Reg <: Loc :
   n: Int
public defstruct FReg <: Loc :
   n: Int
public defstruct Stack <: Loc :
   n: Int   

;                        Immediates Definition
;                        =====================

public definterface Imm

public defstruct Var <: Imm :
   n: Int
   loc: Loc

public defstruct Val <: Imm :
   value

public defn Var (n:Int) :
   Var(n, NoLoc())


;                         Instruction Definition
;                         ======================

public definterface Ins
public defstruct Set <: Ins :
   x: Var
   y: Imm
   
public defstruct Args <: Ins :
   xs: List<Var>
   
public defstruct Call <: Ins :
   arity: Int
   xs: List<Var>
   f: Imm
   ys: List<Imm>
   tail?: True|False

public defstruct CallC <: Ins :
   xs: List<Var>
   f: Imm
   ys: List<Imm>

public defstruct Return <: Ins :
   xs: List<Imm>
   
public defstruct Op <: Ins :
   op: BBOp
   xs: List<Var>
   ys: List<Imm>

public defstruct Branch <: Ins :
   op: BBOp
   xs: List<Imm>


;                          Block Definition
;                          ================

public definterface Block
public defmulti n (b:Block) -> Int
public defmulti ins (b:Block) -> Vector<Ins>
public defmulti next (b:Block) -> List<Int>

public defstruct EBlock <: Block :
   n: Int with: (as-method => true)
   ins: Vector<Ins> with: (as-method => true)
   next: List<Int> with: (as-method => true)
with :
   constructor => Block


;                          Allocation Unit
;                          ===============

public defstruct Unit :
   defs: Vector<tgt-DefVar>
   blocks: Vector<Block>


;                        Printing Definition
;                        ===================

defn cms (xs) : join(xs, ", ")

defmethod print (o:OutputStream, u:Unit) :
   val io = IndentedStream(o, 3)
   print(o, "unit : ")
   for d in defs(u) do :
      print(io, "\ndef ~" << [d])
   for b in blocks(u) do :
      print(io, "\n~" << [b])

defmethod print (o:OutputStream, b:EBlock) :
   val io = IndentedStream(o, 3)
   print(o, "block ~ :" << [n(b)])
   for i in ins(b) do :
      print(io, "\n~" << [i])
   print(io, "\nnext ~@" << [cms(next(b))])   

defmethod print (o:OutputStream, i:Ins) :
   print{o, _} $ match(i) :
      (i:Set) : "~ = ~" << [x(i), y(i)]
      (i:Args) : "(~@) = Args" << [cms(xs(i))]
      (i:Call) : "(~@) = ~(~@)" << [cms(xs(i)), f(i), cms(ys(i))]
      (i:CallC) : "(~@) = ~(~@)" << [cms(xs(i)), f(i), cms(ys(i))]
      (i:Return) : "return (~@)" << [cms(xs(i))]
      (i:Op) : "(~@) = ~(~@)" << [cms(xs(i)), op(i), cms(ys(i))]
      (i:Branch) : "branch when ~(~@)" << [op(i), cms(xs(i))]

defmethod print (o:OutputStream, v:Var) :
   print{o, _} $ match(loc(v)) :
      (l:NoLoc) : n(v)
      (l) : "~:~" << [n(v), l]

defmethod print (o:OutputStream, v:Val) :
   print(o, "val(~)" << [value(v)])

defmethod print (o:OutputStream, l:Loc) :
   print{o, _} $ match(l) :
      (l:NoLoc) : "none"
      (l:Reg) : "Reg(~)" << [n(l)]
      (l:FReg) : "FReg(~)" << [n(l)]
      (l:Stack) : "Stack(~)" << [n(l)]

defmethod print (o:OutputStream, op:BBOp) :
   print{o, _} $ match(op) :
      (op:ComOp) : "com"
      (op:NComOp) : "ncom"
      (op:DivOp) : "div"
      (op:ShfOp) : "shf"
      (op:CmpOp) : "cmp"
      (op:DivModOp) : "divmod"
      (op:LoadOp) : "load"
      (op:StoreOp) : "store"
      (op:AddrOp) : "addr"
      (op:ConvOp) : "conv"
      (op:NOp) : "nop"