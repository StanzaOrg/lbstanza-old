defpackage stz/bb-ir :
   import core
   import verse
   import stz/tgt-ir with :
      prefix => tgt-

;                         Operation Definition
;                         ====================
   
definterface BBOp 
definterface Com2Op <: BBOp

;                         Location Definition
;                         ===================

definterface Loc
defstruct NoLoc <: Loc
defstruct Reg <: Loc :
   n: Int
defstruct Stack <: Loc :
   n: False|Int

defn Stack () :
   Stack(false)

;                          Variable Definition
;                          ===================

;Variable Definition
defstruct Var :
   name: Symbol
   loc: Loc

defn Var (name:Symbol) :
   Var(name, NoLoc())


;                         Instruction Definition
;                         ======================

definterface Ins
defstruct Set <: Ins :
   x: Var
   y: Var
   
defstruct Args <: Ins :
   xs: List<Var>
   
defstruct Call <: Ins :
   xs: List<Var>
   f: False|Var
   ys: List<Var>

defstruct Return <: Ins :
   xs: List<Var>
   
defstruct Op <: Ins :
   op: BBOp
   xs: List<Var>
   ys: List<Var>

defstruct Branch <: Ins :
   conseq: Symbol
   alt: Symbol
   op: BBOp
   xs: List<Var>


;                           Block Definition
;                           ================

definterface Block
defmulti name (b:Block) -> Symbol
defmulti ins (b:Block) -> Vector<Ins>
defmulti next (b:Block) -> List<Symbol>

defstruct EBlock <: Block :
   name: Symbol with: (as-method => true)
   ins: Vector<Ins> with: (as-method => true)
   next: List<Symbol> with: (as-method => true)
with :
   constructor => Block


;                          Allocation Unit
;                          ===============

defstruct Unit :
   defs: List<tgt-DefVar>
   blocks: Vector<Block>


;                      Printing Definition
;                      ===================

defmethod print (o:OutputStream, u:Unit) :
   val io = IndentedStream(o, 3)
   print(o, "unit : ")
   for d in defs(u) do :
      print(io, "\ndef ~" << [d])
   for b in blocks(u) do :
      print(io, "\n~" << [b])

defmethod print (o:OutputStream, b:EBlock) :
   val io = IndentedStream(o, 3)
   print(o, "block ~ :" << [name(b)])
   for i in ins(b) do :
      print(io, "\n~" << [i])
   print(io, "\nnext = ~@" << [cms(next(b))])   

defmethod print (o:OutputStream, i:Ins) :
   match(i) :
      (i:)

defmethod print (o:OutputStream, v:Var) :
   print{o, _} $ match(loc(v)) :
      (l:NoLoc) : name(v)
      (l) : "~:~" << [name(v), l]

defmethod print (o:OutputStream, l:Loc) :
   print{o, _} $ match(l) :
      (l:NoLoc) : "none"
      (l:Reg) : "Reg(~)" << [n(l)]
      (l:Stack) :
         match(n(l)) :
            (n:Int) : "Stack(~)" << [n]
            (n:False) : "Stack"

defmethod print (o:OutputStream, op:BBOp) :
   print{o, _} $ match(op) :
      (op:Com2Op) : "com2"