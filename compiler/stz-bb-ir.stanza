defpackage stz/bb-ir :
   import core
   import collections
   import stz/tgt-ir with :
      prefix => tgt-

;                        Location Definition
;                        ===================

public deftype Loc
public defstruct NoLoc <: Loc
public defstruct Reg <: Loc :
   n: Int
public defstruct FReg <: Loc :
   n: Int
public defstruct Stack <: Loc :
   n: Int   

;                        Immediates Definition
;                        =====================

public deftype Imm

public defstruct Var <: Imm & Equalable :
   n: Int
   loc: Loc

public defstruct Val <: Imm :
   value

public defn Var (n:Int) :
   Var(n, NoLoc())

defmethod equal? (a:Var, b:Var) :
   n(a) == n(b)


;                         Instruction Definition
;                         ======================

public deftype Ins
public defmulti killed (i:Ins) -> List<Int>

public defstruct Set <: Ins :
   x: Var
   y: Imm
   killed: List<Int> with: (as-method => true)

public defstruct Args <: Ins :
   xs: List<Var>
   ctxt: FnContext
   killed: List<Int> with: (as-method => true)

public defstruct Return <: Ins :
   xs: List<Imm>
   ctxt: FnContext
   killed: List<Int> with: (as-method => true)
   
public defstruct Call <: Ins :
   xs: List<Var>
   f: Imm
   ys: List<Imm>
   type: CallType
   killed: List<Int> with: (as-method => true)
   
public defstruct Op <: Ins :
   op: tgt-TgtOp
   xs: List<Var>
   ys: List<Imm>   
   killed: List<Int> with: (as-method => true)

public defstruct Branch <: Ins :
   op: tgt-TgtOp
   xs: List<Imm>
   killed: List<Int> with: (as-method => true)

public defn Set (x:Var, y:Imm) : Set(x, y, List())
public defn Args (xs:List<Var>, ctxt:FnContext) : Args(xs, ctxt, List())
public defn Return (xs:List<Imm>, ctxt:FnContext) : Return(xs, ctxt, List())
public defn Call (xs:List<Var>, f:Imm, ys:List<Imm>, type:CallType) : Call(xs, f, ys, type, List())
public defn Op (op:tgt-TgtOp, xs:List<Var>, ys:List<Imm>) : Op(op, xs, ys, List())
public defn Branch (op:tgt-TgtOp, xs:List<Imm>) : Branch(op, xs, List())

public deftype FnContext
public defstruct StanzaContext <: FnContext
public defstruct CContext <: FnContext

public deftype CallType
public defstruct StanzaCall <: CallType :
   arity: Int
   tail?: True|False
   new-stack?: True|False
   info: False|FileInfo
public defstruct StackCall <: CallType :
   tail?: True|False
   info: False|FileInfo
public defstruct CCall <: CallType :
   num-on-stack: Int



;                          Block Definition
;                          ================

public deftype Block
public defmulti n (b:Block) -> Int
public defmulti ins (b:Block) -> Vector<Ins>
public defmulti next (b:Block) -> List<Int>

public defstruct EBlock <: Block :
   n: Int with: (as-method => true)
   ins: Vector<Ins> with: (as-method => true)
   next: List<Int> with: (as-method => true)
with :
   constructor => Block


;                          Allocation Unit
;                          ===============

public defstruct Unit :
   defs: Vector<tgt-DefVar>
   blocks: Vector<Block>

;                          Mappers and Doers
;                          =================

public defn map (g:Imm -> Imm, i:Ins) :
   defn gs (xs:List<Imm>) : map(g, xs)
   defn gv (v:Var) : g(v) as Var
   defn gvs (vs:List<Var>) : map(gv, vs)
   match(i) :
      (i:Set) : Set(gv(x(i)), g(y(i)))
      (i:Args) : Args(gvs(xs(i)), ctxt(i))
      (i:Return) : Return(gs(xs(i)), ctxt(i))
      (i:Call) : Call(gvs(xs(i)), g(f(i)), gs(ys(i)), type(i))
      (i:Op) : Op(op(i), gvs(xs(i)), gs(ys(i)))
      (i:Branch) : Branch(op(i), gs(xs(i)))


;                        Printing Definition
;                        ===================

defn cms (xs) : join(xs, ", ")

defmethod print (o:OutputStream, u:Unit) :
   val io = IndentedStream(o, 3)
   print(o, "unit : ")
   for d in defs(u) do :
      print(io, "\ndef %~" % [d])
   for b in blocks(u) do :
      print(io, "\n%~" % [b])

defmethod print (o:OutputStream, b:EBlock) :
   val io = IndentedStream(o, 3)
   print(o, "block %~ :" % [n(b)])
   for i in ins(b) do :
      print(io, "\n%~" % [i])
   print(io, "\nnext %*" % [cms(next(b))])   

defmethod print (o:OutputStream, i:Ins) :
   val ks = if empty?(killed(i)) : ""
            else : " killed: %," % [killed(i)]
   print{o, _} $ match(i) :
      (i:Set) : "%~ = %~%_" % [x(i), y(i), ks]
      (i:Args) : "(%*) = Args%_" % [cms(xs(i)), ks]
      (i:Call) : "(%*) = %~(%*) %~%_" % [cms(xs(i)), f(i), cms(ys(i)), type(i), ks]
      (i:Return) : "return (%*)%_" % [cms(xs(i)), ks]
      (i:Op) : "(%*) = %~(%*)%_" % [cms(xs(i)), op(i), cms(ys(i)), ks]
      (i:Branch) : "branch when %~(%*)%_" % [op(i), cms(xs(i)), ks]

defmethod print (o:OutputStream, v:Var) :
   print{o, _} $ match(loc(v)) :
      (l:NoLoc) : n(v)
      (l) : "%~:%~" % [n(v), l]

defmethod print (o:OutputStream, v:Val) :
   print(o, "val(%~)" % [value(v)])

defmethod print (o:OutputStream, l:Loc) :
   print{o, _} $ match(l) :
      (l:NoLoc) : "none"
      (l:Reg) : "Reg(%~)" % [n(l)]
      (l:FReg) : "FReg(%~)" % [n(l)]
      (l:Stack) : "Stack(%~)" % [n(l)]

defmethod print (o:OutputStream, c:CallType) :
   print{o, _} $ match(c) :
      (c:StanzaCall) : "stanza(%~, %~, %~)" % [arity(c), tail?(c), new-stack?(c)]
      (c:StackCall) : "stack(%~)" % [tail?(c)]
      (c:CCall) : "c(%~)" % [num-on-stack(c)]