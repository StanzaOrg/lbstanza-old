defpackage stz/reg-alloc-engine :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-block
  import stz/reg-alloc-model-check
  import stz/reg-alloc-program-check
  import stz/reg-alloc-model-properties
  import stz/reg-alloc-datastructures
  import stz/reg-alloc-model-env
  import stz/reg-alloc-model-analysis
  import stz/reg-alloc-basic-blocks
  import stz/reg-alloc-liveness
  import stz/reg-alloc-port-prefs
  import stz/reg-alloc-block-stmt-processor
  import stz/reg-alloc-block-arranger

;<doc>=======================================================
;====================== Algorithm ===========================
;============================================================

For each program:
  Check that the program is wellformed. (Optional)
  Analyze the basic blocks
  Compute live variables
  Annotate port preferences
  Then for each block:
    Compute 

;============================================================
;=======================================================<doc>

;============================================================
;=================== State Definition =======================
;============================================================

;Holds the complete state of the register allocation engine.
public defstruct RegAllocEngine <: ModelEnv :
  num-regs:Int
  num-fregs:Int
  vardefs:Vector<VarDef> with:
    init => Vector<VarDef>()
  instructions:Vector<ProgramStmt> with:
    init => Vector<ProgramStmt>()
  blocks:Vector<Block> with:
    init => Vector<Block>()
  models:Vector<OperationModel> with:
    init => Vector<OperationModel>()
  model-properties:Vector<ModelProperties> with:
    init => Vector<ModelProperties>()  
  model-checker:ModelChecker
  datastructures:RegAllocDatastructures with :
    setter => set-datastructures
with:
  constructor => #RegAllocEngine

;Holds the datastructures that are specific to the number of
;variables.
public defstruct RegAllocDatastructures :
  num-vars:Int
  program-checker:ProgramChecker

;============================================================
;==================== Constructor ===========================
;============================================================

;Create a new Register Allocator engine.
public defn RegAllocEngine (num-regs:Int,
                            num-fregs:Int) -> RegAllocEngine :
  ;Create the datastructures that do not depend on number
  ;of program variables.
  val resources = ResourceProvider(num-regs, num-fregs, 0)
  val model-checker = ModelChecker(resources, num-regs, num-fregs)

  ;Create the variable-specific datastructures with an
  ;initial number of variables.
  val num-vars = 256
  val var-resources = ResourceProvider(num-regs, num-fregs, num-vars)
  val reg-datastructures = RegAllocDatastructures(
                             num-vars,
                             ProgramChecker(var-resources))

  ;Create the engine.
  #RegAllocEngine(num-regs,
                  num-fregs,
                  model-checker
                  reg-datastructures)

;============================================================
;============= RegAllocEngine as ModelEnv ===================
;============================================================

defmethod num-models (e:RegAllocEngine) :
  length(models(e))

defmethod model (e:RegAllocEngine, id:Int) :
  models(e)[id]

defmethod model-properties (e:RegAllocEngine, id:Int) :
  model-properties(e)[id]

;============================================================
;========== RegAllocEngine as BlockStmtProcessor ============
;============================================================

;The block stmt processor for the RegAllocEngine.
deftype EngineStmtProcessor <: BlockStmtProcessor

;Indicate that we have finished processing the block and the
;results should be stored in the engine.
defmulti save-results (proc:EngineStmtProcessor) -> False

defn stmt-processor (r:RegAllocEngine, block-index:Int) -> BlockStmtProcessor :
  ;Retrieve the block.
  val block = blocks(r)[block-index]

  ;
  new EngineStmtProcessor :
    ;Add a new statement.
    defmethod emit (this, s:ProgramStmt) :
      add(instructions(r), s)
    ;Retrieve the block ports.
    defmethod inputs (this) :
      inputs(block)
    defmethod outputs (this) :
      outputs(block)
    ;Retrieve the block predecessor/successors.
    defmethod successor-ports (this) :
      []
    defmethod predecessor-ports (this) :
      []
    ;Retrieve the statements in forward order.
    defmethod stmts (return:(Int,ProgramStmt) -> ?, this) :
      val indices = start(block) to end(block)
      for i in indices do :
        val stmt = instructions(r)[i]
        return(i - start(block), stmt)
    ;Retrieve the statements in backward order.
    defmethod stmts-in-reverse (return:(Int,ProgramStmt) -> ?, this) :
      val indices = reverse(start(block) to end(block))
      for i in indices do :
        val stmt = instructions(r)[i]
        return(i - start(block), stmt)
    ;Retrieve the variable definitions.
    defmethod vartype (this, v:Int) :
      type(vardefs(r)[v])


;============================================================
;====================== Adding Models =======================
;============================================================

public defn add (r:RegAllocEngine, m:OperationModel) -> False :
  ;Ensure that the model is properly indexed.
  if id(m) != length(models(r)) :
    fatal("Model is not densely indexed.")
    
  ;Ensure that the model is well-formed.
  try :
    check-model(model-checker(r), m)
  catch (e) :
    fatal(e)

  ;Analyze the model.
  val model-props = analyze(m)

  ;Add the model and its properties to the engine.
  add(models(r), m)
  add(model-properties(r), model-props)

;============================================================
;======================= Analysis ===========================
;============================================================

public defn analyze (r:RegAllocEngine, p:Program) -> False :
  if length(vars(p)) > num-vars(datastructures(r)) :
    fatal("Too many vars. Growth is not yet supported.")
  analyze(r, datastructures(r), p)

;Assume that the datastructures has been calculated which
;will work with the given program. Analyze it.
public defn analyze (r:RegAllocEngine,
                     rdata:RegAllocDatastructures
                     program:Program) -> False :
  ;Ensure that the program is well-formed.
  try :                   
    check-program(program-checker(rdata), program, true, r)
  catch (e) :
    fatal(e)

  ;Analyze the basic blocks.
  add-all(blocks(r), analyze-basic-blocks(program, r))

  ;Order the blocks in reverse post-order.
  order-blocks(blocks(r))

  ;Compute liveness of variables.
  compute-live(program, blocks(r))

  ;Compute the port preferences of each block.
  compute-port-prefs(program, r, blocks(r)) 

  do(println, blocks(r))

  println("Hello")
  