defpackage stz/reg-alloc-engine :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-block
  import stz/reg-alloc-model-check
  import stz/reg-alloc-program-check
  import stz/reg-alloc-model-properties
  import stz/reg-alloc-datastructures
  import stz/reg-alloc-model-env
  import stz/reg-alloc-model-analysis

;<doc>=======================================================
;====================== Algorithm ===========================
;============================================================

For each program:
  Check that the program is wellformed. (Optional)
  Analyze the basic blocks
  Compute live variables
  Annotate port preferences
  Then for each block:
    Compute 

;============================================================
;=======================================================<doc>

;============================================================
;=================== State Definition =======================
;============================================================

;Holds the complete state of the register allocation engine.
public defstruct RegAllocEngine <: ModelEnv :
  num-regs:Int
  num-fregs:Int
  blocks:Vector<Block> with:
    init => Vector<Block>()
  models:Vector<OperationModel> with:
    init => Vector<OperationModel>()
  model-properties:Vector<ModelProperties> with:
    init => Vector<ModelProperties>()  
  model-checker:ModelChecker
  datastructures:RegAllocDatastructures with :
    setter => set-datastructures
with:
  constructor => #RegAllocEngine

;Holds the datastructures that are specific to the number of
;variables.
public defstruct RegAllocDatastructures :
  num-vars:Int
  program-checker:ProgramChecker

;============================================================
;==================== Constructor ===========================
;============================================================

;Create a new Register Allocator engine.
public defn RegAllocEngine (num-regs:Int,
                            num-fregs:Int) -> RegAllocEngine :
  ;Create the datastructures that do not depend on number
  ;of program variables.
  val resources = ResourceProvider(num-regs, num-fregs, 0)
  val model-checker = ModelChecker(resources, num-regs, num-fregs)

  ;Create the variable-specific datastructures with an
  ;initial number of variables.
  val num-vars = 256
  val var-resources = ResourceProvider(num-regs, num-fregs, num-vars)
  val reg-datastructures = RegAllocDatastructures(
                             num-vars,
                             ProgramChecker(var-resources))

  ;Create the engine.
  #RegAllocEngine(num-regs,
                  num-fregs,
                  model-checker
                  reg-datastructures)

;============================================================
;============= RegAllocEngine as ModelEnv ===================
;============================================================

defmethod num-models (e:RegAllocEngine) :
  length(models(e))

defmethod model (e:RegAllocEngine, id:Int) :
  models(e)[id]

defmethod model-properties (e:RegAllocEngine, id:Int) :
  model-properties(e)[id]

;============================================================
;====================== Adding Models =======================
;============================================================

public defn add (r:RegAllocEngine, m:OperationModel) -> False :
  ;Ensure that the model is properly indexed.
  if id(m) != length(models(r)) :
    fatal("Model is not densely indexed.")
    
  ;Ensure that the model is well-formed.
  try :
    check-model(model-checker(r), m)
  catch (e) :
    fatal(e)

  ;Analyze the model.
  val model-props = analyze(m)

  ;Add the model and its properties to the engine.
  add(models(r), m)
  add(model-properties(r), model-props)

;============================================================
;======================= Analysis ===========================
;============================================================

public defn analyze (r:RegAllocEngine, p:Program) -> False :
  if length(vars(p)) > num-vars(datastructures(r)) :
    fatal("Too many vars. Growth is not yet supported.")
  analyze(r, datastructures(r), p)

;Assume that the datastructures has been calculated which
;will work with the given program. Analyze it.
public defn analyze (r:RegAllocEngine,
                     rdata:RegAllocDatastructures
                     p:Program) -> False :
  ;Ensure that the program is well-formed.
  try :                   
    check-program(program-checker(rdata), p, true, r)
  catch (e) :
    fatal(e)

  ;