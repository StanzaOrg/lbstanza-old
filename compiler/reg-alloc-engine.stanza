defpackage stz/reg-alloc-engine :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-block
  import stz/reg-alloc-model-check
  import stz/reg-alloc-program-check
  import stz/reg-alloc-critical-edges
  import stz/reg-alloc-model-properties
  import stz/reg-alloc-datastructures
  import stz/reg-alloc-model-env
  import stz/reg-alloc-model-analysis
  import stz/reg-alloc-basic-blocks
  import stz/reg-alloc-liveness
  import stz/reg-alloc-port-prefs
  import stz/reg-alloc-block-stmt-processor
  import stz/reg-alloc-block-arranger
  import stz/reg-alloc-annotations
  import stz/reg-alloc-allocation
  import stz/reg-alloc-assignment
  import stz/reg-alloc-add-temp-vars
  import stz/reg-alloc-stitcher
  import stz/reg-alloc-shuffle
  import stz/reg-alloc-stackmap
  import stz/reg-alloc-collapse
  import stz/reg-alloc-verify
  import stz/reg-alloc-flow-order
  import stz/printing-utils

;============================================================
;=================== State Definition =======================
;============================================================

;Holds the complete state of the register allocation engine.
public defstruct RegAllocEngine <: ModelEnv :
  num-regs:Int
  num-fregs:Int
  vardefs:Vector<VarDef> with:
    init => Vector<VarDef>()
  instructions:Vector<ProgramStmt> with:
    init => Vector<ProgramStmt>()
  blocks:Vector<Block> with:
    init => Vector<Block>()
  models:Vector<OperationModel> with:
    init => Vector<OperationModel>()
  model-properties:Vector<ModelProperties> with:
    init => Vector<ModelProperties>()
  used-registers-table:HashTable<UsageKey, UsedRegisters> with:
    init => HashTable<UsageKey, UsedRegisters>()
  model-checker:ModelChecker
  shuffler:ShuffleEngine
  datastructures:RegAllocDatastructures with :
    setter => set-datastructures
with:
  constructor => #RegAllocEngine

;Holds the datastructures that are specific to the number of
;variables.
public defstruct RegAllocDatastructures :
  num-vars:Int
  program-checker:ProgramChecker
  add-temp-vars:AddTempVars
  stitcher:Stitcher
  resources:ResourceProvider

;============================================================
;==================== Constructor ===========================
;============================================================

;Create a new Register Allocator engine.
public defn RegAllocEngine (num-regs:Int,
                            num-fregs:Int) -> RegAllocEngine :
  ;Create the datastructures that do not depend on number
  ;of program variables.
  val resources = ResourceProvider(num-regs, num-fregs, 0)
  val model-checker = ModelChecker(resources, num-regs, num-fregs)
  val shuffler = ShuffleEngine(resources)

  ;Create the variable-specific datastructures with an
  ;initial number of variables.
  val num-vars = 256
  val var-resources = ResourceProvider(num-regs, num-fregs, num-vars)
  val reg-datastructures = RegAllocDatastructures(
                             num-vars,
                             ProgramChecker(var-resources)
                             AddTempVars(var-resources)
                             Stitcher(shuffler, var-resources)
                             var-resources)

  ;Create the engine.
  #RegAllocEngine(num-regs,
                  num-fregs,
                  model-checker
                  shuffler
                  reg-datastructures)

;============================================================
;======================= Printing ===========================
;============================================================

defn current-program (e:RegAllocEngine) -> Printable :
  new Printable :
    defmethod print (o:OutputStream, this) :
      val o2 = IndentedStream(o)
      print(o, "Current Program:")
      for block in blocks(e) do :
        val ins = for i in 0 to length(block) seq :
          instructions(e)[i + start(block)]
        val items = [
          simple-field("start", start(block))
          simple-field("length", length(block))
          simple-field("succs", succs(block))
          simple-field("preds", preds(block))
          simple-field("ends-with-goto?", ends-with-goto?(block))
          named-list-fields("inputs", inputs(block))
          named-list-fields("statements", ins)
          named-list-fields("outputs", outputs(block))
          simple-list-field("defs", defs(block))]
        lnprint(o2, "block B%_ %_" % [index(block), colon-field-list(items)])

defn format-block (e:RegAllocEngine, b:Block) -> Printable :
  new Printable :
    defmethod print (o:OutputStream, this) :
      val ins = for i in 0 to length(b) seq :
        instructions(e)[i + start(b)]
      val items = [
        simple-field("start", start(b))
        simple-field("length", length(b))
        simple-field("succs", succs(b))
        simple-field("preds", preds(b))
        simple-field("ends-with-goto?", ends-with-goto?(b))
        named-list-fields("inputs", inputs(b))
        named-list-fields("statements", ins)
        named-list-fields("outputs", outputs(b))
        simple-list-field("defs", defs(b))]
      lnprint(o, "block B%_ %_" % [index(b), colon-field-list(items)])      

;============================================================
;============= RegAllocEngine as ModelEnv ===================
;============================================================

defmethod num-models (e:RegAllocEngine) :
  length(models(e))

defmethod model (e:RegAllocEngine, id:Int) :
  models(e)[id]

defmethod model-properties (e:RegAllocEngine, id:Int) :
  model-properties(e)[id]

;Retrieve the used registers for a given operation under a given usage context.
defmethod used-registers (e:RegAllocEngine, id:Int, ctxt:UsageContext) -> UsedRegisters :
  val table = used-registers-table(e)
  set?(table, UsageKey(id,ctxt),
    fn () :
      used-registers(model(e,id), ctxt))

;Lookup the used registers corresponding to a particular type of
;usage of a given operation.
defstruct UsageKey <: Hashable&Equalable :
  op-id:Int
  killed:Tuple<Int>
with:
  hashable => true
  equalable => true

;Create a UsageKey from a UsageContext.
defn UsageKey (op-id:Int, ctxt:UsageContext) -> UsageKey :
  UsageKey(op-id, killed(ctxt))

;============================================================
;========== RegAllocEngine as BlockStmtProcessor ============
;============================================================

;The block stmt processor for the RegAllocEngine.
deftype EngineStmtProcessor <: BlockStmtProcessor

;Indicate that we have finished processing the block and the
;results should be stored in the engine.
defmulti save-results (proc:EngineStmtProcessor) -> False

defn stmt-processor (r:RegAllocEngine, block-index:Int) -> EngineStmtProcessor :
  ;Retrieve the block.
  val block = blocks(r)[block-index]

  ;Retrieve the number of instructions
  ;in the buffer before anything is emitted.
  val num-instructions = length(instructions(r))

  ;Store the direction that the statements are traversed in.
  var direction:Direction|False = false

  ;Return the statement processor.
  new EngineStmtProcessor :
    ;Add a new statement.
    defmethod emit (this, s:ProgramStmt) :
      add(instructions(r), s)
    ;Retrieve the block ports.
    defmethod inputs (this) :
      inputs(block)
    defmethod outputs (this) :
      outputs(block)
    ;Retrieve the block predecessor/successors.
    defmethod successor-ports (this) :
      ;val next = for succ in succs(block) filter :
      ;  succ > block-index
      val next = succs(block)
      to-tuple $ seq(inputs{blocks(r)[_]}, next)
    defmethod predecessor-ports (this) :
      val prev = preds(block)
      ;val prev = for pred in preds(block) filter :
      ;  pred < block-index
      to-tuple $ seq(outputs{blocks(r)[_]}, prev)
    ;Retrieve the statements in forward order.
    defmethod stmts (return:(Int,ProgramStmt) -> ?, this) :
      direction = Forward
      val indices = start(block) to end(block)
      for i in indices do :
        val stmt = instructions(r)[i]
        return(i - start(block), stmt)
    ;Retrieve the statements in backward order.
    defmethod stmts-in-reverse (return:(Int,ProgramStmt) -> ?, this) :
      direction = Reverse
      val indices = reverse(start(block) to end(block))
      for i in indices do :
        val stmt = instructions(r)[i]
        return(i - start(block), stmt)
    ;Retrieve the variable definitions.
    defmethod vartype (this, v:Int) :
      type(vardefs(r)[v])
    ;Save the results of the block.
    defmethod save-results (this) :
      ;Compute the total number of instructions emitted to the buffer.
      val len = length(instructions(r)) - num-instructions
      ;If the instructions were emitted in reverse order, then
      ;flip them.
      if direction is Reverse :
        reverse-range!(instructions(r), num-instructions, len)
      ;Save the new block instructions.
      set-start(block, num-instructions)
      set-length(block, len)

;Represent the traversal direction.
defenum Direction :
  Forward
  Reverse

;Reverse all the elements in the given range of the vector.
defn reverse-range! (x:Vector, start:Int, len:Int) -> False :
  ;Swap the element at index a with the element at index b.
  defn swap! (a:Int, b:Int) -> False :
    if a != b :
      val xa = x[a]
      val xb = x[b]
      x[a] = xb
      x[b] = xa
  ;Swap!
  val last = start + len - 1
  for i in 0 to len / 2 do :
    swap!(start + i, last - i)

;============================================================
;====================== Adding Models =======================
;============================================================

public defn add (r:RegAllocEngine, m:OperationModel) -> False :
  ;Ensure that the model is properly indexed.
  if id(m) != length(models(r)) :
    fatal("Model is not densely indexed.")

  ;Ensure that the model is well-formed.
  try :
    check-model(model-checker(r), m)
  catch (e) :
    fatal(e)

  ;Analyze the model.
  val model-props = analyze(m)

  ;Add the model and its properties to the engine.
  add(models(r), m)
  add(model-properties(r), model-props)

;============================================================
;======================= Analysis ===========================
;============================================================

public defn analyze (r:RegAllocEngine, p:Program) -> False :
  if length(vars(p)) > num-vars(datastructures(r)) :
    fatal("Too many vars. Growth is not yet supported.")

  ;Ensure that the program is well-formed.
  try :
    check-program(program-checker(datastructures(r)), p, true, r)
  catch (e) :
    fatal(e)
 
  ;Preprocess the program by adding temporary variables.
  val add-vars = add-temp-vars(datastructures(r))
  val processed-program = process(add-vars, p, r)

  ;Analyze the processed program.
  analyze(r, datastructures(r), processed-program)

;Assume that the datastructures has been calculated which
;will work with the given program. Analyze it.
public defn analyze (r:RegAllocEngine,
                     rdata:RegAllocDatastructures
                     program:Program) -> False :


  ;Analyze the basic blocks.
  add-all(blocks(r), analyze-basic-blocks(program, r))

  ;Remove critical edges.
  remove-critical-edges(blocks(r))

  ;Order the blocks in reverse post-order.
  order-blocks(blocks(r))

  ;Compute liveness of variables.
  compute-live(program, blocks(r))

  ;Compute the port preferences of each block.
  compute-port-prefs(program, r, blocks(r))

  ;Load all the program definitions into the buffer.
  add-all(vardefs(r), vars(program))
  add-all(instructions(r), stmts(program))

  ;Process a block.
  defn process-block (f:BlockStmtProcessor -> False, block:Int) :
    val proc = stmt-processor(r, block)
    f(proc)
    save-results(proc)

  ;Compute annotations for all blocks.
  for block in in-reverse(blocks(r)) do :
    process-block(annotate-block{_, r}, index(block))
  println(current-program(r))

  ;Compute in flow order.
  for stage in flow-order(blocks(r)) do :
    switch(type(stage)) :
      ForwardStage :
        process-block(allocate-block{_, r, num-regs(r), num-fregs(r)}, block(stage))
        process-block(assign-registers{_, r, resources(rdata)}, block(stage))
      HeaderStage :
        process-block(inherit-predecessor-prefs, block(stage))
      BackwardStage :
        process-block(annotate-block{_, r}, block(stage))

;  ;Allocate and assign all blocks.
;  for block in blocks(r) do :
;    ;Allocate
;    val proc = stmt-processor(r, index(block))
;    allocate-block(proc, r, num-regs(r), num-fregs(r))
;    save-results(proc)
;    ;Assign
;    val proc2 = stmt-processor(r, index(block))
;    assign-registers(proc2, r, resources(rdata))
;    save-results(proc2)

  ;Compute stack map
  val stackmap = compute-stackmap(vardefs(r),
                                  instructions(r),
                                  blocks(r))
  println(stackmap)

  ;Stitch blocks together.
  val stitch-results = stitch-blocks(stitcher(rdata), blocks(r))
  for block in blocks(r) do :
    val proc = stmt-processor(r, index(block))
    preamble(emit{proc, _}, stitch-results, index(block))
    within (i, stmt) = stmts(proc) :
      emit(proc, stmt)
    postamble(emit{proc, _}, stitch-results, index(block))
    save-results(proc)

  ;Collapse everything into a single program.
  val new-program = collapse(vardefs(r),
                             instructions(r),
                             blocks(r),
                             stackmap)
  ;New program
  println(new-program)

  ;Verification
  verify(new-program, r)


