defpackage stz/reg-alloc-program-check :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-datastructures
  import stz/reg-alloc-errors
  import stz/reg-alloc-error-utils
  import stz/reg-alloc-model-env

;Type for checking programs.
public defstruct ProgramChecker : ()

;Create a program checker.
public defn ProgramChecker (resources:ResourceProvider) -> ProgramChecker :
  ProgramChecker()

;Check the program and throw errors if program is invalid.
public defn check-program (c:ProgramChecker,
                           p:Program,
                           allow-repetitions?:True|False,
                           models:ModelEnv) -> False :
  within throw-if-errors(ProgramErrors) :
    check-variable-indexing(c, vars(p))
  within throw-if-errors(ProgramErrors) :
    check-program-labels(c, p)
    check-program-operations(c, vars(p), stmts(p), models, allow-repetitions?)

;Check the given program fragment and throw errors if its invalid.
public defn check-program-fragment (c:ProgramChecker,
                                    vars:Tuple<VarDef>,
                                    statements:Tuple<ProgramStmt>,
                                    models:ModelEnv) -> False :
  within throw-if-errors(ProgramErrors) :
    check-variable-indexing(c, vars)
  within throw-if-errors(ProgramErrors) :
    check-program-operations(c, vars, statements, models, false)

;Check that the variables are correctly indexed.
defn check-variable-indexing (c:ProgramChecker, vars:Tuple<VarDef>) -> False :
  ;CHECK: Variables should be densely indexed.
  for (v in vars, i in 0 to false) do :
    if id(v) != i :
      error(BadIndexedProgramVar())  

;Check that the statements are wellformed.
defn check-program-labels (c:ProgramChecker, p:Program) -> False :
  ;Retrieve all labels in the program.
  val labels = to-tuple(filter-by<LabelStmt>(stmts(p)))

  ;Helper: Return true if i is a valid label index.
  defn good-label? (i:Int) -> True|False :
    i >= 0 and i < length(labels)

  ;Create the table of labels.
  val label-array = Array<True|False>(length(labels), false)
  for l in labels do :
    within stop-on-first-error() :
      ;CHECK: Is label index wellformed?
      if not good-label?(index(l)) :
        error(BadlyIndexedLabel())
      ;CHECK: Is label defined twice?
      if label-array[index(l)] :
        error(DuplicateLabel())
      label-array[index(l)] = true  

  ;Loop through other statements and make sure those
  ;are wellformed labels.
  for stmt in stmts(p) do :
    match(stmt) :
      (stmt:BranchStmt) :
        ;CHECK: Is target indices wellformed?
        for target in targets(stmt) do :
          if not good-label?(target) :
            error(BadTarget())
      (stmt:GotoStmt) :
        ;CHECK: Is target index wellformed?
        if not good-label?(target(stmt)) :
          error(BadTarget())
      (stmt) :
        false

;Check that the program operations are wellformed.
defn check-program-operations (c:ProgramChecker,
                               vars:Tuple<VarDef>,
                               statements:Tuple<ProgramStmt>,
                               models:ModelEnv,
                               allow-repetitions?:True|False) -> False :
                               
  ;Helper: Return true if given id is a valid operation id.
  defn good-op? (id:Int) -> True|False :
    id >= 0 and id < num-models(models)

  ;Helper: Return true if given v is a valid variable.
  defn good-var? (v:Int) -> True|False :
    v >= 0 and v < length(vars)

  ;Helper: Return the type of the variable v.
  defn var-type (v:Int) -> RegisterType :
    type(vars[v])   
  
  val var-set = IntSet()
  for stmt in statements do :
    match(stmt) :
      ;Check an OperationStmt.
      (stmt:OperationStmt) :
        within stop-on-first-error() :
          ;CHECK: The operation is wellformed.
          if not good-op?(op-id(stmt)) :
            error(BadOp())
          ;CHECK: Arguments are wellformed.
          for v in cat(results(stmt),args(stmt)) do :
            if not good-var?(v) :
              error(BadProgramVar())
          ;CHECK: Correct number of arguments.
          val given-args = length(args(stmt))
          val expected-args = length(arg-types(models, op-id(stmt)))
          if given-args != expected-args :
            error(BadArgArity(op-id(stmt), expected-args, given-args))
          ;CHECK: Correct number of results.
          val given-results = length(results(stmt))
          val expected-results = length(result-types(models, op-id(stmt)))
          if given-results != expected-results :
            error(BadResultArity(op-id(stmt), expected-results, given-results))
          ;CHECK: Arguments are welltyped.
          for (v in args(stmt), t in arg-types(models, op-id(stmt))) do :
            if var-type(v) != t :
              error(BadArgType())
          ;CHECK: Results are welltyped.
          for (v in results(stmt), t in result-types(models, op-id(stmt))) do :
            if var-type(v) != t :
              error(BadResultType())
          ;CHECK: Results cannot use the same var.
          clear(var-set)
          for v in results(stmt) do :
            if not add(var-set,v) :
              error(RepeatedVarInResult())
          ;CHECK: Repetitions are removed.
          if not allow-repetitions? :
            clear(var-set)
            for v in cat(results(stmt),args(stmt)) do :
              if not add(var-set,v) :
                error(RepeatedVarInOp(op-id(stmt), v))
                
      ;Check SetStmt.
      (stmt:SetStmt) :
        within stop-on-first-error() :
          ;CHECK: Arguments are wellformed.
          for v in cat(results(stmt),args(stmt)) do :
            if not good-var?(v) :
              error(BadProgramVar())
          ;CHECK: Statement has at least one argument and result.
          val given-args = length(args(stmt))
          val given-results = length(results(stmt))
          if given-args == 0 or given-results == 0 :
            error(EmptySetStmt())
          ;CHECK: Statement has same number of arguments and results.
          if given-args != given-results :
            error(MismatchedSetStmt())
          ;CHECK: Arguments and results have same type.
          for (a in args(stmt), r in results(stmt)) do :
            if var-type(a) != var-type(r) :
              error(BadSetType())
          ;CHECK: Results cannot use the same var.
          clear(var-set)
          for v in results(stmt) do :
            if not add(var-set,v) :
              error(RepeatedVarInResult())
          ;CHECK: Repetitions are removed.
          if not allow-repetitions? :
            clear(var-set)
            for v in cat(results(stmt),args(stmt)) do :
              if not add(var-set,v) :
                error(RepeatedVarInSet(v))          
      
      ;Other statements have already been checked.
      (stmt) :
        false
