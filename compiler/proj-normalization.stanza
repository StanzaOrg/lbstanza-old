defpackage stz/proj-normalization :
  import core
  import collections
  import stz/proj-ir
  import stz/proj-stage0
  import stz/proj-errors
  import core/parsed-path

;============================================================
;========== Entry point: Normalize an Entire File ===========
;============================================================

;This pass normalizes all ProjValue within the proj file.
;- Collapses all CondPlatform values into a single value.
;- Collapses all SplicedString values into an AtomValue containing a String.
;- Guarantees that ProjValues do not recursively contain ProjValues.

public defn normalize (f:ProjFileS0,
                       current-platform:Symbol,
                       workdir:String) -> ProjFileS0 :
  val dirtable = SpecialDirTable(f, workdir)
  defn norm (item:ProjItem) -> ProjItem :
    match(item:ProjValue) : normalize(item, current-platform, dirtable)
    else : map(norm, item)
  val new-stmts = map({norm(_) as ProjStmt}, stmts(f))
  sub-stmts(f, new-stmts)

;============================================================
;============= Entry point: Normalize One Value =============
;============================================================

;Used to fill in default values.
;- proj-path: The full path of the ProjFile containing this value.
public defn normalize (v:ProjValue,
                       current-platform:Symbol,
                       workdir:String,
                       proj-path:String) -> ProjValue :
  val dirtable = SpecialDirTable(workdir, proj-path)
  normalize(v, current-platform, dirtable)

;============================================================
;=================== Value Normalization ====================
;============================================================

;Normalize the given value under the given platform.
;- Collapses all CondPlatform values into a single value.
;- Separates SplicedString values that contain ProjValues.
;- Guarantees that ProjValues do not recursively contain ProjValues.

defn normalize (v:ProjValue,
                platform:Symbol,
                dirtable:SpecialDirTable) -> ProjValue :
  v $> eval-condplatform{_, platform}
    $> substitute-special-dirs{_, dirtable}
    $> collapse-spliced-strings
    $> flatten-projvalues

;============================================================
;================ Evaluate CondPlatform =====================
;============================================================

;Evaluate all CondPlatform in the given ProjValue.
defn eval-condplatform (v:ProjValue, platform:Symbol) -> ProjValue :
  match(v:CondPlatform) :
    for e in values(v) first! :
      if key(e) == platform or key(e) == `else :
        One(eval-condplatform(value(e), platform))
      else :
        None()
  else :
    val result = map(eval-condplatform{_ as ProjValue, platform}, v)
    result as ProjValue

;============================================================
;================ Substitute Special Dirs ===================
;============================================================

;Hold all the paths needed to resolve WorkDir and ProjDir.
defstruct SpecialDirTable :
  workdir:String
  projdirs:IntTable<String>

;Scan the file for the mapping from file ids to paths.
;- workdir: The absolute path to the current working directory.
defn SpecialDirTable (file:ProjFileS0, workdir:String) -> SpecialDirTable :

  ;Create the table of project directories.
  val projdirs = IntTable<String>()

  ;Add a new project directory to the table.
  defn add-proj-dir (id:Int, proj-path:String) :
    projdirs[id] = to-string(enclosing-dir(proj-path))

  ;Scan a statement and add entries to prodirs.
  defn scan (stmt:ProjStmt) :
    match(stmt:IncludedStmtsS0) :
      add-proj-dir(proj-file-id(stmt), full-path(stmt))
      do(scan, stmts(stmt))

  ;Launch!
  add-proj-dir(id(file), full-path(file))
  do(scan, stmts(file))

  ;Bundle up the SpecialDirTable.
  SpecialDirTable(workdir, projdirs)

;Special case for building a SpecialDirTable for just one value.
;The special id 0 is given to the proj-file-id. 
defn SpecialDirTable (workdir:String, proj-path:String) -> SpecialDirTable :
  val projdirs = IntTable<String>()
  projdirs[0] = to-string(enclosing-dir(proj-path))
  SpecialDirTable(workdir, projdirs)

;Substitute all the WorkDir|ProjDir values in the ProjValue.
defn substitute-special-dirs (v:ProjValue,
                              dirtable:SpecialDirTable) -> ProjValue :
  match(v) :
    (v:WorkDir) :
      AtomValue(info(v), workdir(dirtable))
    (v:ProjDir) :
      AtomValue(info(v), projdirs(dirtable)[proj-file-id(v)])
    (v:ProjValue) :
      map(substitute-special-dirs{_ as ProjValue, dirtable}, v)


;============================================================
;================= Collapse SplicedString ===================
;============================================================

;If a SplicedString contains a ProjValues, then treat the
;values as if they contain a separator, and hence splits up the
;overall string into multiple separate values.
;The input SplicedString assumes that values contain no CondPlatform.

defn collapse-spliced-strings (v:ProjValue) -> ProjValue :
  val result = map(collapse-spliced-strings{_ as ProjValue}, v)
  match(result) :
    (result:SplicedString) : join-string(result)
    (result:ProjValue) : result

;Join all the parts in the given spliced string into an
;AtomValue.
defn join-string (spliced-string:SplicedString) -> AtomValue :
  ;Create buffer of all substrings.
  val buffer = Vector<String>()

  ;Iterate through all individual parts within v.
  defn all-parts (return:AtomValue -> ?, v:ProjValue) :
    match(v) :
      (v:ProjValues) : do(all-parts{return, _}, values(v))
      (v:ProjTuple) : all-parts(return, value(v))
      (v:AtomValue) : return(v)

  ;Iterate through the values and add them to the buffer with
  ;a separator between ProjValues.
  for value in values(spliced-string) do :
    val index-counter = to-seq(0 to false)
    for part in value all-parts :
      add(buffer, " ") when next(index-counter) > 0
      add(buffer, to-string(/value(part)))

  ;Return the joined string.
  AtomValue(info(spliced-string), string-join(buffer))

;============================================================
;=================== Flatten ProjValues =====================
;============================================================

;Flatten every ProjValues. We guarantee after this that:
;- ProjValues never recursively contains another ProjValues.
;- ProjValues never have length 1.

defn flatten-projvalues (v:ProjValue) -> ProjValue :
  match(v:ProjValues) :
    val vs = to-tuple $
      for vi in values(v) seq-cat :
        match(flatten-projvalues(vi)) :
          (vi:ProjValues) : values(vi)
          (v) : [v]
    if length(vs) == 1 : vs[0]
    else : ProjValues(info(v), vs)
  else :
    map(flatten-projvalues{_ as ProjValue}, v) as ProjValue

