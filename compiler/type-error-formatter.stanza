defpackage stz/type-error-formatter :
  import core
  import collections
  import stz/tl-ir2
  import stz/type-errors
  import stz/namemap
  import stz/type-formatter
  import stz/types
  import stz/type-fargs

;============================================================
;==================== Public API ============================
;============================================================

;Type for computing human-readable versions of type errors.
public deftype TypeErrorFormatter

;Format a type error to be human-readable.
public defmulti format (f:TypeErrorFormatter, e:TypeError) -> ?

;============================================================
;==================== Formatting ============================
;============================================================

public defn TypeErrorFormatter (namemap:NameMap) :

  ;Return a human-readable name for the given identifier.
  defn def-name (n:Int) -> Symbol :
    if key?(namemap, n) : name(namemap[n])
    else : to-symbol("$v%_" % [n])

  ;Create a formatter for formatting types.
  val type-formatter = TypeFormatter(def-name)

  ;Return a human-readable string representing the definition
  ;name.
  defn def-description (e:TDef|TDefTuple|TDefVar|TLet|TLetVar|TLetTuple|LSDef|
                          TDefn|TDefmethod|TFn|TLDef|TLDefVar|TLDefn|TLDefmethod|TLExternFn) :
    defn fmt (s:String, n:Int|Tuple<Int>) :
      match(n) :
        (n:Int) : s % [def-name(n)]
        (ns:Tuple<Int>) : s % [seq(def-name, ns)]
    match(e) :
      (e:TDef) : fmt("global variable %_", n(e))
      (e:TDefTuple) : fmt("global variables %,", ns(e))
      (e:TDefVar) : fmt("global mutable variable %_", n(e))
      (e:TLet) : fmt("variable %_", n(e))
      (e:TLetVar) : fmt("mutable variable %_", n(e))
      (e:TLetTuple) : fmt("variables %,", ns(e))
      (e:TLDef) : fmt("LoStanza global variable %_", n(e))
      (e:TLDefVar) : fmt("LoStanza global mutable variable %_", n(e))
      (e:LSDef) : fmt("LoStanza global variable %_", n(e))
      (e:TDefn) : fmt("global function %_", n(e))
      (e:TLDefn) : fmt("LoStanza global function %_", n(e))
      (e:TDefmethod) : fmt("method %_", first-n(multi(e)))
      (e:TLDefmethod) : fmt("LoStanza method %_", first-n(multi(e)))
      (e:TFn) : "anonymous function"
      (e:TLExternFn) : fmt("externfn %_", n(e))

  ;Return a human-readable string representing the given LValue.
  defn loc-description (e:LSExp|TRef) :
    defn fmt (s:String, n:Int) : s % [def-name(n)]
    match(e) :
      (e:TRef) : fmt("variable %_", n(e))
      (e:LSVar) : fmt("LoStanza variable %_", n(e))
      (e:LSDeref) : "dereferenced location"
      (e:LSSlot) : "indexed slot"
      (e:LSField) : "field '.%_'" % [name(e)]

  ;Return a human-readable string describing the given expression.
  defn exp-description (e:TExp|LSExp) :
    defn fmt (s:String, n:Int) : s % [def-name(n)]
    match(e) :
      (e:TRef) : fmt("variable %_", n(e))
      (e:TMix) : fmt("function %_", n(refs(e)[0]))
      (e:LSVar) : fmt("variable %_", n(e))
      (e:LSMix) : fmt("function %_", n(refs(e)[0]))
      (e) : "expression"

  ;Return a human-readable listing of arguments and their expected types.
  defn arg-descriptions (es:Tuple<KeyValue<Int,TExp|LSExp>>) :
    val entries = for e in es seq :
      val index = key(e)
      val type = type!(value(e))
      val exp-type = expected(ctxt(value(e)) as ExpCtxt|LSExpCtxt)
      Indented("Argument %_: Passing type '%_' to expected type '%_'." % [index, type, exp-type])
    "%n" % [entries]

  ;Retrieve human-readable description of the given type.
  defn type-description (t:Type|LSType) :
    format(type-formatter, t)

  ;Return the first identifier within the TMix.
  ;Used to retrieve a human-readable name for the mix.
  defn first-n (e:TExp) -> Int :
    n(refs(e as TMix)[0])

  ;Return a human-readable prefix for the file information.
  defn info-str (info:FileInfo|False) :
    "" when info is False else "%_: " % [info]
  defn info-str (e:TExp|TComm|LSExp|LSComm) :
    info-str(info(e))

  new TypeErrorFormatter :

    defmethod format (this, e:TypeError) :
      defn temp-message (info:FileInfo|False) :
        "%_ at %_" % [object-type(e), info]

      match(e) :
      
        (e:NoInferredType) :
          "%_Could not infer type of %_." % [
          info-str(info(comm(e))), def-description(comm(e))]

        (e:NoInferredArg) :
          "%_Could not infer type of function argument '%_'" % [
          info-str(info(exp(e))), def-name(arg(e))]

        (e:NoInferredReturn) :
          "%_Could not infer return type of %_." % [
          info-str(comm(e)), def-description(comm(e))]

        (e:BadDetuple) :
          val arity = length(ns(comm(e)))
          "%_Cannot detuple expression of type '%_' into a tuple of %_ elements." % [
          info-str(comm(e)), type-description(type!(value(comm(e)))), arity]

        (e:BadAssign) :
          val value-type = type!(value(comm(e)) as TExp|LSExp)
          val exp-type = match(comm(e)) :
            (c:TDef|TDefVar|TLDef|TLDefVar) : type(c) as Type|LSType
            (c:TLet|TLetVar) : ntype(c) as Type
            (c:LSDef|LSDefVar) : type(c) as LSType
            (c:TDefTuple) : TTuple(types(c) as Tuple<Type>)
            (c:TLetTuple) : TTuple(ntypes(c) as Tuple<Type>)
          "%_Cannot assign expression of type '%_' to %_ with expected type '%_'." % [
          info-str(comm(e)), type-description(value-type), type-description(exp-type)]

        (e:BadReturn) :
          "%_Cannot return expression of type '%_' from function with declared return type '%_'." % [
          info-str(exp(e)), type-description(type!(exp(e))), type-description(return-type(e))]

        (e:BadLSReturn) :
          val v = exp(exp(e))
          val exp-type = expected(ctxt(v) as LSExpCtxt)
          "%_Cannot return expression of type '%_' from function with declared return type '%_'." % [
          info-str(exp(e)), type-description(type!(v)), type-description(exp-type)]

        (e:UnboundedDef) :
          "%_Cannot declare %_ with unbounded type '%_'." % [
          info-str(comm(e)), def-description(comm(e)), type-description(type(comm(e)))]

        (e:UnboundedArg) :
          val arg-index = index-of!(args(comm(e)), arg(e))
          val arg-type = type(a1(comm(e))[arg-index])
          "%_Cannot declare argument %_ with unbounded type '%_' in %_." % [
          info-str(comm(e)), def-name(arg(e)), type-description(arg-type), def-description(comm(e))]

        (e:UnboundedReturn) :
          "%_Cannot declare %_ with unbounded return type '%_'." % [
          info-str(comm(e)), def-description(comm(e)), type-description(a2(comm(e)))]

        (e:UnboundedStruct) :
          "%_Cannot directly allocate struct '%_' of unbounded size." % [
          info-str(exp(e)), def-name(n(exp(e)))]

        (e:UnboundedDeref) :
          val v = exp(exp(e))
          "%_Cannot dereference expression of type '%_' of unbounded size." % [
          info-str(exp(e)), type-description(type!(v))]

        (e:UnboundedDeslot) :
          val v = exp(exp(e))
          "%_Cannot access indexed slot in expression of type '%_' of unbounded size." % [
          info-str(exp(e)), type-description(type!(v))]

        (e:UnboundedField) :
          val v = exp(exp(e))
          "%_Cannot access named field '.%_' in expression of type '%_'. Field has unbounded size." % [
          info-str(exp(e)), name(exp(e)), type-description(type!(v))]

        (e:UnboundedCast) :
          "%_Cannot cast expression to unbounded type '%_'." % [
          info-str(exp(e)), type-description(targ(exp(e)))]

        (e:BadExternfnArg) :
          val arg-index = index-of!(args(comm(e)), arg(e))
          val arg-type = a1(comm(e))[arg-index]
          "%_Argument '%_' in %_ declared with invalid type '%_'." % [
          info-str(comm(e)), def-name(arg(e)), def-description(comm(e)), type-description(arg-type)]

        (e:BadExternfnReturn) :
          val ret-type = a2(comm(e))
          "%_Cannot declare %_ with invalid return type '%_'." % [
          info-str(comm(e)), def-description(comm(e)), type-description(ret-type)]

        (e:BadUpCast) :
          val v = exp(exp(e))
          "%_Expression of type '%_' cannot be upcasted to type '%_'." % [
          info-str(exp(e)), type-description(type!(v)), type-description(targ(exp(e)))]

        (e:BadSetRef) :
          val v = ref(exp(e))
          "%_The variable '%_' of type '%_' cannot be assigned to in HiStanza context." % [
          info-str(exp(e)), def-name(n(v)), type-description(true-type(v) as Type|LSType)]

        (e:BadSetValue) :
          val value-type = type!(value(exp(e)))
          val loc = match(exp(e)) :
            (e:TSet) : ref(e)
            (e:LSSet) : exp(e)
          val loc-type = type!(loc)
          "%_Cannot assign expression of type '%_' to %_ of type '%_'." % [
          info-str(exp(e)), type-description(value-type), loc-description(loc), type-description(loc-type)]

        (e:BadLValue) :
          val loc = exp(exp(e))
          "%_Cannot assign to non-mutable %_." % [
          info-str(exp(e)), loc-description(loc)]

        (e:BadArgTypes) :
          val func = func(exp(e))
          val arg-exps = map(type, args(exp(e)))
          val arg-entries = for i in arg-indices(e) map : i => arg-exps[i]
          if func is TMix|LSMix :          
            "%_Cannot call %_ with given arguments:\n%_" % [
            info-str(exp(e)), exp-description(func), arg-descriptions(arg-entries)]
          else :
            "%_Cannot call %_ of type '%_' with given arguments:\n%_" % [
            info-str(exp(e)), exp-description(func), type-description(type!(func)),
            arg-descriptions(arg-entries)]
;<comment>          
        (e:NotFunction) :
          val func = ???
          "%_Cannot call %_ of type '%_' with %_ type arguments and %_ value arguments" % [
          info-str(exp(e)), exp-description(func), type-description(type!(func)), num-targs, num-args]

        (e:BadPrimitive) :
          prim
          "%_Cannot call primitive '%_' with arguments of type (%,)." % [
          info-str(exp(e)), name(prim), seq(type-description,arg-types)]

        (e:BadGotoArity) :
          val num-args = ...
          "%_Cannot goto labeled block '%_' using %_ arguments." % [
          info-str(exp(e)), def-name(lbl), num-args]

        (e:BadGotoArgs) :
          val arg-entries = ???
          "%_Cannot goto labeled block '%_' with given arguments:\n%_" % [
          info-str(exp(e)), def-name(lbl), arg-descriptions(arg-entries)]

        (e:BadIfPred) :
          "%_Invalid expression of type %_ for 'if' condition. Expected a 'long'." % [
          info-str(exp(e)), type-description(type!(exp(e)))]

        (e:BadAndArg) :
          "%_Invalid expression of type %_ in 'and' expression. Expected a 'long'." % [
          info-str(exp(e)), type-description(type!(exp(e)))]

        (e:BadOrArg) :
          "%_Invalid expression of type %_ in 'or' expression. Expected a 'long'." % [
          info-str(exp(e)), type-description(type!(exp(e)))]

        (e:BadHiStanzaRef) :
          "%_Cannot reference variable '%_' of type '%_' from HiStanza context." % [
          info-str(ref(e)), def-name(n), type-description(ref-type)]

        (e:BadObjectTArity) :
          "%_The type '%_' expects %_ type arguments but received %_ arguments." % [
          info-str(exp(e)), num-expected-targs, num-targs]

        (e:BadObjectArity) :
          if rest-type?(n) :
            "%_The type '%_' expects at least %_ fields but received %_ fields." % [
            info-str(exp(e)), def-name(n), field-arity, num-fields]
          else :
            "%_The type '%_' expects %_ fields but received %_ fields." % [
            info-str(exp(e)), def-name(n), field-arity, num-fields]

        (e:BadObjectArgs) :
          "%_Cannot initialize type '%_' with given fields:\n%_" % [
          info-str(exp(e)), def-name(n), arg-descriptions(arg-entries)]

        (e:UnsupportedNew) :
          "%_The type '%_' cannot be instantiated using the 'new' operator. The first field \
           in a variable-sized type must be 'long'." % [
           info-str(exp(e)), def-name(n)]

        (e:UnstableAddr) :
          "%_Cannot retrieve the address of unstable heap location using 'addr' operator. \
           To forcefully the address use the 'addr!' operator." % [
           info(exp(e))]

        (e:BadDeref) :
          "%_Cannot dereference expression of type '%_'." % [
          info(exp(e)), type-description(type!(v))]

        (e:BadDeslot) :
          "%_Cannot access indexed slot in expression of type '%_'."

        (e:BadIndex) :
          "%_Cannot use expression of type '%_' as index. Index must be a 'long'."

        (e:BadField) :
          "%_Cannot access named field .F in expression of type '%_'."

        (e:BadSize) :
          "%_The type '%_' does not have a fixed size."

        (e:BadCast) :
          "%_Expression of type '%_' cannot be cast to type '%_'."

        (e:BadBranchArg) :
          "%_Invalid argument '%_' of type '%_'. This type cannot match the \
           'match' argument of type '%_'"

        (e:BadMatchArg) :
          "%_Argument %_ of type '%_' cannot be used in a 'match' expression."

        (e:FunctionRefInInvalidCtxt) :
          "%_Cannot directly reference function '%_' in this context."

        (e:AmbMix) :
          temp-message(info(exp(e)))

        (e:NoMix) :
          temp-message(info(exp(e)))

        (e:NoMulti) :
          temp-message(info(exp(e)))

        (e:AmbMulti) :
          temp-message(info(exp(e)))

        (e:BadSubmethod) :          
          temp-message(info(comm(e)))

        (e:BadThisType) :        
          temp-message(info(comm(e)))
;<comment>