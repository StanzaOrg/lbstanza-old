defpackage stz/primitives :
   import core
   import verse
   import stz/tl-ir
   import stz/utils

public defstruct LSPrimitive :
   name: Symbol
   targs: List<Int>
   a: List<LSType>
   b: LSType
   
public val LS-PRIMITIVES = Vector<LSPrimitive>()
add(LS-PRIMITIVES, LSPrimitive(`heap, List(), List(), PtrT(UnknownT())))
add(LS-PRIMITIVES, LSPrimitive(`set-heap, List(), list(PtrT(UnknownT())), LongT()))
add(LS-PRIMITIVES, LSPrimitive(`heap-limit, List(), List(), PtrT(UnknownT())))
add(LS-PRIMITIVES, LSPrimitive(`set-heap-limit, List(), list(PtrT(UnknownT())), LongT()))

defn sub (t:LSType, env:List<KeyValue<Int,LSType>>) :
   match(t) :
      (t:UVarT) : lookup!(env, n(t))
      (t) : map(sub{_, env}, t)

public defn ls-primitive? (primname:Symbol) :
   ls-primitive(primname) != false

public defn ls-primitive (primname:Symbol) :
   for p in LS-PRIMITIVES find :
      primname == name(p)

public defn ls-primitive! (primname:Symbol) :
   ls-primitive(primname) as LSPrimitive

public defn ls-primitive-type (primname:Symbol, type-args:List<LSType>) :
   val p = ls-primitive!(primname)
   if length(targs(p)) == length(type-args) :
      val env = map(KeyValue, targs(p), type-args)
      FnT(
         map(sub{_, env}, a(p))
         NoneT()
         sub(b(p), env))
   else : NoneT()