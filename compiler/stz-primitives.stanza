defpackage stz/primitives :
   import core
   import verse
   import stz/tl-ir
   import stz/kl-ir
   import stz/utils

public defstruct LSPrimitive :
   name: Symbol
with:
   constructor => #LSPrimitive
   
public val LS-PRIMITIVES = Vector<LSPrimitive>()
defn LSPrimitive (name:Symbol) :
   val p = #LSPrimitive(name)
   add(LS-PRIMITIVES, p)
   p

defmethod equal? (a:LSPrimitive, b:LSPrimitive) :
   name(a) == name(b)

defmethod print (o:OutputStream, p:LSPrimitive) :
   print(o, name(p))

public val GET-HEAP-OP = LSPrimitive(`heap)
public val SET-HEAP-OP = LSPrimitive(`set-heap)
public val GET-HEAP-LIM-OP = LSPrimitive(`heap-limit)
public val SET-HEAP-LIM-OP = LSPrimitive(`set-heap-limit)
public val ADD-OP = LSPrimitive(`add)
public val SUB-OP = LSPrimitive(`sub)
public val MUL-OP = LSPrimitive(`mul)
public val DIV-OP = LSPrimitive(`div)
public val MOD-OP = LSPrimitive(`mod)
public val AND-OP = LSPrimitive(`and)
public val OR-OP = LSPrimitive(`or)
public val XOR-OP = LSPrimitive(`xor)
public val SHL-OP = LSPrimitive(`shl)
public val SHR-OP = LSPrimitive(`shr)
public val ASHR-OP = LSPrimitive(`ashr)
public val EQ-OP = LSPrimitive(`eq)
public val NE-OP = LSPrimitive(`ne)
public val LT-OP = LSPrimitive(`lt)
public val GT-OP = LSPrimitive(`gt)
public val LE-OP = LSPrimitive(`le)
public val GE-OP = LSPrimitive(`ge)
public val ULT-OP = LSPrimitive(`ult)
public val UGT-OP = LSPrimitive(`ugt)
public val ULE-OP = LSPrimitive(`ule)
public val UGE-OP = LSPrimitive(`uge)

public defn ls-primitive? (primname:Symbol) :
   ls-primitive(primname) != false

public defn ls-primitive (primname:Symbol) :
   for p in LS-PRIMITIVES find :
      primname == name(p)

public defn ls-primitive! (primname:Symbol) :
   ls-primitive(primname) as LSPrimitive