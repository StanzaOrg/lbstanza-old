defpackage stz/type-fill :
  import core
  import collections
  import stz/types
  import stz/type-equation-solver
  import stz/tl-ir2
  import stz/type-match
  import stz/type-instfns

;============================================================
;===================== Fill Solution ========================
;============================================================

;Fill the computed solutions in the Solver into the program.
public defn fill-solution (prog:TProg, solns:SolverState) -> TProg :
  val new-packages = for package in packages(prog) map :
    fill-solution(package, solns)
  sub-packages(prog, new-packages)

;Fill all the solutions in the package commands.
public defn fill-solution (package:TPackage, solns:SolverState) -> TPackage :
  val new-comms = for comm in comms(package) map :
    fill-comm(comm, solns, List())
  sub-comms(package, new-comms)

;============================================================
;================== Detailed Substitution ===================
;============================================================

;Fill the solved types in the given top-level command.
defn fill-comm (comm:TComm, soln:SolverState, scope:List<Int>) -> TComm :
  match(comm) :
    (comm:TDefType) :
      comm
    (comm:TDef) :
      val new-type = fill-type!(type(comm), soln)
      val new-value = fill-exp(value(comm), soln, List())
      println("CHECK TYPE OF VALUE.")
      TDef(info(comm), n(comm), new-type, new-value)
    (comm:TDefTuple) :
      val new-types = fill-types!(types(comm), soln)
      val new-value = fill-exp(value(comm), soln, List())
      println("CHECK TYPE OF VALUE.")
      TDefTuple(info(comm), ns(comm), new-types, new-value)
    (comm:TDefVar) :
      val new-type = fill-type!(type(comm), soln)
      val new-value = fill-exp?(value(comm), soln, List())
      println("CHECK TYPE OF VALUE.")
      println("CHECK SCOPE OF TYPE.")
      TDefVar(info(comm), n(comm), new-type, new-value)
    (comm:TDefn) :
      val tvars = to-list $ cat(targs(comm), cargs(comm))
      val new-a2 = fill-type!(a2(comm), soln)
      val new-body = fill-exp(body(comm), soln, tvars)
      println("CHECK TYPE OF BODY")
      TDefn(info(comm), tail?(comm), n(comm), targs(comm), cargs(comm),
            a1(comm), new-a2, args(comm), new-body)
    (comm:TDefmulti) :
      comm
    (comm:TDefmethod) :
      fill-method(comm, None(), soln, scope)
    (comm:TInit) :
      val new-exp = fill-exp(exp(comm), soln, List())
      TInit(info(comm), new-exp)
    (comm:TLDefType) :
      comm
    (comm:TLDef) :
      val new-value = fill-ls-exp(value(comm), soln, List())
      println("CHECK VALUE TYPE")
      TLDef(info(comm), n(comm), type(comm), new-value)
    (comm:TLDefVar) :
      val new-value = fill-ls-exp?(value(comm), soln, List())
      println("CHECK VALUE TYPE")
      println("CHECK SCOPE OF TYPE")
      TLDefVar(info(comm), n(comm), type(comm), new-value)
    (comm:TLDefn) :
      val tvars = to-list $ cat(targs(comm), cargs(comm))
      val new-body = fill-ls-comm(body(comm), soln, tvars)
      println("CHECK BODY RETURN")
      TLDefn(info(comm), tail?(comm), n(comm), targs(comm), cargs(comm), a1(comm), a2(comm), args(comm), new-body)
    (comm:TLExternFn) :
      val new-body = fill-ls-comm(body(comm), soln, List())
      println("CHECK BODY RETURN")
      TLExternFn(info(comm), n(comm), a1(comm), a2(comm), args(comm), new-body, lbl(comm))
    (comm:TLDefmethod) :
      val tvars = to-list $ cat(targs(comm), cargs(comm))
      val new-body = fill-ls-comm(body(comm), soln, tvars)
      println("CHECK BODY RETURN")
      TLDefmethod(info(comm), tail?(comm), n(comm), multi(comm), targs(comm), cargs(comm),
                  a1(comm), a2(comm), args(comm), new-body)
    (comm:TExtern) :
      comm
    (comm:TLInit) :
      val new-comm = fill-ls-comm(/comm(comm), soln, List())
      TLInit(info(comm), new-comm)
    (comm:TDoc) :
      comm

;Fill the solved types in the given expression.
defn fill-exp (e:TExp, soln:SolverState, scope:List<Int>) -> TExp :
  match(fill-exp-common(e, soln)) :
    (e:TLet) :
      val new-ntype = fill-type!(ntype(e), soln)
      val new-value = fill-exp(value(e), soln, scope)
      val new-body = fill-exp(body(e), soln, scope)
      println("CHECK TYPE OF VALUE")
      TLet(info(e), type(e), ctxt(e), n(e), new-ntype, new-value, new-body)
    (e:TLetVar) :
      val new-ntype = fill-type!(ntype(e), soln)
      val new-value = fill-exp?(value(e), soln, scope)
      val new-body = fill-exp(body(e), soln, scope)
      println("CHECK TYPE OF VALUE")
      println("CHECK SCOPE OF TYPE")
      println("CHECK INFERENCE OF TYPE")
      TLetVar(info(e), type(e), ctxt(e), n(e), new-ntype, new-value, new-body)
    (e:TLetTuple) :
      val new-ntypes = fill-types!(ntypes(e), soln)
      val new-value = fill-exp(value(e), soln, scope)
      val new-body = fill-exp(body(e), soln, scope)
      println("CHECK GOOD VALUE TYPE")
      println("CHECK INFERENCE OF TYPES")
      TLetTuple(info(e), type(e), ctxt(e), ns(e), new-ntypes, new-value, new-body)
    (e:TLetRec) :
      val new-defns = fill-comms(defns(e), soln, scope) as Tuple<TDefn>
      val new-body = fill-exp(body(e), soln, scope)
      TLetRec(info(e), type(e), ctxt(e), new-defns, new-body)
    (e:TFn) :
      val new-a1 = fill-types!(a1(e), soln)
      val new-a2 = fill-type!(a2(e), soln)
      val new-body = fill-exp(body(e), soln, scope)
      println("CHECK ARG INFERENCE")
      println("CHECK RETURN INFERENCE")
      println("CHECK BODY TYPE")
      TFn(info(e), type(e), ctxt(e), tail?(e), new-a1, new-a2, args(e), new-body)
    (e:TMulti) :
      val new-funcs = fill-exps(funcs(e), soln, scope) as Tuple<TFn>
      TMulti(info(e), type(e), ctxt(e), new-funcs)
    (e:TSeq) :
      val new-a = fill-exp(a(e), soln, scope)
      val new-b = fill-exp(b(e), soln, scope)
      TSeq(info(e), type(e), ctxt(e), new-a, new-b)
    (e:TMatch) :
      val new-args = fill-exps(args(e), soln, scope)
      val new-branches = fill-exps(branches(e), soln, scope) as Tuple<TBranch>
      println("CHECK BRANCH ARGUMENT TYPES")
      TMatch(info(e), type(e), ctxt(e), new-args, new-branches)
    (e:TBranch) :
      val new-atypes = fill-types!(atypes(e), soln)
      val new-body = fill-exp(body(e), soln, scope)
      TBranch(info(e), type(e), ctxt(e), args(e), new-atypes, new-body)
    (e:TNew) :
      val new-methods = fill-methods(methods(e), One(class(e)), soln, scope)
      TNew(info(e), type(e), ctxt(e), class(e), new-methods)
    (e:TRef) :
      e
    (e:TCast) :
      val new-exp = fill-exp(exp(e), soln, scope)
      println("CHECK GOOD CAST")
      TCast(info(e), type(e), ctxt(e), new-exp, targ(e))
    (e:TUpCast) :
      val new-exp = fill-exp(exp(e), soln, scope)
      println("CHECK GOOD CAST")
      TUpCast(info(e), type(e), ctxt(e), new-exp, targ(e))
    (e:TSet) :
      val new-ref = fill-exp(ref(e), soln, scope) as TRef
      val new-value = fill-exp(value(e), soln, scope)
      println("CHECK VALUE TYPE")
      TSet(info(e), type(e), ctxt(e), new-ref, new-value)
    (e:TDo) :
      val new-func = fill-exp(func(e), soln, scope)
      val new-args = fill-args(args(e), soln, scope)
      println("CHECK LEGAL CALL")
      TDo(info(e), type(e), ctxt(e), new-func, targs(e), new-args)
    (e:TPrim) :
      val new-args = fill-exps(args(e), soln, scope)
      println("CHECK LEGAL PRIMITIVE")
      TPrim(info(e), type(e), ctxt(e), op(e), new-args)
    (e:TLiteral) :
      e
    (e:TTupleExp) :
      val new-exps = fill-exps(exps(e), soln, scope)
      TTupleExp(info(e), type(e), ctxt(e), new-exps)
    (e:TMix) :
      val new-sel = fill-sel(sel(e) as Selection, soln)
      val new-inst = fill-inst(inst(e) as Instantiation, soln)
      val [pruned-sel, pruned-inst] = select(new-sel, new-inst)
      val new-refs = match(instantiated(refs(e), pruned-inst)) :
        (refs:Tuple<TRef>) : fill-exps(refs, soln, scope) as Tuple<TRef>
        (f:False) : refs(e)
      println("CHECK VALID MIX")
      TMix(info(e), type(e), ctxt(e), new-refs, pruned-sel, pruned-inst)

;Fill the solved types in the given command.
defn fill-ls-comm (comm:LSComm, soln:SolverState, scope:List<Int>) -> LSComm :
  match(comm) :
    (comm:LSCall) :
      ;(exp:LSExp)
      fatal("fill-ls-comm LSCall")
    (comm:LSSet) :
      ;(exp:LSExp, value:LSExp)
      fatal("fill-ls-comm LSSet")
    (comm:LSLabels) :
      ;(blocks:Tuple<LSLabeledBlock>)
      fatal("fill-ls-comm LSLabels")
    (comm:LSLabeledBlock) :
      ;(n:Int, args:Tuple<Int>, atypes:Tuple<LSType>, body:LSComm)
      fatal("fill-ls-comm LSLabeledBlock")
    (comm:LSGoto) :
      ;(n:Int, args:Tuple<LSExp>)
      fatal("fill-ls-comm LSGoto")
    (comm:LSReturn) :
      ;(exp:LSExp)
      fatal("fill-ls-comm LSReturn")
    (comm:LSDef) :
      ;(n:Int, type:False|LSType, value:LSExp)
      fatal("fill-ls-comm LSDef")
    (comm:LSDefVar) :
      ;(n:Int, type:LSType, value:False|LSExp)
      fatal("fill-ls-comm LSDefVar")
    (comm:LSSeq) :
      ;(a:LSComm, b:LSComm)
      fatal("fill-ls-comm LSSeq")
    (comm:LSIf) :
      ;(pred:LSExp, conseq:LSComm, alt:LSComm)
      fatal("fill-ls-comm LSIf")
    (comm:LSMatch) :
      ;(args:Tuple<LSExp>, branches:Tuple<LSBranch>)
      fatal("fill-ls-comm LSMatch")
    (comm:LSBranch) :
      ;(args:Tuple<Int>, atypes:Tuple<False|LSType>, body:LSComm)
      fatal("fill-ls-comm LSBranch")
    (comm:LSSkip) :
      ;()
      fatal("fill-ls-comm LSSkip")

;Fill the solved types in the given expression.
defn fill-ls-exp (exp:LSExp, soln:SolverState, scope:List<Int>) -> LSExp :
  match(exp) :
    (e:LSVar) :
      ;(n:Int)
      fatal("fill-ls-exp LSVar")
    (e:LSNew) :
      ;(n:Int, targs:Tuple<Type>, args:Tuple<LSExp>)
      fatal("fill-ls-exp LSNew")
    (e:LSStruct) :
      ;(n:Int, targs:Tuple<Type>, args:Tuple<LSExp>)
      fatal("fill-ls-exp LSStruct")
    (e:LSAddr) :
      ;(exp:LSExp, unstable?:True|False)
      fatal("fill-ls-exp LSAddr")
    (e:LSDeref) :
      ;(exp:LSExp)
      fatal("fill-ls-exp LSDeref")
    (e:LSSlot) :
      ;(exp:LSExp, index:LSExp)
      fatal("fill-ls-exp LSSlot")
    (e:LSField) :
      ;(exp:LSExp, name:Symbol)
      fatal("fill-ls-exp LSField")
    (e:LSDo) :
      ;(func:LSExp, targs:Tuple<Type>, args:Tuple<LSArg>)
      fatal("fill-ls-exp LSDo")
    (e:LSCallC) :
      ;(func:LSExp, args:Tuple<LSArg>)
      fatal("fill-ls-exp LSCallC")
    (e:LSPrim) :
      ;(op:LSPrimitive, args:Tuple<LSExp>)
      fatal("fill-ls-exp LSPrim")
    (e:LSSizeof) :
      ;(targ:LSType)
      fatal("fill-ls-exp LSSizeof")
    (e:LSTagof) :
      ;(n:Int)
      fatal("fill-ls-exp LSTagof")
    (e:LSCast) :
      ;(exp:LSExp, targ:LSType)
      fatal("fill-ls-exp LSCast")
    (e:LSLiteral) :
      ;(value:?)
      fatal("fill-ls-exp LSLiteral")
    (e:LSAnd) :
      ;(a:LSExp, b:LSExp)
      fatal("fill-ls-exp LSAnd")
    (e:LSOr) :
      ;(a:LSExp, b:LSExp)
      fatal("fill-ls-exp LSOr")
    (e:LSLetExp) :
      ;(comm:LSComm, exp:LSExp)
      fatal("fill-ls-exp LSLetExp")
    (e:LSMix) :
      ;(refs:Tuple<LSVar>, sel:False|Selection, inst:False|LSInstantiation)
      fatal("fill-ls-exp LSMix")
    (e:LSFn) :
      ;(ref:TExp)
      fatal("fill-ls-exp LSFn")

;Fill the solution for the given method.
defn fill-method (m:TDefmethod, thist:Maybe<Type>, soln:SolverState, scope:List<Int>) -> TDefmethod :
  val new-multi = fatal("fill-multi")
  val tvars = to-list $ cat(targs(m), cargs(m))
  val new-a2 = fill-type!(a2(m), soln)
  val new-body = fill-exp(body(m), soln, tvars)
  println("CHECK MULTI RESOLVED")
  println("CHECK SUBMETHOD")
  println("CHECK TYPE OF BODY")
  println("CHECK VALID THIS TYPE.")
  TDefmethod(info(m), tail?(m), n(m), multi(m), thisn(m), targs(m), cargs(m),
             a1(m), new-a2, args(m), new-body)

;Fill only the common fields of the given expression.
;Currently, the 'type' and the 'ctxt'.
defn fill-exp-common (e:TExp, soln:SolverState) -> TExp :
  val new-type = fill-type!(type(e), soln)
  val new-ctxt = fill-ctxt(ctxt(e) as Context, soln)
  e $> sub-type{_, new-type}
    $> sub-ctxt{_, new-ctxt}

;Fill the solved types with the solutions.
;Any unsolved variables remain as TUVar and UVarT.
defn fill-type-lstype (t:Type|LSType, soln:SolverState) -> Type|LSType :
  match(t:TUVar|UVarT) :
    match(soln[n(t)]) :
      (t:SolvedType) : value(t) as Type|LSType
      (v) : t
  else :
    map-lstype(fill-type-lstype{_, soln}, t)

;Fill the given context with the solutions.
defn fill-ctxt (ctxt:Context, soln:SolverState) -> Context :
  val result = let loop (item:TLItem = ctxt) :
    match(item:Type) : fill-type!(item, soln)
    else : map(loop, item)
  result as Context

;Fill the given Selection with the values.
defn fill-sel (s:Selection, soln:SolverState) -> Selection :
  match(s:SVar) :
    match(soln[n(s)]) :
      (x:SolvedSel) :
        if all?({_ is True|False|PartialMatch}, values(x)) :
          SSel(values(x) as Tuple<True|False|PartialMatch>)
        else : s
      (x) : s
  else : s

;Fill the given instantiation with the solved values.
defn fill-inst (i:Instantiation, soln:SolverState) -> Instantiation :
  match(i:InstVar) :
    match(soln[n(i)]) :
      (x:SolvedInstantiation) : InstFns(funcs(x))
      (x) : i
  else : i

;Select the chosen instantiations.
defn select (s:Selection, i:Instantiation) -> [Selection, Instantiation] :
  match(s:SSel, i:InstFns) :
    ;Sanity check.
    if length(sels(s)) != length(funcs(i)) :
      fatal("Mismatch between selection and instantiation.")

    ;Prune the false matches from the instantiation.
    val new-sels = Vector<True|PartialMatch>()
    val new-funcs = Vector<InstFn>()
    for (s in sels(s), f in funcs(i)) do :
      match(s:True|PartialMatch) :
        add(new-sels,s)
        add(new-funcs,f)
        
    ;Return the new selection and insts
    [SSel(to-tuple(new-sels)), InstFns(to-tuple(new-funcs))]
  else :
    [s, i]

;Return the set of TRef that is actually instantiated.
;If instantiation is unsolved, then just return original TRef tuple.
defn instantiated (rs:Tuple<TRef>, i:Instantiation) -> Tuple<TRef>|False :
  match(i:InstFns) :
    val ns = to-intset(seq(n, funcs(i)))
    to-tuple $ for r in rs filter :
      ns[n(r)]

;============================================================
;================= Convenience Fillers ======================
;============================================================

;Type-casted versions of fill-type-lstype.
defn fill-type! (t:Type|False, soln:SolverState) -> Type :
  fill-type-lstype(t as Type, soln) as Type
defn fill-lstype! (t:LSType|False, soln:SolverState) -> LSType :
  fill-type-lstype(t as LSType, soln) as LSType

;Fill a function argument.
defn fill-arg (a:TArg, soln:SolverState, scope:List<Int>) -> TArg :
  TArg(keyword(a), fill-exp(value(a), soln, scope))
defn fill-arg (a:LSArg, soln:SolverState, scope:List<Int>) -> LSArg :
  LSArg(keyword(a), fill-ls-exp(value(a), soln, scope))

;Fill multiple function arguments.
defn fill-args (xs:Tuple<TArg>, soln:SolverState, scope:List<Int>) -> Tuple<TArg> :
  map(fill-arg{_, soln, scope}, xs)
defn fill-args (xs:Tuple<LSArg>, soln:SolverState, scope:List<Int>) -> Tuple<LSArg> :
  map(fill-arg{_, soln, scope}, xs)

;Fill multiple commands
defn fill-comms (cs:Tuple<TComm>, soln:SolverState, scope:List<Int>) -> Tuple<TComm> :
  map(fill-comm{_, soln, scope}, cs)

;Fill multiple types.
defn fill-types! (ts:Tuple<Type|False>, soln:SolverState) -> Tuple<Type> :
  map(fill-type!{_, soln}, ts)

;Fill an optional expression.
defn fill-exp? (e:TExp|False, soln:SolverState, scope:List<Int>) -> TExp|False :
  match(e:TExp) :
    fill-exp(e, soln, scope)

;Fill multiple expressions.
defn fill-exps (es:Tuple<TExp>, soln:SolverState, scope:List<Int>) -> Tuple<TExp> :
  map(fill-exp{_, soln, scope}, es)

;Fill an optional Lostanza expression.
defn fill-ls-exp? (e:LSExp|False, soln:SolverState, scope:List<Int>) -> LSExp|False :
  match(e:LSExp) :
    fill-ls-exp(e, soln, scope)

;Fill multiple methods.
defn fill-methods (ms:Tuple<TDefmethod>, thist:Maybe<Type>,
                   soln:SolverState, scope:List<Int>) -> Tuple<TDefmethod> :
  map(fill-method{_, thist, soln, scope}, ms)