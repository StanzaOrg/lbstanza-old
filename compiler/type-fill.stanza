defpackage stz/type-fill :
  import core
  import collections
  import stz/types
  import stz/type-equation-solver
  import stz/tl-ir2

;============================================================
;===================== Fill Solution ========================
;============================================================

;Fill the computed solutions in the Solver into the program.
public defn fill-solution (prog:TProg, solns:SolverState) -> TProg :
  val new-packages = for package in packages(prog) map :
    fill-solution(package, solns)
  sub-packages(prog, new-packages)

;Fill all the solutions in the package commands.
public defn fill-solution (package:TPackage, solns:SolverState) -> TPackage :
  val new-comms = for comm in comms(package) map :
    fill-comm(comm, solns)
  sub-comms(package, new-comms)

;============================================================
;================== Detailed Substitution ===================
;============================================================

;Fill the solved types in the given top-level command.
defn fill-comm (comm:TComm, soln:SolverState) -> TComm :
  match(comm) :
    (comm:TDefType) :
      comm
    (comm:TDef) :
      val new-type = fill-type(type(comm) as Type, soln, List())
      val new-value = fill-exp(value(comm), soln, List())
      fatal("CHECK TYPE OF VALUE.")
      TDef(info(comm), n(comm), new-type, new-value)
    (comm:TDefTuple) :
      val new-types = fill-types(types(comm) as Tuple<Type>, soln, List())
      val new-value = fill-exp(value(comm), soln, List())
      fatal("CHECK TYPE OF VALUE.")
      TDefTuple(info(comm), ns(comm), new-types, new-value)
    (comm:TDefVar) :
      val new-type = fill-type(type(comm) as Type, soln, List())
      val new-value = fill-exp?(value(comm), soln, List())
      fatal("CHECK TYPE OF VALUE.")
      fatal("CHECK SCOPE OF TYPE.")
      TDefVar(info(comm), n(comm), new-type, new-value)
    (comm:TDefn) :
      val tvars = to-list $ cat(targs(comm), cargs(comm))
      val new-a2 = fill-type(a2(comm) as Type, soln, tvars)
      val new-body = fill-exp(body(comm), soln, tvars)
      fatal("CHECK TYPE OF BODY")
      TDefn(info(comm), tail?(comm), n(comm), targs(comm), cargs(comm),
            a1(comm), new-a2, args(comm), new-body)
    (comm:TDefmulti) :
      comm
    (comm:TDefmethod) :
      val new-multi = fatal("fill-multi")
      val tvars = to-list $ cat(targs(comm), cargs(comm))
      val new-a2 = fill-type(a2(comm) as Type, soln, tvars)
      val new-body = fill-exp(body(comm), soln, tvars)
      fatal("CHECK MULTI RESOLVED")
      fatal("CHECK SUBMETHOD")
      fatal("CHECK TYPE OF BODY")
      TDefmethod(info(comm), tail?(comm), n(comm), multi(comm), thisn(comm), targs(comm), cargs(comm),
                 a1(comm), new-a2, args(comm), new-body)
    (comm:TInit) :
      val new-exp = fill-exp(exp(comm), soln, List())
      TInit(info(comm), new-exp)
    (comm:TLDefType) :
      comm
    (comm:TLDef) :
      val new-value = fill-ls-exp(value(comm), soln, List())
      fatal("CHECK VALUE TYPE")
      TLDef(info(comm), n(comm), type(comm), new-value)
    (comm:TLDefVar) :
      val new-value = fill-ls-exp?(value(comm), soln, List())
      fatal("CHECK VALUE TYPE")
      TLDefVar(info(comm), n(comm), type(comm), new-value)
    (comm:TLDefn) :
      val tvars = to-list $ cat(targs(comm), cargs(comm))
      val new-body = fill-ls-comm(body(comm), soln, tvars)
      fatal("CHECK BODY RETURN")
      TLDefn(info(comm), tail?(comm), n(comm), targs(comm), cargs(comm), a1(comm), a2(comm), args(comm), new-body)
    (comm:TLExternFn) :
      val new-body = fill-ls-comm(body(comm), soln, List())
      fatal("CHECK BODY RETURN")
      TLExternFn(info(comm), n(comm), a1(comm), a2(comm), args(comm), new-body, lbl(comm))
    (comm:TLDefmethod) :
      val tvars = to-list $ cat(targs(comm), cargs(comm))
      val new-body = fill-ls-comm(body(comm), soln, tvars)
      fatal("CHECK BODY RETURN")
      TLDefmethod(info(comm), tail?(comm), n(comm), multi(comm), targs(comm), cargs(comm),
                  a1(comm), a2(comm), args(comm), new-body)
    (comm:TExtern) :
      comm
    (comm:TLInit) :
      val new-comm = fill-ls-comm(/comm(comm), soln, List())
      TLInit(info(comm), new-comm)
    (comm:TDoc) :
      comm

defn fill-exp (exp:TExp, soln:SolverState, scope:List<Int>) -> TExp :
  fatal("Fill-exp")

defn fill-ls-comm (comm:LSComm, soln:SolverState, scope:List<Int>) -> LSComm :
  fatal("Fill LSComm")

defn fill-ls-exp (exp:LSExp, soln:SolverState, scope:List<Int>) -> LSExp :
  fatal("Fill LSExp")

defn fill-type (t:Type, soln:SolverState, scope:List<Int>) -> Type :
  fatal("Fill type")

;============================================================
;================= Convenience Fillers ======================
;============================================================

defn fill-types (ts:Tuple<Type>, soln:SolverState, scope:List<Int>) -> Tuple<Type> :
  fatal("Not yet implemented")

defn fill-exp? (e:TExp|False, soln:SolverState, scope:List<Int>) -> TExp|False :
  match(e:TExp) :
    fill-exp(e, soln, scope)

defn fill-ls-exp? (e:LSExp|False, soln:SolverState, scope:List<Int>) -> LSExp|False :
  match(e:LSExp) :
    fill-ls-exp(e, soln, scope)