defpackage stz/type-fill :
  import core
  import collections
  import stz/types
  import stz/type-equation-solver
  import stz/tl-ir2

;============================================================
;===================== Fill Solution ========================
;============================================================

;Fill the computed solutions in the Solver into the program.
public defn fill-solution (prog:TProg, solns:SolverState) -> TProg :
  val new-packages = for package in packages(prog) map :
    fill-solution(package, solns)
  sub-packages(prog, new-packages)

;Fill all the solutions in the package commands.
public defn fill-solution (package:TPackage, solns:SolverState) -> TPackage :
  val new-comms = for comm in comms(package) map :
    fill-comm(comm, solns)
  sub-comms(package, new-comms)

;============================================================
;================== Detailed Substitution ===================
;============================================================

;Fill the solved types in the given top-level command.
defn fill-comm (comm:TComm, soln:SolverState) -> TComm :
  match(comm) :
    (comm:TDefType) :
      comm
    (comm:TDef) :
      val new-type = fill-type(type(comm) as Type, soln, List())
      val new-value = fill-exp(value(comm), soln, List())
      fatal("CHECK TYPE OF VALUE.")
      TDef(info(comm), n(comm), new-type, new-value)
    (comm:TDefTuple) :
      val new-types = fill-types(types(comm) as Tuple<Type>, soln, List())
      val new-value = fill-exp(value(comm), soln, List())
      fatal("CHECK TYPE OF VALUE.")
      TDefTuple(info(comm), ns(comm), new-types, new-value)
    (comm:TDefVar) :
      val new-type = fill-type(type(comm) as Type, soln, List())
      val new-value = fill-exp?(value(comm), soln, List())
      fatal("CHECK TYPE OF VALUE.")
      fatal("CHECK SCOPE OF TYPE.")
      TDefVar(info(comm), n(comm), new-type, new-value)
    (comm:TDefn) :
      val tvars = to-list $ cat(targs(comm), cargs(comm))
      val new-a2 = fill-type(a2(comm) as Type, soln, tvars)
      val new-body = fill-exp(body(comm), soln, tvars)
      fatal("CHECK TYPE OF BODY")
      TDefn(info(comm), tail?(comm), n(comm), targs(comm), cargs(comm),
            a1(comm), new-a2, args(comm), new-body)
    (comm:TDefmulti) :
      comm
    (comm:TDefmethod) :
      val new-multi = fatal("fill-multi")
      val tvars = to-list $ cat(targs(comm), cargs(comm))
      val new-a2 = fill-type(a2(comm) as Type, soln, tvars)
      val new-body = fill-exp(body(comm), soln, tvars)
      fatal("CHECK MULTI RESOLVED")
      fatal("CHECK SUBMETHOD")
      fatal("CHECK TYPE OF BODY")
      TDefmethod(info(comm), tail?(comm), n(comm), multi(comm), thisn(comm), targs(comm), cargs(comm),
                 a1(comm), new-a2, args(comm), new-body)
    (comm:TInit) :
      val new-exp = fill-exp(exp(comm), soln, List())
      TInit(info(comm), new-exp)
    (comm:TLDefType) :
      comm
    (comm:TLDef) :
      val new-value = fill-ls-exp(value(comm), soln, List())
      fatal("CHECK VALUE TYPE")
      TLDef(info(comm), n(comm), type(comm), new-value)
    (comm:TLDefVar) :
      val new-value = fill-ls-exp?(value(comm), soln, List())
      fatal("CHECK VALUE TYPE")
      fatal("CHECK SCOPE OF TYPE")
      TLDefVar(info(comm), n(comm), type(comm), new-value)
    (comm:TLDefn) :
      val tvars = to-list $ cat(targs(comm), cargs(comm))
      val new-body = fill-ls-comm(body(comm), soln, tvars)
      fatal("CHECK BODY RETURN")
      TLDefn(info(comm), tail?(comm), n(comm), targs(comm), cargs(comm), a1(comm), a2(comm), args(comm), new-body)
    (comm:TLExternFn) :
      val new-body = fill-ls-comm(body(comm), soln, List())
      fatal("CHECK BODY RETURN")
      TLExternFn(info(comm), n(comm), a1(comm), a2(comm), args(comm), new-body, lbl(comm))
    (comm:TLDefmethod) :
      val tvars = to-list $ cat(targs(comm), cargs(comm))
      val new-body = fill-ls-comm(body(comm), soln, tvars)
      fatal("CHECK BODY RETURN")
      TLDefmethod(info(comm), tail?(comm), n(comm), multi(comm), targs(comm), cargs(comm),
                  a1(comm), a2(comm), args(comm), new-body)
    (comm:TExtern) :
      comm
    (comm:TLInit) :
      val new-comm = fill-ls-comm(/comm(comm), soln, List())
      TLInit(info(comm), new-comm)
    (comm:TDoc) :
      comm

;Fill the solved types in the given expression.
defn fill-exp (exp:TExp, soln:SolverState, scope:List<Int>) -> TExp :
  match(exp) :
    (e:TLet) :
      ;(n:Int, ntype:False|Type, value:TExp, body:TExp)
      fatal("fill-exp TLet")
    (e:TLetVar) :
      ;(n:Int, ntype:False|Type, value:False|TExp, body:TExp)
      fatal("fill-exp TLetVar")
    (e:TLetTuple) :
      ;(ns:Tuple<Int>, ntypes:Tuple<False|Type>, value:TExp, body:TExp)
      fatal("fill-exp TLetTuple")
    (e:TLetRec) :
      ;(defns:Tuple<TDefn>, body:TExp)
      fatal("fill-exp TLetRec")
    (e:TFn) :
      ;(tail?:True|False, a1:Tuple<False|Type>, a2:False|Type, args:Tuple<Int>, body:TExp)
      fatal("fill-exp TFn")
    (e:TMulti) :
      ;(funcs:Tuple<TFn>)
      fatal("fill-exp TMulti")
    (e:TSeq) :
      ;(a:TExp, b:TExp)
      fatal("fill-exp TSeq")
    (e:TMatch) :
      ;(args:Tuple<TExp>, branches:Tuple<TBranch>)
      fatal("fill-exp TMatch")
    (e:TBranch) :
      ;(args:Tuple<Int>, atypes:Tuple<False|Type>, body:TExp)
      fatal("fill-exp TBranch")
    (e:TNew) :
      ;(class:Type, methods:Tuple<TDefmethod>)
      fatal("fill-exp TNew")
    (e:TRef) :
      ;(n:Int)
      fatal("fill-exp TRef")
    (e:TCast) :
      ;(exp:TExp, targ:Type)
      fatal("fill-exp TCast")
    (e:TUpCast) :
      ;(exp:TExp, targ:Type)
      fatal("fill-exp TUpCast")
    (e:TSet) :
      ;(ref:TRef, value:TExp)
      fatal("fill-exp TSet")
    (e:TDo) :
      ;(func:TExp, targs:Tuple<Type>, args:Tuple<TArg>)
      fatal("fill-exp TDo")
    (e:TPrim) :
      ;(op:Primitive, args:Tuple<TExp>)
      fatal("fill-exp TPrim")
    (e:TLiteral) :
      ;(value:?)
      fatal("fill-exp TLiteral")
    (e:TTupleExp) :
      ;(exps:Tuple<TExp>)
      fatal("fill-exp TTupleExp")
    (e:TMix) :
      ;(refs:Tuple<TRef>, sel:False|Selection, inst:False|Instantiation)
      fatal("fill-exp TMix")

;Fill the solved types in the given command.
defn fill-ls-comm (comm:LSComm, soln:SolverState, scope:List<Int>) -> LSComm :
  match(comm) :
    (comm:LSCall) :
      ;(exp:LSExp)
      fatal("fill-ls-comm LSCall")
    (comm:LSSet) :
      ;(exp:LSExp, value:LSExp)
      fatal("fill-ls-comm LSSet")
    (comm:LSLabels) :
      ;(blocks:Tuple<LSLabeledBlock>)
      fatal("fill-ls-comm LSLabels")
    (comm:LSLabeledBlock) :
      ;(n:Int, args:Tuple<Int>, atypes:Tuple<LSType>, body:LSComm)
      fatal("fill-ls-comm LSLabeledBlock")
    (comm:LSGoto) :
      ;(n:Int, args:Tuple<LSExp>)
      fatal("fill-ls-comm LSGoto")
    (comm:LSReturn) :
      ;(exp:LSExp)
      fatal("fill-ls-comm LSReturn")
    (comm:LSDef) :
      ;(n:Int, type:False|LSType, value:LSExp)
      fatal("fill-ls-comm LSDef")
    (comm:LSDefVar) :
      ;(n:Int, type:LSType, value:False|LSExp)
      fatal("fill-ls-comm LSDefVar")
    (comm:LSSeq) :
      ;(a:LSComm, b:LSComm)
      fatal("fill-ls-comm LSSeq")
    (comm:LSIf) :
      ;(pred:LSExp, conseq:LSComm, alt:LSComm)
      fatal("fill-ls-comm LSIf")
    (comm:LSMatch) :
      ;(args:Tuple<LSExp>, branches:Tuple<LSBranch>)
      fatal("fill-ls-comm LSMatch")
    (comm:LSBranch) :
      ;(args:Tuple<Int>, atypes:Tuple<False|LSType>, body:LSComm)
      fatal("fill-ls-comm LSBranch")
    (comm:LSSkip) :
      ;()
      fatal("fill-ls-comm LSSkip")

;Fill the solved types in the given expression.
defn fill-ls-exp (exp:LSExp, soln:SolverState, scope:List<Int>) -> LSExp :
  match(exp) :
    (e:LSVar) :
      ;(n:Int)
      fatal("fill-ls-exp LSVar")
    (e:LSNew) :
      ;(n:Int, targs:Tuple<Type>, args:Tuple<LSExp>)
      fatal("fill-ls-exp LSNew")
    (e:LSStruct) :
      ;(n:Int, targs:Tuple<Type>, args:Tuple<LSExp>)
      fatal("fill-ls-exp LSStruct")
    (e:LSAddr) :
      ;(exp:LSExp, unstable?:True|False)
      fatal("fill-ls-exp LSAddr")
    (e:LSDeref) :
      ;(exp:LSExp)
      fatal("fill-ls-exp LSDeref")
    (e:LSSlot) :
      ;(exp:LSExp, index:LSExp)
      fatal("fill-ls-exp LSSlot")
    (e:LSField) :
      ;(exp:LSExp, name:Symbol)
      fatal("fill-ls-exp LSField")
    (e:LSDo) :
      ;(func:LSExp, targs:Tuple<Type>, args:Tuple<LSArg>)
      fatal("fill-ls-exp LSDo")
    (e:LSCallC) :
      ;(func:LSExp, args:Tuple<LSArg>)
      fatal("fill-ls-exp LSCallC")
    (e:LSPrim) :
      ;(op:LSPrimitive, args:Tuple<LSExp>)
      fatal("fill-ls-exp LSPrim")
    (e:LSSizeof) :
      ;(targ:LSType)
      fatal("fill-ls-exp LSSizeof")
    (e:LSTagof) :
      ;(n:Int)
      fatal("fill-ls-exp LSTagof")
    (e:LSCast) :
      ;(exp:LSExp, targ:LSType)
      fatal("fill-ls-exp LSCast")
    (e:LSLiteral) :
      ;(value:?)
      fatal("fill-ls-exp LSLiteral")
    (e:LSAnd) :
      ;(a:LSExp, b:LSExp)
      fatal("fill-ls-exp LSAnd")
    (e:LSOr) :
      ;(a:LSExp, b:LSExp)
      fatal("fill-ls-exp LSOr")
    (e:LSLetExp) :
      ;(comm:LSComm, exp:LSExp)
      fatal("fill-ls-exp LSLetExp")
    (e:LSMix) :
      ;(refs:Tuple<LSVar>, sel:False|Selection, inst:False|LSInstantiation)
      fatal("fill-ls-exp LSMix")
    (e:LSFn) :
      ;(ref:TExp)
      fatal("fill-ls-exp LSFn")

;Fill the solved types.
defn fill-type (t:Type, soln:SolverState, scope:List<Int>) -> Type :
  fatal("Fill type")

;============================================================
;================= Convenience Fillers ======================
;============================================================

;Fill multiple types.
defn fill-types (ts:Tuple<Type>, soln:SolverState, scope:List<Int>) -> Tuple<Type> :
  for t in ts map :
    fill-type(t, soln, scope)

;Fill an optional expression.
defn fill-exp? (e:TExp|False, soln:SolverState, scope:List<Int>) -> TExp|False :
  match(e:TExp) :
    fill-exp(e, soln, scope)

;Fill an optional Lostanza expression.
defn fill-ls-exp? (e:LSExp|False, soln:SolverState, scope:List<Int>) -> LSExp|False :
  match(e:LSExp) :
    fill-ls-exp(e, soln, scope)