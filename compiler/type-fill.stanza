defpackage stz/type-fill :
  import core
  import collections
  import stz/types
  import stz/type-equation-solver
  import stz/tl-ir2
  import stz/type-match
  import stz/type-instfns
  import stz/type-solver
  import stz/type-utils

;============================================================
;===================== Fill Solution ========================
;============================================================

;Fill the computed solutions in the Solver into the program.
public defn fill-solution (prog:TProg, solns:SolverState) -> TProg :
  val new-packages = for package in packages(prog) map :
    fill-solution(package, solns)
  sub-packages(prog, new-packages)

;Fill all the solutions in the package commands.
public defn fill-solution (package:TPackage, solns:SolverState) -> TPackage :
  val new-comms = for comm in comms(package) map :
    fill-comm(comm, solns, List())
  sub-comms(package, new-comms)

;============================================================
;================== Detailed Substitution ===================
;============================================================

;Fill the solved types in the given top-level command.
defn fill-comm (comm:TComm, soln:SolverState, scope:List<Int>) -> TComm :
  match(comm) :
    (comm:TDefType) :
      comm
    (comm:TDef) :
      val new-type = fill-type!(type(comm), soln)
      val new-value = fill-exp(value(comm), soln, scope)
      println("CHECK TYPE OF VALUE.")
      TDef(info(comm), n(comm), new-type, new-value)
    (comm:TDefTuple) :
      val new-types = fill-types!(types(comm), soln)
      val new-value = fill-exp(value(comm), soln, scope)
      println("CHECK TYPE OF VALUE.")
      TDefTuple(info(comm), ns(comm), new-types, new-value)
    (comm:TDefVar) :
      val new-type = fill-type!(type(comm), soln)
      val new-value = fill-exp?(value(comm), soln, scope)
      println("CHECK TYPE OF VALUE.")
      println("CHECK SCOPE OF TYPE.")
      TDefVar(info(comm), n(comm), new-type, new-value)
    (comm:TDefn) :
      val tvars = to-list $ cat(targs(comm), cargs(comm), scope)
      val new-a2 = fill-type!(a2(comm), soln)
      val new-body = fill-exp(body(comm), soln, tvars)
      println("CHECK TYPE OF BODY")
      TDefn(info(comm), tail?(comm), n(comm), targs(comm), cargs(comm),
            a1(comm), new-a2, args(comm), new-body)
    (comm:TDefmulti) :
      comm
    (comm:TDefmethod) :
      fill-method(comm, None(), soln, scope)
    (comm:TInit) :
      val new-exp = fill-exp(exp(comm), soln, scope)
      TInit(info(comm), new-exp)
    (comm:TLDefType) :
      comm
    (comm:TLDef) :
      val new-value = fill-ls-exp(value(comm), soln, scope)
      println("CHECK VALUE TYPE")
      TLDef(info(comm), n(comm), type(comm), new-value)
    (comm:TLDefVar) :
      val new-value = fill-ls-exp?(value(comm), soln, scope)
      println("CHECK VALUE TYPE")
      println("CHECK SCOPE OF TYPE")
      TLDefVar(info(comm), n(comm), type(comm), new-value)
    (comm:TLDefn) :
      val tvars = to-list $ cat(targs(comm), cargs(comm), scope)
      val new-body = fill-ls-comm(body(comm), soln, tvars)
      println("CHECK BODY RETURN")
      println("CHECK a2 BOUNDEDNESS")
      TLDefn(info(comm), tail?(comm), n(comm), targs(comm), cargs(comm), a1(comm), a2(comm), args(comm), new-body)
    (comm:TLExternFn) :
      val new-body = fill-ls-comm(body(comm), soln, scope)
      println("CHECK BODY RETURN")
      println("CHECK A2 BOUNDEDNESS")
      TLExternFn(info(comm), n(comm), a1(comm), a2(comm), args(comm), new-body, lbl(comm))
    (comm:TLDefmethod) :
      val new-multi = fill-multi(multi(comm) as TMix, soln)
      val tvars = to-list $ cat(targs(comm), cargs(comm), scope)
      val new-body = fill-ls-comm(body(comm), soln, tvars)
      println("CHECK BODY RETURN")
      println("CHECK a2 BOUNDEDNESS")
      TLDefmethod(info(comm), tail?(comm), n(comm), new-multi, targs(comm), cargs(comm),
                  a1(comm), a2(comm), args(comm), new-body)
    (comm:TExtern) :
      println("CHECK A2 BOUNDEDNESS")
      comm
    (comm:TLInit) :
      val new-comm = fill-ls-comm(/comm(comm), soln, scope)
      TLInit(info(comm), new-comm)
    (comm:TDoc) :
      comm

;Fill the solved types in the given expression.
defn fill-exp (e:TExp, soln:SolverState, scope:List<Int>) -> TExp :
  match(fill-exp-common(e, soln)) :
    (e:TLet) :
      val new-ntype = fill-type!(ntype(e), soln)
      val new-value = fill-exp(value(e), soln, scope)
      val new-body = fill-exp(body(e), soln, scope)
      println("CHECK TYPE OF VALUE")
      TLet(info(e), type(e), ctxt(e), n(e), new-ntype, new-value, new-body)
    (e:TLetVar) :
      val new-ntype = fill-type!(ntype(e), soln)
      val new-value = fill-exp?(value(e), soln, scope)
      val new-body = fill-exp(body(e), soln, scope)
      println("CHECK TYPE OF VALUE")
      println("CHECK SCOPE OF TYPE")
      println("CHECK INFERENCE OF TYPE")
      TLetVar(info(e), type(e), ctxt(e), n(e), new-ntype, new-value, new-body)
    (e:TLetTuple) :
      val new-ntypes = fill-types!(ntypes(e), soln)
      val new-value = fill-exp(value(e), soln, scope)
      val new-body = fill-exp(body(e), soln, scope)
      println("CHECK GOOD VALUE TYPE")
      println("CHECK INFERENCE OF TYPES")
      TLetTuple(info(e), type(e), ctxt(e), ns(e), new-ntypes, new-value, new-body)
    (e:TLetRec) :
      val new-defns = fill-comms(defns(e), soln, scope) as Tuple<TDefn>
      val new-body = fill-exp(body(e), soln, scope)
      TLetRec(info(e), type(e), ctxt(e), new-defns, new-body)
    (e:TFn) :
      val new-a1 = fill-types!(a1(e), soln)
      val new-a2 = fill-type!(a2(e), soln)
      val new-body = fill-exp(body(e), soln, scope)
      println("CHECK ARG INFERENCE")
      println("CHECK RETURN INFERENCE")
      println("CHECK BODY TYPE")
      TFn(info(e), type(e), ctxt(e), tail?(e), new-a1, new-a2, args(e), new-body)
    (e:TMulti) :
      val new-funcs = fill-exps(funcs(e), soln, scope) as Tuple<TFn>
      TMulti(info(e), type(e), ctxt(e), new-funcs)
    (e:TSeq) :
      val new-a = fill-exp(a(e), soln, scope)
      val new-b = fill-exp(b(e), soln, scope)
      TSeq(info(e), type(e), ctxt(e), new-a, new-b)
    (e:TMatch) :
      val new-args = fill-exps(args(e), soln, scope)
      val new-branches = fill-exps(branches(e), soln, scope) as Tuple<TBranch>
      println("CHECK BRANCH ARGUMENT TYPES")
      TMatch(info(e), type(e), ctxt(e), new-args, new-branches)
    (e:TBranch) :
      val new-atypes = fill-types!(atypes(e), soln)
      val new-body = fill-exp(body(e), soln, scope)
      TBranch(info(e), type(e), ctxt(e), args(e), new-atypes, new-body)
    (e:TNew) :
      val new-methods = fill-methods(methods(e), One(class(e)), soln, scope)
      TNew(info(e), type(e), ctxt(e), class(e), new-methods)
    (e:TRef) :
      e
    (e:TCast) :
      val new-exp = fill-exp(exp(e), soln, scope)
      println("CHECK GOOD CAST")
      TCast(info(e), type(e), ctxt(e), new-exp, targ(e))
    (e:TUpCast) :
      val new-exp = fill-exp(exp(e), soln, scope)
      println("CHECK GOOD CAST")
      TUpCast(info(e), type(e), ctxt(e), new-exp, targ(e))
    (e:TSet) :
      val new-ref = fill-exp(ref(e), soln, scope) as TRef
      val new-value = fill-exp(value(e), soln, scope)
      println("CHECK VALUE TYPE")
      TSet(info(e), type(e), ctxt(e), new-ref, new-value)
    (e:TDo) :
      val new-func = fill-exp(func(e), soln, scope)
      val new-args = fill-args(args(e), soln, scope)
      println("CHECK LEGAL CALL")
      TDo(info(e), type(e), ctxt(e), new-func, targs(e), new-args)
    (e:TPrim) :
      val new-args = fill-exps(args(e), soln, scope)
      println("CHECK LEGAL PRIMITIVE")
      TPrim(info(e), type(e), ctxt(e), op(e), new-args)
    (e:TLiteral) :
      e
    (e:TTupleExp) :
      val new-exps = fill-exps(exps(e), soln, scope)
      TTupleExp(info(e), type(e), ctxt(e), new-exps)
    (e:TMix) :
      val new-sel = fill-sel(sel(e) as Selection, soln)
      val new-inst = fill-inst(inst(e) as Instantiation, soln)
      val [pruned-sel, pruned-inst] = select(new-sel, new-inst)
      val new-refs = match(instantiated(refs(e), pruned-inst)) :
        (refs:Tuple<TRef>) : fill-exps(refs, soln, scope) as Tuple<TRef>
        (f:False) : refs(e)
      println("CHECK VALID MIX")
      TMix(info(e), type(e), ctxt(e), new-refs, pruned-sel, pruned-inst)

;Fill the solved types in the given command.
defn fill-ls-comm (comm:LSComm, soln:SolverState, scope:List<Int>) -> LSComm :
  match(comm) :
    (comm:LSCall) :
      val new-exp = fill-ls-exp(exp(comm), soln, scope)
      LSCall(info(comm), new-exp)
    (comm:LSSet) :
      val new-exp = fill-ls-exp(exp(comm), soln, scope)
      val new-value = fill-ls-exp(value(comm), soln, scope)
      println("CHECK TYPE OF VALUE")
      LSSet(info(comm), new-exp, new-value)
    (comm:LSLabels) :
      val new-blocks = fill-ls-comms(blocks(comm), soln, scope) as Tuple<LSLabeledBlock>
      println("Check at least one block, and first block has no arguments.")
      LSLabels(info(comm), new-blocks)
    (comm:LSLabeledBlock) :
      val new-body = fill-ls-comm(body(comm), soln, scope)
      LSLabeledBlock(info(comm), n(comm), args(comm), atypes(comm), new-body)
    (comm:LSGoto) :    
      val new-args = fill-ls-exps(args(comm), soln, scope)
      println("CHECK ARGUMENTS OF GOTO")
      LSGoto(info(comm), n(comm), new-args)
    (comm:LSReturn) :
      val new-exp = fill-ls-exp(exp(comm), soln, scope)
      println("CHECK RETURN TYPE")
      LSReturn(info(comm), new-exp)
    (comm:LSDef) :
      val new-type = fill-ls-type!(type(comm), soln)
      val new-value = fill-ls-exp(value(comm), soln, scope)
      println("CHECK INFERENCE")
      println("CHECK TYPE OF VALUE")
      LSDef(info(comm), n(comm), new-type, new-value)
    (comm:LSDefVar) :
      val new-value = fill-ls-exp?(value(comm), soln, scope)
      println("CHECK VALUE TYPE")
      LSDefVar(info(comm), n(comm), type(comm), new-value)
    (comm:LSSeq) :
      val new-a = fill-ls-comm(a(comm), soln, scope)
      val new-b = fill-ls-comm(b(comm), soln, scope)
      LSSeq(info(comm), new-a, new-b)
    (comm:LSIf) :
      val new-pred = fill-ls-exp(pred(comm), soln, scope)
      val new-conseq = fill-ls-comm(conseq(comm), soln, scope)
      val new-alt = fill-ls-comm(alt(comm), soln, scope)
      println("CHECK TYPE OF PRED")
      LSIf(info(comm), new-pred, new-conseq, new-alt)
    (comm:LSMatch) :
      val new-args = fill-ls-exps(args(comm), soln, scope)
      val new-branches = fill-ls-comms(branches(comm), soln, scope) as Tuple<LSBranch>
      println("CHECK BRANCH ARGUMENT TYPES")
      LSMatch(info(comm), new-args, new-branches)
    (comm:LSBranch) :
      val new-atypes = fill-ls-types!(atypes(comm), soln)
      val new-body = fill-ls-comm(body(comm), soln, scope)
      LSBranch(info(comm), args(comm), new-atypes, new-body)
    (comm:LSSkip) :
      comm

;Fill the solved types in the given expression.
defn fill-ls-exp (e:LSExp, soln:SolverState, scope:List<Int>) -> LSExp :
  match(fill-ls-exp-common(e, soln)) :
    (e:LSVar) :
      e
    (e:LSNew) :
      val new-args = fill-ls-exps(args(e), soln, scope)
      println("CHECK ARG TYPES")
      LSNew(info(e), type(e), ctxt(e), n(e), targs(e), new-args)
    (e:LSStruct) :
      val new-args = fill-ls-exps(args(e), soln, scope)
      println("CHECK ARG TYPES")
      println("CHECK STRUCT BOUNDEDNESS")
      LSStruct(info(e), type(e), ctxt(e), n(e), targs(e), new-args)
    (e:LSAddr) :
      val new-exp = fill-ls-exp(exp(e), soln, scope)
      LSAddr(info(e), type(e), ctxt(e), new-exp, unstable?(e))
    (e:LSDeref) :
      val new-exp = fill-ls-exp(exp(e), soln, scope)
      println("CHECK BOUNDEDNESS")
      LSDeref(info(e), type(e), ctxt(e), new-exp)
    (e:LSSlot) :
      val new-exp = fill-ls-exp(exp(e), soln, scope)
      val new-index = fill-ls-exp(index(e), soln, scope)
      println("CHECK SLOT TYPE")
      println("CHECK INDEX TYPE")
      println("CHECK BOUNDEDNESS")
      LSSlot(info(e), type(e), ctxt(e), new-exp, new-index)
    (e:LSField) :
      val new-exp = fill-ls-exp(exp(e), soln, scope)
      println("CHECK GOOD FIELD")
      LSField(info(e), type(e), ctxt(e), new-exp, name(e))
    (e:LSDo) :
      val new-func = fill-ls-exp(func(e), soln, scope)
      val new-args = fill-ls-args(args(e), soln, scope)
      LSDo(info(e), type(e), ctxt(e), new-func, targs(e), new-args)
    (e:LSCallC) :
      val new-func = fill-ls-exp(func(e), soln, scope)
      val new-args = fill-ls-args(args(e), soln, scope)
      println("CHECK CALLABLE")
      LSCallC(info(e), type(e), ctxt(e), new-func, new-args)
    (e:LSPrim) :
      val new-args = fill-ls-exps(args(e), soln, scope)
      println("CHECK GOOD PRIMITIVE ARGS")
      LSPrim(info(e), type(e), ctxt(e), op(e), new-args)
    (e:LSSizeof) :
      println("CHECK BOUNDEDNESS")
      e
    (e:LSTagof) :
      e
    (e:LSCast) :
      val new-exp = fill-ls-exp(exp(e), soln, scope)
      println("CHECK GOOD CAST")
      val conv? = resolved?(type!(exp(e)))
              and convert?(type!(exp(e)), targ(e))
      if conv? : LSConv(info(e), type(e), ctxt(e), new-exp, targ(e))
      else : LSCast(info(e), type(e), ctxt(e), new-exp, targ(e))
    (e:LSLiteral) :
      e
    (e:LSAnd) :
      val new-a = fill-ls-exp(a(e), soln, scope)
      val new-b = fill-ls-exp(b(e), soln, scope)
      println("CHECK AND TYPES")
      LSAnd(info(e), type(e), ctxt(e), new-a, new-b)
    (e:LSOr) :
      val new-a = fill-ls-exp(a(e), soln, scope)
      val new-b = fill-ls-exp(b(e), soln, scope)
      println("CHECK OR TYPES")
      LSOr(info(e), type(e), ctxt(e), new-a, new-b)
    (e:LSLetExp) :
      val new-comm = fill-ls-comm(comm(e), soln, scope)
      val new-exp = fill-ls-exp(exp(e), soln, scope)
      LSLetExp(info(e), type(e), ctxt(e), new-comm, new-exp)
    (e:LSMix) :
      println("CHECK CONTEXT")
      val new-sel = fill-sel(sel(e) as Selection, soln)
      val new-inst = fill-inst(inst(e) as LSInstFns, soln)
      val [pruned-sel, pruned-insts] = ls-select(new-sel, new-inst)
      match(pruned-insts:LSInstFns) :
        val refs = instantiated(refs(e), pruned-insts)
        val filled-refs = fill-ls-exps(refs, soln, scope) as Tuple<LSVar>
        println("CHECK VALID MIX")
        LSMix(info(e), type(e), ctxt(e), filled-refs, pruned-sel, pruned-insts)
      else :
        println("ISSUE ERROR.")
        e
    (e:LSFn) :
      val new-ref = fill-exp(ref(e), soln, scope)
      LSFn(info(e), type(e), ctxt(e), new-ref)

;Fill the solution for the given method.
defn fill-method (m:TDefmethod, thist:Maybe<Type>, soln:SolverState, scope:List<Int>) -> TDefmethod :
  println("FILL MULTI")
  val new-multi = fill-multi(multi(m) as TMix, soln)
  val tvars = to-list $ cat(targs(m), cargs(m))
  val new-a2 = fill-type!(a2(m), soln)
  val new-body = fill-exp(body(m), soln, tvars)
  println("CHECK MULTI RESOLVED")
  println("CHECK SUBMETHOD")
  println("CHECK TYPE OF BODY")
  println("CHECK VALID THIS TYPE.")
  TDefmethod(info(m), tail?(m), n(m), new-multi, thisn(m), targs(m), cargs(m),
             a1(m), new-a2, args(m), new-body)

;Fill the solution for the given multi.
defn fill-multi (multis:TMix, soln:SolverState) -> TMix :
  val m = fill-exp-common(multis, soln) as TMix
  val new-sel = fill-sel(sel(m) as Selection, soln)
  val new-inst = fill-inst(inst(m) as Instantiation, soln)
  val [pruned-sel, pruned-inst] = select(new-sel, new-inst)
  val new-refs = match(instantiated(refs(m), pruned-inst)) :
    (refs:Tuple<TRef>) : fill-exps(refs, soln, List()) as Tuple<TRef>
    (f:False) : refs(m)
  println("CHECK SINGLE SELECTION")
  TMix(info(m), type(m), ctxt(m), new-refs, pruned-sel, pruned-inst)

;Fill only the common fields of the given expression.
;Currently, the 'type' and the 'ctxt'.
defn fill-exp-common (e:TExp, soln:SolverState) -> TExp :
  val new-type = fill-type!(type(e), soln)
  val new-ctxt = fill-ctxt(ctxt(e) as Context, soln)
  e $> sub-type{_, new-type}
    $> sub-ctxt{_, new-ctxt}

;Fill only the common fields of the given expression.
;Currently, the 'type' and 'ctxt' fields.
defn fill-ls-exp-common (e:LSExp, soln:SolverState) -> LSExp :
  val new-type = fill-ls-type!(type(e), soln)
  val new-ctxt = fill-ls-ctxt(ctxt(e) as LSContext, soln)
  e $> sub-type{_, new-type}
    $> sub-ctxt{_, new-ctxt}

;Fill the solved types with the solutions.
;Any unsolved variables remain as TUVar and UVarT.
defn fill-type-lstype (t:Type|LSType, soln:SolverState) -> Type|LSType :
  match(t:TUVar|UVarT) :
    match(soln[n(t)]) :
      (t:SolvedType) : value(t) as Type|LSType
      (v) : t
  else :
    map-lstype(fill-type-lstype{_, soln}, t)

;Fill the given context with the solutions.
defn fill-ctxt (ctxt:Context, soln:SolverState) -> Context :
  val result = let loop (item:TLItem = ctxt) :
    match(item:Type) : fill-type!(item, soln)
    else : map(loop, item)
  result as Context

;Fill the given LoStanza context with the solutions.
defn fill-ls-ctxt (ctxt:LSContext, soln:SolverState) -> LSContext :
  val result = let loop (item:TLItem = ctxt) :
    match(item:Type|LSType) : fill-type-lstype(item, soln)
    else : map(loop, item)
  result as LSContext

;Fill the given Selection with the values.
defn fill-sel (s:Selection, soln:SolverState) -> Selection :
  match(s:SVar) :
    match(soln[n(s)]) :
      (x:SolvedSel) :
        if all?({_ is True|False|PartialMatch}, values(x)) :
          SSel(values(x) as Tuple<True|False|PartialMatch>)
        else : s
      (x) : s
  else : s

;Fill the given instantiation with the solved values.
defn fill-inst (i:Instantiation, soln:SolverState) -> Instantiation :
  match(i) :
    (i:InstVar) :
      match(soln[n(i)]) :
        (x:SolvedInstantiation) : InstFns(funcs(x))
        (x) : i
    (i:InstFns) :
      InstFns $ for f in funcs(i) map :
        map(fill-type!{_, soln}, f)

;Fill the given LoStanza instantiations with their solved types.
defn fill-inst (instfns:LSInstFns, soln:SolverState) -> LSInstFns :
  LSInstFns $ for func in funcs(instfns) map :
    map(fill-type-lstype{_, soln}, func)

;Select the chosen instantiations.
defn select (s:Selection, i:Instantiation) -> [Selection, Instantiation] :
  match(s:SSel, i:InstFns) :
    ;Sanity check.
    if length(sels(s)) != length(funcs(i)) :
      fatal("Mismatch between selection and instantiation.")

    ;Prune the false matches from the instantiation.
    val new-sels = Vector<True|PartialMatch>()
    val new-funcs = Vector<InstFn>()
    for (s in sels(s), f in funcs(i)) do :
      match(s:True|PartialMatch) :
        add(new-sels,s)
        add(new-funcs,f)
        
    ;Return the new selection and insts
    [SSel(to-tuple(new-sels)), InstFns(to-tuple(new-funcs))]
  else :
    [s, i]

;Select the chosen instantiations.
defn ls-select (s:Selection, insts:False|LSInstFns) -> [Selection, False|LSInstFns] :
  match(s:SSel, insts:LSInstFns) :
    ;Sanity check.
    if length(sels(s)) != length(funcs(insts)) :
      fatal("Mismatch between selection and instantiation.")

    ;Prune the false matches from the instantiation.
    val new-sels = Vector<True|PartialMatch>()
    val new-funcs = Vector<LSInstFn>()
    for (s in sels(s), f in funcs(insts)) do :
      match(s:True|PartialMatch) :
        add(new-sels, s)
        add(new-funcs, f)

    ;Return the new selection and insts
    [SSel(to-tuple(new-sels)), LSInstFns(to-tuple(new-funcs))]
  else :
    [s, insts]

;Return the set of TRef that is actually instantiated.
;If instantiation is unsolved, then return false.
defn instantiated (rs:Tuple<TRef>, i:Instantiation) -> Tuple<TRef>|False :
  match(i:InstFns) :
    val ns = to-intset(seq(n, funcs(i)))
    to-tuple $ for r in rs filter :
      ns[n(r)]

;Return the set of LSVar that is actually instantiated.
defn instantiated (rs:Tuple<LSVar>, inst:LSInstFns) -> Tuple<LSVar> :
  val ns = to-intset(seq(n, funcs(inst)))
  to-tuple $ for r in rs filter :
    ns[n(r)]

;============================================================
;================= Convenience Fillers ======================
;============================================================

;Type-casted versions of fill-type-lstype.
defn fill-type! (t:Type|False, soln:SolverState) -> Type :
  fill-type-lstype(t as Type, soln) as Type
defn fill-ls-type! (t:LSType|False, soln:SolverState) -> LSType :
  fill-type-lstype(t as LSType, soln) as LSType

;Fill a function argument.
defn fill-arg (a:TArg, soln:SolverState, scope:List<Int>) -> TArg :
  TArg(keyword(a), fill-exp(value(a), soln, scope))
defn fill-ls-arg (a:LSArg, soln:SolverState, scope:List<Int>) -> LSArg :
  LSArg(keyword(a), fill-ls-exp(value(a), soln, scope))

;Fill multiple function arguments.
defn fill-args (xs:Tuple<TArg>, soln:SolverState, scope:List<Int>) -> Tuple<TArg> :
  map(fill-arg{_, soln, scope}, xs)
defn fill-ls-args (xs:Tuple<LSArg>, soln:SolverState, scope:List<Int>) -> Tuple<LSArg> :
  map(fill-ls-arg{_, soln, scope}, xs)

;Fill multiple commands
defn fill-comms (cs:Tuple<TComm>, soln:SolverState, scope:List<Int>) -> Tuple<TComm> :
  map(fill-comm{_, soln, scope}, cs)

;Fill multiple types.
defn fill-types! (ts:Tuple<Type|False>, soln:SolverState) -> Tuple<Type> :
  map(fill-type!{_, soln}, ts)
defn fill-ls-types! (ts:Tuple<LSType|False>, soln:SolverState) -> Tuple<LSType> :
  map(fill-ls-type!{_, soln}, ts)

;Fill an optional expression.
defn fill-exp? (e:TExp|False, soln:SolverState, scope:List<Int>) -> TExp|False :
  match(e:TExp) :
    fill-exp(e, soln, scope)

;Fill multiple expressions.
defn fill-exps (es:Tuple<TExp>, soln:SolverState, scope:List<Int>) -> Tuple<TExp> :
  map(fill-exp{_, soln, scope}, es)

;Fill multiple lostanza expressions.
defn fill-ls-exps (es:Tuple<LSExp>, soln:SolverState, scope:List<Int>) -> Tuple<LSExp> :
  map(fill-ls-exp{_, soln, scope}, es)

;Fill multiple lostanza commands.
defn fill-ls-comms (cs:Tuple<LSComm>, soln:SolverState, scope:List<Int>) -> Tuple<LSComm> :
  map(fill-ls-comm{_, soln, scope}, cs)

;Fill an optional Lostanza expression.
defn fill-ls-exp? (e:LSExp|False, soln:SolverState, scope:List<Int>) -> LSExp|False :
  match(e:LSExp) :
    fill-ls-exp(e, soln, scope)

;Fill multiple methods.
defn fill-methods (ms:Tuple<TDefmethod>, thist:Maybe<Type>,
                   soln:SolverState, scope:List<Int>) -> Tuple<TDefmethod> :
  map(fill-method{_, thist, soln, scope}, ms)

;============================================================
;==================== Small Utilities =======================
;============================================================

;Three-argument cat.
defn cat<?T> (xs:Seqable<?T>, ys:Seqable<?T>, zs:Seqable<?T>) -> Seq<T> :
  cat(xs, cat(ys, zs))