defpackage stz/type :
   import core
   import verse
   import stz/il-ir
   import stz/tl-ir
   import stz/namemap
   import stz/infer
   import stz/type-calculus

;============================================================
;=============== Conversion to Type IR ======================
;============================================================

public defn to-tprog (nm:NameMap, e:IExp) :
   ;======== State ========
   val comms = Vector<TComm>()   
   val hier = THierarchy $ [
      `False => resolve-type(nm, `core, `False)
      `Int => resolve-type(nm, `core, `Int)
      `String => resolve-type(nm, `core, `String)
      `Symbol => resolve-type(nm, `core, `Symbol)
      `List => resolve-type(nm, `core, `List)
      `Tuple => resolve-type(nm, `core, `Tuple)]
      
   ;======== Utilities ========
   val #TN = TNone()
   val #CN = CNone()
   val #IN = INone(FileInfo())
   defn add-comm (c:TComm) : add(comms, c)
   defn add-comm (cs:List<TComm>) : do(add-comm, cs)
   defn n! (es:List<IExp>) : map(n!, es)
   defn #comm (es:List<IExp>) : do(#comm, es)
   defn #type (es:List<IExp>) : map(#type, es)
   defn #exp (es:List<IExp>) : map(#exp, es)
   defn #farg (es:List<IExp>, ts:List<Type>) : map(#farg{_ ts}, es)
   defn #defn (defs:List<IDefn>) : map(#defn, defs)
   defn #defmethod (defs:List<IDefmethod>) : map(#defmethod, defs)
      
   defn n! (e:IExp) :
      match(e) :
         (e:VarN) : n(e)
         (e:LSVarN) : n(e)

   defn split-targs (es:List<IExp>) :
      val targs = Vector<Int>()
      val cargs = Vector<Int>()
      for e in es do :
         match(e) :
            (e:VarN) : add(targs, n(e))
            (e:ICap) : add(cargs, n!(name(e)))
      [to-list(targs), to-list(cargs)]

   ;======== Transformers ========
   defn #comm (e:IExp) -> False :
      match(e) :
         (e:IBegin) :
            #comm(exps(e))
         (e:IPublic) :
            #comm(exp(e))
         (e:IProtected) :
            #comm(exp(e))
         (e:IDefType) :
            add(hier, c, args*, p) where :
               val c = n!(class(e))
               val args* = n!(args(e))
               val p = #type(parent(e))
         (e:IDef) :
            add-comm(destructure-def(e))
         (e:IDefVar) :
            add-comm(TDefVar(n, t, v)) where :
               val n = n!(name(e))
               val t = #type(type(e))
               val v = #exp(value(e))
         (e:IDefn) :
            add-comm(#defn(e))
         (e:IDefmulti) :
            add-comm(TDefmulti(n, targs, cargs, a1*, a2*)) where :
               val n = n!(name(e))
               val [targs, cargs] = split-targs(targs(e))
               val a1* = #type(a1(e))
               val a2* = #type(a2(e))
         (e:IDefmethod) :
            add-comm(#defmethod(e))
         (e:ILoStanza) :
            false
         (e) :
            add-comm(TExpComm(#exp(e)))

   defn #type (e:IExp) -> Type :
      match(e) :
         (e:ITuple) : TTuple(#type(exps(e)))
         (e:IOf) : TOf(n!(class(e)), TTuple(#type(args(e))))
         (e:IAnd) : TAnd(#type(a(e)), #type(b(e)))
         (e:IOr) : TOr(#type(a(e)), #type(b(e)))
         (e:IArrow) : TArrow(TTuple(#type(a1(e))), #type(a2(e)))
         (e:ICap) : TCap(n!(name(e)))
         (e:IGradual) : TGradual()
         (e:IVoid) : TBot()
         (e:INone) : TNone()
         (e:VarN) : TVar(n(e))
         (e:Raw) : TOf(n!(class(e)), TGradual())      

   defn #exp (e:IExp) -> TExp :
      match(e) :
         (e:IFn) :
            TFn(tail?(e), a1*, a2*, ns, body, #TN, #CN) where :
               val a1* = to-type(a1(e))
               val a2* = to-type(a2(e))
               val [ns, body] = destructure-args(args(e), body(e))
         (e:IMulti) :
            TMulti(fs, #TN, #CN) where :
               val fs = #exp(funcs(e)) as List<TFn>
         (e:IBegin) :
            if empty?(tail(exps(e))) :
               #exp(head(exps(e)))
            else :
               TSeq(a*, b*, #TN, #CN) where :
                  val a* = #exp(head(exps(e)))
                  val binfo = info(exps(e)[1])
                  val b* = #exp(IBegin(tail(exps(e)), binfo))
         (e:IMatch) :
            TMatch(args*, brs*, #TN, #CN) where :
               val args* = #exp(args(e))
               val brs* = #exp(branches(e)) as List<TBranch>
         (e:IBranch) :
            TBranch(ns, ts, body, #TN, #CN) where :
               val ts = #type(types(e))
               val [ns, body] = destructure-args(args(e), body(e))            
         (e:INew) :
            TNew(ms, t, #CN) where :
               val ms = #defmethod(methods(e) as List<IDefmethod>)
               val t = #type(class(e))
         (e:ISet) :
            TSet(r, v, #TN, #CN) where :
               val r = #exp(name(e)) as TRef
               val v = #exp(value(e))
         (e:IDo) :
            TDo(f*, args*, #TN, #CN) where :
               val f* = match(func(e)) :
                  (f:IOf) :
                     if empty?(args(f)) : #exp(class(f))
                     else : #farg(class(f), #type(args(f)))
                  (f) : #exp(f)
               val args* = #exp(args(e))            
         (e:IPrim) :
            TPrim(n, args*, #TN, #CN) where :
               val n = name(function(e) as IVar)
               val args* = #exp(args(e))
         (e:ICallLS) :
            TCallLS(n, targs, args*, #TN, #CN) where :
               val [n, targs] = match(function(e)) :
                  (f:IOf) : [n!(class(f)), #type(args(f))]
                  (f) : [n!(f), List()]
               val args* = #exp(args(e))
         (e:ILiteral) :
            TLiteral(value(e), #TN, #CN)
         (e:ITuple) :
            TTupleExp(#exp(exps(e)), #TN, #CN)
         (e:INone) :
            TElide(#TN, #CN)
         (e:VarN) :
            TRef(n(e), #TN, #CN)
         (e:Mix) :
            TMix(SNone(), #exp(exps(e)), #TN, #CN)
         (e:Let) :
            destructure-let(e)
         (e:LetRec) :
            TLetRec(defns*, body*, #TN, #CN) where :
               val defns* = #defn(defns(e) as List<IDefn>)
               val body* = #exp(body(e))
         (e) :
            error("Unsupported expression: ~" % [e])

   defn #farg (e:IExp, ts:List<Type>) -> TExp :
      match(e) :
         (e:VarN) :
            TArgExp(ref, ts, List(), #TN, #CN) where :
               val ref = TRef(n(e), #TN, #CN)
         (e:Mix) :
            TMix(#SN, exps*, #TN, #CN) where :
               val exps* = #farg(exps(e), ts)

   defn #defn (def:IDefn) :
      TDefn(tail?(def), n, targs, cargs, a1*, a2*, args*, body*) where :
         val n = n!(name(def))               
         val [targs, cargs] = split-targs(targs(def))
         val a1* = #type(a1(def))
         val a2* = #type(a2(def))
         val [args*, body*] = destructure-args(args(def), body(def))

   defn #defmethod (def:IDefmethod) :
      TDefmethod(tail?(def), n, m, thisn(def), targs, cargs, a1*, a2*, args*, body*) where :
         val n = fresh-n()
         val m = #exp(multi(def))
         val a1* = #type(a1(def))
         val a1* = #type(a2(def))
         val [targs, cargs] = split-targs(targs(def))
         val [args*, body*] = destructure-args(args(def), body(def))

   ;======== Destructuring ========
   defn destructure (args:List<IExp>, value:TExp) -> List<KeyValue<List<Int>, TExp>> :
      val [ns, bs] = destructure(args)
      List(ns => value, bs)
      
   defn destructure (args:List<IExp>) -> [List<Int>, List<KeyValue<List<Int>, TExp>>] :
      var bindings = List()
      defn #n (x:IExp) -> Int :
         match(x) :
            (x:ITuple) :
               val n = fresh-n()
               bindings = List(entry, bindings) where :
                  val exps* = map(#n, exps(x))
                  val entry = exps* => TRef(n, #TN, #CN)
               n   
            (x) :
               n!(x)
      val ns = map(#n, args)
      [ns, bindings]

   defn destructure-args (args:List<IExp>, fbody:IExp) -> [List<Int>, TExp] :
      val [ns, bs] = destructure(args)
      var body = #exp(fbody)
      for b in bs do :
         body = TLetTuple(ns, ts, v, body, #TN, #CN) where :
            val [ns, v] = [key(b), value(b)]
            val ts = map({#TN}, ns)         
      [ns, body]

   defn destructure-let (lete:Let) -> TExp :
      defn loop (name:IExp, type:IExp, v:IExp) :
         match(name, type) :
            (name:ITuple, type:INone) :
               var body = #exp(body(lete))
               for b in destructure(exps(name), #exp(v)) do :
                  body = TLetTuple(ns, ts, v, body, #TN, #CN) where :
                     val [ns, v] = [key(b), value(b)]
                     val ts = map({#TN}, ns)                  
               body
            (name:ITuple, type) :
               TLet(n, t*, v*, body*, #TN, #CN) where :
                  val n = fresh-n()
                  val t* = #type(type)
                  val v* = #exp(v)
                  val body* = loop(name, #IN, VarN(n, info(name)))               
            (name, type) :
               TLet(n!(name), t*, v*, body*, #TN, #CN) where :
                  val t* = #type(type)
                  val v* = #exp(v)
                  val body* = #exp(body(lete))               
      loop(name(d), type(d), value(d)) where :
         val d = def(lete) as IDef

   defn destructure-def (def:IDef) -> List<TDef|TDefTuple> :
      defn loop (name:IExp, type:IExp) :
         match(name, type) :
            (name:ITuple, type:INone) :
               val bs = destructure(exps(name), #exp(value(def)))
               for b in bs map :
                  TDefTuple(ns, ts, v) where :
                     val [ns, v] = [key(b), value(b)]
                     val ts = map({#TN}, ns)                  
            (name:ITuple, type) :
               List(TDef(n, t*, v*), rest*) where :
                  val n = fresh-n()
                  val t* = #type(type)
                  val v* = #exp(value(def))
                  val rest* = loop(name, #IN)
            (name, type) :
               list(TDef(n, t*, v*)) where :
                  val n = n!(name)
                  val t* = #type(type)
                  val v* = #exp(value(def))
      loop(name(def), type(def))


   ;======== Driver ========
   #comm(e)
   TProg(hier, to-list(comms))   


;============================================================
;============== Generate Type Variables =====================
;============================================================
public defn initialize-types (prog:TProg) :
   ;======== Environment ========
   val env = HashTable<Int,Type>({_})

   ;======== Utilities ========
   val #? = TGradual()
   val #fresh = Fresh()
   defn #freshv () : TUVar(fresh-n())
   defn #freshv (n:Int) : map(#freshv{}, 0 to n)
   defn #or (x:Type, y:Type) : y when x typeof TUVar|TNone else x
   defn #or (x:Type, f:Fresh) : #freshv() when x typeof TUVar|TNone else x
   defn #or (xs:List<Type>, y:Type|Fresh) : map(#or{_, y}, xs)
   defn #or (xs:List<Type>, ys:List<Type>) : map(#or, xs, ys)
   defn set-env (n:Int, t:Type) : env[n] = t
   defn set-env (n:Int, f:Fresh) : env[n] = #freshv()
   defn set-env (ns:List<Int>, y:Type|Fresh) : do(set-env{_, y}, ns)
   defn set-env (ns:List<Int>, ts:List<Type>) : do(set-env, ns, ts)   
   defn bexp (es:List<TExp>, c:Context) : map(bexp{_, c}, es)
   defn bcomm<?T> (cs:List<?T&TComm>) : map(bcomm, cs)
   defn #types (es:List<TExp>) : map(type, es)
   
   defn env-a1 (n:Int) :
      defn* loop (t:Type) :
         match(t) :
            (t:TPoly) : loop(func(t))
            (t:TArrow) : types(a(t) as TTuple)
      loop(env[n])

   defn env-a2 (n:Int) :
      defn* loop (t:Type) :
         match(t) :
            (t:TPoly) : loop(func(t))
            (t:TArrow) : b(t)
      loop(env[n])

   defn fn-type (c:TDefmulti|TDefn|TDefmethod) :
      val t = TArrow(TTuple(a1*), a2*) where :
         val a1* = #or(a1(c), #?)
         val a2* = #or(a2(c), #fresh)
      if empty?(targs(c)) and empty?(cargs(c)) : t
      else : TPoly(targs(c), cargs(c), t)

   ;======== Specialized Type Constructors ========
   defn lit-type (v) :
      defn base (n:Int) : TOf(n, TTuple(List()))
      defn raw (n:Int) : TOf(n, TGradual())
      match(v) :
         (v:False) : base(False(hier(prog)))
         (v:Int) : base(Int(hier(prog)))
         (v:String) : base(String(hier(prog)))
         (v:Symbol) : base(Symbol(hier(prog)))
         (v:List) : raw(List(hier(prog)))

   defn prim-type (f:Symbol) :
      error("Primitive type not yet implemented.")


   ;======== Build top level environment ========
   defn build-environment () :
      for c in comms(prog) do :
         match(c) :
            (c:TDef) : set-env(n(c), #or(type(c), #fresh))
            (c:TDefTuple) : set-env(ns(c), #fresh)
            (c:TDefVar) : set-env(n(c), #or(type(c), #fresh))
            (c:TDefn) : set-env(n(c), fn-type(c))
            (c:TDefmulti) : set-env(n(c), fn-type(c))
            (c:TDefmethod) : set-env(n(c), fn-type(c))
            (c:TExpComm) : false
         
   ;======== Productions ========
   defn bcomm<?T> (c:?T&TComm) -> T :
      {_ as T&TComm} $ match(c) :
         (c:TDef) :
            TDef(n(c), t*, v*) where :
               val v* = bexp(value(c), CExp(#or(type(c), #?)))
               val t* = env[n(c)]
         (c:TDefTuple) :
            TDefTuple(ns(c), ts*, v*) where :
               val v* = bexp(value(c), CExp(#?))
               val ts* = map({env[_]}, ns(c))            
         (c:TDefVar) :
            TDefVar(n(c), t*, v*) where :
               val v* = bexp(value(c), CExp(#or(type(c), #?)))
               val t* = env[n(c)]            
         (c:TDefn) :
            set-env(args(c), map(uncap, env-a1(n(c))))
            TDefn(tail?(c), n(c), targs(c), cargs(c), a1*, a2*, args(c), body*) where :
               val body* = bexp(body(c), CExp(#or(a2(c), #?)))
               val a1* = env-a1(n(c))
               val a2* = env-a2(n(c))
         (c:TDefmulti) :
            TDefmulti(n(c), targs(c), cargs(c), a1*, a2*) where :
               val a1* = env-a1(n(c))
               val a2* = env-a2(n(c))               
         (c:TDefmethod) :
            set-env(args(c), map(uncap, env-a1(n(c))))
            TDefmethod(tail?(c), n(c), m*, thisn(c), targs(c), cargs(c), a1*, a2*, args(c), body*) where :
               val m* = bexp(multi(c), CExp(#?))        
               val a1* = env-a1(n(c))
               val a2* = env-a2(n(c))
               val body* = bexp(body(c), CExp(#or(a2(c), #?)))
         (c:TExpComm) :
            TExpComm(bexp(exp(c), CExp(#?)))

   defn bexp (e:TExp, c:Context) -> TExp :
      match(e) :
         (e:TLet) :
            TLet(n(e), type(v*), v*, body*, type(body*), c) where :
               val v* = bexp(value(e), CExp(#or(ntype(e), #?)))
               set-env(n(e), type(v*))
               val body* = bexp(body(e), c)
         (e:TLetVar) :
            TLetVar(n(e), t*, v*, body*, type(body*), c) where :
               val t* = #or(ntype(e), #fresh)
               val v* = bexp(value(e), CExp(t*))
               set-env(n(e), t*)
               val body* = bexp(body(e), c)
         (e:TLetTuple) :
            TLetTuple(ns(e), ts*, v*, body*, type(body*), c) where :
               val ts* = #or(ntypes(e), #fresh)
               val v* = bexp(value(e), CExp(#?))
               set-env(ns(e), ts*)
               val body* = bexp(body(e), c)
         (e:TLetRec) :
            TLetRec(defns*, body*, type(body*), c) where :
               for def in defns(e) do :
                  set-env(n(def), fn-type(def))
               val defns* = for d in defns(e) map :
                  TDefn(tail?(d), n(d), targs(d), cargs(d), a1*, a2*, args(d), body*) where :
                     val a1* = env-a1(n(d))
                     val a2* = env-a2(n(d))
                     set-env(args(d), a1*)
                     val body* = bexp(body(d), CExp(#or(a2(d), #?)))
               val body* = bexp(body(e), c)
         (e:TFn) :
            TFn(tail?(e), a1*, a2*, args(e), body*, t*, c) where :
               val a1* = #or(a1(e), #fresh)
               val a2* = #or(a2(e), #fresh)
               val t* = TArrow(TTuple(a1*), a2*)
               set-env(args(e), a1*)
               val body* = bexp(body(e), CExp(#or(a2(e), #fresh)))
         (e:TMulti) :
            TMulti(funcs*, type*, c) where :
               val funcs* = bexp(funcs(e), c) as List<TFn>
               val type* = reduce(TAnd, #types(funcs*))
         (e:TSeq) :
            TSeq(a*, b*, type(b*), c) where :
               val a* = bexp(a(e), CExp(#?))
               val b* = bexp(b(e), c)
         (e:TMatch) :         
            TMatch(args*, branches*, #freshv(), c) where :
               val args* = bexp(args(e), CExp(#?))
               val branches* = for b in branches(e) map :
                  TBranch(args(b), atypes*, body*, type(body*), c) where :
                     val atypes* = #or(atypes(b), #types(args*))
                     set-env(args(b), atypes*)
                     val body* = bexp(body(b), c)
         (e:TNew) :
            TNew(ms*, type(e), c) where :
               val ms* = bcomm(methods(e))
         (e:TArgExp) :
            TArgExp(e*, targs(e), cargs*, #freshv(), c) where :
               val t = env[n(ref(e))]
               val e* = TRef(n(ref(e)), t, c)
               val cargs* = match(t) :
                  (t:TPoly) : #freshv(length(cargs(t)))
                  (t) : List()
         (e:TRef) :
            val t = env[n(e)]
            val e* = TRef(n(e), t, c)
            match(t) :
               (t:TPoly) :
                  TArgExp(e*, List(), #freshv(n), #freshv(), c) where :
                     val n = length(cargs(t))
               (t) : e*
         (e:TCast) :
            TCast(exp*, type(e), c) where :
               val exp* = bexp(exp(e), CExp(#?))
         (e:TSet) :
            TSet(ref*, v*, lit-type(false), c) where :
               val ref* = bexp(ref(e), CExp(#?)) as TRef
               val v* = bexp(value(e), CExp(type(ref*)))
         (e:TDo) :         
            TDo(f*, args*, #freshv(), c) where :
               val args* = map(bexp{_, CExp(#freshv())}, args(e))
               val ret* = match(c) :
                  (c:CExp) : type(c)
                  (c:CDo) : TArrow(TTuple(args(c)), ret(c))
               val f* = bexp(func(e), CDo(#types(args*), ret*, #freshv()))
         (e:TPrim) :
            TPrim(function(e), args*, t*, c) where :
               val args* = bexp(args(e), CExp(#?))
               val t* = prim-type(function(e))
         (e:TCallLS) :
            TCallLS(function(e), targs(e), args*, #?, c) where :
               val args* = bexp(args(e), CExp(#?))
         (e:TLiteral) :
            TLiteral(value(e), lit-type(value(e)), c)
         (e:TTupleExp) :
            TTupleExp(exps*, t*, c) where :
               val exps* = map(bexp{_, CExp(#freshv())}, exps(e))
               val t* = TTuple(#types(exps*))
         (e:TMix) :
            TMix(sel*, exps*, #freshv(), c) where :
               val sel* = SVar(fresh-n())
               val exps* = match(c) :
                  (c:CExp) : bexp(exps(e), c)
                  (c:CDo) : bexp(exps(e), CDo(args(c), ret(c), TNone()))
         (e:TElide) :
            e

   ;Return new program
   build-environment()
   TProg(hier(prog), bcomm(comms(prog)))


;============================================================
;============== Generate Type Constraints ===================
;============================================================
defstruct TupleF : ()
defstruct SubF : (ti:Type, t:Type)
defstruct ArgsF : ()
defstruct RetF : (n:Int)

public defn generate-type-constraints (prog:TProg) :
   ;======== State ========
   val exp-env = HashTable<Int,Type>({_})
   val constraints = Vector<Constraint>()
   
   ;======== Utilities ========
   val #? = TGradual()
   val #fresh = Fresh()   
   defn expected (n:Int) : get?(exp-env, n, false)
   defn set-expected (n:Int, t:Type) : exp-env[n] = t
   defn set-expected (ns:List<Int>, ts:List<Type>) : do(set-expected, ns, ts)
   defn addc (c:Constraint) : add(constraints, c)   
   defn #or (x:Type, f:Fresh) : TUVar(fresh-n()) when x typeof TUVar else x
   defn #or (xs:List<Type>, f:Fresh) : map(#or{_, f}, xs)
   defn #ctxts (es:List<TExp>) : map(ctxt, es)
   defn #types (es:List<TExp>) : map(type, es)
   defn #types (cs:List<CExp>) : map(type, cs)
   defn #super (a:False, b:Type) : false
   defn #equal (ats:List<Type>, bts:List<Type>) : do(#equal, ats, bts)
   defn #equal (ats:List<Type>, b:Type) : do(#equal{_, b}, ats)
   defn #flow (rs:List<TUVar>, t:Type, w:Type) : do(#flow{_, t, w}, rs)

   defn #tuple-cap (t:TUVar, i:Int, m:Int) :
      TTuple $ for j in 0 to m map :
         if j == i : TCap(n(t))
         else : #?
      
   ;======== Constraint Generation Language ========
   ;Propagate type upwards towards a subform
   defn #upto (r:Type, w:Type, f:SubF) :
      defn sub (t:Type, n*:Int, t*:Type) :
         match(t) :
            (t:TUVar) : 
               if n(t) == n* : t*
               else : #?
            (t) : map(sub{_, n*, t*}, t)            
      match(r, ti(f)) :
         (r:TUVar, ti:TUVar) :
            val t* = sub(t(f), n(ti), TCap(n(r)))
            #cap(r, t*, w)
         (r, ti) :
            false

   ;Propagate type upwards towards elements of tuple form
   defn #upto (rs:List<TUVar>, w:Type, f:TupleF) :
      val n = length(rs)
      for (r in rs, i in 0 to n) do :
         #cap(r, #tuple-cap(r, i, n), w)
   
   ;Propagate type downwards towards arguments of function
   defn #downto (rs:List<TUVar>, w:Type, f:ArgsF) :
      val n = length(rs)
      for (r in rs, i in 0 to n) do :
         val a1 = #tuple-cap(r, i, n)
         #cap(r, w, TArrow(a1, #?))

   ;Propagate type downwards towards return of function   
   defn #downto (r:TUVar, w:Type, f:RetF) :
      val a = TTuple(map({#?}, 0 to n(f)))
      val b = TCap(n(r))
      #cap(r, w, TArrow(a, b))

   ;Propagate type downwards towards elements of tuple form
   defn #downto (rs:List<TUVar>, w:Type, f:TupleF) :
      val n = length(rs)
      for (r in rs, i in 0 to n) do :
         #cap(r, w, #tuple-cap(r, i, n))

   ;Create supertype constraint
   defn #super (a:Type, b:Type) :
      match(a) :
         (a:TUVar) : addc(SuperConstraint(n(a), b))
         (a) : false

   ;Create equality constraint
   defn #equal (a:Type, b:Type) :
      match(a) :
         (a:TUVar) : addc(EqualConstraint(n(a), b))
         (a) : false
   
   ;Create capture constraint
   defn #cap (r:TUVar, x:Type, y:Type) :
      addc(FlowConstraint(n(r), x, y))

   ;Create a selection constraint
   defn #select (s:SVar, ats:List<Type>, bt:Type) :
      addc(SelConstraint(n(s), ats, bt))

   ;Create a mixture constraint
   defn #mix (t:TUVar, s:SVar, ats:List<Type>) :
      addc(MixConstraint(n(t), n(s), ats))
   
   ;Create a threshold constraint
   defn #thresh (s:SVar) :
      val r = SVar(fresh-n())
      addc(ThresholdConstraint(n(r), n(s)))
      r
   
   ;Create a flow constraint
   defn #flow (r:TUVar, t:Type, w:Type) :
      ;Isolate a single capture variable
      defn isolate (n*:Int, t:Type) :
         match(t) :
            (t:TCap) :
               if n(t) == n* : t
               else : TUVar(n(t))
            (t) : map(isolate{n*, _}, t)
      addc(FlowConstraint(n(r), t*, w)) where :      
         val t* = isolate(n(r), t)

      
   ;
   ;defn #expect (c:Context, t:Type) :
   ;   match(c) :
   ;      (c:CDo) : #super(exp(c), t)
   ;      (c) : false
   ;
   ;defn #targ-apply (t*:Type, targs*:List<Type>, cargs*:List<Type>) :
   ;   match(t*) :
   ;      (t*:TPoly) :
   ;         if length(targs(t*)) != length(targs*) :
   ;            throw(ConstraintError())
   ;         val env = map(KeyValue, append(targs(t*), cargs(t*)),
   ;                                 append(targs*, cargs*))
   ;         defn repl (t:Type) :
   ;            match(t) :
   ;               (t:TCap) : TCap(n(lookup!(env, n(t)) as TUVar))
   ;               (t:TVar) : lookup(env, n(t), t)
   ;               (t) : map(repl, t)
   ;         val a* = repl(a(func(t*)))
   ;         val b* = TUVar(fresh-n())
   ;         addc(SubConstraint(n(b*), b(func(t*)), env))
   ;         TArrow(a*, b*)
   ;      (t*) :
   ;         throw(ConstraintError())  
   ;

   ;

   ;
   ;
   ;
   ;;Constraint Generation for Commands
   ;defn gen-comm (c:TComm) :
   ;   match(c) :
   ;      (c:TDef) :
   ;         gen-exp(value(c))
   ;         #equal(type(c), type(value(c)))
   ;      (c:TDefTuple) :
   ;         gen-exp(value(c))
   ;         #downto(types(c), type(value(c)), TupleF())
   ;      (c:TDefVar) :
   ;         gen-exp(value(c))
   ;         if value(c) not-typeof TElide :
   ;            #super(type(c), type(value(c)))
   ;      (c:TDefn) :
   ;         gen-exp(body(c))
   ;         #equal(a2(c), type(body(c)))
   ;      (c:TDefmulti) :
   ;         false
   ;      (c:TDefmethod) :
   ;         gen-exp(body(c))
   ;         #equal(a2(c), type(body(c)))
   ;      (c:TExpComm) :
   ;         gen-exp(exp(c))
   ;      
   ;;Constraint generation for expressions
   ;defn gen-exp (e:TExp) :
   ;   match(e) :
   ;      (e:TFn) :
   ;         match(ctxt(e)) :
   ;            (c:CExp) :
   ;               ;Compute expected return
   ;               val ret = type(ctxt(body(e)) as CExp)
   ;               #upto(ret, type(c), SubF(a2(e), type(e)))
   ;               ;Compute expected arguments
   ;               for t in a1(e) do :
   ;                  #upto(t, type(c), SubF(t, type(e)))
   ;            (c:CDo) :
   ;               ;Set expected type
   ;               val exp-a1 = #or(a1(e), #fresh)
   ;               #super(exp(c), TArrow(TTuple(exp-a1), a2(e)))
   ;               set-expected(args(e), exp-a1)
   ;               ;Compute expected return
   ;               val exp-ret = type(ctxt(body(e)) as CExp)
   ;               #equal(exp-ret, ret(c))
   ;               ;Compute expected arguments
   ;               if length(args(e)) == length(args(c)) :
   ;                  #equal(a1(e), args(c))
   ;         do(gen-exp, e)
   ;      (e:TMulti) :
   ;         match(ctxt(e)) :
   ;            (c:CExp) :
   ;               for f in funcs(e) do :
   ;                  ;Compute expected return
   ;                  val ret = type(ctxt(body(f)) as CExp)
   ;                  #upto(ret, type(c), SubF(a2(f), type(e)))
   ;                  ;Compute expected arguments
   ;                  for t in a1(f) do : #upto(t, type(c), SubF(t, type(e)))
   ;                  ;Recurse on body
   ;                  gen-exp(body(f))
   ;            (c:CDo) :
   ;               for f in funcs(e) do :
   ;                  if length(args(f)) == length(args(c)) :
   ;                     gen-exp(f)
   ;                  else :
   ;                     ;Set argument types
   ;                     #equal(a1(f), TBot())
   ;                     gen-exp(body(f))
   ;      (e:TNew) :
   ;         do(gen-comm, methods(e))
   ;         #expect(ctxt(e), type(e))
   ;      (e:TSet) :
   ;         do(gen-exp, e)
   ;         #super(type(ref(e)), type(value(e)))
   ;         #expect(ctxt(e), type(e))
   ;      (e:TDo) :
   ;         do(gen-exp, e)
   ;         val fc = ctxt(func(e)) as CDo
   ;         val argcs = #ctxts(args(e)) as List<CExp>
   ;         #downto(#types(argcs), exp(fc), ArgsF())
   ;         #downto(type(e), exp(fc), RetF(length(args(e))))
   ;         #expect(ctxt(e), type(e))
   ;      (e:TPrim) :
   ;         do(gen-exp, e)
   ;         #expect(ctxt(e), type(e))
   ;      (e:TCallLS) :
   ;         do(gen-exp, e)
   ;         #expect(ctxt(e), type(e))
   ;      (e:TTupleExp) :
   ;         do(gen-exp, exps(e))
   ;         if ctxt(e) typeof CExp :
   ;            val c = ctxt(e) as CExp
   ;            val ts = #types(#ctxts(exps(e)) as List<CExp>)
   ;            #upto(ts, type(c), TupleF())
   ;         #expect(ctxt(e), type(e))
   ;      (e:TRef) :
   ;         val w = match(ctxt(e)) :
   ;            (c:CExp) : type(c)
   ;            (c:CDo) : TArrow(TTuple(args(c)), ret(c))
   ;         #super(expected(n(e)), w)
   ;         #expect(ctxt(e), type(e))
   ;      (e:TArgExp) :
   ;         val w = match(ctxt(e)) :
   ;            (c:CExp) : type(c)
   ;            (c:CDo) : TArrow(TTuple(args(c)), #?)
   ;         try :
   ;            val t* = #targ-apply(type(ref(e)), targs(e), cargs(e))
   ;            #equal(type(e), uncap(t*))
   ;            #flow(cargs(e), t*, w)
   ;         catch (e:ConstraintError) : false
   ;         #expect(ctxt(e), type(e))
   ;      (e:TMix) :
   ;         val w = match(ctxt(e)) :
   ;            (c:CExp) : type(c)
   ;            (c:CDo) : TArrow(TTuple(args(c)), #?)
   ;         do(gen-exp, e)
   ;         #select(sel(e), #types(exps(e)), w)
   ;         #mix(type(e), s, #types(exps(e))) where :
   ;            val s = match(ctxt(e)) :
   ;               (c:CExp) : #thresh(sel(e))
   ;               (c:CDo) : sel(e)
   ;         #expect(ctxt(e), type(e))
   ;      (e:TMatch) :
   ;         do(gen-exp, args(e))
   ;         do(gen-exp, branches(e))
   ;         #equal(type(e), reduce(TOr, #types(branches(e))))         
   ;      (e:TLet) :
   ;         do(gen-exp, e)
   ;      (e:TLetVar) :
   ;         if value(e) not-typeof TElide :
   ;            #super(ntype(e), type(value(e)))
   ;         do(gen-exp, e)
   ;      (e:TLetTuple) :
   ;         val n = length(ns(e))
   ;         #downto(ntypes(e), type(value(e)), TupleF())
   ;         do(gen-exp, e)
   ;      (e:TLetRec) :
   ;         do(gen-comm, defns(e))
   ;         gen-exp(body(e))
   ;      (e:TSeq) : do(gen-exp, e)
   ;      (e:TBranch) : do(gen-exp, e)
   ;      (e:TElide) : false
   ;      (e:TLiteral) : #expect(ctxt(e), type(e))
   ;
   ;;Driver
   ;do(gen-comm, comms(prog))
   ;do(println, constraints)

;============================================================
;=============== General Utilities ==========================
;============================================================
defstruct Fresh

defstruct ConstraintError <: Exception

defn uncap (t:Type) :
   match(t) :
      (t:TCap) : TUVar(n(t))
      (t) : map(uncap, t)

defn map<?T> (f:Int -> ?T, r:Range) :
   to-list(stream(f, r))