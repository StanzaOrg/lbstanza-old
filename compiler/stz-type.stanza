defpackage stz/type :
   import core
   import verse
   import stz/il-ir
   import stz/tl-ir
   import stz/namemap
   import stz/infer
   import stz/type-calculus
   import stz/algorithms
   import stz/utils
   import stz/ids
   import stz/primitives

#use-overlay(stz/attempt-lang)

;============================================================
;====================== Driver ==============================
;============================================================

public defn type-program (nm:NameMap, e:IExp) :
   val prog = to-tprog(nm, e)
   println("==== TYPE PROGRAM =====")
   println(prog)
   set-current-hierarchy(hier(prog))
   println("Infer types")
   val [prog*, env, ls-env] = infer-types(prog)
   println(prog*)
   println("Report errors")
   report-errors(nm, prog*, env, ls-env)
   prog*

;============================================================
;=============== Conversion to Type IR ======================
;============================================================

definterface Assert
defstruct CorrectTArity <: Assert: (info:FileInfo, n:Int, targs:List<Type>)

defstruct DefChild :
   n: Int
   args: List<Int>
   parent: Type

defn to-tprog (nm:NameMap, e:IExp) :
   ;     State
   ;     =====
   val accum = Vector<TComm>()
   val asserts = Vector<Assert>()
   val errors = Vector<?>()
   val hier = THierarchy()
   val defchilds = Vector<DefChild>()

   defn add-error (e) :
      add(errors, to-string(e))

   ;     Utilities
   ;     =========
   val #IN = INone(FileInfo())
   defn #name (n:Int) : name(nm[n])
   defn #info (n:Int) : info(nm[n])
   defn #pr (t:Type) : printable(nm, t)
   defn #pr (ts:Streamable<Type>) : stream(#pr, ts)
   defn cms (xs:Streamable) : join(xs, ", ")
   defn add-comm (c:TComm) : add(accum, c)
   defn add-comm (cs:List<TComm>) : do(add-comm, cs)
   defn name! (e:IExp) : name(e as IVar)
   defn n! (e:IExp) : n(e as VarN)
   defn n! (es:List<IExp>) : map(n!, es)
   defn #comm (es:List<IExp>) : do(#comm, es)
   defn #type (es:List<IExp>) : map(#type, es)
   defn #lstype (es:List<IExp>) : map(#lstype, es)
   defn #exp (es:List<IExp>) : map(#exp, es)
   defn #lsexp (es:List<IExp>) : map(#lsexp, es)
   defn #lscomm (es:List<IExp>) : map(#lscomm, es)
   defn #defn (defs:List<IDefn>) : map(#defn, defs)
   defn #defmethod (defs:List<IDefmethod>) : map(#defmethod, defs)

   defn split-targs (es:List<IExp>) :
      val targs = Vector<Int>()
      val cargs = Vector<Int>()
      for e in es do :
         match(e) :
            (e:VarN) : add(targs, n(e))
            (e:ICap) : add(cargs, n!(name(e)))
      [to-list(targs), to-list(cargs)]

   ;     Transformers
   ;     ============
   defn #comm (e:IExp) -> False :
      match(e) :
         (e:IBegin) :
            #comm(exps(e))
         (e:IPublic) :
            #comm(exp(e))
         (e:IProtected) :
            #comm(exp(e))
         (e:IDefType) :
            add(hier, HSHEntry(c, args*, p)) where :
               val c = n!(class(e))
               val args* = n!(args(e))
               val p = #type(parent(e))
            for c in children(e) do :
               add(defchilds, #child(c as IDefChild))
         (e:IDef) :
            add-comm(destructure-def(e))
         (e:IDefVar) :
            add-comm(TDefVar(n, t, v, info(e))) where :
               val n = n!(name(e))
               val t = #type(type(e))
               val v = #exp(value(e)) when value(e) not-typeof INone
         (e:IDefn) :
            add-comm(#defn(e))
         (e:IDefmulti) :
            add-comm(TDefmulti(n, targs, cargs, a1*, a2*, inf)) where :
               val n = n!(name(e))
               val inf = info(e)
               val [targs, cargs] = split-targs(targs(e))
               val a1* = #type(a1(e))
               val a2* = #type(a2(e))
         (e:IDefmethod) :
            add-comm(#defmethod(e))
         (e:IFn|IMulti|IBegin|IMatch|IBranch|INew|
            VarN|ICast|IUpCast|ISet|IDo|IPrim|ILiteral|ITuple)  :
            add-comm(TInit(#exp(e), info(e)))
         (e:ILSDef) :
            val t = #lstype(type(e)) as LSType
            val exp = #lsexp(exp(e))
            add-comm(TLDef(n!(name(e)), t, exp, info(e)))
         (e:ILSDefVar) :
            val t = #lstype(type(e)) as LSType
            val v = #lsexp(exp(e)) when exp(e) not-typeof INone
            add-comm(TLDefVar(n!(name(e)), t, v, info(e)))
         (e:ILSDefType) :
            add(hier, LSHEntry(c, args*, p, fs, rf)) where :
               val c = n!(name(e))
               val args* = n!(args(e))
               val p = #type(parent(e))
               val fs = map(#field, fields(e), types(e))
               val rf = #field?(rfield(e), rtype(e))
         (e:ILSExtern) :
            val t = #lstype(type(e)) as LSType
            add-comm(TExtern(n!(name(e)), t, info(e)))
         (e:ILSDefn) :
            val [targs, cargs] = split-targs(targs(e))
            val a1* = #lstype(a1(e)) as List<LSType>
            val a2* = #lstype(a2(e)) as LSType
            val body* = #lscomm(body(e))
            val inf = info(e)
            add-comm(TLDefn(tail?(e), n!(name(e)), targs, cargs, a1*, a2*, n!(args(e)), body*, inf))            
         (e:ILSDefmethod) :
            val [targs, cargs] = split-targs(targs(e))
            val m = #exp(multi(e))
            val a1* = #lstype(a1(e)) as List<LSType>
            val a2* = #lstype(a2(e)) as LSType
            val body* = #lscomm(body(e))
            val inf = info(e)
            add-comm(TLDefmethod(tail?(e), fresh-id(), m, targs, cargs, a1*, a2*, n!(args(e)), body*, inf))            
         (e:ILSSet|ILSLabels|ILSLabel|ILSGoto|ILSReturn|ILSLet|
            ILSIf|ILSMatch|ILSBranch|ILSDef|ILSDefVar|
            ILSDo|ILSDoInStack|ILSDoStack|ILSPrim|ILSCallC) :
            add-comm(TLInit(#lscomm(e), info(e)))
         (e) :
            error("Unsupported form: ~" % [e])

   defn #child (e:IDefChild) :
      val n = n!(name(e))
      val args = n!(args(e))
      add(asserts, CorrectTArity(info(e), n, map(TVar, args)))
      DefChild(n, args, #type(parent(e)) as Type)

   defn #field (name:IExp, type:IExp) :
      val n = n!(name)
      val t = #lstype(type) as LSType
      Field(n!(name), #name(n), t)
   defn #field? (name:IExp, type:IExp) :
      #field(name, type) when name not-typeof INone

   defn #type (e:IExp) -> False|Type :
      defn #type! (e:IExp) : #type(e) as Type
      defn #type! (es:List<IExp>) : #type(es) as List<Type>
      match(e) :
         (e:ITuple) : TTuple(#type!(exps(e)))
         (e:IOf) :
            val n = n!(class(e))
            val targs = #type!(args(e))
            add(asserts, CorrectTArity(info(e), n, targs))
            TOf(n, TTuple(targs))
         (e:IAnd) : TAnd(#type!(a(e)), #type!(b(e)))
         (e:IOr) : TOr(#type!(a(e)), #type!(b(e)))
         (e:IArrow) : TArrow(TTuple(#type!(a1(e))), #type!(a2(e)))
         (e:ICap) : TCap(n!(name(e)))
         (e:IGradual) : TGradual()
         (e:IVoid) : TBot()
         (e:VarN) : TVar(n(e))
         (e:Raw) : TOf(n!(class(e)), TGradual())
         (e:INone) : false

   defn #exp (e:IExp) -> TExp :
      match(e) :
         (e:IFn) :
            TFn(tail?(e), a1*, a2*, ns, body, false, false, false, inf) where :
               val a1* = #type(a1(e))
               val a2* = #type(a2(e))
               val inf = info(e)
               val [ns, body] = destructure-args(args(e), body(e))
         (e:IMulti) :
            TMulti(fs, false, false, false, inf) where :
               val fs = #exp(funcs(e)) as List<TFn>
               val inf = info(e)
         (e:IBegin) :
            if empty?(tail(exps(e))) :
               #exp(head(exps(e)))
            else :
               TSeq(a*, b*, false, false, false, info(e)) where :
                  val a* = #exp(head(exps(e)))
                  val binfo = info(exps(e)[1])
                  val b* = #exp(IBegin(tail(exps(e)), binfo))
         (e:IMatch) :
            TMatch(args*, brs*, false, false, false, inf) where :
               val args* = #exp(args(e))
               val inf = info(e)
               val brs* = #exp(branches(e)) as List<TBranch>
         (e:IBranch) :
            TBranch(ns, ts, body, false, false, false, inf) where :
               val ts = #type(types(e))
               val inf = info(e)
               val [ns, body] = destructure-args(args(e), body(e))
         (e:INew) :
            TNew(c, ms, false, false, false, inf) where :
               val c = #type(class(e)) as Type
               val inf = info(e)
               val ms = #defmethod(methods(e) as List<IDefmethod>)
         (e:ICast) :
            TCast(e*, t*, false, false, false, inf) where :
               val e* = #exp(exp(e))
               val inf = info(e)
               val t* = #type(type(e)) as Type
         (e:IUpCast) :
            TUpCast(e*, t*, false, false, false, inf) where :
               val e* = #exp(exp(e))
               val inf = info(e)
               val t* = #type(type(e)) as Type
         (e:ISet) :
            TSet(r, v, false, false, false, inf) where :
               val r = #exp(name(e)) as TRef
               val inf = info(e)
               val v = #exp(value(e))
         (e:IDo) :
            TDo(f*, args*, false, false, false, inf) where :
               val f* = #farg(func(e))
               val inf = info(e)
               val args* = #exp(args(e))
         (e:IPrim) :
            TPrim(op, args*, false, false, false, inf) where :
               val op = primitive!(name!(op(e)))
               val inf = info(e)
               val args* = #exp(args(e))
         (e:ILiteral) :
            TLiteral(value(e), false, false, false, info(e))
         (e:ITuple) :
            TTupleExp(#exp(exps(e)), false, false, false, info(e))
         (e:ILet) :
            #exp(exp(e))
         (e:VarN) :
            TRef(n(e), false, false, false, info(e))
         (e:Mix) :
            TMix(false, #exp(exps(e)), false, false, false, info(e))            
         (e:Let) :
            destructure-let(e)
         (e:LetRec) :
            TLetRec(defns*, body*, false, false, false, inf) where :
               val defns* = #defn(defns(e) as List<IDefn>)
               val body* = #exp(body(e))
               val inf = info(e)
         (e:ISet) :
            TSet(#exp(name(e)) as TRef, #exp(value(e)), false, false, false, info(e))
         (e) :
            error("Unsupported expression: ~" % [e])

   defn #farg (e:IExp) -> TExp :
      match(e) :
         (e:IOf) :
            if empty?(args(e)) :
               #exp(class(e))
            else :
               val ts = #type(args(e)) as List<Type>
               defn #mix (e:IExp) :
                  match(e) :
                     (e:VarN) :
                        val ref = TRef(n(e), false, false, false, info(e))
                        TCurry(ref, ts, List(), false, false, false, info(e))
                     (e:Mix) :
                        TMix(false, map(#mix, exps(e)), false, false, false, info(e))
               #mix(class(e))
         (e) :
            #exp(e)

   defn #defn (def:IDefn) :
      TDefn(tail?(def), n, targs, cargs, a1*, a2*, args*, body*, inf) where :
         val n = n!(name(def))
         val inf = info(def)
         val [targs, cargs] = split-targs(targs(def))
         val a1* = #type(a1(def))
         val a2* = #type(a2(def))
         val [args*, body*] = destructure-args(args(def), body(def))


   defn #defmethod (def:IDefmethod) :
      TDefmethod(tail?(def), fresh-id(), m, thisn(def), targs, cargs, a1*, a2*, args*, body*, inf) where :
         val m = #exp(multi(def))
         val inf = info(def)
         val a1* = #type(a1(def))
         val a2* = #type(a2(def))
         val [targs, cargs] = split-targs(targs(def))
         val [args*, body*] = destructure-args(args(def), body(def))

   defn #lsexp (e:IExp) -> LSExp :
      match(e) :
         (e:ILSNew) :
            val [n, targ] = #lsclass(type(e))
            val inf = info(e)
            LSNew(n, targ, #lsexp(args(e)), false, false, false, inf)
         (e:ILSArray) :
            val [n, targ] = #lsclass(type(e))
            val inf = info(e)
            LSArray(n, targ, #lsexp(args(e)), #lsexp(length(e)), false, false, false, inf)
         (e:ILSStruct) :
            val [n, targ] = #lsclass(type(e))
            val inf = info(e)
            LSStruct(n, targ, #lsexp(args(e)), false, false, false, inf)
         (e:ILSAddr) :
            val inf = info(e)
            LSAddr(#lsexp(exp(e)), false, false, false, inf)
         (e:ILSDeref) :
            val inf = info(e)
            LSDeref(#lsexp(exp(e)), false, false, false, inf)
         (e:ILSSlot) :
            val inf = info(e)
            LSSlot(#lsexp(exp(e)), #lsexp(index(e)), false, false, false, inf)
         (e:ILSField) :
            val inf = info(e)
            LSField(#lsexp(exp(e)), name!(name(e)), false, false, false, inf)
         (e:ILSDo) :
            LSDo(f*, args*, false, false, false, inf) where :
               val f* = #lsfarg(func(e))
               val args* = #lsexp(args(e))
               val inf = info(e)
         (e:ILSDoInStack) :
            LSDoInStack(f*, args*, ret*, false, false, false, inf) where :
               val f* = #lsfarg(func(e))
               val args* = #lsexp(args(e))
               val ret* = #lstype(ret(e)) as LSType
               val inf = info(e)
         (e:ILSDoStack) :
            LSDoStack(f*, arg*, ret*, false, false, false, inf) where :
               val f* = #lsexp(func(e))
               val arg* = #lsexp(arg(e))
               val ret* = #lstype(ret(e)) as LSType
               val inf = info(e)
         (e:ILSCallC) :
            val inf = info(e)
            LSCallC(#lsexp(func(e)), #lsexp(args(e)), false, false, false, inf)
         (e:ILSPrim) :
            val op = ls-primitive!(name!(op(e)))
            val inf = info(e)
            LSPrim(op, #lsexp(args(e)), false, false, false, inf)
         (e:ILSSizeof) :
            val inf = info(e)
            val t = #lstype(type(e)) as LSType
            LSSizeof(t, false, false, false, inf)
         (e:ILSTagof) :
            val inf = info(e)
            LSTagof(n!(name(e)), false, false, false, inf)
         (e:ILSAs) :
            val inf = info(e)
            val t = #lstype(type(e)) as LSType
            LSCast(#lsexp(exp(e)), t, false, false, false, inf)
         (e:ILSAnd) :
            val inf = info(e)
            LSAnd(#lsexp(a(e)), #lsexp(b(e)), false, false, false, inf)
         (e:ILSOr) :
            val inf = info(e)
            LSOr(#lsexp(a(e)), #lsexp(b(e)), false, false, false, inf)
         (e:ILSLetExp) :
            val inf = info(e)
            LSLetExp(#lscomm(comm(e)), #lsexp(exp(e)), false, false, false, inf)
         (e:ILSFn) :
            val inf = info(e)
            LSFn(#exp(ref(e)), false, false, false, inf)
         (e:VarN) :
            val inf = info(e)
            LSVar(n!(e), false, false, false, inf)
         (e:ILiteral) :
            val inf = info(e)
            LSLiteral(value(e), false, false, false, inf)
         (e:Mix) :
            val inf = info(e)
            LSMix(false, map(#lsexp, exps(e)), false, false, false, inf)
         (e) :
            error("Not a LoStanza expression: ~" % [e])

   defn #lscomm (e:IExp) -> LSComm :
      match(e) :
         (e:IBegin) :
            if empty?(exps(e)) :
               LSSkip(info(e))
            else if empty?(tail(exps(e))) :
               #lscomm(head(exps(e)))
            else :
               val inf = info(exps(e)[1])
               LSSeq(
                  #lscomm(head(exps(e)))
                  #lscomm(IBegin(tail(exps(e)), inf))
                  info(e))
         (e:ILSSet) :
            val inf = info(e)
            LSSet(#lsexp(exp(e)), #lsexp(value(e)), inf)
         (e:ILSLabels) :
            val inf = info(e)
            LSLabels(n!(names(e)), #lscomm(body(e)), inf)
         (e:ILSLabel) :
            val inf = info(e)
            LSLabel(n!(name(e)), inf)
         (e:ILSGoto) :
            val inf = info(e)
            LSGoto(n!(name(e)), inf)
         (e:ILSReturn) :
            val inf = info(e)
            LSReturn(#lsexp(exp(e)), inf)
         (e:ILSLet) :
            #lscomm(comm(e))
         (e:ILSIf) :
            val inf = info(e)
            LSIf(#lsexp(pred(e)), #lscomm(conseq(e)), #lscomm(alt(e)), inf)
         (e:ILSMatch) :
            val args* = #lsexp(args(e))
            val bs = #lscomm(branches(e)) as List<LSBranch>
            val inf = info(e)
            LSMatch(args*, bs, inf)
         (e:ILSBranch) :
            val inf = info(e)
            LSBranch(n!(args(e)), #lstype(types(e)), #lscomm(body(e)), inf)
         (e:ILSDef) :
            val inf = info(e)
            LSDef(n!(name(e)), #lstype(type(e)), #lsexp(exp(e)), inf)
         (e:ILSDefVar) :
            val inf = info(e)
            val v = #lsexp(exp(e)) when exp(e) not-typeof INone
            val t = #lstype(type(e)) as LSType
            LSDefVar(n!(name(e)), t, v, inf)
         (e:ILSDo|ILSDoInStack|ILSDoStack|ILSPrim|ILSCallC) :
            val inf = info(e)
            LSCall(#lsexp(e), inf)

   defn #lsclass (e:IExp) :
      match(e) :
         (e:ILSOfT) : [n!(class(e)), TTuple(#type(args(e)) as List<Type>)]
         (e:Raw) : [n!(class(e)), TGradual()]

   defn #lsfarg (e:IExp) :
      match(e) :
         (e:ILSOfT) :
            if empty?(args(e)) :
               #lsexp(class(e))
            else :
               val ts = #type(args(e)) as List<Type>
               defn #mix (e:IExp) :
                  match(e) :
                     (e:VarN) :
                        val inf = info(e)
                        val ref = LSVar(n(e), false, false, false, inf)
                        LSCurry(ref, ts, List(), false, false, false, inf)
                     (e:Mix) :
                        val inf = info(e)
                        LSMix(false, map(#mix, exps(e)), false, false, false, inf)
               #mix(class(e))
         (e) :
            #lsexp(e)

   defn #lstype (e:IExp) -> False|LSType :
      defn #lstype! (e:IExp) : #lstype(e) as LSType
      defn #lstype! (es:List<IExp>) : #lstype(es) as List<LSType>
      defn #type! (e:IExp) : #type(e) as Type
      defn #type! (es:List<IExp>) : #type(es) as List<Type>
      match(e) :
         (e:ILSByteT) : ByteT()
         (e:ILSIntT) : IntT()
         (e:ILSLongT) : LongT()
         (e:ILSFloatT) : FloatT()
         (e:ILSDoubleT) : DoubleT()
         (e:ILSUnknownT) : UnknownT()
         (e:ILSOfT) :
            val n = n!(class(e))
            val targs = #type!(args(e))
            add(asserts, CorrectTArity(info(e), n, targs))
            StructT(n, TTuple(targs))
         (e:ILSPtrT) : PtrT(#lstype!(type(e)))
         (e:ILSRefT) : RefT(#type!(type(e)))
         (e:ILSFnT) : FnT(#lstype!(a1(e)), #lstype(ar(e)), #lstype!(a2(e)))
         (e:Raw) : StructT(n!(class(e)), TGradual())
         (e:INone) : false
         (e) : error("Not a LoStanza type: ~" % [e])

   ;     Nested Tuple Destructuring
   ;     ==========================
   defn destructure (args:List<IExp>, value:TExp) -> List<KeyValue<List<Int>, TExp>> :
      val [ns, bs] = destructure(args)
      List(ns => value, bs)

   defn destructure (args:List<IExp>) -> [List<Int>, List<KeyValue<List<Int>, TExp>>] :
      var bindings = List()
      defn #n (x:IExp) -> Int :
         match(x) :
            (x:ITuple) :
               val n = fresh-id()
               bindings = List(entry, bindings) where :
                  val exps* = map(#n, exps(x))
                  val entry = exps* => TRef(n, false, false, false, info(x))
               n
            (x) :
               n!(x)
      val ns = map(#n, args)
      [ns, bindings]

   defn destructure-args (args:List<IExp>, fbody:IExp) -> [List<Int>, TExp] :
      val [ns, bs] = destructure(args)
      var body = #exp(fbody)
      for b in bs do :
         body = TLetTuple(ns, ts, v, body, false, false, false, inf) where :
            val [ns, v] = [key(b), value(b)]
            val ts = map({false}, ns)
            val inf = info(v)
      [ns, body]

   defn destructure-def (def:IDef) -> List<TDef|TDefTuple> :
      match(name(def), type(def), value(def)) :
         (name:ITuple, type:INone, v) :
            val bs = destructure(exps(name), #exp(v))
            for b in bs map :
               TDefTuple(ns, ts, v, inf) where :
                  val [ns, v] = [key(b), value(b)]
                  val ts = map({false}, ns)
                  val inf = info(v)
         (name:ITuple, type, v) :
            val tmp = VarN(fresh-id(), info(name))
            append(
               destructure-def(IDef(tmp, type, v, info(name)))
               destructure-def(IDef(name, #IN, tmp, info(name))))
         (name, type, v) :
            list(TDef(n, t*, v*, inf)) where :
               val n = n!(name)
               val t* = #type(type)
               val v* = #exp(v)
               val inf = info(v)

   defn destructure-let (lete:Let) -> TExp :
      match(def(lete)) :
         (def:IDefVar) :
            val n = n!(name(def))
            val t = #type(type(def))
            val e = #exp(value(def)) when value(def) not-typeof INone
            val b = #exp(body(lete))
            val inf = info(def)
            TLetVar(n, t, e, b, false, false, false, inf)
         (def:IDef) :
            defn loop (defs:List<TDef|TDefTuple>) :
               if empty?(defs) :
                  #exp(body(lete))
               else :
                  val body = loop(tail(defs))
                  match(head(defs)) :
                     (e:TDef) : TLet(n(e), type(e), value(e), body, false, false, false, info(e))
                     (e:TDefTuple) : TLetTuple(ns(e), types(e), value(e), body, false, false, false, info(e))
            loop(destructure-def(def))

   ;     Error Reporting
   ;     ===============
   ;Check hierarchical cycles
   defn check-cycles () :
      defn classes (t:False|Type) -> List<Int> :
         match(t) :
            (t:TOf) : list(n(t))
            (t:TAnd) : append(classes(a(t)), classes(b(t)))
            (t:False) : list()
      val components = strong-components $
         for entry in hier stream :
            n(entry) => classes(parent(entry))
      val cycles =
         {_ as Stream<List<Int>>} $
         filter({_ typeof List}, components)
      for c in cycles do :
         defn msg (ns:List<Int>) :
            join{_, "\n"} $
            for n in ns stream :
               "   ~ at ~" << [#name(n), #info(n)]
         add-error("Illegal cycle in type hierarchy. The following types are parents of each other.\n~@" << [
            msg(c)])

   ;Check type arities
   defn check-arities () :
      for assert in asserts do :
         match(assert) :
            (a:CorrectTArity) :
               val arity = length(args(hier[n(a)]))
               if length(targs(a)) != arity :
                  add-error("~: Incorrect number of type parameters for type ~. Expecting ~ but given ~@." << [
                     info(a), #name(n(a)), arity, cms(#pr(targs(a)))])

   ;Report errors
   defn report-errors () :
      check-cycles()
      check-arities()
      if not empty?(errors) :
         do(println, errors)
         throw(TypeError())

   ;     Processing Children
   ;     ===================
   defn process-children () :
      defn tand (a:False|Type, b:Type) :
         match(a) :
            (a:False) : b
            (a:Type) : TAnd(a, b)
      defn add-parent (e:HEntry, p:Type) :
         match(e) :
            (e:HSHEntry) : HSHEntry(n(e), args(e), tand(parent(e), p))
            (e:LSHEntry) : LSHEntry(n(e), args(e), tand(parent(e), p), fields(e), rfield(e))
      for c in defchilds do :
         val e = hier[n(c)]
         val env = map({_ => TVar(_)}, args(c), args(e))
         val p = sub(parent(c), env)
         add(hier, add-parent(e, p))

   ;     Driver
   ;     ======
   #comm(e)
   report-errors()
   process-children()
   TProg(hier, to-list(accum))

;============================================================
;================= Primitives Types  ========================
;============================================================

;              HiStanza Callable Relation
;              ==========================

defn callable? (p:Primitive, args:List<Type>) -> True|False :
   val int-type = TOf(INT-TYPE-ID, TTuple(List()))
   defn int? (x:Type) :
      subtype?(x, int-type) as True|False
   defn two-ints? (args:List<Type>) :
      if length(args) == 2 :
         int?(args[0]) and int?(args[1])
   defn one-int? (args:List<Type>) :
      if length(args) == 1 :
         int?(head(args))

   switch {p == _} :
      ADD-OP : two-ints?(args)
      SUB-OP : two-ints?(args)
      MUL-OP : two-ints?(args)
      DIV-OP : two-ints?(args)
      MOD-OP : two-ints?(args)
      AND-OP : two-ints?(args)
      OR-OP : two-ints?(args)
      XOR-OP : two-ints?(args)
      SHL-OP : two-ints?(args)
      SHR-OP : two-ints?(args)
      ASHR-OP : two-ints?(args)
      EQ-OP : two-ints?(args)
      NE-OP : two-ints?(args)
      LT-OP : two-ints?(args)
      GT-OP : two-ints?(args)
      LE-OP : two-ints?(args)
      GE-OP : two-ints?(args)
      NOT-OP : one-int?(args)
      NEG-OP : one-int?(args)

;              LoStanza Callable Relation
;              ==========================

defn callable? (p:LSPrimitive, args:List<LSType>) -> True|False :
   defn matching-nums? () :
      match(args[0], args[1]) :
         (x:ByteT|IntT|LongT|FloatT|DoubleT, y:ByteT|IntT|LongT|FloatT|DoubleT) :
            (assignable?(x, y) == true) or (assignable?(y, x) == true)
         (x, y) : false
   defn matching-ints? () :
      match(args[0], args[1]) :
         (x:ByteT|IntT|LongT, y:ByteT|IntT|LongT) :
            (assignable?(x, y) == true) or (assignable?(y, x) == true)
         (x, y) : false
   defn binop-nums? () :
      (length(args) == 2) and
      matching-nums?()
   defn binop-ints? () :
      (length(args) == 2) and
      matching-ints?()
   defn binop-cmp? () :
      if length(args) == 2 :
         match(args[0], args[1]) :
            (x:PtrT, y:PtrT) : true
            (x, y) : matching-nums?()
   defn one-snum? () :
      if length(args) == 1 :
         args[0] typeof IntT|LongT|FloatT|DoubleT
   defn one-int? () :
      if length(args) == 1 :
         args[0] typeof ByteT|IntT|LongT
   defn one-fnum? () :
      if length(args) == 1 :
         args[0] typeof FloatT|DoubleT
   defn one-sint? () :
      if length(args) == 1 :
         args[0] typeof IntT|LongT

   match(p) :
      (p:GetterPrimitive) :
         empty?(args)
      (p:SetterPrimitive) :
         (length(args) == 1) and
         assignable?(head(args), type(p)) == true
      (p) :
         switch {p == _} :
            LS-ADD-OP :
               if length(args) == 2 :
                  match(args[0], args[1]) :
                     (x:PtrT, y) : assignable?(y, LongT()) == true
                     (x, y) : matching-nums?()
            LS-SUB-OP :
               if length(args) == 2 :
                  match(args[0], args[1]) :
                     (x:PtrT, y:PtrT) : true
                     (x:PtrT, y) : assignable?(y, LongT()) == true
                     (x, y) : matching-nums?()
            LS-MUL-OP : binop-nums?()
            LS-DIV-OP : binop-nums?()
            LS-MOD-OP : binop-ints?()
            LS-AND-OP : binop-ints?()
            LS-OR-OP : binop-ints?()
            LS-XOR-OP : binop-ints?()
            LS-SHL-OP : binop-ints?()
            LS-SHR-OP : binop-ints?()
            LS-ASHR-OP : binop-ints?()
            LS-EQ-OP :
               if length(args) == 2 :
                  match(args[0], args[1]) :
                     (x:PtrT, y:PtrT) : true
                     (x:RefT, y:RefT) : true
                     (x, y) : matching-nums?()
            LS-NE-OP :
               if length(args) == 2 :
                  match(args[0], args[1]) :
                     (x:PtrT, y:PtrT) : true
                     (x:RefT, y:RefT) : true
                     (x, y) : matching-nums?()
            LS-LT-OP : binop-cmp?()
            LS-GT-OP : binop-cmp?()
            LS-LE-OP : binop-cmp?()
            LS-GE-OP : binop-cmp?()
            LS-ULT-OP : binop-ints?()
            LS-UGT-OP : binop-ints?()
            LS-ULE-OP : binop-ints?()
            LS-UGE-OP : binop-ints?()
            LS-NOT-OP : one-int?()
            LS-NEG-OP : one-snum?()
            LS-BITS-OP : one-fnum?()
            LS-FNUM-OP : one-sint?()


;============================================================
;============== Generate Type Variables =====================
;============================================================
defstruct TupleF : ()
defstruct SubF : (ti:Type, t:Type)
defstruct ArgsF : ()
defstruct RetF : (n:Int)

definterface InstResult
definterface LSInstResult
defstruct Instantiated <: InstResult :
   cargs: List<TUVar>
   type: TArrow
   exp-type: TArrow
defstruct LSInstantiated <: LSInstResult :
   cargs: List<TUVar>
   type: FnT
   exp-type: FnT
defstruct WrongArity <: InstResult & LSInstResult
defstruct NotPoly <: InstResult & LSInstResult

defstruct Filler :
   fill-ctxt: Context -> Context
   fill-s: Selection -> Selection|False
   fill-t: Type -> Type|False
   fill-lt: LSType -> LSType|False
   fill-lc: LSComm -> LSComm
   fill-le: LSExp -> LSExp
   fill-e: TExp -> TExp
   fill-c: TComm -> TComm
   fill-prog: TProg -> TProg


defn infer-types (prog:TProg) :
   ;======== Environment ========
   val env = HashTable<Int,False|Type>({_})
   val ls-env = HashTable<Int, False|LSType>({_})
   val req-env = HashTable<Int, TUVar>({_})
   val constraints = Vector<Constraint>()
   var current-return-type : False|LSType = false

   ;          ==================================
   ;          ==   Type Variable Generation   ==
   ;          ==================================

   val #? = TGradual()
   val #ls? = UnknownT()
   val #fresh = Fresh()
   defn addc (c:Constraint) : add(constraints, c)
   defn #freshv () : TUVar(fresh-id())
   defn #freshv (n:Int) : map(#freshv{}, 0 to n)
   defn #ls-freshv () : UVarT(fresh-id())
   defn #ls-freshv (n:Int) : map(#ls-freshv{}, 0 to n)
   defn #or (x:False, y:False) : false
   defn #or (x:False, y:Type) : y
   defn #or (x:False, y:LSType) : y
   defn #or (x:False, y:Fresh) : #freshv()
   defn #or (x:Type, y:False) : y when x typeof TUVar else x
   defn #or (x:Type, y:Type) : y when x typeof TUVar else x
   defn #or (x:Type, y:Fresh) : #freshv() when x typeof TUVar else x
   defn #or (x:LSType, y:False) : y when x typeof UVarT else x
   defn #or (x:LSType, y:LSType) : y when x typeof UVarT else x
   defn #or (x:LSType, y:Fresh) : #freshv() when x typeof UVarT else x
   defn #or (xs:List<False|Type>, y:False) : map(#or{_, y}, xs)
   defn #or (xs:List<False|Type>, y:Type|Fresh) : map(#or{_, y}, xs)   
   defn #or (xs:List<False|Type>, ys:List<False|Type>) : map(#or, xs, ys)
   defn #or (xs:List<False|LSType>, ys:List<False|LSType>) : map(#or, xs, ys)
   defn set-req-env (n:Int, t:TUVar) : req-env[n] = t
   defn set-env (n:Int, t:False|Type) : env[n] = t
   defn set-env (ns:List<Int>, y:False|Type) : do(set-env{_, y}, ns)
   defn set-env (ns:List<Int>, ts:List<False|Type>) : do(set-env, ns, ts)
   defn set-ls-env (n:Int, t:False|LSType) : ls-env[n] = t
   defn set-ls-env (ns:List<Int>, ts:List<False|LSType>) : do(set-ls-env, ns, ts)
   defn bexp (es:List<TExp>, c:Context) : map(bexp{_, c}, es)
   defn bcomm<?T> (cs:List<?T&TComm>) : map(bcomm, cs)
   defn #types (es:List<TExp>) : map(type, es)
   defn #types (es:List<LSExp>) : map(type, es)
   defn #exp-types (es:List<TExp>) : map(exp-type, es)
   defn #exp-types (es:List<LSExp>) : map(exp-type, es)
   defn #V (t:False) : fail()
   defn #V (t:LSType) : t
   defn #V (t:Type) : t

   defn env-a1 (n:Int) :
      defn* loop (t:False|Type) :
         match(t) :
            (t:TPoly) : loop(func(t))
            (t:TArrow) : types(a(t) as TTuple)
      loop(env[n])

   defn env-a2 (n:Int) :
      defn* loop (t:False|Type) :
         match(t) :
            (t:TPoly) : loop(func(t))
            (t:TArrow) : b(t)
      loop(env[n])

   defn wrap-poly (t:TArrow, targs:List<Int>, cargs:List<Int>) :
      if empty?(targs) and empty?(cargs) : t
      else : TPoly(targs, cargs, t)

   defn fn-type (c:TDefmethod, thist:Type) :
      val a1* = for (t in a1(c), x in args(c)) map :
         if x == thisn(c) : thist
         else : #or(t, #?)
      val a2* = #or(a2(c), #fresh)
      val t = TArrow(TTuple(a1*), a2*)
      wrap-poly(t, targs(c), cargs(c))

   defn fn-type (c:TDefn|TDefmethod) :
      val t = TArrow(TTuple(a1*), a2*) where :
         val a1* = #or(a1(c), #?)
         val a2* = #or(a2(c), #fresh)
      wrap-poly(t, targs(c), cargs(c))

   defn fn-type (c:TDefmulti) :
      val t = TArrow(TTuple(a1*), a2*) where :
         val a1* = #or(a1(c), #?)
         val a2* = #or(a2(c), #?)
      wrap-poly(t, targs(c), cargs(c))

   defn fn-type (c:TLDefn|TLDefmethod) :
      val t = FnT(a1(c), false, a2(c))
      if empty?(targs(c)) and empty?(cargs(c)) : t
      else : PolyT(targs(c), cargs(c), t)

   defn to-hs-type (t:LSType) :
      match(t) :
         (t:RefT) : type(t)
         (t) : false

   ;======== Specialized Type Constructors ========
   defn lit-type (v) :
      defn base (n:Int) : TOf(n, TTuple(List()))
      defn raw (n:Int) : TOf(n, TGradual())
      match(v) :
         (v:Byte) : base(BYTE-TYPE-ID)
         (v:Char) : base(CHAR-TYPE-ID)
         (v:Int) : base(INT-TYPE-ID)
         (v:Long) : base(LONG-TYPE-ID)
         (v:Float) : base(FLOAT-TYPE-ID)
         (v:Double) : base(DOUBLE-TYPE-ID)
         (v:String) : base(STRING-TYPE-ID)
         (v:Symbol) : base(SYMBOL-TYPE-ID)
         (v:List) : raw(LIST-TYPE-ID)
         (v:True) : base(TRUE-TYPE-ID)
         (v:False) : base(FALSE-TYPE-ID)
         (v) : error("Unsupported literal type ~." % [v])

   defn ls-lit-type (v) :
      defn base (n:Int) : RefT(TOf(n, TTuple(List())))
      match(v) :
         (v:Byte) : ByteT()
         (v:Char) : ByteT()
         (v:Int) : IntT()
         (v:Long) : LongT()
         (v:Float) : FloatT()
         (v:Double) : DoubleT()
         (v:String) : PtrT(ByteT())
         (v:True) : base(TRUE-TYPE-ID)
         (v:False) : base(FALSE-TYPE-ID)
         (v) : error("Unsupported LoStanza literal ~." % [v])

   defn prim-type (op:Primitive) :
      defn base (n:Int) : TOf(n, TTuple(List()))
      val int-type = base(INT-TYPE-ID)
      val bool-type = TOr(base(TRUE-TYPE-ID), base(FALSE-TYPE-ID))
      switch {op == _} :
         ADD-OP : int-type
         SUB-OP : int-type
         MUL-OP : int-type
         DIV-OP : int-type
         MOD-OP : int-type
         AND-OP : int-type
         OR-OP : int-type
         XOR-OP : int-type
         SHL-OP : int-type
         SHR-OP : int-type
         ASHR-OP : int-type
         NOT-OP : int-type
         NEG-OP : int-type
         EQ-OP : bool-type
         NE-OP : bool-type
         LT-OP : bool-type
         GT-OP : bool-type
         LE-OP : bool-type
         GE-OP : bool-type
         else : error("Unrecognized primitive: ~" % [op])

   ;====== Environment Queries ======
   ;Return all possible types in e
   defn all-types (e:TExp) -> List<False|Type> :
      match(e) :
         (e:TLet) : all-types(body(e))
         (e:TLetVar) : all-types(body(e))
         (e:TLetTuple) : all-types(body(e))
         (e:TLetRec) : all-types(body(e))
         (e:TSeq) : all-types(b(e))
         (e:TBranch) : all-types(body(e))
         (e:TMatch) : map-append(all-types, branches(e))
         (e:TMix) : map-append(all-types, exps(e))
         (e) : list(exp-type(e))

   defn all-types (e:LSExp) -> List<False|LSType> :
      defn reft (t:False|Type) : RefT(t as Type) when t != false
      match(e) :
         (e:LSLetExp) : all-types(exp(e))
         (e:LSMix) : map-append(all-types, exps(e))
         (e:LSFn) : map(reft, all-types(ref(e)))
         (e) : list(exp-type(e))

   ;======== Build top level environment ========
   defn build-environment () :
      for c in comms(prog) do :
         match(c) :
            (c:TDef) :
               val t = #or(type(c), #fresh)
               set-env(n(c), t)
               set-ls-env(n(c), RefT(t))
            (c:TDefTuple) :
               val ts = map(#freshv{}, ns(c))
               set-env(ns(c), ts)
               set-ls-env(ns(c), map(RefT, ts))
            (c:TDefVar) :
               val t = #or(type(c), #fresh)
               set-env(n(c), t)
               set-ls-env(n(c), RefT(t))
            (c:TDefn) :
               val t = fn-type(c)
               set-env(n(c), t)
               set-ls-env(n(c), to-ls-fn(t))
            (c:TDefmulti) :
               val t = fn-type(c)
               set-env(n(c), t)
               set-ls-env(n(c), to-ls-fn(t))
            (c:TDefmethod) :
               set-env(n(c), fn-type(c))
            (c:TInit) :
               false
            (c:TLDef) :
               set-ls-env(n(c), type(c))
               set-env(n(c), to-hs-type(type(c)))
            (c:TLDefVar) :
               set-ls-env(n(c), type(c))
               set-env(n(c), to-hs-type(type(c)))
            (c:TLDefn) :
               val t = fn-type(c)
               set-ls-env(n(c), t)
               set-env(n(c), to-hs-fn(t))
            (c:TLDefmethod) :
               val t = fn-type(c)
               set-ls-env(n(c), t)
               set-env(n(c), to-hs-fn(t))
            (c:TExtern) :
               set-ls-env(n(c), type(c))
            (c:TLInit) :
               false

   ;======== Productions ========
   defn bcomm<?T> (c:?T&TComm) -> T :
      {_ as T&TComm} $ match(c) :
         (c:TDef) :
            val v* = bexp(value(c), CExp(#or(type(c), #?)))
            val t* = env[n(c)]
            #equal(t*, type(v*))
            TDef(n(c), t*, v*, info(c))
         (c:TDefTuple) :
            val v* = bexp(value(c), CExp(#?))
            val ts* = map({env[_] as TUVar}, ns(c))
            #downto(ts*, type(v*), TupleF())
            TDefTuple(ns(c), ts*, v*, info(c))
         (c:TDefVar) :
            val t* = env[n(c)]
            match(value(c)) :
               (v:False) :
                  TDefVar(n(c), t*, false, info(c))
               (v:TExp) :
                  val v* = bexp(v, CExp(#or(type(c), #?)))
                  #super(t*, type(v*))
                  TDefVar(n(c), t*, v*, info(c))
         (c:TDefn) :
            val a1* = env-a1(n(c))
            val a2* = env-a2(n(c))
            set-env(args(c), map(uncap, a1*))
            val body* = bexp(body(c), CExp(#or(a2(c), #?)))
            #equal(a2*, type(body*))
            TDefn(tail?(c), n(c), targs(c), cargs(c), a1*, a2*, args(c), body*, info(c))
         (c:TDefmulti) :
            val a1* = env-a1(n(c))
            val a2* = env-a2(n(c))
            TDefmulti(n(c), targs(c), cargs(c), a1*, a2*, info(c))
         (c:TDefmethod) :
            val a1* = env-a1(n(c))
            val a2* = env-a2(n(c))
            val t* = TArrow(uncap(TTuple(a1*)), a2*)
            val m* = bmulti(multi(c), map(TVar, targs(c)), CMulti(t*))
            set-env(args(c), map(uncap, a1*))
            val body* = bexp(body(c), CExp(#or(a2(c), #?)))
            #equal(a2*, type(body*))
            TDefmethod(tail?(c), n(c), m*, thisn(c), targs(c), cargs(c), a1*, a2*, args(c), body*, info(c))
         (c:TInit) :
            TInit(bexp(exp(c), CExp(#?)), info(c))
         (c:TLDef) :
            val e* = blsexp(value(c), CLSExp(type(c)))
            TLDef(n(c), type(c), e*, info(c))
         (c:TLDefVar) :
            val e* = blsexp(value(c) as LSExp, CLSExp(type(c))) when value(c) != false
            TLDefVar(n(c), type(c), e*, info(c))
         (c:TLDefn) :
            set-ls-env(args(c), map(uncap, a1(c)))
            val body* = let-var current-return-type = a2(c) :
               blscomm(body(c))
            TLDefn(tail?(c), n(c), targs(c), cargs(c), a1(c), a2(c), args(c), body*, info(c))
         (c:TLDefmethod) :
            val m* = match(env[n(c)]) :
               (t:False) :
                  multi(c)
               (t) : 
                  val a1* = env-a1(n(c))
                  val a2* = env-a2(n(c))
                  val t* = TArrow(uncap(TTuple(a1*)), a2*)
                  bmulti(multi(c), map(TVar, targs(c)), CMulti(t*))            
            set-ls-env(args(c), map(uncap, a1(c)))
            val body* = let-var current-return-type = a2(c) :
               blscomm(body(c))
            TLDefmethod(tail?(c), n(c), m*, targs(c), cargs(c), a1(c), a2(c), args(c), body*, info(c))            
         (c:TExtern) :
            c
         (c:TLInit) :
            TLInit(blscomm(comm(c)), info(c))

   defn bfn (e:TFn, c:Context) -> TFn :
      ;Type variables for arguments
      val a1* = #or(a1(e), #fresh)
      val req-a1* = #or(a1(e), #fresh)
      set-env(args(e), a1*)
      for (x in args(e), t* in req-a1*) do :
         set-req-env(x, t* as TUVar) when t* typeof TUVar
      ;Type variables for return
      val a2* = #or(a2(e), #freshv())
      val t* = TArrow(TTuple(a1*), a2*)
      val exp-t* = TArrow(TTuple(req-a1*), a2*)
      val body* = bexp(body(e), CExp(#or(a2(e), #freshv())))
      ;Constraints
      #equal(a2*, type(body*))
      ;Return new struct
      TFn(tail?(e), a1*, a2*, args(e), body*, t*, exp-t*, c, info(e))

   defn capfn (f:TFn, c:Context, ft:Type) :
      match(c) :
         (c:CExp) :
            ;Expected return type
            val exp-a2 = type(ctxt(body(f)) as CExp)
            #upto(exp-a2, type(c), SubF(a2(f) as Type, ft))
            ;Infer argument types
            for t in a1(f) do :
               #upto(t, type(c), SubF(t as Type, ft))
         (c:CDo) :
            ;Expected return type
            val exp-a2 = type(ctxt(body(f)) as CExp)
            #equal(exp-a2, ret(c))
            ;Infer argument types
            if length(args(f)) == length(args(c)) :
               #equal(a1(f), args(c))

   defn bexp (e:TExp, ctxt:Context) -> TExp :
      val c = ctxt as CDo|CExp
      match(e) :
         (e:TLet) :
            val v* = bexp(value(e), CExp(#or(ntype(e), #?)))
            val t* = #or(ntype(e), type(v*))
            set-env(n(e), t*)
            val body* = bexp(body(e), c)
            TLet(n(e), t*, v*, body*, type(body*), exp-type(body*), c, info(e))
         (e:TLetVar) :
            val t* = #or(ntype(e), #fresh)
            set-env(n(e), t*)
            val body* = bexp(body(e), c)
            match(value(e)) :
               (v:False) :
                  TLetVar(n(e), t*, false, body*, type(body*), exp-type(body*), c, info(e))
               (v:TExp) :
                  val v* = bexp(v, CExp(t*))
                  #super(t*, type(v*))
                  TLetVar(n(e), t*, v*, body*, type(body*), exp-type(body*), c, info(e))
         (e:TLetTuple) :
            val ts* = #freshv(length(ns(e)))
            val v* = bexp(value(e), CExp(#?))
            set-env(ns(e), ts*)
            val body* = bexp(body(e), c)
            #downto(ts*, type(v*), TupleF())
            TLetTuple(ns(e), ts*, v*, body*, type(body*), exp-type(body*), c, info(e))
         (e:TLetRec) :
            ;Define types for functions
            for def in defns(e) do :
               set-env(n(def), fn-type(def))
            val defns* = map(bcomm, defns(e))
            val body* = bexp(body(e), c)
            TLetRec(defns*, body*, type(body*), exp-type(body*), c, info(e))
         (e:TFn) :
            val f = bfn(e, c)
            capfn(f, c, type(f) as Type)
            f
         (e:TMulti) :
            val fs = map(bfn{_, c}, funcs(e))
            val mt = reduce(TAnd, #types(fs) as List<Type>)
            val exp-mt = reduce(TAnd, #exp-types(fs) as List<Type>)
            for f in fs do : capfn(f, c, mt)
            TMulti(fs, mt, exp-mt, c, info(e))
         (e:TSeq) :
            val a* = bexp(a(e), CExp(#?))
            val b* = bexp(b(e), c)
            TSeq(a*, b*, type(b*), exp-type(b*), c, info(e))
         (e:TMatch) :
            val args* = bexp(args(e), CExp(#?))
            val branches* = for b in branches(e) map :
               TBranch(args(b), atypes*, body*, type(body*), exp-type(body*), c, info(b)) where :
                  val atypes* = #or(atypes(b), #types(args*))
                  set-env(args(b), atypes*)
                  val body* = bexp(body(b), c)
            val t* = attempt: reduce(TOr, map(#V, #types(branches*)))
            val exp-t* = attempt: reduce(TOr, map(#V, #exp-types(branches*)))
            TMatch(args*, branches*, t*, exp-t*, c, info(e))
         (e:TNew) :
            ;Define types for methods
            for m in methods(e) do :
               set-env(n(m), fn-type(m, class(e)))
            val ms* = bcomm(methods(e))
            TNew(class(e), ms*, class(e), class(e), c, info(e))
         (e:TCurry) :
            val t = env[n(ref(e))]
            val e* = TRef(n(ref(e)), t, t, c, info(e))
            match(#instantiate(t, targs(e), type(c))) :
               (r:Instantiated) : TCurry(e*, targs(e), cargs(r), type(r), exp-type(r), c, info(e))
               (r:WrongArity) : TCurry(e*, targs(e), List(), false, false, c, info(e))
         (e:TRef) :
            val t = env[n(e)]
            val e* = TRef(n(e), t, t, c, info(e))
            val rt = get?(req-env, n(e), false)
            #super(rt, type(c))
            match(#instantiate(t, List(), type(c))) :
               (r:Instantiated) : TCurry(e*, List(), cargs(r), type(r), exp-type(r), c, info(e))
               (r:WrongArity) : TCurry(e*, List(), List(), false, false, c, info(e))
               (r:NotPoly) : e*
         (e:TCast) :
            val exp* = bexp(exp(e), CExp(#?))
            TCast(exp*, targ(e), targ(e), targ(e), c, info(e))
         (e:TUpCast) :
            val exp* = bexp(exp(e), CExp(targ(e)))
            TUpCast(exp*, targ(e), targ(e), targ(e), c, info(e))
         (e:TSet) :
            val ref* = bexp(ref(e), CExp(#?)) as TRef
            val v* = bexp(value(e), CExp(type(ref*)))
            #super(type(ref*), type(v*))
            TSet(ref*, v*, lit-type(false), lit-type(false), c, info(e))
         (e:TDo) :
            ;Variables
            val exp-a1* = #freshv(length(args(e)))
            val args* = map(bexp{_, CExp(_)}, args(e), exp-a1*)
            val fc = CDo(#types(args*), type(c), map(all-types, args*))
            val f* = bexp(func(e), fc)
            ;Expected argument types
            #downto(exp-a1*, exp-type(f*), ArgsF())
            ;Infer return type
            val a2* = #freshv()
            #downto(a2*, type(f*), RetF(length(args(e))))
            TDo(f*, args*, a2*, a2*, c, info(e))
         (e:TPrim) :
            val args* = bexp(args(e), CExp(#?))
            val t* = prim-type(op(e))
            TPrim(op(e), args*, t*, t*, c, info(e))
         (e:TLiteral) :
            val vt = lit-type(value(e))
            TLiteral(value(e), vt, vt, c, info(e))
         (e:TTupleExp) :
            val exp-ts* = #freshv(length(exps(e)))
            val exps* = map(bexp{_, CExp(_)}, exps(e), exp-ts*)
            val t* = attempt: TTuple(map(#V, #types(exps*)))
            val exp-t* = attempt: TTuple(map(#V, #exp-types(exps*)))
            #upto(exp-ts*, type(c), TupleF())
            TTupleExp(exps*, t*, exp-t*, c, info(e))
         (e:TMix) :
            val sv = SVar(fresh-id())
            val exps* = map(bexp{_, c}, exps(e))
            val t* = #freshv()
            val et* = #freshv()
            match(c) :
               (c:CExp) :
                  #partof(sv, #exp-types(exps*) as List<False|TArrow>, type(c))
                  #mix(t*, sv, #types(exps*) as List<False|TArrow>)
                  #mix(et*, sv, #exp-types(exps*) as List<False|TArrow>)
               (c:CDo) :
                  #callable(sv, #exp-types(exps*) as List<False|TArrow>, all-args(c))
                  #mix(t*, sv, #types(exps*) as List<False|TArrow>)
                  #mix(et*, sv, #exp-types(exps*) as List<False|TArrow>)
            TMix(sv, exps*, t*, et*, c, info(e))

   defn bmulti (e:TExp, targs*:List<TVar>, c:CMulti) -> TExp :
      match(e) :
         (e:TRef) :
            val t = env[n(e)]
            val e* = TRef(n(e), t, t, c, info(e))
            match(#instantiate(t, targs*, type(c))) :
               (r:Instantiated) : TCurry(e*, targs*, cargs(r), type(r), exp-type(r), c, info(e))
               (r:WrongArity) : TCurry(e*, targs*, List(), false, false, c, info(e))
               (r:NotPoly) : e*
         (e:TMix) :
            val sv = SVar(fresh-id())
            val exps* = map(bmulti{_, targs*, c}, exps(e))
            #select-multi(sv, type(c), #types(exps*) as List<False|TArrow>)
            TMix(sv, exps*, false, false, c, info(e))

   defn blscomm (c:LSComm) -> LSComm :
      match(c) :
         (c:LSCall) :
            LSCall(blsexp(exp(c), CLSExp(#ls?)), info(c))
         (c:LSSet) :
            LSSet(exp*, v*, info(c)) where :
               val exp* = blsexp(exp(c), CLSExp(#ls?))
               val v* = blsexp(value(c), CLSExp(type(exp*)))
         (c:LSLabels) :
            LSLabels(ns(c), blscomm(body(c)), info(c))
         (c:LSLabel) :
            c
         (c:LSGoto) :
            c
         (c:LSReturn) :
            val ret = current-return-type as LSType
            LSReturn(blsexp(exp(c), CLSExp(ret)), info(c))
         (c:LSDef) :
            LSDef(n(c), t*, v*, info(c)) where :
               val v* = blsexp(value(c), CLSExp(#or(type(c), #ls?)))
               val t* = #or(type(c), type(v*))
               set-ls-env(n(c), t*)
         (c:LSDefVar) :
            LSDefVar(n(c), type(c), v*, info(c)) where :
               val v* = blsexp(value(c) as LSExp, CLSExp(type(c))) when value(c) != false
               set-ls-env(n(c), type(c))
         (c:LSSeq) :
            LSSeq(blscomm(a(c)), blscomm(b(c)), info(c))
         (c:LSIf) :
            LSIf(pred*, conseq*, alt*, info(c)) where :
               val pred* = blsexp(pred(c), CLSExp(LongT()))
               val conseq* = blscomm(conseq(c))
               val alt* = blscomm(alt(c))
         (c:LSMatch) :
            val args* = map(blsexp{_, CLSExp(#ls?)}, args(c))
            val bs* = for b in branches(c) map :
               LSBranch(args(b), atypes*, body*, info(c)) where :
                  val atypes* = #or(atypes(b), #types(args*))
                  set-ls-env(args(b), atypes*)
                  val body* = blscomm(body(b))
            LSMatch(args*, bs*, info(c))
         (c:LSSkip) :
            c

   defn blsfields (n:Int, targ:Type, es:List<LSExp>) :
      val fts = match(field-types(n, targ)) :
         (fts:List<LSType>) : fts when length(fts) == length(es)
         (fts:False) : false
      match(fts) :
         (fts:List<LSType>) : map(blsexp{_, CLSExp(_)}, es, fts)
         (fts:False) : map(blsexp{_, CLSExp(false)}, es)            

   defn blsexp (e:LSExp, ctxt:Context) -> LSExp :
      val c = ctxt as CLSDo|CLSExp
      match(e) :
         (e:LSVar) :
            val t = ls-env[n(e)]
            val e* = LSVar(n(e), t, t, c, info(e))
            match(#instantiate(t, List(), type(c))) :
               (r:LSInstantiated) : LSCurry(e*, List(), cargs(r), type(r), exp-type(r), c, info(e))
               (r:WrongArity) : LSCurry(e*, List(), List(), false, false, c, info(e))
               (r:NotPoly) : e*
         (e:LSNew) :
            val t = RefT(TOf(n(e), targ(e)))
            val args* = blsfields(n(e), targ(e), args(e))
            LSNew(n(e), targ(e), args*, t, t, c, info(e))
         (e:LSArray) :
            val t = RefT(TOf(n(e), targ(e)))
            val args* = blsfields(n(e), targ(e), args(e))
            val len* = blsexp(length(e), CLSExp(LongT()))
            LSArray(n(e), targ(e), args*, len*, t, t, c, info(e))
         (e:LSStruct) :
            val t = StructT(n(e), targ(e))
            val args* = blsfields(n(e), targ(e), args(e))
            LSStruct(n(e), targ(e), args*, t, t, c, info(e))
         (e:LSAddr) :
            val c = CLSExp(#deptr(type(c)))
            val exp* = blsexp(exp(e), c)
            val t* = attempt: PtrT(#V(type(exp*)))
            val exp-t* = attempt: PtrT(#V(exp-type(exp*)))
            LSAddr(exp*, t*, exp-t*, c, info(e))
         (e:LSDeref) :
            val c = CLSExp(#ls?)
            val exp* = blsexp(exp(e), c)
            LSDeref(exp*, #deref(type(exp*)), #deref(exp-type(exp*)), c, info(e))
         (e:LSSlot) :
            val ptr-t = attempt: PtrT(#V(type(c)))
            val exp* = blsexp(exp(e), CLSExp(ptr-t))
            val ind* = blsexp(index(e), CLSExp(LongT()))
            LSSlot(exp*, ind*, #deref(type(exp*)), #deref(exp-type(exp*)), c, info(e))
         (e:LSField) :
            val exp* = blsexp(exp(e), CLSExp(#ls?))
            val t* = #field(type(exp*), name(e))
            LSField(exp*, name(e), t*, t*, c, info(e))
         (e:LSDo) :
            ;Variables
            val exp-a1* = #ls-freshv(length(args(e)))
            val args* = map(blsexp{_, CLSExp(_)}, args(e), exp-a1*)
            val fc = CLSDo(#types(args*), type(c), map(all-types, args*))
            val f* = blsexp(func(e), fc)
            ;Expected argument types
            #args(exp-a1*, exp-type(f*))
            ;Infer return type
            val t* = #ret(type(f*))
            LSDo(f*, args*, t*, t*, c, info(e))
         (e:LSDoInStack) :
            ;Variables
            val exp-a1* = #ls-freshv(length(args(e)))
            val args* = map(blsexp{_, CLSExp(_)}, args(e), exp-a1*)
            val fc = CLSDo(#types(args*), type(c), map(all-types, args*))
            val f* = blsexp(func(e), fc)
            ;Expected argument types
            #args(exp-a1*, exp-type(f*))
            ;Return type is given
            val t* = ret(e)
            LSDoInStack(f*, args*, ret(e), t*, t*, c, info(e))
         (e:LSDoStack) :
            val stack-type = RefT(TOf(STACK-TYPE-ID, TTuple(List())))
            val f* = blsexp(func(e), CLSExp(stack-type))
            val arg* = blsexp(arg(e), CLSExp(#ls?))
            val t* = ret(e)
            LSDoStack(f*, arg*, ret(e), t*, t*, c, info(e))
         (e:LSCallC) :
            ;Variables
            val exp-a1* = #ls-freshv(length(args(e)))
            val args* = map(blsexp{_, CLSExp(_)}, args(e), exp-a1*)
            val fc = CLSDo(#types(args*), type(c), map(all-types, args*))
            val f* = blsexp(func(e), fc)
            ;Expected argument types
            #args(exp-a1*, exp-type(f*))
            ;Infer return type
            val t* = #ret(type(f*))
            LSCallC(f*, args*, t*, t*, c, info(e))
         (e:LSPrim) :
            val args* = map(blsexp{_, CLSExp(false)}, args(e))
            val ret = #prim(op(e), #types(args*))
            LSPrim(op(e), args*, ret, ret, c, info(e))
         (e:LSSizeof) :
            LSSizeof(targ(e), LongT(), LongT(), c, info(e))
         (e:LSTagof) :
            LSTagof(n(e), LongT(), LongT(), c, info(e))
         (e:LSCast) :
            val exp* = blsexp(exp(e), CLSExp(#ls?))
            LSCast(exp*, targ(e), targ(e), targ(e), c, info(e))
         (e:LSLiteral) :
            val t = ls-lit-type(value(e))
            LSLiteral(value(e), t, t, c, info(e))
         (e:LSAnd) :
            defn blong (e:LSExp) : blsexp(e, CLSExp(LongT()))
            LSAnd(blong(a(e)), blong(b(e)), LongT(), LongT(), c, info(e))
         (e:LSOr) :
            defn blong (e:LSExp) : blsexp(e, CLSExp(LongT()))
            LSOr(blong(a(e)), blong(b(e)), LongT(), LongT(), c, info(e))
         (e:LSLetExp) :
            val comm* = blscomm(comm(e))
            val exp* = blsexp(exp(e), c)
            LSLetExp(comm*, exp*, type(exp*), exp-type(exp*), c, info(e))
         (e:LSMix) :
            val sv = SVar(fresh-id())
            val exps* = map(blsexp{_, c}, exps(e))
            val t* = #ls-freshv()
            val ct* = #ls-freshv()
            match(c) :
               (c:CLSExp) :
                  #select(sv, #exp-types(exps*) as List<False|FnT>, type(c))
                  #pick(t*, sv, #types(exps*) as List<False|FnT>)
                  #pick(ct*, sv, #exp-types(exps*) as List<False|FnT>)
               (c:CLSDo) :
                  #callable(sv, #exp-types(exps*) as List<False|FnT>, all-args(c))
                  #mix(t*, sv, #types(exps*) as List<False|FnT>)
                  #mix(ct*, sv, #exp-types(exps*) as List<False|FnT>)
            LSMix(sv, exps*, t*, ct*, c, info(e))
         (e:LSCurry) :
            val t = ls-env[n(ref(e))]
            val e* = LSVar(n(ref(e)), t, t, c, info(e))
            match(#instantiate(t, targs(e), type(c))) :
               (r:LSInstantiated) : LSCurry(e*, targs(e), cargs(r), type(r), exp-type(r), c, info(e))
               (r:WrongArity) : LSCurry(e*, targs(e), List(), false, false, c, info(e))
         (e:LSFn) :
            val ref* = bexp(ref(e), CExp(#ref-type(type(c))))
            defn reft (t:False|Type) : attempt: RefT(#V(t))
            LSFn(ref*, reft(type(ref*)), reft(exp-type(ref*)), c, info(e))


   ;             ===============================
   ;             ==   Constraint Generation   ==
   ;             ===============================

   ;===== Constraint Upward and Downward Propagators =====
   ;Propagate type upwards towards a subform
   defn #upto (r:False|Type, w:False|Type, f:SubF) :
      ;Substitute TUVar(n*) with t*, and all other TUVar with ?
      defn sub (t:Type, n*:Int, t*:Type) :
         match(t) :
            (t:TUVar) :
               if n(t) == n* : t*
               else : #?
            (t) : map(sub{_, n*, t*}, t)
      match(r, w, ti(f)) :
         (r:TUVar, w:Type, ti:TUVar) :
            val t* = sub(t(f), n(ti), TCap(n(r)))
            #cap(r, t*, w)
         (r, w, ti) :
            false

   ;Propagate type upwards towards elements of tuple form
   defn #upto (rs:List<TUVar>, w:False|Type, f:TupleF) :
      if w != false :
         val n = length(rs)
         for (r in rs, i in 0 to n) do :
            #cap(r, #tuple-cap(r, i, n), w as Type)

   ;Propagate type downwards towards elements of tuple form
   defn #downto (rs:List<TUVar>, w:False|Type, f:TupleF) :
      if w != false :
         val n = length(rs)
         for (r in rs, i in 0 to n) do :
            #cap(r, w as Type, #tuple-cap(r, i, n))

   ;Propagate type downwards towards arguments of function
   defn #downto (rs:List<TUVar>, w:False|Type, f:ArgsF) :
      if w != false :
         val n = length(rs)
         for (r in rs, i in 0 to n) do :
            val a1 = #tuple-cap(r, i, n)
            #cap(r, w as Type, TArrow(a1, #?))

   ;Propagate type downwards towards return of function
   defn #downto (r:TUVar, w:False|Type, f:RetF) :
      if w != false :
         val a = TTuple(map({#?}, 0 to n(f)))
         val b = TCap(n(r))
         #cap(r, w as Type, TArrow(a, b))

   ;===== Constraint Generation Utilities =====
   ;Create a new constraint variables
   defn make-ls-constraint-var (Constraint: Int -> Constraint) :
      val r = #ls-freshv()
      addc(Constraint(n(r)))
      r
   defn make-constraint-var (Constraint: Int -> Constraint) :
      val r = #freshv()
      addc(Constraint(n(r)))
      r

   ;Capture i'th element in m element tuple
   defn #tuple-cap (t:TUVar, i:Int, m:Int) :
      TTuple $ for j in 0 to m map :
         if j == i : TCap(n(t))
         else : #?

   ;Create supertype constraint
   defn #super (a:False|Type, b:False|Type) :
      match(a, b) :
         (a:TUVar, b:Type) : addc(SuperConstraint(n(a), b))
         (a, b) : false

   ;Create equality constraint
   defn #equal (ats:List<False|Type>, bts:List<False|Type>) :
      do(#equal, ats, bts)

   defn #equal (a:Type, b:False|Type) :
      match(a, b) :
         (a:TUVar, b:Type) : addc(EqualConstraint(n(a), b))
         (a, b) : false

   defn #equal (a:LSType, b:False|LSType) :
      match(a, b) :
         (a:UVarT, b:LSType) : addc(LSEqualConstraint(n(a), b))
         (a, b) : false

   defn #equal (a:False, b:False|LSType) :
      false

   ;Create capture constraint
   defn #cap (r:TUVar, x:Type, y:Type) :
      error("Invalid cap(~, ~)" % [x, y]) when (x typeof TPoly) or (y typeof TPoly) ;DEBUG
      addc(FlowConstraint(n(r), x, y))

   defn #cap (r:TUVar, x:LSType, y:LSType) :
      error("Invalid cap(~, ~)" % [x, y]) when (x typeof PolyT) or (y typeof PolyT) ;DEBUG
      addc(LSFlowConstraint(n(r), x, y))

   ;Create a partof constraint
   defn #partof (s:SVar, ats:List<False|TArrow>, bt:False|Type) :
      if bt != false :
         addc(PartofConstraint(n(s), ats, bt as Type))

   ;Create a callable constraint
   defn #callable (s:SVar, ats:List<False|TArrow>, args:List<List<False|Type>>) :
      val valid? = for xs in args all? :
                      for x in xs all? :
                         x != false
      if valid? :                   
         addc(CallableConstraint(n(s), ats, args as List<List<Type>>))

   defn #callable (s:SVar, ats:List<False|FnT>, args:List<List<False|LSType>>) :
      val valid? = for xs in args all? :
                      for x in xs all? :
                         x != false   
      addc(LSCallableConstraint(n(s), ats, args as List<List<LSType>>))

   ;Create a selection constraint
   defn #select (s:SVar, ats:List<False|FnT>, bt:False|LSType) :
      if bt != false :
         addc(LSSelConstraint(n(s), ats, bt as LSType))

   ;Create a multi selection constraint
   defn #select-multi (s:SVar, at:False|TArrow, bts:List<False|TArrow>) :
      if at != false :
         addc(SelMultiConstraint(n(s), at as TArrow, bts))

   ;Create a substitution constraint
   defn #sub (t:Type, env:List<KeyValue<Int,Type>>) :
      make-constraint-var(SubConstraint{_, t, env})

   ;Create a mixture constraint
   defn #mix (t:TUVar, s:SVar, ats:List<False|TArrow>) :
      addc(MixConstraint(n(t), n(s), ats))

   defn #mix (t:UVarT, s:SVar, ats:List<False|FnT>) :
      addc(LSMixConstraint(n(t), n(s), ats))

   ;Create a pick constraint
   defn #pick (t:UVarT, s:SVar, xs:List<False|FnT>) :
      addc(LSPickConstraint(n(t), n(s), xs))

   ;Isolate a single capture variable
   defn isolate-cap (n*:Int, t:Type) :
      match(t) :
         (t:TCap) :
            if n(t) == n* : t
            else : TUVar(n(t))
         (t) : map(isolate-cap{n*, _}, t)
   defn isolate-cap (n*:Int, t:LSType) :
      mapr(isolate-cap{n*, _}, t)

   ;Relax captures in a type
   defn relax-cap (t:Type) :
      match(t) :
         (t:TCap) : TGradual()
         (t) : map(relax-cap, t)
   defn relax-cap (t:LSType) :
      mapr(relax-cap, t)

   ;Instantiate a polymorphic type with the given type arguments
   ;Returns [Instantiated Captured Args, Instantiated Type, Relaxed Type]
   ;Instantiated type contains unification variables for captured args.
   ;Relaxed type contains graduals in place of captured args
   defn #instantiate (t:Type, targs*:List<Type>, w:False|Type) -> InstResult :
      match(t) :
         (t:TPoly) :
            if length(targs(t)) == length(targs*) :
               val cargs* = #freshv(length(cargs(t)))
               val env = map(KeyValue,
                             append(targs(t), cargs(t))
                             append(targs*, cargs*))
               val a1* = sub(uncap(a(func(t))), env)
               val a2* = #sub(b(func(t)), env)
               val t* = TArrow(a1*, a2*)
               val cap-a1* = sub(a(func(t)), env)
               val cap-t* = TArrow(cap-a1*, a2*)
               if w != false :
                  for v in cargs* do :
                     #cap(v, isolate-cap(n(v), cap-t*), w as Type)
               Instantiated(cargs*, t*, relax-cap(cap-t*) as TArrow)
            else : WrongArity()
         (t) :
            if empty?(targs*) : NotPoly()
            else : WrongArity()

   defn #instantiate (t:LSType, targs*:List<Type>, w:False|LSType) -> LSInstResult :
      match(t) :
         (t:PolyT) :
            if length(targs(t)) == length(targs*) :
               val cargs* = #freshv(length(cargs(t)))
               val env = map(KeyValue,
                             append(targs(t), cargs(t))
                             append(targs*, cargs*))
               val a* = map(sub{uncap(_), env}, a(func(t)))
               val r* = attempt: sub(uncap(#V(r(func(t)))), env)
               val b* = sub(b(func(t)), env)
               val t* = FnT(a*, r*, b*)
               val cap-a* = map(sub{_, env}, a(func(t)))
               val cap-r* = attempt: sub(#V(r(func(t))), env)
               val cap-t* = FnT(cap-a*, cap-r*, b*)
               if w != false :
                  for v in cargs* do :
                     #cap(v, isolate-cap(n(v), cap-t*), w as LSType)
               LSInstantiated(cargs*, t*, relax-cap(cap-t*) as FnT)
            else : WrongArity()
         (t) :
            if empty?(targs*) : NotPoly()
            else : WrongArity()

   defn #instantiate (t:False, targs*:List<Type>, w:False|LSType|Type) :
      NotPoly()

   ;Create an arguments constraint
   defn #arg (r:UVarT, t:False|LSType, i:Int, arity:Int) :
      if t != false :
         addc(ArgConstraint(n(r), t as LSType, i, arity))
   defn #args (rs:List<UVarT>, t:False|LSType) :
      val n = length(rs)
      for (r in rs, i in 0 to false) do :
         #arg(r, t, i, n)

   ;LS Constraints
   defn #deptr (t:False|LSType) :
      attempt: make-ls-constraint-var(DeptrConstraint{_, #V(t)})
   defn #deref (t:False|LSType) :
      attempt: make-ls-constraint-var(DerefConstraint{_, #V(t)})
   defn #field (t:False|LSType, name:Symbol) :
      attempt: make-ls-constraint-var(FieldConstraint{_, #V(t), name})
   defn #ret (t:False|LSType) :
      attempt: make-ls-constraint-var(RetConstraint{_, #V(t)})
   defn #prim (op:LSPrimitive, args:List<False|LSType>) :
      attempt: make-ls-constraint-var(LSPrimConstraint{_, op, map(#V,args)})
   defn #ref-type (t:False|LSType) :
      attempt: make-constraint-var(RefTypeConstraint{_, #V(t)})


   ;               Fill Results
   ;               ============
   defn filler (results:SolveResults) :
      ;   Track the type variables currently in scope
      ;   -------------------------------------------
      var tvars-in-scope:List<Int> = List()
      defn in-scope? (t:Type) :
         match(t) :
            (t:TVar) : contains?(tvars-in-scope, n(t))
            (t) : all?(in-scope?, children(t))
      defn in-scope? (t:LSType) :
         match(t) :
            (t:RefT) : in-scope?(type(t))
            (t:StructT) : in-scope?(type(t))
            (t) : all?(in-scope?, children(t))
      defn with-targs<?T> (c:TComm, f: () -> ?T) :
         defn use-targs (xs:List<Int>) :
            let-var tvars-in-scope = append(xs, tvars-in-scope) :
               f()
         match(c) :
            (c:TDefn|TDefmethod|TLDefn|TLDefmethod) :
               use-targs(append(targs(c), cargs(c)))
            (c) : f()

      ;   Smart Mapper
      ;   ------------
      defn map? (f:Type -> Type|False, c:TComm) :
         match(c) :
            (c:TDefn) :
               val a2* = f(a2(c) as Type) when a2(c) != false
               TDefn(tail?(c), n(c), targs(c), cargs(c), a1(c), a2*, args(c), body(c), info(c))
            (c:TDefmulti) :
               c
            (c:TDefmethod) :
               val a2* = f(a2(c) as Type) when a2(c) != false
               TDefmethod(tail?(c), n(c), multi(c), thisn(c), targs(c), cargs(c), a1(c), a2*, args(c), body(c), info(c))
            (c) : map(f, c)

      ;   Filling Functions
      ;   -----------------
      defn fill-ctxt (c:Context) -> Context :
         map(fill-lt, map(fill-t, c))
      defn fill-s (s:Selection) -> False|Selection :
         match(s) :
            (s:SVar) : get?(sels(results), n(s), false)
            (s) : s
      defn fill-t! (t:Type) -> Type :
         match(t) :
            (t:TUVar) :
               match(get?(types(results), n(t), false)) :
                  (t:Type) : t when in-scope?(t) else fail()
                  (t:False) : fail()
            (t) : map(fill-t!, t)
      defn fill-lt! (t:LSType) -> LSType :
         match(t) :
            (t:UVarT) :
               match(get?(lstypes(results), n(t), false)) :
                  (t:LSType) : t when in-scope?(t) else fail()
                  (t) : fail()
            (t) : map(fill-lt!, map(fill-t!, t))               
      defn fill-t (t:Type) -> False|Type :
         attempt: simplify(fill-t!(t))
      defn fill-lt (t:LSType) -> False|LSType :
         attempt: fill-lt!(t)
      defn fill-lc (c:LSComm) :         
         map{fill-lt, _} $
         map{fill-lc, _} $
         map{fill-le, _} $
         c
      defn fill-le (e:LSExp) :
         map{fill-t, _} $
         map{fill-lc, _} $
         map{fill-le, _} $
         map{fill-lt, _} $
         map{fill-e, _} $
         map{fill-s, _} $
         map{fill-ctxt, _} $
         e
      defn fill-e (e:TExp) -> TExp :            
         map{fill-t, _} $
         map{fill-e, _} $
         map{fill-c, _} $
         map{fill-ctxt, _} $
         map{fill-s, _} $
         e
      defn fill-c (c:TComm) -> TComm :
         with-targs{c, _} $ fn* () :
            map{fill-le, _} $
            map{fill-lc, _} $
            map{fill-e, _} $
            map?{fill-t, _} $
            c
      defn fill-prog (p:TProg) :
         TProg(hier(p),
               map(fill-c, comms(p)))
      Filler(fill-ctxt, fill-s, fill-t, fill-lt,
             fill-lc, fill-le, fill-e, fill-c, fill-prog)

   ;                 Driver
   ;                 ======
   build-environment()
   val prog* = TProg(hier(prog), bcomm(comms(prog)))
   println("Generated type variables")
   println(prog*)

   val f = filler(solve(constraints))
   val fprog = fill-prog(f)(prog*)
   for entry in env do :
      attempt: env[key(entry)] = fill-t(f)(#V(value(entry)))
   for entry in ls-env do :
      attempt: ls-env[key(entry)] = fill-lt(f)(#V(value(entry)))
   [fprog, env, ls-env]

;============================================================
;=================== Print a Type ===========================
;============================================================
defn cms (xs:Streamable) : join(xs, ", ")

defn printable (nm:NameMap, t:Type) :
   defn #name (n:Int) : name(nm[n])
   defn #carg (n:Int) : "?~" << [#name(n)]
   defn lvl (t:Type) :
      match(t) :
         (t:TArrow|TPoly) : 0
         (t:TOr) : 1
         (t) : 2

   defn p0 (t:Type) : pt(t, 0)
   defn p0 (ts:List<Type>) : stream(p0, ts)
   defn pt (t:Type, l:Int) :
      defn pn (t2:Type) : pt(t2, lvl(t))
      defn p+ (t2:Type) : pt(t2, lvl(t) + 1)

      val r = match(t) :
         (t:TArrow) :
            match(a(t)) :
               (a:TTuple) :
                  if length(types(a)) == 1 : "~ -> ~" << [p+(head(types(a))), pn(b(t))]
                  else : "(~@) -> ~" << [cms(p0(types(a))), pn(b(t))]
               (a:TGradual) : "(? ...) -> ~" << [pn(b(t))]
         (t:TPoly) :
            val ts = concat(stream(#name, targs(t)), stream(#carg, cargs(t)))
            val f = pn(func(t))
            "<~@> . ~" << [cms(ts), f]
         (t:TOr) :
            "~|~" << [pn(a(t)), pn(b(t))]
         (t:TAnd) :
            "~&~" << [pn(a(t)), pn(b(t))]
         (t:TOf) :
            match(type(t)) :
               (ta:TTuple) :
                  if empty?(types(ta)) : #name(n(t))
                  else : "~<~@>" << [#name(n(t)), cms(p0(types(ta)))]
               (ta:TGradual) :
                  #name(n(t))
         (t:TGradual) :
            "?"
         (t:TBot) :
            "Void"
         (t:TVar) :
            #name(n(t))
         (t:TUVar) :
            "UK"
         (t:TCap) :
            #carg(n(t))
         (t:TTuple) :
            "[~@]" << [cms(p0(types(t)))]
      if lvl(t) < l : "(~)" << [r]
      else : r
   p0(t)

defn printable (nm:NameMap, t:LSType) :
   defn #pr (t:LSType) : printable(nm, t)
   defn #pr (t:Type) : printable(nm, t)
   defn #pr (ts:Streamable<LSType>) : stream(#pr, ts)
   defn #pr (ts:Streamable<Type>) : stream(#pr, ts)
   defn #ap (ts:Streamable<LSType>, t:LSType) : concat(ts, [t])
   defn #name (n:Int) : name(nm[n])
   defn #carg (n:Int) : "?~" << [#name(n)]
   match(t) :
      (t:ByteT) : "byte"
      (t:IntT) : "int"
      (t:LongT) : "long"
      (t:FloatT) : "float"
      (t:DoubleT) : "double"
      (t:UnknownT) : "?"
      (t:UVarT) : "UK"
      (t:PtrT) : "ptr<~>" << [#pr(type(t))]
      (t:RefT) : "ref<~>" << [#pr(type(t))]
      (t:FnT) :
         match(r(t)) :
            (r:False) : "(~@) -> ~" << [cms(#pr(a(t))), #pr(b(t))]
            (r:LSType) : "(~@ ...) -> ~" << [cms(#pr(#ap(a(t), r))), #pr(b(t))]
      (t:PolyT) :
         val ts = concat(stream(#name, targs(t)), stream(#carg, cargs(t)))
         "<~@> . ~" << [cms(ts), #pr(func(t))]
      (t:StructT) :
         match(type(t)) :
            (ta:TTuple) :
               if empty?(types(ta)) : #name(n(t))
               else : "~<~@>" << [#name(n(t)), cms(#pr(types(ta)))]
            (ta:TGradual) :
               #name(n(t))


;============================================================
;=================== Report Errors ==========================
;============================================================

defn report-errors (nm:NameMap,
                    prog:TProg,
                    env:HashTable<Int,False|Type>,
                    ls-env:HashTable<Int, False|LSType>) :
                    
   ;              Error Buffer
   ;              ============
   val errors = Vector<?>()

   defn add-error (msg) :
      val msg* = to-string(msg)
;      println("ADDED ERROR: ~" << [msg*])
      add(errors, msg*)

   ;              Track Current Return Type
   ;              =========================
   var current-return-type : False|LSType = false

   ;               Error Predicates
   ;               ================
   defn #V (f:False) : fail()
   defn #V (t:Type) : t
   defn #V (t:LSType) : t
   defn #V (s:Selection) : s as SSel

   defn false? (x:False|Type|LSType) : x typeof False

   defn not-st? (x:Type, y:Type) :
      subtype?(x, y) == false
   defn not-st? (x:LSType, y:LSType) :
      subtype?(x, y) == false

   defn not-tuple? (t:Type) :
      val tuple-t = TOf(TUPLE-TYPE-ID, TTuple(list(TGradual())))
      not-st?(t, tuple-t)

   defn not-func? (t:Type) :
      val func-t = TArrow(TGradual(), TGradual())
      not-st?(t, func-t)

   defn cant-call? (t:Type, ats:List<Type>) :
      val func-t = TArrow(TTuple(ats), TGradual())
      not-st?(t, func-t)
   
   defn not-assign? (x:LSType, y:LSType) :
      assignable?(x, y) == false
      
   defn not-callable? (x:FnT, ys:List<LSType>) :
      callable?(x, ys) == false

   defn not-sm? (x:TArrow, y:TArrow) :
      submethod?(x, y) == false

   defn ref? (t:LSType) :
      t typeof RefT

   defn not-refs? (ts:List<LSType>) :
      not all?(ref?, ts)

   defn not-func? (t:LSType) :
      t not-typeof FnT

   defn not-stack? (t:LSType) :
      val stack-t = RefT(TOf(STACK-TYPE-ID, TTuple(List())))
      not-assign?(t, stack-t)

   defn not-long? (t:LSType) :
      not-assign?(t, LongT())

   defn no-size? (t:LSType) :
      t typeof UnknownT|FnT

   defn all-pairs<?T> (xs:Streamable<?T>) :
      val xs* = to-array(xs)
      generate<[T, T]> :
         for i in 0 to length(xs*) do :
            for j in (i + 1) to length(xs*) do :
               yield([xs*[i], xs*[j]])

   defn disjoint? (ts:List<TArrow>, u:Type) :
      for [x, y] in all-pairs(ts) all? :
         disjoint-fns?(x, y, u)

   defn disjoint? (ts:List<FnT>, u:LSType) :
      for [x, y] in all-pairs(ts) all? :
         disjoint-fns?(x, y, u)

   defn tarity (t:Type) :
      match(t) :
         (t:TArrow) : 0
         (t:TPoly) : length(targs(t))

   defn tarity (t:LSType) :
      match(t) :
         (t:FnT) : 0
         (t:PolyT) : length(targs(t))

   defn ls-def? (n:Int) :
      type(nm[n]) typeof LFnE|LVarE|LValE

   defn mutable? (n:Int) :
      type(nm[n]) typeof VarE|LVarE

   defn lvalue? (e:LSExp) :
      match(e) :
         (e:LSVar) :
            mutable?(n(e))
         (e:LSDeref|LSSlot) :
            true
         (e:LSField) :
            ;Does it expand to an addr(...) expression?
            defn addr? (t:LSType) :
               match(t) :
                  (t:StructT) : rest-field?(n(t), name(e))
                  (t:PtrT) : addr?(type(t))
                  (t:RefT) : addr?(to-ls-type(type(t)) as LSType)
            if not addr?(type(exp(e)) as LSType) :
               match(type(exp(e))) :
                  (t:PtrT|RefT) : true
                  (t:StructT) : lvalue?(exp(e))
         (e) : false

   defn wrong-tarity? (n:Int, targ:Type) :
      match(targ) :
         (targ:TGradual) : false
         (targ:TTuple) : length(types(targ)) != type-tarity(n)

   defn select<?T> (xs:List<?T>, ss:SSel) :
      to-list $ for (x in xs, s in sels(ss)) filter :
         s != false

   ;               Tree Walker
   ;               ===========

   defn check (c:TComm) :
      check(c, false)

   defn check (c:TComm, top?:True|False) :
;      println("check(~, ~)" << [c, top?])
;      indented $ fn () :
      
      ;Continue recursion
      defn check-subexps () :
         do(check{_:TExp}, c)
         do(check{_:LSExp}, c)
         do(check{_:LSComm}, c)

      match(c) :
         (c:TDef) :
            check-subexps()
            attempt :
               bad-assign(c) when not-st?(#V(type(value(c))), #V(type(c)))
            no-inferred-type(c) when top? and false?(type(c))
         (c:TDefTuple) :
            check-subexps()   
            attempt :
               not-tuple(c) when not-tuple?(#V(type(value(c))))
               bad-detuple(c) when any?(false?, types(c))
            no-inferred-type(c) when top? and any?(false?, types(c))
         (c:TDefVar) :
            check-subexps()
            attempt :
               if value(c) != false :
                  val vt = #V(type(value(c) as TExp))
                  bad-assign(c) when not-st?(vt, #V(type(c)))
            no-inferred-type(c) when false?(type(c))                              
         (c:TDefn) :
            attempt :
               val bt = #V(type(body(c)))
               bad-ret(c) when not-st?(bt, #V(a2(c)))
            check-subexps()   
            no-inferred-ret(c) when false?(a2(c))
         (c:TDefmethod) :
            ;Check method overriding
            attempt :
               val mt = #V(type(ctxt(multi(c)) as CMulti))
               check-multi(multi(c), mt as TArrow)
            ;Check body   
            check(body(c))
            ;Check return type
            attempt :
               val bt = #V(type(body(c)))
               bad-ret(c) when not-st?(bt, #V(a2(c)))
         (c:TLDef) :
            check-subexps()
            attempt :
               val vt = #V(type(value(c)))
               bad-assign(c) when not-assign?(vt, type(c))
            unbound-def(c) when not bounded?(type(c))
         (c:TLDefVar) :
            check-subexps()
            attempt :
               if value(c) != false :
                  val vt = #V(type(value(c) as LSExp))
                  bad-assign(c) when not-assign?(vt, type(c))
            unbound-def(c) when not bounded?(type(c))
         (c:TLDefmethod) :
            ;Check method overriding
            attempt :
               val mt = #V(type(ctxt(multi(c)) as CMulti))
               check-multi(multi(c), mt as TArrow)
            ;Check type signature               
            bad-ls-method(c) when false?(env[n(c)])
            ;Check body
            let-var current-return-type = a2(c) :
               check(body(c))
         (c:TLDefn) :
            let-var current-return-type = a2(c) :
               check(body(c))
         (c) :
            check-subexps()

   defn check-multi (e:TExp, mt:TArrow) :
;      println("check-multi(~, ~)" << [e, mt])
;      indented $ fn () :
      match(e) :
         (e:TRef) :
            match(type(e)) :
               (t:TArrow) : bad-method(e) when not-sm?(mt, t)
               (t) : bad-method(e)
         (e:TMix) :
            attempt :
               val exps* = select(exps(e), #V(sel(e)))
               val n = length(exps*)
               switch {n == _} :
                  0 : no-method(e)
                  1 : check-multi(head(exps*), mt)
                  else : amb-method(e)
         (e:TCurry) :
            ;Check submethod
            attempt :
               match(#V(type(e))) :
                  (t:TArrow) : bad-method(e) when not-sm?(mt, t)
                  (t:Type) : bad-method(e)
            ;Check targ arity
            val arity = tarity(type(ref(e)) as Type)
            bad-tarity(e) when arity != length(targs(e))
            ;Check carg captures
            bad-capture(e) when any?(false?, cargs(e))

   defn check (e:TExp) :
;      println("check(~)" << [e])
;      indented $ fn () :
      
      ;Check subexpressions
      defn check-subexps () :
         do(check{_:TExp}, e)
         do(check{_:TComm}, e)
      
      ;Check constraints
      match(e) :
         (e:TLet) :          
            check-subexps()
            attempt :
               val vt = #V(type(value(e)))
               bad-assign(e) when not-st?(vt, #V(ntype(e)))
         (e:TLetVar) :
            check-subexps()
            no-inferred-type(e) when false?(ntype(e))
            attempt :
               if value(e) != false :
                  val vt = #V(type(value(e) as TExp))
                  bad-assign(e) when not-st?(vt, #V(ntype(e)))
         (e:TLetTuple) :
            check-subexps()
            attempt :
               not-tuple(e) when not-tuple?(#V(type(value(e))))
               bad-detuple(e) when any?(false?, ntypes(e))
         (e:TFn) :
            ;Check inferred arguments
            no-inferred-args(e) when any?(false?, a1(e))
            ;Check body
            check-subexps()
            ;Check return type
            attempt :
               val bt = #V(type(body(e)))
               bad-ret(e) when not-st?(bt, #V(a2(e)))
         (e:TMatch) :
            attempt :
               val arg-ts = map(#V{type(_)}, args(e))
               for b in branches(e) do :
                  val bts = map(#V, atypes(b))
                  if not all?(overlap?, arg-ts, bts) :
                     bad-branch(e, b)
            check-subexps()         
         (e:TCast) :
            check-subexps()   
            attempt :
               val et = #V(type(exp(e)))
               bad-cast(e) when not overlap?(et, targ(e))
         (e:TUpCast) :
            check-subexps()
            attempt :
               val et = #V(type(exp(e)))
               bad-upcast(e) when not-st?(et, targ(e))
         (e:TSet) :
            check-subexps()
            attempt :
               val vt = #V(type(value(e)))
               val rt = #V(type(ref(e)))
               bad-set(e) when not-st?(vt, rt)
         (e:TDo) :
            check-subexps()
            attempt :
               val ft = #V(type(func(e)))
               if not-func?(ft) :
                  not-function(e)
               else :
                  val ats = map(#V{type(_)}, args(e))
                  bad-call(e) when cant-call?(ft, ats)
         (e:TPrim) :
            check-subexps()
            attempt :
               val ats = map(#V{type(_)}, args(e))
               bad-prim(e) when not callable?(op(e), ats)
         (e:TMix) :
            attempt :
               val exps* = select(exps(e), #V(sel(e)))
               val n = length(exps*)
               switch {n == _} :
                  0 : no-mix(e)
                  1 : check(head(exps*))
                  else :
                     val ts = map({#V(type(_)) as TArrow}, exps*)
                     val ct = #V(type(ctxt(e) as CExp|CDo))
                     if disjoint?(ts, ct) : do(check, exps*)
                     else : amb-mix(e)
         (e:TCurry) :
            ;Check ref
            check-subexps()
            ;Check targ arity
            attempt :
               val arity = tarity(#V(type(ref(e))))
               bad-tarity(e) when arity != length(targs(e))
            ;Check carg captures
            attempt :
               #V(type(ctxt(e) as CExp|CDo))
               bad-capture(e) when any?(false?, cargs(e))
         (e:TRef) :
            if ls-def?(n(e)) :
               bad-ls-ref(e) when false?(type(e))
         (e) :
            check-subexps()


   defn check (c:LSComm) :
;      println("check(~)" << [c])
;      indented $ fn () :
      
      defn check-subexps () :
         do(check{_:LSExp}, c)
         do(check-bounded, c)
         do(check{_:LSComm}, c)
      
      match(c) :
         (c:LSSet) :
            check-subexps()
            attempt :
               val et = #V(type(exp(c)))
               bad-lvalue-set(c) when not lvalue?(exp(c))
               val vt = #V(type(value(c)))
               bad-set(c) when not-assign?(vt, et)
         (c:LSReturn) :
            check-subexps()
            attempt :
               val et = #V(type(exp(c)))
               val ret = current-return-type as LSType
               bad-ret(c, ret) when not-assign?(et, ret)
         (c:LSDef) :
            check-subexps()
            attempt :
               val vt = #V(type(value(c)))
               val dt = #V(type(c))
               bad-assign(c) when not-assign?(vt, dt)
               unbound-def(c) when not bounded?(dt)
         (c:LSDefVar) :
            unbound-def(c) when not bounded?(type(c))
            check-subexps()
            attempt :
               if value(c) != false :
                  val vt = #V(type(value(c) as LSExp))
                  bad-assign(c) when not-assign?(vt, type(c))
         (c:LSIf) :
            attempt :
               val pt = #V(type(pred(c)))
               bad-pred(c) when not-long?(pt)
            check-subexps()
         (c:LSMatch) :
            attempt :
               val arg-ts = map(#V{type(_)}, args(c))
               if not-refs?(arg-ts) :
                  bad-match(c)
               else :
                  for b in branches(c) do :
                     val ats = arg-ts as List<RefT>
                     val bts = map(#V, atypes(b)) as List<RefT>
                     bad-branch(c, b) when not all?(overlap?, ats, bts)
            check-subexps()
         (c) :
            check-subexps()

   defn check (e:LSExp) -> False :
;      println("check(~)" << [e])
;      indented $ fn () :
      
      ;Check subexpressions
      defn check-subexps () :
         do(check{_:LSExp}, e)
         do(check{_:LSComm}, e)
         do(check{_:TExp}, e)

      match(e) :
         (e:LSNew) :         
            unbounded-new(e) when not bounded-type?(n(e))
            check-subexps()
            ;Check arities
            if wrong-tarity?(n(e), targ(e)) :
               bad-type-tarity(e)
            else :   
               val fts = field-types!(n(e), targ(e))
               bad-type-arity(e) when length(args(e)) != length(fts)
               ;Check initialization types
               attempt :
                  val ats = map(#V{type(_)}, args(e))
                  bad-new(e) when any?(not-assign?, ats, fts)
         (e:LSArray) :
            bounded-array(e) when bounded-type?(n(e))            
            check-subexps()
            ;Check arities
            if wrong-tarity?(n(e), targ(e)) :
               bad-type-tarity(e)
            else :
               val fts = field-types!(n(e), targ(e))
               bad-type-arity(e) when length(args(e)) != length(fts)
               ;Check initialization types
               attempt :
                  val ats = map(#V{type(_)}, args(e))
                  bad-new(e) when any?(not-assign?, ats, fts)
            ;Check length
            attempt :
               val lt = #V(type(length(e)))
               bad-length(e) when not-long?(lt)
         (e:LSStruct) :
            unbounded-struct(e) when not bounded-type?(n(e))            
            check-subexps()
            ;Check arities
            if wrong-tarity?(n(e), targ(e)) :
               bad-type-tarity(e)
            else :
               val fts = field-types!(n(e), targ(e))
               bad-type-arity(e) when length(args(e)) != length(fts)
               ;Check initialization types
               attempt :
                  val ats = map(#V{type(_)}, args(e))
                  bad-new(e) when any?(not-assign?, ats, fts)
         (e:LSDeref) :
            check-subexps()
            attempt :
               #V(type(exp(e)))
               bad-deref(e) when false?(type(e))
         (e:LSSlot) :
            check-subexps()
            ;Check index
            attempt :
               val it = #V(type(index(e)))
               bad-index(e) when not-long?(it)
            ;Check expression
            attempt :               
               #V(type(exp(e)))
               bad-slot(e) when false?(type(e))
         (e:LSField) :
            check-subexps()
            attempt :
               #V(type(exp(e)))
               bad-field(e) when false?(type(e))
         (e:LSDo|LSDoInStack) :
            check-subexps()
            attempt :
               val ft = #V(type(func(e)))
               if not-func?(ft) :
                  not-function(e)
               else :
                  val ats = map(#V{type(_)}, args(e))
                  bad-call(e) when not-callable?(ft as FnT, ats)
         (e:LSDoStack) :
            check-subexps()
            attempt :              
               val st = #V(type(func(e)))               
               bad-stack(e) when not-stack?(st)
         (e:LSAddr) :
            check-subexps()
            attempt :
               #V(type(exp(e)))
               bad-lvalue-addr(e) when not lvalue?(exp(e))
         (e:LSCallC) :
            check-subexps()
            attempt :
               val ft = #V(type(func(e)))
               if not-func?(ft) :
                  not-function(e)
               else :
                  ;Check if closure
                  match(func(e)) :
                     (f:LSDeref) : bad-callc-closure(e) when ref?(#V(type(exp(f))))
                     (f) : false
                  ;Check call
                  val ats = map(#V{type(_)}, args(e))
                  bad-call(e) when not-callable?(ft as FnT, ats)
         (e:LSPrim) :
            check-subexps()
            attempt :
               val ats = map(#V{type(_)}, args(e))
               bad-prim(e) when not callable?(op(e), ats)
         (e:LSSizeof) :
            bad-sizeof(e) when no-size?(targ(e))
         (e:LSCast) :
            check-subexps()
            attempt :
               val et = #V(type(exp(e)))
               bad-cast(e) when not castable?(et, targ(e))
         (e:LSAnd) :
            check-subexps()
            attempt :
               val at = #V(type(a(e)))
               val bt = #V(type(b(e)))
               bad-and(e) when not-long?(at) or not-long?(bt)
         (e:LSOr) :
            check-subexps()
            attempt :
               val at = #V(type(a(e)))
               val bt = #V(type(b(e)))
               bad-or(e) when not-long?(at) or not-long?(bt)
         (e:LSMix) :
            attempt :
               val exps* = select(exps(e), #V(sel(e)))
               val n = length(exps*)
               switch {n == _} :
                  0 : no-mix(e)
                  1 : check(head(exps*))
                  else :
                     val ts = map({#V(type(_)) as FnT}, exps*)
                     val ct = #V(type(ctxt(e) as CLSExp|CLSDo))
                     if disjoint?(ts, ct) : do(check, exps*)
                     else : amb-mix(e)
         (e:LSCurry) :
            check-subexps()
            ;Check targ arity            
            val arity = tarity(type(ref(e)) as LSType)
            bad-tarity(e) when arity != length(targs(e))
            ;Check carg captures
            attempt :
               #V(type(ctxt(e) as CLSExp|CLSDo))
               bad-capture(e) when any?(false?, cargs(e))
         (e) :
            check-subexps()

   defn check-bounded (e:LSExp) :
      defn check-exp (e:LSExp, bounded-exp?:True|False) -> False :
         if bounded-exp? :
            attempt :
               val t = #V(type(e))
               unbounded(e) when not bounded?(t)
         match(e) :
            (e:LSDo|LSDoInStack|LSCallC) :
               check-exp(func(e), false)
               do(check-exp{_, true}, args(e))
            (e:LSAddr) : check-exp(exp(e), false)
            (e:LSField) : check-exp(exp(e), false)
            (e:LSMix|LSCurry) : false
            (e:LSLetExp) : check-exp(exp(e), bounded-exp?)
            (e) : do(check-exp{_:LSExp, true}, e)
      check-exp(e, true)
      

   ;               Report Generation Utilities
   ;               ===========================

   defn cms (xs:Streamable) : join(xs, ", ")

   defn #pr (f:False) : error("No printable type")      
   defn #pr (t:Type) : printable(nm, t)
   defn #pr (t:LSType) : printable(nm, t)
   defn #pr (ts:Streamable<False|Type|LSType>) : stream(#pr, ts)
   
   
   defn has-name? (n:Int) :
      key?(nm,n)

   defn #name (n:Int) :
      name(nm[n])

   defn #info (n:Int) :
      info(nm[n])

   defn #type (n:Int) -> Type|LSType :
      match(env[n], ls-env[n]) :
         (t:Type, lt) : t
         (t:False, lt:LSType) : lt

   defn name? (x:Int|List<Int>, str:String, default:String) :
      match(x) :
         (xs:List<Int>) :
            if all?(has-name?, xs) : str << [cms(stream(#name, xs))]
            else : default
         (x:Int) :
            if has-name?(x) : str << [#name(x)]
            else : default

   defn def-name (c:TLetTuple|TLetVar|TLet|TDefTuple|TDefVar|TDef|TLDef|TLDefVar|LSDef|LSDefVar) :
      match(c) :
         (c:TDef|TLDef) : name?(n(c), "global value ~", "global value")
         (c:TDefVar|TLDefVar) : name?(n(c), "global variable ~", "global variable")
         (c:TDefTuple) : name?(ns(c), "global values ~@", "tuple elements")
         (c:TLet|LSDef) : name?(n(c), "value ~", "value")
         (c:TLetVar|LSDefVar) : name?(n(c), "variable ~", "variable")
         (c:TLetTuple) : name?(ns(c), "values ~@", "tuple elements")

   defn def-type (c:TLetTuple|TLetVar|TLet|TDefTuple|TDefVar|TDef|TLDef|TLDefVar|LSDef|LSDefVar) :
      match(c) :
         (c:TLetVar|TLet) : ntype(c)
         (c:LSDef|LSDefVar) : type(c)
         (c:TDef|TDefVar) : type(c)
         (c:TLetTuple) : TTuple(ntypes(c) as List<Type>)
         (c:TDefTuple) : TTuple(types(c) as List<Type>)
         (c:TLDef|TLDefVar) : type(c)

   defn defined-function-name (c:TDefn|TDefmethod|TFn) :
      match(c) :
         (c:TDefn) : name?(n(c), "function ~", "function")
         (c:TDefmethod) : "method"
         (c:TFn) : "anonymous function"   

   defn variable-name (e:LSExp) :
      match(e) :
         (e:LSVar) : name?(n(e), "variable ~", "variable")
         (e) : "location"

   defn value-name (e:TExp|LSExp) :
      match(e) :
         (e:TRef) : name?(n(e), "Value ~", "Value")
         (e:LSVar) : name?(n(e), "Value ~", "Value")
         (e) : "Expression"

   defn function-name (e:TExp|LSExp) :
      match(e) :
         (e:TRef) : name?(n(e), "function ~", "function")
         (e:TMix) : function-name(head(exps(e)))
         (e:TCurry) : function-name(ref(e))
         (e:LSVar) : name?(n(e), "function ~", "function")
         (e:LSMix) : function-name(head(exps(e)))
         (e:LSCurry) : function-name(ref(e))
         (e) : "expression"

   defn ref-n (e:TExp|LSExp) :
      match(e) :
         (e:TRef) : n(e)
         (e:TCurry) : ref-n(ref(e))
         (e:LSVar) : n(e)
         (e:LSCurry) : ref-n(ref(e))
            
   defn possibilities (exps:Streamable<TExp|LSExp>) :
      join{_, "\n"} $ for e in exps stream :
         val n = ref-n(e)
         "   ~: ~ at ~" << [#name(n), #pr(#type(n)), #info(n)]            

   ;                  Report Generation
   ;                  =================
         
   defn no-inferred-type (c:TDef|TDefTuple|TDefVar|TLetVar) :
      add-error("~: Could not infer type of ~." << [info(c), def-name(c)])

   defn bad-assign (c:TDef|TDefVar|TLDef|TLDefVar|TLet|TLetVar|LSDef|LSDefVar) :
      val v = value(c) as TExp|LSExp
      add-error("~: Cannot assign expression of type ~ to ~ with declared type ~." <<
         [info(c), #pr(type(v)), def-name(c), #pr(def-type(c))])

   defn bad-ls-method (c:TLDefmethod) :
      add-error("~: Cannot define LoStanza method with type ~." << [
         info(c), #pr(#type(n(c)))])

   defn unbound-def (c:TLDef|TLDefVar|LSDef|LSDefVar) :
      add-error("~: Cannot define ~ with unbounded type ~." << [
         info(c), def-name(c), #pr(def-type(c))])

   defn unbounded (e:LSExp) :
      add-error("~: Expression has unbounded type ~." << [
         info(e), #pr(type(e))])

   defn unbounded-new (e:LSNew) :
      val t = StructT(n(e), targ(e))
      add-error("~: Cannot use new operator to create object of type ~ containing rest field." << [
         info(e), #pr(t)])

   defn unbounded-struct (e:LSStruct) :
      val t = StructT(n(e), targ(e))
      add-error("~: Cannot create struct of type ~ containing rest field." << [
         info(e), #pr(t)])

   defn bounded-array (e:LSArray) :
      val t = StructT(n(e), targ(e))
      add-error("~: Cannot use array operator to create object of type ~ without rest field." << [
         info(e), #pr(t)])

   defn bad-type-tarity (e:LSNew|LSArray|LSStruct) :
      val name = name?(n(e), "Type ~", "Type")
      val given = length(types(targ(e) as TTuple))
      val n = type-tarity(n(e))
      add-error("~: ~ requires ~ type arguments, but given ~." << [
         info(e), name, n, given])

   defn bad-type-arity (e:LSNew|LSArray|LSStruct) :
      val name = name?(n(e), "Type ~", "Type")
      val n = length(field-types!(n(e), targ(e)))
      add-error("~: ~ requires ~ fields, but given ~." << [
         info(e), name, n, length(args(e))])

   defn bad-new (e:LSNew|LSArray|LSStruct) :
      val construct = match(e) :
         (e:LSNew) : "object"
         (e:LSArray) : "array"
         (e:LSStruct) : "struct"
      val t = StructT(n(e), targ(e))
      val ts = map(type, args(e))
      add-error("~: Cannot create ~ of type ~ with fields of type (~@)." << [
         info(e), construct, #pr(t), cms(#pr(ts))])

   defn not-tuple (c:TDefTuple|TLetTuple) :
      add-error("~: Cannot detuple expression of type ~." <<
         [info(c), #pr(type(value(c)))])

   defn bad-detuple (c:TDefTuple|TLetTuple) :
      val n = length(ns(c))
      add-error("~: Cannot deconstruct expression of type ~ into tuple of length ~." <<
         [info(c), #pr(type(value(c))), n])

   defn no-inferred-args (e:TFn) :
      val w = type(ctxt(e) as CExp|CDo)
      for (a in args(e), t in a1(e), i in 0 to false) do :
         if false?(t) :
            val name = name?(a, "argument ~", "argument ~" % [i])
            attempt :
               add-error("~: Could not infer type for ~. Function used in context expecting type ~." << [
                  info(e), name, #pr(#V(w))])
            else :      
               add-error("~: Could not infer type for ~." << [info(e), name])

   defn no-inferred-ret (e:TDefn) :
      add-error("~: Could not infer return type for ~." << [
         info(e), defined-function-name(e)])

   defn bad-ret (f:TDefn|TDefmethod|TFn) :
      val name = defined-function-name(f)
      defn loop (e:TExp) :
         match(e) :
            (e:TLet|TLetVar|TLetTuple|TLetRec|TBranch) : loop(body(e))
            (e:TMatch) : do(loop, branches(e))
            (e:TSeq) : loop(b(e))
            (e) :
               if not-st?(type(e) as Type, a2(f) as Type) :
                  add-error("~: Cannot return an expression of type ~ for ~ with declared return type ~." << [
                     info(e), #pr(type(e)), name, #pr(a2(f))])
      loop(body(f))

   defn bad-ret (c:LSReturn, t:LSType) :
      val et = type(exp(c))
      add-error("~: Cannot return expression of type ~ from function with declared return type ~." << [
         info(c), #pr(et), #pr(t)])

   defn bad-branch (e:TMatch, b:TBranch) :
      val bargs = stream({[_, _]}, args(b), atypes(b))
      for (a in args(e), [ba, bt] in bargs, i in 0 to false) do :
         if not overlap?(type(a) as Type, bt as Type) :
            val name = name?(ba, "argument ~", "argument ~" % [i])
            add-error("~: Branch type ~ for ~ cannot match against match argument of type ~." << [
               info(b),  #pr(bt), name, #pr(type(a))])

   defn bad-branch (e:LSMatch, b:LSBranch) :
      val bargs = stream({[_, _ as RefT]}, args(b), atypes(b))
      for (a in args(e), [ba, bt] in bargs, i in 0 to false) do :
         if not overlap?(type(a) as RefT, bt) :
            val name = name?(ba, "argument ~", "argument ~" % [i])
            add-error("~: Branch type ~ for ~ cannot match against match argument of type ~." << [
               info(b), #pr(bt), name, #pr(type(a))])

   defn bad-cast (e:TCast) :
      add-error("~: Cannot cast expression of type ~ to type ~." << [
         info(e), #pr(type(exp(e))), #pr(targ(e))])

   defn bad-upcast (e:TUpCast) :
      add-error("~: Cannot upcast expression of type ~ to type ~." << [
         info(e), #pr(type(exp(e))), #pr(targ(e))])

   defn bad-cast (e:LSCast) :
      val et = type(exp(e))
      add-error("~: Cannot cast expression of type ~ to type ~." << [
         info(e), #pr(et), #pr(targ(e))])

   defn bad-set (e:TSet) :
      val name = name?(n(ref(e)), "variable ~", "variable")
      add-error("~: Cannot assign expression of type ~ to ~ with declared type ~." << [
         info(e), #pr(type(value(e))), name, #pr(type(ref(e)))])

   defn bad-set (e:LSSet) :
      val et = type(exp(e))
      val vt = type(value(e))
      add-error("~: Cannot assign expression of type ~ to ~ with declared type ~." << [
         info(e), #pr(vt), variable-name(exp(e)), #pr(et)])

   defn bad-lvalue-set (e:LSSet) :
      add-error("~: Cannot assign to non-assignable ~." << [
         info(e), variable-name(exp(e))])

   defn bad-lvalue-addr (e:LSAddr) :
      add-error("~: Cannot get address of non-assignable ~." << [
         info(e), variable-name(exp(e))])

   defn not-function (e:TDo) :
      val name = value-name(func(e))
      add-error("~: ~ of type ~ cannot be called as a function." << [
         info(e), name, #pr(type(func(e)))])

   defn not-function (e:LSDo|LSDoInStack|LSCallC) :
      val ft = type(func(e))
      val name = value-name(func(e))
      add-error("~: ~ of type ~ cannot be called as a function." << [
         info(e), name, #pr(ft)])

   defn bad-call (e:TDo) :
      val name = function-name(func(e))
      val ats = map(type, args(e))
      add-error("~: Cannot call ~ of type ~ with arguments of type (~@)." << [
         info(e), name, #pr(type(func(e))), cms(#pr(ats))])

   defn bad-call (e:LSDo|LSDoInStack|LSCallC) :
      val name = function-name(func(e))
      val ft = type(func(e))
      val ats = map(type, args(e))
      add-error("~: Cannot call ~ of type ~ with arguments of type (~@)." << [
         info(e), name, #pr(ft), cms(#pr(ats))])

   defn bad-stack (e:LSDoStack) :
      add-error("~: Cannot call switch stack with value of type ~." << [
         info(e), #pr(type(func(e)))])

   defn bad-callc-closure (e:LSCallC) :
      add-error("~: Cannot call closure of type ~ using C calling convention." << [
         info(e), #pr(type(func(e)))])

   defn bad-ls-ref (e:TRef) :
      val name =
         match(type(nm[n(e)])) :
            (t:LVarE) : name?(n(e), "variable ~", "variable")
            (t:LValE) : name?(n(e), "value ~", "value")
            (t:LFnE) : name?(n(e), "function ~", "function")
      add-error("~: LoStanza ~ of type ~ can only be referred to from LoStanza." << [
         info(e), name, #pr(#type(n(e)))])

   defn no-mix (e:TMix|LSMix) :
      val name = #name(ref-n(head(exps(e))))
      match(ctxt(e)) :
         (c:CDo|CLSDo) :
            attempt :
               val ats = map(#V, args(c))
               add-error("~: No appropriate function ~ for arguments of type (~@). Possibilities are:\n~@" << [
                  info(e), name, cms(#pr(ats)), possibilities(exps(e))])
            else :
               add-error("~: No appropriate function ~ for this context. Possibilities are:\n~@" << [
                  info(e), name, possibilities(exps(e))])
         (c:CExp|CLSExp) :
            attempt :
               val t = #V(type(c))
               add-error("~: No appropriate function ~ for expected type ~. Possibilities are:\n~@" << [
                  info(e), name, #pr(t), possibilities(exps(e))])
            else :      
               add-error("~: No appropriate function ~ for this context. Possibilities are:\n~@" << [
                  info(e), name, possibilities(exps(e))])
               
   defn amb-mix (e:TMix|LSMix) :
      val exps* = select(exps(e), #V(sel(e)))
      val name = #name(ref-n(head(exps*)))
      match(ctxt(e)) :
         (c:CDo|CLSDo) :
            add-error("~: Ambiguous call to overloaded function ~ with arguments of type (~@). Possibilities are:\n~@" << [
               info(e), name, cms(#pr(args(c))), possibilities(exps*)])
         (c:CExp|CLSExp) :
            add-error("~: Ambiguous reference to overloaded function ~ for expected type ~. Possibilities are:\n~@" << [
               info(e), name, #pr(type(c)), possibilities(exps*)])

   defn no-method (e:TMix) :
      val name = #name(ref-n(head(exps(e))))
      val t = type(ctxt(e) as CMulti)
      add-error("~: No appropriate multi ~ for method of type ~. Possibilities are:\n~@" << [
         info(e), name, #pr(t), possibilities(exps(e))])

   defn amb-method (e:TMix) :
      val exps* = select(exps(e), #V(sel(e)))
      val name = #name(ref-n(head(exps(e))))
      val t = type(ctxt(e) as CMulti)
      add-error("~: Multiple appropriate multis ~ for method of type ~@. Possibilities are:\n~@" << [
         info(e), name, #pr(t), possibilities(exps*)])

   defn bad-method (c:TExp) :
      val name = function-name(c)
      val t = type(ctxt(c) as CMulti)
      add-error("~: Cannot attach method of type ~ to ~ of type ~." << [
         info(c), #pr(t), name, #pr(type(c))])

   defn bad-tarity (e:TCurry|LSCurry) :
      match(type(ref(e))) :
         (t:TPoly|PolyT) :
            add-error("~: Function ~ of type ~ requires ~ type arguments, but received (~@)." << [
               info(e), #name(n(ref(e))), #pr(type(ref(e))), length(targs(t)), cms(#pr(targs(e)))])
         (t:TArrow|FnT) :
            add-error("~: Function ~ of type ~ does not accept type arguments, but received (~@)." << [
               info(e), #name(n(ref(e))), #pr(type(ref(e))), cms(#pr(targs(e)))])

   defn bad-prim (e:LSPrim) :
      val ats = map(type, args(e))
      add-error("~: Cannot call LoStanza primitive ~ with arguments of type (~@)." << [
         info(e), op(e), cms(#pr(ats))])

   defn bad-prim (e:TPrim) :
      val ats = map(type, args(e))
      add-error("~: Cannot call Stanza primitive ~ with arguments of type (~@)." << [
         info(e), op(e), cms(#pr(ats))])

   defn bad-capture (e:TCurry|LSCurry) :
      val rt = type(ref(e)) as TPoly|PolyT
      for (a in cargs(rt), t in cargs(e)) do :
         if false?(t) :
            val a-name = name?(a, "type argument ~", "type argument")
            val r-name = #name(n(ref(e)))
            match(ctxt(e)) :
               (c:CExp|CLSExp|CMulti) :
                  add-error("~: Could not capture ~ for function ~ of type ~. Expected type is ~." << [
                     info(e), a-name, r-name, #pr(rt), #pr(type(c))])
               (c:CDo|CLSDo) :
                  add-error("~: Could not capture ~ for function ~ of type ~. Called with arguments of type (~@)." << [
                     info(e), a-name, r-name, #pr(rt), cms(#pr(args(c)))])

   defn bad-pred (c:LSIf) :
      add-error("~: Expression of type ~ cannot be used as predicate in if statement. Must be a long." << [
         info(c), #pr(type(pred(c)))])

   defn bad-match (c:LSMatch) :
      val ts = map(type, args(c))
      add-error("~: Match statement cannot be used on values of types (~@). Must be ref types." << [
         info(c), cms(#pr(ts))])

   defn bad-length (e:LSArray) :
      val t = type(length(e))
      add-error("~: Expression of type ~ cannot be used as length for array. Must be a long." << [
         info(e), #pr(t)])

   defn bad-deref (e:LSDeref) :
      add-error("~: Expression of type ~ cannot be dereferenced." << [
         info(e), #pr(type(exp(e)))])

   defn bad-index (e:LSSlot) :
      add-error("~: Expression of type ~ cannot be used as index. Must be a long." << [
         info(e), #pr(type(index(e)))])

   defn bad-slot (e:LSSlot) :
      add-error("~: Cannot access indexed slot in expression of type ~." << [
         info(e), #pr(type(index(e)))])

   defn bad-field (e:LSField) :
      add-error("~: Cannot access field ~ in expression of type ~." << [
         info(e), name(e), #pr(type(exp(e)))])

   defn bad-sizeof (e:LSSizeof) :
      add-error("~: Cannot compute the size of type ~." << [
         info(e), #pr(targ(e))])

   defn bad-and (e:LSAnd) :
      add-error("~: And operator cannot be applied to arguments of type ~ and ~. Must be longs." << [
         info(e), #pr(type(a(e))), #pr(type(b(e)))])

   defn bad-or (e:LSOr) :
      add-error("~: Or operator cannot be applied to arguments of type ~ and ~. Must be longs." << [
         info(e), #pr(type(a(e))), #pr(type(b(e)))])

   ;======== Driver ========
   do(check, comms(prog))
   if not empty?(errors) :
      do(println, errors)
      throw(TypeError())

;;============================================================
;;=============== General Utilities ==========================
;;============================================================
defstruct Fresh
defstruct TypeError <: Exception
