defpackage stz/type :
   import core
   import verse
   import stz/il-ir
   import stz/tl-ir
   import stz/namemap

public defn to-tprog (e:IExp) :
   val hier = THierarchy()
   val comms = Vector<TComm>()
   defn to-tcomm (e:IExp) :
      match(e) :
         (e:IBegin) : do(to-tcomm, exps(e))
         (e:IPublic) : to-tcomm(exp(e))
         (e:IProtected) : to-tcomm(exp(e))
         (e:IDefType) : add(hier, n!(class(e)), n!(args(e)), to-type(parent(e)))
         (e:IDef) : do(add{comms, _}, destructure-def(e))
         (e:IDefVar) : add(comms, TDefVar(n!(name(e)), to-type(type(e)), to-exp(value(e))))
         (e:IDefn) : add(comms, to-defn(e))
         (e:IDefmulti) :
            val [targs, cargs] = split-targs(targs(e))
            add(comms, TDefmulti(n!(name(e)), targs, cargs, to-type(a1(e)), to-type(a2(e))))
         (e:IDefmethod) : add(comms, to-defmethod(e))
         (e:ILoStanza) : false
         (e) : add(comms, TExpComm(to-exp(e)))
   to-tcomm(e)       
   TProg(hier, to-list(comms))

defn to-type (es:List<IExp>) :
   map(to-type, es)
   
defn to-type (e:IExp) -> Type :
   match(e) :
      (e:ITuple) : TTuple(to-type(exps(e)))
      (e:IOf) : TOf(n!(class(e)), TTuple(to-type(args(e))))
      (e:IAnd) : TAnd(to-type(a(e)), to-type(b(e)))
      (e:IOr) : TOr(to-type(a(e)), to-type(b(e)))
      (e:IArrow) : TArrow(TTuple(to-type(a1(e))), to-type(a2(e)))
      (e:ICap) : TCap(n!(name(e)))
      (e:IGradual) : TGradual()
      (e:IVoid) : TBot()
      (e:INone) : TNone()
      (e:VarN) : TVar(n(e))
      (e:Raw) : TOf(n!(class(e)), TGradual())      

defn to-exp (es:List<IExp>) :
   map(to-exp, es)

defn to-exp (e:IExp) -> TExp :
   match(e) :
      (e:IFn) :
         val [ns, body] = destructure-args(args(e), body(e))
         TFn(tail?(e), to-type(a1(e)), to-type(a2(e)), ns, body, TNone())
      (e:IMulti) :
         TMulti(to-exp(funcs(e)), TNone())
      (e:IBegin) :
         if empty?(tail(exps(e))) :
            to-exp(head(exps(e)))
         else :
            val a = to-exp(head(exps(e)))
            val binfo = info(exps(e)[1])
            val b = to-exp(IBegin(tail(exps(e)), binfo))
            TSeq(a, b, TNone())
      (e:IMatch) :
         TMatch(to-exp(args(e)), to-exp(branches(e)) as List<TBranch>, TNone())
      (e:IBranch) :
         val types = to-type(types(e))
         val [ns, body] = destructure-args(args(e), body(e))
         TBranch(ns, types, body, TNone())
      (e:INew) :
         TNew(to-defmethod(methods(e) as List<IDefmethod>), to-type(class(e)))
      (e:ISet) :
         TSet(n!(name(e)), to-exp(value(e)), TNone())
      (e:IDo) :
         match(func(e)) :
            (f:IOf) : TPolyDo(to-exp(class(f)), to-type(args(f)), to-exp(args(e)), TNone())
            (f) : TDo(to-exp(f), to-exp(args(e)), TNone())
      (e:IPrim) :
         val prim-name = name(function(e) as IVar)
         TPrim(prim-name, to-exp(args(e)), TNone())
      (e:ICallLS) :
         match(function(e)) :
            (f:IOf) : TCallLS(n!(class(f)), to-type(args(f)), to-exp(args(e)), TNone())
            (f) : TCallLS(n!(f), List(), to-exp(args(e)), TNone())
      (e:ILiteral) :
         TLiteral(value(e), TNone())
      (e:ITuple) :
         TTupleExp(to-exp(exps(e)), TNone())
      (e:INone) :
         TElide(TNone())
      (e:VarN) :
         TRef(n(e), TNone())
      (e:Mix) :
         TMix(to-exp(exps(e)), TNone())
      (e:Let) :
         destructure-let(e)
      (e:LetRec) :
         TLetRec(to-defn(defns(e) as List<IDefn>), to-exp(body(e)), TNone())
      (e) :
         error("Unsupported expression: ~" % [e])

defn split-targs (es:List<IExp>) :
   val targs = Vector<Int>()
   val cargs = Vector<Int>()
   for e in es do :
      match(e) :
         (e:VarN) : add(targs, n(e))
         (e:ICap) : add(cargs, n!(name(e)))
   [to-list(targs), to-list(cargs)]    

defn to-defn (defs:List<IDefn>) :
   map(to-defn, defs)

defn to-defn (def:IDefn) :
   val [targs, cargs] = split-targs(targs(def))
   val [ns, body] = destructure-args(args(def), body(def))
   TDefn(tail?(def), n!(name(def)), targs, cargs,
         to-type(a1(def)), to-type(a2(def)),
         ns, body)

defn to-defmethod (defs:List<IDefmethod>) :
   map(to-defmethod, defs)

defn to-defmethod (def:IDefmethod) :
   val [targs, cargs] = split-targs(targs(def))
   val [ns, body] = destructure-args(args(def), body(def))
   TDefmethod(tail?(def), to-exp(multi(def)), thisn(def), targs, cargs,
         to-type(a1(def)), to-type(a2(def)),
         ns, body)

;Global Destructuring
defn destructure-def (def:IDef) -> List<TDef|TDefTuple> :
   var body = List()
   defn loop (xs:List<IExp>, v:IExp) :
      val ns = for x in xs map :
         match(x) :
            (x:ITuple) :
               val v* = VarN(fresh-n(), info(x))
               loop(exps(x), v*)
               n(v*)
            (x) : n!(x)
      body = List(TDefTuple(ns, map(TNone{}, ns), to-exp(v)), body)
   match(name(def), type(def)) :
      (name:ITuple, type:INone) :
         loop(exps(name), value(def))
         body
      (name:ITuple, type) :
         val v* = VarN(fresh-n(), info(name))
         loop(exps(name), v*)
         List(TDef(n(v*), to-type(type), to-exp(value(def))), body)
      (name, type) :
         list(TDef(n!(name), to-type(type), to-exp(value(def))))

;Local Destructuring
defn destructure-let (lete:Let) -> TExp :
   var body = to-exp(body(lete))
   defn loop (xs:List<IExp>, v:IExp) :
      val ns = for x in xs map :
         match(x) :
            (x:ITuple) :
               val v* = VarN(fresh-n(), info(x))
               loop(exps(x), v*)
               n(v*)
            (x) : n!(x)
      body = TLetTuple(ns, map(TNone{}, ns), to-exp(v), body, TNone())
   val def = def(lete) as IDef
   match(name(def), type(def)) :
      (name:ITuple, type:INone) :
         loop(exps(name), value(def))
         body
      (name:ITuple, type) :
         val v* = VarN(fresh-n(), info(name))
         loop(exps(name), v*)
         TLet(n(v*), to-type(type), to-exp(value(def)), body, TNone())
      (name, type) :
         TLet(n!(name), to-type(type), to-exp(value(def)), body, TNone())

;Argument Destructuring
defn destructure-args (args:List<IExp>, fbody:IExp) -> [List<Int>, TExp] :
   var body = fbody
   val ns = for a in args map :
      match(a) :
         (a:ITuple) :
            val v* = VarN(fresh-n(), info(a))
            body = Let(IDef(a, INone(info(a)), v*, info(a)), body, info(a))
            n(v*)
         (a) : n!(a)
   [ns, to-exp(body)]

;Returning indices
defn n! (es:List<IExp>) :
   map(n!, es)
   
defn n! (e:IExp) :
   match(e) :
      (e:VarN) : n(e)
      (e:LSVarN) : n(e)