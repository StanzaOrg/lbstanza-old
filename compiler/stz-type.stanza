defpackage stz/type :
   import core
   import verse
   import stz/il-ir
   import stz/tl-ir
   import stz/namemap

;============================================================
;=============== Conversion to Type IR ======================
;============================================================

public defn to-tprog (nm:NameMap, e:IExp) :
   val hier = THierarchy $ [
      `False => resolve-type(nm, `core, `False)
      `Int => resolve-type(nm, `core, `Int)
      `String => resolve-type(nm, `core, `String)
      `Symbol => resolve-type(nm, `core, `Symbol)
      `List => resolve-type(nm, `core, `List)
      `Tuple => resolve-type(nm, `core, `Tuple)]
      
   val comms = Vector<TComm>()
   defn to-tcomm (e:IExp) :
      match(e) :
         (e:IBegin) : do(to-tcomm, exps(e))
         (e:IPublic) : to-tcomm(exp(e))
         (e:IProtected) : to-tcomm(exp(e))
         (e:IDefType) : add(hier, n!(class(e)), n!(args(e)), to-type(parent(e)))
         (e:IDef) : do(add{comms, _}, destructure-def(e))
         (e:IDefVar) : add(comms, TDefVar(n!(name(e)), to-type(type(e)), to-exp(value(e))))
         (e:IDefn) : add(comms, to-defn(e))
         (e:IDefmulti) :
            val [targs, cargs] = split-targs(targs(e))
            add(comms, TDefmulti(n!(name(e)), targs, cargs, to-type(a1(e)), to-type(a2(e))))
         (e:IDefmethod) : add(comms, to-defmethod(e))
         (e:ILoStanza) : false
         (e) : add(comms, TExpComm(to-exp(e)))
   to-tcomm(e)       
   TProg(hier, to-list(comms))

defn to-type (es:List<IExp>) :
   map(to-type, es)
   
defn to-type (e:IExp) -> Type :
   match(e) :
      (e:ITuple) : TTuple(to-type(exps(e)))
      (e:IOf) : TOf(n!(class(e)), TTuple(to-type(args(e))))
      (e:IAnd) : TAnd(to-type(a(e)), to-type(b(e)))
      (e:IOr) : TOr(to-type(a(e)), to-type(b(e)))
      (e:IArrow) : TArrow(TTuple(to-type(a1(e))), to-type(a2(e)))
      (e:ICap) : TCap(n!(name(e)))
      (e:IGradual) : TGradual()
      (e:IVoid) : TBot()
      (e:INone) : TNone()
      (e:VarN) : TVar(n(e))
      (e:Raw) : TOf(n!(class(e)), TGradual())      

defn to-exp (es:List<IExp>) :
   map(to-exp, es)

defn to-exp (e:IExp) -> TExp :
   match(e) :
      (e:IFn) :
         val [ns, body] = destructure-args(args(e), body(e))
         TFn(tail?(e), to-type(a1(e)), to-type(a2(e)), ns, body, TNone(), CNone())
      (e:IMulti) :
         TMulti(to-exp(funcs(e)), TNone(), CNone())
      (e:IBegin) :
         if empty?(tail(exps(e))) :
            to-exp(head(exps(e)))
         else :
            val a = to-exp(head(exps(e)))
            val binfo = info(exps(e)[1])
            val b = to-exp(IBegin(tail(exps(e)), binfo))
            TSeq(a, b, TNone(), CNone())
      (e:IMatch) :
         TMatch(to-exp(args(e)), to-exp(branches(e)) as List<TBranch>, TNone(), CNone())
      (e:IBranch) :
         val types = to-type(types(e))
         val [ns, body] = destructure-args(args(e), body(e))
         TBranch(ns, types, body, TNone(), CNone())
      (e:INew) :
         TNew(to-defmethod(methods(e) as List<IDefmethod>), to-type(class(e)), CNone())
      (e:ISet) :
         TSet(to-exp(name(e)) as TRef, to-exp(value(e)), TNone(), CNone())
      (e:IDo) :
         val f* = match(func(e)) :
            (f:IOf) :
               if empty?(args(f)) : to-exp(class(f))
               else : to-farg(class(f), to-type(args(f)))
            (f) : to-exp(f)
         TDo(f*, to-exp(args(e)), TNone(), CNone())
      (e:IPrim) :
         val prim-name = name(function(e) as IVar)
         TPrim(prim-name, to-exp(args(e)), TNone(), CNone())
      (e:ICallLS) :
         match(function(e)) :
            (f:IOf) : TCallLS(n!(class(f)), to-type(args(f)), to-exp(args(e)), TNone(), CNone())
            (f) : TCallLS(n!(f), List(), to-exp(args(e)), TNone(), CNone())
      (e:ILiteral) :
         TLiteral(value(e), TNone(), CNone())
      (e:ITuple) :
         TTupleExp(to-exp(exps(e)), TNone(), CNone())
      (e:INone) :
         TElide(TNone(), CNone())
      (e:VarN) :
         TRef(n(e), TNone(), CNone())
      (e:Mix) :
         TMix(SNone(), to-exp(exps(e)), TNone(), CNone())
      (e:Let) :
         destructure-let(e)
      (e:LetRec) :
         TLetRec(to-defn(defns(e) as List<IDefn>), to-exp(body(e)), TNone(), CNone())
      (e) :
         error("Unsupported expression: ~" % [e])

defn to-farg (es:List<IExp>, ts:List<Type>) -> List<TExp> :
   map(to-farg{_, ts}, es)

defn to-farg (e:IExp, ts:List<Type>) -> TExp :
   match(e) :
      (e:VarN) : TArgExp(TRef(n(e), TNone(), CNone()), ts, List(), TNone(), CNone())
      (e:Mix) : TMix(SNone(), to-farg(exps(e), ts), TNone(), CNone())

defn split-targs (es:List<IExp>) :
   val targs = Vector<Int>()
   val cargs = Vector<Int>()
   for e in es do :
      match(e) :
         (e:VarN) : add(targs, n(e))
         (e:ICap) : add(cargs, n!(name(e)))
   [to-list(targs), to-list(cargs)]    

defn to-defn (defs:List<IDefn>) :
   map(to-defn, defs)

defn to-defn (def:IDefn) :
   val [targs, cargs] = split-targs(targs(def))
   val [ns, body] = destructure-args(args(def), body(def))
   TDefn(tail?(def), n!(name(def)), targs, cargs,
         to-type(a1(def)), to-type(a2(def)),
         ns, body)

defn to-defmethod (defs:List<IDefmethod>) :
   map(to-defmethod, defs)

defn to-defmethod (def:IDefmethod) :
   val [targs, cargs] = split-targs(targs(def))
   val [ns, body] = destructure-args(args(def), body(def))
   TDefmethod(tail?(def), fresh-n(), to-exp(multi(def)), thisn(def), targs, cargs,
         to-type(a1(def)), to-type(a2(def)),
         ns, body)

;Global Destructuring
defn destructure-def (def:IDef) -> List<TDef|TDefTuple> :
   defn loop (name:IExp, type:IExp) :
      match(name, type) :
         (name:ITuple, type:INone) :
            for b in destructure(exps(name), to-exp(value(def))) map :
               val ts = map(TNone{}, key(b))
               TDefTuple(key(b), ts, value(b))
         (name:ITuple, type) :
            val n = fresh-n()
            List(TDef(n, to-type(type), to-exp(value(def)))
                 loop(name, INone(FileInfo())))
         (name, type) :
            list(TDef(n!(name), to-type(type), to-exp(value(def))))
   loop(name(def), type(def))

;Local Destructuring
defn destructure-let (lete:Let) -> TExp :
   defn loop (name:IExp, type:IExp, dvalue:IExp) :
      match(name, type) :
         (name:ITuple, type:INone) :
            var body = to-exp(body(lete))
            for b in destructure(exps(name), to-exp(dvalue)) do :
               val ts = map(TNone{}, key(b))
               body = TLetTuple(key(b), ts, value(b), body, TNone(), CNone())
            body
         (name:ITuple, type) :
            val n = fresh-n()
            val body* = loop(name, INone(FileInfo()), VarN(n, info(name)))
            TLet(n, to-type(type), to-exp(dvalue), body*, TNone(), CNone())
         (name, type) :
            val t* = to-type(type)
            val v* = to-exp(dvalue)
            val body* = to-exp(body(lete))            
            TLet(n!(name), t*, v*, body*, TNone(), CNone())
   val def = def(lete) as IDef
   loop(name(def), type(def), value(def))

;Argument Destructuring
defn destructure-args (args:List<IExp>, fbody:IExp) -> [List<Int>, TExp] :
   val [ns, bs] = destructure(args)
   var body = to-exp(fbody)
   for b in bs do :
      val ts = map(TNone{}, key(b))
      body = TLetTuple(key(b), ts, value(b), body, TNone(), CNone())
   [ns, body]

;Destructuring
defn destructure (args:List<IExp>, value:TExp) -> List<KeyValue<List<Int>, TExp>> :
   val [ns, bs] = destructure(args)
   List(ns => value, bs)
   
defn destructure (args:List<IExp>) -> [List<Int>, List<KeyValue<List<Int>, TExp>>] :
   var bindings = List()
   defn loop (xs:List<IExp>) -> List<Int> :
      for x in xs map :
         match(x) :
            (x:ITuple) :
               val exps* = loop(exps(x))
               val n = fresh-n()
               bindings = List(exps* => TRef(n, TNone(), CNone()), bindings)
               n
            (x) :
               n!(x)
   val ns = loop(args)
   [ns, bindings]

;Returning indices
defn n! (es:List<IExp>) :
   map(n!, es)
   
defn n! (e:IExp) :
   match(e) :
      (e:VarN) : n(e)
      (e:LSVarN) : n(e)

;============================================================
;============== Generate Type Variables =====================
;============================================================

;Fresh Marker
defstruct Fresh

public defn initialize-types (prog:TProg) :
   ;Environment
   val env = HashTable<Int,Type>({_})

   ;Utilities   
   defn env-a1 (n:Int) :
      defn* loop (t:Type) :
         match(t) :
            (t:TPoly) : loop(func(t))
            (t:TArrow) : types(a(t) as TTuple)
      loop(env[n])     

   defn env-a2 (n:Int) :
      defn* loop (t:Type) :
         match(t) :
            (t:TPoly) : loop(func(t))
            (t:TArrow) : b(t)
      loop(env[n])
      
   val #? = TGradual()
   val #fresh = Fresh()
   defn #freshv () : TUVar(fresh-n())
   defn #freshv (n:Int) : to-list(stream(#freshv{}, 0 to n))
   defn #or (x:Type, y:Type) : y when x typeof TUVar|TNone else x
   defn #or (x:Type, f:Fresh) : #freshv() when x typeof TUVar|TNone else x
   defn #or (xs:List<Type>, y:Type|Fresh) : map(#or{_, y}, xs)
   defn #or (xs:List<Type>, ys:List<Type>) : map(#or, xs, ys)
   defn set-env (n:Int, t:Type) : env[n] = t
   defn set-env (n:Int, f:Fresh) : env[n] = #freshv()
   defn set-env (ns:List<Int>, y:Type|Fresh) : do(set-env{_, y}, ns)
   defn set-env (ns:List<Int>, ts:List<Type>) : do(set-env, ns, ts)   
   defn bexp (es:List<TExp>, c:Context) : map(bexp{_, c}, es)
   defn bcomm<?T> (cs:List<?T&TComm>) : map(bcomm, cs)
   defn types (es:List<TExp>) : map(type, es)

   ;Specialized Type constructors
   defn lit-type (v) :
      defn base (n:Int) : TOf(n, TTuple(List()))
      defn raw (n:Int) : TOf(n, TGradual())
      match(v) :
         (v:False) : base(False(hier(prog)))
         (v:Int) : base(Int(hier(prog)))
         (v:String) : base(String(hier(prog)))
         (v:Symbol) : base(Symbol(hier(prog)))
         (v:List) : raw(List(hier(prog)))

   defn prim-type (f:Symbol) :
      error("Primitive type not yet implemented.")

   ;Add function to environment
   defn add-fn-type (c:TDefmulti|TDefn|TDefmethod) :
      var t = TArrow(TTuple(#or(a1(c), #?)) #or(a2(c), #fresh))
      if not empty?(targs(c)) or not empty?(cargs(c)) :
         t = TPoly(targs(c), cargs(c), t as TArrow)
      set-env(n(c), t)   

   ;Build environment
   defn build-environment () :
      for c in comms(prog) do :
         match(c) :
            (c:TDef) :
               set-env(n(c), #or(type(c), #fresh))
            (c:TDefTuple) :
               set-env(ns(c), #fresh)
            (c:TDefVar) :
               set-env(n(c), #or(type(c), #fresh))
            (c:TDefn) :
               add-fn-type(c)
            (c:TDefmulti) :
               add-fn-type(c)
            (c:TDefmethod) :
               add-fn-type(c)
            (c:TExpComm) :
               false
         
   defn bcomm<?T> (c:?T&TComm) -> T :
      {_ as T&TComm} $ match(c) :
         (c:TDef) :
            val v* = bexp(value(c), CExp(#or(type(c), #?)))
            TDef(n(c), env[n(c)], v*)
         (c:TDefTuple) :
            val v* = bexp(value(c), CExp(#?))
            val ts = map({env[_]}, ns(c))
            TDefTuple(ns(c), ts, v*)
         (c:TDefVar) :
            val v* = bexp(value(c), CExp(#or(type(c), #?)))
            TDefVar(n(c), env[n(c)], v*)
         (c:TDefn) :
            set-env(args(c), env-a1(n(c)))
            val body* = bexp(body(c), CExp(#or(a2(c), #?)))            
            TDefn(tail?(c), n(c), targs(c), cargs(c),
                  env-a1(n(c)), env-a2(n(c)),
                  args(c), body*)
         (c:TDefmulti) :
            TDefmulti(n(c), targs(c), cargs(c),
                      env-a1(n(c)), env-a2(n(c)))
         (c:TDefmethod) :
            set-env(args(c), env-a1(n(c)))
            val body* = bexp(body(c), CExp(#or(a2(c), #?)))
            TDefmethod(tail?(c), n(c), bexp(multi(c), CExp(#?)), thisn(c), targs(c), cargs(c),
                       env-a1(n(c)), env-a2(n(c)),
                       args(c), body*)
         (c:TExpComm) :
            TExpComm(bexp(exp(c), CExp(#?)))

   defn bexp (e:TExp, c:Context) -> TExp :
      match(e) :
         (e:TLet) :
            val v* = bexp(value(e), CExp(#or(ntype(e), #?)))
            set-env(n(e), type(v*))
            val body* = bexp(body(e), c)
            TLet(n(e), type(v*), v*, body* c)
         (e:TLetVar) :
            val t* = #or(ntype(e), #fresh)
            val v* = bexp(value(e), CExp(t*))
            set-env(n(e), t*)
            val body* = bexp(body(e), c)
            TLetVar(n(e), t*, v*, body*, type(body*), c)
         (e:TLetTuple) :
            val ts* = #or(ntypes(e), #fresh)
            val v* = bexp(value(e), CExp(#?))
            set-env(ns(e), ts*)
            val body* = bexp(body(e), c)
            TLetTuple(ns(e), ts*, v*, body*, type(body*), c)
         (e:TLetRec) :
            do(add-fn-type, defns(e))
            val defns* = for def in defns(e) map :
               set-env(args(def), env-a1(n(def)))
               val body* = bexp(body(def), CExp(#or(a2(def), #?)))
               TDefn(tail?(def), n(def), targs(def), cargs(def),
                     env-a1(n(def)), env-a2(n(def)), args(def), body*)
            val body* = bexp(body(e), c)
            TLetRec(defns*, body*, type(body*), c)
         (e:TFn) :
            val a1* = #or(a1(e), #fresh)
            val a2* = #or(a2(e), #fresh)
            set-env(args(e), a1*)
            val body* = bexp(body(e), CExp(#or(a2(e), #fresh)))
            TFn(tail?(e), a1*, a2*, args(e), body*, TArrow(TTuple(a1*), a2*), c)
         (e:TMulti) :         
            val funcs* = bexp(funcs(e), c)
            val type* = reduce(TAnd, types(funcs*))
            TMulti(funcs*, type*, c)
         (e:TSeq) :
            val a* = bexp(a(e), CExp(#?))
            val b* = bexp(b(e), c)
            TSeq(a*, b*, type(b*), c)
         (e:TMatch) :         
            val args* = bexp(args(e), CExp(#?))
            val branches* = for b in branches(e) map :
               val atypes* = #or(atypes(b), types(args*))
               set-env(args(b), atypes*)
               val body* = bexp(body(b), c)
               TBranch(args(b), atypes*, body*, type(body*), c)
            TMatch(args*, branches*, #freshv(), c)
         (e:TNew) :
            val ms* = bcomm(methods(e))
            TNew(ms*, type(e), c)
         (e:TArgExp) :
            val t = env[n(ref(e))]
            val e* = TRef(n(ref(e)), t, c)
            val cargs* = match(t) :
               (t:TPoly) : #freshv(length(cargs(t)))
               (t) : List()
            TArgExp(e*, targs(e), cargs*, #freshv(), c)
         (e:TRef) :
            val t = env[n(e)]
            val e* = TRef(n(e), t, c)
            match(t) :
               (t:TPoly) :
                  val n = length(cargs(t))
                  TArgExp(e*, List(), #freshv(n), #freshv(), c)
               (t) : e*
         (e:TCast) :
            TCast(bexp(exp(e), CExp(#?)), type(e), c)
         (e:TSet) :
            val ref* = bexp(ref(e), CExp(#?)) as TRef
            val v* = bexp(value(e), CExp(type(ref*)))
            TSet(ref*, v*, lit-type(false), c)
         (e:TDo) :         
            val args* = map(bexp{_, CExp(#freshv())}, args(e))
            val ret* = match(c) :
               (c:CExp) : type(c)
               (c:CDo) : TArrow(TTuple(args(c)), ret(c))
            val f* = bexp(func(e), CDo(types(args*), ret*, #freshv()))
            TDo(f*, args*, #freshv(), c)            
         (e:TPrim) :
            val args* = map(bexp{_, CExp(#?)}, args(e))
            TPrim(function(e), args*, prim-type(function(e)), c)
         (e:TCallLS) :
            val args* = map(bexp{_, CExp(#?)}, args(e))
            TCallLS(function(e), targs(e), args*, #?, c)
         (e:TLiteral) :
            TLiteral(value(e), lit-type(value(e)), c)
         (e:TTupleExp) :
            val exps* = map(bexp{_, CExp(#freshv())}, exps(e))
            TTupleExp(exps*, TTuple(types(exps*)), c)
         (e:TMix) :
            val exps* = match(c) :
               (c:CExp) : bexp(exps(e), c)
               (c:CDo) : bexp(exps(e), CDo(args(c), ret(c), TNone()))
            TMix(SVar(fresh-n()), exps*, #freshv(), c)
         (e:TElide) :
            e

   ;Return new program
   build-environment()
   TProg(hier(prog), map(bcomm, comms(prog)))


;============================================================
;============== Generate Type Constraints ===================
;============================================================
         
defstruct TupleF : (n:Int)
defstruct SubF : (ti:Type, t:Type)
defstruct ArgsF : (n:Int)
defstruct RetF : (n:Int)
defstruct Fresh

defn generate-type-constraints (prog:TProg) :
   defn gen-exp (e:TExp) :
      match(e) :
         (e:TFn) :
            match(c) :
               (c:CExp) :
                  do(gen-exp, e)
                  ;Compute expected return
                  val ret = type(ctxt(body(e)) as CExp)
                  #upto(ret, type(c), SubF(a2(e), type(e)))
                  ;Compute expected arguments
                  for t in a1(e) do : #upto(t, type(c), SubF(t, type(e)))
               (c:CDo) :
                  ;Set expected type
                  val exp-a1 = #or(a1(e), #fresh)
                  #super(exp(c), TArrow(TTuple(exp-a1), a2(e)))
                  set-expected(args(e), exp-a1)
                  ;Compute expected return
                  val exp-ret = type(ctxt(body(e)) as CExp)
                  #equal(exp-ret, ret(c))
                  ;Compute expected arguments
                  if length(args(e)) == length(args(c)) :
                     #equal(a1(e), args(c))
                  ;Constraints for body
                  gen-exp(body(e))
         (e:TMulti) :
            match(c) :
               (c:CExp) :
                  for f in funcs(e) do :
                     do(gen-exp, f)
                     ;Compute expected return
                     val ret = type(ctxt(body(f)) as CExp)
                     #upto(ret, type(c), SubF(a2(f), type(e)))
                     ;Compute expected arguments
                     for t in a1(f) do : #upto(t, type(c), SubF(t, type(e)))                     
               (c:CDo) :
                  for f in funcs(e) do :
                     if length(args(f)) == length(args(c)) :
                        gen-exp(f)
                     else :
                        ;Set argument types
                        #equal(a1(f), TBot())
                        gen-exp(body(f))
         (e:TNew) :
            gen-comm(methods(e))
            #expect(ctxt(e), type(e))
         (e:TSet) :
            do(gen-exp, e)
            #super(type(ref(e)), type(value(e)))
            #expect(ctxt(e), type(e))
         (e:TDo) :
            do(gen-exp, e)
            val fc = ctxt(func(e)) as CDo
            val argcs = ctxts(args(e)) as List<CExp>
            #downto(types(argcs), exp(fc), ArgF())
            #downto(type(e), exp(fc), RetF())
            #expect(ctxt(e), type(e))
         (e:TPrim) :
            do(gen-exp, e)
            #expect(ctxt(e), type(e))
         (e:TCallLS) :
            do(gen-exp, e)
            #expect(ctxt(e), type(e))
         (e:TTupleExp) :
            do(gen-exp, exps(e))
            if ctxt(e) typeof CExp :
               val c = ctxt(e) as CExp
               val ts = types(ctxts(exps(e)) as List<CExp>)
               #upto(ts, type(c), TupleF())
            #expect(ctxt(e), type(e))
         (e:TRef) :
            val w = match(ctxt(e)) :
               (c:CExp) : type(c)
               (c:CDo) : TArrow(TTuple(args(c)), ret(c))
            #super(expected(n(e)), w)
            #expect(ctxt(e), type(e))      
         (e:TArgExp) :
            val w = match(ctxt(e)) :
               (c:CExp) : type(c)
               (c:CDo) : TArrow(TTuple(args(c)), #?)
            #equal(type(e), #targ-apply(type(exp(e)), targs(e), cargs(e)))
            #cap(cargs(e), type(e), w)
            #expect(ctxt(e), type(e))
         (e:TMix) :
            val w = match(ctxt(e)) :
               (c:CExp) : type(c)
               (c:CDo) : TArrow(TTuple(args(c)), #?)
            do(gen-exp, e)
            #select(sel(e), types(exps(e)), w)
            #mix(type(e), s, types(exps(e))) where :
               val s = match(ctxt(e)) :
                  (c:CExp) : #thresh(sel(e))
                  (c:CDo) : sel(e)
            #expect(ctxt(e), type(e))
         (e:TMatch) :
            do(gen-exp, args(e))
            do(gen-exp, branches(e))
            #equal(type(e), reduce(TOr, types(branches(e))))         
         (e:TLet) :
            do(gen-exp, e)
         (e:TLetVar) :
            #super(ntype(e), type(value(e)))
            do(gen-exp, e)
         (e:TLetTuple) :
            val n = length(ns(e))
            #downto(ntypes(e), type(value(e)), TupleF())
            do(gen-exp, e)
         (e:TLetRec) :
            gen-comm(defns(e))
            gen-exp(body(e))
         (e:TSeq) :do(gen-exp, e)
         (e:TBranch) : do(gen-exp, e)
         (e:TElide) : false
         (e:TLiteral) : false

