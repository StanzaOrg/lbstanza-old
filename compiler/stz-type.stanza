defpackage stz/type :
   import core
   import verse
   import stz/il-ir
   import stz/tl-ir
   import stz/namemap

;============================================================
;=============== Conversion to Type IR ======================
;============================================================

public defn to-tprog (nm:NameMap, e:IExp) :
   val hier = THierarchy $ [
      `False => resolve-type(nm, `core, `False)
      `Int => resolve-type(nm, `core, `Int)
      `String => resolve-type(nm, `core, `String)
      `Symbol => resolve-type(nm, `core, `Symbol)
      `List => resolve-type(nm, `core, `List)
      `Tuple => resolve-type(nm, `core, `Tuple)]
      
   val comms = Vector<TComm>()
   defn to-tcomm (e:IExp) :
      match(e) :
         (e:IBegin) : do(to-tcomm, exps(e))
         (e:IPublic) : to-tcomm(exp(e))
         (e:IProtected) : to-tcomm(exp(e))
         (e:IDefType) : add(hier, n!(class(e)), n!(args(e)), to-type(parent(e)))
         (e:IDef) : do(add{comms, _}, destructure-def(e))
         (e:IDefVar) : add(comms, TDefVar(n!(name(e)), to-type(type(e)), to-exp(value(e))))
         (e:IDefn) : add(comms, to-defn(e))
         (e:IDefmulti) :
            val [targs, cargs] = split-targs(targs(e))
            add(comms, TDefmulti(n!(name(e)), targs, cargs, to-type(a1(e)), to-type(a2(e))))
         (e:IDefmethod) : add(comms, to-defmethod(e))
         (e:ILoStanza) : false
         (e) : add(comms, TExpComm(to-exp(e)))
   to-tcomm(e)       
   TProg(hier, to-list(comms))

defn to-type (es:List<IExp>) :
   map(to-type, es)
   
defn to-type (e:IExp) -> Type :
   match(e) :
      (e:ITuple) : TTuple(to-type(exps(e)))
      (e:IOf) : TOf(n!(class(e)), TTuple(to-type(args(e))))
      (e:IAnd) : TAnd(to-type(a(e)), to-type(b(e)))
      (e:IOr) : TOr(to-type(a(e)), to-type(b(e)))
      (e:IArrow) : TArrow(TTuple(to-type(a1(e))), to-type(a2(e)))
      (e:ICap) : TCap(n!(name(e)))
      (e:IGradual) : TGradual()
      (e:IVoid) : TBot()
      (e:INone) : TNone()
      (e:VarN) : TVar(n(e))
      (e:Raw) : TOf(n!(class(e)), TGradual())      

defn to-exp (es:List<IExp>) :
   map(to-exp, es)

defn to-exp (e:IExp) -> TExp :
   match(e) :
      (e:IFn) :
         val [ns, body] = destructure-args(args(e), body(e))
         TFn(tail?(e), to-type(a1(e)), to-type(a2(e)), ns, body, TNone())
      (e:IMulti) :
         TMulti(to-exp(funcs(e)), TNone())
      (e:IBegin) :
         if empty?(tail(exps(e))) :
            to-exp(head(exps(e)))
         else :
            val a = to-exp(head(exps(e)))
            val binfo = info(exps(e)[1])
            val b = to-exp(IBegin(tail(exps(e)), binfo))
            TSeq(a, b, TNone())
      (e:IMatch) :
         TMatch(to-exp(args(e)), to-exp(branches(e)) as List<TBranch>, TNone())
      (e:IBranch) :
         val types = to-type(types(e))
         val [ns, body] = destructure-args(args(e), body(e))
         TBranch(ns, types, body, TNone())
      (e:INew) :
         TNew(to-defmethod(methods(e) as List<IDefmethod>), to-type(class(e)))
      (e:ISet) :
         TSet(n!(name(e)), to-exp(value(e)), TNone())
      (e:IDo) :
         match(func(e)) :
            (f:IOf) :
               val [f*, args*] = [to-exp(class(f)), to-exp(args(e))]
               if empty?(args(f)) : TDo(f*, args*, TNone())
               else : TPolyDo(f*, to-type(args(f)), args*, TNone())
            (f) : TDo(to-exp(f), to-exp(args(e)), TNone())
      (e:IPrim) :
         val prim-name = name(function(e) as IVar)
         TPrim(prim-name, to-exp(args(e)), TNone())
      (e:ICallLS) :
         match(function(e)) :
            (f:IOf) : TCallLS(n!(class(f)), to-type(args(f)), to-exp(args(e)), TNone())
            (f) : TCallLS(n!(f), List(), to-exp(args(e)), TNone())
      (e:ILiteral) :
         TLiteral(value(e), TNone())
      (e:ITuple) :
         TTupleExp(to-exp(exps(e)), TNone())
      (e:INone) :
         TElide(TNone())
      (e:VarN) :
         TRef(n(e), TNone())
      (e:Mix) :
         TMix(to-exp(exps(e)), TNone())
      (e:Let) :
         destructure-let(e)
      (e:LetRec) :
         TLetRec(to-defn(defns(e) as List<IDefn>), to-exp(body(e)), TNone())
      (e) :
         error("Unsupported expression: ~" % [e])

defn split-targs (es:List<IExp>) :
   val targs = Vector<Int>()
   val cargs = Vector<Int>()
   for e in es do :
      match(e) :
         (e:VarN) : add(targs, n(e))
         (e:ICap) : add(cargs, n!(name(e)))
   [to-list(targs), to-list(cargs)]    

defn to-defn (defs:List<IDefn>) :
   map(to-defn, defs)

defn to-defn (def:IDefn) :
   val [targs, cargs] = split-targs(targs(def))
   val [ns, body] = destructure-args(args(def), body(def))
   TDefn(tail?(def), n!(name(def)), targs, cargs,
         to-type(a1(def)), to-type(a2(def)),
         ns, body)

defn to-defmethod (defs:List<IDefmethod>) :
   map(to-defmethod, defs)

defn to-defmethod (def:IDefmethod) :
   val [targs, cargs] = split-targs(targs(def))
   val [ns, body] = destructure-args(args(def), body(def))
   TDefmethod(tail?(def), fresh-n(), to-exp(multi(def)), thisn(def), targs, cargs,
         to-type(a1(def)), to-type(a2(def)),
         ns, body)

;Global Destructuring
defn destructure-def (def:IDef) -> List<TDef|TDefTuple> :
   var body = List()
   defn loop (xs:List<IExp>, v:IExp) :
      val ns = for x in xs map :
         match(x) :
            (x:ITuple) :
               val v* = VarN(fresh-n(), info(x))
               loop(exps(x), v*)
               n(v*)
            (x) : n!(x)
      body = List(TDefTuple(ns, map(TNone{}, ns), to-exp(v)), body)
   match(name(def), type(def)) :
      (name:ITuple, type:INone) :
         loop(exps(name), value(def))
         body
      (name:ITuple, type) :
         val v* = VarN(fresh-n(), info(name))
         loop(exps(name), v*)
         List(TDef(n(v*), to-type(type), to-exp(value(def))), body)
      (name, type) :
         list(TDef(n!(name), to-type(type), to-exp(value(def))))

;Local Destructuring
defn destructure-let (lete:Let) -> TExp :
   var body = to-exp(body(lete))
   defn loop (xs:List<IExp>, v:IExp) :
      val ns = for x in xs map :
         match(x) :
            (x:ITuple) :
               val v* = VarN(fresh-n(), info(x))
               loop(exps(x), v*)
               n(v*)
            (x) : n!(x)
      body = TLetTuple(ns, map(TNone{}, ns), to-exp(v), body, TNone())
   val def = def(lete) as IDef
   match(name(def), type(def)) :
      (name:ITuple, type:INone) :
         loop(exps(name), value(def))
         body
      (name:ITuple, type) :
         val v* = VarN(fresh-n(), info(name))
         loop(exps(name), v*)
         TLet(n(v*), to-type(type), to-exp(value(def)), body, TNone())
      (name, type) :
         TLet(n!(name), to-type(type), to-exp(value(def)), body, TNone())

;Argument Destructuring
defn destructure-args (args:List<IExp>, fbody:IExp) -> [List<Int>, TExp] :
   var body = fbody
   val ns = for a in args map :
      match(a) :
         (a:ITuple) :
            val v* = VarN(fresh-n(), info(a))
            body = Let(IDef(a, INone(info(a)), v*, info(a)), body, info(a))
            n(v*)
         (a) : n!(a)
   [ns, to-exp(body)]

;Returning indices
defn n! (es:List<IExp>) :
   map(n!, es)
   
defn n! (e:IExp) :
   match(e) :
      (e:VarN) : n(e)
      (e:LSVarN) : n(e)

;============================================================
;============== Generate Type Variables =====================
;============================================================

public defn initialize-types (prog:TProg) :
   ;Environment
   val env = HashTable<Int,Type>({_})

   ;Utilities
   defn fill-uvar (t:Type) :
      match(t) :
         (t:TNone) : TUVar(fresh-n())
         (t) : map(fill-uvar, t)

   defn fill-gradual (t:Type) :
      match(t) :
         (t:TNone) : TGradual()
         (t) : map(fill-gradual, t)

   defn fill-uvar (ts:List<Type>) :
      map(fill-uvar, ts)

   defn fill-gradual (ts:List<Type>) :
      map(fill-gradual, ts)

   defn env-a1 (n:Int) :
      defn* loop (t:Type) :
         match(t) :
            (t:TPoly) : loop(func(t))
            (t:TArrow) : types(a(t) as TTuple)
      loop(env[n])     

   defn env-a2 (n:Int) :
      defn* loop (t:Type) :
         match(t) :
            (t:TPoly) : loop(func(t))
            (t:TArrow) : b(t)
      loop(env[n]) 

   defn first-type (a:Type, b:Type) :
      match(a) :
         (a:TNone) : b
         (a) : a     

   defn bcomm (cs:List<TComm>) :
      map(bcomm, cs)
      
   defn bexp (es:List<TExp>) :
      map(bexp, es)

   ;Specialized Type constructors
   defn lit-type (v) :
      defn base (n:Int) : TOf(n, TTuple(List()))
      defn raw (n:Int) : TOf(n, TGradual())
      match(v) :
         (v:False) : base(False(hier(prog)))
         (v:Int) : base(Int(hier(prog)))
         (v:String) : base(String(hier(prog)))
         (v:Symbol) : base(Symbol(hier(prog)))
         (v:List) : raw(List(hier(prog)))

   defn prim-type (f:Symbol) :
      error("Primitive type not yet implemented.")

   ;Build environment
   defn build-environment () :
      for c in comms(prog) do :
         match(c) :
            (c:TDef) :
               env[n(c)] = fill-uvar(type(c))
            (c:TDefTuple) :
               for n in ns(c) do : env[n] = TUVar(fresh-n())
            (c:TDefVar) :
               env[n(c)] = fill-uvar(type(c))
            (c:TDefn) :
               var t = TArrow(TTuple(fill-gradual(a1(c))), fill-uvar(a2(c)))
               if not empty?(targs(c)) or not empty?(cargs(c)) :
                  t = TPoly(targs(c), cargs(c), t as TArrow)
               env[n(c)] = t
            (c:TDefmulti) :           
               var t = TArrow(TTuple(fill-gradual(a1(c))), fill-gradual(a2(c)))
               if not empty?(targs(c)) or not empty?(cargs(c)) :
                  t = TPoly(targs(c), cargs(c), t as TArrow)
               env[n(c)] = t
            (c:TDefmethod) :
               var t = TArrow(TTuple(fill-gradual(a1(c))), fill-uvar(a2(c)))
               if not empty?(targs(c)) or not empty?(cargs(c)) :
                  t = TPoly(targs(c), cargs(c), t as TArrow)
               env[n(c)] = t
            (c:TExpComm) :
               false
         
   defn bcomm (c:TComm) -> TComm :
      match(c) :
         (c:TDef) :           
            TDef(n(c), env[n(c)], bexp(value(c)))
         (c:TDefTuple) :
            val ts = map({env[_]}, ns(c))
            TDefTuple(ns(c), ts, bexp(value(c)))
         (c:TDefVar) :
            TDefVar(n(c), env[n(c)], bexp(value(c)))
         (c:TDefn) :
            TDefn(tail?(c), n(c), targs(c), cargs(c),
                  env-a1(n(c)), env-a2(n(c)),
                  args(c), bexp(body(c)))
         (c:TDefmulti) :
            TDefmulti(n(c), targs(c), cargs(c),
                      env-a1(n(c)), env-a2(n(c)))
         (c:TDefmethod) :
            TDefmethod(tail?(c), n(c), bexp(multi(c)), thisn(c), targs(c), cargs(c),
                       env-a1(n(c)), env-a2(n(c)),
                       args(c), bexp(body(c)))
         (c:TExpComm) :
            TExpComm(bexp(exp(c)))

   defn bexp (e:TExp) -> TExp :
      match(e) :
         (e:TLet) :
            val t* = fill-uvar(ntype(e))
            env[n(e)] = t*
            val v* = bexp(value(e))
            val body* = bexp(body(e))
            TLet(n(e), t*, v*, body*, type(body*))
         (e:TLetVar) :
            val t* = fill-uvar(ntype(e))
            env[n(e)] = t*
            val v* = bexp(value(e))
            val body* = bexp(body(e))
            TLetVar(n(e), t*, v*, body*, type(body*))
         (e:TLetTuple) :
            val ts* = fill-uvar(ntypes(e))
            do({env[_] = _}, ns(e), ts*)
            val v* = bexp(value(e))
            val body* = bexp(body(e))
            TLetTuple(ns(e), ts*, v*, body*, type(body*))
         (e:TLetRec) :
            for def in defns(e) do :
               var t = TArrow(TTuple(fill-gradual(a1(def))), fill-uvar(a2(def)))
               if not empty?(targs(def)) or not empty?(cargs(def)) :
                  t = TPoly(targs(def), cargs(def), t as TArrow)
               env[n(def)] = t
            val defns* = for def in defns(e) map :
               for (a in args(def), t in env-a1(n(def))) do : env[a] = t
               val body* = bexp(body(def))
               TDefn(tail?(def), n(def), targs(def), cargs(def),
                     env-a1(n(def)), env-a2(n(def)), args(def), body*)
            val body* = bexp(body(e))
            TLetRec(defns*, body*, type(body*))
         (e:TFn) :
            val a1* = fill-uvar(a1(e))
            val a2* = fill-uvar(a2(e))
            for (a in args(e), t in a1*) do : env[a] = t
            val body* = bexp(body(e))
            TFn(tail?(e), a1*, a2*, args(e), body*, TArrow(TTuple(a1*), a2*))
         (e:TMulti) :
            val funcs* = map(bexp, funcs(e))
            val type* = reduce(TAnd, stream(type, funcs*))
            TMulti(funcs*, type*)
         (e:TSeq) :
            val a* = bexp(a(e))
            val b* = bexp(b(e))
            TSeq(a*, b*, type(b*))
         (e:TMatch) :             
            val args* = bexp(args(e))
            val branches* = for b in branches(e) map :
               val atypes* = map(first-type{_, type(_)}, atypes(b), args*)
               for (a in args(b), t in atypes*) do : env[a] = t
               val body* = bexp(body(b))
               TBranch(args(b), atypes*, body*, type(body*))
            TMatch(args*, branches*, TUVar(fresh-n()))
         (e:TNew) :
            val ms* = bcomm(methods(e)) as List<TDefmethod>
            TNew(ms*, type(e))
         (e:TRef) :
            match(env[n(e)]) :
               (t:TPoly) : TCapExp(TRef(n(e), t), map(TUVar{fresh-n()}, cargs(t)), TUVar(fresh-n()))
               (t) : TRef(n(e), t)
         (e:TCast) :
            TCast(bexp(exp(e)), type(e))
         (e:TSet) :
            TSet(n(e), bexp(value(e)), lit-type(false))
         (e:TDo) :
            TDo(bexp(func(e)), bexp(args(e)), TUVar(fresh-n()))
         (e:TPolyDo) :
            TPolyDo(bexp(func(e)), targs(e), bexp(args(e)), TUVar(fresh-n()))
         (e:TPrim) :
            TPrim(function(e), bexp(args(e)), prim-type(function(e)))
         (e:TCallLS) :
            TCallLS(function(e), targs(e), bexp(args(e)), TGradual())
         (e:TLiteral) :
            TLiteral(value(e), lit-type(value(e)))
         (e:TTupleExp) :
            val es* = bexp(exps(e))
            TTupleExp(es*, TTuple(map(type, es*)))
         (e:TMix) :
            TMix(bexp(exps(e)), TUVar(fresh-n()))
         (e:TElide) :
            e

   ;Return new program
   build-environment()
   TProg(hier(prog), map(bcomm, comms(prog)))


;============================================================
;============== Generate Type Constraints ===================
;============================================================

defmulti gen-constraints (c:Context, e:TExp) -> False

defn generate-type-constraints (prog:TProg) :

   defn gen-exp (e:TExp, exp-type:Type) -> False :
      match(e) :
         (e:

   defn gen-base (c:Context, e:TExp) :
      match(e) :
         (e:TLet|TLetVar) :
            match(ntype(e)) :
               (t:TUVar) :
                  gen-exp(value(e), TGradual())
                  equal(t, type(value(e)))
               (t) :
                  gen-exp(value(e), t)
            continue(c, body(e))
         (e:TLetTuple) :
            gen-exp(exp(e), TGradual())
            elems-of(ntypes(e), type(exp(e)))
            continue(c, body(e))
         (e:TLetRec) :
            gen-comm(defns(e))
            continue(c, body(e))
         (e:TFn) :
            error("Unhandled.")
         (e:TMulti) :
            error("Unhandled.")
         (e:TSeq) :
            gen-exp(a(e), TGradual())
            continue(c, b(e))
         (e:TMatch) :
            gen-exp(args(e), TGradual())
            do(continue{c, _}, branches(e))
         (e:TBranch) :
            continue(c, body(e))
         (e:TNew) :
            gen-comm(methods(e))
         (e:TRef) :
            error("Unhandled.")
         (e:TCast) :
            gen-exp(exp(e), TGradual())
         (e:TSet) :
            gen-exp(value(e), type(ref(e)))
            super(type(ref(e)), type(value(e)))
         (e:TDo) :
            error("Unhandled.")
         (e:TPolyDo) :
            val ft = gen-poly(func(e), targs(e), types(exps(e)))
            val ft-a1 = args-of(ft, length(exps(e)))
            gen-exp(exps(e), ft-a1)
            equal(type(e), ret-of(ft, length(exps(e))))
         (e:TPrim) : gen-exp(args(e), TGradual())
         (e:TCallLS) : gen-exp(args(e), TGradual())
         (e:TLiteral) : false
         (e:TTupleExp) : error("Unhandled.")
         (e:TMix) : error("Unhandled.")
         (e:TCapExp) : error("Unhandled.")
         (e:TElide) : false
            
   
   defmethod gen-constraints (c:Context, e:TExp) :
      match(e) :
         (e:TLet) :
            declared(value(e), ntype(e))
            continue(c, body(e))
         (e:TLetVar) :
            declared(value(e), ntype(e))
            continue(c, body(e))
         (e:TLetTuple) :
            declared-tuple(value(e), ntypes(e))
            continue(c, body(e))
         (e:TLetRec) :
            
            continue(c, body(e))
         

defn generate-type-constraints (prog:TProg) :

   ;#up(e) : e continues in the current context
   ;#downto-tuple(t, ts) : flow type t down to ts
   ;#downto-args(t, n) : flow type t down to function with n arguments
   ;#downto-ret(t, n, r) : flow type t down function with n arguments and return r
   ;#upto(w, ti, t) : flow type w up to position ti of t
   ;#upto(w, e, ti, t) : flow type w up to expression e in position ti of t
   ;#upto-tuple(w, n) : flow type w up to tuple of length n
   ;#super(a, b) : constrain a :> b   
   ;defn #gradual (e:TExp) : gen-exp(e, TGradual())
   
   defn gen-exp (e:TExp, w:Type) -> False :
      defn #up (e:TExp) : gen-exp(e, w)
      defn #up (es:List<TExp>) : do(#up, es)      
      match(e) :
         (e:TLet) :
            #up(body(e))                                          
            gen-exp(value(e), #first(ntype(e), TGradual()))       
            #equal(ntype(e), value(e))                            
         (e:TLetVar) :   
            #up(body(e))                                          
            gen-exp(value(e), #first(ntype(e), TGradual()))       
            #equal(ntype(e), value(e))                            
         (e:TLetTuple) :
            #up(body(e))                                          
            #gradual(value(e))                                    
            #downto-tuple(type(value(e)), ntypes(e))              
         (e:TLetRec) :
            gen-comm(defns(e))                                    
            #up(body(e))                                          
         (e:TFn) :
            #upto(w, body(e), a2(e), type(e))                     
            #upto(w, a1(e), type(e))                              
         (e:TMulti) :
            for f in funcs(e) do :                                
               #upto(w, body(e), a2(f), type(e))                  
               #upto(w, a1(f), type(e))                           
         (e:TSeq) :
            #gradual(a(e))                                        
            #up(b(e))                                             
         (e:TMatch) :
            #gradual(args(e))                                     
            #up(branches(e))                                      
         (e:TBranch) :
            #up(body(e))                                          
         (e:TNew) :
            gen-comm(methods(e))                                  
         (e:TRef) :
            #super(exp-type(n(e)), w)                             
         (e:TCast) :
            #gradual(exp(e))                                      
         (e:TSet) :
            gen-exp(value(e), #first(type(ref(e)), TGradual()))   
            #super(type(ref(e)), type(value(e)))                  
         (e:TDo) :
            val n = length(exps(e))                               
            val ft = gen-call(func(e), map(type, exps(e)), w)     
            gen-exp(exps(e), #downto-args(ft, n))                 
            #downto-ret(ft, n, type(e))                           
         (e:TPolyDo) :
            val n = length(exps(e))
            gen-poly(func(e), targs(e), map(type, exps(e)))
            gen-exp(exps(e), #downto-args(type(func(e)), n))
            #downto-ret(type(func(e)), n, type(e))
         (e:TPrim) :
            #gradual(args(e))
         (e:TCallLS) :
            #gradual(args(e))
         (e:TLiteral) :
            false
         (e:TTupleExp) :
            gen-exp(exps(e), #upto-tuple(w, n))
         (e:TMix) :
            #up(exps(e))
            #mix(type(e), types(exps(e)), w)
         (e:TCapExp) :
            #up(exp(e))
            val t = type(exp(e)) as TPoly
            val t* = #sub(t, cargs(t), cargs(e))
            #cap(cargs(e), t*, w)
         (e:TElide) :
            false

   defn gen-call (e:TExp, w-a1:List<Type>, w-a2:Type) -> Type :
      defn #up (e:TExp) : gen-call(e, w-a1, w-a2)
      defn #up (es:List<TExp>) : do(#up, es)
      match(e) :
         (e:TMix) :
            #up(exps(e))
            #callmix(type(e), types(exps(e)), w-a1)
            type(e)
         (e:TCapExp) :
            #up(exp(e))
            val t = type(exp(e)) as TPoly
            val t* = #sub(t, cargs(t), cargs(e))
            #cap(cargs(e), t*, TArrow(TTuple(w-a1), TGradual()))
            type(e)
         (e:TFn) :
            val exp-a1 = for (x in args(e), t in a1(e)) map :
               match(t) :
                  (t:TUVar) :
                     val v = TUVar(fresh-n())
                     set-exp-type(x, v)
                     v
                  (t) :
                     t
            if length(args(e)) == length(w-a1) :
               #equal(a1(e), w-a1)
            gen-exp(body(e), #first(a2(e), w-a2))
            #equal(a2(e), type(body(e)))
            TArrow(TTuple(exp-a1), a2(e))
         (e:TMulti) :
            var return = type(e)
            for f in funcs(e) do :
               if length(args(f)) == length(w-a1) :
                  val exp-a1 = for (x in args(f), t in a1(f)) map :
                     match(t) :
                        (t:TUVar) :
                           val v = TUVar(fresh-n())
                           set-exp-type(x, t)
                           v
                        (t) :
                           t
                  #equal(a1(f), w-a1)
                  gen-exp(body(f), #first(a2(f), w-a2))
                  #equal(a2(f), type(body(f)))
                  return = TArrow(TTuple(exp-a1), a2(f))
               else :
                  #equal(a1(f), TBot())
                  gen-exp(body(f), #first(a2(f), w-a2))
                  #equal(a2(f), type(body(f)))
            return            
         (e:TLet) :
            gen-exp(value(e), #first(ntype(e), TGradual()))
            #equal(ntype(e), value(e))
            #up(body(e))
         (e:TLetVar) :   
            gen-exp(value(e), #first(ntype(e), TGradual()))
            #equal(ntype(e), value(e))
            #up(body(e))
         (e:TLetTuple) :
            #gradual(value(e))
            #downto-tuple(type(value(e)), ntypes(e))
            #up(body(e))
         (e:TLetRec) :
            gen-comm(defns(e))
            #up(body(e))
         (e:TSeq) :
            #gradual(a(e))
            #up(b(e))
         (e:TMatch) :
            #gradual(args(e))
            reduce(TOr, #up(branches(e)))
         (e:TBranch) :
            #up(body(e))            
         (e) :
            gen-exp(e, TArrow(TTuple(w-a1), TGradual()))
            type(e)






   defn gen-poly (e:TExp, targ-types:List<Type>, arg-types:List<Type>) -> False :
      TRef :
         nothing
      TMix :
         exps:poly with targ-types, arg-types
         type = callmix exps.type with arg-types
      TCapExp :
         t = sub uncap(exp.type) with exp.cargs => cargs
         for ci in cargs do :
            cap ci = exp.type <: arg-types ???
