defpackage stz/type :
   import core
   import verse
   import stz/il-ir
   import stz/tl-ir
   import stz/namemap

;============================================================
;=============== Conversion to Type IR ======================
;============================================================

public defn to-tprog (nm:NameMap, e:IExp) :
   val hier = THierarchy $ [
      `False => resolve-type(nm, `core, `False)
      `Int => resolve-type(nm, `core, `Int)
      `String => resolve-type(nm, `core, `String)
      `Symbol => resolve-type(nm, `core, `Symbol)
      `List => resolve-type(nm, `core, `List)
      `Tuple => resolve-type(nm, `core, `Tuple)]
      
   val comms = Vector<TComm>()
   defn to-tcomm (e:IExp) :
      match(e) :
         (e:IBegin) : do(to-tcomm, exps(e))
         (e:IPublic) : to-tcomm(exp(e))
         (e:IProtected) : to-tcomm(exp(e))
         (e:IDefType) : add(hier, n!(class(e)), n!(args(e)), to-type(parent(e)))
         (e:IDef) : do(add{comms, _}, destructure-def(e))
         (e:IDefVar) : add(comms, TDefVar(n!(name(e)), to-type(type(e)), to-exp(value(e))))
         (e:IDefn) : add(comms, to-defn(e))
         (e:IDefmulti) :
            val [targs, cargs] = split-targs(targs(e))
            add(comms, TDefmulti(n!(name(e)), targs, cargs, to-type(a1(e)), to-type(a2(e))))
         (e:IDefmethod) : add(comms, to-defmethod(e))
         (e:ILoStanza) : false
         (e) : add(comms, TExpComm(to-exp(e)))
   to-tcomm(e)       
   TProg(hier, to-list(comms))

defn to-type (es:List<IExp>) :
   map(to-type, es)
   
defn to-type (e:IExp) -> Type :
   match(e) :
      (e:ITuple) : TTuple(to-type(exps(e)))
      (e:IOf) : TOf(n!(class(e)), TTuple(to-type(args(e))))
      (e:IAnd) : TAnd(to-type(a(e)), to-type(b(e)))
      (e:IOr) : TOr(to-type(a(e)), to-type(b(e)))
      (e:IArrow) : TArrow(TTuple(to-type(a1(e))), to-type(a2(e)))
      (e:ICap) : TCap(n!(name(e)))
      (e:IGradual) : TGradual()
      (e:IVoid) : TBot()
      (e:INone) : TNone()
      (e:VarN) : TVar(n(e))
      (e:Raw) : TOf(n!(class(e)), TGradual())      

defn to-exp (es:List<IExp>) :
   map(to-exp, es)

defn to-exp (e:IExp) -> TExp :
   match(e) :
      (e:IFn) :
         val [ns, body] = destructure-args(args(e), body(e))
         TFn(tail?(e), to-type(a1(e)), to-type(a2(e)), ns, body, TNone(), CNone())
      (e:IMulti) :
         TMulti(to-exp(funcs(e)), TNone(), CNone())
      (e:IBegin) :
         if empty?(tail(exps(e))) :
            to-exp(head(exps(e)))
         else :
            val a = to-exp(head(exps(e)))
            val binfo = info(exps(e)[1])
            val b = to-exp(IBegin(tail(exps(e)), binfo))
            TSeq(a, b, TNone(), CNone())
      (e:IMatch) :
         TMatch(to-exp(args(e)), to-exp(branches(e)) as List<TBranch>, TNone(), CNone())
      (e:IBranch) :
         val types = to-type(types(e))
         val [ns, body] = destructure-args(args(e), body(e))
         TBranch(ns, types, body, TNone(), CNone())
      (e:INew) :
         TNew(to-defmethod(methods(e) as List<IDefmethod>), to-type(class(e)), CNone())
      (e:ISet) :
         TSet(to-exp(name(e)) as TRef, to-exp(value(e)), TNone(), CNone())
      (e:IDo) :
         match(func(e)) :
            (f:IOf) :
               val [f*, args*] = [to-exp(class(f)), to-exp(args(e))]
               if empty?(args(f)) : TDo(f*, args*, TNone(), CNone())
               else : TPolyDo(f*, to-type(args(f)), args*, TNone(), CNone())
            (f) : TDo(to-exp(f), to-exp(args(e)), TNone(), CNone())
      (e:IPrim) :
         val prim-name = name(function(e) as IVar)
         TPrim(prim-name, to-exp(args(e)), TNone(), CNone())
      (e:ICallLS) :
         match(function(e)) :
            (f:IOf) : TCallLS(n!(class(f)), to-type(args(f)), to-exp(args(e)), TNone(), CNone())
            (f) : TCallLS(n!(f), List(), to-exp(args(e)), TNone(), CNone())
      (e:ILiteral) :
         TLiteral(value(e), TNone(), CNone())
      (e:ITuple) :
         TTupleExp(to-exp(exps(e)), TNone(), CNone())
      (e:INone) :
         TElide(TNone(), CNone())
      (e:VarN) :
         TRef(n(e), TNone(), CNone())
      (e:Mix) :
         TMix(SNone(), to-exp(exps(e)), TNone(), CNone())
      (e:Let) :
         destructure-let(e)
      (e:LetRec) :
         TLetRec(to-defn(defns(e) as List<IDefn>), to-exp(body(e)), TNone(), CNone())
      (e) :
         error("Unsupported expression: ~" % [e])

defn split-targs (es:List<IExp>) :
   val targs = Vector<Int>()
   val cargs = Vector<Int>()
   for e in es do :
      match(e) :
         (e:VarN) : add(targs, n(e))
         (e:ICap) : add(cargs, n!(name(e)))
   [to-list(targs), to-list(cargs)]    

defn to-defn (defs:List<IDefn>) :
   map(to-defn, defs)

defn to-defn (def:IDefn) :
   val [targs, cargs] = split-targs(targs(def))
   val [ns, body] = destructure-args(args(def), body(def))
   TDefn(tail?(def), n!(name(def)), targs, cargs,
         to-type(a1(def)), to-type(a2(def)),
         ns, body)

defn to-defmethod (defs:List<IDefmethod>) :
   map(to-defmethod, defs)

defn to-defmethod (def:IDefmethod) :
   val [targs, cargs] = split-targs(targs(def))
   val [ns, body] = destructure-args(args(def), body(def))
   TDefmethod(tail?(def), fresh-n(), to-exp(multi(def)), thisn(def), targs, cargs,
         to-type(a1(def)), to-type(a2(def)),
         ns, body)

;Global Destructuring
defn destructure-def (def:IDef) -> List<TDef|TDefTuple> :
   defn loop (name:IExp, type:IExp) :
      match(name, type) :
         (name:ITuple, type:INone) :
            for b in destructure(exps(name), to-exp(value(def))) map :
               val ts = map(TNone{}, key(b))
               TDefTuple(key(b), ts, value(b))
         (name:ITuple, type) :
            val n = fresh-n()
            List(TDef(n, to-type(type), to-exp(value(def)))
                 loop(name, INone(FileInfo())))
         (name, type) :
            list(TDef(n!(name), to-type(type), to-exp(value(def))))
   loop(name(def), type(def))

;Local Destructuring
defn destructure-let (lete:Let) -> TExp :
   defn loop (name:IExp, type:IExp, dvalue:IExp) :
      match(name, type) :
         (name:ITuple, type:INone) :
            var body = to-exp(body(lete))
            for b in destructure(exps(name), to-exp(dvalue)) do :
               val ts = map(TNone{}, key(b))
               body = TLetTuple(key(b), ts, value(b), body, TNone(), CNone())
            body
         (name:ITuple, type) :
            val n = fresh-n()
            val body* = loop(name, INone(FileInfo()), VarN(n, info(name)))
            TLet(n, to-type(type), to-exp(dvalue), body*, TNone(), CNone())
         (name, type) :
            val t* = to-type(type)
            val v* = to-exp(dvalue)
            val body* = to-exp(body(lete))            
            TLet(n!(name), t*, v*, body*, TNone(), CNone())
   val def = def(lete) as IDef
   loop(name(def), type(def), value(def))

;Argument Destructuring
defn destructure-args (args:List<IExp>, fbody:IExp) -> [List<Int>, TExp] :
   val [ns, bs] = destructure(args)
   var body = to-exp(fbody)
   for b in bs do :
      val ts = map(TNone{}, key(b))
      body = TLetTuple(key(b), ts, value(b), body, TNone(), CNone())
   [ns, body]

;Destructuring
defn destructure (args:List<IExp>, value:TExp) -> List<KeyValue<List<Int>, TExp>> :
   val [ns, bs] = destructure(args)
   List(ns => value, bs)
   
defn destructure (args:List<IExp>) -> [List<Int>, List<KeyValue<List<Int>, TExp>>] :
   var bindings = List()
   defn loop (xs:List<IExp>) -> List<Int> :
      for x in xs map :
         match(x) :
            (x:ITuple) :
               val exps* = loop(exps(x))
               val n = fresh-n()
               bindings = List(exps* => TRef(n, TNone(), CNone()), bindings)
               n
            (x) :
               n!(x)
   val ns = loop(args)
   [ns, bindings]

;Returning indices
defn n! (es:List<IExp>) :
   map(n!, es)
   
defn n! (e:IExp) :
   match(e) :
      (e:VarN) : n(e)
      (e:LSVarN) : n(e)

;============================================================
;============== Generate Type Variables =====================
;============================================================

;Fresh Marker
defstruct Fresh

public defn initialize-types (prog:TProg) :
   ;Environment
   val env = HashTable<Int,Type>({_})

   ;Utilities   
   defn env-a1 (n:Int) :
      defn* loop (t:Type) :
         match(t) :
            (t:TPoly) : loop(func(t))
            (t:TArrow) : types(a(t) as TTuple)
      loop(env[n])     

   defn env-a2 (n:Int) :
      defn* loop (t:Type) :
         match(t) :
            (t:TPoly) : loop(func(t))
            (t:TArrow) : b(t)
      loop(env[n])
      
   val #? = TGradual()
   val #fresh = Fresh()
   defn #freshv () : TUVar(fresh-n())
   defn #freshv (n:Int) : to-list(stream(#freshv{}, 0 to n))
   defn #or (x:Type, y:Type) : y when x typeof TUVar|TNone else x
   defn #or (x:Type, f:Fresh) : #freshv() when x typeof TUVar|TNone else x
   defn #or (xs:List<Type>, y:Type|Fresh) : map(#or{_, y}, xs)
   defn #or (xs:List<Type>, ys:List<Type>) : map(#or, xs, ys)
   defn set-env (n:Int, t:Type) : env[n] = t
   defn set-env (n:Int, f:Fresh) : env[n] = #freshv()
   defn set-env (ns:List<Int>, y:Type|Fresh) : do(set-env{_, y}, ns)
   defn set-env (ns:List<Int>, ts:List<Type>) : do(set-env, ns, ts)   
   defn bexp (es:List<TExp>, c:Context) : map(bexp{_, c}, es)
   defn bcomm<?T> (cs:List<?T&TComm>) : map(bcomm, cs)
   defn types (es:List<TExp>) : map(type, es)

   ;Specialized Type constructors
   defn lit-type (v) :
      defn base (n:Int) : TOf(n, TTuple(List()))
      defn raw (n:Int) : TOf(n, TGradual())
      match(v) :
         (v:False) : base(False(hier(prog)))
         (v:Int) : base(Int(hier(prog)))
         (v:String) : base(String(hier(prog)))
         (v:Symbol) : base(Symbol(hier(prog)))
         (v:List) : raw(List(hier(prog)))

   defn prim-type (f:Symbol) :
      error("Primitive type not yet implemented.")

   ;Add function to environment
   defn add-fn-type (c:TDefmulti|TDefn|TDefmethod) :
      var t = TArrow(TTuple(#or(a1(c), #?)) #or(a2(c), #fresh))
      if not empty?(targs(c)) or not empty?(cargs(c)) :
         t = TPoly(targs(c), cargs(c), t as TArrow)
      set-env(n(c), t)   

   ;Build environment
   defn build-environment () :
      for c in comms(prog) do :
         match(c) :
            (c:TDef) :
               set-env(n(c), #or(type(c), #fresh))
            (c:TDefTuple) :
               set-env(ns(c), #fresh)
            (c:TDefVar) :
               set-env(n(c), #or(type(c), #fresh))
            (c:TDefn) :
               add-fn-type(c)
            (c:TDefmulti) :
               add-fn-type(c)
            (c:TDefmethod) :
               add-fn-type(c)
            (c:TExpComm) :
               false
         
   defn bcomm<?T> (c:?T&TComm) -> T :
      {_ as T&TComm} $ match(c) :
         (c:TDef) :
            val v* = bexp(value(c), CExp(#or(type(c), #?)))
            TDef(n(c), env[n(c)], v*)
         (c:TDefTuple) :
            val v* = bexp(value(c), CExp(#?))
            val ts = map({env[_]}, ns(c))
            TDefTuple(ns(c), ts, v*)
         (c:TDefVar) :
            val v* = bexp(value(c), CExp(#or(type(c), #?)))
            TDefVar(n(c), env[n(c)], v*)
         (c:TDefn) :
            set-env(args(c), env-a1(n(c)))
            val body* = bexp(body(c), CExp(#or(a2(c), #?)))            
            TDefn(tail?(c), n(c), targs(c), cargs(c),
                  env-a1(n(c)), env-a2(n(c)),
                  args(c), body*)
         (c:TDefmulti) :
            TDefmulti(n(c), targs(c), cargs(c),
                      env-a1(n(c)), env-a2(n(c)))
         (c:TDefmethod) :
            set-env(args(c), env-a1(n(c)))
            val body* = bexp(body(c), CExp(#or(a2(c), #?)))
            TDefmethod(tail?(c), n(c), bexp(multi(c), CExp(#?)), thisn(c), targs(c), cargs(c),
                       env-a1(n(c)), env-a2(n(c)),
                       args(c), body*)
         (c:TExpComm) :
            TExpComm(bexp(exp(c), CExp(#?)))

   defn bexp (e:TExp, c:Context) -> TExp :
      match(e) :
         (e:TLet) :
            val t* = #or(ntype(e), #fresh)
            set-env(n(e), t*)
            val v* = bexp(value(e), CExp(t*))
            val body* = bexp(body(e), c)
            TLet(n(e), t*, v*, body*, type(body*), c)
         (e:TLetVar) :
            val t* = #or(ntype(e), #fresh)
            set-env(n(e), t*)
            val v* = bexp(value(e), CExp(t*))
            val body* = bexp(body(e), c)
            TLetVar(n(e), t*, v*, body*, type(body*), c)
         (e:TLetTuple) :
            val ts* = #or(ntypes(e), #fresh)
            set-env(ns(e), ts*)
            val v* = bexp(value(e), CExp(#?))
            val body* = bexp(body(e), c)
            TLetTuple(ns(e), ts*, v*, body*, type(body*), c)
         (e:TLetRec) :
            do(add-fn-type, defns(e))
            val defns* = for def in defns(e) map :
               set-env(args(def), env-a1(n(def)))
               val body* = bexp(body(def), CExp(#or(a2(def), #?)))
               TDefn(tail?(def), n(def), targs(def), cargs(def),
                     env-a1(n(def)), env-a2(n(def)), args(def), body*)
            val body* = bexp(body(e), c)
            TLetRec(defns*, body*, type(body*), c)
         (e:TFn) :
            val a1* = #or(a1(e), #fresh)
            val a2* = #or(a2(e), #fresh)
            set-env(args(e), a1*)
            val body* = bexp(body(e), CExp(#or(a2(e), #?)))
            TFn(tail?(e), a1*, a2*, args(e), body*, TArrow(TTuple(a1*), a2*), c)
         (e:TMulti) :         
            val funcs* = bexp(funcs(e), c)
            val type* = reduce(TAnd, types(funcs*))
            TMulti(funcs*, type*, c)
         (e:TSeq) :
            val a* = bexp(a(e), CExp(#?))
            val b* = bexp(b(e), c)
            TSeq(a*, b*, type(b*), c)
         (e:TMatch) :         
            val args* = bexp(args(e), CExp(#?))
            val branches* = for b in branches(e) map :
               val atypes* = #or(atypes(b), types(args*))
               set-env(args(b), atypes*)
               val body* = bexp(body(b), c)
               TBranch(args(b), atypes*, body*, type(body*), c)
            TMatch(args*, branches*, #freshv(), c)
         (e:TNew) :
            val ms* = bcomm(methods(e))
            TNew(ms*, type(e), c)
         (e:TRef) :
            val t = env[n(e)]
            var e* = TRef(n(e), t, c)
            match(t) :
               (t:TPoly) : TCapExp(e*, #freshv(length(cargs(t))), #freshv(), c)
               (t) : e*
         (e:TCast) :
            TCast(bexp(exp(e), CExp(#?)), type(e), c)
         (e:TSet) :
            val ref* = bexp(value(e), CExp(#?)) as TRef
            val v* = bexp(value(e), CExp(type(ref*)))
            TSet(ref*, v*, lit-type(false), c)
         (e:TDo) :
            val args* = map(bexp{_, CExp(#freshv())}, args(e))
            val ret* = match(c) :
               (c:CExp) : type(c)
               (c:CDo) : TArrow(TTuple(args(c)), ret(c))
            val f* = bexp(func(e), CDo(types(args*), ret*, #freshv()))
            TDo(f*, args*, #freshv(), c)
         (e:TPolyDo) :
            val args* = map(bexp{_, CExp(#freshv())}, args(e))
            val ret* = match(c) :
               (c:CExp) : type(c)
               (c:CDo) : TArrow(TTuple(args(c)), ret(c))
            val f* = bexp(func(e), CPoly(targs(e), types(args*), ret*))
            TPolyDo(f*, targs(e), args*, #freshv(), c)
         (e:TPrim) :
            val args* = map(bexp{_, CExp(#?)}, args(e))
            TPrim(function(e), args*, prim-type(function(e)), c)
         (e:TCallLS) :
            val args* = map(bexp{_, CExp(#?)}, args(e))
            TCallLS(function(e), targs(e), args*, #?, c)
         (e:TLiteral) :
            TLiteral(value(e), lit-type(value(e)), c)
         (e:TTupleExp) :
            val exps* = map(bexp{_, CExp(#freshv())}, exps(e))
            TTupleExp(exps*, TTuple(types(exps*)), c)
         (e:TMix) :
            val exps* = bexp(exps(e), c)
            TMix(SVar(fresh-n()), exps*, #freshv(), c)
         (e:TElide) :
            e

   ;Return new program
   build-environment()
   TProg(hier(prog), map(bcomm, comms(prog)))


;;============================================================
;;============== Generate Type Constraints ===================
;;============================================================
;         
;defstruct TupleF : (n:Int)
;defstruct SubF : (ti:Type, t:Type)
;defstruct ArgsF : (n:Int)
;defstruct RetF : (n:Int)
;defstruct Fresh
;
;defn generate-type-constraints (prog:TProg) :   
;   defn gen-exp (e:TExp, w:Type) -> False :
;      match(e) :
;         (e:TFn) :
;            val exp-a2 = #upto(#fresh(), w, SubF(a2(e), type(e)))            
;            #with(body(e), #or(a2(e), exp-a2))
;            #upto(a1(e), w, SubF(a1(e), type(e)))
;         (e:TMulti) :
;            for f in funcs(e) do :
;               val exp-a2 = #upto(#fresh(), w, SubF(a2(f), type(e)))               
;               #with(body(e), #or(a2(f), exp-a2))
;               #upto(a1(f), w, SubF(a1(f), type(e)))
;         (e:TNew) :            
;            gen-comm(methods(e))                                  
;         (e:TRef) :
;            #super(expected(n(e)), w)
;         (e:TCast) :
;            #with(exp(e), TGradual())
;         (e:TSet) :
;            #with(value(e), #or(type(ref(e)), TGradual()))
;            #super(type(ref(e)), type(value(e)))
;         (e:TDo) :            
;            val n = length(exps(e))
;            val tf = gen-call(func(e), types(exps(e)), w)
;            val exp-a1 = #downto(#fresh(n), tf, ArgsF(n))
;            #with(exps(e), exp-a1)
;            #downto(type(e), tf, RetF(n))
;         (e:TPolyDo) :
;            val n = length(exps(e))
;            val tf = gen-poly(func(e), targs(e), types(exps(e)))
;            val exp-a1 = #downto(#fresh(n), tf, ArgsF(n))
;            #with(exps(e), exp-a1)
;            #downto(type(e), tf, RefF(n))
;         (e:TPrim) :
;            #with(args(e), TGradual())
;         (e:TCallLS) :
;            #with(args(e), TGradual())
;         (e:TLiteral) :
;            false
;         (e:TTupleExp) :
;            val n = length(exps(e))
;            val ets = #upto(#fresh(n), w, TupleF(n))
;            #with(exps(e), ets)
;         (e:TMix) :
;            #with(exps(e), w)
;            #mix(type(e), types(exps(e)), w)
;         (e:TCapExp) :
;            #with(exp(e), w)
;            val t = type(exp(e)) as TPoly
;            val t* = #sub(t, cargs(t), cargs(e))
;            #cap(cargs(e), t*, w)
;         (e:TElide) :
;            false
;         (e:TMatch) :
;            #with(args(e), TGradual())
;            #with(branches(e), w)
;            #equal(type(e), reduce(TOr, types(branches(e))))
;         (e) :
;            gen-common(e,
;               fn (e) : #with(e, w)
;               fn (e) : error("Unsupported expression: ~" % [e]))
;
;   defn gen-call (e:TExp, w1:List<Type>, w2:Type) -> Type :
;      match(e) :
;         (e:TFn) :
;            val a1* = #or(a1(e), #fresh())
;            set-expected(args(e), a1*)
;            #equal(a1(e), w1) when same-length?(a1(e), w1)
;            #with(body(e), #or(a2(e), w2))
;            TArrow(TTuple(a1*), a2(e))
;         (e:TMulti) :
;            var return = type(e)
;            for f in funcs(e) do :
;               if same-length?(args(f), w1) :
;                  return = #call(f, w1, w2)
;               else :
;                  #equal(a1(f), TBot())
;                  #with(body(f), #or(a2(f), TGradual()))
;            return      
;         (e:TMix) :
;            #call(exps(e), w1, w2)
;            #mix-callable(type(e), types(exps(e)), w1)
;         (e:TCapExp) :
;            val te = #call(exp(e), w1, w2) as TPoly
;            #sub(type(e), cargs(te), cargs(e))
;            #cap-callable(cargs(e), type(e), w1)
;            type(e)            
;         (e:TMatch) :
;            #with(args(e), TGradual())
;            #call(branches(e), w1, w2)
;            #equal(type(e), reduce(TOr, types(branches(e))))
;            type(e)
;         (e) :
;            gen-common(e,
;               fn (e) :
;                  #call(e, w1, w2)
;               fn (e) :
;                  #with(e, TArrow(TTuple(w1, w2)))
;                  type(e))
;
;   defn gen-common<?T> (e:TExp, #up: TExp -> ?T, #else: TExp -> ?T) :
;      match(e) :
;         (e:TLet) :
;            #with(value(e), #or(ntype(e), TGradual()))
;            #equal(ntype(e), type(value(e)))
;            #up(body(e))
;         (e:TLetVar) :   
;            #with(value(e), #or(ntype(e), TGradual()))
;            #equal(ntype(e), type(value(e)))
;            #up(body(e))
;         (e:TLetTuple) :
;            val n = length(ns(e))
;            #with(value(e), TGradual())
;            #downto(ntypes(e), type(value(e)), TupleF(n))
;            #up(body(e))
;         (e:TLetRec) :
;            gen-comm(defns(e))
;            #up(body(e))
;         (e:TSeq) :
;            #with(a(e), TGradual())
;            #up(b(e))
;         (e:TBranch) :
;            #up(body(e))
;         (e) :
;            #else(e)      
;
;   defn gen-poly (e:TExp, wa:List<Type>, w1:List<Type>) -> Type :
;      match(e) :
;         (e:TRef) :
;            false
;         (e:TCapExp) :
;            val te = #call(exp(e), wa, w1) as TPoly
;            #sub(type(e), cargs(te), cargs(e))
;            val t* = #sub(#sub(type(e), targs(te), wa), cargs(te), cargs(e))
;            #cap(cargs(te), t*, w1)
;            t*
;         (e:TMix) :
;            val te = #call(exps(e), wa, w1)
;            val sel = #sel(te, w1)
;            val t* = #mix(#fresh(), te, sel)
;            #mix(type(e), types(exps(e)), sel)
;            t*