defpackage stz/type :
   import core
   import verse
   import stz/il-ir
   import stz/tl-ir
   import stz/namemap
   import stz/infer
   import stz/type-calculus
   import stz/algorithms
   import stz/utils
   import stz/ids

#use-overlay(stz/attempt-lang)

;============================================================
;====================== Driver ==============================
;============================================================

public defn type-program (nm:NameMap, e:IExp) :
   val prog = to-tprog(nm, e)
   set-current-hierarchy(hier(prog))
   println("Infer types")
   val prog* = infer-types(prog)
   println(prog*)
   println("Report errors")
   report-errors(nm, prog*)   
   prog*

;============================================================
;=============== Conversion to Type IR ======================
;============================================================

definterface Assert
defstruct CorrectTArity <: Assert: (info:FileInfo, n:Int, targs:List<Type>)

defn to-tprog (nm:NameMap, e:IExp) :
   ;     State
   ;     =====
   val accum = Vector<TComm>()
   val asserts = Vector<Assert>()
   val errors = Vector<?>()
   val hier = THierarchy()
      
   ;     Utilities
   ;     =========
   val #TN = TNone()
   val #LTN = NoneT()
   val #CN = CNone()
   val #SN = SNone()
   val #IN = INone(FileInfo())
   defn #name (n:Int) : name(nm[n] as VarEntry)
   defn #info (n:Int) : info(nm[n] as VarEntry)
   defn #pr (t:Type) : printable(nm, t)
   defn #pr (ts:Streamable<Type>) : stream(#pr, ts)
   defn cms (xs:Streamable) : join(xs, ", ")
   defn add-comm (c:TComm) : add(accum, c)
   defn add-comm (cs:List<TComm>) : do(add-comm, cs)
   defn name! (e:IExp) : name(e as IVar)
   defn n! (e:IExp) : n(e as VarN)
   defn n! (es:List<IExp>) : map(n!, es)
   defn #comm (es:List<IExp>) : do(#comm, es)
   defn #type (es:List<IExp>) : map(#type, es)
   defn #lstype (es:List<IExp>) : map(#lstype, es)
   defn #exp (es:List<IExp>) : map(#exp, es)
   defn #lsexp (es:List<IExp>) : map(#lsexp, es)
   defn #lscomm (es:List<IExp>) : map(#lscomm, es)
   defn #defn (defs:List<IDefn>) : map(#defn, defs)
   defn #defmethod (defs:List<IDefmethod>) : map(#defmethod, defs)

   defn split-targs (es:List<IExp>) :
      val targs = Vector<Int>()
      val cargs = Vector<Int>()
      for e in es do :
         match(e) :
            (e:VarN) : add(targs, n(e))
            (e:ICap) : add(cargs, n!(name(e)))
      [to-list(targs), to-list(cargs)]

   ;     Transformers
   ;     ============   
   defn #comm (e:IExp) -> False :
      match(e) :
         (e:IBegin) :
            #comm(exps(e))
         (e:IPublic) :
            #comm(exp(e))
         (e:IProtected) :
            #comm(exp(e))
         (e:IDefType) :
            add(hier, HSHEntry(c, args*, p)) where :
               val c = n!(class(e))
               val args* = n!(args(e))
               val p = #type(parent(e))
         (e:IDef) :
            add-comm(destructure-def(e))
         (e:IDefVar) :
            add-comm(TDefVar(n, t, v)) where :
               val n = n!(name(e))
               val t = #type(type(e))
               val v = #exp(value(e)) when value(e) not-typeof INone
         (e:IDefn) :
            add-comm(#defn(e))
         (e:IDefmulti) :
            add-comm(TDefmulti(n, targs, cargs, a1*, a2*)) where :
               val n = n!(name(e))
               val [targs, cargs] = split-targs(targs(e))
               val a1* = #type(a1(e))
               val a2* = #type(a2(e))
         (e:IDefmethod) :
            add-comm(#defmethod(e))
         (e:IFn|IMulti|IBegin|IMatch|IBranch|INew|
            VarN|ICast|ISet|IDo|IPrim|ILiteral|ITuple)  :
            add-comm(TInit(#exp(e)))
         (e:ILSDef) :
            add-comm(TLDef(n!(name(e)), #lstype(type(e)), #lsexp(exp(e))))
         (e:ILSDefVar) :
            val v = #lsexp(exp(e)) when exp(e) not-typeof INone
            add-comm(TLDefVar(n!(name(e)), #lstype(type(e)), v))
         (e:ILSDefType) :
            add(hier, LSHEntry(c, args*, p, fs, rf)) where :
               val c = n!(name(e))
               val args* = n!(args(e))
               val p = #type(parent(e))
               val fs = map(#field, fields(e), types(e))
               val rf = #field?(rfield(e), rtype(e))
         (e:ILSExtern) :
            add-comm(TExtern(n!(name(e)), #lstype(type(e))))
         (e:ILSDefn) :
            val [targs, cargs] = split-targs(targs(e))
            val a1* = #lstype(a1(e))
            val a2* = #lstype(a2(e))
            val body* = #lscomm(body(e))
            add-comm(TLDefn(tail?(e), n!(name(e)), targs, cargs, a1*, a2*, n!(args(e)), body*))         
         (e:ILSSet|ILSLabels|ILSLabel|ILSGoto|ILSReturn|ILSLet|
            ILSIf|ILSMatch|ILSBranch|ILSDef|ILSDefVar) :
            add-comm(TLInit(#lscomm(e)))

   defn #field (name:IExp, type:IExp) :
      val n = n!(name)
      Field(n!(name), #name(n), #lstype(type))
   defn #field? (name:IExp, type:IExp) :
      #field(name, type) when name not-typeof INone

   defn #type (e:IExp) -> Type :
      match(e) :
         (e:ITuple) : TTuple(#type(exps(e)))
         (e:IOf) :
            val n = n!(class(e))
            val targs = #type(args(e))
            add(asserts, CorrectTArity(info(e), n, targs))
            TOf(n, TTuple(targs))
         (e:IAnd) : TAnd(#type(a(e)), #type(b(e)))
         (e:IOr) : TOr(#type(a(e)), #type(b(e)))
         (e:IArrow) : TArrow(TTuple(#type(a1(e))), #type(a2(e)))
         (e:ICap) : TCap(n!(name(e)))
         (e:IGradual) : TGradual()
         (e:IVoid) : TBot()
         (e:INone) : TNone()
         (e:VarN) : TVar(n(e))
         (e:Raw) : TOf(n!(class(e)), TGradual())      

   defn #exp (e:IExp) -> TExp :
      match(e) :
         (e:IFn) :
            TFn(tail?(e), a1*, a2*, ns, body, #TN, #CN) where :
               val a1* = #type(a1(e))
               val a2* = #type(a2(e))
               val [ns, body] = destructure-args(args(e), body(e))
         (e:IMulti) :
            TMulti(fs, #TN, #CN) where :
               val fs = #exp(funcs(e)) as List<TFn>
         (e:IBegin) :
            if empty?(tail(exps(e))) :
               #exp(head(exps(e)))
            else :
               TSeq(a*, b*, #TN, #CN) where :
                  val a* = #exp(head(exps(e)))
                  val binfo = info(exps(e)[1])
                  val b* = #exp(IBegin(tail(exps(e)), binfo))
         (e:IMatch) :
            TMatch(args*, brs*, #TN, #CN) where :
               val args* = #exp(args(e))
               val brs* = #exp(branches(e)) as List<TBranch>
         (e:IBranch) :
            TBranch(ns, ts, body, #TN, #CN) where :
               val ts = #type(types(e))
               val [ns, body] = destructure-args(args(e), body(e))            
         (e:INew) :
            TNew(c, ms, #TN, #CN) where :
               val c = #type(class(e))
               val ms = #defmethod(methods(e) as List<IDefmethod>)
         (e:ISet) :
            TSet(r, v, #TN, #CN) where :
               val r = #exp(name(e)) as TRef
               val v = #exp(value(e))
         (e:IDo) :
            TDo(f*, args*, #TN, #CN) where :
               val f* = #farg(func(e))
               val args* = #exp(args(e))            
         (e:IPrim) :
            TPrim(n, args*, #TN, #CN) where :
               val n = name!(function(e))
               val args* = #exp(args(e))
         (e:ILiteral) :
            TLiteral(value(e), #TN, #CN)
         (e:ITuple) :
            TTupleExp(#exp(exps(e)), #TN, #CN)
         (e:VarN) :
            TRef(n(e), #TN, #CN)
         (e:Mix) :
            TMix(#SN, #exp(exps(e)), #TN, #CN)
         (e:Let) :
            destructure-let(e)
         (e:LetRec) :
            TLetRec(defns*, body*, #TN, #CN) where :
               val defns* = #defn(defns(e) as List<IDefn>)
               val body* = #exp(body(e))
         (e) :
            error("Unsupported expression: ~" % [e])

   defn #farg (e:IExp) -> TExp :
      match(e) :
         (e:IOf) :
            if empty?(args(e)) :
               #exp(class(e))
            else :
               val ts = #type(args(e))
               defn #mix (e:IExp) :
                  match(e) :
                     (e:VarN) :
                        val ref = TRef(n(e), #TN, #CN)
                        TCurry(ref, ts, List(), #TN, #CN)
                     (e:Mix) :
                        TMix(#SN, map(#mix, exps(e)), #TN, #CN)
               #mix(class(e))         
         (e) :
            #exp(e)

   defn #defn (def:IDefn) :
      TDefn(tail?(def), n, targs, cargs, a1*, a2*, args*, body*) where :
         val n = n!(name(def))               
         val [targs, cargs] = split-targs(targs(def))
         val a1* = #type(a1(def))
         val a2* = #type(a2(def))
         val [args*, body*] = destructure-args(args(def), body(def))

   defn #defmethod (def:IDefmethod) :
      TDefmethod(tail?(def), n, m, thisn(def), targs, cargs, a1*, a2*, args*, body*) where :
         val n = fresh-id()
         val m = #exp(multi(def))
         val a1* = #type(a1(def))
         val a2* = #type(a2(def))
         val [targs, cargs] = split-targs(targs(def))
         val [args*, body*] = destructure-args(args(def), body(def))

   defn #lsexp (e:IExp) :
      match(e) :
         (e:ILSNew) :
            val [n, targ] = #lsclass(type(e))
            LSNew(n, targ, #lsexp(args(e)), #LTN, #CN)
         (e:ILSArray) :
            val [n, targ] = #lsclass(type(e))
            LSArray(n, targ, #lsexp(args(e)), #lsexp(length(e)), #LTN, #CN)
         (e:ILSStruct) :
            val [n, targ] = #lsclass(type(e))
            LSStruct(n, targ, #lsexp(args(e)), #LTN, #CN)
         (e:ILSAddr) :
            LSAddr(#lsexp(exp(e)), #LTN, #CN)
         (e:ILSDeref) :
            LSDeref(#lsexp(exp(e)), #LTN, #CN)
         (e:ILSSlot) :
            LSSlot(#lsexp(exp(e)), #lsexp(index(e)), #LTN, #CN)
         (e:ILSField) :
            LSField(#lsexp(exp(e)), name!(name(e)), #LTN, #CN)
         (e:ILSDo) :
            LSDo(f*, args*, #LTN, #CN) where :
               val f* = #lsfarg(func(e))
               val args* = #lsexp(args(e))
         (e:ILSCallC) :
            LSCallC(#lsexp(func(e)), #lsexp(args(e)), #LTN, #CN)
         (e:ILSPrim) :
            val [op, targs] = #lprim(op(e))
            LSPrim(op, targs, #lsexp(args(e)), #LTN, #CN)
         (e:ILSSizeof) :
            LSSizeof(#lstype(type(e)), #LTN, #CN)
         (e:ILSTagof) :
            LSTagof(n!(name(e)), #LTN, #CN)
         (e:ILSAs) :
            LSCast(#lsexp(exp(e)), #lstype(type(e)), #LTN, #CN)
         (e:ILSAnd) :
            LSAnd(#lsexp(a(e)), #lsexp(b(e)), #LTN, #CN)
         (e:ILSOr) :
            LSOr(#lsexp(a(e)), #lsexp(b(e)), #LTN, #CN)
         (e:ILSLetExp) :
            LSLetExp(#lscomm(comm(e)), #lsexp(exp(e)), #LTN, #CN)
         (e:VarN) :
            LSVar(n!(e), #LTN, #CN)
         (e:ILiteral) :
            LSLiteral(value(e), #LTN, #CN)

   defn #lscomm (e:IExp) :
      match(e) :
         (e:IBegin) :
            val a = #lscomm(head(exps(e)))
            val rest = tail(exps(e))
            if empty?(rest) : a
            else : LSSeq(a, #lscomm(IBegin(rest, FileInfo())))
         (e:ILSSet) :
            LSSet(#lsexp(exp(e)), #lsexp(value(e)))
         (e:ILSLabels) :
            LSLabels(n!(names(e)), #lscomm(body(e)))
         (e:ILSLabel) :
            LSLabel(n!(name(e)))
         (e:ILSGoto) :
            LSGoto(n!(name(e)))
         (e:ILSReturn) :
            LSReturn(#lsexp(exp(e)))
         (e:ILSLet) :
            #lscomm(comm(e))
         (e:ILSIf) :
            LSIf(#lsexp(pred(e)), #lscomm(conseq(e)), #lscomm(alt(e)))
         (e:ILSMatch) :
            val args* = #lsexp(args(e))
            val bs = #lscomm(branches(e)) as List<LSBranch>
            LSMatch(args*, bs)
         (e:ILSBranch) :
            LSBranch(n!(args(e)), #type(types(e)), #lscomm(body(e)))      
         (e:ILSDef) :
            LSDef(n!(name(e)), #lstype(type(e)), #lsexp(exp(e)))
         (e:ILSDefVar) :
            val v = #lsexp(exp(e)) when exp(e) not-typeof INone
            LSDefVar(n!(name(e)), #lstype(type(e)), v)

   defn #lsclass (e:IExp) :
      match(e) :
         (e:ILSOfT) : [n!(class(e)), TTuple(#type(args(e)))]
         (e:VarN) : [n!(e), TGradual()]

   defn #lprim (e:IExp) :
      match(e) :
         (e:ILSOfT) : [name!(class(e)), #type(args(e))]
         (e:IVar) : [name!(e), List()]

   defn #lsfarg (e:IExp) :
      match(e) :
         (e:ILSOfT) :
            if empty?(args(e)) :
               #lsexp(class(e))
            else :
               val ts = #type(args(e))
               defn #mix (e:IExp) :
                  match(e) :
                     (e:VarN) :
                        val ref = LSVar(n(e), #LTN, #CN)
                        LSCurry(ref, ts, List(), #LTN, #CN)
                     (e:Mix) :
                        LSMix(#SN, map(#mix, exps(e)), #LTN, #CN)
               #mix(class(e))
         (e) :
            #lsexp(e)

   defn #lstype (e:IExp) :
      match(e) :
         (e:ILSByteT) : ByteT()
         (e:ILSIntT) : IntT()
         (e:ILSLongT) : LongT()
         (e:ILSFloatT) : FloatT()
         (e:ILSDoubleT) : DoubleT()
         (e:ILSUnknownT) : UnknownT()
         (e:ILSOfT) :
            val n = n!(class(e))
            val targs = #type(args(e))
            add(asserts, CorrectTArity(info(e), n, targs))
            StructT(n, TTuple(targs))
         (e:ILSPtrT) : PtrT(#lstype(type(e)))
         (e:ILSRefT) : RefT(#type(type(e)))
         (e:ILSFnT) : FnT(#lstype(a1(e)), #lstype(ar(e)), #lstype(a2(e)))
         (e:Raw) : StructT(n!(class(e)), TGradual())
         (e:INone) : NoneT()
         (e) : error("Not a LoStanza type: ~" % [e])

   ;     Nested Tuple Destructuring
   ;     ==========================
   defn destructure (args:List<IExp>, value:TExp) -> List<KeyValue<List<Int>, TExp>> :
      val [ns, bs] = destructure(args)
      List(ns => value, bs)
      
   defn destructure (args:List<IExp>) -> [List<Int>, List<KeyValue<List<Int>, TExp>>] :
      var bindings = List()
      defn #n (x:IExp) -> Int :
         match(x) :
            (x:ITuple) :
               val n = fresh-n()
               bindings = List(entry, bindings) where :
                  val exps* = map(#n, exps(x))
                  val entry = exps* => TRef(n, #TN, #CN)
               n   
            (x) :
               n!(x)
      val ns = map(#n, args)
      [ns, bindings]

   defn destructure-args (args:List<IExp>, fbody:IExp) -> [List<Int>, TExp] :
      val [ns, bs] = destructure(args)
      var body = #exp(fbody)
      for b in bs do :
         body = TLetTuple(ns, ts, v, body, #TN, #CN) where :
            val [ns, v] = [key(b), value(b)]
            val ts = map({#TN}, ns)         
      [ns, body]

   defn destructure-def (def:IDef) -> List<TDef|TDefTuple> :
      match(name(def), type(def), value(def)) :
         (name:ITuple, type:INone, v) :
            val bs = destructure(exps(name), #exp(v))
            for b in bs map :
               TDefTuple(ns, ts, v) where :
                  val [ns, v] = [key(b), value(b)]
                  val ts = map({#TN}, ns)            
         (name:ITuple, type, v) :
            val tmp = VarN(fresh-id(), info(name))
            append(
               destructure-def(IDef(tmp, type, v, info(name)))
               destructure-def(IDef(name, #IN, tmp, info(name))))
         (name, type, v) :
            list(TDef(n, t*, v*)) where :
               val n = n!(name)
               val t* = #type(type)
               val v* = #exp(v)

   defn destructure-let (lete:Let) -> TExp :
      match(def(lete)) :
         (def:IDefVar) :
            val n = n!(name(def))
            val t = #type(type(def))
            val e = #exp(value(def))
            val b = #exp(body(lete))
            TLetVar(n, t, e, b, #TN, #CN)
         (def:IDef) :
            defn loop (defs:List<TDef|TDefTuple>) :
               if empty?(defs) :
                  #exp(body(lete))
               else :
                  val body = loop(tail(defs))
                  match(head(defs)) :
                     (e:TDef) : TLet(n(e), type(e), value(e), body, #TN, #CN)
                     (e:TDefTuple) : TLetTuple(ns(e), types(e), value(e), body, #TN, #CN)
            loop(destructure-def(def))

   ;     Error Reporting
   ;     ===============
   ;Check hierarchical cycles
   defn check-cycles () :
      defn classes (t:Type) -> List<Int> :
         match(t) :
            (t:TOf) : list(n(t))
            (t:TAnd) : append(classes(a(t)), classes(b(t)))
            (t:TNone) : list()
      val components = strong-components $
         for entry in hier stream :
            n(entry) => classes(parent(entry))
      val cycles =
         {_ as Stream<List<Int>>} $
         filter({_ typeof List}, components)
      for c in cycles do :
         defn msg (ns:List<Int>) :
            join{_, "\n"} $
            for n in ns stream :
               "   ~ at ~" << [#name(n), #info(n)]
         add(errors, "Illegal cycle in type hierarchy. The following types are parents of each other.\n~@" << [
            msg(c)])

   ;Check type arities
   defn check-arities () :
      for assert in asserts do :
         match(assert) :
            (a:CorrectTArity) :
               val arity = length(args(hier[n(a)]))
               if length(targs(a)) != arity :
                  add(errors, "~: Incorrect number of type parameters for type ~. Expecting ~ but given ~@." << [
                     info(a), #name(n(a)), arity, cms(#pr(targs(a)))])

   ;Report errors
   defn report-errors () :
      check-cycles()
      check-arities()
      if not empty?(errors) :
         do(println, errors)
         throw(TypeError())

   ;     Driver
   ;     ======
   #comm(e)
   report-errors()
   TProg(hier, to-list(accum))


;============================================================
;============== Generate Type Variables =====================
;============================================================
defn generate-type-vars (prog:TProg) :
   ;======== Environment ========
   val env = HashTable<Int,Type>({_})

   ;======== Utilities ========
   val #? = TGradual()
   val #fresh = Fresh()
   defn #freshv () : TUVar(fresh-id())
   defn #freshv (n:Int) : map(#freshv{}, 0 to n)
   defn #or (x:Type, y:Type) : y when x typeof TUVar|TNone else x
   defn #or (x:Type, f:Fresh) : #freshv() when x typeof TUVar|TNone else x
   defn #or (xs:List<Type>, y:Type|Fresh) : map(#or{_, y}, xs)
   defn #or (xs:List<Type>, ys:List<Type>) : map(#or, xs, ys)
   defn set-env (n:Int, t:Type) : env[n] = t
   defn set-env (n:Int, f:Fresh) : env[n] = #freshv()
   defn set-env (ns:List<Int>, y:Type|Fresh) : do(set-env{_, y}, ns)
   defn set-env (ns:List<Int>, ts:List<Type>) : do(set-env, ns, ts)   
   defn bexp (es:List<TExp>, c:Context) : map(bexp{_, c}, es)
   defn bcomm<?T> (cs:List<?T&TComm>) : map(bcomm, cs)
   defn bmulti (es:List<TExp>, targs:List<TVar>, c:Context) : map(bmulti{_, targs, c}, es)
   defn #types (es:List<TExp>) : map(type, es)
   
   defn env-a1 (n:Int) :
      defn* loop (t:Type) :
         match(t) :
            (t:TPoly) : loop(func(t))
            (t:TArrow) : types(a(t) as TTuple)
      loop(env[n])

   defn env-a2 (n:Int) :
      defn* loop (t:Type) :
         match(t) :
            (t:TPoly) : loop(func(t))
            (t:TArrow) : b(t)
      loop(env[n])

   defn wrap-poly (t:TArrow, targs:List<Int>, cargs:List<Int>) :
      if empty?(targs) and empty?(cargs) : t
      else : TPoly(targs, cargs, t)
   defn fn-type (c:TDefn|TDefmethod) :
      val t = TArrow(TTuple(a1*), a2*) where :
         val a1* = #or(a1(c), #?)
         val a2* = #or(a2(c), #fresh)
      wrap-poly(t, targs(c), cargs(c))
   defn fn-type (c:TDefmulti) :
      val t = TArrow(TTuple(a1*), a2*) where :
         val a1* = #or(a1(c), #?)
         val a2* = #or(a2(c), #?)
      wrap-poly(t, targs(c), cargs(c))

   ;======== Specialized Type Constructors ========
   defn lit-type (v) :
      match(v) :
         (v:False) : TOf(FALSE-TYPE-ID, TTuple(List()))
         (v:True) : TOf(TRUE-TYPE-ID, TTuple(List()))
         (v) : error("Literal type ~ not yet implemented." % [v])
      ;defn base (n:Int) : TOf(n, TTuple(List()))
      ;defn raw (n:Int) : TOf(n, TGradual())
      ;match(v) :
      ;   (v:False) : base(False(hier(prog)))
      ;   (v:Int) : base(Int(hier(prog)))
      ;   (v:String) : base(String(hier(prog)))
      ;   (v:Symbol) : base(Symbol(hier(prog)))
      ;   (v:List) : raw(List(hier(prog)))

   defn prim-type (f:Symbol) :
      error("Primitive type not yet implemented.")


   ;======== Build top level environment ========
   defn build-environment () :
      for c in comms(prog) do :
         match(c) :
            (c:TDef) : set-env(n(c), #or(type(c), #fresh))
            (c:TDefTuple) : set-env(ns(c), #fresh)
            (c:TDefVar) : set-env(n(c), #or(type(c), #fresh))
            (c:TDefn) : set-env(n(c), fn-type(c))
            (c:TDefmulti) : set-env(n(c), fn-type(c))
            (c:TDefmethod) : set-env(n(c), fn-type(c))
            (c:TInit) : false
         
   ;======== Productions ========
   defn bcomm<?T> (c:?T&TComm) -> T :
      {_ as T&TComm} $ match(c) :
         (c:TDef) :
            TDef(n(c), t*, v*) where :
               val v* = bexp(value(c), CExp(#or(type(c), #?)))
               val t* = env[n(c)]
         (c:TDefTuple) :
            TDefTuple(ns(c), ts*, v*) where :
               val v* = bexp(value(c), CExp(#?))
               val ts* = map({env[_]}, ns(c))            
         (c:TDefVar) :
            TDefVar(n(c), t*, v*) where :
               val v* = bexp(value(c) as TExp, CExp(#or(type(c), #?))) when value(c) != false
               val t* = env[n(c)]            
         (c:TDefn) :
            TDefn(tail?(c), n(c), targs(c), cargs(c), a1*, a2*, args(c), body*) where :
               val a1* = env-a1(n(c))
               val a2* = env-a2(n(c))
               set-env(args(c), map(uncap, a1*))
               val body* = bexp(body(c), CExp(#or(a2(c), #?)))
         (c:TDefmulti) :
            TDefmulti(n(c), targs(c), cargs(c), a1*, a2*) where :
               val a1* = env-a1(n(c))
               val a2* = env-a2(n(c))               
         (c:TDefmethod) :
            TDefmethod(tail?(c), n(c), m*, thisn(c), targs(c), cargs(c), a1*, a2*, args(c), body*) where :
               val a1* = env-a1(n(c))
               val a2* = env-a2(n(c))
               val t* = uncap(TArrow(TTuple(a1*), a2*))
               val m* = bmulti(multi(c), map(TVar, targs(c)), CMulti(t*))
               set-env(args(c), map(uncap, a1*))
               val body* = bexp(body(c), CExp(#or(a2(c), #?)))
         (c:TInit) :
            TInit(bexp(exp(c), CExp(#?)))
            
   defn bmulti (e:TExp, targs*:List<TVar>, c:Context) -> TExp :
      match(e) :
         (e:TRef) :
            val t = env[n(e)]
            val e* = TRef(n(e), t, c)
            val cargs* = match(t) :
               (t:TPoly) : #freshv(length(cargs(t)))
               (t:TArrow) : List()
            if empty?(targs*) and empty?(cargs*) : e*
            else : TCurry(e*, targs*, cargs*, #freshv(), c)            
         (e:TMix) :
            TMix(sel*, exps*, #freshv(), c) where :
               val sel* = SVar(fresh-id())
               val exps* = bmulti(exps(e), targs*, c)

   defn bexp (e:TExp, c:Context) -> TExp :
      match(e) :
         (e:TLet) :
            TLet(n(e), type(v*), v*, body*, type(body*), c) where :
               val v* = bexp(value(e), CExp(#or(ntype(e), #?)))
               set-env(n(e), #or(ntype(e), type(v*)))
               val body* = bexp(body(e), c)
         (e:TLetVar) :
            TLetVar(n(e), t*, v*, body*, type(body*), c) where :
               val t* = #or(ntype(e), #fresh)
               val v* = bexp(value(e) as TExp, CExp(t*)) when value(e) != false
               set-env(n(e), t*)
               val body* = bexp(body(e), c)
         (e:TLetTuple) :
            TLetTuple(ns(e), ts*, v*, body*, type(body*), c) where :
               val ts* = #or(ntypes(e), #fresh)
               val v* = bexp(value(e), CExp(#?))
               set-env(ns(e), ts*)
               val body* = bexp(body(e), c)
         (e:TLetRec) :
            TLetRec(defns*, body*, type(body*), c) where :
               for def in defns(e) do :
                  set-env(n(def), fn-type(def))
               val defns* = for d in defns(e) map :
                  TDefn(tail?(d), n(d), targs(d), cargs(d), a1*, a2*, args(d), body*) where :
                     val a1* = env-a1(n(d))
                     val a2* = env-a2(n(d))
                     set-env(args(d), map(uncap, a1*))
                     val body* = bexp(body(d), CExp(#or(a2(d), #?)))
               val body* = bexp(body(e), c)
         (e:TFn) :
            TFn(tail?(e), a1*, a2*, args(e), body*, t*, c) where :
               val a1* = #or(a1(e), #fresh)
               val a2* = #or(a2(e), #fresh)
               val t* = TArrow(TTuple(a1*), a2*)
               set-env(args(e), a1*)
               val body* = bexp(body(e), CExp(#or(a2(e), #fresh)))
         (e:TMulti) :
            TMulti(funcs*, type*, c) where :
               val funcs* = bexp(funcs(e), c) as List<TFn>
               val type* = reduce(TAnd, #types(funcs*))
         (e:TSeq) :
            TSeq(a*, b*, type(b*), c) where :
               val a* = bexp(a(e), CExp(#?))
               val b* = bexp(b(e), c)
         (e:TMatch) :         
            TMatch(args*, branches*, #freshv(), c) where :
               val args* = bexp(args(e), CExp(#?))
               val branches* = for b in branches(e) map :
                  TBranch(args(b), atypes*, body*, type(body*), c) where :
                     val atypes* = #or(atypes(b), #types(args*))
                     set-env(args(b), atypes*)
                     val body* = bexp(body(b), c)
         (e:TNew) :
            TNew(class(e), ms*, class(e), c) where :
               val ms* = bcomm(methods(e))
         (e:TCurry) :
            TCurry(e*, targs(e), cargs*, #freshv(), c) where :
               val t = env[n(ref(e))]
               val e* = TRef(n(ref(e)), t, c)
               val cargs* = match(t) :
                  (t:TPoly) : #freshv(length(cargs(t)))
                  (t) : List()
         (e:TRef) :
            val t = env[n(e)]
            val e* = TRef(n(e), t, c)
            match(t) :
               (t:TPoly) :
                  TCurry(e*, List(), #freshv(n), #freshv(), c) where :
                     val n = length(cargs(t))
               (t) : e*
         (e:TCast) :
            TCast(exp*, targ(e), targ(e), c) where :
               val exp* = bexp(exp(e), CExp(#?))
         (e:TSet) :
            TSet(ref*, v*, lit-type(false), c) where :
               val ref* = bexp(ref(e), CExp(#?)) as TRef
               val v* = bexp(value(e), CExp(type(ref*)))
         (e:TDo) :         
            TDo(f*, args*, #freshv(), c) where :
               val args* = map(bexp{_, CExp(#freshv())}, args(e))
               val ret* = type(c as CExp|CDo)
               val f* = bexp(func(e), CDo(#types(args*), ret*, args*))
         (e:TPrim) :
            TPrim(function(e), args*, t*, c) where :
               val args* = bexp(args(e), CExp(#?))
               val t* = prim-type(function(e))
         (e:TLiteral) :
            TLiteral(value(e), lit-type(value(e)), c)
         (e:TTupleExp) :
            TTupleExp(exps*, t*, c) where :
               val exps* = map(bexp{_, CExp(#freshv())}, exps(e))
               val t* = TTuple(#types(exps*))
         (e:TMix) :
            TMix(sel*, exps*, #freshv(), c) where :
               val sel* = SVar(fresh-id())
               val exps* = bexp(exps(e), c)

   ;Return new program
   build-environment()
   TProg(hier(prog), bcomm(comms(prog)))

;============================================================
;============== Generate Type Constraints ===================
;============================================================
defstruct TupleF : ()
defstruct SubF : (ti:Type, t:Type)
defstruct ArgsF : ()
defstruct RetF : (n:Int)

defn infer-types (prog:TProg) :
   ;======== State ========
   val required-env = HashTable<Int,TUVar>({_})
   val constraints = Vector<Constraint>()
   
   ;======== Utilities ========
   val #? = TGradual()
   val #fresh = Fresh()
   defn set-required (n:Int, t:Type) :
      match(t) :
         (t:TUVar) : required-env[n] = t
         (t) : false
   defn set-required (ns:List<Int>, ts:List<Type>) :
      do(set-required, ns, ts)
   defn addc (c:Constraint) : add(constraints, c)   
   defn #or (x:Type, y:Type) : y when x typeof TUVar else x
   defn #or (x:Type, f:Fresh) : TUVar(fresh-n()) when x typeof TUVar else x
   defn #or (xs:List<Type>, y:Type|Fresh) : map(#or{_, y}, xs)
   defn #ctxts (es:List<TExp>) : map(ctxt, es)
   defn #types (es:List<TExp>) : map(type, es)
   defn #types (cs:List<CExp>) : map(type, cs)
   defn #equal (ats:List<Type>, bts:List<Type>) : do(#equal, ats, bts)
   defn #equal (ats:List<Type>, b:Type) : do(#equal{_, b}, ats)
   defn #flow (rs:List<TUVar>, t:Type, w:Type) : do(#flow{_, t, w}, rs)
   defn gen-comm (cs:Streamable<TComm>) : do(gen-comm, cs)

   ;Capture i'th element in m element tuple
   defn #tuple-cap (t:TUVar, i:Int, m:Int) :
      TTuple $ for j in 0 to m map :
         if j == i : TCap(n(t))
         else : #?

   ;Attempt to apply the given type arguments to a type
   defn #targ-apply (t*:Type, targs*:List<Type>, cargs*:List<TUVar>) :
      label<Type> return :
         match(t*) :
            (t*:TPoly) :
               ;Check Arity
               return(TNone()) when length(targs(t*)) != length(targs*)                  
               return(TNone()) when length(cargs(t*)) != length(cargs*)
               ;Create substitution function
               val env = map(KeyValue, ns, ts) where :
                  val ns = append(targs(t*), cargs(t*))
                  val ts = append(targs*, cargs*)
               defn sub (t:Type) :
                  match(t) :
                     (t:TCap) : TCap(n(lookup!(env, n(t)) as TUVar))
                     (t:TVar) : lookup(env, n(t), t)
                     (t) : map(sub, t)
               ;Return applied arrow      
               TArrow(a*, b*) where :
                  val a* = sub(a(func(t*)))
                  val b* = #sub(b(func(t*)), env)
            (t*) :
               return(TNone())   
      
   ;===== Constraint Upward and Downward Propagators =====
   ;Propagate type upwards towards a subform
   defn #upto (r:Type, w:Type, f:SubF) :
      ;Substitute TUVar(n*) with t*, and all other TUVar with ?      
      defn sub (t:Type, n*:Int, t*:Type) :
         match(t) :
            (t:TUVar) : 
               if n(t) == n* : t*
               else : #?
            (t) : map(sub{_, n*, t*}, t)            
      match(r, ti(f)) :
         (r:TUVar, ti:TUVar) :
            val t* = sub(t(f), n(ti), TCap(n(r)))
            #cap(r, t*, w)
         (r, ti) :
            false

   ;Propagate type upwards towards elements of tuple form
   defn #upto (rs:List<TUVar>, w:Type, f:TupleF) :
      val n = length(rs)
      for (r in rs, i in 0 to n) do :
         #cap(r, #tuple-cap(r, i, n), w)

   ;Propagate type downwards towards elements of tuple form
   defn #downto (rs:List<TUVar>, w:Type, f:TupleF) :
      val n = length(rs)
      for (r in rs, i in 0 to n) do :
         #cap(r, w, #tuple-cap(r, i, n))
   
   ;Propagate type downwards towards arguments of function
   defn #downto (rs:List<TUVar>, w:Type, f:ArgsF) :
      val n = length(rs)
      for (r in rs, i in 0 to n) do :
         val a1 = #tuple-cap(r, i, n)
         #cap(r, w, TArrow(a1, #?))

   ;Propagate type downwards towards return of function   
   defn #downto (r:TUVar, w:Type, f:RetF) :
      val a = TTuple(map({#?}, 0 to n(f)))
      val b = TCap(n(r))
      #cap(r, w, TArrow(a, b))

   ;===== Constraint Generation Utilities =====
   ;Create supertype constraint
   defn #super (a:Type, b:Type) :
      match(a, b) :
         (a:TUVar, b) : addc(SuperConstraint(n(a), b))
         (a, b) : false

   ;Create equality constraint
   defn #equal (a:Type, b:Type) :
      match(a) :
         (a:TUVar) : addc(EqualConstraint(n(a), b))
         (a) : false
   
   ;Create capture constraint
   defn #cap (r:TUVar, x:Type, y:Type) :
      addc(FlowConstraint(n(r), x, y))

   ;Create a selection constraint
   defn #select (s:SVar, ats:List<Type>, bt:Type, min-bt:Type) :
      addc(SelConstraint(n(s), ats, bt, min-bt))

   ;Create a method selection constraint
   defn #select-method (s:SVar, at:Type, bts:List<Type>) :
      addc(SelMethodConstraint(n(s), at, bts))

   ;Create a method pick constraint
   defn #pick (t:TUVar, s:SVar, ys:List<Type>) :
      addc(PickConstraint(n(t), n(s), ys))

   ;Create a substitution constraint
   defn #sub (t:Type, env:List<KeyValue<Int,Type>>) :
      val r = TUVar(fresh-n())
      addc(SubConstraint(n(r), t, env))
      r

   ;Create a mixture constraint
   defn #mix (t:TUVar, s:SVar, ats:List<Type>) :
      addc(MixConstraint(n(t), n(s), ats))
   
   ;Create a threshold constraint
   defn #thresh (s:SVar) :
      val r = SVar(fresh-n())
      addc(ThresholdConstraint(n(r), n(s)))
      r
   
   ;Create a flow constraint
   defn #flow (r:TUVar, t:Type, w:Type) :
      ;Isolate a single capture variable
      defn isolate (n*:Int, t:Type) :
         match(t) :
            (t:TCap) :
               if n(t) == n* : t
               else : TUVar(n(t))
            (t) : map(isolate{n*, _}, t)
      #cap(r, isolate(n(r), t), w)

   ;======== Productions ========
   ;Required Type for Expression
   defn required-type (e:TExp) :
      defn reqt (n:Int, t:Type) :
         if key?(required-env, n) : required-env[n]
         else : t
      match(e) :
         (e:TFn) :            
            val a1* = map(reqt, args(e), a1(e))
            val a2* = #or(a2(e), #?)
            TArrow(TTuple(a1*), a2*)
         (e:TMulti) : reduce(TAnd, stream(required-type, funcs(e)))
         (e:TMatch) : reduce(TOr, stream(required-type, branches(e)))
         (e:TBranch|TLet|TLetVar|TLetTuple) : required-type(body(e))
         (e) : type(e)

   ;Constraint Generation for Commands
   defn gen-comm (c:TComm) :
      ;Constraints for subexpressions
      match(c) :
         (c:TDef|TDefTuple) : gen-exp(value(c))
         (c:TDefVar) : gen-exp(value(c) as TExp) when value(c) != false
         (c:TDefn) : gen-exp(body(c))
         (c:TDefmethod) : (gen-exp(multi(c)), gen-exp(body(c)))
         (c:TInit) : gen-exp(exp(c))
         (c:TDefmulti) : false         
      ;Additional constraints
      match(c) :
         (c:TDef) : #equal(type(c), type(value(c)))
         (c:TDefTuple) : #downto(types(c) as List<TUVar>, type(value(c)), TupleF())
         (c:TDefVar) : #super(type(c), type(value(c) as TExp)) when value(c) != false
         (c:TDefn) : #equal(a2(c), type(body(c)))
         (c:TDefmethod) : #equal(a2(c), type(body(c)))
         (c) : false

   ;Constraint generation for expressions
   defn gen-exp (e:TExp) :
      ;Specialized constraints
      match(e, ctxt(e)) :
         (e:TFn, c:CExp) :
            ;Create required types for arguments
            set-required(args(e), #or(a1(e), #fresh))
            ;Expected return type
            #upto(exp-a2, type(c), SubF(a2(e), type(e))) where :
               val exp-a2 = type(ctxt(body(e)) as CExp)
            ;Infer argument types
            for t in a1(e) do :
               #upto(t, type(c), SubF(t, type(e)))
            ;Inferred return type
            #equal(a2(e), type(body(e)))
         (e:TFn, c:CDo) :
            ;Create required types for arguments
            set-required(args(e), #or(a1(e), #fresh))
            ;Expected return type
            #equal(exp-a2, ret(c)) where :
               val exp-a2 = type(ctxt(body(e)) as CExp)
            ;Infer argument types
            if length(args(e)) == length(args(c)) :
               #equal(a1(e), args(c))
            ;Inferred return type
            #equal(a2(e), type(body(e)))
         (e:TMulti, c:CExp) :
            for f in funcs(e) do :
               ;Create required types for arguments
               set-required(args(f), #or(a1(f), #fresh))
               ;Expected return type
               #upto(exp-a2, type(c), SubF(a2(f), type(e))) where :
                  val exp-a2 = type(ctxt(body(f)) as CExp)
               ;Infer argument types
               for t in a1(f) do :
                  #upto(t, type(c), SubF(t, type(e)))
               ;Inferred return type
               #equal(a2(f), type(body(f)))
         (e:TMulti, c:CDo) :
            for f in funcs(e) do :
               if length(args(f)) == length(args(c)) : gen-exp(f)
               else : #equal(a1(f), TBot())
         (e:TSet, c) :
            #super(type(ref(e)), type(value(e)))
         (e:TDo, c) :
            val f = func(e)
            ;Expected argument types
            #downto(exp-a1, required-type(f), ArgsF()) where :
               val cs = #ctxts(args(e)) as List<CExp>
               val exp-a1 = #types(cs) as List<TUVar>
            ;Infer return type
            #downto(type(e) as TUVar, type(f), RetF(length(args(e))))
         (e:TPrim, c) :
            error("Not yet implemented.")
         (e:TTupleExp, c:CExp) :
            ;Expected expression types
            #upto(exp-a1, type(c), TupleF()) where :
               val cs = #ctxts(exps(e)) as List<CExp>
               val exp-a1 = #types(cs) as List<TUVar>
         (e:TRef, c:CExp|CDo) :
            ;Required type
            if key?(required-env, n(e)) :
               #super(required-env[n(e)], type(c))                  
         (e:TCurry, c:CExp|CMulti|CDo) :
            val cvs = cargs(e) as List<TUVar>
            ;Apply parametric types
            val t* = #targ-apply(type(ref(e)), targs(e), cvs)
            #equal(type(e), uncap(t*))
            ;Capture cargs
            #flow(cvs, t*, type(c))
         (e:TMix, c:CExp) :
            val sv = sel(e) as SVar
            ;Compute Selection
            #select(sv, #types(exps(e)), type(c), #?)
            ;Compute Mixture
            #mix(type(e) as TUVar, #thresh(sv), #types(exps(e)))
         (e:TMix, c:CDo) :
            val sv = sel(e) as SVar
            ;Compute Selection
            #select(sv, #types(exps(e)), t, reqt) where :
               val t = TArrow(TTuple(args(c)), #?)
               val reqt = TArrow(TTuple(map(required-type, arg-exps(c))), #?)
            ;Compute Mixture
            #mix(type(e) as TUVar, sv, #types(exps(e)))
         (e:TMix, c:CMulti) :
            val sv = sel(e) as SVar
            ;Compute selection
            #select-method(sv, type(c), #types(exps(e)))
            ;Compute pick
            #pick(type(e) as TUVar, sv, #types(exps(e)))
         (e:TMatch, c) :
            #equal(type(e), reduce(TOr, #types(branches(e))))
         (e:TLetVar, c) :
            if value(e) != false :
               #super(ntype(e), type(value(e) as TExp))
         (e:TLetTuple, c) :
            #downto(ts, vt, TupleF()) where :
               val ts = ntypes(e) as List<TUVar>
               val vt = type(value(e))
         (e, c) :
            false

      ;Constraints for subexpressions and commands
      match(e) :
         (e:TLetRec) :
            gen-comm(defns(e))
            gen-exp(body(e))
         (e:TMulti) :
            do(gen-exp{body(_)}, funcs(e))
         (e:TNew) :
            gen-comm(methods(e))
         (e:TCurry) :
            false
         (e) :
            do(gen-exp, e)

   ;======== Fill Results =========
   defn fill (prog:TProg, results:SolveResults) :
      defn fill-ctxt (c:Context) -> Context :
         map(fill-t, c)
      defn fill-s (s:Selection) -> Selection :
         match(s) :
            (s:SVar) : sels(results)[n(s)]
            (s) : s
      defn fill-t (t:Type) -> Type :
         match(t) :
            (t:TUVar) : get?(types(results), n(t), t)
            (t) : map(fill-t, t)
      defn fill-e (e:TExp) -> TExp :
         map{fill-t, _} $
         map{fill-e, _} $
         map{fill-c, _} $
         map{fill-ctxt, _} $
         map{fill-s, _} $
         e
      defn fill-c (c:TComm) -> TComm :
         map{fill-e, _} $
         map{fill-t, _} $
         c
         
      TProg(hier(prog), map(fill-c, comms(prog)))
   
   ;======== Driver ========
   println("generate type vars")
   val prog* = generate-type-vars(prog)
   println(prog*)
   println("generate constraints")
   gen-comm(comms(prog*))
   println("solve constraints")
   val results = solve(constraints)
   println("fill results")
   fill(prog*, results)

;============================================================
;=================== Print a Type ===========================
;============================================================
defn cms (xs:Streamable) : join(xs, ", ")

defn printable (nm:NameMap, t:Type) :
   defn #name (n:Int) : name(nm[n] as VarEntry)
   defn #carg (n:Int) : "?~" << [#name(n)]   
   defn lvl (t:Type) :
      match(t) :
         (t:TArrow|TPoly) : 0
         (t:TOr) : 1
         (t) : 2         

   defn p0 (t:Type) : pt(t, 0)
   defn p0 (ts:List<Type>) : stream(p0, ts)
   defn pt (t:Type, l:Int) :
      defn pn (t2:Type) : pt(t2, lvl(t))
      defn p+ (t2:Type) : pt(t2, lvl(t) + 1)
      
      val r = match(t) :
         (t:TArrow) :
            match(a(t)) :
               (a:TTuple) :
                  if length(types(a)) == 1 : "~ -> ~" << [p+(head(types(a))), pn(b(t))]
                  else : "(~@) -> ~" << [cms(p0(types(a))), pn(b(t))]
               (a:TGradual) : "(? ...) -> ~" << [pn(b(t))]
         (t:TPoly) :
            val ts = concat(stream(#name, targs(t)), stream(#carg, cargs(t)))
            val f = pn(func(t))
            "<~@> . ~" << [cms(ts), f]
         (t:TOr) :
            "~|~" << [pn(a(t)), pn(b(t))]
         (t:TAnd) :
            "~&~" << [pn(a(t)), pn(b(t))]
         (t:TOf) :
            match(type(t)) :
               (ta:TTuple) :
                  if empty?(types(ta)) : #name(n(t))
                  else : "~<~@>" << [#name(n(t)), cms(p0(types(ta)))]
               (ta:TGradual) :
                  #name(n(t))
         (t:TGradual) :
            "?"
         (t:TBot) :
            "Void"
         (t:TVar) :
            #name(n(t))
         (t:TUVar) :
            "?"
         (t:TCap) :
            #carg(n(t))
         (t:TNone) :
            "none"
         (t:TTuple) :
            "[~@]" << [cms(p0(types(t)))]
      if lvl(t) < l : "(~)" << [r]
      else : r
   p0(t)

defn printable (nm:NameMap, t:LSType) :
   defn #pr (t:LSType) : printable(nm, t)
   defn #pr (t:Type) : printable(nm, t)
   defn #pr (ts:Streamable<LSType>) : stream(#pr, ts)
   defn #pr (ts:Streamable<Type>) : stream(#pr, ts)
   defn #ap (ts:Streamable<LSType>, t:LSType) : concat(ts, [t])
   defn #name (n:Int) : name(nm[n] as VarEntry)
   match(t) :
      (t:ByteT) : "byte"
      (t:IntT) : "int"
      (t:LongT) : "long"
      (t:FloatT) : "float"
      (t:DoubleT) : "double"
      (t:UnknownT) : "?"
      (t:PtrT) : "ptr<~>" << [#pr(type(t))]
      (t:RefT) : "ref<~>" << [#pr(type(t))]
      (t:FnT) :
         match(r(t)) :
            (r:NoneT) : "(~@) -> ~" << [cms(#pr(a(t))), #pr(b(t))]
            (r:LSType) : "(~@ ...) -> ~" << [cms(#pr(#ap(a(t), r))), #pr(b(t))]
      (t:StructT) :
         match(type(t)) :
            (ta:TTuple) :
               if empty?(types(ta)) : #name(n(t))
               else : "~<~@>" << [#name(n(t)), cms(#pr(types(ta)))]
            (ta:TGradual) :
               #name(n(t))
   
;============================================================
;=================== Report Errors ==========================
;============================================================

defn report-errors (nm:NameMap, prog:TProg) :
   ;======== State ========
   val errors = Vector<Vector<?>>()   

   ;======== Utilities ========
   val #? = TGradual()
   defn unknown? (x:True|False|Maybe|Unknown) : x typeof Unknown
   defn not-st? (x:Type, y:Type) :
      match(x, y) :
         (x:TNone, y) : false
         (x, y:TNone) : false
         (x, y) : subtype?(x, y) == false
   defn not-st? (x:TExp, y:Type) : not-st?(type(x), y)
   defn not-st? (x:Type, y:TExp) : not-st?(x, type(y))
   defn not-st? (x:TExp, y:TExp) : not-st?(type(x), type(y))
   defn cms (xs:Streamable) : join(xs, ", ")
   defn #pr (t:Type) : printable(nm, t)
   defn #pr (ts:Streamable<Type>) : stream(#pr, ts)
   defn #types (es:List<TExp>) : map(type, es)
   
   defn add-error (p:Int, msg) :
      while length(errors) < p + 1 :
         add(errors, Vector<?>())
      add(errors[p], msg)

   defn unresolved? (t:Type) :
      match(t) :
         (t:TUVar) : true
         (t) : any?(unresolved?, children(t))

   defn resolved-pr (x) :
      match(x) :
         (xs:Streamable) : reduce(max{_, resolved-pr(_)}, 0, x)
         (x:Type) : 1 when unresolved?(x) else 0
         (x:TExp) : resolved-pr(type(x))

   defn all-pairs<?T> (xs:Streamable<?T>) :
      val xs* = to-array(xs)
      generate<[T, T]> :
         for i in 0 to length(xs*) do :
            for j in (i + 1) to length(xs*) do :
               yield([xs*[i], xs*[j]])

   defn has-name? (n:Int) :
      key?(nm,n) and (nm[n] typeof VarEntry)

   defn #name (n:Int) :
      name(nm[n] as VarEntry)

   defn not-sm? (x:Type, y:Type) :
      match(x, y) :
         (x:TArrow, y:TArrow) : submethod?(x, y) == false
         (x, y) : false

   defn #select<?T> (xs:List<?T>, ss:List) :
      to-list $ for (x in xs, s in ss) filter :
         s != false

   defn tarity (t:Type) :
      match(t) :
         (t:TArrow) : 0
         (t:TPoly) : length(targs(t))
      
   ;======== Phase 1: Error Detection ========
   defn check (c:TComm) :
      ;Check constraints
      match(c) :
         (c:TDef) :
            no-inferred-type(c) when unresolved?(type(c))
            bad-assign(c) when not-st?(value(c), type(c))
         (c:TDefTuple) :
            val t? = TTuple(map({#?}, types(c)))
            val t = TTuple(types(c))
            not-tuple(c) when not-st?(value(c), t?)
            no-inferred-type(c) when any?(unresolved?, types(c))
            bad-assign(c) when not-st?(value(c), t)
         (c:TDefVar) :
            no-inferred-type(c) when unresolved?(type(c))
            if value(c) != false :
               bad-assign(c) when not-st?(value(c) as TExp, type(c))
         (c:TDefn) :
            no-inferred-ret(c) when unresolved?(a2(c))
            bad-ret(c) when not-st?(body(c), a2(c))
         (c:TDefmethod) :
            val t = type(ctxt(multi(c)) as CMulti)
            val tm = type(multi(c))
            check-multi(multi(c))               
            bad-method(c) when not-sm?(t, tm)
            no-inferred-ret(c) when unresolved?(a2(c))
            bad-ret(c) when not-st?(body(c), a2(c))
         (c) :
            false
      ;Check subexpressions
      match(c) :
         (c:TDefmethod) : check(body(c))
         (c) : do(check{_:TExp}, c)

   defn check-multi (e:TExp) :
      match(e) :
         (e:TRef) :
            false
         (e:TMix) :
            val exps* = #select(exps(e), sels(sel(e) as SSel))
            val n = length(exps*)
            do(check-multi, exps*)
            no-method(e) when n == 0
            amb-method(e) when n > 1
         (e:TCurry) :
            check(e)
               
   defn check (e:TExp) :
      ;Check constraints
      match(e) :
         (e:TLet) :
            no-inferred-type(e) when unresolved?(ntype(e))               
            bad-assign(e) when not-st?(value(e), ntype(e))               
         (e:TLetVar) :
            no-inferred-type(e) when unresolved?(ntype(e))
            if value(e) != false :
               bad-assign(e) when not-st?(value(e) as TExp, ntype(e))
         (e:TLetTuple) :
            val t? = TTuple(map({#?}, ntypes(e)))
            val t = TTuple(ntypes(e))
            not-tuple(e) when not-st?(value(e), t?)               
            no-inferred-type(e) when any?(unresolved?, ntypes(e))
            bad-assign(e) when not-st?(value(e), t)
         (e:TFn) :
            no-inferred-args(e) when any?(unresolved?, a1(e))               
            no-inferred-ret(e) when unresolved?(a2(e))
            bad-ret(e) when not-st?(body(e), a2(e))
         (e:TMatch) :
            if none?(unresolved?{type(_)}, args(e)) :
               for b in branches(e) do :               
                  if any?({not overlap?(type(_), _)}, args(e), atypes(b)) :
                     bad-branch(e, b)
         (e:TCast) :
            if not unresolved?(type(exp(e))) :
               if not overlap?(type(exp(e)), targ(e)) :
                  bad-cast(e)
         (e:TSet) :
            bad-set(e) when not-st?(value(e), ref(e))
         (e:TDo) :
            val t? = TArrow(#?, #?)
            val t = TArrow(TTuple(#types(args(e))), #?)
            not-function(e) when not-st?(func(e), t?) else
            bad-call(e) when not-st?(func(e), t)
         (e:TMix) :
            val ss = sels(sel(e) as SSel)
            if all?({_ typeof False}, ss) :
               no-mix(e)
            else if any?(unknown?, ss) :
               amb-mix(e)
            else :
               ;Check disjoint
               val es = #select(exps(e), ss)
               val disjoint = let :
                  for [x, y] in all-pairs(#types(es)) all? :
                     disjoint?(x as TArrow, y as TArrow, type(ctxt(e) as CExp|CDo))
               amb-mix(e) when not disjoint
         (e:TCurry) :
            val n = tarity(type(ref(e)))
            bad-tarity(e) when n != length(targs(e))
            no-capture(e) when any?(unresolved?, cargs(e))
         (e) :
            false
            
      ;Check subexpressions
      match(e) :
         (e:TMix) :
            for (e in exps(e), s in sels(sel(e) as SSel)) do :
               check(e) when s typeof True|Maybe
         (e:TCurry) :
            false      
         (e) :
            do(check{_:TExp}, e)
            do(check{_:TComm}, e)

   ;======== Phase 2: Report Creation ========
   defn name? (x:Int|List<Int>, str:String, default:String) :
      match(x) :
         (xs:List<Int>) :
            if all?(has-name?, xs) : str << [cms(stream(#name, xs))]
            else : default
         (x:Int) :
            if has-name?(x) : str << [#name(x)]
            else : default
   defn def-name (c:TLetTuple|TLetVar|TLet|TDefTuple|TDefVar|TDef) :
      match(c) :
         (c:TDef) : name?(n(c), "global value ~", "global value")
         (c:TDefVar) : name?(n(c), "global variable ~", "global variable")
         (c:TDefTuple) : name?(ns(c), "global values ~@", "tuple elements")
         (c:TLet) : name?(n(c), "value ~", "value")
         (c:TLetVar) : name?(n(c), "variable ~", "variable")
         (c:TLetTuple) : name?(ns(c), "values ~@", "tuple elements")         
   defn no-inferred-type (c:TLetTuple|TLetVar|TLet|TDefTuple|TDefVar|TDef) :
      val p = match(value(c)) :
         (v:TExp) : resolved-pr(type(v))
         (v:False) : 0
      add-error(p, "Could not infer type of ~." << [def-name(c)])

   defn def-type (c:TLetTuple|TLetVar|TLet|TDefTuple|TDefVar|TDef) :
      match(c) :
         (c:TLetVar|TLet) : ntype(c)
         (c:TDef|TDefVar) : type(c)
         (c:TLetTuple) : TTuple(ntypes(c))
         (c:TDefTuple) : TTuple(types(c))
   defn bad-assign (c:TDef|TDefVar|TLet|TLetVar|TLetTuple|TDefTuple) :
      val name = def-name(c)
      val t = def-type(c)
      val p = resolved-pr([t, value(c) as TExp])
      add-error(p, "Cannot assign expression of type ~ to ~ with declared type ~." <<
         [#pr(type(value(c) as TExp)), name, #pr(t)])

   defn not-tuple (c:TDefTuple|TLetTuple) :
      val n = length(ns(c))
      val p = resolved-pr(value(c))
      add-error(p, "Cannot deconstruct expression of type ~ into tuple of length ~." <<
         [#pr(type(value(c))), n])

   defn no-inferred-args (e:TFn) :
      val w = type(ctxt(e) as CExp|CDo)
      val p = resolved-pr(w)
      for (a in args(e), t in a1(e), i in 0 to false) do :
         if unresolved?(t) :
            val name = name?(a, "argument ~", "argument ~" % [i])
            add-error{p, _} $
               if unresolved?(w) : "Could not infer type for ~." << [name]
               else : "Could not infer type for ~. Function used in context expecting type ~." << [name, #pr(w)]

   defn no-inferred-ret (e:TFn|TDefn|TDefmethod) :
      val p = resolved-pr([a1(e), body(e)])
      val name = match(e) :
         (e:TFn) : "anonymous function"
         (e:TDefn) : name?(n(e), "function ~", "function")
         (e:TDefmethod) : "method"
      add-error(p, "Could not infer return type for ~." << [name])

   defn bad-ret (f:TDefn|TDefmethod|TFn) :
      val name = match(f) :
         (f:TDefn) : name?(n(f), "function ~", "function")
         (f:TDefmethod) : "method"
         (f:TFn) : "anonymous function"
      defn loop (e:TExp) :
         match(e) :
            (e:TLet|TLetVar|TLetTuple|TLetRec|TBranch) : loop(body(e))
            (e:TMatch) : do(loop, branches(e))
            (e) : 
               val p = resolved-pr([a2(f), e])
               if not-st?(e, a2(f)) :
                  add-error(p, "Cannot return an expression of type ~ for ~ with declared return type ~." << [
                     #pr(type(e)), name, #pr(a2(f))])
      loop(body(f))

   defn bad-branch (e:TMatch, b:TBranch) :
      val bargs = stream({[_, _]}, args(b), atypes(b))
      for (a in args(e), [ba, bt] in bargs, i in 0 to false) do :
         if not overlap?(type(a), bt) :
            val name = name?(ba, "argument ~", "argument ~" % [i])
            add-error(0, "Branch type ~ for ~ cannot match against match argument of type ~." << [
               #pr(bt), name, #pr(type(a))])

   defn bad-cast (e:TCast) :
      add-error(0, "Cannot cast expression of type ~ to type ~." << [
         #pr(type(exp(e))), #pr(targ(e))])

   defn bad-set (e:TSet) :
      val p = resolved-pr([ref(e), value(e)])
      val name = name?(n(ref(e)), "variable ~", "variable")
      add-error(p, "Cannot assign expression of type ~ to ~ with declared type ~." << [
         #pr(type(value(e))), name, #pr(type(ref(e)))])

   defn not-function (e:TDo) :
      val p = resolved-pr(func(e))
      val name = match(func(e)) :
         (f:TRef) : name?(n(f), "Value ~", "Value")
         (f) : "Expression"
      add-error(p, "~ of type ~ cannot be called as a function." << [
         name, #pr(type(func(e)))])

   defn bad-call (e:TDo) :
      val p = resolved-pr([func(e), args(e)])
      val name = get-name(func(e)) where :
         defn get-name (e:TExp) :
            match(e) :
               (e:TRef) : name?(n(e), "function ~", "function")
               (e:TMix) : get-name(head(exps(e)))
               (e:TCurry) : get-name(ref(e))
               (e) : "expression"
      add-error(p, "Cannot call ~ of type ~ with arguments of type ~@" << [
         name, #pr(type(func(e))), cms(map(#pr{type(_)}, args(e)))])

   defn get-ref (e:TExp) :
      match(e) :
         (e:TRef) : e
         (e:TCurry) : ref(e)
   defn possibilities (exps:Streamable<TExp>) :      
      join{_, "\n"} $ for e in exps stream :
         val r = get-ref(e)
         "   ~: ~" << [#name(n(r)), #pr(type(r))]                        
   defn no-mix (e:TMix) :
      val name = #name(n(r)) where :
         val r = get-ref(head(exps(e)))
      match(ctxt(e)) :
         (c:CDo) :
            val p = resolved-pr([exps(e), args(c)])
            add-error(p, "No appropriate function ~ for arguments of type ~@. Possibilities are:\n~@" << [
               name, cms(#pr(args(c))), possibilities(exps(e))])
         (c:CExp) :
            val p = resolved-pr([exps(e), type(c)])
            add-error(p, "No appropriate function ~ for expected type ~. Possibilities are:\n~@" << [
               name, #pr(type(c)), possibilities(exps(e))])
   defn amb-mix (e:TMix) :
      val exps* = to-list $
         for (e in exps(e), s in sels(sel(e) as SSel)) filter :
            s != false
      val name = #name(n(r)) where :
         val r = get-ref(head(exps*))
      match(ctxt(e)) :
         (c:CDo) :
            val p = resolved-pr([map(get-ref, exps*), args(c)])
            add-error(p, "Ambiguous call to overloaded function ~ with arguments of type ~@. Possibilities are:\n~@" << [
               name, cms(#pr(args(c))), possibilities(exps*)])
         (c:CExp) :
            val p = resolved-pr([map(get-ref, exps*), type(c)])
            add-error(p, "Ambiguous reference to overloaded function ~ for expected type ~. Possibilities are:\n~@" << [
               name, #pr(type(c)), possibilities(exps*)])

   defn no-method (e:TMix) :
      val name = #name(n(r)) where :
         val r = get-ref(head(exps(e)))
      val t = type(ctxt(e) as CMulti)
      val p = resolved-pr([exps(e), t])
      add-error(p, "No appropriate multi ~ for method of type ~@. Possibilities are:\n~@" << [
         name, #pr(t), possibilities(exps(e))])

   defn amb-method (e:TMix) :
      val ss = sels(sel(e) as SSel)
      val exps* = #select(exps(e), ss)
      val name = #name(n(r)) where :
         val r = get-ref(head(exps(e)))
      val t = type(ctxt(e) as CMulti)
      val p = resolved-pr([exps*, t])
      add-error(p, "Multiple appropriate multis ~ for method of type ~@. Possibilities are:\n~@" << [
         name, #pr(t), possibilities(exps*)])         

   defn bad-method (c:TDefmethod) :
      val name = get-name(multi(c)) where :
         defn get-name (e:TExp) :
            match(e) :
               (e:TMix) : get-name(head(exps(e)))
               (e:TCurry) : get-name(ref(e))
               (e:TRef) : #name(n(e))
      val t = type(ctxt(multi(c)) as CMulti)
      val p = resolved-pr([t, type(multi(c))])
      add-error(p, "Cannot attach method of type ~ to multi ~ of type ~." << [
         #pr(t), name, #pr(type(multi(c)))])

   defn bad-tarity (e:TCurry) :
      match(type(ref(e))) :
         (t:TPoly) :
            add-error(0, "Function ~ of type ~ requires ~ type arguments, but received ~@." << [
               #name(n(ref(e))), #pr(type(ref(e))), cms(#pr(targs(e)))])
         (t:TArrow) :
            add-error(0, "Function ~ of type ~ does not accept type arguments, but received ~@." << [
               #name(n(ref(e))), #pr(type(ref(e))), cms(#pr(targs(e)))])

   defn no-capture (e:TCurry) :
      val rt = type(ref(e)) as TPoly
      for (a in cargs(rt), t in cargs(e)) do :
         if unresolved?(t) :
            val a-name = name?(a, "argument ~", "argument")
            val r-name = #name(n(ref(e)))
            match(ctxt(e)) :
               (c:CExp|CMulti) :
                  val p = resolved-pr(type(c))
                  add-error(p, "Could not capture ~ for function ~ of type ~. Expected type is ~." << [
                     a-name, r-name, #pr(rt), #pr(type(c))])
               (c:CDo) :
                  val p = resolved-pr(args(c))
                  add-error(p, "Could not capture ~ for function ~ of type ~. Called with arguments of type ~@." << [
                     a-name, r-name, #pr(rt), cms(#pr(args(c)))])                  

   ;======== Driver ========
   do(check, comms(prog))
   for i in 0 to length(errors) do :
      if not empty?(errors[i]) :
         do(println, errors[i])
         throw(TypeError())

;;============================================================
;;============== LoStanza Type Inference =====================
;;============================================================
;
;defn infer-lostanza-types (nm:NameMap, prog:TProg) :
;   ;====== State ======
;   val env = HashTable<Int,False|LSType>({_})
;   val structs = HashTable<Int,LSDefStruct>({_})
;   val errors = Vector<?>()
;
;   ;====== Utilities ======
;   defn set-env (n:Int, t:LSType) :
;      env[n] = t
;      
;   defn set-env (ns:List<Int>, ts:List<LSType>) :
;      do(set-env, ns, ts)
;   
;   defn do-ls (f:LSTComm -> ?, prog:TProg) :
;      for c in comms(prog) do :
;         match(c) :
;            (c:TLoStanza) : f(comm(c))
;            (c) : false
;
;   defn map-ls (f:LSTComm -> LSTComm, prog:TProg) :
;      val comms* = for c in comms(prog) map :
;         match(c) :
;            (c:TLoStanza) : TLoStanza(f(comm(c)))
;            (c) : c
;      TProg(hier(prog), comms*)
;
;   defn issue-errors () :
;      if not empty?(errors) :
;         do(println, errors)
;         throw(TypeError())
;
;   defn ensure!<T> (x:T|False) :
;      match(x) :
;         (x:False) : fail()
;         (x:T) : x
;
;   defn type! (e:LSExp) : ensure!<LSType>(type(e))
;   defn type! (c:LSLetVar) : ensure!<LSType>(type(c))      
;   defn value! (e:LSDefVar|LSLetVar) : ensure!<LSExp>(value(e))
;
;   defn deref (e:LSExp) :
;      attempt :
;         match(type!(e)) :
;            (t:RefT|PtrT) : deref(LSDeref(e, type(t)))
;            (t) : fail()
;      else : e
;
;   defn struct-type! (t:StructT, fname:Symbol) :
;      label<LSType> return :
;         val s = structs[n(t)]
;         match(rfield(s)) :
;            (f:StructField) :
;               if name(f) == fname :
;                  return(PtrT(type(f)))
;            (f:False) : false
;         for f in fields(s) do :
;            return(type(f)) when name(f) == fname
;         fail()
;
;   defn lvalue? (e:LSExp) :
;      match(e) :
;         (e:LSVar|LSDeref|LSSlot) : true
;         (e:LSField) : lvalue?(exp(e))
;
;   ;====== Phase 1: Build Global Environment ======
;   defn build-env (c:LSTComm) :
;      match(c) :
;         (c:LSDefVar) : set-env(n(c), type(c))
;         (c:LSDefStruct) : structs[n(c)] = c
;         (c:LSExtern) : set-env(n(c), type(c))
;         (c:LSExternFn) : set-env(n(c), type(c))
;         (c:LSDefn) : set-env(n(c), FnT(a1(c), false, a2(c)))
;         (c) : false
;
;   ;====== Phase 2: Inference ======
;   defn infer-tc (c:LSTComm) -> LSTComm :
;      match(c) :
;         (c:LSDefVar) :
;            val c* = map(infer-e, c)
;            attempt :
;               val tau = type!(value!(c*))
;               bad-def(c*) when not subtype?(tau, type(c*))
;            c*
;         (c:LSDefn) :
;            set-env(args(c), a1(c))
;            map(infer-c{_, a2(c)}, c)
;         (c:LSTopComm) :
;            map(infer-c{_, false}, c)
;         (c:LSDefStruct|LSExtern|LSExternFn) :
;            c
;
;   defn infer-c (c:LSComm, ret:False|LSType) -> LSComm :
;      defn ret! () : ret as LSType            
;      match(c) :
;         (#c:LSTCall) :
;            val c = map(infer-e, #c)
;            attempt :
;               val tau = type!(exp(c))
;               bad-ret(c, ret!()) when not subtype?(tau, ret!())
;            c            
;         (#c:LSSet) :
;            val c = map(infer-e, #c)
;            attempt :
;               val tau = type!(exp(c))
;               not-lvalue(c) when not lvalue?(exp(c))
;               val tau* = type!(value(c))               
;               bad-set(c) when not subtype?(tau*, tau)
;            c
;         (#c:LSReturn) :
;            val c = map(infer-e, #c)
;            attempt :
;               val tau = type!(exp(c))
;               bad-ret(c, ret!()) when not subtype?(tau, ret!())
;            c   
;         (c:LSLetVar) :
;            val v* = infer-e(value(c))
;            val type* = match(type(c)) :
;               (t:LSType) : t
;               (t:False) : type(v* as LSExp)
;            env[n(c)] = type*   
;            val body* = infer-c(body(c), ret)
;            val c* = LSLetVar(n(c), type*, v*, body*)
;            attempt :
;               val tau = type!(value!(c*))
;               bad-let(c*) when not subtype?(tau, type!(c))
;            c*
;         (c:LSSeq) :
;            map(infer-c{_, ret}, c)
;         (#c:LSIf) :
;            val c = map(infer-c{_, ret}, map(infer-e, #c))
;            attempt :
;               val tau = type!(pred(c))
;               bad-pred(c) when not subtype?(tau, LongT())
;            c
;         (c:LSMatch) :
;            val arg* = infer-e(arg(c))
;            val br* = for b in branches(c) map :
;               env[n(b)] = type(b)
;               val body* = infer-c(body(b), ret)
;               LSBranch(n(b), type(b), body*)
;            val c* = LSMatch(arg*, br*)
;            attempt :
;               val t = type!(arg*)
;               val reft = RefT(UnknownT())
;               bad-match(c*) when not subtype?(t, reft)
;            c*
;         (c:LSCall|LSLabel|LSGoto) :
;            map(infer-e, c)
;
;   defn infer-e (e:False) -> False :
;      false
;      
;   defn infer-e (e:LSExp) -> LSExp :
;      match(map(infer-e, e)) :
;         (e:LSVar) :
;            LSVar(n(e), env[n(e)])
;         (e:LSRef) :
;            LSRef(n(e), args(e), RefT(StructT(n(e))))
;         (e:LSRefArray) :
;            attempt :
;               val tau = type!(length(e))
;               bad-length(e) when not subtype?(tau, LongT())
;            LSRefArray(n(e), length(e), args(e), RefT(StructT(n(e))))
;         (e:LSStruct) :
;            LSStruct(n(e), args(e), StructT(n(e)))
;         (e:LSPtr) :
;            val type* = attempt :
;               val tau = type!(exp(e))
;               not-lvalue(e) when not lvalue?(exp(e))
;               PtrT(tau)
;            LSPtr(exp(e), type*)
;         (e:LSDeref) :
;            val type* = attempt :
;               match(type!(exp(e))) :
;                  (t:RefT) : type(t)
;                  (t:PtrT) : type(t)
;                  (t) : (bad-deref(e), fail())
;            LSDeref(exp(e), type*)
;         (e:LSSlot) :
;            val type* = attempt :
;               match(type!(exp(e))) :
;                  (t:PtrT) : type(t)
;                  (t) : (bad-slot(e), fail())
;            attempt :
;               val tau = type!(index(e))
;               bad-index(e) when not subtype?(tau, LongT())
;            LSSlot(exp(e), index(e), type*)      
;         (e:LSField) :
;            val exp* = deref(exp(e))               
;            val type* = attempt :
;               val tau = type!(exp*)
;               match(tau) :
;                  (tau:StructT) :
;                     attempt : struct-type!(tau, name(e))
;                     else : (no-field(e), fail())
;                  (tau) : (bad-field(e), fail())
;            LSField(exp*, name(e), type*)
;         (e:LSDo) :
;            val type* = attempt :
;               match(type!(func(e))) :
;                  (tau:FnT) :
;                     val ts = map(type!, args(e))
;                     bad-call(e) when not subtype?(ts, false, a(tau), r(tau))
;                     b(tau)
;                  (tau) :
;                     not-func(e)
;                     fail()
;            LSDo(func(e), args(e), type*)         
;         (e:LSCallC) :
;            val type* = attempt :
;               match(type!(func(e))) :
;                  (tau:FnT) :
;                     val ts = map(type!, args(e))
;                     bad-call(e) when not subtype?(ts, false, a(tau), r(tau))
;                     b(tau)
;                  (tau) :
;                     not-func(e)
;                     fail()
;            LSCallC(func(e), args(e), type*)                     
;         (e:LSSizeof) :
;            LSSizeof(argtype(e), LongT())
;         (e:LSTagof) :
;            LSTagof(n(e), LongT())
;         (e:LSCast) :
;            attempt :
;               val tau = type!(exp(e))
;               bad-cast(e) when not castable?(tau, type!(e))
;            e               
;         (e:LSValue) :
;            e
;         (e:LSAnd) :
;            defn long? (e:LSExp) : subtype?(type!(e), LongT())               
;            attempt: bad-and-a(e) when not long?(a(e))
;            attempt: bad-and-b(e) when not long?(b(e))            
;            LSAnd(a(e), b(e), LongT())
;         (e:LSOr) :
;            defn long? (e:LSExp) : subtype?(type!(e), LongT())
;            attempt: bad-or-a(e) when not long?(a(e))
;            attempt: bad-or-b(e) when not long?(b(e))            
;            LSOr(a(e), b(e), LongT())
;
;   ;====== Phase 3: Report Generation ======
;   defn cms (xs:Streamable) : join(xs, ", ")   
;   defn has-name? (n:Int) : key?(nm,n) and (nm[n] typeof VarEntry)
;   defn #name (n:Int) : name(nm[n] as VarEntry)
;   defn #pr (t:LSType) : printable(nm, t)
;   defn #pr (ts:Streamable<LSType>) : stream(#pr, ts)
;         
;   defn name? (x:Int|List<Int>, format:String, default:String) :
;      match(x) :
;         (xs:List<Int>) :
;            if all?(has-name?, xs) : format << [cms(stream(#name, xs))]
;            else : default
;         (x:Int) :
;            if has-name?(x) : format << [#name(x)]
;            else : default
;
;   defn name? (e:LSExp, format:String, default:String) :
;      match(e) :
;         (e:LSVar) : name?(n(e), format, default)
;         (e) : default
;
;   defn bad-def (e:LSDefVar) :
;      val name = name?(n(e), "Variable ~", "Variable")
;      add(errors, "~ of declared type ~ cannot be initialized with expression of type ~." << [
;         name, #pr(type(e)), #pr(type!(value!(e)))])
;
;   defn bad-let (c:LSLetVar) :
;      val name = name?(n(c), "Variable ~", "Variable")
;      add(errors, "~ of declared type ~ cannot be initialized with expression of type ~." << [
;         name, #pr(type!(c)), #pr(type!(value!(c)))])
;
;   defn bad-ret (c:LSTCall|LSReturn, ret:LSType) :
;      add(errors, "Cannot return expression of type ~ from function with declared type ~." << [
;         #pr(type!(exp(c))), #pr(ret)])
;
;   defn bad-set (c:LSSet) :
;      val name = name?(exp(c), "variable ~", "location")
;      add(errors, "Cannot assign expression of type ~ to ~ of type ~." << [
;         #pr(type!(value(c))), name, #pr(type!(exp(c)))])
;
;   defn bad-pred (c:LSIf) :
;      add(errors, "Expression of type ~ cannot be used as predicate to if statement." << [
;         #pr(type!(pred(c)))])
;
;   defn bad-match (c:LSMatch) :
;      add(errors, "Expression of type ~ cannot be used as argument to match statement." << [
;         #pr(type!(arg(c)))])         
;
;   defn bad-length (e:LSRefArray) :
;      add(errors, "Expression of type ~ cannot be used as length." << [
;         #pr(type!(length(e)))])
;         
;   defn bad-index (e:LSSlot) :
;      add(errors, "Expression of type ~ cannot be used as index." << [
;         #pr(type!(index(e)))])
;
;   defn not-lvalue (e:LSPtr) :
;      add(errors, "Cannot create pointer to non-lvalue expression.")
;
;   defn not-lvalue (c:LSSet) :
;      add(errors, "Cannot assign to non-lvalue expression.")
;
;   defn bad-deref (e:LSDeref) :
;      add(errors, "Cannot dereference expression of type ~." << [#pr(type!(exp(e)))])
;
;   defn bad-slot (e:LSSlot) :
;      add(errors, "Cannot access indexed slot in expression of type ~." << [#pr(type!(exp(e)))])
;
;   defn no-field (e:LSField) :
;      add(errors, "Expression of type ~ has no field named ~." << [
;         #pr(type!(exp(e))), name(e)])
;
;   defn bad-field (e:LSField) :
;      add(errors, "Cannot access named field ~ in expression of type ~." << [
;         name(e), #pr(type!(exp(e)))])
;
;   defn bad-call (e:LSDo|LSCallC) :
;      val name = name?(func(e), "Function ~", "Function")
;      add(errors, "~ of type ~ cannot be called with arguments of type ~@." << [
;         name, #pr(type!(func(e))), cms(#pr(map(type!, args(e))))])
;
;   defn not-func (e:LSDo|LSCallC) :
;      val name = name?(func(e), "Value ~", "Expression")
;      add(errors, "~ of type ~ cannot be called as a function." << [
;         name, #pr(type!(func(e)))])
;
;   defn bad-cast (e:LSCast) :
;      add(errors, "Expression of type ~ cannot be cast to ~." << [
;         #pr(type!(exp(e))), #pr(type!(e))]) 
;
;   defn bad-and-a (e:LSAnd) :
;      add(errors, "Expression of type ~ cannot be used as operand to and." << [
;         #pr(type!(a(e)))])
;         
;   defn bad-and-b (e:LSAnd) :
;      add(errors, "Expression of type ~ cannot be used as operand to and." << [
;         #pr(type!(b(e)))])
;
;   defn bad-or-a (e:LSOr) :
;      add(errors, "Expression of type ~ cannot be used as operand to or." << [
;         #pr(type!(a(e)))])
;         
;   defn bad-or-b (e:LSOr) :
;      add(errors, "Expression of type ~ cannot be used as operand to or." << [
;         #pr(type!(b(e)))])
;
;   ;====== Driver ======
;   do-ls(build-env, prog)
;   val prog* = map-ls(infer-tc, prog)
;   issue-errors()
;   prog*
;   
;
;;============================================================
;;=============== General Utilities ==========================
;;============================================================
defstruct Fresh

defstruct TypeError <: Exception

defn uncap (t:Type) :
   match(t) :
      (t:TCap) : TUVar(n(t))
      (t) : map(uncap, t)

defn map<?T> (f:Int -> ?T, r:Range) :
   to-list(stream(f, r))
