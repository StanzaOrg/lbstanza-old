;See License.txt for details about licensing.

defpackage stz/type :
  import core
  import collections
  import stz/il-ir
  import stz/tl-ir
  import stz/dl-ir
  import stz/tl-to-dl
  import stz/namemap
  import stz/infer
  import stz/type-calculus
  import stz/algorithms
  import stz/utils
  import stz/ids
  import stz/primitives

;============================================================
;====================== Driver ==============================
;============================================================

public defn type-program (ipackages:Tuple<IPackage>, environment:Tuple<Export>) -> TProg|TypeErrors :
  val nm = NameMap(seq(namemap, ipackages), environment)
  val idtable = IDTable(nm)
  within set-idtable(idtable) :
    try :
      val prog = to-tprog(ipackages, environment, nm)
      set-current-hierarchy(hier(prog))

      ;println("===== Type Hierarchy =====")
      ;for entry in hier(prog) do :
      ;  val name = name(nm[n(entry)])
      ;  val parent = match(parent(entry)) :
      ;    (p:Type) : printable(nm, p)
      ;    (p:False) : false
      ;  println("Type %_ (%_) <: %_" % [n(entry), name, parent])
      ;println("==========================")

      val [prog*, env, ls-env] = infer-types(prog, environment)
      report-errors(nm, prog*, env, ls-env)
      val tpackages* = for p in packages(prog*) map :
        sub-packageio(p, to-dl(p, hier(prog*), nm))
      sub-packages(prog*, tpackages*)
    catch (e:TypeErrors) :
      e

;============================================================
;=============== Conversion to Type IR ======================
;============================================================

deftype Assert
defstruct CorrectTArity <: Assert: (info:False|FileInfo, n:Int, targs:List<Type>)

defstruct DefChild :
  n: Int
  args: List<Int>
  parent: Type

defn to-tprog (ipackages:Tuple<IPackage>, environment:Tuple<Export>, nm:NameMap) :  
  ;     State
  ;     ===== 
  var accum = Vector<TComm>()
  val asserts = Vector<Assert>()
  val errors = Vector<?>()
  val defchilds = Vector<DefChild>()

  defn add-error (e) :
    add(errors, to-string(e))

  ;    Annotation State
  ;    ================
  var current-annotations: List<KeyValue<Symbol,?>> = List()
  defn push-annotations<?T> (xs:List<KeyValue<Symbol,?>>, f:() -> ?T) -> T :
    let-var current-annotations = append(xs, current-annotations) :
      f()
  defn current-fn-properties () :
    val show-opt = lookup?(current-annotations, `show-optimizations, false) as True|False
    FnProperties(show-opt)

  ;     Utilities
  ;     =========
  val #IN = INone(false)
  defn #name (n:Int) : name(nm[n])
  defn #pr (t:Type) : printable(nm, t)
  defn #pr (ts:Seqable<Type>) : seq(#pr, ts)
  defn cms (xs:Seqable) : join(xs, ", ")
  defn add-comm (c:TComm) : add(accum, c)
  defn add-comm (cs:List<TComm>) : do(add-comm, cs)
  defn name! (e:IExp) : name(e as IVar)
  defn n! (e:IExp) : n(e as VarN)
  defn n! (es:List<IExp>) : map(n!, es)
  defn #comm (es:List<IExp>) : do(#comm, es)
  defn #type (es:List<IExp>) : map(#type, es)
  defn #lstype (es:List<IExp>) : map(#lstype, es)
  defn #exp (es:List<IExp>) : map(#exp, es)
  defn #lsexp (es:List<IExp>) : map(#lsexp, es)
  defn #lscomm (es:List<IExp>) : map(#lscomm, es)
  defn #defn (defs:List<IDefn>) : map(#defn, defs)
  defn #defmethod (defs:List<IDefmethod>) : map(#defmethod, defs)

  defn info-str (n:Int) :
    match(info(nm[n])) :
      (info:FileInfo) : "at %_" % [info]
      (info:False) : "in package %~" % [package(nm[n])]

  defn split-targs (es:List<IExp>) :
    val targs = Vector<Int>()
    val cargs = Vector<Int>()
    for e in es do :
      match(e) :
        (e:VarN) : add(targs, n(e))
        (e:ICap) : add(cargs, n!(name(e)))
    [to-list(targs), to-list(cargs)]

  ;     Transformers
  ;     ============
  defn #tpackage (ipackage:IPackage) -> TPackage :
    let-var accum = Vector<TComm>() :
      do(#comm, exps(ipackage))
      val imports = for i in imports(ipackage) map :
        name!(package(i as IImport))
      TPackage(name(ipackage), imports, to-list(accum))
  
  defn #comm (e:IExp) -> False :
    match(e) :
      (e:IBegin) :
        #comm(exps(e))
      (e:IPublic) :
        #comm(exp(e))
      (e:IProtected) :
        #comm(exp(e))
      (e:IAnnotate) :
        push-annotations{properties(e), _} $ fn () :
          #comm(body(e))
      (e:IDefType) :
        add-comm(TDefType(n, args, p, cs, info(e))) where:
          val n = n!(class(e))
          val args = n!(args(e))
          val p = #type(parent(e))
          val cs = map(#child{_ as IDefChild}, children(e))
      (e:IDef) :
        add-comm(destructure-def(e))
      (e:IDefVar) :
        add-comm(TDefVar(n, t, v, info(e))) where :
          val n = n!(name(e))
          val t = #type(type(e))
          val v = #exp(value(e)) when value(e) is-not INone
      (e:IDefn) :
        add-comm(#defn(e))
      (e:IDefmulti) :
        add-comm(TDefmulti(n, targs, cargs, a1*, a2*, inf)) where :
          val n = n!(name(e))
          val inf = info(e)
          val [targs, cargs] = split-targs(targs(e))
          val a1* = #type(a1(e))
          val a2* = #type(a2(e))
      (e:IDefmethod) :
        add-comm(#defmethod(e))
      (e:IFn|IMulti|IBegin|IMatch|IBranch|INew|
        VarN|ICast|IUpCast|ISet|IDo|IPrim|ILiteral|ITuple|ILet)  :
        add-comm(TInit(#exp(e), info(e)))
      (e:ILSDef) :
        val t = #lstype(type(e)) as LSType
        val exp = #lsexp(exp(e))
        add-comm(TLDef(n!(name(e)), t, exp, info(e)))
      (e:ILSDefVar) :
        val t = #lstype(type(e)) as LSType
        val v = #lsexp(exp(e)) when exp(e) is-not INone
        add-comm(TLDefVar(n!(name(e)), t, v, info(e)))
      (e:ILSDefType) :
        add-comm(TLDefType(n, args, p, fs, info(e))) where :
          val n = n!(name(e))
          val args = n!(args(e))
          val p = #type(parent(e))
          val fs = to-list $ generate<Field> :
            do(yield{#field(_, _)}, fields(e), types(e))
            yield(#rfield(rfield(e), rtype(e))) when rfield(e) is-not INone
      (e:ILSExtern) :
        val t = #lstype(type(e)) as LSType
        val n = n!(name(e))
        val lbl = name(nm[n])
        add-comm(TExtern(n, t, lbl, info(e)))
      (e:ILSDefn) :
        val [targs, cargs] = split-targs(targs(e))
        val a1* = #lstype(a1(e)) as List<LSType>
        val a2* = #lstype(a2(e)) as LSType
        val body* = #lscomm(body(e))
        val inf = info(e)
        val ps = current-fn-properties()
        add-comm(TLDefn(ps, tail?(e), n!(name(e)), targs, cargs, a1*, a2*, n!(args(e)), body*, inf))
      (e:ILSExternFn) :
        val a1* = #lstype(a1(e)) as List<LSType>
        val a2* = #lstype(a2(e)) as LSType
        val body* = #lscomm(body(e))
        val ps = current-fn-properties()
        val n = n!(name(e))
        val lbl = name(nm[n])
        add-comm(TLExternFn(ps, n, a1*, a2*, n!(args(e)), body*, lbl, info(e)))            
      (e:ILSDefmethod) :
        val [targs, cargs] = split-targs(targs(e))
        val m = #exp(multi(e))
        val a1* = #lstype(a1(e)) as List<LSType>
        val a2* = #lstype(a2(e)) as LSType
        val body* = #lscomm(body(e))
        val inf = info(e)
        val ps = current-fn-properties()
        add-comm(TLDefmethod(ps, tail?(e), fresh-id(), m, targs, cargs, a1*, a2*, n!(args(e)), body*, inf))
      (e:ILSSet|ILSLabels|ILSLet|
        ILSIf|ILSMatch|ILSBranch|ILSDef|ILSDefVar|
        ILSDo|ILSPrim|ILSCallC) :
        add-comm(TLInit(#lscomm(e), info(e)))
      (e) :
        fatal("Unsupported form: %~" % [e])

  defn #child (e:IDefChild) :
    Child(n, args, t) where :
      val n = n!(name(e))
      val args = n!(args(e))
      val t = #type(parent(e)) as Type
      add(asserts, CorrectTArity(info(e), n, map(TVar, args)))

  defn #field (name:IExp, type:IExp) :
    val n = n!(name)
    val t = #lstype(type) as LSType
    Field(n!(name), #name(n), t)
  defn #rfield (name:IExp, type:IExp) :
    val n = n!(name)
    val t = #lstype(type) as LSType
    Field(n!(name), #name(n), RestT(t))

  defn #type (e:IExp) -> False|Type :
    defn #type! (e:IExp) : #type(e) as Type
    defn #type! (es:List<IExp>) : #type(es) as List<Type>
    match(e) :
      (e:ITuple) : TTuple(#type!(exps(e)))
      (e:IOf) :
        val n = n!(class(e))
        val targs = #type!(args(e))
        add(asserts, CorrectTArity(info(e), n, targs))
        TOf(n, TTuple(targs))
      (e:IAnd) : TAnd(#type!(a(e)), #type!(b(e)))
      (e:IOr) : TOr(#type!(a(e)), #type!(b(e)))
      (e:IArrow) : TArrow(TTuple(#type!(a1(e))), #type!(a2(e)))
      (e:ICap) : TCap(n!(name(e)))
      (e:IGradual) : TGradual()
      (e:IVoid) : TBot()
      (e:VarN) : TVar(n(e))
      (e:Raw) : TOf(n!(class(e)), TGradual())
      (e:INone) : false

  defn #exp (e:IExp) -> TExp :
    match(e) :
      (e:IFn) :
        TFn(tail?(e), a1*, a2*, ns, body, false, false, false, inf) where :
          val a1* = #type(a1(e))
          val a2* = #type(a2(e))
          val inf = info(e)
          val [ns, body] = destructure-args(args(e), body(e))
      (e:IMulti) :
        TMulti(fs, false, false, false, inf) where :
          val fs = #exp(funcs(e)) as List<TFn>
          val inf = info(e)
      (e:IBegin) :
        if empty?(tail(exps(e))) :
          #exp(head(exps(e)))
        else :
          TSeq(a*, b*, false, false, false, info(e)) where :
            val a* = #exp(head(exps(e)))
            val binfo = info(exps(e)[1])
            val b* = #exp(IBegin(tail(exps(e)), binfo))
      (e:IMatch) :
        TMatch(args*, brs*, false, false, false, inf) where :
          val args* = #exp(args(e))
          val inf = info(e)
          val brs* = #exp(branches(e)) as List<TBranch>
      (e:IBranch) :
        TBranch(ns, ts, body, false, false, false, inf) where :
          val ts = #type(types(e))
          val inf = info(e)
          val [ns, body] = destructure-args(args(e), body(e))
      (e:INew) :
        TNew(c, ms, false, false, false, inf) where :
          val c = #type(class(e)) as Type
          val inf = info(e)
          val ms = #defmethod(methods(e) as List<IDefmethod>)
      (e:ICast) :
        TCast(e*, t*, false, false, false, inf) where :
          val e* = #exp(exp(e))
          val inf = info(e)
          val t* = #type(type(e)) as Type
      (e:IUpCast) :
        TUpCast(e*, t*, false, false, false, inf) where :
          val e* = #exp(exp(e))
          val inf = info(e)
          val t* = #type(type(e)) as Type
      (e:ISet) :
        TSet(r, v, false, false, false, inf) where :
          val r = #exp(name(e)) as TRef
          val inf = info(e)
          val v = #exp(value(e))
      (e:IDo) :
        TDo(f*, args*, false, false, false, inf) where :
          val f* = #farg(func(e))
          val inf = info(e)
          val args* = #exp(args(e))
      (e:IPrim) :
        TPrim(op, args*, false, false, false, inf) where :
          val op = primitive!(name!(op(e)))
          val inf = info(e)
          val args* = #exp(args(e))
      (e:ILiteral) :
        TLiteral(value(e), false, false, false, info(e))
      (e:ITuple) :
        TTupleExp(#exp(exps(e)), false, false, false, info(e))
      (e:ILet) :
        #exp(exp(e))
      (e:VarN) :
        TRef(n(e), false, false, false, info(e))
      (e:Mix) :
        TMix(false, #exp(exps(e)), false, false, false, info(e))
      (e:Let) :
        destructure-let(e)
      (e:LetRec) :
        TLetRec(defns*, body*, false, false, false, inf) where :
          val defns* = #defn(defns(e) as List<IDefn>)
          val body* = #exp(body(e))
          val inf = info(e)
      (e:ISet) :
        TSet(#exp(name(e)) as TRef, #exp(value(e)), false, false, false, info(e))
      (e) :
        fatal("Unsupported expression: %~" % [e])

  defn #farg (e:IExp) -> TExp :
    match(e) :
      (e:IOf) :
        if empty?(args(e)) :
          #exp(class(e))
        else :
          val ts = #type(args(e)) as List<Type>
          defn #mix (e:IExp) :
            match(e) :
              (e:VarN) :
                val ref = TRef(n(e), false, false, false, info(e))
                TCurry(ref, ts, List(), false, false, false, info(e))
              (e:Mix) :
                TMix(false, map(#mix, exps(e)), false, false, false, info(e))
          #mix(class(e))
      (e) :
        #exp(e)

  defn #defn (def:IDefn) :
    TDefn(ps, tail?(def), n, targs, cargs, a1*, a2*, args*, body*, inf) where :
      val ps = current-fn-properties()
      val n = n!(name(def))
      val inf = info(def)
      val [targs, cargs] = split-targs(targs(def))
      val a1* = #type(a1(def))
      val a2* = #type(a2(def))
      val [args*, body*] = destructure-args(args(def), body(def))


  defn #defmethod (def:IDefmethod) :
    TDefmethod(ps, tail?(def), fresh-id(), m, thisn(def), targs, cargs, a1*, a2*, args*, body*, inf) where :
      val ps = current-fn-properties()
      val m = #exp(multi(def))
      val inf = info(def)
      val a1* = #type(a1(def))
      val a2* = #type(a2(def))
      val [targs, cargs] = split-targs(targs(def))
      val [args*, body*] = destructure-args(args(def), body(def))

  defn #lsexp (e:IExp) -> LSExp :
    match(e) : 
      (e:ILSNew) :
        val [n, targ] = #lsclass(type(e))
        val inf = info(e)
        LSNew(n, targ, #lsexp(args(e)), false, false, false, inf)
      (e:ILSStruct) :
        val [n, targ] = #lsclass(type(e))
        val inf = info(e)
        LSStruct(n, targ, #lsexp(args(e)), false, false, false, inf)
      (e:ILSAddr) :
        val inf = info(e)
        LSAddr(#lsexp(exp(e)), unstable?(e), false, false, false, inf)
      (e:ILSDeref) :
        val inf = info(e)
        LSDeref(#lsexp(exp(e)), false, false, false, inf)
      (e:ILSSlot) :
        val inf = info(e)
        LSSlot(#lsexp(exp(e)), #lsexp(index(e)), false, false, false, inf)
      (e:ILSField) :
        val inf = info(e)
        LSField(#lsexp(exp(e)), name!(name(e)), false, false, false, inf)
      (e:ILSDo) :
        LSDo(f*, args*, false, false, false, inf) where :
          val f* = #lsfarg(func(e))
          val args* = #lsexp(args(e))
          val inf = info(e)
      (e:ILSCallC) :
        val inf = info(e)
        LSCallC(#lsexp(func(e)), #lsexp(args(e)), false, false, false, inf)
      (e:ILSPrim) :
        val op = ls-primitive!(name!(op(e)))
        val inf = info(e)
        LSPrim(op, #lsexp(args(e)), false, false, false, inf)
      (e:ILSSizeof) :
        val inf = info(e)
        val t = #lstype(type(e)) as LSType
        LSSizeof(t, false, false, false, inf)
      (e:ILSTagof) :
        val inf = info(e)
        LSTagof(n!(name(e)), false, false, false, inf)
      (e:ILSAs) :
        val inf = info(e)
        val t = #lstype(type(e)) as LSType
        LSCast(#lsexp(exp(e)), t, false, false, false, false, inf)
      (e:ILSAnd) :
        val inf = info(e)
        LSAnd(#lsexp(a(e)), #lsexp(b(e)), false, false, false, inf)
      (e:ILSOr) :
        val inf = info(e)
        LSOr(#lsexp(a(e)), #lsexp(b(e)), false, false, false, inf)
      (e:ILSLetExp) :
        val inf = info(e)
        LSLetExp(#lscomm(comm(e)), #lsexp(exp(e)), false, false, false, inf)
      (e:ILSFn) :
        val inf = info(e)
        LSFn(#exp(ref(e)), false, false, false, inf)
      (e:VarN) :
        val inf = info(e)
        LSVar(n!(e), false, false, false, inf)
      (e:ILiteral) :
        val inf = info(e)
        LSLiteral(value(e), false, false, false, inf)
      (e:Mix) :
        val inf = info(e)
        LSMix(false, map(#lsexp, exps(e)), false, false, false, inf)
      (e) :
        fatal("Not a LoStanza expression: %~" % [e])

  defn #lscomm (e:IExp) -> LSComm :
    match(e) :
      (e:IBegin) :
        if empty?(exps(e)) :
          LSSkip(info(e))
        else if empty?(tail(exps(e))) :
          #lscomm(head(exps(e)))
        else :
          val inf = info(exps(e)[1])
          LSSeq(
            #lscomm(head(exps(e)))
            #lscomm(IBegin(tail(exps(e)), inf))
            info(e))
      (e:ILSSet) :
        val inf = info(e)
        LSSet(#lsexp(exp(e)), #lsexp(value(e)), inf)
      (e:ILSLabels) :
        val inf = info(e)
        val blks = map(#lscomm, blocks(e)) as List<LSLabeledBlock>
        LSLabels(blks, inf)
      (e:ILSLabeledBlock) :
        val inf = info(e)
        val ts = #lstype(types(e)) as List<LSType>
        LSLabeledBlock(n!(name(e)), n!(args(e)), ts, #lscomm(body(e)), inf)
      (e:ILSGoto) :
        val inf = info(e)
        LSGoto(n!(name(e)), #lsexp(args(e)), inf)
      (e:ILSReturn) :
        val inf = info(e)
        LSReturn(#lsexp(exp(e)), inf)
      (e:ILSLet) :
        #lscomm(comm(e))
      (e:ILSIf) :
        val inf = info(e)
        LSIf(#lsexp(pred(e)), #lscomm(conseq(e)), #lscomm(alt(e)), inf)
      (e:ILSMatch) :
        val args* = #lsexp(args(e))
        val bs = #lscomm(branches(e)) as List<LSBranch>
        val inf = info(e)
        LSMatch(args*, bs, inf)
      (e:ILSBranch) :
        val inf = info(e)
        LSBranch(n!(args(e)), #lstype(types(e)), #lscomm(body(e)), inf)
      (e:ILSDef) :
        val inf = info(e)
        LSDef(n!(name(e)), #lstype(type(e)), #lsexp(exp(e)), inf)
      (e:ILSDefVar) :
        val inf = info(e)
        val v = #lsexp(exp(e)) when exp(e) is-not INone
        val t = #lstype(type(e)) as LSType
        LSDefVar(n!(name(e)), t, v, inf)
      (e:ILSDo|ILSPrim|ILSCallC) :
        val inf = info(e)
        LSCall(#lsexp(e), inf)

  defn #lsclass (e:IExp) :
    match(e) :
      (e:ILSOfT) : [n!(class(e)), TTuple(#type(args(e)) as List<Type>)]
      (e:Raw) : [n!(class(e)), TGradual()]

  defn #lsfarg (e:IExp) :
    match(e) :
      (e:ILSOfT) :
        if empty?(args(e)) :
          #lsexp(class(e))
        else :
          val ts = #type(args(e)) as List<Type>
          defn #mix (e:IExp) :
            match(e) :
              (e:VarN) :
                val inf = info(e)
                val ref = LSVar(n(e), false, false, false, inf)
                LSCurry(ref, ts, List(), false, false, false, inf)
              (e:Mix) :
                val inf = info(e)
                LSMix(false, map(#mix, exps(e)), false, false, false, inf)
          #mix(class(e))
      (e) :
        #lsexp(e)

  defn #lstype (e:IExp) -> False|LSType :
    defn #lstype! (e:IExp) : #lstype(e) as LSType
    defn #lstype! (es:List<IExp>) : #lstype(es) as List<LSType>
    defn #type! (e:IExp) : #type(e) as Type
    defn #type! (es:List<IExp>) : #type(es) as List<Type>
    match(e) :
      (e:ILSByteT) : ByteT()
      (e:ILSIntT) : IntT()
      (e:ILSLongT) : LongT()
      (e:ILSFloatT) : FloatT()
      (e:ILSDoubleT) : DoubleT()
      (e:ILSUnknownT) : UnknownT()
      (e:ILSOfT) :
        val n = n!(class(e))
        val targs = #type!(args(e))
        add(asserts, CorrectTArity(info(e), n, targs))
        StructT(n, TTuple(targs))
      (e:ILSPtrT) : PtrT(#lstype!(type(e)))
      (e:ILSRefT) : RefT(#type!(type(e)))
      (e:ILSFnT) : FnT(#lstype!(a1(e)), #lstype(ar(e)), #lstype!(a2(e)))
      (e:Raw) : StructT(n!(class(e)), TGradual())
      (e:INone) : false
      (e) : fatal("Not a LoStanza type: %~" % [e])

  ;     Nested Tuple Destructuring
  ;     ==========================
  defn destructure (args:List<IExp>, value:TExp) -> List<KeyValue<List<Int>, TExp>> :
    val [ns, bs] = destructure(args)
    cons(ns => value, bs)

  defn destructure (args:List<IExp>) -> [List<Int>, List<KeyValue<List<Int>, TExp>>] :
    var bindings = List()
    defn #n (x:IExp) -> Int :
      match(x) :
        (x:ITuple) :
          val n = fresh-id()
          bindings = cons(entry, bindings) where :
            val exps* = map(#n, exps(x))
            val entry = exps* => TRef(n, false, false, false, info(x))
          n
        (x) :
          n!(x)
    val ns = map(#n, args)
    [ns, bindings]

  defn destructure-args (args:List<IExp>, fbody:IExp) -> [List<Int>, TExp] :
    val [ns, bs] = destructure(args)
    var body = #exp(fbody)
    for b in in-reverse(bs) do :
      body = TLetTuple(ns, ts, v, body, false, false, false, inf) where :
        val [ns, v] = [key(b), value(b)]
        val ts = map({false}, ns)
        val inf = info(v)
    [ns, body]

  defn destructure-def (def:IDef) -> List<TDef|TDefTuple> :
    match(name(def), type(def), value(def)) :
      (name:ITuple, type:INone, v) :
        val bs = destructure(exps(name), #exp(v))
        for b in bs map :
          TDefTuple(ns, ts, v, inf) where :
            val [ns, v] = [key(b), value(b)]
            val ts = map({false}, ns)
            val inf = info(v)
      (name:ITuple, type, v) :
        val tmp = VarN(fresh-id(), info(name))
        append(
          destructure-def(IDef(tmp, type, v, info(name)))
          destructure-def(IDef(name, #IN, tmp, info(name))))
      (name, type, v) :
        List(TDef(n, t*, v*, inf)) where :
          val n = n!(name)
          val t* = #type(type)
          val v* = #exp(v)
          val inf = info(v)

  defn destructure-let (lete:Let) -> TExp :
    match(def(lete)) :
      (def:IDefVar) :
        val n = n!(name(def))
        val t = #type(type(def))
        val e = #exp(value(def)) when value(def) is-not INone
        val b = #exp(body(lete))
        val inf = info(def)
        TLetVar(n, t, e, b, false, false, false, inf)
      (def:IDef) :
        defn loop (defs:List<TDef|TDefTuple>) :
          if empty?(defs) :
            #exp(body(lete))
          else :
            val body = loop(tail(defs))
            match(head(defs)) :
              (e:TDef) : TLet(n(e), type(e), value(e), body, false, false, false, info(e))
              (e:TDefTuple) : TLetTuple(ns(e), types(e), value(e), body, false, false, false, info(e))
        loop(destructure-def(def))

  ;     Hierarchy Building
  ;     ==================
  defn #hier (tpackages:Collection<TPackage>, environment:Tuple<Export>) :
    ;Iterate over type commands
    defn do-type-comms (f: TDefType|TLDefType|Export -> ?) :
      for tpackage in tpackages do :
        do(f, filter-by<TDefType|TLDefType>(comms(tpackage)))
      for e in environment do :
        f(e) when rec(e) is TypeRec|StructRec|TypeDecl
                      
    ;Compute parents of all types
    val parents = IntTable<False|Type>()
    val type-args = IntTable<List<Int>>()
    val hier = THierarchy()

    defn calc-direct-parents () :
      within c = do-type-comms() :
        match(c) :
          (c:TDefType|TLDefType) :
            parents[n(c)] = parent(c)
            type-args[n(c)] = args(c)
          (c:Export) :
            val r = rec(c) as TypeRec|StructRec
            val targs = TVars(ntargs(r))
            parents[n(c)] = to-type?(parent(r), targs)
            type-args[n(c)] = to-list(seq(n,targs))

    defn calc-child-parents () :
      defn add-parent (n:Int, t:Type) :
        defn tand (a:False|Type, b:Type) :
          match(a) :
            (a:False) : b
            (a:Type) : TAnd(a, b)               
        parents[n] = tand(parents[n], t)

      within c = do-type-comms() :
        match(c) :
          (c:TDefType) :
            for c in children(c) do :
              val env = map({_ => TVar(_)}, args(c), type-args[n(c)])
              add-parent(n(c), sub(parent(c), env))
          (c:Export) :
            match(rec(c)) :
              (r:TypeRec) :
                for c in children(r) do :
                  val n = coreid(id(c))
                  val type-args =
                    if ntargs(c) == length(type-args[n]) :
                      to-tuple(seq(TVar{_, false}, type-args[n]))
                    else :
                      TVars(ntargs(c))
                  add-parent(n, to-type(parent(c), type-args))                    
              (r) : false
          (c) : false

    defn calc-hier-entries () :
      within c = do-type-comms() :
        val hentry = match(c) :
          (c:TDefType) :
            HSHEntry(n(c), args(c), parents[n(c)])
          (c:TLDefType) :
            val fs = for f in fields(c) map :
              Field(n(f), name(f), type(f))
            LSHEntry(n(c), args(c), parents[n(c)], fs)
          (c:Export) :            
            val n = coreid(id(rec(c)) as TypeId)
            match(rec(c)) :
              (r:TypeRec|TypeDecl) :
                val args = to-list(0 to ntargs(r))
                HSHEntry(n, args, parents[n])
              (r:StructRec) :                
                ;Convert fields
                defn to-field (Type:LSType -> LSType, f:StructField) :
                  val type = Type(to-lstype(type(f), TVars(ntargs(r))))
                  Field(fresh-id(), name(f), type)
                val fs = Vector<Field>()                
                for f in base(r) do : add(fs, to-field({_}, f))
                val rf = items(r)
                match(rf:StructField) :
                  add(fs, to-field(RestT, rf))
                ;Create entry                
                val args = to-list(0 to ntargs(r))
                LSHEntry(n, args, parents[n], to-list(fs))
        add(hier, hentry)
             
    ;Return Hierarchy
    calc-direct-parents()
    calc-child-parents()
    calc-hier-entries()
    hier

  ;     Error Reporting
  ;     ===============
  ;Check hierarchical cycles
  defn check-cycles (hier:THierarchy) :
    defn classes (t:False|Type) -> List<Int> :
      match(t) :
        (t:TOf) : List(n(t))
        (t:TAnd) : append(classes(a(t)), classes(b(t)))
        (t:False) : List()
    val components = strong-components $
      for entry in hier seq :
        n(entry) => classes(parent(entry))
    val cycles =
      {_ as Seq<List<Int>>} $
      filter({_ is List}, components)
    for c in cycles do :
      defn msg (ns:List<Int>) :
        join{_, "\n"} $
        for n in ns seq :
           "   %~ %_" % [#name(n), info-str(n)]
      add-error("Illegal cycle in type hierarchy. The following types are parents of each other.\n%*" % [
        msg(c)])

  ;Check type arities
  defn check-arities (hier:THierarchy) :
    for assert in asserts do :
      match(assert) :
        (a:CorrectTArity) :
          val arity = length(args(hier[n(a)]))
          if length(targs(a)) != arity :
            add-error("%_: Incorrect number of type parameters for type %~. Expecting %~ but given %,." % [
              info(a), #name(n(a)), arity, #pr(targs(a))])

  ;Report errors
  defn report-errors (hier:THierarchy) :
    check-cycles(hier)
    check-arities(hier)
    if not empty?(errors) :
      throw(TypeErrors(errors))

  ;     Driver
  ;     ======
  val tpackages = map(#tpackage, ipackages)
  val hier = #hier(tpackages, environment)  
  report-errors(hier)
  TProg(hier, to-list(tpackages), environment, nm)

defn NameMap (nms:Seqable<NameMap>, environment:Seqable<Export>) :
  val namemap = NameMap()
  for nm in nms do :
    do(add{namemap, _}, nm)
  for e in environment do :
    add(namemap, VEntry(e))
  namemap

defn TVars (n:Int) :
  to-tuple(seq(TVar{_, false}, 0 to n))

defn coreid (id:TypeId) :
  current-idtable()[id]

;============================================================
;================= Primitives Types  ========================
;============================================================

;              HiStanza Callable Relation
;              ==========================

defn callable? (p:Primitive, args:List<Type>) -> True|False :
  val int = TOf(coreid(CORE-INT-ID), TTuple(List()))
  val any = TGradual()

  defn args? (ts:Tuple<Type>) :
    if length(args) == length(ts) :
      for (a in args, t in ts) all? :
        subtype?(a, t) as True|False

  switch {p == _} :
    ADD-OP : args?([int int])
    SUB-OP : args?([int int])
    MUL-OP : args?([int int])
    DIV-OP : args?([int int])
    MOD-OP : args?([int int])
    AND-OP : args?([int int])
    OR-OP : args?([int int])
    XOR-OP : args?([int int])
    SHL-OP : args?([int int])
    SHR-OP : args?([int int])
    ASHR-OP : args?([int int])
    EQ-OP : args?([int int])
    NE-OP : args?([int int])
    LT-OP : args?([int int])
    GT-OP : args?([int int])
    LE-OP : args?([int int])
    GE-OP : args?([int int])
    NOT-OP : args?([int])
    NEG-OP : args?([int])
    IDENTICAL-OP : args?([any any])

;              LoStanza Callable Relation
;              ==========================

defn callable? (p:LSPrimitive, args:List<LSType>) -> True|False :
  defn matching-nums? () :
    match(args[0], args[1]) :
      (x:ByteT|IntT|LongT|FloatT|DoubleT, y:ByteT|IntT|LongT|FloatT|DoubleT) :
        (assignable?(x, y) is True) or (assignable?(y, x) is True)
      (x, y) : false
  defn matching-ints? () :
    match(args[0], args[1]) :
      (x:ByteT|IntT|LongT, y:ByteT|IntT|LongT) :
        (assignable?(x, y) is True) or (assignable?(y, x) is True)
      (x, y) : false
  defn binop-nums? () :
    (length(args) == 2) and
    matching-nums?()
  defn binop-ints? () :
    (length(args) == 2) and
    matching-ints?()
  defn binop-cmp? () :
    if length(args) == 2 :
      match(args[0], args[1]) :
        (x:PtrT, y:PtrT) : true
        (x, y) : matching-nums?()
  defn one-snum? () :
    if length(args) == 1 :
      args[0] is IntT|LongT|FloatT|DoubleT
  defn one-int? () :
    if length(args) == 1 :
      args[0] is ByteT|IntT|LongT
  defn one-fnum? () :
    if length(args) == 1 :
      args[0] is FloatT|DoubleT
  defn one-sint? () :
    if length(args) == 1 :
      args[0] is IntT|LongT
  defn stk? (t:LSType) :
    assignable?(t, RefT(TOf(coreid(CORE-STACK-ID), TTuple(List())))) is True
  defn gradual? (t:LSType) :
    assignable?(t, RefT(TGradual())) is True

  match(p) :
    (p:GetterPrimitive|AddrPrimitive) :
      empty?(args)
    (p:SetterPrimitive) :
      (length(args) == 1) and
      assignable?(head(args), type(p)) is True
    (p) :
      switch {p == _} :
        GET-STACK-OP :
          empty?(args)
        SET-STACK-OP :
          val type = RefT(TOf(coreid(CORE-STACK-ID), TTuple(List())))
          (length(args) == 1) and
          assignable?(head(args), type) is True          
        LS-YIELD-OP :
          (length(args) == 2) and
          stk?(args[0]) and
          gradual?(args[1])
        LS-ENTER-OP :
          (length(args) == 2) and
          stk?(args[0]) and
          gradual?(args[1])
        LS-NEW-STACK-OP :
          length(args) >= 1        
        LS-LAST-STACK-OP :
          length(args) == 0
        LS-ADD-OP :
          if length(args) == 2 :
            match(args[0], args[1]) :
              (x:PtrT, y) : assignable?(y, LongT()) is True
              (x, y) : matching-nums?()
        LS-SUB-OP :
          if length(args) == 2 :
            match(args[0], args[1]) :
              (x:PtrT, y:PtrT) : true
              (x:PtrT, y) : assignable?(y, LongT()) is True
              (x, y) : matching-nums?()
        LS-MUL-OP : binop-nums?()
        LS-DIV-OP : binop-nums?()
        LS-MOD-OP : binop-ints?()
        LS-AND-OP : binop-ints?()
        LS-OR-OP : binop-ints?()
        LS-XOR-OP : binop-ints?()
        LS-SHL-OP : binop-ints?()
        LS-SHR-OP : binop-ints?()
        LS-ASHR-OP : binop-ints?()
        LS-EQ-OP :
          if length(args) == 2 :
            match(args[0], args[1]) :
              (x:PtrT, y:PtrT) : true
              (x:RefT, y:RefT) : true
              (x, y) : matching-nums?()
        LS-NE-OP :
          if length(args) == 2 :
            match(args[0], args[1]) :
              (x:PtrT, y:PtrT) : true
              (x:RefT, y:RefT) : true
              (x, y) : matching-nums?()
        LS-LT-OP : binop-cmp?()
        LS-GT-OP : binop-cmp?()
        LS-LE-OP : binop-cmp?()
        LS-GE-OP : binop-cmp?()
        LS-ULT-OP : binop-ints?()
        LS-UGT-OP : binop-ints?()
        LS-ULE-OP : binop-ints?()
        LS-UGE-OP : binop-ints?()
        LS-NOT-OP : one-int?()
        LS-NEG-OP : one-snum?()
        LS-BITS-OP : one-fnum?()
        LS-FNUM-OP : one-sint?()


;============================================================
;============== Generate Type Variables =====================
;============================================================
defstruct TupleF : ()
defstruct SubF : (ti:Type, t:Type)
defstruct ArgsF : ()
defstruct RetF : (n:Int)

deftype InstResult
deftype LSInstResult
defstruct Instantiated <: InstResult :
  cargs: List<TUVar>
  type: TArrow
  exp-type: TArrow
defstruct LSInstantiated <: LSInstResult :
  cargs: List<TUVar>
  type: FnT
  exp-type: FnT
defstruct WrongArity <: InstResult & LSInstResult
defstruct NotPoly <: InstResult & LSInstResult

defstruct Filler :
  fill-ctxt: Context -> Context
  fill-s: Selection -> Selection
  fill-t: Type -> Type
  fill-lt: LSType -> LSType
  fill-lc: LSComm -> LSComm
  fill-le: LSExp -> LSExp
  fill-e: TExp -> TExp
  fill-c: TComm -> TComm
  fill-prog: TProg -> TProg


defn infer-types (prog:TProg, environment:Tuple<Export>) :   
  ;======== Environment ========
  val env = IntTable<False|Type>()
  val ls-env = IntTable<False|LSType>()
  val req-env = IntTable<TUVar>()
  val constraints = Vector<Constraint>()
  var current-return-type : False|LSType = false

  ;          ==================================
  ;          ==   Type Variable Generation   ==
  ;          ==================================

  val #? = TGradual()
  val #ls? = UnknownT()
  val #fresh = Fresh()
  defn addc (c:Constraint) : add(constraints, c)
  defn #freshv () : TUVar(fresh-id())
  defn #freshv (n:Int) : map(#freshv{}, 0 to n)
  defn #ls-freshv () : UVarT(fresh-id())
  defn #ls-freshv (n:Int) : map(#ls-freshv{}, 0 to n)
  defn #or (x:False, y:False) : false
  defn #or (x:False, y:Type) : y
  defn #or (x:False, y:LSType) : y
  defn #or (x:False, y:Fresh) : #freshv()
  defn #or (x:Type, y:False) : y when x is TUVar else x
  defn #or (x:Type, y:Type) : y when x is TUVar else x
  defn #or (x:Type, y:Fresh) : #freshv() when x is TUVar else x
  defn #or (x:LSType, y:False) : y when x is UVarT else x
  defn #or (x:LSType, y:LSType) : y when x is UVarT else x
  defn #or (x:LSType, y:Fresh) : #freshv() when x is UVarT else x
  defn #or (xs:List<False|Type>, y:False) : map(#or{_, y}, xs)
  defn #or (xs:List<False|Type>, y:Type|Fresh) : map(#or{_, y}, xs)
  defn #or (xs:List<False|Type>, ys:List<False|Type>) : map(#or, xs, ys)
  defn #or (xs:List<False|LSType>, ys:List<False|LSType>) : map(#or, xs, ys)
  defn set-req-env (n:Int, t:TUVar) : req-env[n] = t
  defn set-env (n:Int, t:False|Type) : env[n] = t
  defn set-env (ns:List<Int>, y:False|Type) : do(set-env{_, y}, ns)
  defn set-env (ns:List<Int>, ts:List<False|Type>) : do(set-env, ns, ts)
  defn set-ls-env (n:Int, t:False|LSType) : ls-env[n] = t
  defn set-ls-env (ns:List<Int>, ts:List<False|LSType>) : do(set-ls-env, ns, ts)
  defn bexp (es:List<TExp>, c:Context) : map(bexp{_, c}, es)
  defn bcomm<?T> (cs:List<?T&TComm>) : map(bcomm, cs)
  defn #types (es:List<TExp>) : map(type, es)
  defn #types (es:List<LSExp>) : map(type, es)
  defn #exp-types (es:List<TExp>) : map(exp-type, es)
  defn #exp-types (es:List<LSExp>) : map(exp-type, es)
  defn #V (t:False) : fail()
  defn #V (t:LSType) : t
  defn #V (t:Type) : t

  defn env-a1 (n:Int) :
    defn* loop (t:False|Type) :
      match(t) :
        (t:TPoly) : loop(func(t))
        (t:TArrow) : types(a(t) as TTuple)
    loop(env[n])

  defn env-a2 (n:Int) :
    defn* loop (t:False|Type) :
      match(t) :
        (t:TPoly) : loop(func(t))
        (t:TArrow) : b(t)
    loop(env[n])

  defn wrap-poly (t:TArrow, targs:List<Int>, cargs:List<Int>) :
    if empty?(targs) and empty?(cargs) : t
    else : TPoly(targs, cargs, t)
  defn wrap-poly (a1:List<Type>, a2:Type, targs:List<Int>, cargs:List<Int>) :
    wrap-poly(TArrow(TTuple(a1), a2), targs, cargs)
  defn wrap-poly (t:FnT, targs:List<Int>, cargs:List<Int>) :
    if empty?(targs) and empty?(cargs) : t
    else : PolyT(targs, cargs, t)
  defn wrap-poly (a1:List<LSType>, a2:LSType, targs:List<Int>, cargs:List<Int>) :
    wrap-poly(FnT(a1, false, a2), targs, cargs)

  defn fn-type (c:TDefmethod, thist:Type) :
    val a1* = for (t in a1(c), x in args(c)) map :
      if x == thisn(c) : #or(t, thist)
      else : #or(t, #?)
    val a2* = #or(a2(c), #fresh)
    val t = TArrow(TTuple(a1*), a2*)
    wrap-poly(t, targs(c), cargs(c))

  defn fn-type (c:TDefn|TDefmethod) :
    val t = TArrow(TTuple(a1*), a2*) where :
      val a1* = #or(a1(c), #?)
      val a2* = #or(a2(c), #fresh)
    wrap-poly(t, targs(c), cargs(c))

  defn fn-type (c:TDefmulti) :
    val t = TArrow(TTuple(a1*), a2*) where :
      val a1* = #or(a1(c), #?)
      val a2* = #or(a2(c), #?)
    wrap-poly(t, targs(c), cargs(c))

  defn fn-type (c:TLDefn|TLDefmethod) :
    val t = FnT(a1(c), false, a2(c))
    if empty?(targs(c)) and empty?(cargs(c)) : t
    else : PolyT(targs(c), cargs(c), t)

  defn fn-type (c:TLExternFn) :
    FnT(a1(c), false, a2(c))

  defn to-hs-type (t:LSType) :
    match(t) :
      (t:RefT) : type(t)
      (t) : false

  ;======== Specialized Type Constructors ========
  defn lit-type (v) :
    defn base (n:Int) : TOf(n, TTuple(List()))
    defn raw (n:Int) : TOf(n, TGradual())
    match(v) :
      (v:Byte) : base(coreid(CORE-BYTE-ID))
      (v:Char) : base(coreid(CORE-CHAR-ID))
      (v:Int) : base(coreid(CORE-INT-ID))
      (v:Long) : base(coreid(CORE-LONG-ID))
      (v:Float) : base(coreid(CORE-FLOAT-ID))
      (v:Double) : base(coreid(CORE-DOUBLE-ID))
      (v:String) : base(coreid(CORE-STRING-ID))
      (v:Symbol) : base(coreid(CORE-SYMBOL-ID))
      (v:List) : raw(coreid(CORE-LIST-ID))
      (v:True) : base(coreid(CORE-TRUE-ID))
      (v:False) : base(coreid(CORE-FALSE-ID))
      (v) : fatal("Unsupported literal type %~." % [v])

  defn ls-lit-type (v) :
    defn base (n:Int) : RefT(TOf(n, TTuple(List())))
    match(v) :
      (v:Byte) : ByteT()
      (v:Char) : ByteT()
      (v:Int) : IntT()
      (v:Long) : LongT()
      (v:Float) : FloatT()
      (v:Double) : DoubleT()
      (v:String) : PtrT(ByteT())
      (v:True) : base(coreid(CORE-TRUE-ID))
      (v:False) : base(coreid(CORE-FALSE-ID))
      (v) : fatal("Unsupported LoStanza literal %~." % [v])

  defn prim-type (op:Primitive) :
    defn base (n:Int) : TOf(n, TTuple(List()))
    val int-type = base(coreid(CORE-INT-ID))
    val char-type = base(coreid(CORE-CHAR-ID))
    val bool-type = TOr(base(coreid(CORE-TRUE-ID)), base(coreid(CORE-FALSE-ID)))
    val false-type = base(coreid(CORE-FALSE-ID))
    switch {op == _} :
      ADD-OP : int-type
      SUB-OP : int-type
      MUL-OP : int-type
      DIV-OP : int-type
      MOD-OP : int-type
      AND-OP : int-type
      OR-OP : int-type
      XOR-OP : int-type
      SHL-OP : int-type
      SHR-OP : int-type
      ASHR-OP : int-type
      NOT-OP : int-type
      NEG-OP : int-type
      EQ-OP : bool-type
      NE-OP : bool-type
      LT-OP : bool-type
      GT-OP : bool-type
      LE-OP : bool-type
      GE-OP : bool-type
      IDENTICAL-OP : bool-type
      AGET-OP : TGradual()
      ASET-OP : false-type
      ALEN-OP : int-type
      CHAR-AGET-OP : char-type
      CHAR-ASET-OP : false-type
      STRING-GET-OP : char-type
      STRING-LEN-OP : int-type
      else : fatal("Unrecognized primitive: %~" % [op])

  ;====== Environment Queries ======
  ;Return all possible types in e
  defn all-types (e:TExp) -> List<Type> :
    match(e) :
      (e:TLet) : all-types(body(e))
      (e:TLetVar) : all-types(body(e))
      (e:TLetTuple) : all-types(body(e))
      (e:TLetRec) : all-types(body(e))
      (e:TSeq) : all-types(b(e))
      (e:TBranch) : all-types(body(e))
      (e:TMatch) : seq-append(all-types, branches(e))
      (e:TMix) : List(TMixed(seq-append(all-types, exps(e)) as List<TArrow>))
      (e) :
        match(exp-type(e)) :
          (t:False) : List()
          (t:Type) : List(t)

  defn all-types (e:LSExp) -> List<LSType> :
    match(e) :
      (e:LSLetExp) : all-types(exp(e))
      (e:LSMix) : seq-append(all-types, exps(e))
      (e:LSFn) : map(RefT, all-types(ref(e)))
      (e) :
        match(exp-type(e)) :
          (t:False) : List()
          (t:LSType) : List(t)

  ;======== Build top level environment ========
  defn build-environment () :
    ;Build environment from package declarations
    for e in environment do :
      match(rec(e)) :
        (r:ValRec) :
          if lostanza?(r) : lsval(n(e), type(r))
          else : hsval(n(e), type(r))
        (r:FnRec) :
          if lostanza?(r) : lsfn(n(e), id(r) as FnId, a2(r))
          else : hsfn(n(e), id(r) as FnId, a2(r))
        (r:MultiRec) : hsfn(n(e), id(r) as FnId, a2(r))          
        (r:ExternFnRec) : lsfn(n(e), id(r) as FnId, a2(r))
        (r:ExternRec) : lsval(n(e), type(r))
        (r) : false
      where :
        defn lsval (n:Int, t:DType) :
          val t* = to-lstype(t, [])
          set-ls-env(n, t*)
          set-env(n, to-hs-type(t*))
        defn hsval (n:Int, t:DType) :
          val t* = to-type(t, [])
          set-env(n, t*)
          set-ls-env(n, RefT(t*))
        defn make-targs (id:FnId) :
          val targs* = to-list $ seq(fresh-id{}, 0 to ntargs(id))
          val cargs* = to-list $ seq(fresh-id{}, 0 to ncargs(id))
          val tcargs* = to-tuple $ seq(TVar{_, false}, cat(targs*,cargs*))
          [targs*, cargs*, tcargs*]
        defn hstype (id:FnId, a2:DType) :
          val [targs*, cargs*, tcargs*] = make-targs(id)
          wrap-poly(TArrow(TTuple(a*), b*), targs*, cargs*) where :
            val a* = to-list(seq(to-type{_, tcargs*}, a1(id)))
            val b* = to-type(a2, tcargs*)
        defn hsfn (n:Int, id:FnId, a2:DType) :
          val t = hstype(id,a2)
          set-env(n, t)
          set-ls-env(n, to-ls-fn(t))
        defn lstype (id:FnId, a2:DType) :
          val [targs*, cargs*, tcargs*] = make-targs(id)
          wrap-poly(FnT(a*, false, b*), targs*, cargs*) where :
            val a* = to-list(seq(to-lstype{_, tcargs*}, a1(id)))
            val b* = to-lstype(a2, tcargs*)
        defn lsfn (n:Int, id:FnId, a2:DType) :
          val t = lstype(id,a2)
          set-ls-env(n, t)
          set-env(n, to-hs-fn(t))

    ;Build environment from top-level commands
    for c in prog do :
      match(c) :
        (c:TDefType) :
          false
        (c:TLDefType) :
          false
        (c:TDef) :
          val t = #or(type(c), #fresh)
          set-env(n(c), t)
          set-ls-env(n(c), RefT(t))
        (c:TDefTuple) :
          val ts = map(#freshv{}, ns(c))
          set-env(ns(c), ts)
          set-ls-env(ns(c), map(RefT, ts))
        (c:TDefVar) :
          val t = #or(type(c), #fresh)
          set-env(n(c), t)
          set-ls-env(n(c), RefT(t))
        (c:TDefn) :
          val t = fn-type(c)
          set-env(n(c), t)
          set-ls-env(n(c), to-ls-fn(t))
        (c:TDefmulti) :
          val t = fn-type(c)
          set-env(n(c), t)
          set-ls-env(n(c), to-ls-fn(t))
        (c:TDefmethod) :
          set-env(n(c), fn-type(c))
        (c:TInit) :
          false
        (c:TLDef) :
          set-ls-env(n(c), type(c))
          set-env(n(c), to-hs-type(type(c)))
        (c:TLDefVar) :
          set-ls-env(n(c), type(c))
          set-env(n(c), to-hs-type(type(c)))
        (c:TLDefn) :
          val t = fn-type(c)
          set-ls-env(n(c), t)
          set-env(n(c), to-hs-fn(t))
        (c:TLExternFn) :
          val t = fn-type(c)
          set-ls-env(n(c), t)
          set-env(n(c), to-hs-fn(t))
        (c:TLDefmethod) :
          val t = fn-type(c)
          set-ls-env(n(c), t)
          set-env(n(c), to-hs-fn(t))
        (c:TExtern) :
          set-ls-env(n(c), type(c))
          set-env(n(c), to-hs-type(type(c)))
        (c:TLInit) :
          false

  ;======== Productions ========
  defn bcomm<?T> (c:?T&TComm) -> T :
    {_ as T&TComm} $ match(c) :
      (c:TDefType) :
        c
      (c:TLDefType) :
        c
      (c:TDef) :
        val v* = bexp(value(c), CExp(#or(type(c), #?)))
        val t* = env[n(c)]
        #equal(t*, type(v*))
        TDef(n(c), t*, v*, info(c))
      (c:TDefTuple) :
        val v* = bexp(value(c), CExp(#?))
        val ts* = map({env[_] as TUVar}, ns(c))
        #downto(ts*, type(v*), TupleF())
        TDefTuple(ns(c), ts*, v*, info(c))
      (c:TDefVar) :
        val t* = env[n(c)]
        match(value(c)) :
          (v:False) :
            TDefVar(n(c), t*, false, info(c))
          (v:TExp) :
            val v* = bexp(v, CExp(#or(type(c), #?)))
            #super(t*, type(v*))
            TDefVar(n(c), t*, v*, info(c))
      (c:TDefn) :
        val a1* = env-a1(n(c))
        val a2* = env-a2(n(c))
        set-env(args(c), map(uncap, a1*))
        val body* = bexp(body(c), CExp(#or(a2(c), #?)))
        #equal(a2*, type(body*))
        TDefn(props(c), tail?(c), n(c), targs(c), cargs(c), a1*, a2*, args(c), body*, info(c))
      (c:TDefmulti) :
        val a1* = env-a1(n(c))
        val a2* = env-a2(n(c))
        TDefmulti(n(c), targs(c), cargs(c), a1*, a2*, info(c))
      (c:TDefmethod) :
        val a1* = env-a1(n(c))
        val a2* = env-a2(n(c))
        val t* = TArrow(uncap(TTuple(a1*)), a2*)
        val m* = bmulti(multi(c), map(TVar, targs(c)), CMulti(t*))
        set-env(args(c), map(uncap, a1*))
        val body* = bexp(body(c), CExp(#or(a2(c), #?)))
        #equal(a2*, type(body*))
        TDefmethod(props(c), tail?(c), n(c), m*, thisn(c), targs(c), cargs(c), a1*, a2*, args(c), body*, info(c))
      (c:TInit) :
        TInit(bexp(exp(c), CExp(#?)), info(c))
      (c:TLDef) :
        val e* = blsexp(value(c), CLSExp(type(c)))
        TLDef(n(c), type(c), e*, info(c))
      (c:TLDefVar) :
        val e* = blsexp(value(c) as LSExp, CLSExp(type(c))) when value(c) is-not False
        TLDefVar(n(c), type(c), e*, info(c))
      (c:TLDefn) :
        set-ls-env(args(c), map(uncap, a1(c)))
        val body* = let-var current-return-type = a2(c) :
          blscomm(body(c))
        TLDefn(props(c), tail?(c), n(c), targs(c), cargs(c), a1(c), a2(c), args(c), body*, info(c))
      (c:TLExternFn) :
        set-ls-env(args(c), a1(c))
        val body* = let-var current-return-type = a2(c) :
          blscomm(body(c))
        TLExternFn(props(c), n(c), a1(c), a2(c), args(c), body*, lbl(c), info(c))
      (c:TLDefmethod) :
        val m* = match(env[n(c)]) :
          (t:False) :
            multi(c)
          (t) :
            val a1* = env-a1(n(c))
            val a2* = env-a2(n(c))
            val t* = TArrow(uncap(TTuple(a1*)), a2*)
            bmulti(multi(c), map(TVar, targs(c)), CMulti(t*))
        set-ls-env(args(c), map(uncap, a1(c)))
        val body* = let-var current-return-type = a2(c) :
          blscomm(body(c))
        TLDefmethod(props(c), tail?(c), n(c), m*, targs(c), cargs(c), a1(c), a2(c), args(c), body*, info(c))
      (c:TExtern) :
        c
      (c:TLInit) :
        TLInit(blscomm(comm(c)), info(c))

  defn bfn (e:TFn, c:Context) -> TFn :
    ;Type variables for arguments
    val a1* = #or(a1(e), #fresh)
    val req-a1* = #or(a1(e), #fresh)
    set-env(args(e), a1*)
    for (x in args(e), t* in req-a1*) do :
       set-req-env(x, t* as TUVar) when t* is TUVar
    ;Type variables for return
    val a2* = #or(a2(e), #freshv())
    val t* = TArrow(TTuple(a1*), a2*)
    val exp-t* = TArrow(TTuple(req-a1*), a2*)
    val body* = bexp(body(e), CExp(#or(a2(e), #freshv())))
    ;Constraints
    #equal(a2*, type(body*))
    ;Return new struct
    TFn(tail?(e), a1*, a2*, args(e), body*, t*, exp-t*, c, info(e))

  defn capfn (f:TFn, c:Context, ft:Type) :
    match(c) :
      (c:CExp) :
        ;Expected return type
        val exp-a2 = type(ctxt(body(f)) as CExp)
        #upto(exp-a2, type(c), SubF(a2(f) as Type, ft))
        ;Infer argument types
        for t in a1(f) do :
          #upto(t, type(c), SubF(t as Type, ft))
      (c:CDo) :
        ;Expected return type
        val exp-a2 = type(ctxt(body(f)) as CExp)
        #equal(exp-a2, ret(c))
        ;Infer argument types
        if length(args(f)) == length(args(c)) :
          #equal(a1(f), args(c))

  defn bexp (e:TExp, ctxt:Context) -> TExp :
    val c = ctxt as CDo|CExp
    match(e) :
      (e:TLet) :
        val v* = bexp(value(e), CExp(#or(ntype(e), #?)))
        val t* = #or(ntype(e), type(v*))
        set-env(n(e), t*)
        val body* = bexp(body(e), c)
        TLet(n(e), t*, v*, body*, type(body*), exp-type(body*), c, info(e))
      (e:TLetVar) :
        val t* = #or(ntype(e), #fresh)
        set-env(n(e), t*)
        val body* = bexp(body(e), c)
        match(value(e)) :
          (v:False) :
            TLetVar(n(e), t*, false, body*, type(body*), exp-type(body*), c, info(e))
          (v:TExp) :
            val v* = bexp(v, CExp(t*))
            #super(t*, type(v*))
            TLetVar(n(e), t*, v*, body*, type(body*), exp-type(body*), c, info(e))
      (e:TLetTuple) :
        val ts* = #freshv(length(ns(e)))
        val v* = bexp(value(e), CExp(#?))
        set-env(ns(e), ts*)
        val body* = bexp(body(e), c)
        #downto(ts*, type(v*), TupleF())
        TLetTuple(ns(e), ts*, v*, body*, type(body*), exp-type(body*), c, info(e))
      (e:TLetRec) :
        ;Define types for functions
        for def in defns(e) do :
          set-env(n(def), fn-type(def))
        val defns* = map(bcomm, defns(e))
        val body* = bexp(body(e), c)
        TLetRec(defns*, body*, type(body*), exp-type(body*), c, info(e))
      (e:TFn) :
        val f = bfn(e, c)
        capfn(f, c, type(f) as Type)
        f
      (e:TMulti) :
        val fs = map(bfn{_, c}, funcs(e))
        val mt = reduce(TAnd, #types(fs) as List<Type>)
        val exp-mt = reduce(TAnd, #exp-types(fs) as List<Type>)
        for f in fs do : capfn(f, c, mt)
        TMulti(fs, mt, exp-mt, c, info(e))
      (e:TSeq) :
        val a* = bexp(a(e), CExp(#?))
        val b* = bexp(b(e), c)
        TSeq(a*, b*, type(b*), exp-type(b*), c, info(e))
      (e:TMatch) :
        val args* = bexp(args(e), CExp(#?))
        val branches* = for b in branches(e) map :
          TBranch(args(b), atypes*, body*, type(body*), exp-type(body*), c, info(b)) where :
            val atypes* = #or(atypes(b), #types(args*))
            set-env(args(b), atypes*)
            val body* = bexp(body(b), c)
        val t* = attempt: reduce(TOr, map(#V, #types(branches*)))
        val exp-t* = attempt: reduce(TOr, map(#V, #exp-types(branches*)))
        TMatch(args*, branches*, t*, exp-t*, c, info(e))
      (e:TNew) :
        ;Define types for methods
        for m in methods(e) do :
          set-env(n(m), fn-type(m, class(e)))
        val ms* = bcomm(methods(e))
        TNew(class(e), ms*, class(e), class(e), c, info(e))
      (e:TCurry) :
        val t = env[n(ref(e))]
        val e* = TRef(n(ref(e)), t, t, c, info(e))
        match(#instantiate(t, targs(e), type(c))) :
          (r:Instantiated) : TCurry(e*, targs(e), cargs(r), type(r), exp-type(r), c, info(e))
          (r:WrongArity) : TCurry(e*, targs(e), List(), false, false, c, info(e))
      (e:TRef) :
        val t = env[n(e)]
        val e* = TRef(n(e), t, t, c, info(e))
        val rt = get?(req-env, n(e), false)
        #super(rt, type(c))
        match(#instantiate(t, List(), type(c))) :
          (r:Instantiated) : TCurry(e*, List(), cargs(r), type(r), exp-type(r), c, info(e))
          (r:WrongArity) : TCurry(e*, List(), List(), false, false, c, info(e))
          (r:NotPoly) : e*
      (e:TCast) :
        val exp* = bexp(exp(e), CExp(#?))
        TCast(exp*, targ(e), targ(e), targ(e), c, info(e))
      (e:TUpCast) :
        val exp* = bexp(exp(e), CExp(targ(e)))
        TUpCast(exp*, targ(e), targ(e), targ(e), c, info(e))
      (e:TSet) :
        val ref* = bexp(ref(e), CExp(#?)) as TRef
        val v* = bexp(value(e), CExp(type(ref*)))
        #super(type(ref*), type(v*))
        TSet(ref*, v*, lit-type(false), lit-type(false), c, info(e))
      (e:TDo) :
        ;Variables
        val exp-a1* = #freshv(length(args(e)))
        val args* = map(bexp{_, CExp(_)}, args(e), exp-a1*)
        val fc = CDo(#types(args*), type(c), map(all-types, args*))
        val f* = bexp(func(e), fc)
        ;Expected argument types
        #downto(exp-a1*, exp-type(f*), ArgsF())
        ;Infer return type
        val a2* = #freshv()
        #downto(a2*, type(f*), RetF(length(args(e))))
        TDo(f*, args*, a2*, a2*, c, info(e))
      (e:TPrim) :
        val args* = bexp(args(e), CExp(#?))
        val t* = prim-type(op(e))
        TPrim(op(e), args*, t*, t*, c, info(e))
      (e:TLiteral) :
        val vt = lit-type(value(e))
        TLiteral(value(e), vt, vt, c, info(e))
      (e:TTupleExp) :
        val exp-ts* = #freshv(length(exps(e)))
        val exps* = map(bexp{_, CExp(_)}, exps(e), exp-ts*)
        val t* = attempt: TTuple(map(#V, #types(exps*)))
        val exp-t* = attempt: TTuple(map(#V, #exp-types(exps*)))
        #upto(exp-ts*, type(c), TupleF())
        TTupleExp(exps*, t*, exp-t*, c, info(e))
      (e:TMix) :
        val sv = SVar(fresh-id())
        val exps* = map(bexp{_, c}, exps(e))
        val t* = #freshv()
        val et* = #freshv()
        match(c) :
          (c:CExp) :
            #partof(sv, #exp-types(exps*) as List<False|TArrow>, type(c))
            #mix(t*, sv, #types(exps*) as List<False|TArrow>)
            #mix(et*, sv, #exp-types(exps*) as List<False|TArrow>)
          (c:CDo) :
            #callable(sv, #exp-types(exps*) as List<False|TArrow>, all-args(c))
            #mix(t*, sv, #types(exps*) as List<False|TArrow>)
            #mix(et*, sv, #exp-types(exps*) as List<False|TArrow>)
        TMix(sv, exps*, t*, et*, c, info(e))

  defn bmulti (e:TExp, targs*:List<TVar>, c:CMulti) -> TExp :
    match(e) :
      (e:TRef) :
        val t = env[n(e)]
        val e* = TRef(n(e), t, t, c, info(e))
        match(#instantiate(t, targs*, type(c))) :
          (r:Instantiated) : TCurry(e*, targs*, cargs(r), type(r), exp-type(r), c, info(e))
          (r:WrongArity) : TCurry(e*, targs*, List(), false, false, c, info(e))
          (r:NotPoly) : e*
      (e:TMix) :
        val sv = SVar(fresh-id())
        val exps* = map(bmulti{_, targs*, c}, exps(e))
        #select-multi(sv, type(c), #types(exps*) as List<False|TArrow>)
        TMix(sv, exps*, false, false, c, info(e))

  defn blscomm (c:LSComm) -> LSComm :
    match(c) :
      (c:LSCall) :
        LSCall(blsexp(exp(c), CLSExp(#ls?)), info(c))
      (c:LSSet) :
        LSSet(exp*, v*, info(c)) where :
          val exp* = blsexp(exp(c), CLSExp(#ls?))
          val v* = blsexp(value(c), CLSExp(type(exp*)))
      (c:LSLabels) :
        ;Register blocks
        for b in blocks(c) do :
          set-ls-env(n(b), FnT(atypes(b), false, UnknownT()))
        ;Gen blocks
        val bs* = for b in blocks(c) map :
          set-ls-env(args(b), atypes(b))
          LSLabeledBlock(n(b), args(b), atypes(b), blscomm(body(b)), info(b))
        LSLabels(bs*, info(c))
      (c:LSGoto) :
        ;Block types
        val bts = a(ls-env[n(c)] as FnT)
        val args* = map(blsexp{_, CLSExp(_)}, args(c), bts)
        LSGoto(n(c), args*, info(c))
      (c:LSReturn) :
        val ret = current-return-type as LSType
        LSReturn(blsexp(exp(c), CLSExp(ret)), info(c))
      (c:LSDef) :
        LSDef(n(c), t*, v*, info(c)) where :
          val v* = blsexp(value(c), CLSExp(#or(type(c), #ls?)))
          val t* = #or(type(c), type(v*))
          set-ls-env(n(c), t*)
      (c:LSDefVar) :
        LSDefVar(n(c), type(c), v*, info(c)) where :
          val v* = blsexp(value(c) as LSExp, CLSExp(type(c))) when value(c) is-not False
          set-ls-env(n(c), type(c))
      (c:LSSeq) :
        LSSeq(blscomm(a(c)), blscomm(b(c)), info(c))
      (c:LSIf) :
        LSIf(pred*, conseq*, alt*, info(c)) where :
          val pred* = blsexp(pred(c), CLSExp(LongT()))
          val conseq* = blscomm(conseq(c))
          val alt* = blscomm(alt(c))
      (c:LSMatch) :
        val args* = map(blsexp{_, CLSExp(#ls?)}, args(c))
        val bs* = for b in branches(c) map :
          LSBranch(args(b), atypes*, body*, info(c)) where :
            val atypes* = #or(atypes(b), #types(args*))
            set-ls-env(args(b), atypes*)
            val body* = blscomm(body(b))
        LSMatch(args*, bs*, info(c))
      (c:LSSkip) :
        c

  defn blsfields (n:Int, targ:Type, es:List<LSExp>) :
    val fts = match(field-types(n, targ)) :
      (fts:List<LSType>) : fts when length(fts) == length(es)
      (fts:False) : false
    match(fts) :
      (fts:List<LSType>) : map(blsexp{_, CLSExp(_)}, es, fts)
      (fts:False) : map(blsexp{_, CLSExp(false)}, es)

  defn blsexp (e:LSExp, ctxt:Context) -> LSExp :
    val c = ctxt as CLSDo|CLSExp
    match(e) :
      (e:LSVar) :
        val t = ls-env[n(e)]
        val e* = LSVar(n(e), t, t, c, info(e))
        match(#instantiate(t, List(), type(c))) :
          (r:LSInstantiated) : LSCurry(e*, List(), cargs(r), type(r), exp-type(r), c, info(e))
          (r:WrongArity) : LSCurry(e*, List(), List(), false, false, c, info(e))
          (r:NotPoly) : e*
      (e:LSNew) :
        val t = RefT(TOf(n(e), targ(e)))
        val args* = blsfields(n(e), targ(e), args(e))
        LSNew(n(e), targ(e), args*, t, t, c, info(e))
      (e:LSStruct) :
        val t = StructT(n(e), targ(e))
        val args* = blsfields(n(e), targ(e), args(e))
        LSStruct(n(e), targ(e), args*, t, t, c, info(e))
      (e:LSAddr) :
        val c = CLSExp(#deptr(type(c)))
        val exp* = blsexp(exp(e), c)
        LSAddr(exp*, unstable?(e), #ptr(type(exp*)), #ptr(exp-type(exp*)), c, info(e))
      (e:LSDeref) :
        val c = CLSExp(#ls?)
        val exp* = blsexp(exp(e), c)
        LSDeref(exp*, #deref(type(exp*)), #deref(exp-type(exp*)), c, info(e))
      (e:LSSlot) :
        val ptr-t = attempt: PtrT(#V(type(c)))
        val exp* = blsexp(exp(e), CLSExp(ptr-t))
        val ind* = blsexp(index(e), CLSExp(LongT()))
        LSSlot(exp*, ind*, #deptr(type(exp*)), #deptr(exp-type(exp*)), c, info(e))
      (e:LSField) :
        val exp* = blsexp(exp(e), CLSExp(#ls?))
        val t* = #field(type(exp*), name(e))
        LSField(exp*, name(e), t*, t*, c, info(e))
      (e:LSDo) :
        ;Variables
        val exp-a1* = #ls-freshv(length(args(e)))
        val args* = map(blsexp{_, CLSExp(_)}, args(e), exp-a1*)
        val fc = CLSDo(#types(args*), type(c), map(all-types, args*))
        val f* = blsexp(func(e), fc)
        ;Expected argument types
        #args(exp-a1*, exp-type(f*))
        ;Infer return type
        val t* = #ret(type(f*))
        LSDo(f*, args*, t*, t*, c, info(e))
      (e:LSCallC) :
        ;Variables
        val exp-a1* = #ls-freshv(length(args(e)))
        val args* = map(blsexp{_, CLSExp(_)}, args(e), exp-a1*)
        val fc = CLSDo(#types(args*), type(c), map(all-types, args*))
        val f* = blsexp(func(e), fc)
        ;Expected argument types
        #args(exp-a1*, exp-type(f*))
        ;Infer return type
        val t* = #ret(type(f*))
        LSCallC(f*, args*, t*, t*, c, info(e))
      (e:LSPrim) :
        val args* = map(blsexp{_, CLSExp(UnknownT())}, args(e))
        val ret = #prim(op(e), #types(args*))
        LSPrim(op(e), args*, ret, ret, c, info(e))
      (e:LSSizeof) :
        LSSizeof(targ(e), LongT(), LongT(), c, info(e))
      (e:LSTagof) :
        LSTagof(n(e), LongT(), LongT(), c, info(e))
      (e:LSCast) :
        val exp* = blsexp(exp(e), CLSExp(#ls?))
        LSCast(exp*, targ(e), conv?(e), targ(e), targ(e), c, info(e))
      (e:LSLiteral) :
        val t = ls-lit-type(value(e))
        LSLiteral(value(e), t, t, c, info(e))
      (e:LSAnd) :
        defn blong (e:LSExp) : blsexp(e, CLSExp(LongT()))
        LSAnd(blong(a(e)), blong(b(e)), LongT(), LongT(), c, info(e))
      (e:LSOr) :
        defn blong (e:LSExp) : blsexp(e, CLSExp(LongT()))
        LSOr(blong(a(e)), blong(b(e)), LongT(), LongT(), c, info(e))
      (e:LSLetExp) :
        val comm* = blscomm(comm(e))
        val exp* = blsexp(exp(e), c)
        LSLetExp(comm*, exp*, type(exp*), exp-type(exp*), c, info(e))
      (e:LSMix) :
        val sv = SVar(fresh-id())
        val exps* = map(blsexp{_, c}, exps(e))
        val ts* = #types(exps*) as List<False|FnT>
        val exp-ts* = #exp-types(exps*) as List<False|FnT>
        val t* = #ls-freshv()
        val ct* = #ls-freshv()
        match(c) :
          (c:CLSExp) :
            #select(sv, exp-ts*, type(c))
            #pick(t*, sv, ts*)
            #pick(ct*, sv, exp-ts*)
          (c:CLSDo) :
            #callable(sv, exp-ts*, all-args(c))
            #mix(t*, sv, ts*)
            #mix(ct*, sv, exp-ts*)
        LSMix(sv, exps*, t*, ct*, c, info(e))
      (e:LSCurry) :
        val t = ls-env[n(ref(e))]
        val e* = LSVar(n(ref(e)), t, t, c, info(e))
        match(#instantiate(t, targs(e), type(c))) :
          (r:LSInstantiated) : LSCurry(e*, targs(e), cargs(r), type(r), exp-type(r), c, info(e))
          (r:WrongArity) : LSCurry(e*, targs(e), List(), false, false, c, info(e))
      (e:LSFn) :
        val ref* = bexp(ref(e), CExp(#ref-type(type(c))))
        defn reft (t:False|Type) : attempt: RefT(#V(t))
        LSFn(ref*, reft(type(ref*)), reft(exp-type(ref*)), c, info(e))


  ;             ===============================
  ;             ==   Constraint Generation   ==
  ;             ===============================

  ;===== Constraint Upward and Downward Propagators =====
  ;Propagate type upwards towards a subform
  defn #upto (r:False|Type, w:False|Type, f:SubF) :
    ;Substitute TUVar(n*) with t*, and all other TUVar with ?
    defn sub (t:Type, n*:Int, t*:Type) :
      match(t) :
        (t:TUVar) :
          if n(t) == n* : t*
          else : #?
        (t) : map(sub{_, n*, t*}, t)
    match(r, w, ti(f)) :
      (r:TUVar, w:Type, ti:TUVar) :
        val t* = sub(t(f), n(ti), TCap(n(r)))
        #cap(r, t*, w)
      (r, w, ti) :
        false

  ;Propagate type upwards towards elements of tuple form
  defn #upto (rs:List<TUVar>, w:False|Type, f:TupleF) :
    if w is-not False :
      val n = length(rs)
      for (r in rs, i in 0 to n) do :
        #cap(r, #tuple-cap(r, i, n), w as Type)

  ;Propagate type downwards towards elements of tuple form
  defn #downto (rs:List<TUVar>, w:False|Type, f:TupleF) :
    if w is-not False :
      val n = length(rs)
      for (r in rs, i in 0 to n) do :
        #cap(r, w as Type, #tuple-cap(r, i, n))

  ;Propagate type downwards towards arguments of function
  defn #downto (rs:List<TUVar>, w:False|Type, f:ArgsF) :
    if w is-not False :
      val n = length(rs)
      for (r in rs, i in 0 to n) do :
        val a1 = #tuple-cap(r, i, n)
        #cap(r, w as Type, TArrow(a1, #?))

  ;Propagate type downwards towards return of function
  defn #downto (r:TUVar, w:False|Type, f:RetF) :
    if w is-not False :
      val a = TTuple(map({#?}, 0 to n(f)))
      val b = TCap(n(r))
      #cap(r, w as Type, TArrow(a, b))

  ;===== Constraint Generation Utilities =====
  ;Create a new constraint variables
  defn make-ls-constraint-var (Constraint: Int -> Constraint) :
    val r = #ls-freshv()
    addc(Constraint(n(r)))
    r
  defn make-constraint-var (Constraint: Int -> Constraint) :
    val r = #freshv()
    addc(Constraint(n(r)))
    r

  ;Capture i'th element in m element tuple
  defn #tuple-cap (t:TUVar, i:Int, m:Int) :
    TTuple $ for j in 0 to m map :
      if j == i : TCap(n(t))
      else : #?

  ;Create supertype constraint
  defn #super (a:False|Type, b:False|Type) :
    match(a, b) :
      (a:TUVar, b:Type) : addc(SuperConstraint(n(a), b))
      (a, b) : false

  ;Create equality constraint
  defn #equal (ats:List<False|Type>, bts:List<False|Type>) :
    do(#equal, ats, bts)

  defn #equal (a:Type, b:False|Type) :
    match(a, b) :
      (a:TUVar, b:Type) : addc(EqualConstraint(n(a), b))
      (a, b) : false

  defn #equal (a:LSType, b:False|LSType) :
    match(a, b) :
      (a:UVarT, b:LSType) : addc(LSEqualConstraint(n(a), b))
      (a, b) : false

  defn #equal (a:False, b:False|LSType) :
    false

  ;Create capture constraint
  defn #cap (r:TUVar, x:Type, y:Type) :
    addc(FlowConstraint(n(r), x, y))

  defn #cap (r:TUVar, x:LSType, y:LSType) :
    addc(LSFlowConstraint(n(r), x, y))

  ;Create a partof constraint
  defn #partof (s:SVar, ats:List<False|TArrow>, bt:False|Type) :
    if bt is-not False :
      addc(PartofConstraint(n(s), ats, bt as Type))

  ;Create a callable constraint
  defn #callable (s:SVar, ats:List<False|TArrow>, args:List<List<Type>>) :
    addc(CallableConstraint(n(s), ats, args))

  defn #callable (s:SVar, ats:List<False|FnT>, args:List<List<LSType>>) :
    addc(LSCallableConstraint(n(s), ats, args))

  ;Create a selection constraint
  defn #select (s:SVar, ats:List<False|FnT>, bt:False|LSType) :
    if bt is-not False :
      addc(LSSelConstraint(n(s), ats, bt as LSType))

  ;Create a multi selection constraint
  defn #select-multi (s:SVar, at:False|TArrow, bts:List<False|TArrow>) :
    if at is-not False :
      addc(SelMultiConstraint(n(s), at as TArrow, bts))

  ;Create a substitution constraint
  defn #sub (t:Type, env:List<KeyValue<Int,Type>>) :
    make-constraint-var(SubConstraint{_, t, env})

  defn #sub (t:LSType, env:List<KeyValue<Int,Type>>) :
    make-ls-constraint-var(LSSubConstraint{_, t, env})

  ;Create a mixture constraint
  defn #mix (t:TUVar, s:SVar, ats:List<False|TArrow>) :
    addc(MixConstraint(n(t), n(s), ats))

  defn #mix (t:UVarT, s:SVar, ats:List<False|FnT>) :
    addc(LSMixConstraint(n(t), n(s), ats))

  ;Create a pick constraint
  defn #pick (t:UVarT, s:SVar, xs:List<False|FnT>) :
    addc(LSPickConstraint(n(t), n(s), xs))

  ;Isolate a single capture variable
  defn isolate-cap (n*:Int, t:Type) :
    match(t) :
      (t:TCap) :
        if n(t) == n* : t
        else : TUVar(n(t))
      (t) : map(isolate-cap{n*, _}, t)
  defn isolate-cap (n*:Int, t:LSType) :
    mapr(isolate-cap{n*, _}, t)

  ;Relax captures in a type
  defn relax-cap (t:Type) :
    match(t) :
      (t:TCap) : TGradual()
      (t) : map(relax-cap, t)
  defn relax-cap (t:LSType) :
    mapr(relax-cap, t)

  ;Instantiate a polymorphic type with the given type arguments
  ;Returns [Instantiated Captured Args, Instantiated Type, Relaxed Type]
  ;Instantiated type contains unification variables for captured args.
  ;Relaxed type contains graduals in place of captured args
  defn #instantiate (t:Type, targs*:List<Type>, w:False|Type) -> InstResult :
    match(t) :
      (t:TPoly) :
        if length(targs(t)) == length(targs*) :
          val cargs* = #freshv(length(cargs(t)))
          val env = map(KeyValue,
                       append(targs(t), cargs(t))
                       append(targs*, cargs*))
          val a1* = sub(uncap(a(func(t))), env)
          val a2* = #sub(b(func(t)), env)
          val t* = TArrow(a1*, a2*)
          val cap-a1* = sub(a(func(t)), env)
          val cap-t* = TArrow(cap-a1*, a2*)
          if w is-not False :
            for v in cargs* do :
              #cap(v, isolate-cap(n(v), cap-t*), w as Type)
          Instantiated(cargs*, t*, relax-cap(cap-t*) as TArrow)
        else : WrongArity()
      (t) :
        if empty?(targs*) : NotPoly()
        else : WrongArity()

  defn #instantiate (t:LSType, targs*:List<Type>, w:False|LSType) -> LSInstResult :
    match(t) :
      (t:PolyT) :
        if length(targs(t)) == length(targs*) :
          val cargs* = #freshv(length(cargs(t)))
          val env = map(KeyValue,
                       append(targs(t), cargs(t))
                       append(targs*, cargs*))
          val a* = map(sub{uncap(_), env}, a(func(t)))
          val r* = attempt: sub(uncap(#V(r(func(t)))), env)
          val b* = #sub(b(func(t)), env)
          val t* = FnT(a*, r*, b*)
          val cap-a* = map(sub{_, env}, a(func(t)))
          val cap-r* = attempt: sub(#V(r(func(t))), env)
          val cap-t* = FnT(cap-a*, cap-r*, b*)
          if w is-not False :
            for v in cargs* do :
              #cap(v, isolate-cap(n(v), cap-t*), w as LSType)
          LSInstantiated(cargs*, t*, relax-cap(cap-t*) as FnT)
        else : WrongArity()
      (t) :
        if empty?(targs*) : NotPoly()
        else : WrongArity()

  defn #instantiate (t:False, targs*:List<Type>, w:False|LSType|Type) :
    NotPoly()

  ;Create an arguments constraint
  defn #arg (r:UVarT, t:False|LSType, i:Int, arity:Int) :
    if t is-not False :
      addc(ArgConstraint(n(r), t as LSType, i, arity))
  defn #args (rs:List<UVarT>, t:False|LSType) :
    val n = length(rs)
    for (r in rs, i in 0 to false) do :
      #arg(r, t, i, n)

  ;LS Constraints
  defn #ptr (t:False|LSType) :
    attempt: make-ls-constraint-var(PtrConstraint{_, #V(t)})
  defn #deptr (t:False|LSType) :
    attempt: make-ls-constraint-var(DeptrConstraint{_, #V(t)})
  defn #deref (t:False|LSType) :
    attempt: make-ls-constraint-var(DerefConstraint{_, #V(t)})
  defn #field (t:False|LSType, name:Symbol) :
    attempt: make-ls-constraint-var(FieldConstraint{_, #V(t), name})
  defn #ret (t:False|LSType) :
    attempt: make-ls-constraint-var(RetConstraint{_, #V(t)})
  defn #prim (op:LSPrimitive, args:List<False|LSType>) :
    attempt: make-ls-constraint-var(LSPrimConstraint{_, op, map(#V,args)})
  defn #ref-type (t:False|LSType) :
    attempt: make-constraint-var(RefTypeConstraint{_, #V(t)})


  ;               Fill Results
  ;               ============
  defn filler (results:SolveResults) :
    ;   Track the type variables currently in scope
    ;   -------------------------------------------
    var tvars-in-scope:List<Int> = List()
    defn in-scope? (t:Type) :
      match(t) :
        (t:TVar) : contains?(tvars-in-scope, n(t))
        (t) : all?(in-scope?, children(t))
    defn in-scope? (t:LSType) :
      match(t) :
        (t:RefT) : in-scope?(type(t))
        (t:StructT) : in-scope?(type(t))
        (t) : all?(in-scope?, children(t))
    defn with-targs<?T> (c:TComm, f: () -> ?T) :
      defn use-targs (xs:List<Int>) :
        let-var tvars-in-scope = append(xs, tvars-in-scope) :
          f()
      match(c) :
        (c:TDefn|TDefmethod|TLDefn|TLDefmethod|TDefmulti) :
          use-targs(append(targs(c), cargs(c)))
        (c) : f()

    ;   Filling Functions
    ;   -----------------
    defn fill-ctxt (c:Context) -> Context :
      map(fill-lt, map(fill-t, c))
    defn fill-s (s:Selection) -> Selection :
      match(s) :
        (s:SVar) : get?(sels(results), n(s), s)
        (s) : s
    defn #fill-t (t:Type) -> Type :
      match(t) :
        (t:TUVar) :
          match(get?(types(results), n(t), false)) :
            (t*:Type) : t* when in-scope?(t*) else t
            (t*:False) : t
        (t) : map(#fill-t, t)
    defn #fill-lt (t:LSType) -> LSType :
      match(t) :
        (t:UVarT) :
          match(get?(lstypes(results), n(t), false)) :
            (t*:LSType) : t* when in-scope?(t*) else t
            (t*:False) : t
        (t) : map(#fill-lt, map(#fill-t, t))
    defn fill-t (t:Type) -> Type :
      simplify(#fill-t(t))
    defn fill-lt (t:LSType) -> LSType :
      simplify(#fill-lt(t))
    defn fill-lc (c:LSComm) :
      map{fill-lt, _} $
      map{fill-lc, _} $
      map{fill-le, _} $
      c
    defn fill-le (e:LSExp) :
      val e* = map{fill-t, _} $
               map{fill-lc, _} $
               map{fill-le, _} $
               map{fill-lt, _} $
               map{fill-e, _} $
               map{fill-s, _} $
               map{fill-ctxt, _} $
               e
      match(e*:LSCast) :
        val conv? = attempt :
          val et = type(exp(e*)) as? LSType
          val reinterpret? = reinterpret?(et, targ(e*)) as? True|False
          not reinterpret?
        LSCast(exp(e*), targ(e*), conv?, type(e*), exp-type(e*), ctxt(e*), info(e*))
      else : e*
    defn fill-e (e:TExp) -> TExp :
      map{fill-t, _} $
      map{fill-e, _} $
      map{fill-c, _} $
      map{fill-ctxt, _} $
      map{fill-s, _} $
      e
    defn fill-c (c:TComm) -> TComm :
      with-targs{c, _} $ fn* () :
        map{fill-le, _} $
        map{fill-lc, _} $
        map{fill-e, _} $
        map{fill-t, _} $
        c
    defn fill-prog (p:TProg) :
      map(fill-c, p)

    Filler(fill-ctxt, fill-s, fill-t, fill-lt,
           fill-lc, fill-le, fill-e, fill-c, fill-prog)

  ;Infer Missing Types
  defn infer-types (prog:TProg) :
    build-environment()
    var prog* = map(bcomm, prog)
    val f = filler(solve(constraints))
    fill-prog(f)(prog*)

  ;Update environment with missing types
  defn final-fn-type (c:TDefn|TDefmethod|TDefmulti) :
    val a1* = a1(c) as List<Type>
    val a2* = a2(c) as Type
    wrap-poly(TArrow(TTuple(a1*), a2*), targs(c), cargs(c))
  
  defn update-env (prog:TProg) :
    for c in prog do :
      match(c) :
        (c:TDefType) :
          false
        (c:TLDefType) :
          false
        (c:TDef) :
          val t = type(c) as Type
          set-env(n(c), t)
          set-ls-env(n(c), RefT(t))
        (c:TDefTuple) :
          val ts = types(c) as List<Type>
          set-env(ns(c), ts)
          set-ls-env(ns(c), map(RefT, ts))
        (c:TDefVar) :
          val t = type(c) as Type
          set-env(n(c), t)
          set-ls-env(n(c), RefT(t))
        (c:TDefn) :
          val t = final-fn-type(c)
          set-env(n(c), t)
          set-ls-env(n(c), to-ls-fn(t))
        (c:TDefmulti) :
          val t = final-fn-type(c)
          set-env(n(c), t)
          set-ls-env(n(c), to-ls-fn(t))
        (c:TDefmethod) :
          set-env(n(c), final-fn-type(c))
        (c:TInit) :
          false
        (c:TLDef) :
          set-ls-env(n(c), type(c))
          set-env(n(c), to-hs-type(type(c)))
        (c:TLDefVar) :
          set-ls-env(n(c), type(c))
          set-env(n(c), to-hs-type(type(c)))
        (c:TLDefn) :
          val t = fn-type(c)
          set-ls-env(n(c), t)
          set-env(n(c), to-hs-fn(t))
        (c:TLExternFn) :
          val t = fn-type(c)
          set-ls-env(n(c), t)
          set-env(n(c), to-hs-fn(t))
        (c:TLDefmethod) :
          val t = fn-type(c)
          set-ls-env(n(c), t)
          set-env(n(c), to-hs-fn(t))
        (c:TExtern) :
          set-ls-env(n(c), type(c))
          set-env(n(c), to-hs-type(type(c)))
        (c:TLInit) :
          false

  ;                 Driver
  ;                 ======
  val prog* = infer-types(prog)
  update-env(prog*)
  [prog*, env, ls-env]

;============================================================
;=================== Report Errors ==========================
;============================================================

defn report-errors (nm:NameMap,
                    prog:TProg,                    
                    env:IntTable<False|Type>,
                    ls-env:IntTable<False|LSType>) :

   ;              Error Buffer
   ;              ============
   val errors = Vector<TypeError>()
   defn E! (e:TypeError) : add(errors, e)

   ;         Track Current Scope Information
   ;         ===============================
   var current-return-type : False|LSType = false
   var current-new-type : False|Type = false

   ;               Error Predicates
   ;               ================
   ;Short for casted
   defn #C (f:False) : fatal("Cast Error")
   defn #C (t:Type) : t
   defn #C (t:LSType) : t
   defn #C (t:List<False|Type>) : t as List<Type>
   defn #C (t:List<False|LSType>) : t as List<LSType>

   defn not-resolved? (x:False|Type|LSType|Selection) :
      match(x) :
         (x:False) : false
         (x:Type) : not resolved?(x)
         (x:LSType) : not resolved?(x)
         (x:SSel) : any?({_ is Unknown}, sels(x))
         (x:SVar) : true

   defn not-st? (x:False|Type|LSType, y:False|Type|LSType) :
      match(x, y) :
         (x:False, y) : false
         (x, y:False) : false
         (x:Type, y:Type) : subtype?(x, y) is False
         (x:LSType, y:LSType) : subtype?(x, y) is False

   defn not-sm? (x:TArrow, y:False|Type) :
      match(y) :
         (y:TArrow) : submethod?(x, y) is False
         (y) : false

   defn not-overlap? (x:False|Type|LSType, y:False|Type|LSType) :
      match(x, y) :
         (x:False, y) : false
         (x, y:False) : false
         (x:Type, y:Type) : overlap?(x, y) is False
         (x:RefT, y:RefT) : overlap?(x, y) is False
         (x:LSType, y:LSType) : false

   defn not-tuple? (t:False|Type) :
      val tuple-t = TOf(coreid(CORE-TUPLE-ID), TTuple(List(TGradual())))
      not-st?(t, tuple-t)

   defn not-tuple? (t:False|Type, arity:Int) :
      val tuple-t = TTuple(map(TGradual{}, 0 to arity))
      not-st?(t, tuple-t)

   defn not-func? (t:False|Type) :
      val func-t = TArrow(TGradual(), TGradual())
      not-st?(t, func-t)

   defn not-assign? (x:False|LSType, y:False|LSType) :
      match(x, y) :
         (x:False, y) : false
         (x, y:False) : false
         (x:LSType, y:LSType) : assignable?(x, y) is False

   defn not-bounded? (t:False|LSType) :
      (t is LSType) and bounded?(#C(t)) is False

   defn cant-call? (t:False|Type, ats:List<False|Type>) :
      if none?({_ is False}, ats) :
         val func-t = TArrow(TTuple(#C(ats)), TGradual())
         not-st?(t, func-t)

   defn cant-ls-call? (t:False|LSType, ats:List<False|LSType>) :
      if (t is-not False) and none?({_ is False}, ats) :
         callable?(t as FnT, #C(ats)) is False

   defn cant-call? (op:Primitive, ats:List<False|Type>) :
      if none?({_ is False}, ats) :
         not callable?(op, #C(ats))

   defn cant-call? (op:LSPrimitive, ats:List<False|LSType>) :
      if none?({_ is False}, ats) :
         not callable?(op, #C(ats))

   defn cant-cast? (x:False|LSType, y:LSType) :
      match(x) :
         (x:LSType) : castable?(x, y) is False
         (x:False) : false

   defn not-ref? (t:False|LSType) :
      (t is-not False) and (t is-not RefT)

   defn cant-deref? (t:False|LSType) :
      (t is-not False) and (deref(#C(t)) is False)

   defn cant-deptr? (t:False|LSType) :
      (t is-not False) and (deptr(#C(t)) is False)

   defn cant-field? (t:False|LSType, f:Symbol) :
      (t is-not False) and (field(#C(t), f) is False)

   defn not-func? (t:LSType) :
      t is-not FnT

   defn not-stack? (t:False|LSType) :
      val stack-t = RefT(TOf(coreid(CORE-STACK-ID), TTuple(List())))
      not-assign?(t, stack-t)

   defn not-long? (t:False|LSType) :
      not-assign?(t, LongT())

   defn not-longs? (x:False|LSType, y:False|LSType) :
      match(x, y) :
         (x:False, y) : false
         (x, y:False) : false
         (x:LSType, y:LSType) : not-assign?(x, LongT()) or not-assign?(y, LongT())

   defn no-size? (t:LSType) :
      t is UnknownT|FnT

   defn all-pairs<?T> (xs:Seqable<?T>) :
      val xs* = to-array<T>(xs)
      generate<[T, T]> :
         for i in 0 to length(xs*) do :
            for j in (i + 1) to length(xs*) do :
               yield([xs*[i], xs*[j]])

   defn not-disjoint? (ts:List<TArrow>, u:False|Type) :
      val u* = TGradual() when u is False else #C(u)
      for [x, y] in all-pairs(ts) any? :
         not disjoint-fns?(x, y, u*)

   defn not-disjoint? (ts:List<FnT>, u:False|LSType) :
      val u* = UnknownT() when u is False else #C(u)
      for [x, y] in all-pairs(ts) any? :
         not disjoint-fns?(x, y, u*)

   defn wrong-poly-tarity? (t:False|Type|LSType, type-args:List<Type>|List<LSType>) :
      match(t) :
         (t:TArrow|FnT) : not empty?(type-args)
         (t:TPoly|PolyT) : length(type-args) != length(targs(t))
         (t:False) : false

   defn ls-def? (n:Int) :
      key?(nm, n) and (type(nm[n]) is LFnE|LVarE|LValE)

   defn mutable? (n:Int) :
      key?(nm, n) and type(nm[n]) is VarE|LVarE

   defn not-lvalue? (e:LSExp) :
      match(e) :
         (e:LSVar) : not mutable?(n(e))
         (e:LSField) :
            match(type(exp(e))) :
               (t:RefT|PtrT) : false
               (t:LSType) : not-lvalue?(exp(e))
               (t:False) : false
         (e:LSDeref|LSSlot) : false
         (e) : false

   defn unstable-loc? (e:LSExp) :
      defn unstable-base? (e:LSExp) :
         match(e) :
            (e:LSDeref) : unstable-base?(exp(e))
            (e:LSSlot) : unstable-base?(exp(e))
            (e:LSField) : unstable-base?(exp(e))
            (e) : type(e) is RefT
      match(e) :
         (e:LSVar) : false
         (e:LSDeref|LSSlot|LSField) : unstable-base?(e)
         (e) : false

   defn wrong-tarity? (n:Int, targ:Type) :
      match(targ) :
         (targ:TGradual) : false
         (targ:TTuple) : length(types(targ)) != type-tarity(n)

   defn select<?T> (xs:List<?T>, ss:SSel) :
      to-list $ for (x in xs, s in sels(ss)) filter :
         s is-not False

   ;               Tree Walker
   ;               ===========

   defn check (c:TComm) :
      check(c, false)

   defn check (c:TComm, top?:True|False) :
      ;Continue recursion
      defn check-subexps () :
         do(check{_:TExp}, c)
         do(check{_:LSExp}, c)
         do(check{_:LSComm}, c)

      match(c) :
         (c:TDef) :
            check-subexps()
            if not-st?(type(value(c)), type(c)) :
               E!(BadAssign(info(c), c))
            if top? and not-resolved?(type(c)) :
               E!(NoInferredType(info(c), c))
         (c:TDefTuple) :
            check-subexps()
            ;Check detupling
            val t = type(value(c))
            val arity = length(ns(c))
            E!(NotTuple(info(c), #C(t))) when not-tuple?(t) else
            E!(BadDetuple(info(c), #C(t), arity)) when not-tuple?(t, arity)
            ;Check inferred
            if top? and any?(not-resolved?, types(c)) :
               E!(NoInferredType(info(c), c))
         (c:TDefVar) :
            check-subexps()
            if value(c) is-not False :
               val vt = type(value(c) as TExp)
               E!(BadAssign(info(c), c)) when not-st?(vt, type(c))
            E!(NoInferredType(info(c), c)) when not-resolved?(type(c))
         (c:TDefn) :
            check-subexps()
            ;Check Return
            val bt = type(body(c))
            check-ret(c) when not-st?(bt, a2(c))
            ;Check inferred ret
            E!(NoInferredRet(info(c), c)) when not-resolved?(a2(c))
         (c:TDefmethod) :
            ;Check method overriding
            val mt = type(ctxt(multi(c)) as CMulti) as TArrow
            check-multi(multi(c), mt)
            ;Check body
            check(body(c))
            ;Check this type
            if current-new-type is-not False :
               val i = index-of(args(c), thisn(c) as Int) as Int
               val this-t = a1(c)[i] as Type
               val obj-t = current-new-type as Type
               if not this-type?(this-t, obj-t) :
                  E!(BadThisType(info(c), this-t, obj-t))
            ;Check return type
            val bt = type(body(c))
            check-ret(c) when not-st?(bt, a2(c))
         (c:TLDef) :
            check-subexps()
            val vt = type(value(c))
            E!(BadAssign(info(c),c)) when not-assign?(vt, type(c))
            E!(UnboundedDef(info(c),c)) when not-bounded?(type(c))
         (c:TLDefVar) :
            check-subexps()
            ;Check initial value
            if value(c) is-not False :
               val vt = type(value(c) as LSExp)
               E!(BadAssign(info(c),c)) when not-assign?(vt, type(c))
            ;Check boundedness
            E!(UnboundedDef(info(c),c)) when not-bounded?(type(c))
         (c:TLDefmethod) :
            ;Check method overriding
            if ctxt(multi(c)) is-not False :
               val mt = type(ctxt(multi(c)) as CMulti) as TArrow
               check-multi(multi(c), mt)
            ;Check type signature
            if env[n(c)] is False :
               E!(BadLSMethod(info(c), ls-env[n(c)] as LSType))
            ;Check body
            let-var current-return-type = a2(c) :
               check(body(c))
         (c:TLDefn) :
            let-var current-return-type = a2(c) :
               check(body(c))
         (c:TLExternFn) :
            let-var current-return-type = a2(c) :
               check(body(c))
         (c) :
            check-subexps()

   defn check-ret (def:TDefn|TDefmethod|TFn) :
      val ret = #C(a2(def))
      defn loop (e:TExp) :
         match(e) :
            (e:TLet|TLetVar|TLetTuple|TLetRec|TBranch) : loop(body(e))
            (e:TMatch) : do(loop, branches(e))
            (e:TSeq) : loop(b(e))
            (e) :
               if not-st?(type(e), ret) :
                  E!(BadRet(info(e), def, #C(type(e))))
      loop(body(def))

   defn check-multi (e:TExp, mt:TArrow) :
      match(e) :
         (e:TRef) :
            match(type(e)) :
               (t:TArrow) : E!(BadMethod(info(e), e, mt)) when not-sm?(mt, t)
               (t:Type) : E!(BadMethod(info(e), e, mt))
               (t:False) : false
         (e:TMix) :
            val exps* = select(exps(e), sel(e) as SSel)
            val n = length(exps*)
            switch {n == _} :
               0 : E!(NoMulti(info(e), exps(e), mt))
               1 : check-multi(head(exps*), mt)
               else : E!(AmbMulti(info(e), exps*, mt))
         (e:TCurry) :
            ;Check submethod
            if not-sm?(mt, type(e)) :
               E!(BadMethod(info(e), e, mt))
            ;Check targ arity
            if wrong-poly-tarity?(type(ref(e)), targs(e)) :
               E!(WrongTypeArity(info(e), e))
            ;Check carg captures
            if ctxt(e) is-not False :
               if any?(not-resolved?, cargs(e) as List<Type>) :
                  E!(BadCapture(info(e), e, ctxt(e) as CMulti))

   defn check (e:TExp) :
      ;Check subexpressions
      defn check-subexps () :
         do(check{_:TExp}, e)
         do(check{_:TComm}, e)

      ;Check constraints
      match(e) :
         (e:TLet) :
            check-subexps()
            ;Check assign
            val vt = type(value(e))
            E!(BadAssign(info(e),e)) when not-st?(vt, ntype(e))
         (e:TLetVar) :
            check-subexps()
            E!(NoInferredType(info(e),e)) when not-resolved?(ntype(e))
            if value(e) is-not False :
               val vt = type(value(e) as TExp)
               E!(BadAssign(info(e),e)) when not-st?(vt, ntype(e))
         (e:TLetTuple) :
            check-subexps()
            val t = type(value(e))
            val arity = length(ns(e))
            E!(NotTuple(info(e), t as Type)) when not-tuple?(t) else
            E!(BadDetuple(info(e), t as Type, arity)) when not-tuple?(t, arity)
         (e:TFn) :
            ;Check inferred arguments
            for (a in args(e), t in a1(e)) do :
               E!(NoInferredArg(info(e), a, ctxt(e) as Context)) when not-resolved?(t)
            ;Check body
            check-subexps()
            ;Check return type
            val bt = type(body(e))
            check-ret(e) when not-st?(bt, a2(e))
         (e:TMatch) :
            val arg-ts = map(type, args(e))
            for b in branches(e) do :
               for (a in args(b), at in arg-ts, bt in atypes(b)) do :
                  if not-overlap?(at, bt) :
                     E!(BadBranchArg(info(e), a, bt as Type, at as Type))
            check-subexps()
         (e:TCast) :
            check-subexps()
            val et = type(exp(e))
            E!(BadCast(info(e), et as Type, targ(e))) when not-overlap?(et, targ(e))
         (e:TUpCast) :
            check-subexps()
            val et = type(exp(e))
            E!(BadUpcast(info(e), et as Type, targ(e))) when not-st?(et, targ(e))
         (e:TSet) :
            check-subexps()
            val vt = type(value(e))
            val rt = type(ref(e))
            E!(BadSet(info(e), n(ref(e)), vt as Type)) when not-st?(vt, rt)
         (e:TDo) :
            check-subexps()
            val ft = type(func(e))
            if not-func?(ft) :
               E!(NotFunction(info(e), func(e)))
            else :
               val ats = map(type, args(e))
               E!(BadCall(info(e), func(e), ats as List<Type>)) when cant-call?(ft, ats)
         (e:TPrim) :
            check-subexps()
            val ats = map(type, args(e))
            E!(BadPrimitive(info(e), op(e), ats as List<Type>)) when cant-call?(op(e), ats)
         (e:TMix) :
            val exps* = select(exps(e), sel(e) as SSel)
            val n = length(exps*)
            val c = ctxt(e) as CExp|CDo
            switch {n == _} :
               0 :
                  ;Selection is all false
                  E!(NoMix(info(e), exps(e), c))
               1 :
                  ;Selection has exactly one non-false
                  check(head(exps*))
               else :
                  ;Selection contains unknowns
                  if not-resolved?(sel(e)) :
                     E!(AmbMix(info(e), exps*, c))
                  ;Selection contains multiple trues
                  else :
                     val ts = map({type(_) as TArrow}, exps*)
                     if not-disjoint?(ts, type(c)) : E!(AmbMix(info(e), exps*, c))
                     else : do(check, exps*)
         (e:TCurry) :
            ;Check ref
            check-subexps()
            ;Check targ arity
            if wrong-poly-tarity?(type(ref(e)), targs(e)) :
               E!(WrongTypeArity(info(e),e))
            ;Check carg captures
            val c = ctxt(e) as Context
            E!(BadCapture(info(e), e, c)) when any?(not-resolved?, cargs(e))
         (e:TRef) :
            if ls-def?(n(e)) :
               E!(BadLSRef(info(e), n(e))) when type(e) is False
         (e:TNew) :
            let-var current-new-type = class(e) :
               check-subexps()
         (e) :
            check-subexps()


   defn check (c:LSComm) :
      defn check-subexps () :
         do(check{_:LSExp}, c)
         do(check-bounded, c)
         do(check{_:LSComm}, c)

      match(c) :
         (c:LSSet) :
            check-subexps()
            E!(BadLValue(info(c),exp(c))) when not-lvalue?(exp(c))
            val et = type(exp(c))
            val vt = type(value(c))
            E!(BadLSSet(info(c),exp(c),vt as LSType)) when not-assign?(vt, et)
         (c:LSReturn) :
            check-subexps()
            val et = type(exp(c))
            val ret = current-return-type as LSType
            E!(BadLSRet(info(c), et as LSType, ret)) when not-assign?(et, ret)
         (c:LSDef) :
            check-subexps()
            val vt = type(value(c))
            val dt = type(c)
            E!(BadAssign(info(c),c)) when not-assign?(vt, dt)
            E!(UnboundedDef(info(c),c)) when not-bounded?(dt)
         (c:LSDefVar) :
            E!(UnboundedDef(info(c),c)) when not-bounded?(type(c))
            check-subexps()
            if value(c) is-not False :
               val vt = type(value(c) as LSExp)
               E!(BadAssign(info(c),c)) when not-assign?(vt, type(c))
         (c:LSIf) :
            val pt = type(pred(c))
            E!(BadPred(info(c), pt as LSType)) when not-long?(pt)
            check-subexps()
         (c:LSMatch) :
            val arg-ts = map(type, args(c))
            if any?(not-ref?, arg-ts) :
               for (a in args(c), t in arg-ts) do :
                  E!(BadMatchArg(info(a), t as LSType)) when not-ref?(t)
            else :
               val ats = arg-ts as List<RefT>
               for b in branches(c) do :
                  val bts = atypes(b)
                  for (x in args(b), at in ats, bt in bts) do :
                     E!(BadBranchArg(info(b), x, #C(bt), at)) when not-overlap?(at, bt)
            check-subexps()
         (e:LSGoto) :
            check-subexps()
            val bt = ls-env[n(e)] as FnT
            val ats = map(type, args(e))
            E!(BadGoto(info(e), n(e), bt, #C(ats))) when cant-ls-call?(bt, ats)
         (c) :
            check-subexps()

   defn check (e:LSExp) -> False :
      ;Check subexpressions
      defn check-subexps () :
         do(check{_:LSExp}, e)
         do(check{_:LSComm}, e)
         do(check{_:TExp}, e)

      match(e) :
         (e:LSNew) :
            check-subexps()
            
            ;Check targ arities
            if wrong-tarity?(n(e), targ(e)) :
               E!(ObjectWrongTypeArity(info(e), n(e), targ(e)))
               
            ;If creating a simple object   
            else if bounded-type?(n(e)) :
               val fts = init-field-types!(n(e), targ(e))
               val actual = length(fts)
               val given = length(args(e))
               E!(ObjectWrongFieldArity(info(e), n(e), given, actual)) when given != actual
               ;Check initialization types
               val ats = map(type, args(e))
               E!(BadNew(info(e), e, #C(ats))) when any?(not-assign?, ats, fts)
               
            ;If creating an array object      
            else :
               ;Retrieve field types and rest field types
               val [fts, rft] = let :
                  val fs = field-types!(n(e), targ(e))
                  [but-last(fs), type(last(fs) as RestT)]
               val actual = length(fts)
               val given = length(args(e))
               E!(ObjectWrongMinFieldArity(info(e), n(e), given, actual)) when given < actual
               ;Ensure length field
               if empty?(fts) or head(fts) is-not LongT :
                  E!(NoLengthField(info(e), e))
               ;Check initialization types
               val ats = map(type, args(e))
               if any?(not-assign?, ats, cat(fts, repeat(rft))) :
                  E!(BadArray(info(e), e, #C(ats)))
         (e:LSStruct) :
            check-subexps()
            ;Check bounded
            val t = StructT(n(e), targ(e))
            E!(StructWithRest(info(e), t)) when not bounded-type?(n(e))
            ;Check arities
            if wrong-tarity?(n(e), targ(e)) :
               E!(ObjectWrongTypeArity(info(e), n(e), targ(e)))
            else :
               val fts = init-field-types!(n(e), targ(e))
               val actual = length(fts)
               val given = length(args(e))
               E!(ObjectWrongFieldArity(info(e), n(e), given, actual)) when given != actual
               ;Check initialization types
               val ats = map(type, args(e))
               E!(BadNew(info(e), e, #C(ats))) when any?(not-assign?, ats, fts)
         (e:LSDeref) :
            check-subexps()
            val t = type(exp(e))
            E!(BadDeref(info(e), #C(t))) when cant-deref?(t)
         (e:LSSlot) :
            check-subexps()
            ;Check index
            val it = type(index(e))
            E!(BadIndex(info(e), #C(it))) when not-long?(it)
            ;Check expression
            val t = type(exp(e))
            E!(BadSlot(info(e), #C(t))) when cant-deptr?(t)
         (e:LSField) :
            check-subexps()
            val t = type(exp(e))
            E!(BadField(info(e),#C(t),name(e))) when cant-field?(t, name(e))
         (e:LSDo) :
            check-subexps()
            val ft = type(func(e))
            if not-func?(ft) :
               E!(NotLSFunction(info(e),func(e)))
            else :
               val ats = map(type, args(e))
               E!(BadLSCall(info(e),func(e),#C(ats))) when cant-ls-call?(ft, ats)
         (e:LSAddr) :
            check-subexps()
            if not unstable?(e) :
               E!(BadAddr(info(e), exp(e))) when unstable-loc?(exp(e))
         (e:LSCallC) :
            check-subexps()
            val ft = type(func(e))
            if not-func?(ft) :
               E!(NotLSFunction(info(e),func(e)))
            else :
               ;Check if closure
               match(func(e)) :
                  (f:LSDeref) :
                     val ft = type(exp(f))
                     E!(BadLSCallClosure(info(e),exp(f))) when ft is RefT
                  (f) : false
               ;Check call
               val ats = map(type, args(e))
               E!(BadLSCall(info(e),func(e),#C(ats))) when cant-ls-call?(ft, ats)
         (e:LSPrim) :
            check-subexps()
            val ats = map(type, args(e))
            E!(BadPrimitive(info(e),op(e),#C(ats))) when cant-call?(op(e), ats)
         (e:LSSizeof) :
            E!(BadSizeof(info(e),targ(e))) when no-size?(targ(e))
         (e:LSCast) :
            check-subexps()
            val et = type(exp(e))
            E!(BadCast(info(e),#C(et),targ(e))) when cant-cast?(et, targ(e))
         (e:LSAnd) :
            check-subexps()
            val at = type(a(e))
            val bt = type(b(e))
            E!(BadAnd(info(e),#C(at),#C(bt))) when not-longs?(at,bt)
         (e:LSOr) :
            check-subexps()
            val at = type(a(e))
            val bt = type(b(e))
            E!(BadOr(info(e),#C(at),#C(bt))) when not-longs?(at,bt)
         (e:LSMix) :
            val exps* = select(exps(e), sel(e) as SSel)
            val n = length(exps*)
            val c = ctxt(e) as CLSExp|CLSDo
            switch {n == _} :
               0 :
                  ;Selection is all false
                  E!(NoMix(info(e), exps(e), c))
               1 :
                  ;Selection has exactly one non-false
                  check(head(exps*))
               else :
                  ;Selection contains unknowns
                  if not-resolved?(sel(e)) :
                     E!(AmbMix(info(e), exps*, c))
                  ;Selection contains multiple trues
                  else :
                     val ts = map({type(_) as FnT}, exps*)
                     if not-disjoint?(ts, type(c)) : E!(AmbMix(info(e), exps*, c))
                     else : do(check, exps*)
         (e:LSCurry) :
            check-subexps()
            ;Check targ arity
            if wrong-poly-tarity?(type(ref(e)), targs(e)) :
               E!(WrongTypeArity(info(e),e))
            ;Check carg captures
            val c = ctxt(e) as Context
            E!(BadCapture(info(e), e, c)) when any?(not-resolved?, cargs(e))
         (e) :
            check-subexps()

   defn check-bounded (e:LSExp) :
      defn check-exp (e:LSExp, bounded-exp?:True|False) -> False :
         if bounded-exp? :
            if not-bounded?(type(e)) :
               E!(UnboundedExp(info(e),#C(type(e))))
         match(e) :
            (e:LSDo|LSCallC) :
               check-exp(func(e), false)
               do(check-exp{_, true}, args(e))
            (e:LSAddr) : check-exp(exp(e), false)
            (e:LSField) : check-exp(exp(e), false)
            (e:LSSlot) :
               check-exp(exp(e), false)
               check-exp(index(e), true)
            (e:LSMix|LSCurry) : false
            (e:LSLetExp) : check-exp(exp(e), bounded-exp?)
            (e) : do(check-exp{_:LSExp, true}, e)
      check-exp(e, true)

   ;======== Driver ========
   do(check, prog)
   if not empty?(errors) :
      ;Filter out low priority errors
      val filtered-errors = let :
         val hp = filter(high-priority{_, env, ls-env}, errors)
         errors when empty?(hp) else hp
      ;Throw Errors
      throw $ TypeErrors $ to-tuple $
         for e in filtered-errors seq :
            to-printable(e, nm, env, ls-env)

;============================================================
;================== Error Messages ==========================
;============================================================
public defstruct TypeErrors <: Exception :
  messages: Collection
defmethod print (o:OutputStream, e:TypeErrors) :
  print-all(o, join(messages(e), "\n"))

deftype TypeError <: Exception

defstruct NoInferredType <: TypeError :
   info: False|FileInfo
   def: TDef|TDefTuple|TDefVar|TLetVar

defstruct BadAssign <: TypeError :
   info: False|FileInfo
   def: TDef|TDefVar|TLDef|TLDefVar|TLet|TLetVar|LSDef|LSDefVar

defstruct BadLSMethod <: TypeError :
   info: False|FileInfo
   type: LSType

defstruct UnboundedDef <: TypeError :
   info: False|FileInfo
   def: TLDef|TLDefVar|LSDef|LSDefVar

defstruct UnboundedExp <: TypeError :
   info: False|FileInfo
   type: LSType

defstruct StructWithRest <: TypeError :
   info: False|FileInfo
   type: LSType

defstruct ObjectWrongTypeArity <: TypeError :
   info: False|FileInfo
   n: Int
   targ: Type

defstruct ObjectWrongFieldArity <: TypeError :
   info: False|FileInfo
   n: Int
   given: Int
   actual: Int

defstruct ObjectWrongMinFieldArity <: TypeError :
   info: False|FileInfo
   n: Int
   given: Int
   actual: Int

defstruct BadNew <: TypeError :
   info: False|FileInfo
   exp: LSNew|LSStruct
   types: List<LSType>

defstruct BadArray <: TypeError :
   info: False|FileInfo
   exp: LSNew
   types: List<LSType>

defstruct NoLengthField <: TypeError :
   info: False|FileInfo
   exp: LSNew

defstruct NotTuple <: TypeError :
   info: False|FileInfo
   type: Type

defstruct BadDetuple <: TypeError :
   info: False|FileInfo
   type: Type
   n: Int

defstruct NoInferredArg <: TypeError :
   info: False|FileInfo
   n: Int
   ctxt: Context

defstruct NoInferredRet <: TypeError :
   info: False|FileInfo
   def: TDefn

defstruct BadThisType <: TypeError :
   info: False|FileInfo
   this-type: Type
   obj-type: Type

defstruct BadRet <: TypeError :
   info: False|FileInfo
   def: TDefn|TDefmethod|TFn
   type: Type

defstruct BadLSRet <: TypeError :
   info: False|FileInfo
   type: LSType
   expected: LSType

defstruct BadBranchArg <: TypeError :
   info: False|FileInfo
   n: Int
   type: Type|LSType
   match-type: Type|LSType

defstruct BadCast <: TypeError :
   info: False|FileInfo
   type: Type|LSType
   targ: Type|LSType

defstruct BadUpcast <: TypeError :
   info: False|FileInfo
   type: Type
   targ: Type

defstruct BadSet <: TypeError :
   info: False|FileInfo
   n: Int
   type: Type

defstruct BadLSSet <: TypeError :
   info: False|FileInfo
   loc: LSExp
   type: LSType

defstruct BadLValue <: TypeError :
   info: False|FileInfo
   loc: LSExp

defstruct BadAddr <: TypeError :
   info: False|FileInfo
   loc: LSExp

defstruct NotFunction <: TypeError :
   info: False|FileInfo
   func: TExp

defstruct NotLSFunction <: TypeError :
   info: False|FileInfo
   func: LSExp

defstruct BadCall <: TypeError :
   info: False|FileInfo
   func: TExp
   arg-types: List<Type>

defstruct BadLSCall <: TypeError :
   info: False|FileInfo
   func: LSExp
   arg-types: List<LSType>

defstruct BadGoto <: TypeError :
   info: False|FileInfo
   n: Int
   block-type: FnT
   arg-types: List<LSType>

defstruct BadLSCallClosure <: TypeError :
   info: False|FileInfo
   func: LSExp

defstruct BadLSRef <: TypeError :
   info: False|FileInfo
   n: Int

defstruct NoMix <: TypeError :
   info: False|FileInfo
   exps: List<TExp>|List<LSExp>
   ctxt: Context

defstruct AmbMix <: TypeError :
   info: False|FileInfo
   exps: List<TExp>|List<LSExp>
   ctxt: Context

defstruct NoMulti <: TypeError :
   info: False|FileInfo
   exps: List<TExp>
   method-type: Type

defstruct AmbMulti <: TypeError :
   info: False|FileInfo
   exps: List<TExp>
   method-type: Type

defstruct BadMethod <: TypeError :
   info: False|FileInfo
   multi: TExp
   method-type: Type

defstruct WrongTypeArity <: TypeError :
   info: False|FileInfo
   exp: TCurry|LSCurry

defstruct BadPrimitive <: TypeError :
   info: False|FileInfo
   op: Primitive|LSPrimitive
   arg-types: List<Type>|List<LSType>

defstruct BadCapture <: TypeError :
   info: False|FileInfo
   func: TCurry|LSCurry
   ctxt: Context

defstruct BadPred <: TypeError :
   info: False|FileInfo
   type: LSType

defstruct BadMatchArg <: TypeError :
   info: False|FileInfo
   type: LSType

defstruct BadLength <: TypeError :
   info: False|FileInfo
   type: LSType

defstruct BadDeref <: TypeError :
   info: False|FileInfo
   type: LSType

defstruct BadIndex <: TypeError :
   info: False|FileInfo
   type: LSType

defstruct BadSlot <: TypeError :
   info: False|FileInfo
   type: LSType

defstruct BadField <: TypeError :
   info: False|FileInfo
   type: LSType
   name: Symbol

defstruct BadSizeof <: TypeError :
   info: False|FileInfo
   targ: LSType

defstruct BadAnd <: TypeError :
   info: False|FileInfo
   atype: LSType
   btype: LSType

defstruct BadOr <: TypeError :
   info: False|FileInfo
   atype: LSType
   btype: LSType


;============================================================
;=============== Error Message Printing =====================
;============================================================

defn to-printable (e:TypeError,
                   nm:NameMap,
                   env:IntTable<False|Type>,
                   ls-env:IntTable<False|LSType>) :
   ;Utilities
   defn cms (xs:Seqable) : join(xs, ", ")
   defn #pr (t:Type) : printable(nm, t)
   defn #pr (t:LSType) : printable(nm, t)
   defn #pr (ts:Seqable<Type|LSType>) : cms(seq(#pr, ts))

   defn #V (f:False) : fail()
   defn #V (t:Type) : t
   defn #V (t:LSType) : t

   ;Properties at definition
   defn has-name? (n:Int) : key?(nm,n)
   defn #name (n:Int) :
     if has-name?(n) : name(nm[n])
     else : "V%_" % [n]
   defn #type (n:Int) -> Type|LSType :
      match(get?(env, n), get?(ls-env, n)) :
         (t:Type, lt) : t
         (t:False, lt:LSType) : lt

   defn info-str (n:Int) :
     match(info(nm[n])) :
       (info:FileInfo) : "at %_" % [info]
       (info:False) : "in package %~" % [package(nm[n])]

   defn #inf? (x:False|FileInfo) :
      match(x) :
         (x:False) : ""
         (x:FileInfo) : "%_: " % [x]

   defn name? (x:Int|List<Int>, str:String, default:String) :
      match(x) :
         (xs:List<Int>) :
            if all?(has-name?, xs) : str % [cms(seq(#name, xs))]
            else : default
         (x:Int) :
            if has-name?(x) : str % [#name(x)]
            else : default

   defn def-name (c:TLetTuple|TLetVar|TLet|TDefTuple|TDefVar|TDef|TLDef|TLDefVar|LSDef|LSDefVar) :
      match(c) :
         (c:TDef|TLDef) : name?(n(c), "global value %_", "global value")
         (c:TDefVar|TLDefVar) : name?(n(c), "global variable %_", "global variable")
         (c:TDefTuple) : name?(ns(c), "global values %*", "tuple elements")
         (c:TLet|LSDef) : name?(n(c), "value %_", "value")
         (c:TLetVar|LSDefVar) : name?(n(c), "variable %_", "variable")
         (c:TLetTuple) : name?(ns(c), "values %*", "tuple elements")

   defn def-type (c:TLetTuple|TLetVar|TLet|TDefTuple|TDefVar|TDef|TLDef|TLDefVar|LSDef|LSDefVar) :
      match(c) :
         (c:TLetVar|TLet) : ntype(c) as Type
         (c:LSDef|LSDefVar) : type(c) as LSType
         (c:TDef|TDefVar) : type(c) as Type
         (c:TLetTuple) : TTuple(ntypes(c) as List<Type>)
         (c:TDefTuple) : TTuple(types(c) as List<Type>)
         (c:TLDef|TLDefVar) : type(c) as LSType

   defn defined-function-name (c:TDefn|TDefmethod|TFn) :
      match(c) :
         (c:TDefn) : name?(n(c), "function %_", "function")
         (c:TDefmethod) : "method"
         (c:TFn) : "anonymous function"

   defn variable-name (e:LSExp) :
      match(e) :
         (e:LSVar) : name?(n(e), "variable %_", "variable")
         (e) : "location"

   defn value-name (e:TExp|LSExp) :
      match(e) :
         (e:TRef) : name?(n(e), "Value %_", "Value")
         (e:LSVar) : name?(n(e), "Value %_", "Value")
         (e) : "Expression"

   defn function-name (e:TExp|LSExp) :
      match(e) :
         (e:TRef) : name?(n(e), "function %_", "function")
         (e:TMix) : function-name(head(exps(e)))
         (e:TCurry) : function-name(ref(e))
         (e:LSVar) : name?(n(e), "function %_", "function")
         (e:LSMix) : function-name(head(exps(e)))
         (e:LSCurry) : function-name(ref(e))
         (e) : "expression"

   defn multi-name (e:TExp) :
      match(e) :
         (e:TRef) : name?(n(e), "multi %_", "multi")
         (e:TMix) : multi-name(head(exps(e)))
         (e:TCurry) : multi-name(ref(e))

   defn ref-n (e:TExp|LSExp) :
      match(e) :
         (e:TRef) : n(e)
         (e:TCurry) : ref-n(ref(e))
         (e:LSVar) : n(e)
         (e:LSCurry) : ref-n(ref(e))

   defn possibilities (exps:Seqable<TExp|LSExp>) :
      join{_, "\n"} $ for e in exps seq :
         val n = ref-n(e)         
         "   %_: %_ %_" % [#name(n), #pr(#type(n)), info-str(n)]

   match(e) :
      (e:NoInferredType) :
         "%_Could not infer type of %_." % [
            #inf?(info(e)), def-name(def(e))]
      (e:BadAssign) :
         val v = value(def(e)) as TExp|LSExp
         "%_Cannot assign expression of type %_ to %_ with declared type %_." % [
            #inf?(info(e)), #pr(type(v) as Type|LSType), def-name(def(e)), #pr(def-type(def(e)))]
      (e:BadLSMethod) :
         "%_Cannot define LoStanza method with type %_." % [
            #inf?(info(e)), #pr(type(e))]
      (e:UnboundedDef) :
         "%_Cannot define %_ with unbounded type %_." % [
            #inf?(info(e)), def-name(def(e)), #pr(def-type(def(e)))]
      (e:UnboundedExp) :
         "%_Expression has unbounded type %_." % [
            #inf?(info(e)), #pr(type(e))]
      (e:StructWithRest) :
         "%_Cannot create struct of type %_ containing rest field." % [
            #inf?(info(e)), #pr(type(e))]
      (e:ObjectWrongTypeArity) :
         val actual = type-tarity(n(e))
         val given = types(targ(e) as TTuple)
         val name = name?(n(e), "Type %_", "Type")
         "%_%_ requires %_ type arguments, but given (%*)." % [
            #inf?(info(e)), name, actual, #pr(given)]
      (e:ObjectWrongFieldArity) :
         val name = name?(n(e), "Type %_", "Type")
         "%_%_ requires %_ fields, but given %_." % [
            #inf?(info(e)), name, actual(e), given(e)]
      (e:ObjectWrongMinFieldArity) :
         val name = name?(n(e), "Type %_", "Type")
         "%_%_ requires at least %_ fields, but given %_." % [
            #inf?(info(e)), name, actual(e), given(e)]
      (e:BadNew) :
         val t = StructT(n(exp(e)), targ(exp(e)))
         val construct = match(exp(e)) :
            (e:LSNew) : "object"
            (e:LSStruct) : "struct"
         "%_Cannot create %_ of type %_ with fields of type (%*)." % [
            #inf?(info(e)), construct, #pr(t), #pr(types(e))]
      (e:BadArray) :
         val t = StructT(n(exp(e)), targ(exp(e)))
         "%_Cannot create array of type %_ with fields of type (%*)." % [
            #inf?(info(e)), #pr(t), #pr(types(e))]
      (e:NoLengthField) :
         val t = StructT(n(exp(e)), targ(exp(e)))
         "%_Cannot create array of type %_. First field must be of type long to indicate the array length." % [
            #inf?(info(e)), #pr(t)]         
      (e:NotTuple) :
         "%_Cannot detuple expression of type %_." %
            [#inf?(info(e)), #pr(type(e))]
      (e:BadDetuple) :
         "%_Cannot deconstruct expression of type %_ into tuple of length %_." %
            [#inf?(info(e)), #pr(type(e)), n(e)]
      (e:NoInferredArg) :
         val ctxt = match(ctxt(e)) :
            (c:CDo) :
               attempt :
                  val ats = map(#V, args(c))
                  " Called with arguments (%*)." % [#pr(ats)]
               else : ""
            (c:CExp) :
               attempt :
                  val t = #V(type(c))
                  " Context expecting type %_." % [#pr(t)]
               else : ""
         val name = name?(n(e), "argument %_", "argument")
         "%_Could not infer type for %_.%_" % [
            #inf?(info(e)), name, ctxt]
      (e:NoInferredRet) :
         "%_Could not infer return type for %_." % [
            #inf?(info(e)), defined-function-name(def(e))]
      (e:BadThisType) :
         "%_Cannot define this argument with type %_ when constructing object of type %_." % [
            #inf?(info(e)), #pr(this-type(e)), #pr(obj-type(e))]
      (e:BadRet) :
         val name = defined-function-name(def(e))
         val ret = a2(def(e)) as Type
         "%_Cannot return an expression of type %_ for %_ with declared return type %_." % [
            #inf?(info(e)), #pr(type(e)), name, #pr(ret)]
      (e:BadLSRet) :
         "%_Cannot return expression of type %_ from function with declared return type %_." % [
            #inf?(info(e)), #pr(type(e)), #pr(expected(e))]
      (e:BadBranchArg) :
         val name = name?(n(e), "argument %_", "argument")
         "%_Branch type %_ for %_ cannot match against match argument of type %_." % [
            #inf?(info(e)), #pr(type(e)), name, #pr(match-type(e))]
      (e:BadCast) :
         "%_Cannot cast expression of type %_ to type %_." % [
            #inf?(info(e)), #pr(type(e)), #pr(targ(e))]
      (e:BadUpcast) :
         "%_Cannot upcast expression of type %_ to type %_." % [
            #inf?(info(e)), #pr(type(e)), #pr(targ(e))]
      (e:BadSet) :
         val name = name?(n(e), "variable %_", "variable")
         "%_Cannot assign expression of type %_ to %_ with declared type %_." % [
            #inf?(info(e)), #pr(type(e)), name, #pr(#type(n(e)))]
      (e:BadLSSet) :
         val name = variable-name(loc(e))
         val loct = type(loc(e)) as LSType
         "%_Cannot assign expression of type %_ to %_ with declared type %_." % [
            #inf?(info(e)), #pr(type(e)), name, #pr(loct)]
      (e:BadLValue) :
         "%_Cannot assign to non-assignable %_." % [
            #inf?(info(e)), variable-name(loc(e))]
      (e:BadAddr) :
         "%_Cannot retrieve address of unstable %_ using addr operator." % [
            #inf?(info(e)), variable-name(loc(e))]
      (e:NotFunction) :
         val name = value-name(func(e))
         val ft = type(func(e)) as Type
         "%_%_ of type %_ cannot be called as a function." % [
            #inf?(info(e)), name, #pr(ft)]
      (e:NotLSFunction) :
         val name = value-name(func(e))
         val ft = type(func(e)) as LSType
         "%_%_ of type %_ cannot be called as a function." % [
            #inf?(info(e)), name, #pr(ft)]
      (e:BadCall) :
         val name = function-name(func(e))
         val ft = type(func(e)) as Type
         "%_Cannot call %_ of type %_ with arguments of type (%*)." % [
            #inf?(info(e)), name, #pr(ft), #pr(arg-types(e))]
      (e:BadLSCall) :
         val name = function-name(func(e))
         val ft = type(func(e)) as LSType
         "%_Cannot call %_ of type %_ with arguments of type (%*)." % [
            #inf?(info(e)), name, #pr(ft), #pr(arg-types(e))]
      (e:BadGoto) :
         val name = name?(n(e), "block %_", "block")
         val bts = a(block-type(e))
         "%_Cannot goto %_ defined with argument types (%*) with given arguments of type (%*)." % [
            #inf?(info(e)), name, #pr(bts), #pr(arg-types(e))]
      (e:BadLSCallClosure) :
         val ft = type(func(e)) as LSType
         "%_Cannot call closure of type %_ using C calling convention." % [
            #inf?(info(e)), #pr(ft)]
      (e:BadLSRef) :
         val name =
            match(type(nm[n(e)])) :
               (t:LVarE) : name?(n(e), "variable %_", "variable")
               (t:LValE) : name?(n(e), "value %_", "value")
               (t:LFnE) : name?(n(e), "function %_", "function")
         "%_LoStanza %_ of type %_ can only be referred to from LoStanza." % [
            #inf?(info(e)), name, #pr(#type(n(e)))]
      (e:NoMix) :
         val name = #name(ref-n(head(exps(e))))
         match(ctxt(e)) :
            (c:CDo|CLSDo) :
               attempt :
                  val ats = map(#V, args(c))
                  "%_No appropriate function %_ for arguments of type (%*). Possibilities are:\n%*" % [
                     #inf?(info(e)), name, #pr(ats), possibilities(exps(e))]
               else :
                  "%_No appropriate function %_ for this context. Possibilities are:\n%*" % [
                     #inf?(info(e)), name, possibilities(exps(e))]
            (c:CExp|CLSExp) :
               attempt :
                  val t = #V(type(c))
                  "%_No appropriate function %_ for expected type %_. Possibilities are:\n%*" % [
                     #inf?(info(e)), name, #pr(t), possibilities(exps(e))]
               else :
                  "%_No appropriate function %_ for this context. Possibilities are:\n%*" % [
                     #inf?(info(e)), name, possibilities(exps(e))]
      (e:AmbMix) :
         val name = #name(ref-n(head(exps(e))))
         match(ctxt(e)) :
            (c:CDo|CLSDo) :
               attempt :
                  val ats = map(#V, args(c))
                  "%_Ambiguous call to overloaded function %_ with arguments of type (%*). Possibilities are:\n%*" % [
                     #inf?(info(e)), name, #pr(ats), possibilities(exps(e))]
               else :
                  "%_Ambiguous call to overloaded function %_. Possibilities are:\n%*" % [
                     #inf?(info(e)), name, possibilities(exps(e))]
            (c:CExp|CLSExp) :
               attempt :
                  val t = #V(type(c))
                  "%_Ambiguous reference to overloaded function %_ for expected type %_. Possibilities are:\n%*" % [
                     #inf?(info(e)), name, #pr(t), possibilities(exps(e))]
               else :
                  "%_Ambiguous reference to overloaded function %_. Possibilities are:\n%*" % [
                     #inf?(info(e)), name, possibilities(exps(e))]
      (e:NoMulti) :
         val name = #name(ref-n(head(exps(e))))
         "%_No appropriate multi %_ for method of type %_. Possibilities are:\n%*" % [
            #inf?(info(e)), name, #pr(method-type(e)), possibilities(exps(e))]
      (e:AmbMulti) :
         val name = #name(ref-n(head(exps(e))))
         "%_Multiple appropriate multis %_ for method of type %_. Possibilities are:\n%*" % [
            #inf?(info(e)), name, #pr(method-type(e)), possibilities(exps(e))]
      (e:BadMethod) :
         val name = multi-name(multi(e))
         val multi-t = type(multi(e)) as Type
         "%_Cannot attach method of type %_ to %_ of type %_." % [
            #inf?(info(e)), #pr(method-type(e)), name, #pr(multi-t)]
      (e:WrongTypeArity) :
         val name = #name(n(ref(exp(e))))
         val ft = type(ref(exp(e))) as Type|LSType
         match(ft) :
            (t:TPoly|PolyT) :
               if empty?(targs(exp(e))) :
                  "%_Function %_ of type %_ requires %_ type arguments." % [
                     #inf?(info(e)), name, #pr(t), length(targs(t))]
               else :
                  "%_Function %_ of type %_ requires %_ type arguments, but received (%*)." % [
                     #inf?(info(e)), name, #pr(t), length(targs(t)), #pr(targs(exp(e)))]
            (t:TArrow|FnT) :
               "%_Function %_ of type %_ does not accept type arguments, but received (%*)." % [
                  #inf?(info(e)), name, #pr(t), #pr(targs(exp(e)))]
      (e:BadPrimitive) :
         "%_Cannot call primitive %_ with arguments of type (%*)." % [
            #inf?(info(e)), op(e), #pr(arg-types(e))]
      (e:BadCapture) :
         val func-t = type(ref(func(e))) as TPoly|PolyT
         val func-name = #name(n(ref(func(e))))
         val arg-vars = to-list $
            for (a in cargs(func-t), t in cargs(func(e))) filter :
               not resolved?(t as Type)
         val arg-names =
            if length(arg-vars) == 1 : "type argument %_" % [#name(head(arg-vars))]
            else : "type arguments %*" % [cms(map(#name, arg-vars))]
         match(ctxt(e)) :
            (c:CDo|CLSDo) :
               attempt :
                  val ats = map(#V, args(c))
                  "%_Could not capture %_ for function %_ of type %_. Called with arguments of type (%*)." % [
                     #inf?(info(e)), arg-names, func-name, #pr(func-t), #pr(ats)]
               else :
                  "%_Could not capture %_ for function %_ of type %_." % [
                     #inf?(info(e)), arg-names, func-name, #pr(func-t)]
            (c:CExp|CLSExp|CMulti) :
               attempt :
                  val t = #V(type(c))
                  "%_Could not capture %_ for function %_ of type %_. Expected type is %_." % [
                     #inf?(info(e)), arg-names, func-name, #pr(func-t), #pr(t)]
               else :
                  "%_Could not capture %_ for function %_ of type %_." % [
                     #inf?(info(e)), arg-names, func-name, #pr(func-t)]         
      (e:BadPred) :
         "%_Expression of type %_ cannot be used as predicate in if statement. Must be a long." % [
            #inf?(info(e)), #pr(type(e))]
      (e:BadMatchArg) :
         "%_Expression of type %_ cannot be used as argument to match expression. Must be a ref type." % [
            #inf?(info(e)), #pr(type(e))]
      (e:BadLength) :
         "%_Expression of type %_ cannot be used as length for array. Must be a long." % [
            #inf?(info(e)), #pr(type(e))]
      (e:BadDeref) :
         "%_Expression of type %_ cannot be dereferenced." % [
            #inf?(info(e)), #pr(type(e))]
      (e:BadIndex) :
         "%_Expression of type %_ cannot be used as index. Must be a long." % [
            #inf?(info(e)), #pr(type(e))]
      (e:BadSlot) :
         "%_Cannot access indexed slot in expression of type %_." % [
            #inf?(info(e)), #pr(type(e))]
      (e:BadField) :
         "%_Cannot access field %_ in expression of type %_." % [
            #inf?(info(e)), name(e), #pr(type(e))]
      (e:BadSizeof) :
         "%_Cannot compute the size of type %_." % [
            #inf?(info(e)), #pr(targ(e))]
      (e:BadAnd) :
         "%_And operator cannot be applied to argument of type %_ and %_. Must be longs." % [
            #inf?(info(e)), #pr(atype(e)), #pr(btype(e))]
      (e:BadOr) :
         "%_Or operator cannot be applied to argument of type %_ and %_. Must be longs." % [
            #inf?(info(e)), #pr(atype(e)), #pr(btype(e))]


;============================================================
;============== Error Message Priority ======================
;============================================================

defn high-priority (e:TypeError, env:IntTable<False|Type>, ls-env:IntTable<False|LSType>) -> True|False :
   defn #R! (f:False) : fail()
   defn #R! (t:Type) : fail() when not resolved?(t)
   defn #R! (t:LSType) : fail() when not resolved?(t)
   defn #R! (e:TExp) : #R!(type(e))
   defn #R! (e:LSExp) : #R!(type(e))

   defn #type (n:Int) -> Type|LSType :
      match(get?(env, n), get?(ls-env, n)) :
         (t:Type, lt) : t
         (t:False, lt:LSType) : lt

   defn def-type (c:TLetTuple|TLetVar|TLet|TDefTuple|TDefVar|TDef|TLDef|TLDefVar|LSDef|LSDefVar) :
      match(c) :
         (c:TLetVar|TLet) : ntype(c) as Type
         (c:LSDef|LSDefVar) : type(c) as LSType
         (c:TDef|TDefVar) : type(c) as Type
         (c:TLetTuple) : TTuple(ntypes(c) as List<Type>)
         (c:TDefTuple) : TTuple(types(c) as List<Type>)
         (c:TLDef|TLDefVar) : type(c) as LSType

   attempt :
      match(e) :
         (e:NoInferredType) : false
         (e:BadAssign) : (#R!(value(def(e))), #R!(def-type(def(e))))
         (e:BadLSMethod) : #R!(type(e))
         (e:UnboundedDef) : false
         (e:UnboundedExp) : #R!(type(e))
         (e:StructWithRest) : false
         (e:ObjectWrongTypeArity) : false
         (e:ObjectWrongFieldArity) : false
         (e:ObjectWrongMinFieldArity) : false
         (e:BadNew) : do(#R!, types(e))
         (e:BadArray) : do(#R!, types(e))
         (e:NoLengthField) : false
         (e:NotTuple) : #R!(type(e))
         (e:BadDetuple) : #R!(type(e))
         (e:NoInferredArg) : #R!(type(ctxt(e) as CDo|CExp))
         (e:NoInferredRet) : false
         (e:BadThisType) : false
         (e:BadRet) : (#R!(type(e)), #R!(a2(def(e))))
         (e:BadLSRet) : #R!(type(e))
         (e:BadBranchArg) : (#R!(match-type(e)), #R!(type(e)))
         (e:BadCast) : #R!(type(e))
         (e:BadUpcast) : #R!(type(e))
         (e:BadSet) : (#R!(type(e)), #R!(#type(n(e))))
         (e:BadLSSet) : (#R!(loc(e)), #R!(type(e)))
         (e:BadLValue) : false
         (e:BadAddr) : #R!(loc(e))
         (e:NotFunction) : #R!(func(e))
         (e:NotLSFunction) : #R!(func(e))
         (e:BadCall) : (#R!(func(e)), do(#R!, arg-types(e)))
         (e:BadLSCall) : (#R!(func(e)), do(#R!, arg-types(e)))
         (e:BadGoto) : do(#R!, arg-types(e))
         (e:BadLSCallClosure) : #R!(func(e))
         (e:BadLSRef) : false
         (e:NoMix) :
            match(ctxt(e)) :
               (c:CDo|CLSDo) : do(#R!, args(c))
               (c:CExp|CLSExp) : #R!(type(c))
         (e:AmbMix) :
            match(ctxt(e)) :
               (c:CDo|CLSDo) : do(#R!, args(c))
               (c:CExp|CLSExp) : #R!(type(c))
         (e:NoMulti) : #R!(method-type(e))
         (e:AmbMulti) : #R!(method-type(e))
         (e:BadMethod) : (#R!(multi(e)), #R!(method-type(e)))
         (e:WrongTypeArity) : #R!(ref(exp(e)))
         (e:BadPrimitive) : do(#R!, arg-types(e))
         (e:BadCapture) :
            #R!(ref(func(e)))
            match(ctxt(e)) :
               (c:CDo|CLSDo) : do(#R!, args(c))
               (c:CExp|CLSExp|CMulti) : #R!(type(c))
         (e:BadPred) : #R!(type(e))
         (e:BadMatchArg) : #R!(type(e))
         (e:BadLength) : #R!(type(e))
         (e:BadDeref) : #R!(type(e))
         (e:BadIndex) : #R!(type(e))
         (e:BadSlot) : #R!(type(e))
         (e:BadField) : #R!(type(e))
         (e:BadSizeof) : false
         (e:BadAnd) : (#R!(atype(e)), #R!(btype(e)))
         (e:BadOr) : (#R!(atype(e)), #R!(btype(e)))
      ;Return true
      true

;============================================================
;=============== General Utilities ==========================
;============================================================
defstruct Fresh
