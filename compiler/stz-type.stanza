defpackage stz/type :
   import core
   import verse
   import stz/il-ir
   import stz/tl-ir

defn to-tprog (e:IExp) :
   val hier = THierarchy()
   val comms = Vector<TComm>()
   defn to-tcomm (e:IExp) :
      match(e) :
         (e:IPublic) : to-tcomm(exp(e))
         (e:IProtected) : to-tcomm(exp(e))
         (e:IDefType) : add(hier, n!(class(e)), n!(args(e)), to-type(parent(e)))
         (e:IDef) : do(add{comms, _}, destructure-let(e))
         (e:IDefVar) : add(comms, TDefVar(n!(name(e)), to-type(type(e)), to-exp(value(e))))
         (e:IDefn) : add(comms, to-defn(e))
         (e:IDefmulti) :
            val [targs, cargs] = split-targs(targs(e))
            add(comms, TDefmulti(n!(name(e)), targs, cargs, to-type(a1(e)), to-type(a2(e))))
         (e:IDefmethod) : add(comms, to-defmethod(e))
         (e:ILoStanza) : false
         (e) : add(comms, TExpComm(to-exp(e)))
   TProg(hier, to-list(comms))

defn to-type (es:List<IExp) :
   map(to-type, es)
   
defn to-type (e:IExp) -> Type :
   match(e) :
      (e:ITuple) : TTuple(to-type(exps(e)))
      (e:IOf) : TOf(n!(class(e)), TTuple(to-type(args(e))))
      (e:IAnd) : TAnd(to-type(a(e)), to-type(b(e)))
      (e:IOr) : TOr(to-type(a(e)), to-type(b(e)))
      (e:IArrow) : TArrow(TTuple(to-type(a1(e))), to-type(a2(e)))
      (e:ICap) : TCap(n!(name(e)))
      (e:IGradual) : TGradual()
      (e:IVoid) : TBot()
      (e:INone) : TNone()
      (e:VarN) : TVar(n(e))
      (e:Raw) : TOf(n!(class(e)), TGradual())      

defn to-exp (es:List<IExp>) :
   map(to-exp, es)

defn to-exp (e:IExp) -> TExp :
   match(e) :
      (e:IFn) :
         val [ns, body] = destructure(args(e), to-exp(body(e)))
         TFn(tail?(e), to-type(a1(e)), to-type(a2(e)), ns, body)
      (e:IMulti) :
         TMulti(to-exp(funcs(e)))
      (e:IBegin) :
         if empty?(tail(exps)) :
            to-exp(head(exps))
         else :
            val a = to-exp(head(exps))
            val binfo = info(exps(e)[1])
            val b = to-exp(IBegin(tail(exps), binfo))
            TSeq(a, b)
      (e:IMatch) :
         TMatch(to-exp(args(e)), to-exp(branches(e)))
      (e:IBranch) :
         val types = to-type(types(e))
         val [ns, body] = destructure(args(e), to-exp(body(e)))
         TBranch(ns, types, body)
      (e:INew) :
         TNew(to-type(class(e)), to-defmethod(methods(e)))
      (e:ISet) :
         TSet(n!(name(e)), to-exp(value(e)))
      (e:IDo) :
         match(func(e)) :
            (f:IOf) : TPolyDo(to-exp(class(f)), to-type(args(f)), to-exp(args(e)))
            (f) : TDo(to-exp(f), to-exp(args(e)))
      (e:IPrim) :
         val prim-name = name(function(e) as IVar)
         TPrim(prim-name, to-exp(args(e)))
      (e:ICallLS) :
         TCallLS(n!(function(e)), to-type(targs(e)), to-exp(args(e)))
      (e:ILiteral) :
         TLiteral(value(e))
      (e:ITuple) :
         TTuple(to-exp(exps(e)))
      (e:INone) :
         TElide()
      (e:VarN) :
         TVar(n(e))
      (e:Mix) :
         TMix(to-exp(exps(e)))
      (e:Let) :
         to-let(def(e), to-exp(body(e)))
      (e:LetRec) :
         TLetRec(to-defn(defns(e)), to-exp(body(e)))
      (e) :
         error("Unsupported expression: ~" % [e])

defn split-targs (es:List<IExp>) :
   val targs = Vector<Int>()
   val cargs = Vector<Int>()
   for e in es do :
      match(e) :
         (e:VarN) : add(targs, n(e))
         (e:ICap) : add(targs, n!(name(e)))
   [to-list(targs), to-list(cargs)]    

defn to-defn (defs:List<IDefn>) :
   map(to-defn, defs)

defn to-defn (def:IDefn) :
   val [targs, cargs] = split-targs(targs(def))
   val [ns, body] = destructure(args(def), to-exp(body(def)))
   TDefn(tail?(def), n!(name(def)), targs, cargs,
         to-type(a1(def)), to-type(a2(def)),
         ns, body)

defn to-defmethod (def:IDefmethod) :
   val [targs, cargs] = split-targs(targs(def))
   val [ns, body] = destructure(args(def), to-exp(body(def)))
   TDefmethod(tail?(def), to-exp(multi(def)), thisn(def), targs, cargs,
         to-type(a1(def)), to-type(a2(def)),
         ns, body)

;Global Destructuring
defn destructure-def (def:IDef) -> List<TDef> :
   var body = List()
   defn loop (xs:List<IExp>, v:IExp) :
      val ns = for x in xs map :
         match(x) :
            (x:ITuple) :
               val v* = VarN(fresh-n())
               loop(exps(x), v*)
               n(v*)
            (x) : n!(x)
      body = List(IDefTuple(ns, map(TNone{}, ns), v), body)
   match(name(def), type(def)) :
      (name:ITuple, type:INone) :
         loop(exps(name), to-exp(value(def)))
         body
      (name:ITuple, type) :
         val v* = VarN(fresh-n())
         loop(exps(name), v*)
         List(TDef(n(v*), to-type(type), to-exp(value(def))), body)
      (name, type) :
         list(TDef(n!(name), to-type(type), to-exp(value(def))))

;Local Destructuring
defn destructure-let (lete:ILet) -> TExp :
   var body = to-exp(body(lete))
   defn loop (xs:List<IExp>, v:IExp) :
      val ns = for x in xs map :
         match(x) :
            (x:ITuple) :
               val v* = VarN(fresh-n())
               loop(exps(x), v*)
               n(v*)
            (x) : n!(x)
      body = TLetTuple(ns, map(TNone{}, ns), v, body)
   val def = def(lete)
   match(name(def), type(def)) :
      (name:ITuple, type:INone) :
         loop(exps(name), to-exp(value(def)))
         body
      (name:ITuple, type) :
         val v* = VarN(fresh-n())
         loop(exps(name), v*)
         TLet(n(v*), to-type(type), to-exp(value(def)), body)
      (name, type) :
         TLet(n!(name), to-type(type), to-exp(value(def)), body)

;Argument Destructuring
defn destructure-arg (args:List<IExp>, fbody:IExp) -> [List<Int>, TExp] :
   var body = fbody
   val ns = for a in args map :
      match(a) :
         (a:ITuple) :
            val v* = VarN(fresh-n())
            body = ILet(IDef(a, INone(), v*), body)
            n(v*)
         (a) : n!(a)
   [ns, to-exp(body)]

;Returning indices
defn n! (es:List<IExp>) :
   map(n!, es)
   
defn n! (e:IExp) :
   match(e) :
      (e:VarN) : n(e)
      (e:LSVarN) : n(e)