defpackage stz/earley-sexp-stream :
  import core
  import collections
  
;============================================================
;=================== SExpStream Interface ===================
;============================================================

;+[SExpStream Definition]
public deftype SExpStream
public defmulti peek (s:SExpStream) -> SExpToken
public defmulti advance (s:SExpStream, expand-list?:True|False) -> False
public defmulti advance-rest (s:SExpStream) -> False
public defmulti insert-wildcard (s:SExpStream) -> False
public defmulti insert-list (s:SExpStream) -> False
public defmulti info (s:SExpStream) -> FileInfo|False

;============================================================
;====================== SExpTokens ==========================
;============================================================

;+[SExpToken Definition]
public deftype SExpToken
public defstruct SExpForm <: SExpToken :
  form
  list:List
with:
  printer => true
public defstruct SExpWildcard <: SExpToken
public defstruct SExpListEnd <: SExpToken
public defstruct EndOfInput <: SExpToken

public defn list (t:SExpListEnd) :
  List()

;============================================================
;====================== Implementation ======================
;============================================================

public defn SExpStream (input:List) :
  println("Make SExpStream from %_" % [input])
  val stack = Vector<List>()
  var current:List|False = input
  var info:FileInfo|False = false

  defn update-info () :
    match(current:List) :
      if not empty?(current) :
        val t = head(current)
        match(t:Token) :
          info = /info(t)

  defn peek-stream () :
    match(current:List) :
      if empty?(current) : SExpListEnd()
      else :
        match(head(current)) :
          (t:SExpWildcard) : t
          (t) : SExpForm(t, current)
    else : EndOfInput()

  defn ensure-not-empty! () :
    fatal("No more tokens.") when current is False

  defn advance-stream (expand-list?:True|False) :
    ensure-not-empty!()
    val curr = current as List
    if empty?(curr) :
      current = pop(stack) when not empty?(stack)
    else :
      val expand? = expand-list? and
                    unwrap-token(head(curr)) is List
      if expand? :
        add(stack, tail(curr))
        current = unwrap-token(head(curr)) as List
      else :
        current = tail(curr)
    update-info()

  update-info()
  new SExpStream :
    defmethod info (this) :
      info
    defmethod peek (this) :    
      val x = peek-stream()
      println("peek(stream) = %_" % [x])
      x
    defmethod advance (this, expand-list?:True|False) :
      println("advance stream (expand = %_)" % [expand-list?])
      advance-stream(expand-list?)
    defmethod advance-rest (this) :
      println("advance rest of stream")
      ensure-not-empty!()
      current = List()
    defmethod insert-wildcard (this) :
      ensure-not-empty!()
      current = cons(SExpWildcard(), current as List)
    defmethod insert-list (this) :
      ensure-not-empty!()
      current = cons(List(), current as List)
;/[SExpStream Definition]

;============================================================
;=============== Backward Implementation ====================
;============================================================

public defn BackwardSExpStream (tokens:Vector<SExpToken>, infos:Vector<FileInfo|False>) :
  println(tokens)
  var index:Int = length(tokens) - 1
  new SExpStream :
    defmethod peek (this) :
      if index == -1 : EndOfInput()
      else : tokens[index]
    defmethod advance (this, expand?:True|False) :
      fatal("Backward stream does not support expand.") when expand?
      fatal("No more tokens.") when index == -1
      index = index - 1
    defmethod advance-rest (this) :
      fatal("Backward stream does not support advance-rest.")
    defmethod insert-wildcard (this) :
      fatal("Backward stream does not support insert-wildcard.")
    defmethod insert-list (this) :
      fatal("Backward stream does not support insert-list.")
    defmethod info (this) :
      infos[index] when index >= 0