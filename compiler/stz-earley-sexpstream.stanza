defpackage stz/earley-sexp-stream :
  import core
  import collections
  
;============================================================
;=================== SExpStream Interface ===================
;============================================================

;+[SExpStream Definition]
public deftype SExpStream
public defmulti peek (s:SExpStream) -> SExpToken
public defmulti advance (s:SExpStream, expand-list?:True|False) -> False
public defmulti advance-rest (s:SExpStream) -> False
public defmulti insert-wildcard (s:SExpStream) -> False
public defmulti insert-list (s:SExpStream) -> False
public defmulti info (s:SExpStream) -> FileInfo|False

;============================================================
;====================== SExpTokens ==========================
;============================================================

;+[SExpToken Definition]
public deftype SExpToken
public defstruct SExpForm <: SExpToken :
  form
  list:List
with:
  printer => true
public defstruct SExpWildcard <: SExpToken
public defstruct SExpListEnd <: SExpToken
public defstruct EndOfInput <: SExpToken

public defn list (t:SExpListEnd) :
  List()

;============================================================
;====================== Implementation ======================
;============================================================

public defn SExpStream (input:List) :
  val stack = Vector<List>()
  var current:List = List(input)
  var info:FileInfo|False = false

  defn update-info () :
    if not empty?(current) :
      val t = head(current)
      match(t:Token) :
        info = /info(t)

  defn peek-stream () :
    if empty?(current) :
      if empty?(stack) : EndOfInput()
      else : SExpListEnd()
    else :
      match(head(current)) :
        (t:SExpWildcard) : t
        (t) : SExpForm(t, current)

  defn ensure-not-empty! () :
    fatal("No more tokens.") when empty?(current) and empty?(stack)

  defn advance-stream (expand-list?:True|False) :
    ensure-not-empty!()
    if empty?(current) :
      current = pop(stack)
    else :
      val expand? = expand-list? and
                    unwrap-token(head(current)) is List
      if expand? :
        add(stack, tail(current))
        current = unwrap-token(head(current)) as List
      else :
        current = tail(current)
    update-info()

  update-info()
  new SExpStream :
    defmethod info (this) :
      info
    defmethod peek (this) :    
      peek-stream()
    defmethod advance (this, expand-list?:True|False) :
      advance-stream(expand-list?)
    defmethod advance-rest (this) :
      ensure-not-empty!()
      current = List()
    defmethod insert-wildcard (this) :
      ensure-not-empty!()
      current = cons(SExpWildcard(), current)
    defmethod insert-list (this) :
      ensure-not-empty!()
      current = cons(List(), current)
;/[SExpStream Definition]

;============================================================
;=============== Backward Implementation ====================
;============================================================

public defn BackwardSExpStream (tokens:Vector<SExpToken>, infos:Vector<FileInfo|False>) :
  var index:Int = length(tokens) - 1
  new SExpStream :
    defmethod peek (this) :
      if index == -1 : EndOfInput()
      else : tokens[index]
    defmethod advance (this, expand?:True|False) :
      fatal("Backward stream does not support expand.") when expand?
      fatal("No more tokens.") when index == -1
      index = index - 1
    defmethod advance-rest (this) :
      fatal("Backward stream does not support advance-rest.")
    defmethod insert-wildcard (this) :
      fatal("Backward stream does not support insert-wildcard.")
    defmethod insert-list (this) :
      fatal("Backward stream does not support insert-list.")
    defmethod info (this) :
      infos[index] when index >= 0