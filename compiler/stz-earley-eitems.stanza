defpackage stz/earley-eitems :
  import core
  import collections
  import stz/earley-grammar

protected val MAIN-TIMER = MillisecondTimer("MAIN TIMER")
protected val FACTORED-TIMER = MillisecondTimer("FACTORED STARTS")

;============================================================
;============== ProductionTable/ProductionSet ===============
;============================================================

public deftype ProductionTable<T> <: Collection<KeyValue<Int,T>>
public defmulti get<?T> (t:ProductionTable<?T>, id:Int) -> T
public defmulti set<?T> (t:ProductionTable<?T>, id:Int, v:T) -> False
public defmulti clear (t:ProductionTable) -> False
public defmulti key? (t:ProductionTable, id:Int) -> True|False

public defn ProductionTable<T> (num-productions:Int, default:T) :
  val table = Array<T>(num-productions,default)
  val occupied = Array<True|False>(num-productions,false)
  new ProductionTable<T> :
    defmethod get (this, id:Int) :
      table[id]
    defmethod set (this, id:Int, v:T) :
      table[id] = v
      occupied[id] = true
    defmethod clear (this) :
      for i in 0 to num-productions do :
        table[i] = default
        occupied[i] = false
    defmethod to-seq (this) :
      for i in 0 to num-productions seq? :
        if occupied[i] : One(i => table[i])
        else : None()
    defmethod key? (this, id:Int) :
      occupied[id]

public defn add<?T> (t:ProductionTable<List<?T>>, id:Int, x:T) :
  t[id] = cons(x, t[id])

public defn map!<?T> (f:KeyValue<Int,T> -> T, table:ProductionTable<?T>) :
  for entry in table do :
    table[key(entry)] = f(entry)

public deftype ProductionSet
public defmulti get (t:ProductionSet, id:Int) -> True|False
public defmulti add (t:ProductionSet, id:Int) -> True|False
public defmulti clear (t:ProductionSet) -> False

public defn ProductionSet (num-productions:Int) :
  val keys = Array<True|False>(num-productions, false)
  new ProductionSet :
    defmethod get (this, id:Int) :
      keys[id]
    defmethod add (this, id:Int) :
      val added = not keys[id]
      keys[id] = true
      added
    defmethod clear (this) :
      for i in 0 to num-productions do :
        keys[i] = false

public deftype CompletionSet
public defmulti add (s:CompletionSet, item:EItem) -> True|False
public defmulti get (s:CompletionSet, item:EItem) -> True|False
public defmulti clear (s:CompletionSet) -> False

public defn CompletionSet () :
  val keys = HashSet<EItemCore>()
  new CompletionSet :
    defmethod add (this, item:EItem) :
      add(keys, core(item))
    defmethod get (this, item:EItem) :
      keys[core(item)]
    defmethod clear (this) :
      clear(keys)

;============================================================
;======================== EItem =============================
;============================================================

;Represents an item in an earley set.
;matched-wildcard? is true if the rule has matched against any inserted wildcards.
public defstruct EItem :
  rule:GTokenRule
  num-parsed:Int
  parent:Int
  matched-wildcard?:True|False
  ends:Array<List<Int>> with: (default => empty-ends(rule))
  completion-root:CompletionRoot with: (init => NoCompletion(), setter => set-completion-root)  
with:
  printer => true

public deftype CompletionRoot
public defstruct NoCompletion <: CompletionRoot
public defstruct ChainRoot <: CompletionRoot
public defstruct ChainLink <: CompletionRoot :
  root: EItem
  link: EItem
public defstruct ChainCompletion <: CompletionRoot :
  items: List<EItem>

defn empty-ends (rule:GTokenRule) :
  val num-tokens = length(tokens(rule))
  Array<List<Int>>(max(num-tokens - 1, 0), List())

public defn add-chain-completion (item:EItem, completion:EItem) :
  val completion-root* = match(completion-root(item)) :
    (r:ChainCompletion) : ChainCompletion(cons(completion, items(r)))
    (r:NoCompletion) : ChainCompletion(List(completion))
  set-completion-root(item, completion-root*)

public defn rule-id (item:EItem) :
  id(rule(item))

public defn inc-num-parsed (x:EItem, wildcard?:True|False) :
  EItem(rule(x), num-parsed(x) + 1, parent(x), matched-wildcard?(x) or wildcard?, ends(x))

public defn upcoming (item:EItem) -> GToken|False :
  val ts = tokens(rule(item))
  val i = num-parsed(item)
  ts[i] when i < length(ts)

public defn previous (item:EItem) -> GToken|False :
  val ts = tokens(rule(item))
  val i = num-parsed(item)
  ts[i - 1] when i > 0
  
public defn production (item:EItem) -> Int :
  prod(rule(item))

public defn format (grammar:Grammar, e:EItem) :
  format(grammar, e, true)

public defn format (grammar:Grammar, e:EItem, show-completion?:True|False) :
  within o = Printable() :
    val r = rule(e)
    print(o, "(rule %_) [%_ =" % [rule-id(e), format(grammar, GProduction(prod(r)))])
    for (t in tokens(r), i in 0 to false) do :
      val prefix = " • " when num-parsed(e) == i else " "
      print-all(o, [prefix, format(grammar,t)])
    if num-parsed(e) == length(tokens(r)) :
      print(o, " •")
    print(o, ", S%_]" % [parent(e)])
    if matched-wildcard?(e) :
      print(o, " (matched wildcard)")
    if show-completion? and completion-root(e) is-not NoCompletion :
      print(o, " %_" % [format(grammar, completion-root(e))])

public defn format (grammar:Grammar, r:CompletionRoot) :
  match(r) :
    (r:NoCompletion) : "(no completion)"
    (r:ChainRoot) : "(completion root)"
    (r:ChainLink) : "(completion root = %_, link = %_)" % [format(grammar,root(r),false), format(grammar,link(r),false)]
    (r:ChainCompletion) : "(completion starts = %,)" % [seq(format{grammar,_,false}, items(r))]

public defn format (grammar:Grammar, setlist:ESetList) :
  within o = Printable() :
    val o2 = IndentedStream(o)
    for eset in sets(setlist) do :
      print(o, "\n") when index(eset) > 0
      print(o, "Set %_:" % [index(eset)])
      do(lnprint{o2, format(grammar,_)}, items(setlist,eset))

defn Printable (f:OutputStream -> ?) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      f(o)

;============================================================
;===================== EItemCore ============================
;============================================================

public defstruct EItemCore <: Hashable&Equalable :
  rule: Int
  num-parsed: Int
  parent: Int

public defn core (item:EItem) :
  EItemCore(rule-id(item), num-parsed(item), parent(item))

defn parts (k:EItemCore) : [rule(k), num-parsed(k), parent(k)]
defmethod equal? (a:EItemCore, b:EItemCore) : parts(a) == parts(b)
defmethod hash (k:EItemCore) : hash(parts(k))
  
;============================================================
;======================== ESetList ==========================
;============================================================

public deftype ESetList
public defmulti add (l:ESetList, items:Seqable<EItem>) -> False
public defmulti clear-markers (l:ESetList) -> False
public defmulti items (return:EItem -> ?, l:ESetList, index:Int, production:Int, mark?:True|False) -> False
public defmulti first-item (l:ESetList, index:Int, production:Int) -> EItem|False
public defmulti sets (l:ESetList) -> Collection<EItemSet>
public defmulti get (l:ESetList, i:Int) -> EItemSet
public defmulti items (l:ESetList, s:EItemSet) -> Collection<EItem>
public defmulti length (l:ESetList) -> Int

public defstruct EItemSet :
  index: Int
  start: Int
  length: Int
  
;============================================================
;====================== Algorithm2 ==========================
;============================================================


public defn ESetList () :
  val items = Vector<EItem>()
  val markers = Vector<Int>()
  val sets = Vector<EItemSet>()
  val buffer = Vector<EItem>()
  var current-marker:Int = 1

  defn upcoming? (item:EItem) :
    match(upcoming(item)) :
      (g:GToken) : One(g)
      (g:False) : None()

  defn productions (return:EItem -> ?, start:Int, end:Int, production:Int) :
    val prod = One(GProduction(production))
    let loop (i:Int = start) :
      if i < end :
        val item = items[i]
        if upcoming?(item) == prod :
          return(item)
          loop(i + 1)

  new ESetList :
    defmethod length (this) :
      length(sets)
    defmethod add (this, new-items:Seqable<EItem>) :
      ;Add new items to item list.
      val item-start = length(items)
      add-all(buffer, new-items)
      qsort!({upcoming?(_) as Comparable}, buffer)
      add-all(items, buffer)
      clear(buffer)
      val item-len = length(items) - item-start
      ;Set new markers
      lengthen(markers, length(items), 0)
      ;Add new set
      add(sets, EItemSet(length(sets), item-start, item-len))
    defmethod items (return:EItem -> ?, this, index:Int, production:Int, mark?:True|False) :
      val eset = sets[index]
      val i = bsearch(upcoming?, items, start(eset), start(eset) + length(eset), One(GProduction(production)))
      match(i:Int) :
        if mark? :
          if markers[i] != current-marker :
            productions(return, i, start(eset) + length(eset), production)
            markers[i] = current-marker
        else :
          productions(return, i, start(eset) + length(eset), production)
    defmethod first-item (this, index:Int, production:Int) :
      val eset = sets[index]
      val i = bsearch(upcoming?, items, start(eset), start(eset) + length(eset), One(GProduction(production)))
      match(i:Int) : items[i]
    defmethod clear-markers (this) :
      current-marker = current-marker + 1
    defmethod sets (this) :
      sets
    defmethod get (this, i:Int) :
      sets[i]
    defmethod items (this, eset:EItemSet) :
      within to-collection() :
        val s = start(eset)
        for i in 0 to length(eset) seq :
          items[s + i]

;============================================================
;======================= Utilities ==========================
;============================================================

;Binary search:
;It returns i such that all items at index < i satisfy key(xs[i]) < v.
defn bsearch<?T> (key:T -> Comparable, xs:Vector<?T>, start:Int, end:Int, v:Comparable) -> Int|False :
  bsearch(xs, start, end, compare{key(_), v})

defn bsearch<?T> (xs:Vector<?T>, start:Int, end:Int, compare:T -> Int) -> Int|False :
  ;All items with index less than i are known to return -1 for compare.
  ;All items with index greater than j are known to return 0/1 for compare.
  let loop (i:Int = start, j:Int = end) :
    if i == j :
      i when i < end and compare(xs[i]) == 0
    else :
      val m = (i + j) / 2
      if compare(xs[m]) < 0 : loop(m + 1, j)
      else : loop(i, m)

defn bsearch<?T> (xs:Vector<?T>, compare:T -> Int) -> Int|False :
  bsearch(xs, 0, length(xs), compare)
