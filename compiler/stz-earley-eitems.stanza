defpackage stz/earley-eitems :
  import core
  import collections
  import stz/earley
  import stz/earley-grammar

;============================================================
;======================== EItem =============================
;============================================================

public defstruct EItem :
  rule:Int
  num-parsed:Int
  parent:Int
  matched-wildcard?:True|False
  passed-guard?:True|False with: (default => true, updater => sub-passed-guard?)
  completion-root:EItem|False with: (init => false, updater => sub-completion-root)  

public defn inc-num-parsed (x:EItem, wildcard?:True|False) :
  EItem(rule(x), num-parsed(x) + 1, parent(x), matched-wildcard?(x) or wildcard?)

public defn dec-num-parsed (x:EItem, wildcard?:True|False) :
  EItem(rule(x), num-parsed(x) - 1, parent(x), matched-wildcard?(x) or wildcard?)

public defn upcoming (grammar:Grammar, item:EItem) -> GToken|False :
  val ts = tokens!(grammar[rule(item)])
  val i = num-parsed(item)
  ts[i] when i < length(ts)

public defn previous (grammar:Grammar, item:EItem) -> GToken|False :
  val ts = tokens!(grammar[rule(item)])
  val i = num-parsed(item)
  ts[i - 1] when i > 0
  
public defn production (grammar:Grammar, item:EItem) -> Symbol :
  name(grammar[rule(item)])

defn Printable (f:OutputStream -> ?) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      f(o)

public defn format (grammar:Grammar, e:EItem) :
  within o = Printable() :
    val r = grammar[rule(e)]
    print(o, "(rule %_) [%_ =" % [rule(e), name(r)])
    for (t in tokens!(r), i in 0 to false) do :
      val prefix = " • " when num-parsed(e) == i else " "
      print-all(o, [prefix, t])
    if num-parsed(e) == length(tokens!(r)) :
      print(o, " •")
    print(o, ", S%_]" % [parent(e)])
    if matched-wildcard?(e) :
      print(o, " (matched wildcard)")
    if r is GMatcherRule :
      print(o, " (custom matcher)")
    if not passed-guard?(e) :
      print(o, " (unmatched)")
    if completion-root(e) is EItem :
      val msg = format(grammar, completion-root(e) as EItem)
      print(o, " (complete as %_)" % [msg])

public defn format (grammar:Grammar, setlist:ESetList) :
  within o = Printable() :
    val o2 = IndentedStream(o)
    for eset in sets(setlist) do :
      print(o, "\n") when index(eset) > 0
      print(o, "Set %_:" % [index(eset)])
      do(lnprint{o2, format(grammar,_)}, items(setlist,eset))
  
;============================================================
;======================== ESetList ==========================
;============================================================

public deftype ESetList
public defmulti add (l:ESetList, items:Seqable<EItem>) -> False
public defmulti clear-markers (l:ESetList) -> False
public defmulti items (return:EItem -> ?, l:ESetList, index:Int, production:Symbol, mark?:True|False) -> False
public defmulti first-item (l:ESetList, index:Int, production:Symbol) -> EItem|False
public defmulti sets (l:ESetList) -> Collection<EItemSet>
public defmulti get (l:ESetList, i:Int) -> EItemSet
public defmulti items (l:ESetList, s:EItemSet) -> Collection<EItem>
public defmulti length (l:ESetList) -> Int

public defstruct EItemSet :
  index: Int
  start: Int
  length: Int

public defn ESetList (grammar:Grammar) :
  println("[TODO] Remove this function")
  ESetList(upcoming{grammar,_})

;Binary search:
;It returns i such that all items at index < i satisfy key(xs[i]) < v.
defn bsearch<?T> (key:T -> Comparable, xs:Vector<?T>, start:Int, end:Int, v:Comparable) -> Int|False :
  bsearch(xs, start, end, compare{key(_), v})

defn bsearch<?T> (xs:Vector<?T>, start:Int, end:Int, compare:T -> Int) -> Int|False :
  ;All items with index less than i are known to return -1 for compare.
  ;All items with index greater than j are known to return 0/1 for compare.
  let loop (i:Int = start, j:Int = end) :
    if i == j :
      i when i < end and compare(xs[i]) == 0
    else :
      val m = (i + j) / 2
      if compare(xs[m]) < 0 : loop(m + 1, j)
      else : loop(i, m)

defn bsearch<?T> (xs:Vector<?T>, compare:T -> Int) -> Int|False :
  bsearch(xs, 0, length(xs), compare)

;============================================================
;====================== Algorithm2 ==========================
;============================================================

public defn ESetList (next-token:EItem -> GToken|False) :
  val items = Vector<EItem>()
  val markers = Vector<Int>()
  val sets = Vector<EItemSet>()
  val buffer = Vector<EItem>()
  var current-marker:Int = 1

  defn upcoming? (item:EItem) :
    match(next-token(item)) :
      (g:GToken) : One(g)
      (g:False) : None()

  defn productions (return:EItem -> ?, start:Int, end:Int, production:Symbol) :
    val prod = One(GProduction(production))
    let loop (i:Int = start) :
      if i < end :
        val item = items[i]
        if upcoming?(item) == prod :
          return(item)
          loop(i + 1)

  new ESetList :
    defmethod length (this) :
      length(sets)
    defmethod add (this, new-items:Seqable<EItem>) :
      add-all(buffer, new-items)
      qsort!({upcoming?(_) as Comparable}, buffer)
      add(sets, EItemSet(length(sets), length(items), length(buffer)))
      add-all(items, buffer)
      lengthen(markers, length(items), 0)
      clear(buffer)
    defmethod items (return:EItem -> ?, this, index:Int, production:Symbol, mark?:True|False) :
      val eset = sets[index]
      val i = bsearch(upcoming?, items, start(eset), start(eset) + length(eset), One(GProduction(production)))
      match(i:Int) :
        if mark? :
          if markers[i] != current-marker :
            productions(return, i, start(eset) + length(eset), production)
            markers[i] = current-marker
        else :
          productions(return, i, start(eset) + length(eset), production)
    defmethod first-item (this, index:Int, production:Symbol) :
      val eset = sets[index]
      val i = bsearch(upcoming?, items, start(eset), start(eset) + length(eset), One(GProduction(production)))
      match(i:Int) : items[i]
    defmethod clear-markers (this) :
      current-marker = current-marker + 1
    defmethod sets (this) :
      sets
    defmethod get (this, i:Int) :
      sets[i]
    defmethod items (this, eset:EItemSet) :
      within to-collection() :
        val s = start(eset)
        for i in 0 to length(eset) seq :
          items[s + i]