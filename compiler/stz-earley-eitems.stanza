defpackage stz/earley-eitems :
  import core
  import collections
  import stz/earley-grammar
  import stz/tree-list

protected val MAIN-TIMER = MillisecondTimer("MAIN TIMER")
protected val FACTORED-TIMER = MillisecondTimer("FACTORED STARTS")

;============================================================
;============== ProductionTable/ProductionSet ===============
;============================================================

public deftype ProductionTable<T> <: Collection<KeyValue<Int,T>>
public defmulti get<?T> (t:ProductionTable<?T>, id:Int) -> T
public defmulti set<?T> (t:ProductionTable<?T>, id:Int, v:T) -> False
public defmulti clear (t:ProductionTable) -> False
public defmulti key? (t:ProductionTable, id:Int) -> True|False

public defn ProductionTable<T> (num-productions:Int, default:T) :
  val table = Array<T>(num-productions,default)
  val occupied = Array<True|False>(num-productions,false)
  new ProductionTable<T> :
    defmethod get (this, id:Int) :
      table[id]
    defmethod set (this, id:Int, v:T) :
      table[id] = v
      occupied[id] = true
    defmethod clear (this) :
      for i in 0 to num-productions do :
        table[i] = default
        occupied[i] = false
    defmethod to-seq (this) :
      for i in 0 to num-productions seq? :
        if occupied[i] : One(i => table[i])
        else : None()
    defmethod key? (this, id:Int) :
      occupied[id]

public defn add<?T> (t:ProductionTable<List<?T>>, id:Int, x:T) :
  t[id] = cons(x, t[id])

public defn map!<?T> (f:KeyValue<Int,T> -> T, table:ProductionTable<?T>) :
  for entry in table do :
    table[key(entry)] = f(entry)

public deftype ProductionSet
public defmulti get (t:ProductionSet, id:Int) -> True|False
public defmulti add (t:ProductionSet, id:Int) -> True|False
public defmulti clear (t:ProductionSet) -> False

public defn ProductionSet (num-productions:Int) :
  val keys = Array<True|False>(num-productions, false)
  new ProductionSet :
    defmethod get (this, id:Int) :
      keys[id]
    defmethod add (this, id:Int) :
      val added = not keys[id]
      keys[id] = true
      added
    defmethod clear (this) :
      for i in 0 to num-productions do :
        keys[i] = false

public deftype CompletionSet
public defmulti add (s:CompletionSet, item:EItem) -> True|False
public defmulti get (s:CompletionSet, item:EItem) -> True|False
public defmulti clear (s:CompletionSet) -> False

public defn CompletionSet () :
  val keys = HashSet<EItemCore>()
  new CompletionSet :
    defmethod add (this, item:EItem) :
      add(keys, core(item))
    defmethod get (this, item:EItem) :
      keys[core(item)]
    defmethod clear (this) :
      clear(keys)

;============================================================
;======================== EItem =============================
;============================================================

;Represents an item in an earley set.
;matched-wildcard? is true if the rule has matched against any inserted wildcards.
public defstruct EItem :
  rule:GTokenRule
  num-parsed:Int
  parent:Int
  matched-wildcard?:True|False
  ends:Array<TreeList>
  completion-root:CompletionRoot with: (init => NoCompletion(), setter => set-completion-root)  
with:
  printer => true

public deftype CompletionRoot
public defstruct NoCompletion <: CompletionRoot
public defstruct ChainRoot <: CompletionRoot
public defstruct ChainLink <: CompletionRoot :
  root: EItem
  link: EItem
public defstruct ChainCompletion <: CompletionRoot :
  items: List<EItem>

public defn add-chain-completion (item:EItem, completion:EItem) :
  val completion-root* = match(completion-root(item)) :
    (r:ChainCompletion) : ChainCompletion(cons(completion, items(r)))
    (r:NoCompletion) : ChainCompletion(List(completion))
  set-completion-root(item, completion-root*)

public defn rule-id (item:EItem) :
  id(rule(item))

public defn inc-num-parsed (x:EItem, wildcard?:True|False) :
  EItem(rule(x), num-parsed(x) + 1, parent(x), matched-wildcard?(x) or wildcard?, ends(x))

public defn upcoming (item:EItem) -> GToken|False :
  val ts = tokens(rule(item))
  val i = num-parsed(item)
  ts[i] when i < length(ts)

public defn previous (item:EItem) -> GToken|False :
  val ts = tokens(rule(item))
  val i = num-parsed(item)
  ts[i - 1] when i > 0
  
public defn production (item:EItem) -> Int :
  prod(rule(item))

public defn format (grammar:Grammar, e:EItem) :
  format(grammar, e, true)

public defn format (grammar:Grammar, e:EItem, show-completion?:True|False) :
  within o = Printable() :
    val r = rule(e)
    print(o, "(rule %_) [%_ =" % [rule-id(e), format(grammar, GProduction(prod(r)))])
    for (t in tokens(r), i in 0 to false) do :
      val prefix = " • " when num-parsed(e) == i else " "
      print-all(o, [prefix, format(grammar,t)])
    if num-parsed(e) == length(tokens(r)) :
      print(o, " •")
    print(o, ", S%_]" % [parent(e)])
    if matched-wildcard?(e) :
      print(o, " (matched wildcard)")
    if show-completion? and completion-root(e) is-not NoCompletion :
      print(o, " %_" % [format(grammar, completion-root(e))])

public defn format (grammar:Grammar, r:CompletionRoot) :
  match(r) :
    (r:NoCompletion) : "(no completion)"
    (r:ChainRoot) : "(completion root)"
    (r:ChainLink) : "(completion root = %_, link = %_)" % [format(grammar,root(r),false), format(grammar,link(r),false)]
    (r:ChainCompletion) : "(completion starts = %,)" % [seq(format{grammar,_,false}, items(r))]

defn Printable (f:OutputStream -> ?) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      f(o)

;============================================================
;===================== EItemCore ============================
;============================================================

public defstruct EItemCore <: Hashable&Equalable :
  rule: Int
  num-parsed: Int
  parent: Int

public defn core (item:EItem) :
  EItemCore(rule-id(item), num-parsed(item), parent(item))

defn parts (k:EItemCore) : [rule(k), num-parsed(k), parent(k)]
defmethod equal? (a:EItemCore, b:EItemCore) : parts(a) == parts(b)
defmethod hash (k:EItemCore) : hash(parts(k))
  
;============================================================
;======================== ESetList ==========================
;============================================================

public deftype ESetList
public defmulti add (l:ESetList, items:Seqable<EItem>) -> False
public defmulti items (return:EItem -> ?, l:ESetList, index:Int, production:Int) -> False
public defmulti first-item (l:ESetList, index:Int, production:Int) -> EItem
  
public defn ESetList () :
  val items = Vector<EItem>()
  val sets = Vector<EItemSet>()
  val buffer = Vector<EItem>()

  defn upcoming? (item:EItem) :
    match(upcoming(item)) :
      (g:GToken) : One(g)
      (g:False) : None()

  defn productions (return:EItem -> ?, start:Int, end:Int, production:Int) :
    val prod = One(GProduction(production))
    let loop (i:Int = start) :
      if i < end :
        val item = items[i]
        if upcoming?(item) == prod :
          return(item)
          loop(i + 1)

  new ESetList :
    defmethod add (this, new-items:Seqable<EItem>) :
      ;Add new items to item list.
      val item-start = length(items)
      add-all(buffer, new-items)
      qsort!({upcoming?(_) as Comparable}, buffer)
      add-all(items, buffer)
      clear(buffer)
      val item-len = length(items) - item-start
      ;Add new set
      add(sets, EItemSet(length(sets), item-start, item-len))
    defmethod items (return:EItem -> ?, this, index:Int, production:Int) :
      val eset = sets[index]
      val i = bsearch(upcoming?, items, start(eset), start(eset) + length(eset), One(GProduction(production)))
      match(i:Int) :
        productions(return, i, start(eset) + length(eset), production)
    defmethod first-item (this, index:Int, production:Int) :
      val eset = sets[index]
      val i = bsearch(upcoming?, items, start(eset), start(eset) + length(eset), One(GProduction(production)))
      items[i as Int]

defstruct EItemSet :
  index: Int
  start: Int
  length: Int

;============================================================
;============ List for Holding Completed Items ==============
;============================================================

public deftype ECompletionList
public defmulti items? (l:ECompletionList, prod:Int, start:Int, end:Int) -> True|False
public defmulti items (l:ECompletionList, prod:Int, start:Int, end:Int) -> List<EItem>
public defmulti items (l:ECompletionList, prod:Int, end:Int) -> List<EItem>
public defmulti add (l:ECompletionList, end:Int, items:Seqable<EItem>) -> False

public defn ECompletionList () :
  val itemlist = Vector<Tuple<EItem>>()
  val buffer = Vector<EItem>()
  defn ensure-length (v:Vector<Tuple>, len:Int) :
    lengthen(v, len, []) when length(v) < len
  new ECompletionList :
    defmethod add (this, end:Int, items:Seqable<EItem>) :
      ensure-length(itemlist, end + 1)
      add-all(buffer, itemlist[end])
      add-all(buffer, items)
      qsort!(buffer, compare-completion)      
      itemlist[end] = to-tuple(buffer)
      clear(buffer)
    defmethod items? (this, prod:Int, start:Int, end:Int) :
      val items = itemlist[end]
      if not empty?(items) :
        bsearch(items, compare-completion{_, prod, start}) is Int
    defmethod items (this, prod:Int, start:Int, end:Int) :
      val items = itemlist[end]
      val index = bsearch(items, compare-completion{_, prod, start}) as Int
      let loop (i:Int = index) :
        if i < length(items) :
          val item = items[i]
          if compare-completion(item, prod, start) == 0 : cons(item, loop(i + 1))
          else : List()
        else : List()
    defmethod items (this, prod:Int, end:Int) :
      val items = itemlist[end]
      val index = bsearch(items, compare-completion{_, prod}) as Int
      let loop (i:Int = index) :
        if i < length(items) :
          val item = items[i]
          if compare-completion(item, prod) == 0 : cons(item, loop(i + 1))
          else : List()
        else : List()
    defmethod print (o:OutputStream, this) :
      val o2 = IndentedStream(o)
      for end in 0 to length(itemlist) do :
        println(o, "\n") when end > 0
        println(o, "Ending at %_ :" % [end])
        do(lnprint{o2, _}, itemlist[end])

defn compare-completion (a:EItem, prod:Int, start:Int) -> Int :
  val cp = compare(/prod(rule(a)), prod)
  if cp == 0 : compare(parent(a), start)
  else : cp      

defn compare-completion (a:EItem, prod:Int) -> Int :
  compare(/prod(rule(a)), prod)

defn compare-completion (a:EItem, b:EItem) -> Int :
  compare-completion(a, prod(rule(b)), parent(b))  

;============================================================
;======================= Utilities ==========================
;============================================================

#for Coll in [Vector, Tuple] :
  ;Binary search:
  ;It returns i such that all items at index < i satisfy key(xs[i]) < v.
  defn bsearch<?T> (key:T -> Comparable, xs:Coll<?T>, start:Int, end:Int, v:Comparable) -> Int|False :
    bsearch(xs, start, end, compare{key(_), v})

  defn bsearch<?T> (xs:Coll<?T>, start:Int, end:Int, compare:T -> Int) -> Int|False :
    ;All items with index less than i are known to return -1 for compare.
    ;All items with index greater or equal to j are known to return 0/1 for compare.
    let loop (i:Int = start, j:Int = end) :
      if i == j :
        i when i < end and compare(xs[i]) == 0
      else :
        val m = (i + j) / 2
        if compare(xs[m]) < 0 : loop(m + 1, j)
        else : loop(i, m)

  defn bsearch<?T> (xs:Coll<?T>, compare:T -> Int) -> Int|False :
    bsearch(xs, 0, length(xs), compare)
