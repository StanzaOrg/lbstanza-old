defpackage stz/vm-encoder :
  import core
  import collections
  import stz/vm-ir
  import stz/typeset
  import stz/vm-ids
  import stz/basic-ops
  import stz/call-records
  import stz/backend
  import stz/utils
  import stz/set-utils
  import stz/conversion-utils
  import stz/dispatch-dag

public deftype EncodingResolver
public defmulti liveness-map (r:EncodingResolver, live:Tuple<Int>, num-locals:Int) -> Int
public defmulti object-header-size (r:EncodingResolver) -> Int
public defmulti object-size-on-heap (r:EncodingResolver, sz:Int) -> Int
public defmulti stack-size (r:EncodingResolver) -> Int
public defmulti dispatch-format (r:EncodingResolver, branches:Tuple<Tuple<TypeSet>>) -> Int
public defmulti match-format (r:EncodingResolver, branches:Tuple<Tuple<TypeSet>>) -> Int
public defmulti method-format (r:EncodingResolver, multi:Int, num-header-args:Int, num-args:Int) -> Int
public defmulti marker (r:EncodingResolver, type:Int) -> Int
public defmulti void-marker (r:EncodingResolver) -> Int
public defmulti ref-offset (r:EncodingResolver) -> Int
public defmulti type-is-final? (r:EncodingResolver, n:Int) -> True|False
public defmulti marker? (r:EncodingResolver, n:Int) -> True|False
public defmulti tagbits (r:EncodingResolver, typeid:Int) -> Int

public defstruct EncodedFunction :
  buffer: ByteBuffer
  fileinfos: Vector<FileInfoEntry>

public defstruct FileInfoEntry :
  pc: Int
  fileinfo: FileInfo
  
public defn encode (func:VMFunction,
                    resolver:EncodingResolver,
                    backend:Backend) -> EncodedFunction :
  ;Encode instructions into this byte buffer
  val buffer = ByteBuffer()
  defn buffer-pos () : write-position(buffer) / 4

  ;Accumulate file information entries for implementing
  ;stack traces.
  val fileinfo-table = Vector<FileInfoEntry>()
  defn record-info (info:FileInfo|False) :
    match(info:FileInfo) :
      add(fileinfo-table, FileInfoEntry(buffer-pos(), info))

  ;Delay the generation of this instruction,
  ;Instruction takes up the given number of 'instruction-words'.
  defn delayed-ins (f:() -> ?, instruction-words:Int) :
    val h = write-position(buffer)
    for i in 0 to instruction-words do :
      put(buffer, -1)
    within delay() :
      val h0 = write-position(buffer)
      set-write-position(buffer, h)
      f()
      val written = write-position(buffer) - h
      val expected = instruction-words * 4
      fatal("Incorrect size.") when written != expected
      set-write-position(buffer, h0)

  ;Instruction formats:
  ;A: [OPCODE | VALUE]
  ;   [  8    |  24  ]
  ;B: [OPCODE | X  | VALUE]
  ;   [  8    | 10 |  14  ]
  ;C: [OPCODE | X  | Y  | VALUE]
  ;   [  8    | 14 | 10 |   32 ]
  ;D: [OPCODE | _  | X ] + VALUE
  ;   [  8    | 14 | 10] +   64
  ;E: [OPCODE | X  | Y  |   Z   | CONST ]
  ;   [  8    | 10 | 10 | 4 + 6 |   26  ]
  ;F: [OPCODE | X  | Y  |    N1  | N2]
  ;   [  8    | 10 | 10 | 4 + 14 | 18]
  defn ten-bits! (x:Int) :
    fatal("Local out of range: %_" % [x]) when x < 0 or x >= 1024
  defn emit-ins-a (opcode:Int, value:Int) :
    ;println("%_) A: [%_ | %_]" % [write-position(buffer), opcode, value])    
    put(buffer, opcode | (value << 8))
  defn emit-ins-b (opcode:Int, x:Int, value:Int) :
    ten-bits!(x)
    ;println("%_) B: [%_ | %_ | %_]" % [write-position(buffer), opcode, x, value])
    put(buffer, opcode | (x << 8) | (value << 18))
  defn emit-ins-c (opcode:Int, x:Int, value:Int) :
    ten-bits!(x)
    ;println("%_) C: [%_ | _ | %_ | %_]" % [write-position(buffer), opcode, x, value])
    put(buffer, opcode | (x << 22))
    put(buffer, value)
  defn emit-ins-c (opcode:Int, x:Int, y:Int, value:Int) :
    ten-bits!(x)
    ten-bits!(y)
    ;println("%_) C: [%_ | %_ | %_ | %_]" % [write-position(buffer), opcode, x, y, value])
    put(buffer, opcode | (x << 8) | (y << 22))
    put(buffer, value)    
  defn emit-ins-d (opcode:Int, x:Int, value:Long) :
    ten-bits!(x)
    ;println("%_) D: [%_ | _ | %_] + %~" % [write-position(buffer), opcode, x, value])
    put(buffer, opcode | (x << 22))
    put(buffer, value)
  defn emit-ins-e (opcode:Int, x:Int, y:Int, z:Int, const:Int) :
    ten-bits!(x)
    ten-bits!(y)
    ten-bits!(z)
    ;println("%_) E: [%_ | %_ | %_ | %_ | %_]" % [write-position(buffer), opcode, x, y, z, const])
    put(buffer, opcode | (x << 8) | (y << 18) | (z << 28))
    put(buffer, (z >> 4) | (const << 6))
  defn emit-ins-f (opcode:Int, x:Int, y:Int, n1:Int, n2:Int) :
    ten-bits!(x)
    ten-bits!(y)
    ;println("%_) F: [%_ | %_ | %_ | %_ | %_]" % [write-position(buffer), opcode, x, y, n1, n2])
    put(buffer, opcode | (x << 8) | (y << 18) | (n1 << 28))
    put(buffer, ((n1 & 0x3FFFF) >> 4) | (n2 << 14))
  defn emit-ins-targets (dests:Tuple<Int>) :
    put(buffer, length(dests))
    for d in dests do : put(buffer, d)

  ;Calculation of sizes
  defn object-size (num-obj:Int, size-on-heap:Int) :
    num-obj * object-header-size(resolver) + size-on-heap
  defn stack-size () :
    object-size(1, /stack-size(resolver))

  ;Split a tuple of VMBranch into typesets and destinations
  defn split-types-and-dests (bs:Tuple<VMBranch>) -> [Tuple<Tuple<TypeSet>>, Tuple<Int>] :
    val types = map(types, bs)
    val targets = map(n, bs)
    [types, targets]

  ;Check whether type is final.
  ;If the function returns true, it means that the type cannot be redefined.
  defn type-is-final? (t:TypeSet) :
    match(t) :
      (t:SingleType) : /type-is-final?(resolver, type(t))
      (t:OrType) : all?(type-is-final?, types(t))
      (t:AndType) : any?(type-is-final?, types(t))
      (t:TopType) : true

  ;Convert a TypeSet to an ISet assuming that the TypeSet represents a final type.
  ;defn final-iset (t:TypeSet) :
  ;  match(t) :
  ;    (t:SingleType) : ISubset([type(t)])
  ;    (t:OrType) : reduce(union, seq(final-iset, types(t)))
  ;    (t:AndType) : final-iset(find!(type-is-final?, types(t)))
  ;    (t:TopType) : IAll()

  ;Check whether all types in branch are final.
  defn branch-is-final? (b:VMBranch) :
    all?(type-is-final?, types(b))

  ;Encode multivarity functions
  defn encode (multi:VMMultifn) :
    ;Declare function positions
    var func-positions
    ;Emit branch instructions
    for (entry in funcs(multi), i in 0 to false) do :
      val arity = key(entry)      
      within delayed-ins(2) :
        val offset = func-positions[i] - buffer-pos()
        emit-ins-c(JUMP-REG-OPCODE, arg(multi), arity, offset)
    ;Emit default branch
    encode(default(multi))
    ;Emit other branches, and compute their positions
    func-positions = for entry in funcs(multi) map :
      val fpos = buffer-pos()
      encode(value(entry))
      fpos

  ;<doc>===================================
  ;========= Encoding a Function ==========
  # Fundamental State #
  
  max-local: Int

    The index of the highest local in this function frame.

  num-locals: Int

    The total number of locals in this function frame, including
    temporary locals needed to satisfy shuffling.
    
  deftable: IntTable<VMDef>

    The mapping from Local identifiers to their definitions.

  label-table: IntTable<Int>

    The mapping from LabelIns identifiers to their buffer position.
    This table is filled during the first pass of the compilation, and
    can only be used after that.
 
  used-labels: IntSet

    The set of all labels used by the given input function. Used
    during generation of new unique labels.

  label-counter: Seq<Int>

    The counter used to generate new unique labels.

  # Immediate Utilities #

  imm-type (x:VMImm) -> VMType
  imm-type (x:VMType) -> VMType
  
    Returns the VMType corresponding to an immediate. Works trivially
    on VMType as well for convenience when dealing with missing
    arguments.

  slot (x:Local) -> Int

    Returns the frame slot in which the given Local is stored.

  # Label Utilities #

  jump-offset (n:Int) -> Int
  
    Returns the offset, relative to the current buffer position, of
    the given label.

  jump-offsets (xs:Seqable<Int>) -> Tuple<Int>
  jump-offsets (xs:Seqable<Int>, ys:Seqable<Int>) -> Tuple<Int>

    Returns all offsets, as a tuple, of the given labels relative to
    the current buffer position.

  gen-label () -> Int
  
    Returns a new unique label.

  ;========================================
  ;===================================<doc>

  ;Encode function instructions
  defn encode (func:VMFunc) :
    ;==================================================
    ;============== Fundamental State =================
    ;==================================================
    ;Reserve extra 3 locals for temporary moving
    val max-local = maximum(-1, seq(local, defs(func)))
    val num-locals = max-local + 1 + 3

    ;Definitions
    val deftable = to-inttable(id, defs(func))
    
    ;Labels
    val label-table = IntTable<Int>()
    val used-labels = to-intset(seq(n, filter-by<LabelIns>(ins(func))))
    val label-counter = to-seq(0 to false)

    ;==================================================
    ;============== Overall Algorithm =================
    ;==================================================
    defn driver () :
      emit-prelude()
      do(emit-ins, ins(func))

    ;Enter a function
    defn emit-prelude () :
      ;Enter function
      emit-ins-a(FNENTRY-OPCODE, num-locals)
      ;Retrieve arguments
      get-regs(args(func))

    ;Encode a match statement that can be redefined later.
    defn emit-non-final-match (ys:Tuple<VMImm>, bs:Tuple<VMBranch>, default:Int) :
      ;Retrieve the format index of this match statement.
      val [types, dests] = split-types-and-dests(bs)
      val format = match-format(resolver, types)
      
      ;Push arguments onto registers
      set-regs(ys)

      ;One target for default and then each branch for dispatch.
      val num-targets = 1 + length(bs)
      within delayed-ins(1 + 1 + num-targets) :
        val targets = jump-offsets([default], dests)
        emit-ins-a(DISPATCH-OPCODE, format)            
        emit-ins-targets(targets)    

    ;Encode a match statement that cannot be redefined later.
    defn emit-final-match (ys:Tuple<VMImm>, bs:Tuple<VMBranch>, default-label:Int) :      
      defn compute-dag () :
        val branch-table = BranchTable(to-branches(seq(types,bs), {[_]}))
        compute-dispatch-dag(branch-table, false)
        
      defn emit-dag (dag:Dag) :
        ;Create labels for all entries
        val labels = map(gen-label{}, entries(dag))
        ;Convert a value into a label
        defn to-label (x:Int|Soln) :
          match(x) :
            (x:Int) : labels[x]
            (x:UniqueSoln) : n(bs[index(x)])
            (x:NoSoln) : default-label
        ;Compile a given entry
        defn emit-entry (e:DagEntry) :
          if empty?(entries(e)) :
            emit-ins(GotoIns(to-label(default(e))))
          else :
            within (entry, last?) = expanded-entries(e) :
              val n1 = to-label(value(entry))
              val n2 = to-label(default(e)) when last? else gen-label()
              emit-ins(Branch1Ins(n1, n2, InstanceofOp(SingleType(key(entry))), ys[depth(e)]))
              emit-ins(LabelIns(n2)) when not last?
        ;Compile all entries
        for (e in entries(dag), l in labels) do :
          emit-ins(LabelIns(l))
          emit-entry(e)

      ;Expand the given entries and compute whether it is the last entry
      defn expanded-entries (f:(KeyValue<Int,Int|Soln>, True|False) -> ?, e:DagEntry) :
        val es = for e in entries(e) seq-cat :
          for v in values(key(e)) seq :
            v => value(e)
        let loop () :
          val e = next(es)          
          f(e, empty?(es))
          loop() when not empty?(es)

      ;Launch
      emit-dag(compute-dag())

    ;Emit instanceof operation
    defn emit-instanceof (n1:Int, n2:Int, x:VMImm, type:TypeSet) :
      if (type is SingleType) and type-is-final?(type) :
        defn driver () :
          val tag = /type(type as SingleType)
          switch(tag) :
            BYTE-TYPE : compare-tag-bits(BYTE-TYPE)
            CHAR-TYPE : compare-tag-bits(CHAR-TYPE)
            INT-TYPE : compare-tag-bits(INT-TYPE)
            FLOAT-TYPE :  compare-tag-bits(FLOAT-TYPE)
            else :
              if marker?(resolver, tag) : compare-marker(tag)
              else : compare-tag-word(tag)
        defn compare-tag-bits (typeid:Int) :
          within delayed-ins(2 + words-for-to-local(x)) :
            val bits = tagbits(resolver,typeid)
            emit-ins-f(JUMP-TAGBITS-OPCODE, to-local(x,0), bits, jump-offset(n1), jump-offset(n2))
        defn compare-marker (typeid:Int) :
          emit-ins(Branch2Ins(n1, n2, EqOp(), x, Marker(typeid)))
        defn compare-tag-word (typeid:Int) :
          val tmp = max-local + 1
          set-local(tmp, NumConst(typeid))
          within delayed-ins(2 + words-for-to-local(x)) :
            emit-ins-f(JUMP-TAGWORD-OPCODE, to-local(x,0), tmp, jump-offset(n1), jump-offset(n2))
        driver()
      else :
        ;Retrieve format
        val format = match-format(resolver, [[type]])          
        ;Push argument into register
        set-reg(0, x)
        ;Emit dispatch instruction
        ;Two targets, match success and default
        val num-targets = 2
        within delayed-ins(1 + 1 + num-targets) :
          val targets = jump-offsets([n2, n1])
          emit-ins-a(DISPATCH-OPCODE, format)
          emit-ins-targets(targets)
    
    ;Encode each instruction
    defn emit-ins (ins:VMIns) :
      match(ins) :
        (ins:LabelIns) :
          label-table[n(ins)] = buffer-pos()
        (ins:UnreachableIns) :
          false
        (ins:TCallIns) :
          set-regs(ys(ins))
          emit-ins-c(tcall-opcode(f(ins)), 0, to-function-local(f(ins)))
        (ins:TCallClosureIns) :
          set-regs(ys(ins))
          emit-ins-a(TCALL-CLOSURE-OPCODE, to-local(f(ins), 0))
        (ins:CallIns) : 
          set-regs(ys(ins))
          emit-ins-c(call-opcode(f(ins)), num-locals, to-function-local(f(ins)))
          record-info(info(ins))
          emit-ins-a(POP-FRAME-OPCODE, num-locals)
          get-regs(xs(ins))
        (ins:CallClosureIns) : 
          set-regs(ys(ins))
          emit-ins-c(CALL-CLOSURE-OPCODE, num-locals, to-local(f(ins), 0))
          record-info(info(ins))
          emit-ins-a(POP-FRAME-OPCODE, num-locals)
          get-regs(xs(ins))
        (ins:CallCIns) :
          ;Convert a VMType into an ArgType for call-record analysis
          defn to-arg-type (t:VMType) :
            match(t) :
              (t:VMFloat|VMDouble) : RealArg()
              (t) : IntArg()
          ;Compute C calling convention
          val records = callc-records(ytypes, xtype, backend) where :
            val xtypes = map(to-arg-type, map(imm-type, xs(ins)))
            val ytypes = map(to-arg-type, map(imm-type, ys(ins)))
            val xtype = IntArg() when empty?(xtypes) else xtypes[0]
          ;Compute register locations
          val num-stack-args-index = 0
          val num-fargs-index = 1 + num-mem-args(records)
          val num-args-index = num-fargs-index + 1 + num-real-args(records)
          val num-fargs-reg-index = num-args-index + 1 + num-int-args(records)
          defn register-index (l:CallLoc) :
            match(l) :
              (l:RegLoc) : num-fargs-reg-index - 1 - index(l)
              (l:FRegLoc) : num-args-index - 1 - index(l)
              (l:MemLoc) : num-fargs-index - 1 - index(l)
          ;Assign registers
          for arg in args(records) do :
            val r = register-index(loc(arg))
            match(value(arg)) :
              (a:StdArg) :
                set-reg(r, ys(ins)[index(a)])
              (a:ShadowArg) :
                fatal("Not yet implemented.")
          set-reg(num-stack-args-index, NumConst(num-mem-args(records)))
          set-reg(num-fargs-index, NumConst(num-real-args(records)))
          set-reg(num-args-index, NumConst(num-int-args(records) + 1))
          set-reg(num-fargs-reg-index, NumConst(num-real-args(records)))
          ;Call function
          match(f(ins)) :
            (f:Local) :
              emit-ins-c(CALLC-OPCODE-LOCAL, num-locals, slot(f))
            (f:ExternId) :
              val address = to-bits(f) as Long
              emit-ins-d(CALLC-OPCODE-WIDE, num-locals, address)
          record-info(info(ins))
          ;Retrieve return registers
          defn return-register-index (l:CallLoc) :
            match(l) :
              (l:RegLoc) : 0
              (l:FRegLoc) : 1
          if not empty?(xs(ins)) :
            val x = xs(ins)[0]
            get-reg(x, return-register-index(return(records)))     
        (ins:YieldIns) : 
          set-regs(ys(ins))
          val opcode = ENTER-STACK-OPCODE when enter?(ins) else YIELD-OPCODE
          emit-ins-a(opcode, to-local(f(ins), 0))
          record-info(info(ins))
          get-regs(xs(ins))
        (ins:ReturnIns) : 
          set-regs(xs(ins))
          emit-ins-a(RETURN-OPCODE, 0)
        (ins:DumpIns) :
          for x in xs(ins) do :
            emit-ins-a(DUMP-OPCODE, slot(x))
        (ins:RecordLiveIns) : 
          val live-map = liveness-map(resolver, map(slot, live(ins)), num-locals)
          emit-ins-a(LIVE-OPCODE, live-map)
        (ins:StoreIns) :          
          val code = store-opcode(y(ins), imm-type(z(ins)))
          val offset* = match(imm-type(x(ins))) :
            (xt:VMRef) : offset(ins) - ref-offset(resolver) + object-header-size(resolver)
            (xt) : offset(ins)
          val x* = to-local(x(ins),0)
          val z* = to-local(z(ins),1)
          val y* = match(y(ins)) :
            (y:VMImm) : to-local(y,2)
            (y:False) : 0
          emit-ins-e(code, x*, y*, z*, offset*)
        (ins:LoadIns) :
          val code = load-opcode(z(ins), imm-type(x(ins)))
          val offset* = match(imm-type(y(ins))) :
            (yt:VMRef) : offset(ins) - ref-offset(resolver) + object-header-size(resolver)
            (yt) : offset(ins)
          val y* = to-local(y(ins),0)
          val z* = match(z(ins)) :
            (z:VMImm) : to-local(z,1)
            (z:False) : 0
          emit-ins-e(code, slot(x(ins)), y*, z*, offset*)
        (ins:Op0Ins) :
          val code = op0-opcode(op(ins))
          emit-ins-a(code, slot(x(ins)))
        (ins:Op1Ins) :
          match(op(ins)) :
            (op:InstanceofOp) :
              ;Push argument into register
              set-reg(0, y(ins))
              val format = match-format(resolver, [[type(op)]])
              ;Emit typeof instruction
              emit-ins-c(TYPEOF-OPCODE, slot(x(ins)), format)
            (op) :
              val opcode = op1-opcode(op, imm-type(x(ins)), imm-type(y(ins)))
              match(opcode:Int) :
                val x* = slot(x(ins))
                val y* = to-local(y(ins), 0)
                emit-ins-b(opcode, x*, y*)
              else :
                set-local(slot(x(ins)), y(ins))
        (ins:Op2Ins) :
          val opcode = op2-opcode(op(ins), imm-type(x(ins)), imm-type(y(ins)))
          val x* = slot(x(ins))
          val y* = to-local(y(ins), 0)
          val z* = to-local(z(ins), 1)
          emit-ins-c(opcode, x*, y*, z*)
        (ins:GotoIns) :
          within delayed-ins(1) :            
            emit-ins-a(GOTO-OPCODE, jump-offset(n(ins)))
        (ins:Branch1Ins) :
          match(op(ins)) :
            (op:InstanceofOp) :
              emit-instanceof(n1(ins), n2(ins), x(ins), type(op))
            (op:False) :
              within delayed-ins(2 + words-for-to-local(x(ins))) :
                emit-ins-f(JUMP-SET-OPCODE, to-local(x(ins), 0), 0, jump-offset(n1(ins)), jump-offset(n2(ins)))
        (ins:Branch2Ins) :
          val code = branch2-opcode(op(ins), imm-type(x(ins)))
          within delayed-ins(2 + words-for-to-local(x(ins)) + words-for-to-local(y(ins))) :
            val x* = to-local(x(ins), 0)
            val y* = to-local(y(ins), 1)
            emit-ins-f(code, x*, y*, jump-offset(n1(ins)), jump-offset(n2(ins)))
        (ins:AllocIns) :
          if all?({_ is NumConst}, sizes(ins)) :
            val num-obj = length(sizes(ins))
            val obj-sizes = for s in sizes(ins) map :
              object-size-on-heap(resolver, value(s as NumConst) as Int)
            val sum-of-sizes = object-size(num-obj, sum(obj-sizes))
            emit-ins-c(RESERVE-OPCODE-CONST, 3, num-locals, sum-of-sizes)
            record-info(info(ins))
            emit-ins-a(POP-FRAME-OPCODE, num-locals)
            for (x in xs(ins), t in types(ins), sz in obj-sizes) do :
              emit-ins-c(ALLOC-OPCODE-CONST, slot(x), sz, t)
          else :
            fatal("Multiple variable-sized allocations.") when length(sizes(ins)) > 1
            val x = xs(ins)[0]
            val type = types(ins)[0]
            val size = to-local(sizes(ins)[0], 0)
            emit-ins-c(RESERVE-OPCODE-LOCAL, 3, num-locals, size)
            record-info(info(ins))
            emit-ins-a(POP-FRAME-OPCODE, num-locals)
            emit-ins-c(ALLOC-OPCODE-LOCAL, slot(x), size, type)
        (ins:DispatchIns) :
          ;Push arguments onto registers
          set-regs(ys(ins))
          val [types, dests] = split-types-and-dests(branches(ins))
          val format = dispatch-format(resolver, types)            
          ;Two targets for default and amb and then each branch for dispatch.
          val num-targets = 2 + length(branches(ins))
          within delayed-ins(1 + 1 + num-targets) :
            val targets = jump-offsets([default(ins), amb(ins)], dests)
            emit-ins-a(DISPATCH-OPCODE, format)            
            emit-ins-targets(targets)
        (ins:MatchIns) :
          if all?(branch-is-final?, branches(ins)) :
            emit-final-match(ys(ins), branches(ins), default(ins))
          else :
            emit-non-final-match(ys(ins), branches(ins), default(ins))
        (ins:MethodDispatchIns) :
          ;Push arguments onto registers
          set-regs(cat(ys(ins), zs(ins)))
          ;Retrieve format
          val format = method-format(resolver, multi(ins), length(ys(ins)), length(zs(ins)))
          ;Only two targets for default and amb
          val num-targets = 2
          within delayed-ins(1 + 1 + num-targets) :
            val targets = jump-offsets([default(ins), amb(ins)])
            emit-ins-a(DISPATCH-METHOD-OPCODE, format)
            emit-ins-targets(targets)
        (ins:SetIns) :
          set-local(slot(x(ins)), y(ins))

    ;==================================================
    ;============= Immediate Utilities ================
    ;==================================================
    ;Retrieve type of immediate
    defn imm-type (x:VMImm) :
      match(x:Local) : type(deftable[index(x)])
      else : type(x)
    defn imm-type (x:VMType) :
      x

    ;Use deftable to retrieve the slot of a local
    defn slot (x:Local) :
      local(deftable[index(x)])

    ;==================================================
    ;============= Label Utilities ====================
    ;==================================================
    ;Create mapping from label ID to position
    defn jump-offset (n:Int) :
      label-table[n] - buffer-pos()
    defn jump-offsets (xs:Seqable<Int>) :
      to-tuple(seq(jump-offset, xs))
    defn jump-offsets (xs:Seqable<Int>, ys:Seqable<Int>) :
      jump-offsets(cat(xs,ys))

    ;Generate new unique label
    defn* gen-label () :
      val l = next(label-counter)
      gen-label() when used-labels[l] else l

    ;==================================================
    ;============= Compilation Utilities ==============
    ;==================================================
    ;Retrieve the corresponding bits for the given immediate
    defn to-bits (y:VMImm) -> Int|Long :
      match(y) :
        (y:Local) : slot(y)
        (y:NumConst) :
          match(value(y)) :
            (v:Char) : to-int(v)
            (v:Byte) : to-int(v)
            (v:Int) : v
            (v:Long) : v
            (v:Float) : bits(v)
            (v:Double) : bits(v)
        (y:Marker) : marker(resolver, typeid(y))
        (y:Tag) : typeid(y)
        (y:VoidMarker) : void-marker(resolver)
        (y:CodeId) : id(y)
        (y:ExternId) : extern-address(id(y))
        (y:GlobalId) : id(y)
        (y:DataId) : id(y)
        (y:ConstId) : id(y)

    ;Set register
    defn set-reg (i:Int, y:VMImm) :
      match(to-bits(y)) :
        (v:Int) : emit-ins-c(set-reg-opcode(y), i, v)
        (v:Long) : emit-ins-d(set-reg-opcode(y), i, v)    
    defn set-regs (ys:Seqable<VMImm>) :
      do(set-reg, 0 to false, ys)
    defn get-reg (x:Local|VMType, i:Int) :
      match(x:Local) :
        emit-ins-b(GET-REG-OPCODE, slot(x), i)
    defn get-regs (xs:Seqable<Local|VMType>) :
      do(get-reg, xs, 0 to false)

    ;Set local
    defn set-local (x:Int, y:VMImm) :
      match(to-bits(y)) :
        (v:Int) : emit-ins-c(set-opcode(y), x, v)
        (v:Long) : emit-ins-d(set-opcode(y), x, v)

    ;Put immediate in temporary local if not a local
    defn to-local (x:VMImm, num:Int) :
      match(x:Local) :
        slot(x)
      else :
        val index = max-local + num + 1
        set-local(index, x)
        index
        
    ;Number of words needed to hold immediate in local
    defn words-for-to-local (x:VMImm) :
      match(x:Local) :
        0
      else :
        match(to-bits(x)) :
          (v:Int) : 2
          (v:Long) : 3

    ;Put immediate in register if not a function immediate
    defn to-function-local (f:VMImm) :
      match(f) :
        (f:CodeId) : id(f)
        (f) : to-local(f, 0)

    ;==================================================
    ;===================== Launch =====================
    ;==================================================
    driver()

  ;Use delayed actions and encode instructions
  within delay-actions() :
    encode(func as VMMultifn|VMFunc)    
  EncodedFunction(buffer, fileinfo-table)

;============================================================
;======================= Opcodes ============================
;============================================================

val SET-OPCODE-LOCAL = 0
val SET-OPCODE-UNSIGNED = 1
val SET-OPCODE-SIGNED = 2
val SET-OPCODE-CODE = 3
val SET-OPCODE-GLOBAL = 5
val SET-OPCODE-DATA = 6
val SET-OPCODE-CONST = 7
val SET-OPCODE-WIDE = 8
val SET-REG-OPCODE-LOCAL = 9
val SET-REG-OPCODE-UNSIGNED = 10
val SET-REG-OPCODE-SIGNED = 11
val SET-REG-OPCODE-CODE = 12
val SET-REG-OPCODE-GLOBAL = 14
val SET-REG-OPCODE-DATA = 15
val SET-REG-OPCODE-CONST = 16
val SET-REG-OPCODE-WIDE = 17
val GET-REG-OPCODE = 18
val CALL-OPCODE-LOCAL = 19
val CALL-OPCODE-CODE = 20
val CALL-CLOSURE-OPCODE = 22
val TCALL-OPCODE-LOCAL = 23
val TCALL-OPCODE-CODE = 24
val TCALL-CLOSURE-OPCODE = 26
val CALLC-OPCODE-LOCAL = 27
val CALLC-OPCODE-WIDE = 28
val POP-FRAME-OPCODE = 30
val LIVE-OPCODE = 31
val YIELD-OPCODE = 32
val RETURN-OPCODE = 33
val DUMP-OPCODE = 34
;2-arity operations
val INT-ADD-OPCODE = 35
val INT-SUB-OPCODE = 36
val INT-MUL-OPCODE = 37
val INT-DIV-OPCODE = 38
val INT-MOD-OPCODE = 39
val INT-AND-OPCODE = 40
val INT-OR-OPCODE = 41
val INT-XOR-OPCODE = 42
val INT-SHL-OPCODE = 43
val INT-SHR-OPCODE = 44
val INT-ASHR-OPCODE = 45
val INT-LT-OPCODE = 46
val INT-GT-OPCODE = 47
val INT-LE-OPCODE = 48
val INT-GE-OPCODE = 49
val EQ-OPCODE-REF-REF = 50
val EQ-OPCODE-REF = 51
val EQ-OPCODE-BYTE = 52
val EQ-OPCODE-INT = 53
val EQ-OPCODE-LONG = 54
val EQ-OPCODE-FLOAT = 55
val EQ-OPCODE-DOUBLE = 56
val NE-OPCODE-REF-REF = 57
val NE-OPCODE-REF = 58
val NE-OPCODE-BYTE = 59
val NE-OPCODE-INT = 60
val NE-OPCODE-LONG = 61
val NE-OPCODE-FLOAT = 62
val NE-OPCODE-DOUBLE = 63
val ADD-OPCODE-BYTE = 64
val ADD-OPCODE-INT = 65
val ADD-OPCODE-LONG = 66
val ADD-OPCODE-FLOAT = 67
val ADD-OPCODE-DOUBLE = 68
val SUB-OPCODE-BYTE = 69
val SUB-OPCODE-INT = 70
val SUB-OPCODE-LONG = 71
val SUB-OPCODE-FLOAT = 72
val SUB-OPCODE-DOUBLE = 73
val MUL-OPCODE-BYTE = 74
val MUL-OPCODE-INT = 75
val MUL-OPCODE-LONG = 76
val MUL-OPCODE-FLOAT = 77
val MUL-OPCODE-DOUBLE = 78
val DIV-OPCODE-BYTE = 79
val DIV-OPCODE-INT = 80
val DIV-OPCODE-LONG = 81
val DIV-OPCODE-FLOAT = 82
val DIV-OPCODE-DOUBLE = 83
val MOD-OPCODE-BYTE = 84
val MOD-OPCODE-INT = 85
val MOD-OPCODE-LONG = 86
val AND-OPCODE-BYTE = 87
val AND-OPCODE-INT = 88
val AND-OPCODE-LONG = 89
val OR-OPCODE-BYTE = 90
val OR-OPCODE-INT = 91
val OR-OPCODE-LONG = 92
val XOR-OPCODE-BYTE = 93
val XOR-OPCODE-INT = 94
val XOR-OPCODE-LONG = 95
val SHL-OPCODE-BYTE = 96
val SHL-OPCODE-INT = 97
val SHL-OPCODE-LONG = 98
val SHR-OPCODE-BYTE = 99
val SHR-OPCODE-INT = 100
val SHR-OPCODE-LONG = 101
val ASHR-OPCODE-INT = 103
val ASHR-OPCODE-LONG = 104
val LT-OPCODE-INT = 105
val LT-OPCODE-LONG = 106
val LT-OPCODE-FLOAT = 107
val LT-OPCODE-DOUBLE = 108
val GT-OPCODE-INT = 109
val GT-OPCODE-LONG = 110
val GT-OPCODE-FLOAT = 111
val GT-OPCODE-DOUBLE = 112
val LE-OPCODE-INT = 113
val LE-OPCODE-LONG = 114
val LE-OPCODE-FLOAT = 115
val LE-OPCODE-DOUBLE = 116
val GE-OPCODE-INT = 117
val GE-OPCODE-LONG = 118
val GE-OPCODE-FLOAT = 119
val GE-OPCODE-DOUBLE = 120
val ULE-OPCODE-BYTE = 121
val ULE-OPCODE-INT = 122
val ULE-OPCODE-LONG = 123
val ULT-OPCODE-BYTE = 124
val ULT-OPCODE-INT = 125
val ULT-OPCODE-LONG = 126
val UGT-OPCODE-BYTE = 127
val UGT-OPCODE-INT = 128
val UGT-OPCODE-LONG = 129
val UGE-OPCODE-BYTE = 130
val UGE-OPCODE-INT = 131
val UGE-OPCODE-LONG = 132
;1-arity operations
val INT-NOT-OPCODE = 133
val INT-NEG-OPCODE = 134
val NOT-OPCODE-BYTE = 135
val NOT-OPCODE-INT = 136
val NOT-OPCODE-LONG = 137
val NEG-OPCODE-INT = 138
val NEG-OPCODE-LONG = 139
val NEG-OPCODE-FLOAT = 140
val NEG-OPCODE-DOUBLE = 141
val DEREF-OPCODE = 142
val TYPEOF-OPCODE = 143
;branch operation
val JUMP-SET-OPCODE = 144
val JUMP-TAGBITS-OPCODE = 240
val JUMP-TAGWORD-OPCODE = 242
val GOTO-OPCODE = 145
;conversion operations
val CONV-OPCODE-BYTE-FLOAT = 146
val CONV-OPCODE-BYTE-DOUBLE = 147
val CONV-OPCODE-INT-BYTE = 148
val CONV-OPCODE-INT-FLOAT = 149
val CONV-OPCODE-INT-DOUBLE = 150
val CONV-OPCODE-LONG-BYTE = 151
val CONV-OPCODE-LONG-INT = 152
val CONV-OPCODE-LONG-FLOAT = 153
val CONV-OPCODE-LONG-DOUBLE = 154
val CONV-OPCODE-FLOAT-BYTE = 155
val CONV-OPCODE-FLOAT-INT = 156
val CONV-OPCODE-FLOAT-LONG = 157
val CONV-OPCODE-FLOAT-DOUBLE = 158
val CONV-OPCODE-DOUBLE-BYTE = 159
val CONV-OPCODE-DOUBLE-INT = 160
val CONV-OPCODE-DOUBLE-LONG = 161
val CONV-OPCODE-DOUBLE-FLOAT = 162
;tagging operations
val DETAG-OPCODE = 163
val TAG-OPCODE-BYTE = 164
val TAG-OPCODE-CHAR = 165
val TAG-OPCODE-INT = 166
val TAG-OPCODE-FLOAT = 167
;storing operations
val STORE-OPCODE-1 = 168
val STORE-OPCODE-4 = 169
val STORE-OPCODE-8 = 170
val STORE-OPCODE-1-VAR-OFFSET = 171
val STORE-OPCODE-4-VAR-OFFSET = 172
val STORE-OPCODE-8-VAR-OFFSET = 173
;loading operations
val LOAD-OPCODE-1 = 174
val LOAD-OPCODE-4 = 175
val LOAD-OPCODE-8 = 176
val LOAD-OPCODE-1-VAR-OFFSET = 177
val LOAD-OPCODE-4-VAR-OFFSET = 178
val LOAD-OPCODE-8-VAR-OFFSET = 179
;Allocation
val RESERVE-OPCODE-LOCAL = 180
val RESERVE-OPCODE-CONST = 181
val ENTER-STACK-OPCODE = 182
val ALLOC-OPCODE-CONST = 183
val ALLOC-OPCODE-LOCAL = 184
;system operations
val GC-OPCODE = 185
val CLASS-NAME-OPCODE = 241
val C-RSP-OPCODE = 243
val PRINT-STACK-TRACE-OPCODE = 186
val FLUSH-VM-OPCODE = 188
;2-arity branch operations
val JUMP-INT-LT-OPCODE = 192
val JUMP-INT-GT-OPCODE = 193
val JUMP-INT-LE-OPCODE = 194
val JUMP-INT-GE-OPCODE = 195
val JUMP-EQ-OPCODE-REF = 196
val JUMP-EQ-OPCODE-BYTE = 197
val JUMP-EQ-OPCODE-INT = 198
val JUMP-EQ-OPCODE-LONG = 199
val JUMP-EQ-OPCODE-FLOAT = 200
val JUMP-EQ-OPCODE-DOUBLE = 201
val JUMP-NE-OPCODE-REF = 202
val JUMP-NE-OPCODE-BYTE = 203
val JUMP-NE-OPCODE-INT = 204
val JUMP-NE-OPCODE-LONG = 205
val JUMP-NE-OPCODE-FLOAT = 206
val JUMP-NE-OPCODE-DOUBLE = 207
val JUMP-LT-OPCODE-INT = 208
val JUMP-LT-OPCODE-LONG = 209
val JUMP-LT-OPCODE-FLOAT = 210
val JUMP-LT-OPCODE-DOUBLE = 211
val JUMP-GT-OPCODE-INT = 212
val JUMP-GT-OPCODE-LONG = 213
val JUMP-GT-OPCODE-FLOAT = 214
val JUMP-GT-OPCODE-DOUBLE = 215
val JUMP-LE-OPCODE-INT = 216
val JUMP-LE-OPCODE-LONG = 217
val JUMP-LE-OPCODE-FLOAT = 218
val JUMP-LE-OPCODE-DOUBLE = 219
val JUMP-GE-OPCODE-INT = 220
val JUMP-GE-OPCODE-LONG = 221
val JUMP-GE-OPCODE-FLOAT = 222
val JUMP-GE-OPCODE-DOUBLE = 223
val JUMP-ULE-OPCODE-BYTE = 224
val JUMP-ULE-OPCODE-INT = 225
val JUMP-ULE-OPCODE-LONG = 226
val JUMP-ULT-OPCODE-BYTE = 227
val JUMP-ULT-OPCODE-INT = 228
val JUMP-ULT-OPCODE-LONG = 229
val JUMP-UGT-OPCODE-BYTE = 230
val JUMP-UGT-OPCODE-INT = 231
val JUMP-UGT-OPCODE-LONG = 232
val JUMP-UGE-OPCODE-BYTE = 233
val JUMP-UGE-OPCODE-INT = 234
val JUMP-UGE-OPCODE-LONG = 235
;dispatch operation
val DISPATCH-OPCODE = 236
val DISPATCH-METHOD-OPCODE = 237
;jump on register
val JUMP-REG-OPCODE = 238
;function entry
val FNENTRY-OPCODE = 239

defn set-reg-opcode (y:VMImm) :
  match(y) :
    (y:Local) : SET-REG-OPCODE-LOCAL
    (y:NumConst) :
      match(value(y)) :
        (v:Char) : SET-REG-OPCODE-UNSIGNED
        (v:Byte) : SET-REG-OPCODE-UNSIGNED
        (v:Int) : SET-REG-OPCODE-UNSIGNED
        (v:Long) : SET-REG-OPCODE-WIDE  ;OR SIGNED
        (v:Float) : SET-REG-OPCODE-UNSIGNED
        (v:Double) : SET-REG-OPCODE-WIDE
    (y:Marker) : SET-REG-OPCODE-UNSIGNED
    (y:Tag) : SET-REG-OPCODE-UNSIGNED
    (y:CodeId) : SET-REG-OPCODE-CODE
    (y:ExternId) : SET-REG-OPCODE-WIDE
    (y:GlobalId) : SET-REG-OPCODE-GLOBAL
    (y:DataId) : SET-REG-OPCODE-DATA
    (y:ConstId) : SET-REG-OPCODE-CONST
    (y:VoidMarker) : SET-REG-OPCODE-UNSIGNED

defn set-opcode (y:VMImm) :
  match(y) :
    (y:Local) : SET-OPCODE-LOCAL
    (y:NumConst) :
      match(value(y)) :
        (v:Char) : SET-OPCODE-UNSIGNED
        (v:Byte) : SET-OPCODE-UNSIGNED
        (v:Int) : SET-OPCODE-UNSIGNED
        (v:Long) : SET-OPCODE-WIDE  ;OR SIGNED
        (v:Float) : SET-OPCODE-UNSIGNED
        (v:Double) : SET-OPCODE-WIDE
    (y:Marker) : SET-OPCODE-UNSIGNED
    (y:Tag) : SET-OPCODE-UNSIGNED
    (y:CodeId) : SET-OPCODE-CODE
    (y:ExternId) : SET-OPCODE-WIDE
    (y:GlobalId) : SET-OPCODE-GLOBAL
    (y:DataId) : SET-OPCODE-DATA
    (y:ConstId) : SET-OPCODE-CONST
    (y:VoidMarker) : SET-OPCODE-UNSIGNED

defn call-opcode (f:VMImm) :
  match(f) :
    (f:Local) : CALL-OPCODE-LOCAL
    (f:CodeId) : CALL-OPCODE-CODE

defn callc-opcode (f:VMImm) :
  match(f) :
    (f:Local) : CALLC-OPCODE-LOCAL
    (f:ExternId) :  CALLC-OPCODE-WIDE

defn tcall-opcode (f:VMImm) :
  match(f) :
    (f:Local) : TCALL-OPCODE-LOCAL
    (f:CodeId) : TCALL-OPCODE-CODE

defn store-opcode (offset:VMImm|False, val-type:VMType) :
  match(offset, val-type) :
    (o:False, vt:VMByte) : STORE-OPCODE-1
    (o:False, vt:VMInt) : STORE-OPCODE-4
    (o:False, vt:VMLong) : STORE-OPCODE-8
    (o:False, vt:VMFloat) : STORE-OPCODE-4
    (o:False, vt:VMDouble) : STORE-OPCODE-8
    (o:False, vt:VMRef) : STORE-OPCODE-8
    (o:VMImm, vt:VMByte) : STORE-OPCODE-1-VAR-OFFSET
    (o:VMImm, vt:VMInt) : STORE-OPCODE-4-VAR-OFFSET
    (o:VMImm, vt:VMLong) : STORE-OPCODE-8-VAR-OFFSET
    (o:VMImm, vt:VMFloat) : STORE-OPCODE-4-VAR-OFFSET
    (o:VMImm, vt:VMDouble) : STORE-OPCODE-8-VAR-OFFSET
    (o:VMImm, vt:VMRef) : STORE-OPCODE-8-VAR-OFFSET

defn load-opcode (offset:VMImm|False, xtype:VMType) :
  match(offset, xtype) :
    (o:False, xt:VMByte) : LOAD-OPCODE-1
    (o:False, xt:VMInt) : LOAD-OPCODE-4
    (o:False, xt:VMLong) : LOAD-OPCODE-8
    (o:False, xt:VMFloat) : LOAD-OPCODE-4
    (o:False, xt:VMDouble) : LOAD-OPCODE-8
    (o:False, xt:VMRef) : LOAD-OPCODE-8
    (o:VMImm, xt:VMByte) : LOAD-OPCODE-1-VAR-OFFSET
    (o:VMImm, xt:VMInt) : LOAD-OPCODE-4-VAR-OFFSET
    (o:VMImm, xt:VMLong) : LOAD-OPCODE-8-VAR-OFFSET
    (o:VMImm, xt:VMFloat) : LOAD-OPCODE-4-VAR-OFFSET
    (o:VMImm, xt:VMDouble) : LOAD-OPCODE-8-VAR-OFFSET
    (o:VMImm, xt:VMRef) : LOAD-OPCODE-8-VAR-OFFSET

defn op0-opcode (op:VMOp) :
  match(op) :
    (op:FlushVMOp) : FLUSH-VM-OPCODE
    (op:CRSPOp) : C-RSP-OPCODE

;Returns false if operation becomes a set operation.
defn op1-opcode (op:VMOp, xt:VMType, yt:VMType) -> Int|False :
  match(op, xt, yt) :
    (op:IntNotOp, xt:VMRef, yt:VMRef) : INT-NOT-OPCODE
    (op:IntNegOp, xt:VMRef, yt:VMRef) : INT-NEG-OPCODE
    (op:NotOp, xt:VMByte, yt:VMByte) : NOT-OPCODE-BYTE
    (op:NotOp, xt:VMInt, yt:VMInt) : NOT-OPCODE-INT
    (op:NotOp, xt:VMLong, yt:VMLong) : NOT-OPCODE-LONG
    (op:NegOp, xt:VMInt, yt:VMInt) : NEG-OPCODE-INT
    (op:NegOp, xt:VMLong, yt:VMLong) : NEG-OPCODE-LONG
    (op:NegOp, xt:VMFloat, yt:VMFloat) : NEG-OPCODE-FLOAT
    (op:NegOp, xt:VMDouble, yt:VMDouble) : NEG-OPCODE-DOUBLE
    (op:InterpretOp, xt, yt) : false
    (op:ConvOp, xt:VMByte, yt:VMByte) : false
    (op:ConvOp, xt:VMByte, yt:VMInt) : false
    (op:ConvOp, xt:VMByte, yt:VMLong) : false
    (op:ConvOp, xt:VMByte, yt:VMFloat) : CONV-OPCODE-BYTE-FLOAT
    (op:ConvOp, xt:VMByte, yt:VMDouble) : CONV-OPCODE-BYTE-DOUBLE
    (op:ConvOp, xt:VMInt, yt:VMByte) : CONV-OPCODE-INT-BYTE
    (op:ConvOp, xt:VMInt, yt:VMInt) : false
    (op:ConvOp, xt:VMInt, yt:VMLong) : false
    (op:ConvOp, xt:VMInt, yt:VMFloat) : CONV-OPCODE-INT-FLOAT
    (op:ConvOp, xt:VMInt, yt:VMDouble) : CONV-OPCODE-INT-DOUBLE
    (op:ConvOp, xt:VMLong, yt:VMByte) : CONV-OPCODE-LONG-BYTE
    (op:ConvOp, xt:VMLong, yt:VMInt) : CONV-OPCODE-LONG-INT
    (op:ConvOp, xt:VMLong, yt:VMLong) : false
    (op:ConvOp, xt:VMLong, yt:VMFloat) : CONV-OPCODE-LONG-FLOAT
    (op:ConvOp, xt:VMLong, yt:VMDouble) : CONV-OPCODE-LONG-DOUBLE
    (op:ConvOp, xt:VMFloat, yt:VMByte) : CONV-OPCODE-FLOAT-BYTE
    (op:ConvOp, xt:VMFloat, yt:VMInt) : CONV-OPCODE-FLOAT-INT
    (op:ConvOp, xt:VMFloat, yt:VMLong) : CONV-OPCODE-FLOAT-LONG
    (op:ConvOp, xt:VMFloat, yt:VMFloat) : false
    (op:ConvOp, xt:VMFloat, yt:VMDouble) : CONV-OPCODE-FLOAT-DOUBLE
    (op:ConvOp, xt:VMDouble, yt:VMByte) : CONV-OPCODE-DOUBLE-BYTE
    (op:ConvOp, xt:VMDouble, yt:VMInt) : CONV-OPCODE-DOUBLE-INT
    (op:ConvOp, xt:VMDouble, yt:VMLong) : CONV-OPCODE-DOUBLE-LONG
    (op:ConvOp, xt:VMDouble, yt:VMFloat) : CONV-OPCODE-DOUBLE-FLOAT
    (op:ConvOp, xt:VMDouble, yt:VMDouble) : false
    (op:TagOp, xt, yt) :
      switch(type(op)) :
        BYTE-TYPE : TAG-OPCODE-BYTE
        CHAR-TYPE : TAG-OPCODE-CHAR
        INT-TYPE : TAG-OPCODE-INT
        FLOAT-TYPE : TAG-OPCODE-FLOAT
    (op:DetagOp, xt, yt) : DETAG-OPCODE
    (op:DerefOp, xt, yt) : DEREF-OPCODE
    (op:GCOp, xt, yt) : GC-OPCODE
    (op:ClassNameOp, xt, yt) : CLASS-NAME-OPCODE
    (op:PrintStackTraceOp, xt, yt) : PRINT-STACK-TRACE-OPCODE

defn op2-opcode (op:VMOp, xt:VMType, yt:VMType) :
  match(op, xt, yt) :
    (op:IntAddOp, xt:VMRef, yt:VMRef) : INT-ADD-OPCODE
    (op:IntSubOp, xt:VMRef, yt:VMRef) : INT-SUB-OPCODE
    (op:IntMulOp, xt:VMRef, yt:VMRef) : INT-MUL-OPCODE
    (op:IntDivOp, xt:VMRef, yt:VMRef) : INT-DIV-OPCODE
    (op:IntModOp, xt:VMRef, yt:VMRef) : INT-MOD-OPCODE
    (op:IntAndOp, xt:VMRef, yt:VMRef) : INT-AND-OPCODE
    (op:IntOrOp, xt:VMRef, yt:VMRef) : INT-OR-OPCODE
    (op:IntXorOp, xt:VMRef, yt:VMRef) : INT-XOR-OPCODE
    (op:IntShlOp, xt:VMRef, yt:VMRef) : INT-SHL-OPCODE
    (op:IntShrOp, xt:VMRef, yt:VMRef) : INT-SHR-OPCODE
    (op:IntAshrOp, xt:VMRef, yt:VMRef) : INT-ASHR-OPCODE
    (op:IntLtOp, xt:VMRef, yt:VMRef) : INT-LT-OPCODE
    (op:IntGtOp, xt:VMRef, yt:VMRef) : INT-GT-OPCODE
    (op:IntLeOp, xt:VMRef, yt:VMRef) : INT-LE-OPCODE
    (op:IntGeOp, xt:VMRef, yt:VMRef) : INT-GE-OPCODE
    (op:EqOp, xt:VMRef, yt:VMRef) : EQ-OPCODE-REF-REF
    (op:EqOp, xt:VMLong, yt:VMRef) : EQ-OPCODE-REF
    (op:EqOp, xt:VMLong, yt:VMByte) : EQ-OPCODE-BYTE
    (op:EqOp, xt:VMLong, yt:VMInt) : EQ-OPCODE-INT
    (op:EqOp, xt:VMLong, yt:VMLong) : EQ-OPCODE-LONG
    (op:EqOp, xt:VMLong, yt:VMFloat) : EQ-OPCODE-FLOAT
    (op:EqOp, xt:VMLong, yt:VMDouble) : EQ-OPCODE-DOUBLE
    (op:NeOp, xt:VMRef, yt:VMRef) : NE-OPCODE-REF-REF
    (op:NeOp, xt:VMLong, yt:VMRef) : NE-OPCODE-REF
    (op:NeOp, xt:VMLong, yt:VMByte) : NE-OPCODE-BYTE
    (op:NeOp, xt:VMLong, yt:VMInt) : NE-OPCODE-INT
    (op:NeOp, xt:VMLong, yt:VMLong) : NE-OPCODE-LONG
    (op:NeOp, xt:VMLong, yt:VMFloat) : NE-OPCODE-FLOAT
    (op:NeOp, xt:VMLong, yt:VMDouble) : NE-OPCODE-DOUBLE
    (op:AddOp, xt:VMByte, yt:VMByte) : ADD-OPCODE-BYTE
    (op:AddOp, xt:VMInt, yt:VMInt) : ADD-OPCODE-INT
    (op:AddOp, xt:VMLong, yt:VMLong) : ADD-OPCODE-LONG
    (op:AddOp, xt:VMFloat, yt:VMFloat) : ADD-OPCODE-FLOAT
    (op:AddOp, xt:VMDouble, yt:VMDouble) : ADD-OPCODE-DOUBLE
    (op:SubOp, xt:VMByte, yt:VMByte) : SUB-OPCODE-BYTE
    (op:SubOp, xt:VMInt, yt:VMInt) : SUB-OPCODE-INT
    (op:SubOp, xt:VMLong, yt:VMLong) : SUB-OPCODE-LONG
    (op:SubOp, xt:VMFloat, yt:VMFloat) : SUB-OPCODE-FLOAT
    (op:SubOp, xt:VMDouble, yt:VMDouble) : SUB-OPCODE-DOUBLE
    (op:MulOp, xt:VMByte, yt:VMByte) : MUL-OPCODE-BYTE
    (op:MulOp, xt:VMInt, yt:VMInt) : MUL-OPCODE-INT
    (op:MulOp, xt:VMLong, yt:VMLong) : MUL-OPCODE-LONG
    (op:MulOp, xt:VMFloat, yt:VMFloat) : MUL-OPCODE-FLOAT
    (op:MulOp, xt:VMDouble, yt:VMDouble) : MUL-OPCODE-DOUBLE
    (op:DivOp, xt:VMByte, yt:VMByte) : DIV-OPCODE-BYTE
    (op:DivOp, xt:VMInt, yt:VMInt) : DIV-OPCODE-INT
    (op:DivOp, xt:VMLong, yt:VMLong) : DIV-OPCODE-LONG
    (op:DivOp, xt:VMFloat, yt:VMFloat) : DIV-OPCODE-FLOAT
    (op:DivOp, xt:VMDouble, yt:VMDouble) : DIV-OPCODE-DOUBLE
    (op:ModOp, xt:VMByte, yt:VMByte) : MOD-OPCODE-BYTE
    (op:ModOp, xt:VMInt, yt:VMInt) : MOD-OPCODE-INT
    (op:ModOp, xt:VMLong, yt:VMLong) : MOD-OPCODE-LONG
    (op:AndOp, xt:VMByte, yt:VMByte) : AND-OPCODE-BYTE
    (op:AndOp, xt:VMInt, yt:VMInt) : AND-OPCODE-INT
    (op:AndOp, xt:VMLong, yt:VMLong) : AND-OPCODE-LONG
    (op:OrOp, xt:VMByte, yt:VMByte) : OR-OPCODE-BYTE
    (op:OrOp, xt:VMInt, yt:VMInt) : OR-OPCODE-INT
    (op:OrOp, xt:VMLong, yt:VMLong) : OR-OPCODE-LONG
    (op:XorOp, xt:VMByte, yt:VMByte) : XOR-OPCODE-BYTE
    (op:XorOp, xt:VMInt, yt:VMInt) : XOR-OPCODE-INT
    (op:XorOp, xt:VMLong, yt:VMLong) : XOR-OPCODE-LONG
    (op:ShlOp, xt:VMByte, yt:VMByte) : SHL-OPCODE-BYTE
    (op:ShlOp, xt:VMInt, yt:VMInt) : SHL-OPCODE-INT
    (op:ShlOp, xt:VMLong, yt:VMLong) : SHL-OPCODE-LONG
    (op:ShrOp, xt:VMByte, yt:VMByte) : SHR-OPCODE-BYTE
    (op:ShrOp, xt:VMInt, yt:VMInt) : SHR-OPCODE-INT
    (op:ShrOp, xt:VMLong, yt:VMLong) : SHR-OPCODE-LONG
    (op:AshrOp, xt:VMInt, yt:VMInt) : ASHR-OPCODE-INT
    (op:AshrOp, xt:VMLong, yt:VMLong) : ASHR-OPCODE-LONG
    (op:LtOp, xt:VMLong, yt:VMInt) : LT-OPCODE-INT
    (op:LtOp, xt:VMLong, yt:VMLong) : LT-OPCODE-LONG
    (op:LtOp, xt:VMLong, yt:VMFloat) : LT-OPCODE-FLOAT
    (op:LtOp, xt:VMLong, yt:VMDouble) : LT-OPCODE-DOUBLE
    (op:GtOp, xt:VMLong, yt:VMInt) : GT-OPCODE-INT
    (op:GtOp, xt:VMLong, yt:VMLong) : GT-OPCODE-LONG
    (op:GtOp, xt:VMLong, yt:VMFloat) : GT-OPCODE-FLOAT
    (op:GtOp, xt:VMLong, yt:VMDouble) : GT-OPCODE-DOUBLE
    (op:LeOp, xt:VMLong, yt:VMInt) : LE-OPCODE-INT
    (op:LeOp, xt:VMLong, yt:VMLong) : LE-OPCODE-LONG
    (op:LeOp, xt:VMLong, yt:VMFloat) : LE-OPCODE-FLOAT
    (op:LeOp, xt:VMLong, yt:VMDouble) : LE-OPCODE-DOUBLE
    (op:GeOp, xt:VMLong, yt:VMInt) : GE-OPCODE-INT
    (op:GeOp, xt:VMLong, yt:VMLong) : GE-OPCODE-LONG
    (op:GeOp, xt:VMLong, yt:VMFloat) : GE-OPCODE-FLOAT
    (op:GeOp, xt:VMLong, yt:VMDouble) : GE-OPCODE-DOUBLE
    (op:UltOp, xt:VMLong, yt:VMByte) : ULT-OPCODE-BYTE
    (op:UltOp, xt:VMLong, yt:VMInt) : ULT-OPCODE-INT
    (op:UltOp, xt:VMLong, yt:VMLong) : ULT-OPCODE-LONG
    (op:UleOp, xt:VMLong, yt:VMByte) : ULE-OPCODE-BYTE
    (op:UleOp, xt:VMLong, yt:VMInt) : ULE-OPCODE-INT
    (op:UleOp, xt:VMLong, yt:VMLong) : ULE-OPCODE-LONG
    (op:UgtOp, xt:VMLong, yt:VMByte) : UGT-OPCODE-BYTE
    (op:UgtOp, xt:VMLong, yt:VMInt) : UGT-OPCODE-INT
    (op:UgtOp, xt:VMLong, yt:VMLong) : UGT-OPCODE-LONG
    (op:UgeOp, xt:VMLong, yt:VMByte) : UGE-OPCODE-BYTE
    (op:UgeOp, xt:VMLong, yt:VMInt) : UGE-OPCODE-INT
    (op:UgeOp, xt:VMLong, yt:VMLong) : UGE-OPCODE-LONG

defn branch2-opcode (op:VMOp, xt:VMType) :
  match(op, xt) :
    (op:IntLtOp, xt:VMRef) : JUMP-INT-LT-OPCODE
    (op:IntGtOp, xt:VMRef) : JUMP-INT-GT-OPCODE
    (op:IntLeOp, xt:VMRef) : JUMP-INT-LE-OPCODE
    (op:IntGeOp, xt:VMRef) : JUMP-INT-GE-OPCODE
    (op:EqOp, xt:VMRef) : JUMP-EQ-OPCODE-REF
    (op:EqOp, xt:VMByte) : JUMP-EQ-OPCODE-BYTE
    (op:EqOp, xt:VMInt) : JUMP-EQ-OPCODE-INT
    (op:EqOp, xt:VMLong) : JUMP-EQ-OPCODE-LONG
    (op:EqOp, xt:VMFloat) : JUMP-EQ-OPCODE-FLOAT
    (op:EqOp, xt:VMDouble) : JUMP-EQ-OPCODE-DOUBLE
    (op:NeOp, xt:VMRef) : JUMP-NE-OPCODE-REF
    (op:NeOp, xt:VMByte) : JUMP-NE-OPCODE-BYTE
    (op:NeOp, xt:VMInt) : JUMP-NE-OPCODE-INT
    (op:NeOp, xt:VMLong) : JUMP-NE-OPCODE-LONG
    (op:NeOp, xt:VMFloat) : JUMP-NE-OPCODE-FLOAT
    (op:NeOp, xt:VMDouble) : JUMP-NE-OPCODE-DOUBLE
    (op:LtOp, xt:VMInt) : JUMP-LT-OPCODE-INT
    (op:LtOp, xt:VMLong) : JUMP-LT-OPCODE-LONG
    (op:LtOp, xt:VMFloat) : JUMP-LT-OPCODE-FLOAT
    (op:LtOp, xt:VMDouble) : JUMP-LT-OPCODE-DOUBLE
    (op:GtOp, xt:VMInt) : JUMP-GT-OPCODE-INT
    (op:GtOp, xt:VMLong) : JUMP-GT-OPCODE-LONG
    (op:GtOp, xt:VMFloat) : JUMP-GT-OPCODE-FLOAT
    (op:GtOp, xt:VMDouble) : JUMP-GT-OPCODE-DOUBLE
    (op:LeOp, xt:VMInt) : JUMP-LE-OPCODE-INT
    (op:LeOp, xt:VMLong) : JUMP-LE-OPCODE-LONG
    (op:LeOp, xt:VMFloat) : JUMP-LE-OPCODE-FLOAT
    (op:LeOp, xt:VMDouble) : JUMP-LE-OPCODE-DOUBLE
    (op:GeOp, xt:VMInt) : JUMP-GE-OPCODE-INT
    (op:GeOp, xt:VMLong) : JUMP-GE-OPCODE-LONG
    (op:GeOp, xt:VMFloat) : JUMP-GE-OPCODE-FLOAT
    (op:GeOp, xt:VMDouble) : JUMP-GE-OPCODE-DOUBLE
    (op:UltOp, xt:VMByte) : JUMP-ULT-OPCODE-BYTE
    (op:UltOp, xt:VMInt) : JUMP-ULT-OPCODE-INT
    (op:UltOp, xt:VMLong) : JUMP-ULT-OPCODE-LONG
    (op:UleOp, xt:VMByte) : JUMP-ULE-OPCODE-BYTE
    (op:UleOp, xt:VMInt) : JUMP-ULE-OPCODE-INT
    (op:UleOp, xt:VMLong) : JUMP-ULE-OPCODE-LONG
    (op:UgtOp, xt:VMByte) : JUMP-UGT-OPCODE-BYTE
    (op:UgtOp, xt:VMInt) : JUMP-UGT-OPCODE-INT
    (op:UgtOp, xt:VMLong) : JUMP-UGT-OPCODE-LONG
    (op:UgeOp, xt:VMByte) : JUMP-UGE-OPCODE-BYTE
    (op:UgeOp, xt:VMInt) : JUMP-UGE-OPCODE-INT
    (op:UgeOp, xt:VMLong) : JUMP-UGE-OPCODE-LONG

;============================================================
;====================== Utilities ===========================
;============================================================

var delay : (() -> ?) -> False =
  fn (f) : fatal("Not within delay-actions block.")
defn delay-actions<?T> (f:() -> ?T) :
  val delays = Vector<(() -> ?)>()
  defn delay-action (action:() -> ?)  : add(delays, action)
  val result = let-var delay = delay-action : f()
  for d in delays do : d()
  clear(delays)
  result
