defpackage stz/reg-alloc-model-processing :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-model-env

;============================================================
;======================== API ===============================
;============================================================

;Callbacks for processing the different actions of a model.
public deftype ModelProcessor

;Release the variable register.
public defmulti release-arg (proc:ModelProcessor, index:Int, id:Int, loc:Location) -> False

;Assign the temporary at index 'index'.
public defmulti assign-temp (proc:ModelProcessor, index:Int, loc:Location, pref:Preference) -> False

;Assign the result with id 'id'.
public defmulti assign-result (proc:ModelProcessor, index:Int, id:Int, loc:Location, pref:Preference) -> False

;Clear all of the registers.
public defmulti clear-registers (proc:ModelProcessor) -> False

;============================================================
;==================== Implementation ========================
;============================================================

;Process the given operation statement using the model processor.
public defn process-model (proc:ModelProcessor,
                           models:ModelEnv,
                           anno-stmt:AnnotatedOperationStmt|AssignedOperationStmt,
                           release-arg-when-killed?:True|False) -> False :
  ;Sanity check: release-arg-when-killed? is only supported by
  ;AnnotatedOperationStmt.
  if release-arg-when-killed? :
    if anno-stmt is AssignedOperationStmt :
      fatal("Illegal option: If statement is AssignedOperationStmt then \
             release-arg-when-killed? must be false.")

  ;Retrieve the model.
  val op-stmt = stmt(anno-stmt)
  val model = model(models, op-id(op-stmt))

  ;Retrieve the index ranges of the different variables.
  val first-temp = length(results(model)) + length(args(model))
  val first-arg = length(results(model))
  val num-vars = length(results(model)) + length(args(model)) + length(temp(model))

  ;Return true if the given variable is a temp variable.
  defn temp? (v:Int) : v >= first-temp and v < num-vars

  ;Return true if the given variable is an arg variable.
  defn arg? (v:Int) : v >= first-arg and v < first-temp

  ;Return true if the given variable is a result variable.
  defn result? (v:Int) : v >= 0 and v < first-arg

  ;Return the index of the temp variable.
  defn temp-index (v:Int) : v - first-temp

  ;Return the index of the arg variable.
  defn arg-index (v:Int) : v - first-arg

  ;Return the index of the result variable.
  defn result-index (v:Int) : v

  ;Return the id of the global argument variable at index 'i'.
  defn arg-var (i:Int) -> Int :
    args(op-stmt)[i]

  ;Return the id of the global result variable at index 'i'.
  defn result-var (i:Int) -> Int :
    results(op-stmt)[i]

  ;Return true if arg at index 'i' should be released.
  ;If anno-stmt is AnnotatedOperationStmt, then we release the argument
  ;if the argument was killed.
  ;If anno-stmt is AssignedOperationStmt, then we always release the
  ;argument.
  defn release-arg? (i:Int) -> True|False :
    if release-arg-when-killed? :
      ;[TODO] Should keep the boolean mask instead of tuple.
      val killed = killed-args(anno-stmt as AnnotatedOperationStmt)
      contains?(killed, i)
    else :
      true

  ;Retrieve the location of the i'th argument/temp/result.
  #for (xyz-location in [arg-location, temp-location, result-location]
        xyz in [args, temp, results]
        xyz-regs in [arg-regs, temp-regs, result-regs]) :
    defn xyz-location (i:Int) -> Location :
      match(anno-stmt) :
        (stmt:AnnotatedOperationStmt) :
          location(xyz(model)[i])
        (stmt:AssignedOperationStmt) :
          xyz-regs(stmt)[i]

  ;Analyze the given preference, and update it
  ;to reflect the global variable ids.
  defn analyze (pref:Preference) -> Preference :
    match(pref:PreferSame) :
      fatal("Invalid preference") when not arg?(id(pref))
      val i = arg-index(id(pref))
      PreferSame(arg-var(i))
    else :
      pref

  ;Iterate through each statement and call
  ;the appropriate callbacks.
  for mstmt in stmts(model) do :
    match(mstmt) :
      (mstmt:Release) :
        fatal("Invalid release") when not arg?(id(mstmt))
        val i = arg-index(id(mstmt))
        if release-arg?(i) :
          release-arg(proc, i, arg-var(i), arg-location(i))
      (mstmt:Assign) :
        if temp?(id(mstmt)) :
          val i = temp-index(id(mstmt))
          assign-temp(proc,
                      i,
                      temp-location(i),
                      analyze(preference(temp(model)[i])))
        else if result?(id(mstmt)) :
          val i = result-index(id(mstmt))
          assign-result(proc,
                        i,
                        result-var(i),
                        result-location(i),
                        analyze(preference(results(model)[i])))
        else :
          fatal("Invalid assignment")
      (mstmt:ClearRegisters) :
        clear-registers(proc)
      (mstmt:Return) :
        false