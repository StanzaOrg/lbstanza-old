defpackage stz/dl-ir :
  import core
  import collections
  import stz/utils
  import stz/visibility

;============================================================
;======================== PackageIO =========================
;============================================================

public defstruct PackageIO :
  package: Symbol
  imported-packages: Tuple<Symbol> with: (updater => sub-imported-packages)
  imports: Tuple<Import> with: (updater => sub-imports)
  exports: Tuple<Export> with: (updater => sub-exports)
  documentation?:False|String with: (updater => sub-documentation)

public defstruct PackageExports :
  package: Symbol
  imported-packages: Tuple<Symbol>
  exports: Tuple<Export> with: (updater => sub-exports)

;============================================================
;===================== Import/Export ========================
;============================================================

public defstruct Export :  
  n: Int with: (updater => sub-n)
  visibility: Visibility
  rec: Rec
  info: FileInfo|False
  documentation?:False|String

public defstruct Import :
  n: Int with: (updater => sub-n)
  rec: Rec with: (updater => sub-rec)
  transient?: True|False

;============================================================
;=================== Record Ids =============================
;============================================================

public deftype RecId <: Hashable & Equalable
public defmulti package (r:RecId) -> Symbol
public defmulti name (r:RecId) -> Symbol

public defstruct ValId <: RecId :
  package: Symbol with: (as-method => true)
  name: Symbol with: (as-method => true)

public defstruct TypeId <: RecId :
  package: Symbol with: (as-method => true)
  name: Symbol with: (as-method => true)

public defstruct FnId <: RecId :
  package: Symbol with: (as-method => true)
  name: Symbol with: (as-method => true)
  ntargs: Int
  ncargs: Int
  a1: Tuple<DType>

;============================================================
;======================= Records ============================
;============================================================

public deftype Rec
public defmulti id (r:Rec) -> RecId

public defstruct ValRec <: Rec :
  id: ValId with: (as-method => true)
  type: DType
  mutable?: True|False
  lostanza?: True|False

public defstruct FnRec <: Rec :
  id: FnId with: (as-method => true)
  a2: DType
  lostanza?: True|False
  tail?: True|False

public defstruct MultiRec <: Rec :
  id: FnId with: (as-method => true)
  a2: DType

public defstruct ExternFnRec <: Rec :
  id: FnId with: (as-method => true)
  a2: DType
  lbl: Symbol|False

public defstruct ExternRec <: Rec :
  id: ValId with: (as-method => true)
  type: DType
  lbl: Symbol

public defstruct StructRec <: Rec :
  id: TypeId with: (as-method => true)
  ntargs: Int
  parent: False|DType
  base: Tuple<StructField>
  items: False|StructField

public defstruct TypeRec <: Rec :
  id: TypeId with: (as-method => true)
  ntargs: Int
  parent: False|DType
  children: Tuple<Child>

public defstruct TypeDecl <: Rec :
  id: TypeId with: (as-method => true)
  ntargs: Int
  parent: False|DType
  children: Tuple<Child> with: (updater => sub-children)

public defstruct StructField <: Equalable :
  name: Symbol
  type: DType
  mutable?: True|False

public defstruct Child <: Equalable :
  id: TypeId
  ntargs: Int
  parent: DOf

;============================================================
;========================= DTypes ===========================
;============================================================
public deftype DType <: Hashable & Equalable & Comparable<DType>

;LoStanza Types
public defstruct DByte <: DType
public defstruct DInt <: DType
public defstruct DLong <: DType
public defstruct DFloat <: DType
public defstruct DDouble <: DType
public defstruct DUnknown <: DType
public defstruct DPtrT <: DType : (type:DType)
public defstruct DFnT <: DType : (a:Tuple<DType>, r:False|DType, b:DType)
public defstruct DStructT <: DType : (id:TypeId, targs:Tuple<DType>)

;HiStanza Types
public defstruct DOf <: DType: (id:TypeId, targs:Tuple<DType>)
public defstruct DTVar <: DType: (index:Int)
public defstruct DCap <: DType: (tvar:DTVar)
public defstruct DAnd <: DType:
  types:Tuple<DType> with:
    ensure => and!<Tuple<DType>>(ordered!, no-ands!)
public defstruct DOr <: DType:
  types:Tuple<DType> with:
    ensure => and!<Tuple<DType>>(ordered!, no-ors!)
public defstruct DTop <: DType
public defstruct DBot <: DType
public defstruct DTuple <: DType : (types:Tuple<DType>)
public defstruct DArrow <: DType : (a1:Tuple<DType>, a2:DType)

defn rank (t:DType) :
  match(t) :
    (t:DByte) : 0
    (t:DInt) : 1
    (t:DLong) : 2
    (t:DFloat) : 3
    (t:DDouble) : 4
    (t:DUnknown) : 5
    (t:DPtrT) : 6
    (t:DFnT) : 7
    (t:DStructT) : 8
    (t:DOf) : 9
    (t:DTVar) : 10
    (t:DAnd) : 11
    (t:DOr) : 12
    (t:DTop) : 13
    (t:DBot) : 14
    (t:DTuple) : 15
    (t:DArrow) : 16
    (t:DCap) : 17

defn and!<T> (a: (String, T) -> True|False, b: (String, T) -> True|False) :
  fn (s:String, x:T) :
    a(s,x)
    b(s,x)

defn ordered! (description:String, ts:Tuple<DType>) :
  if length(ts) < 2 :
    fatal("The %_ with value %_ has length less than 2." % [description, ts])
  else :
    val n = length(ts)
    for i in 0 to n - 1 do :
      if ts[i] >= ts[i + 1] :
        fatal("The %_ with value %_ is not strictly ordered." % [description, ts])

defn no-ands! (description:String, ts:Tuple<DType>) :
  for t in ts do :
    if t is DAnd :
      fatal("The %_ cannot accept 'and' type %_." % [description, t])

defn no-ors! (description:String, ts:Tuple<DType>) :
  for t in ts do :
    if t is DOr :
      fatal("The %_ cannot accept 'or' type %_." % [description, t])

defmethod compare (x:DType, y:DType) :
  defn compare? (x:Comparable|False, y:Comparable|False) :
    match(x, y) :
      (x:Comparable, y:Comparable) : compare(x,y)
      (x:False, y:False) : 0
      (x:Comparable, y:False) : 1
      (x:False, y:Comparable) : -1
  defn compare-id (x:TypeId, y:TypeId) :
    compare([package(x), name(x)], [package(y), name(y)])

  val c = compare(rank(x), rank(y))
  if c == 0 :
    match(x, y) :
      (x:DPtrT, y:DPtrT) :
        compare(type(x), type(y))
      (x:DFnT, y:DFnT) :
        val c = compare?(r(x), r(y))
        compare([a(x), b(x)], [a(y), b(y)]) when c == 0 else c
      (x:DStructT, y:DStructT) :
        val c = compare-id(id(x), id(y))
        compare(targs(x), targs(y)) when c == 0 else c
      (x:DOf, y:DOf) :
        val c = compare-id(id(x), id(y))
        compare(targs(x), targs(y)) when c == 0 else c
      (x:DTVar, y:DTVar) :
        compare(index(x), index(y))
      (x:DAnd, y:DAnd) :
        compare(types(x), types(y))
      (x:DOr, y:DOr) :
        compare(types(x), types(y))
      (x:DTuple, y:DTuple) :
        compare(types(x), types(y))
      (x:DArrow, y:DArrow) :
        compare([a1(x), a2(x)], [a1(y), a2(y)])
      (x, y) : c
  else : c

defmethod equal? (x:DType, y:DType) :
  match(x, y) :
    (x:DByte, y:DByte) : true
    (x:DInt, y:DInt) : true
    (x:DLong, y:DLong) : true
    (x:DFloat, y:DFloat) : true
    (x:DDouble, y:DDouble) : true
    (x:DUnknown, y:DUnknown) : true
    (x:DPtrT, y:DPtrT) : type(x) == type(y)
    (x:DFnT, y:DFnT) : a(x) == a(y) and b(x) == b(y) and r(x) == r(y)
    (x:DStructT, y:DStructT) : id(x) == id(y) and targs(x) == targs(y)
    (x:DOf, y:DOf) : id(x) == id(y) and targs(x) == targs(y)
    (x:DTVar, y:DTVar) : index(x) == index(y)
    (x:DAnd, y:DAnd) : types(x) == types(y)
    (x:DOr, y:DOr) : types(x) == types(y)
    (x:DTop, y:DTop) : true
    (x:DBot, y:DBot) : true
    (x:DTuple, y:DTuple) : types(x) == types(y)
    (x:DArrow, y:DArrow) : a1(x) == a1(y) and a2(x) == a2(y)
    (x:DCap, y:DCap) : tvar(x) == tvar(y)
    (x, y) : false

defmethod hash (x:DType) :
  val base = rank(x) * 13
  defn H (y) : base + hash(y)
  match(x) :
    (x:DPtrT) : H $ type(x)
    (x:DFnT) : H $ [a(x), r(x), b(x)]
    (x:DStructT) : H $ [id(x), targs(x)]
    (x:DOf) : H $ [id(x), targs(x)]
    (x:DTVar) : H $ index(x)
    (x:DAnd) : H $ types(x)
    (x:DOr) : H $ types(x)
    (x:DTuple) : H $ types(x)
    (x:DArrow) : H $ [a1(x), a2(x)]
    (x:DCap) : H $ tvar(x)
    (x) : base

public defn DOr? (ts:Seqable<DType>) :
  label<DType> return :
    val types = Vector<DType>()
    for t in ts do :
      match(t) :
        (t:DTop) : return(t)
        (t:DBot) : false
        (t:DOr) : add-all(types, /types(t))
        (t) : add(types,t)
    qsort!(types)
    remove-duplicates!(types)
    switch(length(types)) :
      0 : DBot()
      1 : types[0]
      else : DOr(to-tuple(types))

public defn DAnd? (ts:Seqable<DType>) :
  label<DType> return :
    val types = Vector<DType>()
    for t in ts do :
      match(t) :
        (t:DTop) : false
        (t:DBot) : return(t)
        (t:DAnd) : add-all(types, /types(t))
        (t) : add(types,t)
    qsort!(types)
    remove-duplicates!(types)
    switch(length(types)) :
      0 : DTop()
      1 : types[0]
      else : DAnd(to-tuple(types))

;============================================================
;======================= Matching ===========================
;============================================================

;------------------------------------------------------------
;--------------- Equality on Ids and Recs -------------------
;------------------------------------------------------------
defmethod equal? (x:TypeId, y:TypeId) :
  package(x) == package(y) and
  name(x) == name(y)

defmethod equal? (x:ValId, y:ValId) :
  package(x) == package(y) and
  name(x) == name(y)

defmethod equal? (x:FnId, y:FnId) :
  package(x) == package(y) and
  name(x) == name(y) and
  ntargs(x) == ntargs(y) and
  ncargs(x) == ncargs(y) and
  a1(x) == a1(y)

defmethod equal? (a:StructField, b:StructField) :
  name(a) == name(b) and
  type(a) == type(b) and
  mutable?(a) == mutable?(b)

defmethod equal? (a:Child, b:Child) :
  id(a) == id(b) and
  ntargs(a) == ntargs(b) and
  parent(a) == parent(b)

;------------------------------------------------------------
;--------------------- Hashing ------------------------------
;------------------------------------------------------------

defmethod hash (x:ValId) :
  hash $ [1, package(x), name(x)]

defmethod hash (x:TypeId) :
  hash $ [2, package(x), name(x)]

defmethod hash (x:FnId) :
  hash $ [3, package(x), name(x), ntargs(x), ncargs(x), a1(x)]

;------------------------------------------------------------
;---------------------- Matching Algorithm ------------------
;------------------------------------------------------------

;Given the package io, returns a predicate that can test
;whether an imported record is consistent against an exported
;record from a parent package.
public defn match? (io:PackageIO) -> (Rec,Rec) -> True|False :
  ;Compute all the referenced types in the given PackageIO.
  ;If it exists in types-in-io, then this type is referenced.
  defn type-id? (r:Rec) -> Maybe<TypeId> :
    match(r:StructRec|TypeRec|TypeDecl) : One(id(r) as TypeId)
    else : None()
  val types-in-io = to-hashset<TypeId> $
    seq?(type-id?{rec(_)}, cat(imports(io), exports(io)))
  ;Return curried function.
  match?{_, _, types-in-io}

;Returns true if the two ValRec records match.
public defn match? (x:Rec, y:Rec, types-in-io:HashSet<TypeId>|False) -> True|False :
  match(x, y) :
    (x:ValRec, y:ValRec) :
      type(x) == type(y) and
      mutable?(x) == mutable?(y) and
      lostanza?(x) == lostanza?(y)
    (x:FnRec, y:FnRec) :
      a2(x) == a2(y) and
      lostanza?(x) == lostanza?(y) and
      tail?(x) == tail?(y)
    (x:MultiRec, y:MultiRec) :
      a2(x) == a2(y)
    (x:ExternFnRec, y:ExternFnRec) :
      a2(x) == a2(y) and
      lbl(x) == lbl(y)
    (x:ExternRec, y:ExternRec) :
      type(x) == type(y) and
      lbl(x) == lbl(y)
    (x:StructRec, y:StructRec) :
      ntargs(x) == ntargs(y) and
      parent(x) == parent(y) and
      base(x) == base(y) and
      items(x) == items(y)
    (x:TypeRec, y:TypeRec) :
      ntargs(x) == ntargs(y) and
      parent(x) == parent(y) and
      children(x) == children(y)
    (x:TypeDecl, y:TypeRec) :
      ;Assert that types-in-io is given.
      fatal("Type set in current PackageIO must be given X %_ Y %_." % [x, y]) when types-in-io is False
      ; fatal("Type set in current PackageIO must be given.") when types-in-io is False
      val types-in-io = types-in-io as HashSet<TypeId>
      if ntargs(x) == ntargs(y) and parent(x) == parent(y) :
        ;Condition 1) All children in x, must also be children in y, and must match the definition.
        ;Condition 2) All children in y must either be children of x, or not a type in io.
        if ntargs(x) == ntargs(y) and parent(x) == parent(y) :
          defn keyed (c:Child) : id(c) => c
          val xchildren = to-hashtable<TypeId,Child> $ seq(keyed, children(x))
          val ychildren = to-hashtable<TypeId,Child> $ seq(keyed, children(y))
          val cond1 = for c in children(x) all? :
            c == get?(ychildren, id(c))
          val cond2 = for c in children(y) all? :
            key?(xchildren, id(c)) or not types-in-io[id(c)]
          cond1 and cond2
    (x, y) :
      false

;============================================================
;===================== Convenience ==========================
;============================================================

public defn to-package-exports (io:PackageIO) :
  PackageExports(package(io), imported-packages(io), exports(io))

public defn to-package-exports? (io:PackageIO|False) :
  match(io:PackageIO) :
    to-package-exports(io)

;============================================================
;===================== IOTable ==============================
;============================================================

public deftype IOTable
public defmulti package (t:IOTable) -> Symbol
public defmulti get (t:IOTable, n:Int) -> Rec
public defmulti key? (t:IOTable, n:Int) -> True|False
public defmulti get (t:IOTable, id:RecId) -> Import|Export

public defn IOTable (io:PackageIO) :
  val idtable = to-hashtable(id{rec(_)}, cat(imports(io), exports(io)))
  val ntable = to-inttable(n, cat(imports(io), exports(io)))  
  new IOTable :
    defmethod package (this) : package(io)
    defmethod get (this, n:Int) : rec(ntable[n])
    defmethod get (this, id:RecId) : idtable[id]
    defmethod key? (this, n:Int) : key?(ntable,n)

public defn n (iotable:IOTable, id:RecId) :
  n(iotable[id])

;============================================================
;========================= Printer ==========================
;============================================================

defmethod print (o:OutputStream, t:DType) :
  print{o, _} $ match(t) :
    (t:DByte) : "byte"
    (t:DInt) : "int"
    (t:DLong) : "long"
    (t:DFloat) : "float"
    (t:DDouble) : "double"
    (t:DUnknown) : "?"
    (t:DPtrT) : "ptr<%_>" % [type(t)]
    (t:DFnT) :
      match(r(t)) :
        (r:DType) : "fn<(%,), %_, %_>" % [a(t), r, b(t)]
        (r:False) : "fn<(%,), %_>" % [a(t), b(t)]
    (t:DStructT) : "struct<%_>(%,)" % [id(t), targs(t)]
    (t:DOf) : "ref<%_>(%,)" % [id(t), targs(t)]
    (t:DTVar) : "TV%_" % [index(t)]
    (t:DAnd) : "and(%,)" % [types(t)]
    (t:DOr) : "or(%,)" % [types(t)]
    (t:DTop) : "top"
    (t:DBot) : "bot"
    (t:DTuple) : "[%,]" % [types(t)]
    (t:DArrow) : "arrow<(%,), %_>" % [a1(t), a2(t)]
    (t:DCap) : "?%_" % [tvar(t)]

defmethod print (o:OutputStream, x:ValId) :
  print(o, "V(%~, %~)" % [package(x), name(x)])

defmethod print (o:OutputStream, x:TypeId) :
  print(o, "T(%~, %~)" % [package(x), name(x)])

defmethod print (o:OutputStream, x:FnId) :
  print(o, "F<%_,%_>(%~, %~, %~)" % [ntargs(x), ncargs(x), package(x), name(x), a1(x)])

defmethod print (o:OutputStream, r:ValRec) :
  val lsstr = "ls" when lostanza?(r) else ""
  val vstr = "var" when mutable?(r) else "val"
  print(o, "%_%_(%_ : %_)" % [
    lsstr, vstr, id(r), type(r)])

defmethod print (o:OutputStream, r:FnRec) :
  val lsstr = "ls" when lostanza?(r) else ""
  val tailstr = "*" when tail?(r) else ""
  print(o, "%_fn%_(%~ -> %~)" % [lsstr, tailstr, id(r), a2(r)])

defmethod print (o:OutputStream, r:MultiRec) :
  print(o, "multi(%~ -> %~)" % [id(r), a2(r)])

defmethod print (o:OutputStream, r:ExternFnRec) :
  val label-str = "" when lbl(r) is False
             else ", %~" % [lbl(r)]
  print(o, "externfn(%~ -> %~%_)" % [id(r), a2(r), label-str])

defmethod print (o:OutputStream, r:ExternRec) :
  print(o, "extern(%_ : %_, %~)" % [id(r), type(r), lbl(r)])

defmethod print (o:OutputStream, r:StructRec) :
  val pstr = "" when parent(r) is False else " <: %_" % [parent(r)]
  print(o, "struct %_<%_>%_ :" % [id(r), ntargs(r), pstr])
  match(items(r)) :
    (items:StructField) :
      val item-str = "%_ ..." % [items]
      bprint(o, cat(base(r), [item-str]))
    (items:False) :
      bprint(o, base(r))

defmethod print (o:OutputStream, f:StructField) :
  val mut-str = "var " when mutable?(f) else ""
  print(o, "%_%~ : %_" % [mut-str, name(f), type(f)])

defmethod print (o:OutputStream, c:Child) :
  print(o, "%_<%_> <: %_" % [id(c), ntargs(c), parent(c)])

defmethod print (o:OutputStream, r:TypeRec) :
  val pstr = "" when parent(r) is False else " <: %_" % [parent(r)]
  print(o, "type %_<%_>%_ :" % [id(r), ntargs(r), pstr])
  bprint(o, children(r))

defmethod print (o:OutputStream, r:TypeDecl) :
  val pstr = "" when parent(r) is False else " <: %_" % [parent(r)]
  print(o, "type-decl %_<%_>%_ :" % [id(r), ntargs(r), pstr])
  bprint(o, children(r))

defmethod print (o:OutputStream, x:Import) :
  val tstr = " transient" when transient?(x) else ""
  print(o, "import%_ %_ %~" % [tstr, n(x), rec(x)])

defmethod print (o:OutputStream, x:Export) :
  print(o, "export %_ %_ %~" % [n(x), visibility(x), rec(x)])
  if documentation?(x) is String :
    val o2 = IndentedStream(o)
    lnprint(o2, "doc: %_" % [documentation?(x)])

defmethod print (o:OutputStream, x:PackageIO) :
  print(o, "package %~ :" % [package(x)])
  val o2 = IndentedStream(o)
  lnprint(o2, "imported-packages = (%@)" % [imported-packages(x)])
  lnprints(o2, cat(imports(x), exports(x)))

defmethod print (o:OutputStream, x:PackageExports) :
  print(o, "package %~ :" % [package(x)])
  val o2 = IndentedStream(o)
  lnprint(o2, "imported-packages = (%@)" % [imported-packages(x)])
  lnprints(o2, exports(x))

defn bprint (o:OutputStream, xs:Seqable) :
  val xs-seq = to-seq(xs)
  if empty?(xs-seq) : print(o, " ()")
  else : lnprints(IndentedStream(o), xs-seq)

;============================================================
;======================= Reader =============================
;============================================================

defsyntax dl-ir :
  defn prefix-id? (x, s:String) :
    match(unwrap-token(x)) :
      (x:Symbol) : prefix?(x, s)
      (x) : false
  defn id-prefix (info:FileInfo|False, x:Symbol|Token, len:Int) :
    match(to-int(to-string(unwrap-token(x))[len to false])) :
      (i:Int) : i
      (i) : throw(DLE(info, "Invalid name: %~" % [x]))

  public defproduction packageio : PackageIO
  defrule packageio = (package ?name:#symbol :
                         imported-packages = (?ips:#symbol ...)
                         ?imports:#import ...
                         ?exports:#export ...) :
    ;[TODO] Add doc string reader macro. Defaulted to false for now.
    PackageIO(name, to-tuple(ips), to-tuple(imports), to-tuple(exports), false) 

  defproduction dtype : DType
  defrule dtype = (byte) : DByte()
  defrule dtype = (int) : DInt()
  defrule dtype = (long) : DLong()
  defrule dtype = (float) : DFloat()
  defrule dtype = (double) : DDouble()
  defrule dtype = (?) : DUnknown()
  defrule dtype = ([?ts:#dtype ...]) : DTuple(to-tuple(ts))
  defrule dtype = (ptr<?t:#dtype>) : DPtrT(t)
  defrule dtype = (fn<(?a:#dtype ...), ?r:#dtype, ?b:#dtype>) : DFnT(to-tuple(a), r, b)
  defrule dtype = (fn<(?a:#dtype ...), ?b:#dtype>) : DFnT(to-tuple(a), false, b)
  defrule dtype = (arrow<(?a:#dtype ...), ?b:#dtype>) : DArrow(to-tuple(a), b)
  defrule dtype = (struct<?t:#tid>(?targs:#dtype ...)) : DStructT(t, to-tuple(targs))
  defrule dtype = (ref<?t:#tid>(?targs:#dtype ...)) : DOf(t, to-tuple(targs))
  defrule dtype = (?x:#dtvar) : x
  defrule dtype = (and(?ts:#dtype ...)) : DAnd(qsort(ts))
  defrule dtype = (or(?ts:#dtype ...)) : DOr(qsort(ts))
  defrule dtype = (top) : DTop()
  defrule dtype = (bot) : DBot()
  defrule dtype = ((~ @cap ?x:#dtvar)) : DCap(x)

  defproduction dtvar : DTVar
  defrule dtvar = (?x) when prefix-id?(x,"TV") : DTVar(id-prefix(closest-info(), x, 2))

  defproduction vis : Visibility
  defrule vis = (private) : Private
  defrule vis = (protected) : Protected
  defrule vis = (public) : Public

  defproduction vid : ValId
  defrule vid = (V(?p:#symbol,?n:#symbol)) : ValId(p,n)
  defproduction fid : FnId
  defrule fid = (F<?ntargs:#int,?ncargs:#int>(?p:#symbol,?n:#symbol, [?a1:#dtype ...])) :
    FnId(p,n,ntargs,ncargs,to-tuple(a1))
  defproduction tid : TypeId
  defrule tid = (T(?p:#symbol,?n:#symbol)) : TypeId(p,n)

  defproduction id : RecId
  defrule id = (?x:#vid) : x
  defrule id = (?x:#tid) : x
  defrule id = (?x:#fid) : x

  defproduction rec : Rec
  defrule rec = (?v:#vtag(?id:#vid : ?t:#dtype)) : ValRec(id, t, mut?, ls?) where :
                                                     val [ls?, mut?] = v
  defrule rec = (?f:#fntag(?id:#fid -> ?a2:#dtype)) : FnRec(id, a2, ls?, tail?) where :
                                                        val [ls?, tail?] = f
  defrule rec = (multi(?id:#fid -> ?a2:#dtype)) : MultiRec(id, a2)
  defrule rec = (externfn(?id:#fid -> ?a2:#dtype, ?lbl:#symbol?)) : ExternFnRec(id, a2, lbl)
  defrule rec = (extern(?id:#vid : ?t:#dtype, ?lbl:#symbol)) : ExternRec(id, t, lbl)
  defrule rec = (struct ?id:#tid<?ntargs:#int> ?p:#parent? : (?fs:#sfield ... ~ ...)) :
    StructRec(id, ntargs, p, to-tuple(but-last(fs)), last(fs))
  defrule rec = (struct ?id:#tid<?ntargs:#int> ?p:#parent? : (?fs:#sfield ...)) :
    StructRec(id, ntargs, p, to-tuple(fs), false)
  defrule rec = (type ?id:#tid<?ntargs:#int> ?p:#parent? : (?cs:#child ...)) :
    TypeRec(id, ntargs, p, to-tuple(cs))
  defrule rec = (type-decl ?id:#tid<?ntargs:#int> ?p:#parent? : (?cs:#child ...)) :
    TypeDecl(id, ntargs, p, to-tuple(cs))

  defproduction symbol?: Symbol|False
  defrule symbol? = (?s:#symbol)
  defrule symbol? = () : false

  defproduction vtag : [True|False, True|False]
  defrule vtag = (val) : [false, false]
  defrule vtag = (lsval) : [true, false]
  defrule vtag = (var) : [false, true]
  defrule vtag = (lsvar) : [true, true]

  defproduction fntag : [True|False, True|False]
  defrule fntag = (fn) : [false, false]
  defrule fntag = (lsfn) : [true, false]
  defrule fntag = (fn*) : [false, true]
  defrule fntag = (lsfn*) : [true, true]

  defproduction mut? : True|False
  defrule mut? = (var) : true
  defrule mut? = () : false

  defproduction sfield : StructField
  defrule sfield = (?m:#mut? ?n:#symbol : ?t:#dtype) : StructField(n,t,m)

  defproduction child : Child
  defrule child = (?id:#tid<?ntargs:#int> <: ?p:#dtype) :
    match(p:DOf) : Child(id, ntargs, p)
    else : throw(DLE(closest-info(), "Invalid parent type."))    

  defproduction parent? : False|DType
  defrule parent? = (<: ?p:#dtype) : p
  defrule parent? = () : false

  public defproduction import : Import
  defrule import = (import ?t:#transient? ?n:#int ?r:#rec) : Import(n,r,t)
  fail-if import = (import) : DLE(closest-info(), "Invalid import statement.")

  public defproduction export : Export
  defrule export = (export ?n:#int ?v:#vis ?r:#rec) :
    ;[TODO] Add documentation? to reader macro. False for now.
    Export(n,v,r,closest-info(), false) 
  fail-if export = (export) :
    DLE(closest-info(), "Invalid export statement.")

  defproduction transient? : True|False
  defrule transient? = (transient) : true
  defrule transient? = () : false

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

;============================================================
;======================== Errors ============================
;============================================================

public defstruct DLError <: Exception :
  info: FileInfo|False
  msg: String

defn DLE (info:FileInfo|False, msg) :
  DLError(info, to-string(msg))

;============================================================
;===================== Doers ================================
;============================================================

public deftype DItem :
  DType <: DItem
  Rec <: DItem
  RecId <: DItem
  Import <: DItem
  Export <: DItem
  StructField <: DItem
  Child <: DItem
  
public defn do (f:DItem -> ?, x:DItem) :
  defn g (x:False) : x
  defn g (x:DItem) : f(x)
  defn g (x:Tuple<DItem|False>) : do(g,x)  
  match(x) :
    ;Recs
    (x:ValRec) : (g(id(x)), g(type(x)))
    (x:FnRec) : (g(id(x)), g(a2(x)))
    (x:MultiRec) : (g(id(x)), g(a2(x)))
    (x:ExternFnRec) : (g(id(x)), g(a2(x)))
    (x:ExternRec) : (g(id(x)), g(type(x)))
    (x:StructRec) : (g(id(x)), g(parent(x)), g(base(x)), g(items(x)))
    (x:TypeRec) : (g(id(x)), g(parent(x)), g(children(x)))
    (x:TypeDecl) : (g(id(x)), g(parent(x)), g(children(x)))
    (x:StructField) : g(type(x))
    (x:Child) : (g(id(x)), g(parent(x)))
    ;RecIds
    (x:ValId) : false
    (x:TypeId) : false
    (x:FnId) : g(a1(x))
    ;Import/Export
    (x:Import) : g(rec(x))
    (x:Export) : g(rec(x))
    ;Types
    (x:DByte) : false
    (x:DInt) : false
    (x:DLong) : false
    (x:DFloat) : false
    (x:DDouble) : false
    (x:DUnknown) : false
    (x:DPtrT) : g(type(x))
    (x:DFnT) : (g(a(x)), g(r(x)), g(b(x)))
    (x:DStructT) : (g(id(x)), g(targs(x)))
    (x:DOf) : (g(id(x)), g(targs(x)))
    (x:DTVar) : false
    (x:DAnd) : g(types(x))
    (x:DOr) : g(types(x))
    (x:DTop) : false
    (x:DBot) : false
    (x:DTuple) : g(types(x))
    (x:DArrow) : (g(a1(x)), g(a2(x)))
    (x:DCap) : g(tvar(x))

;============================================================
;====================== Formatter ===========================
;============================================================

public defn format (t:DType, lostanza?:True|False) :
  format(Formatter(), t, lostanza?)

public defn format (r:Rec) :
  format(Formatter(), r)

deftype Formatter
defmulti format (f:Formatter, t:DType, lostanza?:True|False) -> Printable
defmulti format (f:Formatter, r:Rec) -> Printable

defn Formatter () :
  val preferred-varnames = ["T" "S" "R" "U" "V" "X" "Y" "Z"
                            "A" "B" "C" "D" "E" "F" "G" "H"
                            "P" "Q" "K"]
  defn varname (index:Int) :
    val n = length(preferred-varnames)
    val v = preferred-varnames[index % n]
    val i = index / n
    if i == 0 : v
    else : string-join([v, i])

  ;Wrap closure in printable object
  defn wrap-printable (f:OutputStream -> False) :
    new Printable :
      defmethod print (o:OutputStream, this) :
        f(o)

  defn lslevel (t:DType) :
    match(t) :
      ;Function
      (t:DFnT) : 0
      ;Everything else is atomic
      (t) : 1
  defn hslevel (t:DType) :
    match(t) :
      ;Arrows
      (t:DArrow) : 0
      ;Or Types
      (t:DOr) : 1
      ;And Types
      (t:DAnd) : 2
      ;Atomic types
      (t:DOf|DTVar|DCap|DTop|DBot|DTuple) : 3
  defn hsfs (o:OutputStream, ts:Seqable<DType>, lvl:Int, angle-context:True|False) :
    for (t in ts, i in 0 to false) do :
      print(o, ", ") when i > 0
      hsf(o, t, lvl, angle-context)
  defn hsf (o:OutputStream, t:DType, lvl:Int, angle-context:True|False) :
    val paren? =
      if hslevel(t) < lvl : true
      else if angle-context : t is DArrow
    val angle-context* = angle-context and not paren?
    print(o, "(") when paren?
    match(t) :
      (t:DArrow) :
        if length(a1(t)) == 1 :
          hsf(o, a1(t)[0], 1, angle-context*)
          print(o, " -> ")
          hsf(o, a2(t), 0, angle-context*)
        else :
          print(o, "(")
          hsfs(o, a1(t), 0, false)
          print(o, ") -> ")
          hsf(o, a2(t), 0, angle-context*)
      (t:DOr) :
        for (t in types(t), i in 0 to false) do :
          print(o, "|") when i > 0
          hsf(o, t, 1, angle-context*)
      (t:DAnd) :
        for (t in types(t), i in 0 to false) do :
          print(o, "&") when i > 0
          hsf(o, t, 2, angle-context*)
      ;Atomic
      (t:DOf) :
        write(o, name(id(t)))
        if not empty?(targs(t)) :
          print(o, "<")
          hsfs(o, targs(t), 0, true)
          print(o, ">")
      (t:DTVar) :
        print(o, varname(index(t)))
      (t:DCap) :
        print(o, "?")
        print(o, varname(index(tvar(t))))
      (t:DTop) :
        print(o, "?")
      (t:DBot) :
        print(o, "Void")
      (t:DTuple) :
        print(o, "[")
        hsfs(o, types(t), 0, false)
        print(o, "]")
    print(o, ")") when paren?
  defn lsfs (o:OutputStream, ts:Seqable<DType>, lvl:Int, angle-context:True|False) :
    for (t in ts, i in 0 to false) do :
      print(o, ", ") when i > 0
      lsf(o, t, lvl, angle-context)
  defn lsf (o:OutputStream, t:DType, lvl:Int, angle-context:True|False) :
    val paren? =
      if lslevel(t) < lvl : true
      else if angle-context : t is DFnT
    val angle-context* = angle-context and not paren?
    print(o, "(") when paren?
    match(t) :
      ;Functions
      (t:DFnT) :
        if length(a(t)) == 1 and r(t) is False :
          lsf(o, a(t)[0], 1, angle-context*)
          print(o, " -> ")
          lsf(o, b(t), 0, angle-context*)
        else :
          print(o, "(")
          match(r(t)) :
            (r:False) :
              lsfs(o, a(t), 0, false)
              print(o, ") -> ")
            (r:DType) :
              lsfs(o, cat(a(t), [r]), 0, false)
              print(o, " ...) -> ")
          lsf(o, b(t), 0, angle-context*)
      ;Atomic
      (t:DByte) : print(o, "byte")
      (t:DInt) : print(o, "int")
      (t:DLong) : print(o, "long")
      (t:DFloat) : print(o, "float")
      (t:DDouble) : print(o, "double")
      (t:DUnknown) : print(o, "?")
      (t:DPtrT) :
        print(o, "ptr<")
        lsf(o, type(t), 0, true)
        print(o, ">")
      (t:DStructT) :
        write(o, name(id(t)))
        if not empty?(targs(t)) :
          print(o, "<")
          hsfs(o, targs(t), 0, true)
          print(o, ">")
      ;HiStanza
      (t) :
        print(o, "ref<")
        hsf(o, t, 0, true)
        print(o, ">")      
    print(o, ")") when paren?
  defn typef (t:DType, lostanza?:True|False) :
    if lostanza? :
      wrap-printable $ lsf{_, t, 0, false}
    else :
      wrap-printable $ hsf{_, t, 0, false}

  defn recf (o:OutputStream, r:Rec) :
    defn join-name (id:RecId) :
      symbol-join $ [package(id) "/" name(id)]
      
    defn fnf (id:FnId, a2:DType, lostanza?:True|False) :
      within o = wrap-printable() :
        write(o, join-name(id))
        if ntargs(id) + ncargs(id) > 0 :
          print(o, "<")
          for i in 0 to ntargs(id) + ncargs(id) do :
            print(o, ", ") when i > 0
            print(o, "?") when i >= ntargs(id)
            print(o, varname(i))          
          print(o, ">")
        print(o, " (%,) -> %_" % [
          seq(typef{_, lostanza?}, a1(id))
          typef(a2, lostanza?)])

    defn fieldf (f:StructField) :
      val mut-str = "var " when mutable?(f) else ""
      "%_%~: %_" % [mut-str, name(f), typef(type(f), true)]

    defn deftypef (id:TypeId, ntargs:Int, parent:False|DType) :
      val tvar-str = "" when ntargs == 0
                else "<%,>" % [seq(varname, 0 to ntargs)]
      val pstr = match(parent) :
        (p:False) : ""
        (p:DType) : " <: %_" % [typef(p, false)]
      "%~%_%_" % [join-name(id), tvar-str, pstr]
        
    match(r) :
      (r:ValRec) :
        val ls-str = "lostanza " when lostanza?(r) else ""
        val val-str = "var" when mutable?(r) else "val"
        val name = join-name(id(r))
        val type = typef(type(r), lostanza?(r))
        print(o, "%_%_ %~ : %_" % [ls-str, val-str, name, type])
      (r:ExternRec) :
        val name = join-name(id(r))
        val type = typef(type(r), true)
        val label-str =
          if lbl(r) == /name(id(r)) : ""
          else : " with: (label => %~)" % [lbl(r)]
        print(o, "extern %_ : %_%_" % [name, type, label-str])
      (r:FnRec) :
        val ls-str = "lostanza " when lostanza?(r) else ""
        val tail-str = "*" when tail?(r) else ""
        print(o, "%_defn%_ %_" % [
          ls-str, tail-str, fnf(id(r) as FnId, a2(r), lostanza?(r))])        
      (r:MultiRec) :
        print(o, "defmulti %_" % [fnf(id(r) as FnId, a2(r), false)])
      (r:ExternFnRec) :
        val label-str =
          if lbl(r) == /name(id(r)) : ""
          else : " with: (label => %~)" % [lbl(r)]
        print(o, "extern defn %_%_" % [
          fnf(id(r) as FnId, a2(r), true)
          label-str])
      (r:StructRec) :
        print(o, "lostanza deftype %_" % [deftypef(id(r) as TypeId, ntargs(r), parent(r))])
        if not empty?(base(r)) or items(r) is-not False :
          print(o, " :")
          val o2 = IndentedStream(o)
          for f in base(r) do :
            print(o2, "\n%_" % [fieldf(f)])
          match(items(r)) :
            (f:StructField) : print(o2, "\n%_ ..." % [fieldf(f)])
            (f:False) : false
      (r:TypeRec) :
        print(o, "deftype %_" % [deftypef(id(r) as TypeId, ntargs(r), parent(r))])
        if not empty?(children(r)) :
          print(o, " :")
          val o2 = IndentedStream(o)
          for c in children(r) do :
            print(o2, "\n%_" % [deftypef(id(c), ntargs(c), parent(c))])
      (r:TypeDecl) :
        print(o, "deftype %_" % [deftypef(id(r) as TypeId, ntargs(r), parent(r))])

  ;Return new formatter
  new Formatter :
    defmethod format (this, t:DType, lostanza?:True|False) :
      typef(t, lostanza?)
    defmethod format (this, r:Rec) :
      wrap-printable(recf{_, r})

;============================================================
;=================== Built-in Descriptors ===================
;============================================================

defn core-typeid (name:Symbol) :
  TypeId(`core, name)
defn core-type (name:Symbol) :
  switch(name) :
    `byte : DByte()
    `int : DInt()
    `long : DLong()
    `float : DFloat()
    `double : DDouble()
    `? : DTop()
    else : DOf(core-typeid(name), [])
defn core-fnid (name:Symbol, args:Tuple<Symbol>) :
  FnId(`core, name, 0, 0, map(core-type, args))
defn core-fnid (name:Symbol, args:Tuple<DType>) :
  FnId(`core, name, 0, 0, args)
defn core-fnid (name:Symbol) :
  FnId(`core, name, 0, 0, [])

val CORE-IDS = Vector<RecId>()
public defn core-ids () :
  CORE-IDS
  
defn register<?T> (id:?T&RecId) :
  add(CORE-IDS,id)
  id

val STRING-OR-FALSE = DOr? $ [
  DOf(core-typeid(`String), [])
  DOf(core-typeid(`False), [])]
val STRING = DOf(core-typeid(`String), [])
val TOP-TUPLE = DOf(core-typeid(`Tuple), [DTop()])
val STACK-TYPE = DOf(core-typeid(`Stack), [])

public val CORE-TYPE-ID = register $ core-typeid(`Type)
public val CORE-TUPLE-ID = register $ core-typeid(`Tuple)
public val CORE-BOX-ID = register $ core-typeid(`Box)
public val CORE-FN-ID = register $ core-typeid(`Fn)
public val CORE-STACK-ID = register $ core-typeid(`Stack)
public val CORE-STACKFRAME-ID = register $ core-typeid(`StackFrame)
public val CORE-CHAR-ID = register $ core-typeid(`Char)
public val CORE-BYTE-ID = register $ core-typeid(`Byte)
public val CORE-INT-ID = register $ core-typeid(`Int)
public val CORE-LONG-ID = register $ core-typeid(`Long)
public val CORE-FLOAT-ID = register $ core-typeid(`Float)
public val CORE-DOUBLE-ID = register $ core-typeid(`Double)
public val CORE-FALSE-ID = register $ core-typeid(`False)
public val CORE-TRUE-ID = register $ core-typeid(`True)
public val CORE-LIST-ID = register $ core-typeid(`List)
public val CORE-STRING-ID = register $ core-typeid(`String)
public val CORE-SYMBOL-ID = register $ core-typeid(`Symbol)
public val CORE-UNIQUE-ID = register $ core-typeid(`Unique)
public val CORE-LIVENESS-TRACKER-ID = register $ core-typeid(`LivenessTracker)
public val CORE-ARITY-ERROR-ID = register $ core-fnid(`arity-error, [`long])
public val CORE-NO-METHOD-ERROR-ID = register $ core-fnid(`no-method-error, [STRING, TOP-TUPLE])
public val CORE-AMB-METHOD-ERROR-ID = register $ core-fnid(`amb-method-error, [STRING, TOP-TUPLE])
public val CORE-TUPLE-LENGTH-ERROR-ID = register $ core-fnid(`tuple-length-error, [`long, `long])
public val CORE-NO-BRANCH-ERROR-ID = register $ core-fnid(`no-branch-error, [TOP-TUPLE])
public val CORE-AMB-BRANCH-ERROR-ID = register $ core-fnid(`amb-branch-error, [TOP-TUPLE])
public val CORE-CAST-ERROR-ID = register $ core-fnid(`cast-error, [`Type, `?, `int])
public val CORE-VARIABLE-UNINITIALIZED-ERROR-ID = register $ core-fnid(`variable-uninitialized-error, [STRING-OR-FALSE])
public val CORE-INVALID-RETURN-ID = register $ core-fnid(`invalid-return-error)
public val CORE-VOID-TUPLE-ID = register $ core-fnid(`void-tuple, [`long])
public val CORE-INIT-CONSTS-ID = register $ core-fnid(`initialize-constants)
public val CORE-EXTEND-HEAP-ID = register $ core-fnid(`extend-heap, [`long])
public val CORE-EXTEND-STACK-ID = register $ core-fnid(`extend-stack, [`long])
public val CORE-PRINT-STACK-TRACE-ID = register $ core-fnid(`print-stack-trace, [STACK-TYPE])
public val CORE-COLLECT-STACK-TRACE-ID = register $ core-fnid(`collect-stack-trace, [STACK-TYPE])
public val CORE-COLLECT-GARBAGE-ID = register $ core-fnid(`collect-garbage, [`long])
public val CORE-MAKE-STRING-ID = register $ core-fnid(`String, [DPtrT(DByte())])
public val CORE-EXECUTE-TOPLEVEL-COMMAND-ID = register $ core-fnid(`execute-toplevel-command, [DArrow([], core-type(`False))])

;============================================================
;====================== ID Environment ======================
;============================================================

public deftype IDEnv
public defmulti get (e:IDEnv, id:RecId) -> Int

var ENV:IDEnv|False = false
public defn env-id (id:RecId) :
  (ENV as IDEnv)[id]

public defn set-id-env<?T> (f:() -> ?T, e:IDEnv) :
  let-var ENV = e :
    f()

;============================================================
;================== Consistency Check =======================
;============================================================

public defn ensure-consistency! (packageio:PackageIO) :
  #if-not-defined(OPTIMIZE) :
    ;Compute all declared packages and declared types
    val declared-packages = to-hashset<Symbol>(cat(imported-packages(packageio), [package(packageio)]))
    val declared-types = to-hashset<TypeId>(cat(imp-types, exp-types)) where :
      defn typeids (es:Seqable<Import|Export>) : filter-by<TypeId>(seq(id{rec(_)}, es))
      val imp-types = typeids(imports(packageio))
      val exp-types = typeids(exports(packageio))
    ;Check declaration
    defn check (x:DItem) :
      do(check, x)
      match(x:RecId) :
        fatal("Package %_ not declared." % [package(x)]) when not declared-packages[package(x)]
      match(x:TypeId) :
        fatal("Type %_ not declared." % [x]) when not declared-types[x]      
    ;Check imports
    for i in imports(packageio) do :
      check(i)
      fatal("Import from same package.") when package(id(rec(i))) == package(packageio)
    ;Check exports
    for e in exports(packageio) do :
      check(e)
      fatal("Export from wrong package.") when package(id(rec(e))) != package(packageio)
  false
