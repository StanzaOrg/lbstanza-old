;============================================================
;================ defresolver lang ==========================
;============================================================

defpackage stz/resolver-lang :
   import core
   import verse
   import core/macro-utils
   import stz/lexer

;======== Parse Structures ========
definterface Arg
defstruct DefineArg <: Arg :
   name: Symbol
defstruct SimpleArg <: Arg :
   name: Symbol
   prod: Symbol   
defstruct MapArg <: Arg :
   prod: Symbol
defstruct ScopeArg <: Arg :
   arg: Arg
defstruct BeginArg <: Arg :
   args: List<Arg>
defstruct GotoArg <: Arg :
   prod: Symbol
defstruct ResolveArg <: Arg :
   type: Symbol

defstruct Clause :
   type
   arg: Arg

definterface Prod
defmulti name (p:Prod) -> Symbol
defmulti type (p:Prod) -> ?
defmulti clauses (p:Prod) -> List<Clause>
   
defstruct Definer <: Prod :
   name: Symbol with: (as-method => true)
   type with: (as-method => true)
   clauses: List<Clause> with: (as-method => true)
   
defstruct Resolver <: Prod :
   name: Symbol with: (as-method => true)
   type with: (as-method => true)
   clauses: List<Clause> with: (as-method => true)

defstruct DefResolver :
   name: Symbol
   exp: Symbol
   type: Symbol
   eng: Symbol
   engtype
   prods: List<Prod>

;======== Syntax Definition ========
defsyntax stz/resolver-lang :
   defn sym? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : x != `...
         (x) : false

   defrule :
      sym = (?x) when sym?(x) : unwrap-token(x)
      prefix-op = (defresolver ?name:#sym (?exp:#sym:?type:#sym, ?eng:#sym:?engtype:#type) :
                      ?ps:#prod ...) :
         val r = compile(DefResolver(name, exp, type, eng, engtype, ps))
         #if-defined(DEBUG) :
            println(r)
         #else :
            stz/langs/expande(r)
            
      prod = (define ?name:#sym ?type:#type? : (?cs:#clause ...)) :
         Definer(name, type, cs)
      prod = (resolve ?name:#sym ?type:#type? : (?cs:#clause ...)) :
         Resolver(name, type, cs)
      type? = ((?t:#type)) : t
      type? = () : false

      clause = (?node:#type : ?arg:#arg) : Clause(node, arg)
      arg = (resolve ?type:#sym) : ResolveArg(type)
      arg = (goto ?type:#sym) : GotoArg(type)
      arg = ({?args:#arg ...}) : ScopeArg(BeginArg(args))
      arg = ((?args:#arg ...)) : BeginArg(args)
      arg = (~ _ : ?type:#sym) : MapArg(type)
      arg = (?name:#sym :+) : DefineArg(name)
      arg = (?name:#sym : ?type:#sym) : SimpleArg(name, type)

;======== Compilation ========
definterface Action
defstruct ReadAction <: Action :
   ret: Symbol
   name: Symbol
defstruct AddAction <: Action :
   #name: Symbol
defstruct FieldAction <: Action :
   ret: False|Symbol
   prod: Symbol
   #name: Symbol
defstruct MapAction <: Action :
   ret: True|False
   prod: Symbol
defstruct BuildAction <: Action :
   node: Symbol
   args: List<Symbol>
defstruct GotoAction <: Action :
   ret: True|False
   prod: Symbol   
defstruct ResolveAction <: Action :
   type: Symbol
defstruct PushScope <: Action
defstruct PopScope <: Action

defn fill-each<?T> (f: T -> Streamable<KeyValue<Symbol,?>>, xs:Streamable<?T>) :
   nested(stream(f, xs))

defn compile (d:DefResolver) :
   ;Temporary names of production functions
   defn make-table<?T> (entries: Streamable<KeyValue<Symbol,?T>>) :
      val table = HashTable<Symbol,T>(symbol-hash)
      for e in entries do : table[key(e)] = value(e)
      table
   val prod-table = make-table $ for p in prods(d) stream :
      name(p) => gensym()
   defn #prod (a:SimpleArg|MapArg|GotoArg) : prod-table[prod(a)]
   defn #prod (p:Prod) : prod-table[name(p)]

   ;Getting the node argument structure
   val structure = stz/ast-lang/nodes(stz/ast-lang/AST-TABLE[type(d)])
   defn get-node-args (n) :
      match(unwrap-token(n)) :
         (n:Symbol) : lookup!(structure, n)
         (n) : error("Cannot retrieve node arguments for ~." % [n])

   ;Is a production a definer? or not?
   defn definer? (n:Symbol) :
      label<True|False> return :
         for p in prods(d) do :
            if name(p) == n :
               return(p typeof Definer)
         error("No production named: ~" % [n]) 

   ;Getting the actual input type of a production
   defn type! (p:Prod) :
      match(type(p)) :
         (t:False) : type(d)
         (t) : t

   ;Retrieve a sequential list of productions needed to implement Arg
   defn to-prods (node, a:Arg, ret?:True|False) :
      val prods = Vector<Action>()
      
      val field-table = HashTable<Symbol,Symbol>(symbol-hash)      
      defn get-#name (arg:Symbol) :
         if key?(field-table, arg) :
            field-table[arg]
         else :
            val ret = gensym()
            add(prods, ReadAction(ret, arg))
            field-table[arg] = ret
            ret
            
      defn build () :
         if more?(to-stream(field-table)) :
            val args = get-node-args(node)
            val n = unwrap-token(node) as Symbol
            add(prods, BuildAction(n, map(get-#name, args)))
            clear(field-table)
         
      defn loop (a:Arg) :
         match(a) :
            (a:DefineArg) :
               val n = get-#name(name(a))
               add(prods, AddAction(n))
            (a:SimpleArg) :
               val n = get-#name(name(a))
               if definer?(prod(a)) :
                  add(prods, FieldAction(false, #prod(a), n))               
               else :
                  val ret = gensym()
                  add(prods, FieldAction(ret, #prod(a), n))
                  field-table[name(a)] = ret               
            (a:MapArg) :
               build()
               add{prods, _} $
                  if definer?(prod(a)) : MapAction(false, #prod(a))
                  else : MapAction(true, #prod(a))
            (a:ScopeArg) :
               add(prods, PushScope())
               loop(arg(a))
               add(prods, PopScope())
            (a:BeginArg) :
               do(loop, args(a))
            (a:GotoArg) :
               build()
               add{prods, _} $
                  if definer?(prod(a)) : GotoAction(false, #prod(a))
                  else : GotoAction(true, #prod(a))
            (a:ResolveArg) :
               build()
               add(prods, ResolveAction(type(a)))
            
      loop(a)      
      build() when ret?
      prods

   ;Compiling an argument
   defn compile (node-name, a:Arg, ret?:True|False) :
      val ps = to-prods(node-name, a, ret?)
      defn loop (i:Int) :
         if i < length(ps) :
            match(ps[i]) :
               (p:ReadAction) :
                  fill-template(`(let : (val ret = name(e), body)), [
                     `ret => ret(p)
                     `name => name(p)
                     `e => exp(d)
                     `body => loop(i + 1)])
               (p:AddAction) :
                  fill-template(`(new-definitions(eng, x), body), [
                     `eng => eng(d)
                     `x => #name(p)
                     `body => loop(i + 1)])
               (p:FieldAction) :
                  if ret(p) == false :
                     fill-template(`(#do(f, x), body), [
                        `f => prod(p)
                        `x => #name(p)
                        `body => loop(i + 1)])
                  else :
                     fill-template(`(let : (val ret = #map(f, x), body)), [
                        `ret => ret(p)
                        `f => prod(p)
                        `x => #name(p)
                        `body => loop(i + 1)])
               (p:MapAction) :
                  if ret(p) == false :
                     fill-template(`(do(f, e), body), [
                        `f => prod(p)
                        `e => exp(d)
                        `body => loop(i + 1)])
                  else :
                     fill-template(`(let : (val e = map(f, e), body)), [
                        `e => exp(d)
                        `f => prod(p)
                        `body => loop(i + 1)])
               (p:BuildAction) :
                  fill-template(`(let : (val e = node(args), body)), [
                     `e => exp(d)
                     `node => node(p)
                     `args => splice(args(p))
                     `body => loop(i + 1)])
               (p:GotoAction) :
                  if ret(p) == false :
                     fill-template(`(f(e), body), [
                        `f => prod(p)
                        `e => exp(d)
                        `body => loop(i + 1)])
                  else :
                     fill-template(`(let : (val e = f(e), body)), [
                        `e => exp(d)
                        `f => prod(p)
                        `body => loop(i + 1)])
               (p:ResolveAction) :
                  fill-template(`(resolve-type(eng, e), body), [
                     `resolve-type => to-symbol("resolve-~" << [type(p)])
                     `e => exp(d)
                     `eng => eng(d)
                     `body => loop(i + 1)])
               (p:PushScope) :
                  fill-template(`(push-scope(eng), body), [
                     `eng => eng(d)
                     `body => loop(i + 1)])                     
               (p:PopScope) :
                  fill-template(`(pop-scope(eng), body), [
                     `eng => eng(d)
                     `body => loop(i + 1)])
         else :            
            exp(d) when ret?            
      loop(0)

   defn compile (p:Prod) :
      match(p) :
         (p:Definer) :
            val template = `(
               defn name (e:type) -> core/False :
                  match(e) :
                     clauses{(e:Node) : arg})
            fill-template(template, [
               `name => #prod(p)
               `e => exp(d)
               `type => type!(p)
               `clauses => for c in clauses(p) fill-each : [
                  `Node => type(c)
                  `arg => compile(type(c), arg(c), false)]])               
         (p:Resolver) :
            val template = `(
               defn name (e:type) :
                  match(e) :
                     clauses{(e:Node) : arg})
            fill-template(template, [
               `name => #prod(p)
               `e => exp(d)
               `type => type!(p)
               `clauses => for c in clauses(p) fill-each : [
                  `Node => type(c)
                  `arg => compile(type(c), arg(c), true)]])

   val template = `(
      defn name (e:type, eng:engtype) :
         defn #do<?T> (f:T -> ? , x: ?T) : f(x)
         defn #do<?T> (f:T -> ?, x: List<?T>) : core/do(f, x)      
         defn #map<?S,?T> (f:T -> ?S , x: ?T) : f(x)
         defn #map<?S,?T> (f:T -> ?S, x: List<?T>) : core/map(f, x)
         resolvers
         resolver0(e))
   fill-template(template, [
      `name => name(d)
      `e => exp(d)
      `type => type(d)
      `eng => eng(d)
      `engtype => engtype(d)
      `resolvers => map(compile, prods(d))
      `resolver0 => #prod(head(prods(d)))])