defpackage stz/reg-alloc-assignment-table :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-datastructures
  import stz/printing-utils

;============================================================
;==================== Assignment Table ======================
;============================================================

public deftype AssignmentTable

;Record that the given variable has been saved.
;The shuffling engine needs to know which variables are saved so that
;it doesn't emit extraneous Save statements.
public defmulti set-saved (t:AssignmentTable, v:Int, s:True|False) -> False

;Return whether the variable has been saved.
public defmulti saved? (t:AssignmentTable, v:Int) -> True|False

;Properly clear the assignment table before analyzing an operation.
public defmulti initialize-before-operation (t:AssignmentTable,
                                             args:Tuple<Int>,
                                             num-temp:Int) -> False

;Assign the given register to the given variable.
;Condition: r must not be assigned already.
public defmulti assign (t:AssignmentTable, v:Int, r:Register) -> False

;Assign the given register to the given temporary.
;Condition: r must not be assigned already.
public defmulti assign-temp (t:AssignmentTable, temp:Int, r:Register) -> False

;Release all the assigned temporary registers.
public defmulti release-all-temp (t:AssignmentTable) -> False

;Unassign the variable, such that it doesn't hold any register.
;Condition: v must have an assigned register.
public defmulti unassign (t:AssignmentTable, v:Int) -> False

;Retrieve the register that the variable is assigned to (if any).
public defmulti get? (t:AssignmentTable, v:Int) -> Register|False

;Retrieve the variable (or temporary) that the given register is assigned to (if any).
public defmulti get? (t:AssignmentTable, r:Register) -> Int|Temp|False

;Retrieve the register assigned to the i'th temporary.
public defmulti temp (t:AssignmentTable, i:Int) -> Register|False

;Record the register that was chosen for a given argument.
public defmulti assign-arg (t:AssignmentTable, arg-index:Int, r:Register) -> False

;Return the recorded register chosen for a given argument.
public defmulti arg (t:AssignmentTable, arg-index:Int) -> Register|False

;Return the previous register for a given argument.
public defmulti prev-arg (t:AssignmentTable, arg-index:Int) -> Register

;Retrieve a free register of the following type.
;Used for:
;- Identifying swap registers.
;Arguments:
;- category: The type of register that is desired.
;- allow-reserved?: If false, then registers that are marked as reserved
;  are not considered.
;- allow-reserved-input?: If false, then registers that are marked in the
;  reserved-input set are not considered.
;- pref: If given, a preferred register to try first.
public defmulti free-register (t:AssignmentTable,
                               type:RegisterType,
                               allow-reserved?:True|False,
                               allow-reserved-input?:True|False,
                               pref:Register|False) -> Register

;Mark and clear the reserved register set.
;Used in free-register calculation when selecting registers for output variables.
public defmulti clear-reserved (t:AssignmentTable) -> False
public defmulti mark-reserved (t:AssignmentTable, r:Register) -> True|False

;Mark and clear the reserved-input register set.
;Used in free-register calculation when selecting registers for input variables.
public defmulti clear-reserved-input (t:AssignmentTable) -> False
public defmulti mark-reserved-input (t:AssignmentTable, r:Register) -> False

;Evict the occupants of the given register, and save a record if a
;non-argument variable was evicted.
public defmulti evict? (t:AssignmentTable, r:Register) -> False

;Return the details of the non-arg variables that were evicted.
public defmulti evicted (t:AssignmentTable) -> Vector<VarWithReg>

;Represents a pairing of a variable with a register.
public defstruct VarWithReg :
  variable:Int
  reg:Register
with: (printer => true)

;Represent the index'th temporary in an operation.
public defstruct Temp <: Hashable&Equalable :
  index:Int
with:
  printer => true
  hashable => true
  equalable => true

;============================================================
;==================== Implementation ========================
;============================================================

public defn AssignmentTable (resources:ResourceProvider) :
  ;Hold the mapping from variables to registers.
  val var-table = VarTable<Register>(resources)

  ;Holds the mapping from registers to variables.
  val reg-table = RegisterTable<Int|Temp>(resources)

  ;Holds the mapping from temporaries to registers.
  var num-temps:Int = 0
  val temp-table = TempArray<Register|False>(resources)

  ;Hold the recorded argument/temporary assignments.
  var num-args:Int = 0
  val prev-arg-table = ArgArray<Register>(resources)
  val arg-table = ArgArray<Register|False>(resources)

  ;Hold all the saved variables.
  val var-saved = VarSet(resources)

  ;Holds the set of reserved registers.
  val reserved = RegisterSet(resources)

  ;Holds the set of reserved input registers.
  val reserved-inputs = RegisterSet(resources)

  ;Holds the registers that haven't been assigned to anything.
  val free-regs = RegisterSet(resources)

  ;Hold the registers that the arguments were originally in.
  ;Given this set, when we evict a variable, we can determine
  ;whether it was an argument or not.
  val argument-original-register-set = RegisterSet(resources)

  ;Holds the list of variables that were evicted.
  val evicted-vars = Vector<VarWithReg>()

  ;Sanity check: Ensure that tables are self-consistent.
  defn ensure-consistent! () :
    #if-not-defined(OPTIMIZE) :
      ;Check that free-regs is consistent.
      for r in all-regs(resources) do :
        ;If it is a free register, then it is unassigned.
        if free-regs[r] :
          if key?(reg-table,r) : fatal("Free register is assigned.")
        ;If it is not a free register, then it is assigned.
        else :
          if not key?(reg-table,r) : fatal("Non-free register is not assigned.")
      ;Check that var-table and reg-table is consistent.
      for entry in var-table do :
        val v = key(entry)
        val reg = value(entry)
        if get?(reg-table,reg) != v :
          fatal("Var-table and reg-table are not consistent.")
    false

  ;Log a message for debugging.
  defn log (msg) :
    println("[Assignment Table] %_" % [msg])

  ;Initialize
  add-all(free-regs, all-regs(resources))

  ;Implementation of methods.
  new AssignmentTable :
    ;Initialization
    defmethod initialize-before-operation (this,
                                           args:Tuple<Int>,
                                           num-op-temps:Int) :
      ;Clear the temporary table.
      num-temps = num-op-temps
      for i in 0 to num-temps do :
        temp-table[i] = false

      ;Clear the argument table and set.
      num-args = length(args)
      for (v in args, i in 0 to num-args) do :
        prev-arg-table[i] = var-table[v]
        arg-table[i] = false

      ;Initialize the argument set.
      clear(argument-original-register-set)
      for i in 0 to num-args do :
        add(argument-original-register-set, prev-arg-table[i])

      ;Clear the reserved sets.
      clear(reserved)
      clear(reserved-inputs)

      ;Clear the list of evicted vars.
      clear(evicted-vars)      
  
    ;Record that the given variable has been saved.
    defmethod set-saved (this, v:Int, s:True|False) :
      log("Set V%_ saved to %_." % [v, s])
      if s : add(var-saved,v)
      else : remove(var-saved,v)
      false

    ;Return true if the given variable is saved.
    defmethod saved? (this, v:Int) :
      var-saved[v]

    ;Assign the given register to the given variable.
    defmethod assign (this, v:Int, r:Register) :
      #if-not-defined(OPTIMIZE) :
        if key?(var-table, v) : fatal("Variable V%_ already assigned." % [v])
        if key?(reg-table, r) : fatal("Register %_ is occupied." % [r])
      log("Assign %_ to V%_" % [r, v])
      var-table[v] = r
      reg-table[r] = v
      remove(free-regs, r)
      ensure-consistent!()

    ;Assign the given register to the given temp variable.
    defmethod assign-temp (this, temp:Int, r:Register) -> False :
      #if-not-defined(OPTIMIZE) :
        if temp-table[temp] is-not False : fatal("Temporary T%_ already assigned." % [temp])
        if key?(reg-table, r) : fatal("Register %_ is occupied." % [r])
      log("Assign %_ to temp T%_" % [r, temp])
      temp-table[temp] = r
      reg-table[r] = Temp(temp)
      remove(free-regs, r)
      ensure-consistent!()      

    ;Release all the assigned temp registers.
    defmethod release-all-temp (this) -> False :
      for i in 0 to num-temps do :
        #if-not-defined(OPTIMIZE) :
          if temp-table[i] is False :
            fatal("Temporary T%_ was not assigned." % [i])        
        log("Release temp T%_ (%_)" % [i, temp-table[i]])
        val reg = temp-table[i] as Register
        temp-table[i] = false
        remove(reg-table, reg)
        add(free-regs, reg)
        ensure-consistent!()

    ;Unassign the variable, such that it doesn't hold any register.
    defmethod unassign (this, v:Int) -> False :
      #if-not-defined(OPTIMIZE) :
        if not key?(var-table, v) : fatal("Variable V%_ is not assigned." % [v])
      log("Unassign V%_" % [v])
      val r = var-table[v]
      remove(var-table, v)
      remove(reg-table, r)
      add(free-regs, r)
      ensure-consistent!()

    ;Retrieve the register that the variable is assigned to.
    defmethod get? (this, v:Int) -> Register|False :
      get?(var-table, v)

    ;Retrieve the variable that occupies the given register.
    defmethod get? (this, r:Register) -> Int|Temp|False :
      get?(reg-table, r)

    ;Retrieve the register that the temporary is assigned to.
    defmethod temp (this, i:Int) -> Register|False :
      temp-table[i]

    ;Clear the reserved set.
    defmethod clear-reserved (this) :
      log("Clear Reserved Set")
      clear(reserved)

    ;Mark the given register as reserved.
    defmethod mark-reserved (this, r:Register) :      
      log("Mark %_ as reserved." % [r])
      add(reserved, r)
      false

    ;Clear the reserved input set.
    defmethod clear-reserved-input (this) :
      log("Clear Reserved Input Set")
      clear(reserved-inputs)

    ;Mark the given register as a reserved input.
    defmethod mark-reserved-input (this, r:Register) :
      log("Mark %_ as reserved input." % [r])
      add(reserved-inputs, r)
      false

    ;Return a free register of the given type satisfying the given conditions.
    defmethod free-register (this, 
                             type:RegisterType,
                             allow-reserved?:True|False,
                             allow-reserved-input?:True|False,
                             pref:Register|False) -> Register :
      ;Returns true if one of the reserved sets block the register.
      defn blocked? (r:Register) -> True|False :
        val blocked-by-reserved = reserved[r] when not allow-reserved?
        val blocked-by-reserved-inputs = reserved-inputs[r] when not allow-reserved-input?
        blocked-by-reserved or blocked-by-reserved-inputs

      ;Returns true if appropriate to be returned.
      defn free? (r:Register) -> True|False :
        not blocked?(r) and free-regs[r]

      ;Return true if r is the desired type.
      ;[TODO] Use separate free lists to make this faster.
      defn right-type? (r:Register) -> True|False :
        match(r, type) :
          (r:Reg, type:AnyReg) : true
          (r:FReg, type:AnyFReg) : true
          (r, type) : false

      ;Return true if the preferred register is free.
      defn pref-is-free? () -> True|False :
        match(pref:Register) : free?(pref)

      ;Return the first register that is free.
      defn first-free () -> Register :
        val r = for r in free-regs find :
          not blocked?(r) and right-type?(r)
        fatal("No free registers available.") when r is False
        r as Register
        
      ;Sanity check, pref and category should be the same type.
      #if-not-defined(OPTIMIZE) :
        match(pref, type) :
          (pref:False, type) : false
          (pref:Reg, type:AnyReg) : false
          (pref:FReg, type:AnyFReg) : false
          (pref, type) : fatal("Preferred register is not the right type.")
          
      ;Launch!
      val result = 
        if pref-is-free?() : pref as Register
        else : first-free()
      log("Return free register %_" % [result])
      result

    ;Evict the occupants of the given register, and save a record if a
    ;non-argument variable was evicted.
    defmethod evict? (this, r:Register) -> False :
      match(get?(reg-table, r)) :
        (v:Int) :
          log("Evict V%_ from %_." % [])
          if not argument-original-register-set[r] :
            add(evicted-vars, VarWithReg(v,r))
          unassign(this, v)
        (t:Temp) :
          fatal("Cannot evict a register containing a temporary.")
        (f:False) :
          log("Register %_ is empty. No need to evict." % [r])
          false

    ;Return the details of the variables that were evicted.
    defmethod evicted (this) -> Vector<VarWithReg> :
      evicted-vars

    ;Record the assignment chosen for a given argument.
    defmethod assign-arg (this, arg-index:Int, r:Register) -> False :
      log("Assign %_ to argument Arg%_" % [r, arg-index])
      arg-table[arg-index] = r

    ;Return the recorded register chosen for a given argument.
    defmethod arg (this, arg-index:Int) -> Register|False :
      arg-table[arg-index]

    ;Return the recorded previous register for a given argument.
    defmethod prev-arg (this, arg-index:Int) -> Register :
      prev-arg-table[arg-index]

    defmethod print (o:OutputStream, this) :
      ;Print out the main assignment table.
      println(o, "Assignment Table:")
      print-table(IndentedStream(o), header, rows) where :
        val header = ["Register" "Variable" "Var Saved" "Reserved" "Reserved Input"]
        val rows:Tuple<Tuple<String>> = to-tuple $ for entry in reg-table seq :
          val register = to-string(key(entry))
          val variable = match(value(entry)) :
                           (v:Int) : to-string("V%_" % [v])
                           (t:Temp) : to-string("T%_" % [index(t)])
          val var-saved = match(value(entry)) :
                            (v:Int) : "YES" when var-saved[v] else ""
                            (t:Temp) : ""
          val reserved = "YES" when reserved[key(entry)] else ""
          val reserved-input = "YES" when reserved-inputs[key(entry)] else ""
          [register, variable, var-saved, reserved, reserved-input]

      ;Print out the argument table.
      println(o, "\n\nArgument Table:")
      print-table(IndentedStream(o), header, rows) where :
        val header = ["Argument", "Register"]
        val rows = to-tuple $ for i in 0 to num-args seq :
          val arg = to-string("Arg%_" % [i])
          val reg = match(arg-table[i]) :
                      (r:Register) : to-string(r)
                      (f:False) : ""
          [arg, reg]

      ;Print out the eviction table.
      println(o, "\n\nEvictions:")
      print-table(IndentedStream(o), header, rows) where :
        val header = ["Variable", "Register"]
        val rows = to-tuple $ for entry in evicted-vars seq :
          val variable = to-string("V%_" % [variable(entry)])
          val reg = to-string(reg(entry))
          [variable, reg]

;============================================================
;================== Convenience =============================
;============================================================

;Retrieve the register that the variable is assigned to (if any).
public defn get (t:AssignmentTable, v:Int) -> Register :
  match(get?(t,v)) :
    (r:Register) : r
    (f:False) : fatal("Variable V%_ has no assigned register." % [v])

;Retrieve the variable (or temporary) that the given register is assigned to (if any).
public defn get (t:AssignmentTable, r:Register) -> Int|Temp :
  match(get?(t,r)) :
    (v:Int|Temp) : v
    (f:False) : fatal("Register %_ is not assigned." % [r])

;============================================================
;================= Table Formatting Utility =================
;============================================================

;Create a formatted table. 
defn formatted-table (header:Tuple<String>,
                      rows:Tuple<Tuple<String>>) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      print-table(o, header, rows)

;Small utility to print out a formatted table.
defn print-table (o:OutputStream,
                  header:Tuple<String>
                  rows:Tuple<Tuple<String>>) :

  ;Compute the number of columns in total.                
  val num-columns = length(header)
  
  ;Compute the column widths
  val column-widths = to-tuple(seq(column-width, 0 to num-columns)) where :
    ;Helper: Return the width of a given column.
    defn column-width (i:Int) -> Int :
      var w:Int = 3
      defn consider (s:String) :
        w = max(w, length(s) + 2)
      consider(header[i])
      do(consider{_[i]}, rows)
      w

  ;Return the number of characters in the bar
  ;under the header.
  defn bar-width () -> Int :
    sum(column-widths) + num-columns - 1

  ;Print out the string in left-justified style.
  defn left-justify (s:String, w:Int) :
    print(o, " %_" % [s])
    val num-spaces = w - length(s) - 1
    for i in 0 to num-spaces do :
      print(o, ' ')

  ;Print out the bar underneath the header.
  defn print-bar () :
    print(o, '\n')
    for i in 0 to bar-width() do :
      print(o, '-')

  ;Print out the entire table.
  defn print-row (row:Tuple<String>) :
    for (s in row, i in 0 to false) do :
      print(o, '|') when i > 0
      left-justify(s, column-widths[i])

  ;Launch!
  print-row(header)
  print-bar()
  if empty?(rows) :
    val empty-row = to-tuple(seq({""}, 0 to num-columns))
    print(o, '\n')
    print-row(empty-row)
  else :
    for row in rows do :
      print(o, '\n')
      print-row(row)