defpackage stz/reg-alloc-assignment-table :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-datastructures
  import stz/printing-utils

;============================================================
;==================== Assignment Table ======================
;============================================================

public deftype AssignmentTable

;Record that the given variable has been saved.
;The shuffling engine needs to know which variables are saved so that
;it doesn't emit extraneous Save statements.
public defmulti set-saved (t:AssignmentTable, v:Int, s:True|False) -> False

;Return whether the variable has been saved.
public defmulti saved? (t:AssignmentTable, v:Int) -> True|False

;Hold the registers that the arguments were originally in.
;Given this set, when we evict a variable, we can determine
;whether it was an argument or not.
;This function must be called before evict? is called.
public defmulti set-argument-original-registers (t:AssignmentTable, rs:Seqable<Reg|FReg>) -> False

;Assign the given register to the given variable.
;Condition: r must not be assigned already.
public defmulti assign (t:AssignmentTable, v:Int, r:Reg|FReg) -> False

;Unassign the variable, such that it doesn't hold any register.
;Condition: v must have an assigned register.
public defmulti unassign (t:AssignmentTable, v:Int) -> False

;Retrieve the register that the variable is assigned to (if any).
public defmulti get? (t:AssignmentTable, v:Int) -> Reg|FReg|False

;Retrieve the variable that the given register is assigned to (if any).
public defmulti get? (t:AssignmentTable, r:Reg|FReg) -> Int|False

;Retrieve a free register of the following type.
;Used for:
;- Identifying swap registers.
;Arguments:
;- category: The type of register that is desired.
;- allow-reserved?: If false, then registers that are marked as reserved
;  are not considered.
;- allow-reserved-input?: If false, then registers that are marked in the
;  reserved-input set are not considered.
;- pref: If given, a preferred register to try first.
public defmulti free-register (t:AssignmentTable,
                               category:AnyReg|AnyFReg,
                               allow-reserved?:True|False,
                               allow-reserved-input?:True|False,
                               pref:Reg|FReg|False) -> Reg|FReg

;Mark and clear the reserved register set.
;Used in free-register calculation when selecting registers for output variables.
public defmulti clear-reserved (t:AssignmentTable) -> False
public defmulti mark-reserved (t:AssignmentTable, r:Reg|FReg) -> True|False

;Mark and clear the reserved-input register set.
;Used in free-register calculation when selecting registers for input variables.
public defmulti clear-reserved-input (t:AssignmentTable) -> False
public defmulti mark-reserved-input (t:AssignmentTable, r:Reg|FReg) -> False

;Evict the occupants of the given register, and save a record if a
;non-argument variable was evicted.
public defmulti evict? (t:AssignmentTable, r:Reg|FReg) -> False

;Return the details of the non-arg variables that were evicted.
public defmulti evicted (t:AssignmentTable) -> Vector<VarWithReg>

;Clear the evicted vector.
public defmulti clear-evicted (t:AssignmentTable) -> False

;Represents a pairing of a variable with a register.
public defstruct VarWithReg :
  variable:Int
  reg:Reg|FReg
with: (printer => true)

;Record the register that was chosen for a given argument.
public defmulti record-arg-assignment (t:AssignmentTable, arg-index:Int, r:Reg|FReg) -> False

;Return the recorded register chosen for a given argument.
public defmulti recorded-arg-assignment (t:AssignmentTable, arg-index:Int) -> Reg|FReg|False

;Record the register that was chosen for a given temporary.
public defmulti record-temp-assignment (t:AssignmentTable, temp-index:Int, r:Reg|FReg) -> False

;Return the recorded register that was chosen for a given temporary.
public defmulti recorded-temp-assignment (t:AssignmentTable, temp-index:Int) -> Reg|FReg|False

;Clear all the recorded assignments for the current operation.
;Writes false to the arg assignments.
public defmulti clear-recorded-assignments (t:AssignmentTable, num-args:Int, num-temps:Int) -> False

;============================================================
;==================== Implementation ========================
;============================================================

public defn AssignmentTable (resources:ResourceProvider) :
  ;Hold the mapping from variables to registers.
  val var-table = VarTable<Reg|FReg>(resources)

  ;Holds the mapping from registers to variables.
  val reg-table = RegisterTable<Int>(resources)

  ;Hold all the saved variables.
  val var-saved = VarSet(resources)

  ;Holds the set of reserved registers.
  val reserved = RegisterSet(resources)

  ;Holds the set of reserved input registers.
  val reserved-inputs = RegisterSet(resources)

  ;Holds the registers that haven't been assigned to anything.
  val free-regs = RegisterSet(resources)

  ;Hold the registers that the arguments were originally in.
  ;Given this set, when we evict a variable, we can determine
  ;whether it was an argument or not.
  val argument-original-register-set = RegisterSet(resources)

  ;Holds the list of variables that were evicted.
  val evicted-vars = Vector<VarWithReg>()

  ;Hold the recorded argument/temporary assignments.
  val recorded-args = ArgArray<Reg|FReg|False>(resources)
  val recorded-temps = TempArray<Reg|FReg|False>(resources)

  ;Sanity check: Ensure that tables are self-consistent.
  defn ensure-consistent! () :
    #if-not-defined(OPTIMIZE) :
      ;Check that free-regs is consistent.
      for r in all-regs(resources) do :
        ;If it is a free register, then it is unassigned.
        if free-regs[r] :
          if key?(reg-table,r) : fatal("Free register is assigned.")
        ;If it is not a free register, then it is assigned.
        else :
          if not key?(reg-table,r) : fatal("Non-free register is not assigned.")
      ;Check that var-table and reg-table is consistent.
      for entry in var-table do :
        val v = key(entry)
        val reg = value(entry)
        if get?(reg-table,reg) != v :
          fatal("Var-table and reg-table are not consistent.")
    false

  ;Initialize
  add-all(free-regs, all-regs(resources))

  ;Implementation of methods.
  new AssignmentTable :
  
    ;Record that the given variable has been saved.
    defmethod set-saved (this, v:Int, s:True|False) :
      if s : add(var-saved,v)
      else : remove(var-saved,v)
      false

    ;Return true if the given variable is saved.
    defmethod saved? (this, v:Int) :
      var-saved[v]

    ;Set the registers that the arguments were originally in.
    defmethod set-argument-original-registers (this, rs:Seqable<Reg|FReg>) -> False :
      set-contents(argument-original-register-set, rs)

    ;Assign the given register to the given variable.
    defmethod assign (this, v:Int, r:Reg|FReg) :
      #if-not-defined(OPTIMIZE) :
        if key?(var-table, v) : fatal("Variable V%_ already assigned." % [v])
        if key?(reg-table, r) : fatal("Register %_ is occupied." % [r])
      var-table[v] = r
      reg-table[r] = v
      remove(free-regs, r)
      ensure-consistent!()

    ;Unassign the variable, such that it doesn't hold any register.
    defmethod unassign (this, v:Int) -> False :
      #if-not-defined(OPTIMIZE) :
        if not key?(var-table, v) : fatal("Variable V%_ is not assigned." % [v])
      val r = var-table[v]
      remove(var-table, v)
      remove(reg-table, r)
      add(free-regs, r)
      ensure-consistent!()

    ;Retrieve the register that the variable is assigned to.
    defmethod get? (this, v:Int) -> Reg|FReg|False :
      get?(var-table, v)

    ;Retrieve the variable that occupies the given register.
    defmethod get? (this, r:Reg|FReg) -> Int|False :
      get?(reg-table, r)

    ;Clear the reserved set.
    defmethod clear-reserved (this) :
      clear(reserved)

    ;Mark the given register as reserved.
    defmethod mark-reserved (this, r:Reg|FReg) :
      add(reserved, r)
      false

    ;Clear the reserved input set.
    defmethod clear-reserved-input (this) :
      clear(reserved-inputs)

    ;Mark the given register as a reserved input.
    defmethod mark-reserved-input (this, r:Reg|FReg) :
      add(reserved-inputs, r)
      false

    ;Return a free register of the given type satisfying the given conditions.
    defmethod free-register (this, 
                             category:AnyReg|AnyFReg,
                             allow-reserved?:True|False,
                             allow-reserved-input?:True|False,
                             pref:Reg|FReg|False) -> Reg|FReg :
      ;Returns true if one of the reserved sets block the register.
      defn blocked? (r:Reg|FReg) -> True|False :
        val blocked-by-reserved = reserved[r] when not allow-reserved?
        val blocked-by-reserved-inputs = reserved-inputs[r] when not allow-reserved-input?
        blocked-by-reserved or blocked-by-reserved-inputs

      ;Returns true if appropriate to be returned.
      defn free? (r:Reg|FReg) -> True|False :
        not blocked?(r) and free-regs[r]

      ;Return true if r is the desired category.
      ;[TODO] Use separate free lists to make this faster.
      defn right-category? (r:Reg|FReg) -> True|False :
        match(r, category) :
          (r:Reg, category:AnyReg) : true
          (r:FReg, category:AnyFReg) : true
          (r, category) : false

      ;Return true if the preferred register is free.
      defn pref-is-free? () -> True|False :
        match(pref:Reg|FReg) : free?(pref)

      ;Return the first register that is free.
      defn first-free () -> Reg|FReg :
        val r = for r in free-regs find :
          not blocked?(r) and right-category?(r)
        fatal("No free registers available.") when r is False
        r as Reg|FReg
        
      ;Sanity check, pref and category should be the same type.
      #if-not-defined(OPTIMIZE) :
        match(pref, category) :
          (pref:False, category) : false
          (pref:Reg, category:AnyReg) : false
          (pref:FReg, category:AnyFReg) : false
          (pref, category) : fatal("Preferred register is not the right type.")
          
      ;Launch!
      if pref-is-free?() : pref as Reg|FReg
      else : first-free()

    ;Evict the occupants of the given register, and save a record if a
    ;non-argument variable was evicted.
    defmethod evict? (this, r:Reg|FReg) -> False :
      match(get?(reg-table, r)) :
        (v:Int) :
          if not argument-original-register-set[r] :
            add(evicted-vars, VarWithReg(v,r))
          unassign(this, v)
        (f:False) :
          false

    ;Return the details of the variables that were evicted.
    defmethod evicted (this) -> Vector<VarWithReg> :
      evicted-vars

    ;Clear the evicted vector.
    defmethod clear-evicted (this) -> False :
      clear(evicted-vars)

    ;Record the assignment chosen for a given argument.
    defmethod record-arg-assignment (this, arg-index:Int, r:Reg|FReg) -> False :
      recorded-args[arg-index] = r

    ;Record the assignment chosen for a temp variable.
    defmethod record-temp-assignment (this, temp-index:Int, r:Reg|FReg) -> False :
      recorded-temps[temp-index] = r

    ;Return the recorded register chosen for a given argument.
    defmethod recorded-arg-assignment (this, arg-index:Int) -> Reg|FReg|False :
      recorded-args[arg-index] 

    ;Return the recorded register that was chosen for a given temporary.
    defmethod recorded-temp-assignment (this, temp-index:Int) -> Reg|FReg|False :
      recorded-temps[temp-index]

    ;Clear the recorded assignments for the current operation.
    defmethod clear-recorded-assignments (this,
                                          num-args:Int,
                                          num-temps:Int) -> False :
      for i in 0 to num-args do :
        recorded-args[i] = false
      for i in 0 to num-temps do :
        recorded-temps[i] = false

    defmethod print (o:OutputStream, this) :
      print(o, "var-saved: %_" % [var-saved])
      lnprint(o, "var-table: %_" % [var-table])
      lnprint(o, "reg-table: %_" % [reg-table])
      lnprint(o, "reserved: %_" % [reserved])
      lnprint(o, "reserved inputs: %_" % [reserved-inputs])
