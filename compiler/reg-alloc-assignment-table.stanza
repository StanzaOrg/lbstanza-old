defpackage stz/reg-alloc-assignment-table :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-datastructures
  import stz/printing-utils

;============================================================
;==================== Assignment Table ======================
;============================================================

public deftype AssignmentTable

;Record that the given variable has been saved.
;The shuffling engine needs to know which variables are saved so that
;it doesn't emit extraneous Save statements.
public defmulti set-saved (t:AssignmentTable, v:Int, s:True|False) -> False

;Return whether the variable has been saved.
public defmulti saved? (t:AssignmentTable, v:Int) -> True|False

;Properly clear the assignment table before analyzing an operation.
public defmulti initialize-before-operation (t:AssignmentTable,
                                             arg-registers:Seqable<Reg|FReg>,
                                             num-args:Int,
                                             num-temp:Int) -> False

;Assign the given register to the given variable.
;Condition: r must not be assigned already.
public defmulti assign (t:AssignmentTable, v:Int, r:Reg|FReg) -> False

;Assign the given register to the given temporary.
;Condition: r must not be assigned already.
public defmulti assign-temp (t:AssignmentTable, temp:Int, r:Reg|FReg) -> False

;Unassign the variable, such that it doesn't hold any register.
;Condition: v must have an assigned register.
public defmulti unassign (t:AssignmentTable, v:Int) -> False

;Retrieve the register that the variable is assigned to (if any).
public defmulti get? (t:AssignmentTable, v:Int) -> Reg|FReg|False

;Retrieve the variable (or temporary) that the given register is assigned to (if any).
public defmulti get? (t:AssignmentTable, r:Reg|FReg) -> Int|Temp|False

;Retrieve the register assigned to the i'th temporary.
public defmulti temp (t:AssignmentTable, i:Int) -> Reg|FReg|False

;Record the register that was chosen for a given argument.
public defmulti assign-arg (t:AssignmentTable, arg-index:Int, r:Reg|FReg) -> False

;Return the recorded register chosen for a given argument.
public defmulti arg (t:AssignmentTable, arg-index:Int) -> Reg|FReg|False

;Retrieve a free register of the following type.
;Used for:
;- Identifying swap registers.
;Arguments:
;- category: The type of register that is desired.
;- allow-reserved?: If false, then registers that are marked as reserved
;  are not considered.
;- allow-reserved-input?: If false, then registers that are marked in the
;  reserved-input set are not considered.
;- pref: If given, a preferred register to try first.
public defmulti free-register (t:AssignmentTable,
                               category:AnyReg|AnyFReg,
                               allow-reserved?:True|False,
                               allow-reserved-input?:True|False,
                               pref:Reg|FReg|False) -> Reg|FReg

;Mark and clear the reserved register set.
;Used in free-register calculation when selecting registers for output variables.
public defmulti clear-reserved (t:AssignmentTable) -> False
public defmulti mark-reserved (t:AssignmentTable, r:Reg|FReg) -> True|False

;Mark and clear the reserved-input register set.
;Used in free-register calculation when selecting registers for input variables.
public defmulti clear-reserved-input (t:AssignmentTable) -> False
public defmulti mark-reserved-input (t:AssignmentTable, r:Reg|FReg) -> False

;Evict the occupants of the given register, and save a record if a
;non-argument variable was evicted.
public defmulti evict? (t:AssignmentTable, r:Reg|FReg) -> False

;Return the details of the non-arg variables that were evicted.
public defmulti evicted (t:AssignmentTable) -> Vector<VarWithReg>

;Represents a pairing of a variable with a register.
public defstruct VarWithReg :
  variable:Int
  reg:Reg|FReg
with: (printer => true)

;Represent the index'th temporary in an operation.
public defstruct Temp <: Hashable&Equalable :
  index:Int
with:
  printer => true
  hashable => true
  equalable => true

;============================================================
;==================== Implementation ========================
;============================================================

public defn AssignmentTable (resources:ResourceProvider) :
  ;Hold the mapping from variables to registers.
  val var-table = VarTable<Reg|FReg>(resources)

  ;Holds the mapping from registers to variables.
  val reg-table = RegisterTable<Int|Temp>(resources)

  ;Holds the mapping from temporaries to registers.
  var num-temps:Int = 0
  val temp-table = TempArray<Reg|FReg|False>(resources)

  ;Hold the recorded argument/temporary assignments.
  var num-args:Int = 0
  val arg-table = ArgArray<Reg|FReg|False>(resources)

  ;Hold all the saved variables.
  val var-saved = VarSet(resources)

  ;Holds the set of reserved registers.
  val reserved = RegisterSet(resources)

  ;Holds the set of reserved input registers.
  val reserved-inputs = RegisterSet(resources)

  ;Holds the registers that haven't been assigned to anything.
  val free-regs = RegisterSet(resources)

  ;Hold the registers that the arguments were originally in.
  ;Given this set, when we evict a variable, we can determine
  ;whether it was an argument or not.
  val argument-original-register-set = RegisterSet(resources)

  ;Holds the list of variables that were evicted.
  val evicted-vars = Vector<VarWithReg>()

  ;Sanity check: Ensure that tables are self-consistent.
  defn ensure-consistent! () :
    #if-not-defined(OPTIMIZE) :
      ;Check that free-regs is consistent.
      for r in all-regs(resources) do :
        ;If it is a free register, then it is unassigned.
        if free-regs[r] :
          if key?(reg-table,r) : fatal("Free register is assigned.")
        ;If it is not a free register, then it is assigned.
        else :
          if not key?(reg-table,r) : fatal("Non-free register is not assigned.")
      ;Check that var-table and reg-table is consistent.
      for entry in var-table do :
        val v = key(entry)
        val reg = value(entry)
        if get?(reg-table,reg) != v :
          fatal("Var-table and reg-table are not consistent.")
    false

  ;Initialize
  add-all(free-regs, all-regs(resources))

  ;Implementation of methods.
  new AssignmentTable :
    ;Initialization
    defmethod initialize-before-operation (this,
                                           arg-registers:Seqable<Reg|FReg>,
                                           num-op-args:Int,
                                           num-op-temps:Int) :
      ;Clear the temporary table.
      num-temps = num-op-temps
      for i in 0 to num-temps do :
        temp-table[i] = false
      ;Clear the argument table.
      num-args = num-op-args
      for i in 0 to num-args do :
        arg-table[i] = false
      ;Clear the reserved sets.
      clear(reserved)
      clear(reserved-inputs)
      ;Initialize the argument register set.
      set-contents(argument-original-register-set, arg-registers)
      ;Clear the list of evicted vars.
      clear(evicted-vars)      
  
    ;Record that the given variable has been saved.
    defmethod set-saved (this, v:Int, s:True|False) :
      if s : add(var-saved,v)
      else : remove(var-saved,v)
      false

    ;Return true if the given variable is saved.
    defmethod saved? (this, v:Int) :
      var-saved[v]

    ;Assign the given register to the given variable.
    defmethod assign (this, v:Int, r:Reg|FReg) :
      #if-not-defined(OPTIMIZE) :
        if key?(var-table, v) : fatal("Variable V%_ already assigned." % [v])
        if key?(reg-table, r) : fatal("Register %_ is occupied." % [r])
      var-table[v] = r
      reg-table[r] = v
      remove(free-regs, r)
      ensure-consistent!()

    ;Assign the given register to the given temp variable.
    defmethod assign-temp (this, temp:Int, r:Reg|FReg) -> False :
      #if-not-defined(OPTIMIZE) :
        if temp-table[temp] is-not False : fatal("Temporary T%_ already assigned." % [temp])
        if key?(reg-table, r) : fatal("Register %_ is occupied." % [r])
      temp-table[temp] = r
      reg-table[r] = Temp(temp)
      remove(free-regs, r)
      ensure-consistent!()      

    ;Unassign the variable, such that it doesn't hold any register.
    defmethod unassign (this, v:Int) -> False :
      #if-not-defined(OPTIMIZE) :
        if not key?(var-table, v) : fatal("Variable V%_ is not assigned." % [v])
      val r = var-table[v]
      remove(var-table, v)
      remove(reg-table, r)
      add(free-regs, r)
      ensure-consistent!()

    ;Retrieve the register that the variable is assigned to.
    defmethod get? (this, v:Int) -> Reg|FReg|False :
      get?(var-table, v)

    ;Retrieve the variable that occupies the given register.
    defmethod get? (this, r:Reg|FReg) -> Int|Temp|False :
      get?(reg-table, r)

    ;Retrieve the register that the temporary is assigned to.
    defmethod temp (this, i:Int) -> Reg|FReg|False :
      temp-table[i]

    ;Clear the reserved set.
    defmethod clear-reserved (this) :
      clear(reserved)

    ;Mark the given register as reserved.
    defmethod mark-reserved (this, r:Reg|FReg) :
      add(reserved, r)
      false

    ;Clear the reserved input set.
    defmethod clear-reserved-input (this) :
      clear(reserved-inputs)

    ;Mark the given register as a reserved input.
    defmethod mark-reserved-input (this, r:Reg|FReg) :
      add(reserved-inputs, r)
      false

    ;Return a free register of the given type satisfying the given conditions.
    defmethod free-register (this, 
                             category:AnyReg|AnyFReg,
                             allow-reserved?:True|False,
                             allow-reserved-input?:True|False,
                             pref:Reg|FReg|False) -> Reg|FReg :
      ;Returns true if one of the reserved sets block the register.
      defn blocked? (r:Reg|FReg) -> True|False :
        val blocked-by-reserved = reserved[r] when not allow-reserved?
        val blocked-by-reserved-inputs = reserved-inputs[r] when not allow-reserved-input?
        blocked-by-reserved or blocked-by-reserved-inputs

      ;Returns true if appropriate to be returned.
      defn free? (r:Reg|FReg) -> True|False :
        not blocked?(r) and free-regs[r]

      ;Return true if r is the desired category.
      ;[TODO] Use separate free lists to make this faster.
      defn right-category? (r:Reg|FReg) -> True|False :
        match(r, category) :
          (r:Reg, category:AnyReg) : true
          (r:FReg, category:AnyFReg) : true
          (r, category) : false

      ;Return true if the preferred register is free.
      defn pref-is-free? () -> True|False :
        match(pref:Reg|FReg) : free?(pref)

      ;Return the first register that is free.
      defn first-free () -> Reg|FReg :
        val r = for r in free-regs find :
          not blocked?(r) and right-category?(r)
        fatal("No free registers available.") when r is False
        r as Reg|FReg
        
      ;Sanity check, pref and category should be the same type.
      #if-not-defined(OPTIMIZE) :
        match(pref, category) :
          (pref:False, category) : false
          (pref:Reg, category:AnyReg) : false
          (pref:FReg, category:AnyFReg) : false
          (pref, category) : fatal("Preferred register is not the right type.")
          
      ;Launch!
      if pref-is-free?() : pref as Reg|FReg
      else : first-free()

    ;Evict the occupants of the given register, and save a record if a
    ;non-argument variable was evicted.
    defmethod evict? (this, r:Reg|FReg) -> False :
      match(get?(reg-table, r)) :
        (v:Int) :
          if not argument-original-register-set[r] :
            add(evicted-vars, VarWithReg(v,r))
          unassign(this, v)
        (t:Temp) :
          fatal("Cannot evict a register containing a temporary.")
        (f:False) :
          false

    ;Return the details of the variables that were evicted.
    defmethod evicted (this) -> Vector<VarWithReg> :
      evicted-vars

    ;Record the assignment chosen for a given argument.
    defmethod assign-arg (this, arg-index:Int, r:Reg|FReg) -> False :
      arg-table[arg-index] = r

    ;Return the recorded register chosen for a given argument.
    defmethod arg (this, arg-index:Int) -> Reg|FReg|False :
      arg-table[arg-index] 

    defmethod print (o:OutputStream, this) :
      ;Print out the main assignment table.
      println(o, "Assignment Table:")
      print-table(IndentedStream(o), header, rows) where :
        val header = ["Register" "Variable" "Var Saved" "Reserved" "Reserved Input"]
        val rows:Tuple<Tuple<String>> = to-tuple $ for entry in reg-table seq :
          val register = to-string(key(entry))
          val variable = match(value(entry)) :
                           (v:Int) : to-string("V%_" % [v])
                           (t:Temp) : to-string("T%_" % [index(t)])
          val var-saved = match(value(entry)) :
                            (v:Int) : "YES" when var-saved[v] else ""
                            (t:Temp) : ""
          val reserved = "YES" when reserved[key(entry)] else ""
          val reserved-input = "YES" when reserved-inputs[key(entry)] else ""
          [register, variable, var-saved, reserved, reserved-input]

      ;Print out the argument table.
      println(o, "\n\nArgument Table:")
      print-table(IndentedStream(o), header, rows) where :
        val header = ["Argument", "Register"]
        val rows = to-tuple $ for i in 0 to num-args seq :
          val arg = to-string("Arg%_" % [i])
          val reg = match(arg-table[i]) :
                      (r:Reg|FReg) : to-string(r)
                      (f:False) : ""
          [arg, reg]

      ;Print out the eviction table.
      println(o, "\n\nEvictions:")
      print-table(IndentedStream(o), header, rows) where :
        val header = ["Variable", "Register"]
        val rows = to-tuple $ for entry in evicted-vars seq :
          val variable = to-string("V%_" % [variable(entry)])
          val reg = to-string(reg(entry))
          [variable, reg]

;============================================================
;================== Convenience =============================
;============================================================

;Retrieve the register that the variable is assigned to (if any).
public defn get (t:AssignmentTable, v:Int) -> Reg|FReg :
  match(get?(t,v)) :
    (r:Reg|FReg) : r
    (f:False) : fatal("Variable V%_ has no assigned register." % [v])

;Retrieve the variable (or temporary) that the given register is assigned to (if any).
public defn get (t:AssignmentTable, r:Reg|FReg) -> Int|Temp :
  match(get?(t,r)) :
    (v:Int|Temp) : v
    (f:False) : fatal("Register %_ is not assigned." % [r])

;============================================================
;================= Table Formatting Utility =================
;============================================================

;Create a formatted table. 
defn formatted-table (header:Tuple<String>,
                      rows:Tuple<Tuple<String>>) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      print-table(o, header, rows)

;Small utility to print out a formatted table.
defn print-table (o:OutputStream,
                  header:Tuple<String>
                  rows:Tuple<Tuple<String>>) :

  ;Compute the number of columns in total.                
  val num-columns = length(header)
  
  ;Compute the column widths
  val column-widths = to-tuple(seq(column-width, 0 to num-columns)) where :
    ;Helper: Return the width of a given column.
    defn column-width (i:Int) -> Int :
      var w:Int = 3
      defn consider (s:String) :
        w = max(w, length(s) + 2)
      consider(header[i])
      do(consider{_[i]}, rows)
      w

  ;Return the number of characters in the bar
  ;under the header.
  defn bar-width () -> Int :
    sum(column-widths) + num-columns - 1

  ;Print out the string in left-justified style.
  defn left-justify (s:String, w:Int) :
    print(o, " %_" % [s])
    val num-spaces = w - length(s) - 1
    for i in 0 to num-spaces do :
      print(o, ' ')

  ;Print out the bar underneath the header.
  defn print-bar () :
    print(o, '\n')
    for i in 0 to bar-width() do :
      print(o, '-')

  ;Print out the entire table.
  defn print-row (row:Tuple<String>) :
    for (s in row, i in 0 to false) do :
      print(o, '|') when i > 0
      left-justify(s, column-widths[i])

  ;Launch!
  print-row(header)
  print-bar()
  if empty?(rows) :
    val empty-row = to-tuple(seq({""}, 0 to num-columns))
    print(o, '\n')
    print-row(empty-row)
  else :
    for row in rows do :
      print(o, '\n')
      print-row(row)