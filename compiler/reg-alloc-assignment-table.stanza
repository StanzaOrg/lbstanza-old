defpackage stz/reg-alloc-assignment-table :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-datastructures
  import stz/printing-utils

;============================================================
;==================== Assignment Table ======================
;============================================================

public deftype AssignmentTable

;Record that the given variable has been saved.
;The shuffling engine needs to know which variables are saved so that
;it doesn't emit extraneous Save statements.
public defmulti set-saved (t:AssignmentTable, v:Int, s:True|False) -> False

;Return whether the variable has been saved.
public defmulti saved? (t:AssignmentTable, v:Int) -> True|False

;Assign the given register to the given variable.
;Condition: r must not be assigned already.
public defmulti assign (t:AssignmentTable, v:Int, r:Reg|FReg) -> False

;Unassign the variable, such that it doesn't hold any register.
;Condition: v must have an assigned register.
public defmulti unassign (t:AssignmentTable, v:Int) -> False

;Retrieve the register that the variable is assigned to (if any).
public defmulti get? (t:AssignmentTable, v:Int) -> Reg|FReg|False

;Retrieve the variable that the given register is assigned to (if any).
public defmulti get? (t:AssignmentTable, r:Reg|FReg) -> Int|False

;Retrieve a free register of the following type.
;Used for:
;- Identifying swap registers.
;Arguments:
;- category: The type of register that is desired.
;- allow-reserved?: If false, then registers that are marked as reserved
;  are not considered.
;- allow-reserved-input?: If false, then registers that are marked in the
;  reserved-input set are not considered.
;- pref: If given, a preferred register to try first.
public defmulti free-register (t:AssignmentTable,
                               category:AnyReg|AnyFReg,
                               allow-reserved?:True|False,
                               allow-reserved-input?:True|False,
                               pref:Reg|FReg|False) -> Reg|FReg

;Mark and clear the reserved register set.
;Used in free-register calculation when selecting registers for output variables.
public defmulti clear-reserved (t:AssignmentTable) -> False
public defmulti mark-reserved (t:AssignmentTable, r:Reg|FReg) -> True|False

;Mark and clear the reserved-input register set.
;Used in free-register calculation when selecting registers for input variables.
public defmulti clear-reserved-input (t:AssignmentTable) -> False
public defmulti mark-reserved-input (t:AssignmentTable, r:Reg|FReg) -> False

;Record the registers that were ultimately chosen for an operation statement.
public defmulti record-arg-register (t:AssignmentTable, arg-index:Int, r:Reg|FReg) -> False
public defmulti record-temp-register (t:AssignmentTable, temp-index:Int, r:Reg|FReg) -> False
public defmulti record-result-register (t:AssignmentTable, result-index:Int, r:Reg|FReg) -> False

;============================================================
;==================== Implementation ========================
;============================================================

public defn AssignmentTable (resources:ResourceProvider) :
  ;Hold the mapping from variables to registers.
  val var-table = VarTable<Reg|FReg>(resources)

  ;Holds the mapping from registers to variables.
  val reg-table = RegisterTable<Int>(resources)

  ;Hold all the saved variables.
  val var-saved = VarSet(resources)

  ;Holds the set of reserved registers.
  val reserved = RegisterSet(resources)

  ;Holds the set of reserved input registers.
  val reserved-inputs = RegisterSet(resources)

  ;Holds the registers that haven't been assigned to anything.
  val free-regs = RegisterSet(resources)

  ;Sanity check: Ensure that tables are self-consistent.
  defn ensure-consistent! () :
    #if-not-defined(OPTIMIZE) :
      ;Check that free-regs is consistent.
      for r in all-regs(resources) do :
        ;If it is a free register, then it is unassigned.
        if free-regs[r] :
          if key?(reg-table,r) : fatal("Free register is assigned.")
        ;If it is not a free register, then it is assigned.
        else :
          if not key?(reg-table,r) : fatal("Non-free register is not assigned.")
    false

  ;Implementation of methods.
  new AssignmentTable :
  
    ;Record that the given variable has been saved.
    defmethod set-saved (this, v:Int, s:True|False) :
      if s : add(var-saved,v)
      else : remove(var-saved,v)
      false

    ;Return true if the given variable is saved.
    defmethod saved? (this, v:Int) :
      var-saved[v]

    ;Assign the given register to the given variable.
    defmethod assign (this, v:Int, r:Reg|FReg) :
      #if-not-defined(OPTIMIZE) :
        if key?(var-table, v) : fatal("Variable V%_ already assigned." % [v])
        if key?(reg-table, r) : fatal("Register %_ is occupied." % [r])
      var-table[v] = r
      reg-table[r] = v
      ensure-consistent!()

    ;Unassign the variable, such that it doesn't hold any register.
    defmethod unassign (this, v:Int) -> False :
      #if-not-defined(OPTIMIZE) :
        if not key?(var-table, v) : fatal("Variable V%_ is not assigned." % [v])
      val r = var-table[v]
      remove(var-table, v)
      remove(reg-table, r)
      ensure-consistent!()

    ;Retrieve the register that the variable is assigned to.
    defmethod get? (this, v:Int) -> Reg|FReg|False :
      get?(var-table, v)

    ;Retrieve the variable that occupies the given register.
    defmethod get? (this, r:Reg|FReg) -> Int|False :
      get?(reg-table, r)

    ;Clear the reserved set.
    defmethod clear-reserved (this) :
      clear(reserved)

    ;Mark the given register as reserved.
    defmethod mark-reserved (this, r:Reg|FReg) :
      add(reserved, r)
      false

    ;Clear the reserved input set.
    defmethod clear-reserved-input (this) :
      clear(reserved-inputs)

    ;Mark the given register as a reserved input.
    defmethod mark-reserved-input (this, r:Reg|FReg) :
      add(reserved-inputs, r)
      false

    ;Return a free register of the given type satisfying the given conditions.
    ;defmethod free-register (this, 
    ;                         category:AnyReg|AnyFReg,
    ;                         allow-reserved?:True|False,
    ;                         allow-reserved-input?:True|False,
    ;                         pref:Reg|FReg|False) -> Reg|FReg :
    ;  asdf                       

    defmethod print (o:OutputStream, this) :
      print(o, "var-saved: %_" % [var-saved])
      lnprint(o, "var-table: %_" % [var-table])
      lnprint(o, "reg-table: %_" % [reg-table])
      lnprint(o, "reserved: %_" % [reserved])
      lnprint(o, "reserved inputs: %_" % [reserved-inputs])
