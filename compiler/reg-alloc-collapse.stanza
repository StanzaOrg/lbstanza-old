defpackage stz/reg-alloc-collapse :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-block
  import stz/reg-alloc-block-processing

;Collapse all the given blocks into a single linearized program.
public defn collapse (vars:Vector<VarDef>,
                      instructions:Vector<ProgramStmt>,
                      blocks:Vector<Block>
                      stackmap:StackMap) -> Program :
  val new-blocks = remove-empty-blocks(instructions, blocks)
  val new-instructions = fold-blocks(instructions, new-blocks)
  Program(to-tuple(vars),
          to-tuple(new-instructions),
          stackmap)

;Some blocks are trivial and don't need to be included.
;Compute the forwards for each empty block.
;If some code previously branched to a block that
;is empty, then the forward is the new block that we
;should branch to instead.
defn remove-empty-blocks (instructions:Vector<ProgramStmt>,
                          blocks:Vector<Block>) -> Tuple<Block|False> :
  ;Determine whether a block is trivial.
  defn empty? (b:Block) -> True|False :
    var trivial:True|False = true
    within (i, stmt) = stmts(instructions,b) :
      if stmt is-not VarStatuses :
        trivial = false
    trivial
    
  ;Compute the set of empty blocks.
  val empty-blocks = to-tuple $
    seq(empty?, blocks)

  ;Compute the forward of a block.
  ;Given block must be a trivial block.
  defn forward (b:Block) -> Int :
    if length(succs(b)) != 1 :
      fatal("Trivial block expected to have exactly 1 successor.")
    val succ0 = succs(b)[0]
    if empty-blocks[succ0] : forward(blocks[succ0])
    else : succ0

  ;Compute all forwards.
  val forward-blocks = to-tuple $
    for (b in blocks, empty? in empty-blocks) seq :
      if empty? : forward(b)
      else : index(b)

  ;Remap all the successors.
  for b in blocks do :
    val new-succs = map({forward-blocks[_]}, succs(b))
    set-succs(b, new-succs)

  ;Return the new set of blocks.
  to-tuple $ for b in blocks seq :
    b when not empty-blocks[index(b)]

;Fold all the instructions from all blocks into a
;linearized list of program statements.
defn fold-blocks (instructions:Vector<ProgramStmt>,
                  blocks:Tuple<Block|False>) -> Vector<ProgramStmt> :
  ;Compute new labels for every block.
  val label-counter = to-seq(0 to false)
  val block-labels = to-tuple $
    for b in blocks seq :
      match(b:Block) :
        next(label-counter)

  ;Return true if b0 and b1 are neighbouring blocks.
  defn neighbours? (b0:Int, b1:Int) -> True|False :
    if b0 < b1 :
      for i in (b0 + 1) to b1 all? :
        blocks[i] is False

  ;Collapse all the blocks together.
  val new-stmts = Vector<ProgramStmt>()
  for (block in blocks, block-label in block-labels) do :
    match(block:Block) :
      ;Add the label for the block.
      add(new-stmts, LabelStmt(block-label as Int))

      ;Add the instructions for the block.
      within (i, stmt) = stmts(instructions, block) :
        match(stmt) :
          (stmt:BranchStmt) :
            if length(succs(block)) != length(targets(stmt)) :
              fatal("Successors does not match targets.")
            val new-targets = for succ in succs(block) seq :
              block-labels[succ] as Int
            add(new-stmts, BranchStmt(to-tuple(new-targets)))
          (stmt:GotoStmt) :
            fatal("Unexpected goto statement during collapsing.")
          (stmt) :
            add(new-stmts, stmt)
            
      ;Add the goto statement at the end.
      if ends-with-goto?(block) :
        val succ = succs(block)[0]
        if not neighbours?(index(block), succ) :
          val succ-label = block-labels[succ] as Int
          add(new-stmts, GotoStmt(succ-label))

  ;Return the new statements.
  new-stmts