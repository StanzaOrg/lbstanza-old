;See License.txt for details about licensing.

defpackage stz/il-ir :
  import core
  import collections
  import stz/namemap
  import stz/visibility
  import stz/serializer

;General Multis for IExp
public defmulti info (e:IExp) -> False|FileInfo

public defstruct IPackage :
  name: Symbol
  imports: Tuple<IImport> with: (updater => sub-imports)
  exps: List<IExp> with: (updater => sub-exps)
  info: FileInfo|False
  namemap: NameMap with: (default => void, updater => sub-namemap)
with:
  printer => true

public defstruct IImport :
  package: Symbol
  prefix: Tuple<IPrefix> with: (default => [])
  info: FileInfo|False with: (default => false)
  import-private?: True|False with: (default => false, updater => sub-import-private?)
with:
  printer => true

public defstruct IPrefix :
  names: False|Tuple<Symbol>
  prefix: String
with:
  printer => true

#with-added-syntax(stz-ast-lang) :
   public defast :
      ;=== Types ===
      deftype IExp :
         info: False|FileInfo with: (as-method => true)

      defnodes IExp :
         ;=== Package Forms ===
         IDefPackage :
            name: IExp
            imports: List<IExp>
         IImportExp :
            package: IExp
            prefix: List<IExp>
         IPrefixExp :
            names: False|List<IExp>
            prefix: IExp
         IVisibility :
            exp: IExp
            visibility: Visibility
         ILoadPackage :
            filename: String
            pkg: ? ;TGPackage|KPackage

         ;=== Doc Form ===
         IDoc :
            string: IExp

         ;=== Declaration Forms ===
         IDefType :
            class: IExp
            args: List<IExp>
            parent: IExp
            children: List<IExp>
         IDefChild :
            name: IExp
            args: List<IExp>
            parent: IExp
         IDef :
            name: IExp
            type: IExp
            value: IExp
         IDefVar :
            name: IExp
            type: IExp
            value: IExp
         IDefn :
            tail?: True|False
            name: IExp
            targs: List<IExp>
            a1: List<IExp>
            a2: IExp
            args: List<IExp>
            body: IExp
         IDefmulti :
            name: IExp
            targs: List<IExp>
            a1: List<IExp>
            a2: IExp
         IDefmethod :
            tail?: True|False
            multi: IExp
            thisn: False|Int
            targs: List<IExp>
            a1: List<IExp>
            a2: IExp
            args: List<IExp>
            body: IExp

         ;=== Expression Forms ===
         IFn :
            tail?: True|False
            a1: List<IExp>
            a2: IExp
            args: List<IExp>
            body: IExp
         IMulti :
            funcs: List<IExp>
         IBegin :
            exps: List<IExp>
         IMatch :
            args: List<IExp>
            branches: List<IExp>
         IBranch :
            types: List<IExp>
            args: List<IExp>
            body: IExp
         INew :
            class: IExp
            methods: List<IExp>
         IVar :
            name: Symbol
         ICast :
            exp: IExp
            type: IExp
         IUpCast :
            exp: IExp
            type: IExp
         ISet :
            name: IExp
            value: IExp
         IDo :
            func: IExp
            args: List<IExp>
         IPrim :
            op: IExp
            args: List<IExp>
         ILiteral :
            value: ?
            type: IExp
         ITuple :
            exps: List<IExp>
         ILet :
            exp: IExp

         ;=== Type Forms ===
         IOf :
            class: IExp
            args: List<IExp>
         IAnd :
            a: IExp
            b: IExp
         IOr :
            a: IExp
            b: IExp
         IArrow :
            a1: List<IExp>
            a2: IExp
         ICap :
            name: IExp
         IGradual
         IVoid
         INone

         ;=== LoStanza Expression Forms ===
         ILSNew :
            type: IExp
            args: List<IExp>
         ILSStruct :
            type: IExp
            args: List<IExp>
         ILSAddr :
            exp: IExp
            unstable?: True|False
         ILSDeref :
            exp: IExp
         ILSSlot :
            exp: IExp
            index: IExp
         ILSField :
            exp: IExp
            name: IExp
         ILSDo :
            func: IExp
            args: List<IExp>
         ILSCallC :
            func: IExp
            args: List<IExp>
         ILSPrim :
            op: IExp
            args: List<IExp>
         ILSSizeof :
            type: IExp
         ILSTagof :
            name: IExp
         ILSAs :
            exp: IExp
            type: IExp
         ILSAnd :
            a: IExp
            b: IExp
         ILSOr :
            a: IExp
            b: IExp
         ILSLetExp :
            comm: IExp
            exp: IExp
         ILSFn :
            ref: IExp

         ;=== LoStanza Command Forms ===
         ILSSet :
            exp: IExp
            value: IExp
         ILSLabels :
            blocks: List<IExp>
         ILSLabeledBlock :
            name: IExp
            args: List<IExp>
            types: List<IExp>
            body: IExp
         ILSGoto :
            name: IExp
            args: List<IExp>
         ILSReturn :
            exp: IExp
         ILSLet :
            comm: IExp
         ILSIf :
            pred: IExp
            conseq: IExp
            alt: IExp
         ILSMatch :
            args: List<IExp>
            branches: List<IExp>
         ILSBranch :
            types: List<IExp>
            args: List<IExp>
            body: IExp

         ;=== LoStanza Declaration Forms ===
         ILSDef :
            name: IExp
            type: IExp
            exp: IExp
         ILSDefVar :
            name: IExp
            type: IExp
            exp: IExp
         ILSDefField :
            mut : IExp
            type : IExp
            name : IExp
         ILSDefType :
            name: IExp
            args: List<IExp>
            parent: IExp
            fields : List<IExp>
            rfield : IExp
         ILSExtern :
            name: IExp
            type: IExp
         ILSDefn :
            tail?: True|False
            name: IExp
            targs: List<IExp>
            a1: List<IExp>
            a2: IExp
            args: List<IExp>
            body: IExp
         ILSExternFn :
            name: IExp
            a1: List<IExp>
            a2: IExp
            args: List<IExp>
            body: IExp
         ILSDefmethod :
            tail?: True|False
            multi: IExp
            targs: List<IExp>
            a1: List<IExp>
            a2: IExp
            args: List<IExp>
            body: IExp

         ;=== LoStanza Type Forms ===
         ILSByteT
         ILSIntT
         ILSLongT
         ILSFloatT
         ILSDoubleT
         ILSUnknownT
         ILSOfT :
            class: IExp
            args: List<IExp>
         ILSPtrT :
            type: IExp
         ILSRefT :
            type: IExp
         ILSFnT :
            a1: List<IExp>
            ar: IExp
            a2: IExp

         ;=== Working Nodes ===
         VarN :
            n: Int
         Raw :
            class: IExp
         Mix :
            exps: List<IExp>
         Let :
            def: IExp
            body: IExp
         LetRec :
            defns: List<IExp>
            body: IExp
         LetPackage :
            name: Symbol
            imports: List<IExp>
            body: IExp

      ;=== Mappers/Doers ===
      make-mapper(f:IExp -> IExp, e:IExp)
      make-doer(f:IExp -> ?, e:IExp)

      defmapper (f:IExp -> IExp) :
         (x:IExp) : f(x)
         (x:List<IExp>) : map(f, x)
         (x:False|IExp) : f(x as IExp) when x is-not False
         (x:False|List<IExp>) : map(f, x as List<IExp>) when x != false
      defdoer (f:IExp -> ?) :
         (x:IExp) : f(x)
         (x:List<IExp>) : do(f, x)
         (x:False|IExp) : f(x as IExp) when x is-not False
         (x:False|List<IExp>) : do(f, x as List<IExp>) when x != false

      ignore :
         True|False
         False|FileInfo
         False|Int
         Symbol
         String
         ?
         Int
         TGPackage|KPackage
         List<KeyValue<Symbol,?>>
         Visibility

;Printer
#with-added-syntax(stz-printer-lang) :
   defprinter (e:IExp) :
      IDefPackage :
         ($package name imports ...)
      IImportExp :
         ($import package prefix ...)
      IPrefixExp :
         if names(e) != false : ($prefix-of (names ...) prefix)
         else : ($prefix prefix)
      IVisibility :
         custom{
           "(%_ %_)" % [tag, exp(e)] where :
             val tag = match(visibility(e)) :
               (v:Public) : "$public"
               (v:Protected) : "$protected"
               (v:Private) : "$private"}
      ILoadPackage :
         ($loadpackage filename pkg)

      IDoc :
         ($doc string)

      IDefType :
         ($deftype class (args ...) parent children ...)
      IDefChild :
         ($defchild name (args ...) parent)
      IDef :
         ($def name type value)
      IDefVar :
         ($defvar name type value)
      IDefn :
         if tail?(e) : ($defn* name (targs ...) (a1 ...) a2 (args ...) body)
         else : ($defn name (targs ...) (a1 ...) a2 (args ...) body)
      IDefmulti :
         ($defmulti name (targs ...) (a1 ...) a2)
      IDefmethod :
         if tail?(e) : ($defmethod* multi (targs ...) (a1 ...) a2 (args ...) body)
         else : ($defmethod multi (targs ...) (a1 ...) a2 (args ...) body)

      IFn :
         if tail?(e) : ($fn* (a1 ...) a2 (args ...) body)
         else : ($fn (a1 ...) a2 (args ...) body)
      IMulti :
         ($multi funcs ...)
      IBegin :
         ($begin exps ...)
      IMatch :
         ($match (args ...) branches ...)
      IBranch :
         ($branch (types ...) (args ...) body)
      INew :
         ($new class methods ...)
      IVar :
         custom{name(e)}
      ICast :
         ($cast exp type)
      IUpCast :
         ($upcast exp type)
      ISet :
         ($set name value)
      IDo :
         ($do func args ...)
      IPrim :
         ($prim op args ...)
      ILiteral :
         ($literal value type)
      ITuple :
         ($tuple exps ...)
      ILet :
         ($let exp)

      IOf :
         ($of class args ...)
      IAnd :
         ($and a b)
      IOr :
         ($or a b)
      IArrow :
         ($-> (a1 ...) a2)
      ICap :
         ($cap name)
      IGradual :
         ($?)
      IVoid :
         ($void)
      INone :
         ($none)

      ILSNew :
         ($ls-new type args ...)
      ILSStruct :
         ($ls-struct type args ...)
      ILSAddr :
         ($ls-addr exp)
      ILSDeref :
         ($ls-deref exp)
      ILSSlot :
         ($ls-slot exp index)
      ILSField :
         ($ls-field exp name)
      ILSDo :
         ($ls-do func args ...)
      ILSCallC :
         ($ls-call-c func args ...)
      ILSPrim :
         ($ls-prim op args ...)
      ILSSizeof :
         ($ls-sizeof type)
      ILSTagof :
         ($ls-tagof name)
      ILSAs :
         ($ls-as exp type)
      ILSAnd :
         ($ls-and a b)
      ILSOr :
         ($ls-or a b)
      ILSLetExp :
         ($ls-letexp comm exp)
      ILSFn :
         ($ls-fn ref)

      ILSSet :
         ($ls-set exp value)
      ILSLabels :
         ($ls-labels blocks ...)
      ILSLabeledBlock :
         ($ls-block name (args ...) (types ...) body)
      ILSGoto :
         ($ls-goto name args ...)
      ILSReturn :
         ($ls-return exp)
      ILSLet :
         ($ls-let comm)
      ILSIf :
         ($ls-if pred conseq alt)
      ILSMatch :
         ($ls-match args branches ...)
      ILSBranch :
         ($ls-branch (types ...) (args ...) body)

      ILSDef :
         ($ls-def name type exp)
      ILSDefVar :
         ($ls-defvar name type exp)
      ILSDefField :
         ($ls-deffield mut type name)
      ILSDefType :
         ($ls-deftype name (args ...) parent (fields ...) rfield)
      ILSExtern :
         ($ls-extern name type)
      ILSDefn :
         if tail?(e) : ($ls-defn* name (targs ...) (a1 ...) a2 (args ...) body)
         else : ($ls-defn name (targs ...) (a1 ...) a2 (args ...) body)
      ILSExternFn :
         ($ls-extern-fn name (a1 ...) a2 (args ...) body)
      ILSDefmethod :
         if tail?(e) : ($ls-defmethod* multi (targs ...) (a1 ...) a2 (args ...) body)
         else : ($ls-defmethod multi (targs ...) (a1 ...) a2 (args ...) body)

      ILSByteT :
         ($ls-byte)
      ILSIntT :
         ($ls-int)
      ILSLongT :
         ($ls-long)
      ILSFloatT :
         ($ls-float)
      ILSDoubleT :
         ($ls-double)
      ILSUnknownT :
         ($ls-?)
      ILSOfT :
         ($ls-of class args ...)
      ILSPtrT :
         ($ls-ptr type)
      ILSRefT :
         ($ls-ref type)
      ILSFnT :
         ($ls-fn (a1 ...) ar a2)

      ;=== Working Nodes ===
      VarN :
         custom{"$v%_" % [n(e)]}
      Let :
         ($let def body)
      LetRec :
         ($letrec (defns ...) body)
      LetPackage :
         ($letpackage name (imports ...) body)
      Raw :
         ($raw class)
      Mix :
         ($mix exps ...)

public defn name! (e:IExp) -> Symbol :
   match(e) :
      (e:IVar|LetPackage) : name(e)
      (e:ILoadPackage) : name(pkg(e))
      (e:IDefType) : name!(class(e))
      (e:IDefPackage|IDefChild|IDef|IDefVar|IDefn|IDefmulti|
         ISet|ICap|ILSField|ILSTagof|ILSLabeledBlock|
         ILSGoto|ILSDef|ILSDefVar|ILSDefType|ILSDefField|
         ILSExtern|ILSDefn|ILSExternFn) : name!(name(e))
      (e) : fatal("No name field: %_" % [e])   

public defn subexps (e:IExp) -> Collection<IExp> & Lengthable :
   val es = Vector<IExp>(4)
   do(add{es, _}, e)
   es

public defn flatten (es:List<IExp>) :
   for e in es seq-append :
      match(e) :
         (e:IBegin) : exps(e)
         (e) : List(e)

;Adds only a single level of flattening and assumes nested levels are already flattened
public defn Begin (es:List<IExp>, info:False|FileInfo) :
   val es* = flatten(es)
   if empty?(es*) : IBegin(es*, info)
   else if empty?(tail(es*)) : head(es*)
   else : IBegin(es*, info)

;Flatten and remove private expressions
;Adds only a single level of flattening and assumes nested levels are already flattened
public defn scope-flatten (es:List<IExp>) :
   for e in es seq-append :
      match(e) :
         (e:IBegin) :
           scope-flatten(exps(e))
         (e:IVisibility) :
           if visibility(e) is Private :
             scope-flatten(List(exp(e)))
           else :
             List(e)
         (e) : List(e)

public defn ScopeBegin (es:List<IExp>, info:False|FileInfo) :
   val es* = scope-flatten(es)
   if empty?(es*) : IBegin(es*, info)
   else if empty?(tail(es*)) : head(es*)
   else : IBegin(es*, info)

;============================================================
;=================== Serializer =============================
;============================================================

public defn serialize-il-pkg (o:FileOutputStream, x:IPackage) :
  serialize(o, x)

public defn deserialize-il-pkg (o:FileInputStream) -> IPackage :
  deserialize-pkg(o)

#use-added-syntax(stz-serializer-lang)

defn NameMap (entries:Tuple<VEntry>) -> NameMap:
  val namemap = NameMap()
  do(add{namemap, _}, entries)
  namemap

defn entries (x:NameMap) -> Tuple<VEntry> :
  to-tuple(x)

defserializer (out:FileOutputStream, in:FileInputStream) :

  defunion pkg (IPackage) :
    IPackage: (name:symbol, imports:tuple(iimport), exps:list(iexp), info:opt<FileInfo>(info), namemap:namemap)

  defunion iimport (IImport) :
    IImport: (package:symbol, prefix:tuple(iprefix), info:opt<FileInfo>(info), import-private?:bool)

  defunion iprefix (IPrefix) :
    IPrefix: (names:opt<Tuple<Symbol>>(tuple(symbol)), prefix:string)

  defunion namemap (NameMap) :
    NameMap: (entries:tuple(ventry))

  defunion ventry (VEntry) :
    VEntry: (n:int, package:symbol, name:symbol, visibility:visibility, type:etype, info:opt<FileInfo>(info))

  defunion visibility (Visibility) :
    Local: ()
    Private: ()
    Protected: ()
    Public: ()

  defunion etype (EType) :
    ValE : ()
    VarE : ()
    TVarE : ()
    CapVarE : ()
    TypeE : ()
    MultiE : ()
    FnE : ()
    LValE : ()
    LVarE : ()
    LFnE : ()
    LTypeE : ()
    FieldE : ()
    LabelE : ()

  defunion iexp (IExp) :
    IDefPackage: (name:iexp, imports:list(iexp), info:opt<FileInfo>(info))
    IImportExp: (package:iexp, prefix:list(iexp), info:opt<FileInfo>(info))
    IVisibility: (exp:iexp, visibility:visibility, info:opt<FileInfo>(info))
    ; ILoadPackage: (filename:string, pkg:any)
    IDoc: (string:iexp, info:opt<FileInfo>(info))
    IDefType: (class:iexp, args:list(iexp), parent:iexp, children:list(iexp), info:opt<FileInfo>(info))
    IDefChild: (name:iexp, args:list(iexp), parent:iexp, info:opt<FileInfo>(info))
    IDef: (name:iexp, type:iexp, value:iexp, info:opt<FileInfo>(info))
    IDefVar: (name:iexp, type:iexp, value:iexp, info:opt<FileInfo>(info))
    IDefn: (tail?:bool, name:iexp, targs:list(iexp), a1:list(iexp), a2:iexp, args:list(iexp), body:iexp, info:opt<FileInfo>(info))
    IDefmulti: (name:iexp, targs:list(iexp), a1:list(iexp), a2:iexp, info:opt<FileInfo>(info))
    IDefmethod: (tail?:bool, multi:iexp, thisn:opt<Int>(int), targs:list(iexp), a1:list(iexp), a2:iexp, args:list(iexp), body:iexp, info:opt<FileInfo>(info))
    IFn: (tail?:bool, a1:list(iexp), a2:iexp, args:list(iexp), body:iexp, info:opt<FileInfo>(info))
    IMulti: (funcs:list(iexp), info:opt<FileInfo>(info))
    IBegin: (exps:list(iexp), info:opt<FileInfo>(info))
    IMatch: (args:list(iexp), branches:list(iexp), info:opt<FileInfo>(info))
    IBranch: (types:list(iexp), args:list(iexp), body:iexp, info:opt<FileInfo>(info))
    INew: (class:iexp, methods:list(iexp), info:opt<FileInfo>(info))
    IVar: (name:symbol, info:opt<FileInfo>(info))
    ICast: (exp:iexp, type:iexp, info:opt<FileInfo>(info))
    IUpCast: (exp:iexp, type:iexp, info:opt<FileInfo>(info))
    ISet: (name:iexp, value:iexp, info:opt<FileInfo>(info))
    IDo: (func:iexp, args:list(iexp), info:opt<FileInfo>(info))
    IPrim: (op:iexp, args:list(iexp), info:opt<FileInfo>(info))
    ILiteral: (value:lit, type:iexp, info:opt<FileInfo>(info))
    ITuple: (exps:list(iexp), info:opt<FileInfo>(info))
    ILet: (exp:iexp, info:opt<FileInfo>(info))
    IOf: (class:iexp, args:list(iexp), info:opt<FileInfo>(info))
    IAnd: (a:iexp, b:iexp, info:opt<FileInfo>(info))
    IOr: (a:iexp, b:iexp, info:opt<FileInfo>(info))
    IArrow: (a1:list(iexp), a2:iexp, info:opt<FileInfo>(info))
    ICap: (name:iexp, info:opt<FileInfo>(info))
    IGradual: (info:opt<FileInfo>(info))
    IVoid: (info:opt<FileInfo>(info))
    INone: (info:opt<FileInfo>(info))

    ILSNew: (type:iexp, args:list(iexp), info:opt<FileInfo>(info))
    ILSStruct: (type:iexp, args:list(iexp), info:opt<FileInfo>(info))
    ILSAddr: (exp:iexp, unstable?:bool, info:opt<FileInfo>(info))
    ILSDeref: (exp: iexp, info:opt<FileInfo>(info))
    ILSSlot: (exp:iexp, index:iexp, info:opt<FileInfo>(info))
    ILSField: (exp:iexp, name:iexp, info:opt<FileInfo>(info))
    ILSDo: (func:iexp, args:list(iexp), info:opt<FileInfo>(info))
    ILSCallC: (func: iexp, args: list(iexp), info:opt<FileInfo>(info))
    ILSPrim: (op: iexp, args: list(iexp), info:opt<FileInfo>(info))
    ILSSizeof: (type: iexp, info:opt<FileInfo>(info))
    ILSTagof: (name: iexp, info:opt<FileInfo>(info))
    ILSAs: (exp: iexp type: iexp, info:opt<FileInfo>(info))
    ILSAnd: (a: iexp, b: iexp, info:opt<FileInfo>(info))
    ILSOr: (a: iexp, b: iexp, info:opt<FileInfo>(info))
    ILSLetExp: (comm: iexp, exp: iexp, info:opt<FileInfo>(info))
    ILSFn: (ref:iexp, info:opt<FileInfo>(info))
    
    ILSSet: (exp: iexp value: iexp, info:opt<FileInfo>(info))
    ILSLabels: (blocks: list(iexp), info:opt<FileInfo>(info))
    ILSLabeledBlock: (name: iexp args: list(iexp) types: list(iexp) body: iexp, info:opt<FileInfo>(info))
    ILSGoto: (name: iexp args: list(iexp), info:opt<FileInfo>(info))
    ILSReturn: (exp: iexp, info:opt<FileInfo>(info))
    ILSLet: (comm: iexp, info:opt<FileInfo>(info))
    ILSIf: (pred: iexp conseq: iexp alt: iexp, info:opt<FileInfo>(info))
    ILSMatch: (args: list(iexp) branches: list(iexp), info:opt<FileInfo>(info))
    ILSBranch: (types: list(iexp) args: list(iexp) body: iexp, info:opt<FileInfo>(info))

    ILSDef: (name: iexp type: iexp exp: iexp, info:opt<FileInfo>(info))
    ILSDefVar: (name: iexp type: iexp exp: iexp, info:opt<FileInfo>(info))
    ILSDefField: (mut : iexp type : iexp name : iexp, info:opt<FileInfo>(info))
    ILSDefType: (name: iexp args: list(iexp) parent: iexp fields : list(iexp) rfield : iexp, info:opt<FileInfo>(info))
    ILSExtern: (name: iexp type: iexp, info:opt<FileInfo>(info))
    ILSDefn: (tail?: bool name: iexp targs: list(iexp) a1: list(iexp) a2: iexp args: list(iexp) body: iexp, info:opt<FileInfo>(info))
    ILSExternFn: (name: iexp a1: list(iexp) a2: iexp args: list(iexp) body: iexp, info:opt<FileInfo>(info))
    ILSDefmethod: (tail?: bool multi: iexp targs: list(iexp) a1: list(iexp) a2: iexp args: list(iexp) body: iexp, info:opt<FileInfo>(info))

    ;=== LoStanza Type Forms ===
    ILSByteT: (info:opt<FileInfo>(info))
    ILSIntT: (info:opt<FileInfo>(info))
    ILSLongT: (info:opt<FileInfo>(info))
    ILSFloatT: (info:opt<FileInfo>(info))
    ILSDoubleT: (info:opt<FileInfo>(info))
    ILSUnknownT: (info:opt<FileInfo>(info))
    ILSOfT: (class:iexp, args: list(iexp), info:opt<FileInfo>(info))
    ILSPtrT: (type: iexp, info:opt<FileInfo>(info))
    ILSRefT: (type: iexp, info:opt<FileInfo>(info))
    ILSFnT: (a1: list(iexp) ar: iexp a2: iexp, info:opt<FileInfo>(info))

    ;===  Working Nodes ===
    VarN: (n: int, info:opt<FileInfo>(info))
    Raw: (class: iexp, info:opt<FileInfo>(info))
    Mix: (exps: list(iexp), info:opt<FileInfo>(info))
    Let: (def: iexp body: iexp, info:opt<FileInfo>(info))
    LetRec: (defns: list(iexp) body: iexp, info:opt<FileInfo>(info))
    LetPackage: (name: symbol imports: list(iexp) body: iexp, info:opt<FileInfo>(info))

  defunion info (FileInfo) :
    FileInfo: (filename:string, line:int, column:int)

  ;=====================
  ;==== Combinators ====
  ;=====================
  reader defn read-vector<?T> (f: () -> ?T) :
    val n = length!(read-int())
    to-vector<T>(repeatedly(f, n))

  writer defn write-vector<?T> (f: T -> False, xs:Vector<?T>) :
    write-int(length(xs))
    do(f, xs)

  reader defn read-tuple<?T> (f: () -> ?T) :
    val n = length!(read-int())
    to-tuple(repeatedly(f, n))

  writer defn write-tuple<?T> (f: T -> False, xs:Tuple<?T>) :
    write-int(length(xs))
    do(f, xs)

  reader defn read-list<?T> (f: () -> ?T) :
    val n = length!(read-int())
    to-list(repeatedly(f, n))

  writer defn write-list<?T> (f: T -> False, xs:List<?T>) :
    write-int(length(xs))
    do(f, xs)

  reader defn read-opt<T> (f: () -> T) :
    val n = read-byte()
    f() when n == 1Y

  writer defn write-opt<T> (f: T -> False, x:T|False) :
    match(x) :
      (x:False) :
        write-byte(0Y)
      (x:T) :
        write-byte(1Y)
        f(x)

  defatom bool (x:True|False) :
    writer :
      match(x) :
        (x:True) : put(out, 1Y)
        (x:False) : put(out, 0Y)
    reader :
      switch(get-byte(in)) :
        1Y : true
        0Y : false
        else : throw(DeserializeException())

  defatom int (x:Int) :
    writer :
      to-var-int(x, put{out, _})
    reader :
      from-var-int(read-byte)

  defatom long (x:Long) :
    writer :
      put(out, x)
    reader :
      match(get-long(in)) :
        (x:Long) : x
        (x:False) : throw(DeserializeException())

  defatom float (x:Float) :
    writer :
      put(out, x)
    reader :
      match(get-float(in)) :
        (x:Float) : x
        (x:False) : throw(DeserializeException())

  defatom double (x:Double) :
    writer :
      put(out, x)
    reader :
      match(get-double(in)) :
        (x:Double) : x
        (x:False) : throw(DeserializeException())

  defatom byte (x:Byte) :
    writer :
      put(out, x)
    reader :
      match(get-byte(in)) :
        (x:Byte) : x
        (x:False) : throw(DeserializeException())

  defatom char (x:Char) :
    writer :
      print(out, x)
    reader :
      match(get-char(in)) :
        (x:Char) : x
        (x:False) : throw(DeserializeException())

  defatom string (x:String) :
    writer :
      write-int(length(x))
      print(out, x)
    reader :
      val n = length!(read-int())
      String(repeatedly(read-char, n))

  defatom symbol (x:Symbol) :
    writer :
      write-string(to-string(x))
    reader :
      to-symbol(read-string())

  defatom bytearray (x:ByteArray) :
    writer :
      write-int(length(x))
      do(write-byte, x)
    reader :
      val n = length!(read-int())
      val x = ByteArray(n)
      for i in 0 to n do : x[i] = read-byte()
      x

  ;==================
  ;==== Literals ====
  ;==================
  defatom lit (x:?) :
    writer :
      match(x) :
        (x:Char) :
          write-byte(0Y)
          write-char(x)
        (x:Byte) :
          write-byte(1Y)
          write-byte(x)
        (x:Int) :
          write-byte(2Y)
          write-int(x)
        (x:Long) :
          write-byte(3Y)
          write-long(x)
        (x:Float) :
          write-byte(4Y)
          write-float(x)
        (x:Double) :
          write-byte(5Y)
          write-double(x)
        (x:String) :
          write-byte(6Y)
          write-string(x)
        (x:Symbol) :
          write-byte(7Y)
          write-symbol(x)
        (x:List) :
          write-byte(8Y)
          write-list(write-lit, x)
        (x:True) :
          write-byte(9Y)
        (x:False) :
          write-byte(10Y)
    reader :
      switch(read-byte()) :
        0Y : read-char()
        1Y : read-byte()
        2Y : read-int()
        3Y : read-long()
        4Y : read-float()
        5Y : read-double()
        6Y : read-string()
        7Y : read-symbol()
        8Y : read-list(read-lit)
        9Y : true
        10Y : false


defn non-neg! (x:Int) -> Int :
  if x < 0 : throw(DeserializeException())
  else : x

defn length! (x:Int) -> Int :
  if x < 0 : throw(DeserializeException())
  else if x > 8388608 : throw(DeserializeException())
  else : x

;============================================================
;=============== Variable Length Integer ====================
;============================================================

;Variable-Length Integer
;  0 <= x < 250 :             [x]
;  250 <= x < 506 :           [250 | x - 250]
;  506 <= x < 762 :           [251 | x - 506]
;  762 <= x < 1018 :          [252 | x - 762]
;  â€“32768 <= x < 32768 :      [253 | b1 , b0]
;  -8388608 <= x < 8388608 :  [254 | b2 , b1 , b0]
;  otherwise :                [255 | b3 , b2 , b1, b0]

defn to-var-int (x:Int, Y: Byte -> False) :
  defn B0 (x:Int) : Y(to-byte(x))
  defn B1 (x:Int) : Y(to-byte(x >> 8))
  defn B2 (x:Int) : Y(to-byte(x >> 16))
  defn B3 (x:Int) : Y(to-byte(x >> 24))
  if x >= 0 :
    if x < 250 : B0(x)
    else if x < 506 : (Y(250Y), B0(x - 250))
    else if x < 762 : (Y(251Y), B0(x - 506))
    else if x < 1018 : (Y(252Y), B0(x - 762))
    else if x < 32768 : (Y(253Y), B1(x), B0(x))
    else if x < 8388608 : (Y(254Y), B2(x), B1(x), B0(x))
    else : (Y(255Y), B3(x), B2(x), B1(x), B0(x))
  else :
    if x >= -32768 : (Y(253Y), B1(x), B0(x))
    else if x >= -8388608 : (Y(254Y), B2(x), B1(x), B0(x))
    else : (Y(255Y), B3(x), B2(x), B1(x), B0(x))

defn from-var-int (N: () -> Byte) -> Int :
  defn B0 () : to-int(N())
  defn B1 () : B0() << 8
  defn B2 () : B0() << 16
  defn S1 () : (B0() << 24) >>> 16
  defn S2 () : (B0() << 24) >>> 8
  defn S3 () : (B0() << 24)

  val x = N()
  switch(x) :
    255Y : S3() | B2() | B1() | B0()
    254Y : S2() | B1() | B0()
    253Y : S1() | B0()
    252Y : B0() + 762
    251Y : B0() + 506
    250Y : B0() + 250
    else : to-int(x)