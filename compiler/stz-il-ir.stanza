defpackage stz/il-ir :
   import core
   import verse

;General Multis for IExp
public defmulti info (e:IExp) -> FileInfo

#with-overlay(stz/ast-lang) :
   public defast :
      ;=== Types ===
      deftype IExp :
         info: FileInfo with: (as-method => true)

      ;=== Mappers/Doers ===
      defmap (f:IExp -> IExp, x:IExp) -> IExp :
         (x:IExp) :
            f(x)
         (x:List<IExp>) :
            map(f, x)
         (x:False|List<IExp>) :
            if x != false :
               map(f, x as List<IExp>)
         ignore(True|False)
         ignore(FileInfo)
         ignore(False|Int)
         ignore(Symbol)
         ignore(?)
         ignore(Int)

      defdo (f:IExp -> ?, x:IExp) -> ? :
         (x:IExp) :
            f(x)
         (x:List<IExp>) :
            do(f, x)
         (x:False|List<IExp>) :
            if x != false :
               do(f, x as List<IExp>)
         ignore(True|False)
         ignore(FileInfo)
         ignore(False|Int)
         ignore(Symbol)
         ignore(?)
         ignore(Int)
   
      defnodes IExp :
         ;=== Package Forms ===
         IPackage :
            name: IExp
            imports: List<IExp>
         IImport :
            package: IExp
            prefix: List<IExp>
         IPrefix :
            names: False|List<IExp>
            prefix: IExp
         IPublic :
            exp: IExp
         IProtected :
            exp: IExp
   
         ;=== Declaration Forms ===
         IDefType :
            class: IExp
            args: List<IExp>
            parent: IExp
         IDef :
            name: IExp
            type: IExp
            value: IExp
         IDefVar :
            name: IExp
            type: IExp
            value: IExp
         IDefn :
            tail?: True|False
            name: IExp
            targs: List<IExp>
            a1: List<IExp>
            a2: IExp
            args: List<IExp>
            body: IExp
         IDefmulti :
            name: IExp
            targs: List<IExp>
            a1: List<IExp>
            a2: IExp
         IDefmethod :
            tail?: True|False
            multi: IExp
            thisn: False|Int
            targs: List<IExp>
            a1: List<IExp>
            a2: IExp
            args: List<IExp>
            body: IExp
   
         ;=== Expression Forms ===
         IFn :
            tail?: True|False
            a1: List<IExp>
            a2: IExp
            args: List<IExp>
            body: IExp
         IMulti :
            funcs: List<IExp>
         IBegin :
            exps: List<IExp>
         IMatch :
            args: List<IExp>
            branches: List<IExp>
         IBranch :
            types: List<IExp>
            args: List<IExp>
            body: IExp
         INew :
            class: IExp
            methods: List<IExp>
         IVar :
            name: Symbol
         ICast :
            exp: IExp
            type: IExp
         ISet :
            name: IExp
            value: IExp
         IDo :
            func: IExp
            args: List<IExp>
         IPrim :
            function: IExp
            args: List<IExp>
         ICallLS :
            function: IExp
            args: List<IExp>
         ILiteral :
            value: ?
         ITuple :
            exps: List<IExp>
   
         ;=== Type Forms ===
         IOf :
            class: IExp
            args: List<IExp>
         IAnd :
            a: IExp
            b: IExp
         IOr :
            a: IExp
            b: IExp
         IArrow :
            a1: List<IExp>
            a2: IExp
         ICap :
            name: IExp
         IGradual
         IVoid
         INone
   
         ;=== LoStanza Expression Forms ===
         ILSVar :
            name: Symbol
         ILSRef :
            name: IExp
            args: List<IExp>
         ILSRefArray :
            name: IExp
            length: IExp
            args: List<IExp>
         ILSStruct :
            name: IExp
            args: List<IExp>
         ILSPtr :
            exp: IExp
         ILSDeref :
            exp: IExp
         ILSSlot :
            exp: IExp
            index: IExp
         ILSField :
            exp: IExp
            name: IExp
         ILSDo :
            func: IExp
            args: List<IExp>
         ILSCallC :
            func: IExp
            args: List<IExp>
         ILSPrim :
            op: IExp
            args: List<IExp>
         ILSSizeof :
            type: IExp
         ILSTagof :
            name: IExp
         ILSAs :
            exp: IExp
            type: IExp
         ILSSignedCast :
            exp: IExp
            type: IExp
         ILSUnsignedCast :
            exp: IExp
            type: IExp
         ILSValue :
            value: ?
            type: IExp
         ILSAnd :
            a: IExp
            b: IExp
         ILSOr :
            a: IExp
            b: IExp
   
         ;=== LoStanza Command Forms ===
         ILSTCall :
            exp: IExp
         ILSSet :
            exp: IExp
            value: IExp
         ILSLabel :
            name: IExp
         ILSGoto :
            name: IExp
         ILSReturn :
            exp: IExp
         ILSLet :
            comm: IExp
         ILSIf :
            pred: IExp
            conseq: IExp
            alt: IExp
         ILSBegin :
            comms: List<IExp>
         ILSMatch :
            exp: IExp
            branches: List<IExp>
         ILSBranch :
            exp: IExp
            type: IExp
            body: IExp
   
         ;=== LoStanza Declaration Forms ===
         ILSDef :
            name: IExp
            type: IExp
            exp: IExp
         ILSDefStruct :
            name: IExp
            parents: List<IExp>
            types: List<IExp>
            rtype: IExp
            fields: List<IExp>
            rfield: IExp
         ILSExtern :
            name: IExp
            type: IExp
         ILSExternFn :
            name: IExp
            type: IExp
         ILSDefn :
            name: IExp
            a1: List<IExp>
            a2: IExp
            args: List<IExp>
            body: IExp
   
         ;=== LoStanza Type Forms ===
         ILSByteT
         ILSIntT
         ILSLongT
         ILSFloatT
         ILSDoubleT
         ILSUnknownT
         ILSPtrT :
            type: IExp
         ILSRefT :
            type: IExp
         ILSFnT :
            a1: List<IExp>
            ar: IExp
            a2: IExp
   
         ;=== LoStanza Intrinsics ===
         ILSIntrinsic :
            name: IExp
            args: List<IExp>

         ;=== Working Nodes ===
         VarN :
            n: Int
         LSVarN :
            n: Int
         Raw :
            class: IExp
         Mix :
            exps: List<IExp>
         Let :
            def: IExp
            body: IExp
         LetRec :
            defns: List<IExp>
            body: IExp
         LetPackage :
            name: Symbol
            imports: List<IExp>
            body: IExp

;Printer
#with-overlay(stz/printer-lang) :
   defprinter (e:IExp) :
      IPackage :
         ($package name imports ...)
      IImport :
         ($import package prefix ...)
      IPrefix :
         if names(e) != false : ($prefix-of (names ...) prefix)
         else : ($prefix prefix)
      IPublic :
         ($public exp)
      IProtected :
         ($protected exp)
   
      IDefType :
         ($deftype class (args ...) parent)
      IDef :
         ($def name type value)
      IDefVar :
         ($defvar name type value)
      IDefn :
         if tail?(e) : ($defn* name (targs ...) (a1 ...) a2 (args ...) body)
         else : ($defn name (targs ...) (a1 ...) a2 (args ...) body)
      IDefmulti :
         ($defmulti (targs ...) (a1 ...) a2)
      IDefmethod :
         if tail?(e) : ($defmethod* multi (targs ...) (a1 ...) a2 (args ...) body)
         else : ($defmethod multi (targs ...) (a1 ...) a2 (args ...) body)
   
      IFn :
         if tail?(e) : ($fn* (a1 ...) a2 (args ...) body)
         else : ($fn (a1 ...) a2 (args ...) body)
      IMulti :
         ($multi funcs ...)
      IBegin :
         ($begin exps ...)
      IMatch :
         ($match (args ...) branches ...)
      IBranch :
         ($branch (types ...) (args ...) body)
      INew :
         ($new class methods ...)
      IVar :
         custom{name(e)}
      ICast :
         ($cast exp type)
      ISet :
         ($set name value)
      IDo :
         ($do func args ...)
      IPrim :
         ($prim function args ...)
      ICallLS :
         ($call-ls function args ...)
      ILiteral :
         custom{value(e)}
      ITuple :
         ($tuple exps ...)
   
      IOf :
         ($of class args ...)
      IAnd :
         ($and a b)
      IOr :
         ($or a b)
      IArrow :
         ($-> (a1 ...) a2)
      ICap :
         ($cap name)
      IGradual :
         ($?)
      IVoid :
         ($void)
      INone :
         ($none)

      ILSVar :
         custom{name(e)}
      ILSRef :
         ($ref name args ...)
      ILSRefArray :
         ($refarray name length args ...)
      ILSStruct :
         ($struct name args ...)
      ILSPtr :
         ($ptr exp)
      ILSDeref :
         ($deref exp)
      ILSSlot :
         ($slot exp index)
      ILSField :
         ($field exp name)
      ILSDo :
         ($do func args ...)
      ILSCallC :
         ($call-c func args ...)
      ILSPrim :
         ($prim op args ...)
      ILSSizeof :
         ($sizeof type)
      ILSTagof :
         ($tagof name)
      ILSAs :
         ($as exp type)
      ILSSignedCast :
         ($signed-cast exp type)
      ILSUnsignedCast :
         ($unsigned-cast exp type)
      ILSValue :
         ($value value type)
      ILSAnd :
         ($and a b)
      ILSOr :
         ($or a b)
      ILSIntrinsic :
         ($special name args ...)
   
      ILSTCall :
         ($tcall exp)
      ILSSet :
         ($set exp value)
      ILSLabel :
         ($label name)
      ILSGoto :
         ($goto name)
      ILSReturn :
         ($return exp)
      ILSLet :
         ($let comm)
      ILSIf :
         ($if pred conseq alt)
      ILSBegin :
         ($begin comms ...)
      ILSMatch :
         ($match exp branches ...)
      ILSBranch :
         ($branch exp type body)
   
      ILSDef :
         ($def name type exp)
      ILSDefStruct :
         ($defstruct name (parents ...) (types ...) rtype (fields ...) rfield)
      ILSExtern :
         ($extern name type)
      ILSExternFn :
         ($externfn name type)
      ILSDefn :
         ($defn name (a1 ...) a2 (args ...) body)
   
      ILSByteT :
         ($byte)
      ILSIntT :
         ($int)
      ILSLongT :
         ($long)
      ILSFloatT :
         ($float)
      ILSDoubleT :
         ($double)
      ILSUnknownT :
         ($?)
      ILSPtrT :
         ($ptr type)
      ILSRefT :
         ($ret type)
      ILSFnT :
         ($-> (a1 ...) ar a2)

      ;=== Working Nodes ===
      VarN :
         custom{"$v~" << [n(e)]}
      LSVarN :
         custom{"$v~" << [n(e)]}
      Let :
         ($let def body)
      LetRec :
         ($letrec (defns ...) body)
      LetPackage :
         ($letpackage name (imports ...) body)
      Raw :
         ($raw class)
      Mix :
         ($mix exps ...)