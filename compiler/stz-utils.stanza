defpackage stz/utils :
   import core
   import verse

;                 Failure Implementation
;                 ======================

var FAILURE-CLOSURE: () -> Void = fn* () :
   error("Uncaught failure.")

public defn fail () :
   FAILURE-CLOSURE()
   
public defn attempt-clause<?T> (conseq: () -> ?T, alt: () -> ?T) :
   val result = label<Option<T>> return :
      let-var FAILURE-CLOSURE = fn* () : return(None()) :
         Some(conseq())
   match(result) :
      (r:Some<T>) : item(r)
      (r:None) : alt()

;                       Arithmetic
;                       ==========
public defn ceil8 (x:Int) :
   (x + 7) & -8

;                        HeadLine
;                        ========

public defn headline (str:String) :
   val n = length(str)
   val m = 30 - n / 2
   println()
   do(print{" "}, 0 to m)
   println(str)
   do(print{" "}, 0 to m)
   do(print{"="}, 0 to n)
   println()

;                    Minima Calculation
;                    ==================

public defn minima<?T> (xs: List<?T>, less?: (T T) -> True|False) -> List<T> :
   defn* find-min (m: T, rest: List<T>, check: List<T>) -> List<T> :
      if empty?(rest) :
         List(m, minima(check, less?))
      else if m < head(rest) :
         find-min(m, tail(rest), check)
      else if head(rest) < m :
         find-min(head(rest), tail(rest), check)
      else :
         find-min(m, tail(rest), List(head(rest), check))
   if empty?(xs) : xs
   else : find-min(head(xs), tail(xs), List())

;                      Collections
;                      ===========

public defn repeat<?T> (x:?T, n:Int) :
   for i in 0 to n stream : x
   
public defn repeat<?T> (x:?T) :
   for i in 0 to false stream : x

public defn in-reverse<?T> (xs:Vector<?T>) :
   for i in (length(xs) - 1) through 0 by -1 stream :
      xs[i]

public defn reverse!<?T> (xs:Vector<?T>) :
   val n = length(xs)
   for i in 0 to n / 2 do :
      val j = n - 1 - i
      val xi = xs[i]
      val xj = xs[j]
      xs[i] = xj
      xs[j] = xi

public defn index-of!<?T> (xs:Streamable<?T>, x:T) :
   index-of(xs, x) as Int

public defn find!<?T> (f: T -> True|False, xs:Streamable<?T>) -> T :
   find(f, xs) as T

public defn find!<?T,?S> (f: (T, S) -> True|False, xs:Streamable<?T>, ys:Streamable<?S>) -> T :
   find(f, xs, ys) as T

public defn map<?T> (f:Int -> ?T, r:Range) :
   to-list(stream(f, r))

public defn lookup!<?T> (env:List<KeyValue<Int,?T>>, n:Int) :
   val e = for e in env find :
      key(e) == n
   match(e) :
      (e:KeyValue<Int,T>) : value(e)
      (e:False) : error("No entry for ~ in env." % [n])

public defn lookup<?T,?S> (env:List<KeyValue<Int,?T>>, n:Int, x:?S) :
   val e = for e in env find :
      key(e) == n
   match(e) :
      (e:KeyValue<Int,T>) : value(e)
      (e:False) : x

public defn lookup<?T> (env:List<KeyValue<Int,?T>>, n:Int) :
   lookup(env, n, false)


;============================================================
;================= Memory Watcher ===========================
;============================================================

public defclass MemWatch
public defmulti start (t:MemWatch) -> False
public defmulti stop (t:MemWatch) -> False
public defmulti int-value (t:MemWatch) -> Int
public defmulti value (t:MemWatch) -> Long

public defn MemWatch () -> MemWatch :
   var total:Long = to-long(0)
   var int-total:Int = 0
   var running = false
   var last-value = 0
   val limit = 1 << 30

   new MemWatch :
      defmethod start (this) :
         error("Watch already started.") when running
         running = true
         last-value = total-int-memory-allocated()
      defmethod stop (this) :
         error("Watch has not been started.") when not running
         running = false
         int-total = int-total + (total-int-memory-allocated() - last-value)
         value(this) when int-total > limit
         false
      defmethod int-value (this) :
         int-total
      defmethod value (this) :
         total = total + to-long(int-total)
         int-total = 0
         total
