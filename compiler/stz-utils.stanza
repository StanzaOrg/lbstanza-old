defpackage stz/utils :
   import core
   import verse

;                 Failure Implementation
;                 ======================

var FAILURE-CLOSURE: () -> Void = fn* () :
   error("Uncaught failure.")

public defn fail () :
   FAILURE-CLOSURE()
   
public defn attempt-clause<?T> (conseq: () -> ?T, alt: () -> ?T) :
   val result = label<Option<T>> return :
      FAILURE-CLOSURE = fn* () : return(None())
      Some(conseq())
   match(result) :
      (r:Some<T>) : item(r)
      (r:None) : alt()

;                       Arithmetic
;                       ==========
public defn ceil8 (x:Int) :
   (x + 7) & -8

;                        HeadLine
;                        ========

public defn headline (str:String) :
   val n = length(str)
   val m = 30 - n / 2
   println()
   do(print{" "}, 0 to m)
   println(str)
   do(print{" "}, 0 to m)
   do(print{"="}, 0 to n)
   println()

;                    Minima Calculation
;                    ==================

public defn minima<?T> (xs: List<?T>, less?: (T T) -> True|False) -> List<T> :
   defn* find-min (m: T, rest: List<T>, check: List<T>) -> List<T> :
      if empty?(rest) :
         List(m, minima(check, less?))
      else if m < head(rest) :
         find-min(m, tail(rest), check)
      else if head(rest) < m :
         find-min(head(rest), tail(rest), check)
      else :
         find-min(m, tail(rest), List(head(rest), check))
   if empty?(xs) : xs
   else : find-min(head(xs), tail(xs), List())

;                      Collections
;                      ===========

public defn in-reverse<?T> (xs:Vector<?T>) :
   for i in (length(xs) - 1) through 0 by -1 stream :
      xs[i]

public defn reverse!<?T> (xs:Vector<?T>) :
   val n = length(xs)
   for i in 0 to n / 2 do :
      val j = n - 1 - i
      val xi = xs[i]
      val xj = xs[j]
      xs[i] = xj
      xs[j] = xi

public defn index-of!<?T> (xs:Streamable<?T>, x:T) :
   index-of(xs, x) as Int

public defn find!<?T> (f: T -> True|False, xs:Streamable<?T>) -> T :
   find(f, xs) as T

public defn find!<?T,?S> (f: (T, S) -> True|False, xs:Streamable<?T>, ys:Streamable<?S>) -> T :
   find(f, xs, ys) as T