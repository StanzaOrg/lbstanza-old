defpackage stz/earley-parse-tree :
  import core
  import collections
  import stz/utils
  import stz/earley-eitems
  import stz/earley-grammar
  import stz/earley-sexp-stream
  import stz/earley-search
  import stz/tree-list

;============================================================
;===================== Main Algorithm =======================
;============================================================

public defn parse (eitems:ECompletionList, tset:TerminalSet, input-length:Int) -> ParseNode :
  val forest = ParseForest(eitems, tset)
  select-tree(forest, ParsedProd(0, 0, input-length))
  
;============================================================
;=================== New Parse Forest =======================
;============================================================

;Representation of a Parse Forest.
public deftype ParseForest

;===== Parse Items =====
defmulti items (f:ParseForest, prod:ParsedProd) -> List<EItem>

;===== Scanned Terminals =====
defmulti match? (f:ParseForest, term:GTerminal, position:Int) -> True|False

;===== Parse Positions =====
defmulti ends (f:ParseForest, item:EItem, item-end:Int, token-index:Int, token-start:Int) -> Seqable<Int>
defmulti starts (f:ParseForest, item:EItem, item-end:Int, token-index:Int, token-end:Int) -> Seqable<Int>

;------------------------------------------------------------
;---------------------- Interface ---------------------------
;------------------------------------------------------------

;Construct a parse forest from an Earley setlist.
defn ParseForest (eitems:ECompletionList,
                  tset:TerminalSet) -> ParseForest :
  ;Expand all right-recursive-children for the item 'item' ending
  ;at position 'item-end'.
  defn expand-right-recursive-children (item:EItem, item-end:Int) :
    if completion-root(item) is ChainCompletion :
      val c = completion-root(item) as ChainCompletion
      val items = Vector<EItem>()
      within item = expand-completion-item(c) :
        add(items, item)
      add(eitems, item-end, items)
      set-completion-root(item, NoCompletion())

  ;Return constructed Parse Forest.
  new ParseForest :
    ;===== Parse Items =====
    defmethod items (this, prod:ParsedProd) :
      items(eitems, /prod(prod), start(prod), end(prod))

    ;===== Scanned Terminals =====
    defmethod match? (this, term:GTerminal, position:Int) :
      tset[position, term]

    ;===== Parse Positions =====
    defmethod ends (this, item:EItem, item-end:Int, token-index:Int, token-start:Int) :
      ;Expand all right-recursive children
      expand-right-recursive-children(item, item-end)

      ;Get the tokens in the rule.
      val tokens = tokens(rule(item))

      ;Get the production at token-index.
      val prod = tokens[token-index] as GProduction
      
      ;Returns true if the production can be parsed between
      ;token-start and the given end. 
      defn feasible-end? (candidate-end:Int) -> True|False :
        if candidate-end <= item-end :
          items?(eitems, id(prod), token-start, candidate-end)

      ;Retrieve candidate ends.
      val candidate-ends =
        if last-production?(rule(item), token-index) :
          val num-tokens = length(tokens)
          val num-trailing-terminals = num-tokens - (token-index + 1)
          List(item-end - num-trailing-terminals)
        else :
          val dists = list(ends(item)[token-index])
          map({_ + parent(item)}, dists)

      ;Filter out the unfeasible ends
      filter(feasible-end?, candidate-ends)

    defmethod starts (this, item:EItem, item-end:Int, token-index:Int, token-end:Int) :
      ;Expand all right-recursive children
      expand-right-recursive-children(item, item-end)

      if first-production?(rule(item), token-index) :
        val num-leading-terminals = token-index
        List(parent(item) + num-leading-terminals)
      else :
        val tokens = tokens(rule(item))
        val prod = tokens[token-index] as GProduction
        val dists = reverse(list(ends(item)[token-index - 1]))
        val starts-lr = map({_ + parent(item)}, dists)
        val starts-rl = map(parent, items(eitems, id(prod), token-end))
        list-intersection(starts-lr, starts-rl)

;============================================================
;================ Selecting the Parse Tree ==================
;============================================================

;Select the highest priority parse tree from the ParseForest,
;according to the precedence rules. 
defn select-tree (forest:ParseForest, start-prod:ParsedProd) -> ParseNode :
  ;Node comparison functions
  val node-comparisons = node-comparison-functions()

  ;Return all rules that can be used to parse the given production.
  defn select-rules (prod:ParsedProd) -> Seqable<RuleSelection> :
    defn select (item:EItem) -> Seqable<RuleSelection> :
      match(params(rule(item))) :
        (p:FactoredParams) :
          val child-index = length(tokens(rule(item))) - 1
          val child-starts = starts(forest, item, end(prod), child-index, end(prod))
          for start in child-starts seq-cat :
            val prod-id = id(last-token(rule(item)) as GProduction)
            for sel in select(ParsedProd(prod-id, start, end(prod))) seq :
              FactoredRule(item, sel)
        (p:TokenRuleParams) :
          [LeafRule(item, end(prod))]
    defn select (prod:ParsedProd) -> Seqable<RuleSelection> :
      seq-cat(select, items(forest,prod))
    select(prod)

  ;Compute node from ParsedProd
  defn compute-node-from-prod (prod:ParsedProd) -> ParseNode :
    val nodes = seq(select, select-rules(prod))
    minimum(nodes, node-comparisons)

  ;Compute node from RuleSelection
  defn compute-node-from-sel (sel:RuleSelection) -> ParseNode :
    ;Compute the total number of tokens for the rule selection,
    ;and the end of the selection.
    val node-end = end(sel)
    val num-tokens = num-tokens(sel)

    ;Compute the parsed nodes for 'num' tokens starting at index 'index'
    ;starting from position 'position' and ending at position 'end-position'.
    ;If there is no valid parse starting and ending at the appropriate positions,
    ;then None() is returned. Otherwise returns the list of parse nodes.
    defn compute-left-to-right (num:Int, index:Int,
                                position:Int, end-position:Int) -> Maybe<List<ParseNode|Int>> :
      if num > 0 :
        val ri = sel[index]
        match(token(ri)) :
          (t:GProduction) :            
            val ends = ends(forest, item(ri), node-end, /index(ri), position)
            for end in ends first :
              for rest in compute-left-to-right(num - 1, index + 1, end, end-position) map :
                val node = select(ParsedProd(id(t), position, end))
                cons(node, rest)
          (t:GTerminal) :
            if match?(forest, t, position) :
              for rest in compute-left-to-right(num - 1, index + 1, position + 1, end-position) map :
                cons(position, rest)
            else :
              None()        
      else :
        if position == end-position : One(List())
        else : None()

    ;Compute the parsed nodes for the given 'num' tokens starting at index 0.
    ;The rule starts from 'start-position' and ends at 'end-position'.
    defn compute-right-then-left-to-right (num:Int, end-position:Int, start-position:Int) -> Maybe<List<ParseNode|Int>> :
      val ri = sel[num - 1]
      match(token(ri)) :
        (t:GProduction) :
          val starts = starts(forest, item(ri), end-position, /index(ri), end-position)
          for start in starts first :
            for rest in compute-left-to-right(num - 1, 0, start-position, start) map :
              val node = select(ParsedProd(id(t), start, end-position))
              append(rest, List(node))
        (t:GTerminal) :
          if match?(forest, t, end-position - 1) :
            for rest in compute-left-to-right(num - 1, 0, start-position, end-position - 1) map :
              append(rest, List(end-position - 1))
          else :
            None()

    ;Compute the parsed nodes for all tokens at and after the token
    ;at the given index starting from the given input position.
    ;If there is no valid parse starting from that position, then None()
    ;is returned.
    defn compute-left-to-right (index:Int, position:Int) -> Maybe<List<ParseNode|Int>> :
      compute-left-to-right(num-tokens - index, index, position, node-end)

    ;Compute the parsed nodes for all tokens at and before the token
    ;at the given index ending at the given input position.
    ;If there is no valid parse ending at that position, then None()
    ;is returned. Nodes are returned in right-to-left order.
    defn compute-right-to-left (index:Int, position:Int) -> Maybe<List<ParseNode|Int>> :
      if index >= 0 :
        val ri = sel[index]
        match(token(ri)) :
          (t:GProduction) :
            val starts = starts(forest, item(ri), node-end, /index(ri), position)
            for start in starts first :
              for rest in compute-right-to-left(index - 1, start) map :
                val node = select(ParsedProd(id(t), start, position))
                cons(node, rest)
          (t:GTerminal) :
            if match?(forest, t, position - 1) :
              for rest in compute-right-to-left(index - 1, position - 1) map :
                cons(position - 1, rest)
            else :
              None()
      else :
        One(List())

    ;Compute children
    defn compute-children () -> Tuple<ParseNode|Int> :
      defn left-to-right () :
        val cs = compute-left-to-right(0, parent(item(sel)))
        to-tuple(value!(cs))
      defn right-to-left () :
        val cs = compute-right-to-left(num-tokens - 1, node-end)
        to-tuple(reverse(value!(cs)))
      defn right-then-left-to-right () :
        val cs = compute-right-then-left-to-right(num-tokens, node-end, parent(item(sel)))
        to-tuple(value!(cs))
      val params = params(sel)
      match(operator-type(params), associativity(params)) :
        (opt, a:RightAssociative) : right-to-left()
        (opt:OperatorType, a:LeftAssociative|NonAssociative) : right-then-left-to-right()
        (opt:False, a:LeftAssociative|NonAssociative) : left-to-right()
        
    ;Launch!
    ParseNode(merged-rule(sel),
              parent(item(sel)),
              node-end,
              compute-children())

  ;Compute the appropriate parse node for the give range.
  defn select (sel:RuleSelection) -> ParseNode :
    LazyParseNode(sel, compute-node-from-sel)

  ;Compute the appropriate parse node for the given production.
  defn select (prod:ParsedProd) -> ParseNode :
    LazyParseNode(prod, compute-node-from-prod)

  ;Force traversal of ParseNode
  defn force (n:ParseNode) :
    do(force, filter-by<ParseNode>(children(n)))
    n

  ;Launch!
  force(select(start-prod))

;============================================================
;========== Choose the Most Specific ParseNode ==============
;============================================================

defn node-comparison-functions () -> Tuple<((ParseNode,ParseNode) -> Int)> :
  ;Return the length of the i'th child in node 'n'.
  defn child-length (n:ParseNode, i:Int) -> Int :
    val cs = children(n)
    if empty?(cs) :
      0
    else :
      match(cs[i]) :
        (c:Int) : 1
        (c:ParseNode) : length(c)

  ;Compare the child lengths greedily from left to right.
  defn compare-child-lengths-from-left (a:ParseNode, b:ParseNode) -> Int :
    val al = length(children(a))
    val bl = length(children(b))
    let loop (i:Int = 0, j:Int = 0) :
      if i < al and j < bl :
        val c = compare(child-length(a,i), child-length(b,i))
        if c == 0 : loop(i + 1, j + 1)
        else : c
      else :
        compare(bl, al)

  ;Compare the child lengths greedily from right to left.
  defn compare-child-lengths-from-right (a:ParseNode, b:ParseNode) -> Int :
    val al = length(children(a))
    val bl = length(children(b))
    let loop (i:Int = al - 1, j:Int = bl - 1) :
      if i >= 0 and j >= 0 :
        val c = compare(child-length(a,i), child-length(b,i))
        if c == 0 : loop(i - 1, j - 1)
        else : c
      else :
        compare(bl, al)

  ;Retrieve properties of a node
  defn params (n:ParseNode) :
    /params(rule(n)) as TokenRuleParams  

  ;Comparison functions ordered by importance.
  defn compare-priority (a:ParseNode, b:ParseNode) -> Int :
    compare(priority(params(b)), priority(params(a)))

  defn compare-associativity (a:ParseNode, b:ParseNode) -> Int :
    compare(associativity(params(a)), associativity(params(b)))

  defn compare-associativity-length (a:ParseNode, b:ParseNode) -> Int :
    match(associativity(params(a)), associativity(params(b))) :
      (aa:NonAssociative, ab:NonAssociative) :
        0
      (aa:LeftAssociative, ab:LeftAssociative) :
        compare-child-lengths-from-left(a, b)
      (aa:RightAssociative, ab:RightAssociative) :
        compare-child-lengths-from-right(a, b)

  defn compare-order (a:ParseNode, b:ParseNode) -> Int :
    compare(order(rule(a)) as Int, order(rule(b)) as Int)

  ;Most most specific node
  [compare-priority,
   compare-associativity,
   compare-associativity-length,
   compare-order]

;============================================================
;==================== Rule Selection ========================
;============================================================

;===== Datastructure Definition =====
deftype RuleSelection
defmulti item (s:RuleSelection) -> EItem
defmulti end (s:RuleSelection) -> Int

defstruct LeafRule <: RuleSelection :
  item: EItem with: (as-method => true)
  end: Int with: (as-method => true)
  
defstruct FactoredRule <: RuleSelection :
  item: EItem with: (as-method => true)
  child: RuleSelection  

defmethod end (r:FactoredRule) :
  end(child(r))

;===== Convenience Functions =====
defn num-tokens (r:RuleSelection) -> Int :
  val n = length(tokens(rule(item(r))))
  match(r) :
    (r:FactoredRule) : n - 1 + num-tokens(child(r))
    (r:LeafRule) : n

defn params (r:RuleSelection) -> TokenRuleParams :
  params(rule(item(leaf(r)))) as TokenRuleParams

defn leaf (r:RuleSelection) -> LeafRule :
  match(r:FactoredRule) : leaf(child(r))
  else : r as LeafRule

;===== Printed Representation =====
defmethod print (o:OutputStream, r:LeafRule) :
  print(o, "LeafRule(%_, %_)" % [item(r), end(r)])
  
defmethod print (o:OutputStream, r:FactoredRule) :
  val items = [
    "range = %_" % [item(r)]
    "child = %_" % [child(r)]]
  print(o, "FactoredRule(%_)" % [indented-list(items)])

;------------------------------------------------------------
;------------------ Merged Rule -----------------------------
;------------------------------------------------------------

;Merge the rule selection back into original
;unfactored rule.
defn merged-rule (sel:RuleSelection) -> GTokenRule :
  val tokenlist = Vector<GToken>()
  val leaf-rule = let loop (sel:RuleSelection = sel) :
    match(sel:FactoredRule) :
      val ts = tokens(rule(item(sel)))
      for i in 0 to length(ts) - 1 do :
        add(tokenlist, ts[i])
      loop(child(sel))
    else :
      add-all(tokenlist, tokens(rule(item(sel))))
      rule(item(sel))
  GTokenRule(id(leaf-rule),
             prod(rule(item(sel))),
             to-tuple(tokenlist),
             params(leaf-rule),
             order(leaf-rule))

;------------------------------------------------------------
;---------------------- SelIndex ----------------------------
;------------------------------------------------------------

;Represents a specific position in a RuleSelection.
;Contains the item for the rule and the index of the token
;within that item.
defstruct SelIndex :
  item: EItem
  index: Int

;Retrieve the token representing the SelIndex.
defn token (ri:SelIndex) -> GToken :
  tokens(rule(item(ri)))[index(ri)]

;Retrieve the i'th SelIndex in the given rule selection.
defn get (r:RuleSelection, i:Int) -> SelIndex :
  match(r) :
    (r:LeafRule) :
      SelIndex(item(r), i)
    (r:FactoredRule) :
      val n = length(tokens(rule(item(r)))) - 1
      if i < n : SelIndex(item(r), i)
      else : child(r)[i - n]

;============================================================
;==================== Parsed Production =====================
;============================================================

;Represents a parsed production between a given
;start and end position.
defstruct ParsedProd <: Hashable & Equalable :
  prod: Int
  start: Int
  end: Int
with:
  printer => true

defmethod equal? (a:ParsedProd, b:ParsedProd) :
  prod(a) == prod(b) and
  start(a) == start(b) and
  end(a) == end(b)

defmethod hash (p:ParsedProd) :
  prod(p) +
  71 * start(p) +
  171 * end(p)

;============================================================
;=============== ParseNode Datastructure ====================
;============================================================

;===== Interface =====
public deftype ParseNode
public defmulti start (n:ParseNode) -> Int
public defmulti end (n:ParseNode) -> Int
public defmulti rule (n:ParseNode) -> GTokenRule
public defmulti children (n:ParseNode) -> Tuple<ParseNode|Int>

;===== Simple Constructor =====
defn ParseNode (rule:GTokenRule, start:Int, end:Int, children:Tuple<ParseNode|Int>) :
  new ParseNode :
    defmethod start (this) : start
    defmethod end (this) : end
    defmethod rule (this) : rule
    defmethod children (this) : children

;===== Lazy Constructors =====
defn LazyParseNode (prod:ParsedProd, compute:ParsedProd -> ParseNode) :
  val cache = Cache(compute{prod})
  new ParseNode :
    defmethod start (this) : start(prod)
    defmethod end (this) : end(prod)
    defmethod rule (this) : rule(value(cache))
    defmethod children (this) : children(value(cache))

defn LazyParseNode (sel:RuleSelection, compute:RuleSelection -> ParseNode) :
  val leaf-rule = rule(item(leaf(sel)))
  val cache = Cache(compute{sel})
  new ParseNode :
    defmethod start (this) : parent(item(sel))
    defmethod end (this) : end(sel)
    defmethod rule (this) : rule(value(cache)) when computed?(cache) else leaf-rule
    defmethod children (this) : children(value(cache))

;===== Substitute Children =====
public defn sub-children (n:ParseNode, children:Tuple<ParseNode|Int>) :
  ParseNode(rule(n), start(n), end(n), children)

;===== Convenience Functions =====
public defn length (n:ParseNode) :
  end(n) - start(n)

;===== Debugging Representation =====
public defn format (grammar:Grammar, node:ParseNode) :
  within o = Printable() :
    print(o, "%_ [%_ to %_]" % [format(grammar, rule(node)), start(node), end(node)])
    val o2 = IndentedStream(o)
    do(lnprint{o2, format(grammar,_)}, filter-by<ParseNode>(children(node)))

;============================================================
;================ Utility: Cached Values ====================
;============================================================

;Represents a value whose computations is delayed. Use 'value'
;to force computation of the value (if it has not been computed already.)

deftype Cache<T>
defmulti value<?T> (cache:Cache<?T>) -> T
defmulti computed? (cache:Cache) -> True|False

defn Cache<?T> (f:() -> ?T) :
  var value:Maybe<T> = None()
  new Cache<T> :
    defmethod computed? (this) :
      not empty?(value)
    defmethod value (this) :
      if empty?(value) :
        value = One(f())
      value!(value)

;============================================================
;========== Utility: Retrieve Minima of Items ===============
;============================================================

;Given input items 'input-xs' and a ordered tuple of comparison functions 'compares',
;returns the minimum items. Earlier comparison functions take priority over later ones.
;The function attempts to use earlier comparison functions as much as possible, as
;it is assumed they are cheaper to compute than later ones.

defn minima<?T> (input-xs:Seqable<?T>, compares:Tuple<((T,T) -> Int)>) -> Tuple<T> :
  ;Move minima from xs to ys.
  ;Assumes that xs has length > 1.
  defn move-minima (xs:Vector<T>, ys:Vector<T>, compare:(T,T) -> Int) :
    add(ys, xs[0])
    for i in 1 to length(xs) do :
      switch(compare(xs[i], ys[0])) :
        1 :
          false
        0 :
          add(ys, xs[i])
        -1 :
          clear(ys)
          add(ys, xs[i])

  ;Create state
  val xs = to-vector<T>(input-xs)
  val ys = Vector<T>()
  fatal("Cannot take minima of empty sequence.") when empty?(xs)

  ;Iterate through comparison functions.
  let loop (xs:Vector<T> = xs, ys:Vector<T> = ys, ci:Int = 0) :
    if ci < length(compares) :
      if length(xs) > 1 :
        move-minima(xs, ys, compares[ci])
        clear(xs)
        loop(ys, xs, ci + 1)
      else : to-tuple(xs)
    else : to-tuple(xs)

defn minimum<?T> (input-xs:Seqable<?T>, compares:Tuple<((T,T) -> Int)>) -> T :
  minima(input-xs, compares)[0]

;============================================================
;======= Utility: Intersection of Two Sorted Lists ==========
;============================================================

defn* list-intersection (xs:List<Int>, ys:List<Int>) -> List<Int> :
  if empty?(xs) or empty?(ys) :
    List()
  else :
    switch(compare(head(xs), head(ys))) :
      -1 : list-intersection(tail(xs), ys)
      0 : cons(head(xs), list-intersection(tail(xs), tail(ys)))
      1 : list-intersection(xs, tail(ys))

;============================================================
;============= Utility: Printable From Closure ==============
;============================================================

defn Printable (f:OutputStream -> ?) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      f(o)

defn indented-list (xs:Seqable) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, xs)

;============================================================
;=============== Rule Utilities =============================
;============================================================
defn last-token (rule:GTokenRule) -> GToken :
  val n = length(tokens(rule))
  tokens(rule)[n - 1]

;Returns true if token at given index is the last production
;in the given rule.
defn last-production? (rule:GTokenRule, index:Int) -> True|False :
  val tokens = tokens(rule)
  for i in (index + 1) to length(tokens) none? :
    tokens[i] is GProduction

;Returns true if token at given index is the first production
;in the given rule.
defn first-production? (rule:GTokenRule, index:Int) -> True|False :
  val tokens = tokens(rule)
  for i in 0 to index none? :
    tokens[i] is GProduction

;Given the chain completion 'c', return the entire chain of
;expanded items not including the final root.
defn expand-completion-item (return:EItem -> ?, c:ChainCompletion) :
  val visited = HashSet<EItemCore>()
  defn fill-chain (item:EItem) :
    match(completion-root(item)) :
      (r:ChainLink) :
        if add(visited,core(item)) :
          return(inc-num-parsed(item, false))
          fill-chain(link(r))
      (r:ChainRoot) :
        false
  do(fill-chain, items(c))

;============================================================
;================ Utility: Maybe Mapper =====================
;============================================================
defn map<?T,?S> (f:T -> ?S, x:Maybe<?T>) -> Maybe<S> :
  if empty?(x) : None()
  else : One(f(value!(x)))