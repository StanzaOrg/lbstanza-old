defpackage stz/earley-parse-tree :
  import core
  import collections
  import stz/earley-eitems
  import stz/earley-grammar

;============================================================
;===================== Main Algorithm =======================
;============================================================

public defn parse (grammar:Grammar, setlist:ESetList) -> ParseNode :
  val forest = ParseForest(grammar, setlist)
  select-tree(grammar, forest)

;============================================================
;==================== Output Datastructures =================
;============================================================

public defstruct ParseNode :
  prod: ParsedProd
  range: ParsedRange
  children: Tuple<ParseNode|Int>

public defstruct ParsedRange <: HasParts :
  rule: Int
  start: Int
  end: Int
with:
  printer => true

defmethod parts (r:ParsedRange) :
  [`ParsedRange, rule(r), start(r), end(r)]

public defn length (n:ParseNode) :
  end(prod(n)) - start(prod(n))

;Represents a parsed production between a given
;start and end position.
defstruct ParsedProd <: HasParts :
  prod: Int
  start: Int
  end: Int
with:
  printer => true

defmethod parts (t:ParsedProd) :
  [`ParsedProd, prod(t), start(t), end(t)]

;============================================================
;===================== Utilities ============================
;============================================================

;Represents token at the given index in a specific
;rule starting at a given position.
defstruct ParsedToken <: HasParts :
  rule: Int
  rule-start: Int
  token-index: Int
with:
  printer => true

defmethod parts (t:ParsedToken) :
  [`ParsedToken, rule(t), rule-start(t), token-index(t)]

;Represents a parsed production that ends at the given position.
defstruct ProdEnd <: HasParts :
  prod: Int
  end: Int
with:
  printer => true

defmethod parts (t:ProdEnd) :
  [`ProdEnd, prod(t), end(t)]

;Represents a matched terminal at a given position.
defstruct ParsedTerminal <: HasParts :
  terminal: GTerminal
  position: Int
with:
  printer => true

defmethod parts (t:ParsedTerminal) :
  [`ParsedTerminal, terminal(t), position(t)]

;============================================================
;================== Simple Hash =============================
;============================================================

deftype HasParts <: Hashable & Equalable
defmulti parts (p:HasParts) -> Tuple
defmethod hash (p:HasParts) : hash(parts(p))
defmethod equal? (a:HasParts, b:HasParts) : parts(a) == parts(b)

;============================================================
;====================== Debugging ===========================
;============================================================

public defn format (grammar:Grammar, r:ParsedRange) :
  "(rule %_) [%_ to %_] %_" % [rule(r), start(r), end(r), format(grammar,grammar[rule(r)])]

public defn format (grammar:Grammar, node:ParseNode) :
  within o = Printable() :
    print(o, format(grammar, range(node)))
    val o2 = IndentedStream(o)
    do(lnprint{o2, format(grammar,_)}, filter-by<ParseNode>(children(node)))

defn Printable (f:OutputStream -> ?) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      f(o)

;============================================================
;=================== New Parse Forest =======================
;============================================================

;Representation of a Parse Forest.
deftype ParseForest

;Answers the query:
;Given:
;- The parent parsed range (a range of input parsed using some rule),
;- The index of the token (assumed to be a production) in the rule,
;_ The starting position of this token,
;Return:
;- All potential ends for the parsed range corresponding to that token, sorted
;  in decreasing order.
defmulti ends (f:ParseForest, range:ParsedRange, token-index:Int, token-start:Int) -> Seqable<Int>

;Answers the query:
;Given:
;- The parent parsed range (a range of input parsed using some rule),
;- The index of the token (assumed to be a production) in the rule,
;_ The ending position of this token,
;Return:
;- All potential starts for the parsed range corresponding to that token, sorted
;  in increasing order.
defmulti starts (f:ParseForest, range:ParsedRange, token-index:Int, token-end:Int) -> Seqable<Int>

;Returns true if the given terminal matches the input at the given
;position.
defmulti match? (f:ParseForest, term:GTerminal, position:Int) -> True|False

;Given:
;- A production,
;- A start and end position,
;Return:
;- All possible parses for production in that range of input.
defmulti get (f:ParseForest, prod:ParsedProd) -> List<ParsedRange>

;Retrieve the root ParsedRange representing the forest.
defmulti start (f:ParseForest) -> ParsedRange

;Construct a parse forest from an Earley setlist.
defn ParseForest (grammar:Grammar, setlist:ESetList) -> ParseForest :
  ;For all parsed tokens (that are not at the end of a rule),
  ;record their ending position.
  val prod-ends = HashTable<ParsedToken, List<Int>>(List())

  ;Holds the set of all of the matched terminals.
  val terminal-set = HashSet<ParsedTerminal>()

  ;For all completed productions, record the rule
  ;they were parsed with.
  val prod-rules = HashTable<ParsedProd,List<Int>>(List())

  ;For all parsed productions (that are not at the beginning of a rule),
  ;record their starting position.
  val prod-starts = HashTable<ProdEnd, List<Int>>(List())

  ;If an index exists in prod-calculated, then the appropriate
  ;entries in that set has been added to prod-rules.
  val prod-calculated = IntSet()

  ;Compute the prod-ends table.
  defn compute-prod-ends () :
    ;Iterate through setlist.
    for eset in sets(setlist) do :
      ;Scan through items in list to build production rules.
      for item in items(setlist, eset) do :
        match(previous(grammar,item)) :
          (prev:GProduction) :
            if upcoming(grammar,item) is-not False :
              val rule = rule(item)
              val rule-start = parent(item)
              val token-index = num-parsed(item) - 1
              val token-end = index(eset)
              val parsed-token = ParsedToken(rule, rule-start, token-index)
              update(prod-ends, cons{token-end, _}, parsed-token)
          (prev:GTerminal) :
            val token-position = index(eset) - 1
            val parsed-terminal = ParsedTerminal(prev, token-position)
            add(terminal-set, parsed-terminal)
          (f:False) :
            false

  ;Retrieve the rules that can successfully parse
  ;the given production between tokens start and end.
  defn get-prod-rules (prod:ParsedProd) -> List<Int> :
    compute-prod-rules(end(prod))
    prod-rules[prod]

  ;Retrieve the rules that can successfully parse
  ;the given production between tokens start and end.
  defn get-prod-starts (prod:ProdEnd) -> List<Int> :
    compute-prod-rules(end(prod))
    prod-starts[prod]

  ;If not already computed, process each item
  ;in the given set, and add its entries to the
  ;prod-rules table.
  defn compute-prod-rules (set-index:Int) :
    if add(prod-calculated, set-index) :
      val updated-prods = IntSet()
      val eset = setlist[set-index]
      for item in items(setlist, eset) do :
        if upcoming(grammar,item) is False :
          add-prod-rule(item, index(eset), updated-prods)
          if completion-root(item) is-not False :
            within item = expand-completion-item(item) :
              add-prod-rule(item, index(eset), updated-prods)
      for prod in updated-prods do :
        val prod-end = ProdEnd(prod, index(eset))
        update(prod-starts, to-list{lazy-qsort(_)}, prod-end)

  ;Add the given completion (in set 'end') to the
  ;prod-rules table.
  defn add-prod-rule (item:EItem, end:Int, updated-prods:IntSet) :
    val prod = production(grammar,item)
    val rule = rule(item)
    val start = parent(item)
    val parsed-prod = ParsedProd(prod, start, end)
    update(prod-rules, cons{rule, _}, parsed-prod)
    val prod-end = ProdEnd(prod, end)
    update(prod-starts, cons{start, _}, prod-end)
    add(updated-prods, prod)

  ;Given the completed item with completion root,
  ;Return the entire chain of expanding the items not including the
  ;final root.
  defn expand-completion-item (return:EItem -> ?, item:EItem) :
    val root-core = core(item)
    let loop (x:EItem = completion-root(item) as EItem) :
      if core(x) != root-core :
        return(x)
        val x* = first-item(setlist, parent(x), production(grammar,x))
        loop(inc-num-parsed(x* as EItem, false))

  ;Returns true if token at given index is the last production
  ;in the given rule.
  defn last-production? (rule:Int, index:Int) -> True|False :
    val tokens = tokens(grammar[rule])
    for i in (index + 1) to length(tokens) none? :
      tokens[i] is GProduction

  ;Returns true if token at given index is the first production
  ;in the given rule.
  defn first-production? (rule:Int, index:Int) -> True|False :
    val tokens = tokens(grammar[rule])
    for i in 0 to index none? :
      tokens[i] is GProduction

  ;Compute all tables
  compute-prod-ends()

  ;Return constructed Parse Forest.
  new ParseForest :
    defmethod start (this) :
      ;The last input is the EndOfInput token, and is where
      ;the starting rule ends.
      val rule = next(to-seq(rules(grammar,0)))
      ParsedRange(rule, 0, length(setlist) - 1)
      
    defmethod ends (this, range:ParsedRange, token-index:Int, token-start:Int) :
      ;Get the production at token-index.
      val tokens = tokens(grammar[rule(range)])
      val prod = tokens[token-index] as GProduction
      
      ;Returns true if the current token can be parsed between
      ;token-start and the given end. 
      defn feasible-end? (candidate-end:Int) -> True|False :
        if candidate-end <= end(range) :
          val prod = ParsedProd(id(prod), token-start, candidate-end)
          not empty?(get-prod-rules(prod))

      ;Retrieve candidate ends.
      val candidate-ends =
        if last-production?(rule(range), token-index) :
          val num-tokens = length(tokens)
          val num-trailing-terminals = num-tokens - (token-index + 1)
          List(end(range) - num-trailing-terminals)
        else :
          val token = ParsedToken(rule(range), start(range), token-index)
          prod-ends[token]

      ;Filter out the unfeasible ends
      filter(feasible-end?, candidate-ends)

    defmethod starts (this, range:ParsedRange, token-index:Int, token-end:Int) :
      ;Get the production at token-index.
      val tokens = tokens(grammar[rule(range)])
      val prod = tokens[token-index] as GProduction

      ;Returns true if the current token can be parsed between
      ;the given start and token-end.
      defn feasible-start? (candidate-start:Int) -> True|False :
        if candidate-start >= start(range) :
          val prod = ParsedProd(id(prod), candidate-start, token-end)
          not empty?(get-prod-rules(prod))
      
      ;Retrieve candidate starts.
      val candidate-starts =
        if first-production?(rule(range), token-index) :
          val num-leading-terminals = token-index
          List(start(range) + num-leading-terminals)
        else :
          val prod = ProdEnd(id(prod), token-end)
          get-prod-starts(prod)
          
      ;Filter out the unfeasible starts
      filter(feasible-start?, candidate-starts)
      
    defmethod match? (this, term:GTerminal, position:Int) :
      terminal-set[ParsedTerminal(term, position)]
      
    defmethod get (this, prod:ParsedProd) :
      for rule in get-prod-rules(prod) map :
        ParsedRange(rule, start(prod), end(prod))

;============================================================
;================ Selecting the Parse Tree ==================
;============================================================

;------------------------------------------------------------
;------------------- Cache Utility --------------------------
;------------------------------------------------------------

deftype Cache<T>
defmulti value<?T> (cache:Cache<?T>) -> T
defn Cache<?T> (f:() -> ?T) :
  var value:Maybe<T> = None()
  new Cache<T> :
    defmethod value (this) :
      if empty?(value) :
        value = One(f())
      value!(value)

;------------------------------------------------------------
;--------------------- LazyParseNode ------------------------
;------------------------------------------------------------
defn LazyParseNode (prod:ParsedProd, compute:ParsedProd -> ParseNode) :
  val cache = Cache(compute{prod})
  new ParseNode :
    defmethod prod (this) : prod
    defmethod range (this) : range(value(cache))
    defmethod children (this) : children(value(cache))

defn LazyParseNode (grammar:Grammar, range:ParsedRange, compute:ParsedRange -> ParseNode) :
  val prod-id = prod(grammar[rule(range)])
  val cache = Cache(compute{range})
  new ParseNode :
    defmethod prod (this) : ParsedProd(prod-id, start(range), end(range))
    defmethod range (this) : range
    defmethod children (this) : children(value(cache))

;------------------------------------------------------------
;-------------------- Select Tree ---------------------------
;------------------------------------------------------------
defn select-tree (grammar:Grammar, forest:ParseForest) -> ParseNode :
  ;Compute node from ParsedProd
  defn compute-node-from-prod (prod:ParsedProd) -> ParseNode :
    val ranges = forest[prod]
    most-specific(grammar, seq(select, ranges))

  ;Compute node from ParsedRange.
  defn compute-node-from-range (range:ParsedRange) -> ParseNode :
    val grule = grammar[rule(range)]
    
    ;Compute the parsed nodes for all tokens at and after the token
    ;at the given index starting from the given input position.
    ;If there is no valid parse starting from that position, then None()
    ;is returned.
    defn compute-left-to-right (index:Int, position:Int) -> Maybe<List<ParseNode|Int>> :
      if index < length(tokens(grule)) :
        match(tokens(grule)[index]) :
          (t:GProduction) :            
            val ends = ends(forest, range, index, position)
            val tried = Vector<Int>()
            val end-entry = for end in ends first :
              add(tried, end)
              val rest = compute-left-to-right(index + 1, end)
              if empty?(rest) : None()
              else : One(end => value!(rest))
            println("LR %_: Tried %_ ends for token %_ at position %_: %," % [
              format(grammar,range), length(tried), index, position, tried])
            if empty?(end-entry) :
              None()
            else :
              val end = key(value!(end-entry))
              val rest = value(value!(end-entry))
              val node = select(ParsedProd(id(t), position, end))
              One(cons(node, rest))
          (t:GTerminal) :
            if match?(forest, t, position) :
              val result = compute-left-to-right(index + 1, position + 1)
              if empty?(result) : None()
              else : One(cons(position, value!(result)))
            else :
              None()
      else :
        fatal("Inconsistent end.") when position != end(range)
        One(List())

    ;Compute the parsed nodes for all tokens at and before the token
    ;at the given index ending at the given input position.
    ;If there is no valid parse ending at that position, then None()
    ;is returned. Nodes are returned in right-to-left order.
    defn compute-right-to-left (index:Int, position:Int) -> Maybe<List<ParseNode|Int>> :
      if index >= 0 :
        match(tokens(grule)[index]) :
          (t:GProduction) :
            val starts = starts(forest, range, index, position)
            val tried = Vector<Int>()
            val start-entry = for start in starts first :
              add(tried, start)
              val rest = compute-right-to-left(index - 1, start)
              if empty?(rest) : None()
              else : One(start => value!(rest))
            println("RL %_: Tried %_ starts for token %_ at position %_: %," % [
              format(grammar,range), length(tried), index, position, tried])
            if empty?(start-entry) :
              None()
            else :
              val start = key(value!(start-entry))
              val rest = value(value!(start-entry))
              val node = select(ParsedProd(id(t), start, position))
              One(cons(node, rest))
          (t:GTerminal) :
            if match?(forest, t, position - 1) :
              val result = compute-right-to-left(index - 1, position - 1)
              if empty?(result) : None()
              else : One(cons(position - 1, value!(result)))
            else :
              None()
      else :
        fatal("Inconsistent start.") when position != start(range)
        One(List())

    ;Compute children
    defn compute-children () -> Tuple<ParseNode|Int> :
      defn left-to-right () :
        val cs = compute-left-to-right(0, start(range))
        to-tuple(value!(cs))
      defn right-to-left () :
        val num-tokens = length(tokens(grule))
        val cs = compute-right-to-left(num-tokens - 1, end(range))
        to-tuple(reverse(value!(cs)))        
      match(params(grule)) :
        (params:TokenRuleParams) :
          if operator-type(params) is False :
            match(associativity(params)) :
              (a:LeftAssociative) : left-to-right()
              (a:RightAssociative) : right-to-left()
              (a:NonAssociative) : left-to-right()
          else :
            right-to-left()
        (params:InheritParams) :
          left-to-right()
        
    ;Launch!
    val prod = ParsedProd(prod(grule), start(range), end(range))
    ParseNode(prod, range, compute-children())

  ;Compute the appropriate parse node for the give range.
  defn select (range:ParsedRange) -> ParseNode :
    val grule = grammar[rule(range)]
    if params(grule) is InheritParams :
      val node = compute-node-from-range(range)
      children(node)[0] as ParseNode
    else :
      LazyParseNode(grammar, range, compute-node-from-range)

  ;Compute the appropriate parse node for the given production.
  defn select (prod:ParsedProd) -> ParseNode :
    LazyParseNode(prod, compute-node-from-prod)

  ;Launch!
  val result = select(start(forest))
  let force (n:ParseNode = result) :
    do(force, filter-by<ParseNode>(children(n)))
  result

;------------------------------------------------------------
;---------- Utility: Retrieve Minima of Items ---------------
;------------------------------------------------------------
defn minima<?T> (input-xs:Seqable<?T>, compares:Tuple<((T,T) -> Int)>) -> Tuple<T> :
  ;Move minima from xs to ys.
  ;Assumes that xs has length > 1.
  defn move-minima (xs:Vector<T>, ys:Vector<T>, compare:(T,T) -> Int) :
    add(ys, xs[0])
    for i in 1 to length(xs) do :
      switch(compare(xs[i], ys[0])) :
        1 :
          false
        0 :
          add(ys, xs[i])
        -1 :
          clear(ys)
          add(ys, xs[i])

  ;Create state
  val xs = to-vector<T>(input-xs)
  val ys = Vector<T>()
  fatal("Cannot take minima of empty sequence.") when empty?(xs)

  ;Iterate through comparison functions.
  let loop (xs:Vector<T> = xs, ys:Vector<T> = ys, ci:Int = 0) :
    if ci < length(compares) :
      if length(xs) > 1 :
        move-minima(xs, ys, compares[ci])
        clear(xs)
        loop(ys, xs, ci + 1)
      else : to-tuple(xs)
    else : to-tuple(xs)

;------------------------------------------------------------
;---------- Choose the Most Specific ParseNode --------------
;------------------------------------------------------------

defn most-specific (grammar:Grammar, nodes:Seqable<ParseNode>) -> ParseNode :
  ;Compute the lengths of the first and last child
  ;in the given nodes.
  defn child-length (cs:Tuple<ParseNode|Int>, i:Int) -> Int :
    if empty?(cs) :
      0
    else :
      match(cs[i]) :
        (c:Int) : 1
        (c:ParseNode) : length(c)
  defn first-child-length (n:ParseNode) -> Int :
    val cs = children(n)
    child-length(cs, 0)
  defn last-child-length (n:ParseNode) -> Int :
    val cs = children(n)
    val l = length(cs)
    child-length(cs, l - 1)

  ;Retrieve properties of a node
  defn rule (n:ParseNode) : grammar[/rule(range(n))]
  defn params (n:ParseNode) : /params(rule(n)) as TokenRuleParams  

  ;Comparison functions ordered by importance.
  defn compare-length (a:ParseNode, b:ParseNode) -> Int :
    compare(length(b), length(a))

  defn compare-priority (a:ParseNode, b:ParseNode) -> Int :
    compare(priority(params(b)), priority(params(a)))

  defn compare-associativity (a:ParseNode, b:ParseNode) -> Int :
    compare(associativity(params(a)), associativity(params(b)))

  defn compare-associativity-length (a:ParseNode, b:ParseNode) -> Int :
    match(associativity(params(a)), associativity(params(b))) :
      (aa:NonAssociative, ab:NonAssociative) :
        0
      (aa:LeftAssociative, ab:LeftAssociative) :
        compare(first-child-length(b), first-child-length(a))
      (aa:RightAssociative, ab:RightAssociative) :
        compare(last-child-length(b), last-child-length(a))

  defn compare-order (a:ParseNode, b:ParseNode) -> Int :
    compare(order(rule(a)) as Int, order(rule(b)) as Int)

  ;Most most specific node
  val minima = minima(nodes, [compare-length,
                              compare-priority,
                              compare-associativity,
                              compare-associativity-length,
                              compare-order])
  minima[0]