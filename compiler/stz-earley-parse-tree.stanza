defpackage stz/earley-parse-tree :
  import core
  import collections
  import stz/earley-eitems
  import stz/earley-grammar

;============================================================
;===================== Main Algorithm =======================
;============================================================

public defn parse (grammar:Grammar, setlist:ESetList) -> ParseNode :
  val forest = ParseForest(grammar, setlist)
  select-tree(grammar, forest)

public defn new-parse (grammar:Grammar, setlist:ESetList) -> ParseNode :
  val forest = NewParseForest(grammar, setlist)
  new-select-tree(grammar, forest)

;============================================================
;==================== Output Datastructures =================
;============================================================

public defstruct ParseNode :
  range: ParsedRange
  children: Tuple<ParseNode|Int>

public defstruct ParsedRange <: HasParts :
  rule: Int
  start: Int
  end: Int
with:
  printer => true

defmethod parts (r:ParsedRange) : [`ParsedRange, rule(r), start(r), end(r)]

public defn length (r:ParsedRange) :
  end(r) - start(r)

;============================================================
;===================== Utilities ============================
;============================================================

defstruct PartialRule <: HasParts :
  rule: Int
  num-parsed: Int
  start: Int
  end: Int
with:
  printer => true

defmethod parts (r:PartialRule) : [`PartialRule, rule(r), num-parsed(r), start(r), end(r)]

defstruct ProdPos <: HasParts :
  production: Int
  position: Int
with:
  printer => true

defmethod parts (k:ProdPos) : [`ProdPos, production(k), position(k)]

defstruct ParsedToken <: HasParts :
  rule: Int
  rule-start: Int
  token-index: Int
  token-start: Int
with:
  printer => true

defmethod parts (t:ParsedToken) : [`ParsedToken, rule(t), rule-start(t), token-index(t), token-start(t)]

defstruct ParsedProd <: HasParts :
  prod: Int
  start: Int
  end: Int
with:
  printer => true

defmethod parts (t:ParsedProd) : [`ParsedProd, prod(t), start(t), end(t)]

;============================================================
;================== Simple Hash =============================
;============================================================

deftype HasParts <: Hashable & Equalable
defmulti parts (p:HasParts) -> Tuple
defmethod hash (p:HasParts) : hash(parts(p))
defmethod equal? (a:HasParts, b:HasParts) : parts(a) == parts(b)

;============================================================
;====================== Debugging ===========================
;============================================================

public defn format (grammar:Grammar, r:ParsedRange) :
  "(rule %_) [%_ to %_] %_" % [rule(r), start(r), end(r), format(grammar,grammar[rule(r)])]

public defn format (grammar:Grammar, node:ParseNode) :
  within o = Printable() :
    print(o, format(grammar, range(node)))
    val o2 = IndentedStream(o)
    do(lnprint{o2, format(grammar,_)}, filter-by<ParseNode>(children(node)))

defn Printable (f:OutputStream -> ?) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      f(o)

;============================================================
;=============== Parse Forest Interface =====================
;============================================================

deftype ParseForest

;Retrieve the subranges for each parsed range.
defmulti get (f:ParseForest, r:ParsedRange, index:Int, position:Int) -> Seqable<ParsedRange>

;Retrieve the root ParsedRange representing the forest.
defmulti start (f:ParseForest) -> ParsedRange

;============================================================
;=================== New Parse Forest =======================
;============================================================

deftype NewParseForest

;Answers the query:
;Given:
;  - The parent parsed range (a range of input parsed using some rule),
;  - The index of the token (assumed to be a production) in the rule,
;  _ The starting position of this token,
;Return:
;  - All potential ends for the parsed range corresponding to that token, sorted
;    in decreasing order.
defmulti ends (f:NewParseForest, range:ParsedRange, token-index:Int, token-start:Int) -> Seqable<Int>

;Given:
;  - A production,
;  - A start and end position,
;Return:
;  - All possible parses for production in that range of input.
defmulti get (f:NewParseForest, prod:Int, start:Int, end:Int) -> List<ParsedRange>

;Retrieve the root ParsedRange representing the forest.
defmulti start (f:NewParseForest) -> ParsedRange

;Construct a parse forest from an Earley setlist.
defn NewParseForest (grammar:Grammar, setlist:ESetList) -> NewParseForest :
  ;For all parsed tokens (that are not at the end of a rule),
  ;record their ending position.
  val token-ends = HashTable<ParsedToken, List<Int>>(List())

  ;For all completed productions, record the rule
  ;they were parsed with.
  val prod-rules = HashTable<ParsedProd,List<Int>>(List())

  ;Returns true if token at given index is the last production
  ;in the given rule.
  defn last-production? (rule:Int, index:Int) -> True|False :
    val tokens = tokens(grammar[rule])
    for i in (index + 1) to length(tokens) none? :
      tokens[i] is GProduction

  ;Compute the token-ends table.
  defn compute-prod-tables () :
    ;Iterate through setlist.
    for eset in sets(setlist) do :
      ;Scan through advanced list to build token-ends.
      for adv in advanced(setlist, eset) do :
        val item = item(adv)
        if not last-production?(rule(item), num-parsed(item)) :
          val token = upcoming(grammar,item) as GProduction
          val rule = rule(item)
          val rule-start = parent(item)
          val token-index = num-parsed(item)
          val token-start = index(adv)
          val token-end = index(eset)
          val parsed-token = ParsedToken(rule, rule-start, token-index, token-start)
          update(token-ends, cons{token-end, _}, parsed-token)
      ;Scan through items in list to build production rules.
      for item in items(setlist, eset) do :
        if upcoming(grammar,item) is False :
          val prod = production(grammar,item)
          val start = parent(item)
          val end = index(eset)
          val rule = rule(item)
          val parsed-prod = ParsedProd(prod, start, end)
          update(prod-rules, cons{rule, _}, parsed-prod)

  ;Compute all tables
  compute-prod-tables()
  println("Token Ends:")
  within indented() :
    do(println, token-ends)
  println("Prod Rules:")
  within indented() :
    do(println, prod-rules)

  ;Return constructed Parse Forest.
  new NewParseForest :
    defmethod start (this) :
      ParsedRange(0, 0, length(setlist) - 1)
    defmethod ends (this, range:ParsedRange, token-index:Int, token-start:Int) :
      val token = ParsedToken(rule(range), start(range), token-index, token-start)
      match(get?(token-ends, token)) :
        (es:List<Int>) :
          es
        (f:False) :
          if not last-production?(rule(range), token-index) :
            fatal("Token does not exist in forest.")
          val tokens = tokens(grammar[rule(range)])
          val num-tokens = length(tokens)
          val num-trailing-terminals = num-tokens - (token-index + 1)
          val token-end = end(range) - num-trailing-terminals
          val prod = tokens[token-index] as GProduction
          val parsed-prod = ParsedProd(id(prod), token-start, token-end)
          if key?(prod-rules, parsed-prod) : List(token-end)
          else : List()
    defmethod get (this, prod:Int, start:Int, end:Int) :
      for rule in prod-rules[ParsedProd(prod,start,end)] map :
        ParsedRange(rule, start, end)

;============================================================
;=============== Construct Parse Forest =====================
;============================================================
;Constructs a ParseForest datastructure from the given grammar,
;and setlist from a right-to-left search.
defn ParseForest (grammar:Grammar, setlist:ESetList) -> ParseForest :
  ;Convert the set index from the backwards parse to the
  ;position in the input stream.
  defn set-index-to-position (index:Int) -> Int :
    length(setlist) - 1 - index
  defn position-to-set-index (position:Int) -> Int :
    length(setlist) - 1 - position

  ;Compute partial rules:
  ;Each item PartialRule(rule, num-parsed, start, end) means:
  ;  The input from start (inclusive) to end (exclusive) can successfully
  ;  be parsed as the tokens at index 'num-parsed' and after in rule 'rule'.
  val partial-rules = HashSet<PartialRule>()
  defn init-partial-rules () :
    for eset in sets(setlist) do :
      for item in items(setlist,eset) do :
        val start = set-index-to-position(index(eset))
        val end = set-index-to-position(parent(item))
        add(partial-rules, PartialRule(rule(item), num-parsed(item), start, end))

  ;Compute production parses:
  ;Each entry ProdPos(prod, position) => (R1, R2, ...) means:
  ;  The production 'prod' starting from position 'position' can be
  ;  parsed in the ways given by R1, R2, ....
  ;To be consistent, the start position in each R1, R2 is equal to
  ;'position'.
  val prod-parses = HashTable<ProdPos, List<ParsedRange>>(List())
  defn add-production-range (set-index:Int, item:EItem) :
    fatal("Illegal item") when num-parsed(item) > 0
    val prodpos = ProdPos(production(grammar,item),
                          set-index-to-position(set-index))
    val range = ParsedRange(rule(item),
                            set-index-to-position(set-index),
                            set-index-to-position(parent(item)))
    update(prod-parses, cons{range, _}, prodpos)
  defn init-prod-parses () :
    for eset in sets(setlist) do :
      for item in items(setlist, eset) do :
        if num-parsed(item) == 0 :
          add-production-range(index(eset), item)

  ;Expand all completed items with completion roots for the given
  ;set. For any additional completed items, add them as production-ranges.
  val added-completed-parses = IntSet()
  defn create-completion-production-parses (set-index:Int) -> False :
    if add(added-completed-parses, set-index) :
      ;Gather set of existing completed items.
      val completion-set = HashSet<EItemCore>()
      for item in items(setlist, setlist[set-index]) do :
        if num-parsed(item) == 0 :
          add(completion-set, core(item))
      ;Expand all completed items with completion roots.
      ;Add their production ranges if they did not exist in the
      ;set before.
      for item in items(setlist, setlist[set-index]) do :
        if num-parsed(item) == 0 and completion-root(item) is-not False :
          within x = expand-completion-item(item) :
            if add(completion-set, core(x)) :
              add-production-range(set-index, x)
  ;Given the completed item with completion root,
  ;Return the entire chain of expanding the items not including the
  ;final root.
  defn expand-completion-item (return:EItem -> ?, item:EItem) :
    val root-core = core(item)
    let loop (x:EItem = completion-root(item) as EItem) :
      if core(x) != root-core :
        return(x)
        val x* = first-item(setlist, parent(x), production(grammar,x))
        loop(dec-num-parsed(x* as EItem, false))

  ;Given the ParsedRange 'range', return all of the subparses of production
  ;at index 'index' starting from 'start-position'.
  defn child-ranges (range:ParsedRange, index:Int, start-position:Int) -> Seqable<ParsedRange> :
    create-completion-production-parses(position-to-set-index(start-position))
    val token = tokens(grammar[rule(range)])[index]
    val production = id(token as GProduction)
    val candidates = prod-parses[ProdPos(production, start-position)]
;    println("Candidates:")
;    within indented() :
;      do(println, candidates)
    for r in candidates filter :
;      println("Filter using %_" % [PartialRule(rule(range), index + 1, end(r), end(range))])
      partial-rules[PartialRule(rule(range), index + 1, end(r), end(range))]


  defn time<?T> (f:() -> ?T, name:String) :
    val timer = MillisecondTimer(name)
    println("Starting %_" % [timer])
    start(timer)
    val result = f()
    stop(timer)
    println(timer)
    result

  ;Create ParseForest
  within time("init-partial-rules") :
    init-partial-rules()
  within time("init-prod-parses") :
    init-prod-parses()
;  println("Prod Table:")
;  within indented() :
;    do(println, prod-parses)
;  println("Partial Rules:")
;  within indented() :
;    do(println, partial-rules)
  new ParseForest :
    defmethod get (this, r:ParsedRange, index:Int, position:Int) :
      child-ranges(r, index, position)
    defmethod start (this) :
      ParsedRange(0, 0, length(setlist) - 1)

;============================================================
;================ Selecting the Parse Tree ==================
;============================================================

;------------------------------------------------------------
;--------------------- LazyParseNode ------------------------
;------------------------------------------------------------
;A LazyParseNode is a ParseNode whose children are lazily computed
;using a ParsedRange -> ParseNode function.
defn LazyParseNode (range:ParsedRange, compute-children:ParsedRange -> Tuple<ParseNode|Int>) :
  ;Cache the computed children
  var children:Maybe<Tuple<ParseNode|Int>> = None()
  defn children! () :
    if empty?(children) :
      children = One(compute-children(range))
    value!(children)

  ;Return the lazy parse node
  new ParseNode :
    defmethod range (this) : range
    defmethod children (this) : children!()

;------------------------------------------------------------
;-------------------- Select Tree ---------------------------
;------------------------------------------------------------
defn new-select-tree (grammar:Grammar, forest:NewParseForest) -> ParseNode :
  ;Compute the children nodes for the given parsed range.
  defn compute-children (range:ParsedRange) -> Tuple<ParseNode|Int> :
    val grule = grammar[rule(range)]
    defn compute (index:Int, position:Int) -> Maybe<List<ParseNode|Int>> :
      if index < length(tokens(grule)) :
        match(tokens(grule)[index]) :
          (t:GProduction) :
            val ends = ends(forest, range, index, position)
            val end-entry = for end in ends first :
              val rest = compute(index + 1, end)
              if empty?(rest) : None()
              else : One(end => value!(rest))
            if empty?(end-entry) :
              None()
            else :
              val end = key(value!(end-entry))
              val rest = value(value!(end-entry))
              val ranges = forest[id(t), position, end]
              val nodes = seq(select, ranges)
              val node = most-specific(nodes)
              One(cons(node, rest))
          (t:GTerminal) :
            val result = compute(index + 1, position + 1)
            if empty?(result) : None()
            else : One(cons(position, value!(result)))
      else :
        fatal("Inconsistent end.") when position != end(range)
        One(List())
    to-tuple(value!(compute(0, start(range))))

  ;Compute the appropriate parse node for the give range.
  defn select (range:ParsedRange) -> ParseNode :
    val grule = grammar[rule(range)]
    if params(grule) is InheritParams :
      compute-children(range)[0] as ParseNode
    else :
      LazyParseNode(range, compute-children)

  ;Select the most specific parse node
  defn most-specific (nodes:Seqable<ParseNode>) -> ParseNode :
    defn more-specific? (a:ParseNode, b:ParseNode) -> True|False :
      compare-specificity(grammar, a, b) < 0
    minimum(nodes, more-specific?)

  ;Launch!
  select(start(forest))

;------------------------------------------------------------
;-------------------- Select Tree ---------------------------
;------------------------------------------------------------
defn select-tree (grammar:Grammar, forest:ParseForest) -> ParseNode :
  ;Returns true if a is more specific than b.
  defn more-specific? (a:ParseNode, b:ParseNode) -> True|False :
    compare-specificity(grammar, a, b) < 0

  ;Returns the ParseNode corresponding to the given ParsedRange.
  defn compute-children (range:ParsedRange) -> Tuple<ParseNode|Int> :
    ;Select parse nodes for children
    val children = Vector<ParseNode|Int>()
    val grule = grammar[rule(range)]
    val num-tokens = length(tokens(grule))
    let loop (index:Int = 0, position:Int = start(range)) :
      if index < num-tokens :
        match(tokens(grule)[index]) :
          (t:GTerminal) :
            add(children, position)
            loop(index + 1, position + 1)
          (t:GProduction) :
            val child-nodes = seq(select, forest[range, index, position])
            val child = minimum(child-nodes, more-specific?)
            add(children, child)
            loop(index + 1, end(/range(child)))

    ;Return children
    to-tuple(children)

  ;Create a ParseNode from the given range.
  defn select (range:ParsedRange) -> ParseNode :
    val grule = grammar[rule(range)]
    if params(grule) is InheritParams :
      compute-children(range)[0] as ParseNode
    else :
      LazyParseNode(range, compute-children)

  ;Launch!
  val timer = MillisecondTimer("Select Tree")
  println("Start %_" % [timer])
  start(timer)
  val node = select(start(forest))
  force(node)
  stop(timer)
  println(timer)
  node

defn force (n:ParseNode) -> False :
  for c in children(n) do :
    match(c:ParseNode) :
      force(c)

;------------------------------------------------------------
;---------- Compare which ParseNode is more specific --------
;------------------------------------------------------------

;Return -1 if a should take priority over b during a left-to-right disambiguation sweep of the parse forest.
defn compare-specificity (grammar:Grammar, a:ParseNode, b:ParseNode) -> Int :
  ;Retrieve properties of parse nodes a and b.
  val range-a = range(a)
  val range-b = range(b)
  val rule-a = grammar[rule(range-a)]
  val rule-b = grammar[rule(range-b)]
  val params-a = params(rule-a) as TokenRuleParams
  val params-b = params(rule-b) as TokenRuleParams

  ;Compute the lengths of the first and last child
  ;in the given nodes.
  defn child-length (cs:Tuple<ParseNode|Int>, i:Int) -> Int :
    if empty?(cs) :
      0
    else :
      match(cs[i]) :
        (c:Int) : 1
        (c:ParseNode) : length(range(c))
  defn first-child-length (n:ParseNode) -> Int :
    val cs = children(n)
    child-length(cs, 0)
  defn last-child-length (n:ParseNode) -> Int :
    val cs = children(n)
    val l = length(cs)
    child-length(cs, l - 1)

  ;Comparison functions ordered by importance.
  defn compare-length () :
    compare(length(range-b), length(range-a))
  defn compare-priority () :
    compare(priority(params-b), priority(params-a))
  defn compare-associativity () :
    compare(associativity(params-a), associativity(params-b))
  defn compare-associativity-length () :
    match(associativity(params-a), associativity(params-b)) :
      (aa:NonAssociative, ab:NonAssociative) :
        0
      (aa:LeftAssociative, ab:LeftAssociative) :
        compare(first-child-length(b), first-child-length(a))
      (aa:RightAssociative, ab:RightAssociative) :
        compare(last-child-length(b), last-child-length(a))
  defn compare-order () :
    compare(order(rule-a) as Int, order(rule-b) as Int)

  ;Call comparison functions in order.
  val c0 = compare-length()
  if c0 == 0 :
    val c1 = compare-priority()
    if c1 == 0 :
      val c2 = compare-associativity()
      if c2 == 0 :
        val c3 = compare-associativity-length()
        if c3 == 0 :
          compare-order()
        else : c3
      else : c2
    else : c1
  else : c0
