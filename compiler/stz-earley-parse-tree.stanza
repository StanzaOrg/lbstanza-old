defpackage stz/earley-parse-tree :
  import core
  import collections
  import stz/utils
  import stz/earley-eitems
  import stz/earley-grammar
  import stz/earley-sexp-stream
  import stz/earley-search

;============================================================
;===================== Main Algorithm =======================
;============================================================

public defn parse (grammar:Grammar, tables:ParseTables, inputlist:Vector<SExpToken>) -> ParseNode :
  val forest = ParseForest(grammar, tables, inputlist)
  select-tree(forest)

;============================================================
;==================== Output Datastructures =================
;============================================================

public defstruct ParseNode :
  prod: ParsedProd
  range: ParsedRange
  children: Tuple<ParseNode|Int>

public defstruct ParsedRange :
  rule: GTokenRule
  start: Int
  end: Int
with:
  printer => true

public defn rule-id (r:ParsedRange) :
  id(rule(r))

public defn length (n:ParseNode) :
  end(prod(n)) - start(prod(n))

;Represents a parsed production between a given
;start and end position.
defstruct ParsedProd <: HasParts :
  prod: Int
  start: Int
  end: Int
with:
  printer => true

defmethod parts (t:ParsedProd) :
  [`ParsedProd, prod(t), start(t), end(t)]

defstruct ParsedRule <: HasParts :
  rule: Int
  start: Int
  end: Int
with:
  printer => true

defmethod parts (t:ParsedRule) :
  [`ParsedRule, rule(t), start(t), end(t)]

;============================================================
;===================== Utilities ============================
;============================================================

;Represents a parsed production that ends at the given position.
defstruct ProdEnd <: Hashable & Equalable :
  prod: Int
  end: Int
with:
  printer => true

defmethod hash (p:ProdEnd) :
  111 * prod(p) + 131 * end(p)
defmethod equal? (a:ProdEnd, b:ProdEnd) :
  prod(a) == prod(b) and end(a) == end(b)

;Represents a parsed production that starts at the given position.
defstruct ProdStart <: Hashable & Equalable :
  prod: Int
  start: Int
with:
  printer => true

defmethod hash (p:ProdStart) :
  111 * prod(p) + 131 * start(p)
defmethod equal? (a:ProdStart, b:ProdStart) :
  prod(a) == prod(b) and start(a) == start(b)

defstruct RuleStart <: Hashable & Equalable :
  rule: Int
  start: Int
with:
  printer => true

defmethod hash (p:RuleStart) :
  111 * rule(p) + 131 * start(p)
defmethod equal? (a:RuleStart, b:RuleStart) :
  rule(a) == rule(b) and start(a) == start(b)

;Represents a matched terminal at a given position.
defstruct ParsedTerminal <: Hashable & Equalable :
  terminal: GTerminal
  position: Int
with:
  printer => true

defmethod hash (p:ParsedTerminal) :
  111 * hash(terminal(p)) + 131 * position(p)
defmethod equal? (a:ParsedTerminal, b:ParsedTerminal) :
  terminal(a) == terminal(b) and position(a) == position(b)

;============================================================
;================== Simple Hash =============================
;============================================================

deftype HasParts <: Hashable & Equalable
defmulti parts (p:HasParts) -> Tuple
defmethod hash (p:HasParts) : hash(parts(p))
defmethod equal? (a:HasParts, b:HasParts) : parts(a) == parts(b)

;============================================================
;====================== Debugging ===========================
;============================================================

public defn format (grammar:Grammar, r:ParsedRange) :
  "(rule %_) [%_ to %_] %_" % [rule-id(r), start(r), end(r), format(grammar, rule(r))]

public defn format (grammar:Grammar, node:ParseNode) :
  within o = Printable() :
    print(o, format(grammar, range(node)))
    val o2 = IndentedStream(o)
    do(lnprint{o2, format(grammar,_)}, filter-by<ParseNode>(children(node)))

defn Printable (f:OutputStream -> ?) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      f(o)

;============================================================
;===================== Parse Tables =========================
;============================================================

public deftype ParseTables <: SearchProgress
defmulti rule-ends (t:ParseTables) -> HashTable<RuleStart,Array<List<Int>>>
defmulti prod-ends (t:ParseTables) -> HashTable<ProdStart,List<Int>>
defmulti prod-starts (t:ParseTables) -> HashTable<ProdEnd,List<Int>>
defmulti terminal-set (t:ParseTables) -> HashSet<ParsedTerminal>
defmulti prod-rules (t:ParseTables) -> HashTable<ParsedProd,List<GTokenRule>>
defmulti right-recursive-items (t:ParseTables) -> ESetList
defmulti right-recursive-prod-sets (t:ParseTables) -> HashSet<[Int,Int]>
defmulti factor-starts (t:ParseTables) -> HashTable<RuleStart,List<Int>>
defmulti chain-completions (t:ParseTables) -> HashTable<ParsedRule,ChainCompletion>

public defn ParseTables (grammar:Grammar) :  
  ;For all parsed productions record their ending position.
  ;Does not include right-recursive completions.
  val prod-ends = HashTable<ProdStart, List<Int>>(List())

  ;[TODO]
  val rule-ends = HashTable<RuleStart, Array<List<Int>>>()

  val chain-completions = HashTable<ParsedRule, ChainCompletion>()

  ;For all parsed productions record their starting position.
  ;Computed lazily by compute-prod-rules.
  val prod-starts = HashTable<ProdEnd, List<Int>>(List())

  ;Holds the set of all of the matched terminals that
  ;should be saved.
  val terminal-set = HashSet<ParsedTerminal>()

  ;For all completed productions, record the rule
  ;they were parsed with. Computed lazily by compute-prod-rules. 
  val prod-rules = HashTable<ParsedProd,List<GTokenRule>>(List())

  ;Hold right-recursive item
  val right-recursive-items = ESetList()

  ;Holds the set of productions that lead to the given root
  ;through right-recursive completions.
  val right-recursive-prod-sets = HashSet<[Int,Int]>()

  ;Holds the set of candidate starts for factored productions
  val factor-starts = HashTable<RuleStart,List<Int>>(List())

  val table-timer = MillisecondTimer("Make table")

  ;Add the given completed ESet to the parse tables.
  defn add-to-parse-tables (set-index:Int, eset:ESet) -> False :
    start(table-timer)
    ;Scan through items in list to build production rules.
    for item in eset do :
      if num-parsed(item) == 0 :
        val start = parent(item)
        rule-ends[RuleStart(rule-id(item), start)] = ends(item)
        println("Added ends %_ = %_" % [RuleStart(rule-id(item), start), ends(item)])
        
      ;Add completed productions to production tables.
      if upcoming(item) is False :
        val prod = production(item)
        val start = parent(item)
        val end = set-index
        update(prod-ends, cons?{end, _}, ProdStart(prod,start))
        update(prod-starts, cons{start, _}, ProdEnd(prod,end))
        update(prod-rules, cons{rule(item), _}, ParsedProd(prod,start,end))

      if completion-root(item) is ChainCompletion :
        val c = completion-root(item) as ChainCompletion
        val rule = ParsedRule(rule-id(item), parent(item), set-index)
        chain-completions[rule] = c

      ;Add to right-recursive-prod-sets
      if upcoming(item) is-not False and
         completion-root(item) is-not NoCompletion :
        val root = match(completion-root(item)) :
                     (r:ChainRoot) : item
                     (r:ChainLink) : root(r)
        val prod = production(item)
        add(right-recursive-prod-sets, [rule-id(root), prod])

      ;Add to factored starts
      val num-tokens = length(tokens(rule(item)))
      if num-parsed(item) == num-tokens - 1 and
         params(rule(item)) is FactoredParams :
        val rule = rule-id(item)
        val start = parent(item)
        val factor-start = set-index
        update(factor-starts, cons{factor-start, _}, RuleStart(rule, start))        
        
      ;Add scanned terminals to terminal-set,
      ;if they should be saved.
      val prev-term = previous(item)
      match(prev-term:GTerminal) :
        if save-terminal-match?(prev-term) :
          val token-position = set-index - 1
          val parsed-terminal = ParsedTerminal(prev-term, token-position)
          add(terminal-set, parsed-terminal)

    ;Add right-recursive items
    defn right-recursive? (item:EItem) : completion-root(item) is-not NoCompletion
    add(right-recursive-items, filter(right-recursive?, eset))

    stop(table-timer)

  ;Sort the production starts table
  defn sort-starts-table () :
    val buffer = Vector<Int>()
    for entry in prod-starts map! :      
      sort-and-dedup(value(entry), buffer)
    for entry in factor-starts map! :
      reverse(value(entry))

  ;Return ParseTables
  new ParseTables :
    defmethod completed-set (this, set-index:Int, eset:ESet) :
      ;println("Completed Set %_" % [set-index])
      ;within indented() :
      ;  for item in eset do :
      ;    println(format(grammar,item))
      add-to-parse-tables(set-index, eset)
    defmethod completed-all-sets (this) :
      sort-starts-table()
      do(println, rule-ends)
      println(table-timer)
    defmethod rule-ends (this) : rule-ends
    defmethod prod-ends (this) : prod-ends
    defmethod prod-starts (this) : prod-starts
    defmethod terminal-set (this) : terminal-set
    defmethod prod-rules (this) : prod-rules
    defmethod right-recursive-items (this) : right-recursive-items
    defmethod right-recursive-prod-sets (this) : right-recursive-prod-sets
    defmethod factor-starts (this) : factor-starts
    defmethod chain-completions (this) : chain-completions
    defmethod print (o:OutputStream, this) :
      val o2 = IndentedStream(o)
      print(o, "Prod Ends:")
      do(lnprint{o2, _}, prod-ends)
      lnprint(o, "Prod Starts:")
      do(lnprint{o2, _}, prod-starts)
      lnprint(o, "Prod Rules:")
      do(lnprint{o2, _}, prod-rules)
      lnprint(o, "Right Recursive Production Sets:")
      do(lnprint{o2, _}, right-recursive-prod-sets)
      lnprint(o, "Factor Starts:")
      do(lnprint{o2, _}, factor-starts)

;Returns true if the given terminal is of a type where we should
;not recalculate whether it matches a given input. If it returns
;false, then it is safe to recalculate. 
defn save-terminal-match? (t:GTerminal) -> True|False :
  t is GMatcherToken|GAny|GListStart|GListRest

;Helper: Call cons(a,bs) if a does not already
;appear at the head of bs.
defn cons? (a:Int, bs:List<Int>) -> List<Int> :
  if empty?(bs) : List(a)
  else if head(bs) == a : bs
  else : cons(a, bs)

;Sort and deduplicate the given list 'xs' using the buffer
;'buffer'.
defn sort-and-dedup (xs:List<Int>, buffer:Vector<Int>) -> List<Int> :
  add-all(buffer, xs)
  qsort!(buffer)
  remove-duplicates!(buffer)
  val result = to-list(buffer)
  clear(buffer)
  result  

;============================================================
;=================== New Parse Forest =======================
;============================================================

;Representation of a Parse Forest.
public deftype ParseForest

;Answers the query:
;Given:
;- The parent parsed range (a range of input parsed using some rule),
;- The index of the token (assumed to be a production) in the rule,
;_ The starting position of this token,
;Return:
;- All potential ends for the parsed range corresponding to that token, sorted
;  in decreasing order.
defmulti ends (f:ParseForest, range:ParsedRange, token-index:Int, token-start:Int) -> Seqable<Int>

;Answers the query:
;Given:
;- The parent parsed range (a range of input parsed using some rule),
;- The index of the token (assumed to be a production) in the rule,
;_ The ending position of this token,
;Return:
;- All potential starts for the parsed range corresponding to that token, sorted
;  in increasing order.
defmulti starts (f:ParseForest, range:ParsedRange, token-index:Int, token-end:Int) -> Seqable<Int>

;Answers the query:
;Given:
;- The parsed range of a factored production
;Return:
;- All potential starts for the last token (the factored production).
defmulti factored-starts (this, range:ParsedRange) -> List<Int>

;Returns true if the given terminal matches the input at the given
;position.
defmulti match? (f:ParseForest, term:GTerminal, position:Int) -> True|False

;Given:
;- A production,
;- A start and end position,
;Return:
;- All possible parses for production in that range of input.
defmulti get (f:ParseForest, prod:ParsedProd) -> List<ParsedRange>

;Retrieve the root ParsedRange representing the forest.
defmulti start (f:ParseForest) -> ParsedRange

;Construct a parse forest from an Earley setlist.
defn ParseForest (grammar:Grammar, tables:ParseTables, inputlist:Vector<SExpToken>) -> ParseForest :
  ;Ensure that the list of starts for given production end is sorted.
  val sort-buffer = Vector<Int>()
  defn ensure-starts-sorted (end:ProdEnd) :
    val starts = prod-starts(tables)
    update(starts, sort-and-dedup{_, sort-buffer}, end)

  ;If not already computed, process each item
  ;in the given set, and add its entries to the
  ;prod-rules table.
  val added-right-recursive-completions = HashSet<EItemCore>()
  val added-right-recursive-set = HashSet<[Int,Int]>()
  val updated-prods = IntSet()
;  defn add-right-recursive-completions (set-index:Int, r-prod:Int) :
;    start(stz/earley-eitems/FACTORED-TIMER)
;    if add(added-right-recursive-set, [set-index, r-prod]) :
;      clear(updated-prods)
;      val rr-items = right-recursive-items(tables)
;      val rr-prod-set = right-recursive-prod-sets(tables)
;      val eset = rr-items[set-index]
;      for item in items(rr-items, eset) do :      
;        if upcoming(item) is False and rr-prod-set[[rule-id(item), r-prod]] :
;          if add(added-right-recursive-completions, core(item)) :
;            within item = expand-completion-item(item) :
;              add-prod-rule(item, index(eset), updated-prods)
;      for prod in updated-prods do :
;        ensure-starts-sorted(ProdEnd(prod, index(eset)))
;    stop(stz/earley-eitems/FACTORED-TIMER)

  defn expand-right-recursive-children (rule:ParsedRule) :
    val completions = chain-completions(tables)
    match(get?(completions, rule)) :
      (c:ChainCompletion) :
        println("EXPANDING RIGHT RECURSIVE ITEMS: %_" % [rule])
        within item = expand-completion-item(c) :
          val prod = production(item)
          val start = parent(item)
          val end = end(rule)
          val parsed-prod = ParsedProd(prod, start, end)
          update(prod-rules(tables), cons{/rule(item), _}, parsed-prod)
          println("Production %_ parses with %_" % [parsed-prod, rule-id(item)])
        remove(completions, rule)
      (f:False) :
        false    

  ;Add the given completion (in set 'end') to the
  ;prod-rules table.
  defn add-prod-rule (item:EItem, end:Int, updated-prods:IntSet) :
    val prod = production(item)
    val start = parent(item)
    val parsed-prod = ParsedProd(prod, start, end)
    update(prod-rules(tables), cons{rule(item), _}, parsed-prod)
    val prod-end = ProdEnd(prod, end)
    update(prod-starts(tables), cons{start, _}, prod-end)
    add(updated-prods, prod)

  ;Retrieve the rules that can successfully parse
  ;the given production between tokens start and end.
  defn get-prod-rules (prod:ParsedProd) -> List<GTokenRule> :
;    add-right-recursive-completions(end(prod), /prod(prod))
    prod-rules(tables)[prod]

  ;Retrieve the rules that can successfully parse
  ;the given production between tokens start and end.
  defn get-prod-starts (prod:ProdEnd) -> List<Int> :
;    add-right-recursive-completions(end(prod), /prod(prod))
    prod-starts(tables)[prod]

  ;Given the completed item with completion root,
  ;Return the entire chain of expanding the items not including the
  ;final root.
  defn expand-completion-item (return:EItem -> ?, c:ChainCompletion) :
    val visited = HashSet<EItemCore>()
    defn fill-chain (item:EItem) :
      match(completion-root(item)) :
        (r:ChainLink) :
          if add(visited,core(item)) :
            return(inc-num-parsed(item, false))
            fill-chain(link(r))
        (r:ChainRoot) :
          false
    do(fill-chain, items(c))      

  ;Returns true if token at given index is the last production
  ;in the given rule.
  defn last-production? (rule:GTokenRule, index:Int) -> True|False :
    val tokens = tokens(rule)
    for i in (index + 1) to length(tokens) none? :
      tokens[i] is GProduction

  ;Returns true if token at given index is the first production
  ;in the given rule.
  defn first-production? (rule:GTokenRule, index:Int) -> True|False :
    val tokens = tokens(rule)
    for i in 0 to index none? :
      tokens[i] is GProduction

  ;Return constructed Parse Forest.
  new ParseForest :
    defmethod start (this) :
      ;The last input is the EndOfInput token, and is where
      ;the starting rule ends.
      val start-rule = next(to-seq(rules(grammar,0)))
      ParsedRange(grammar[start-rule], 0, length(inputlist))
      
    defmethod ends (this, range:ParsedRange, token-index:Int, token-start:Int) :
      expand-right-recursive-children(ParsedRule(rule-id(range), start(range), end(range)))

      ;Get the production at token-index.
      val tokens = tokens(rule(range))
      val prod = tokens[token-index] as GProduction
      
      ;Returns true if the current token can be parsed between
      ;token-start and the given end. 
      defn feasible-end? (candidate-end:Int) -> True|False :
        if candidate-end <= end(range) :
          val prod = ParsedProd(id(prod), token-start, candidate-end)
          not empty?(get-prod-rules(prod))

      ;Retrieve candidate ends.
      val candidate-ends =
        if last-production?(rule(range), token-index) :
          val num-tokens = length(tokens)
          val num-trailing-terminals = num-tokens - (token-index + 1)
          List(end(range) - num-trailing-terminals)
        else :
          val rs = RuleStart(rule-id(range), start(range))
          val result1 = match(get?(rule-ends(tables), rs)) :
            (ends:Array<List<Int>>) : ends[token-index]
            (f:False) : List()


          val prod = ProdStart(id(prod), token-start)
          val result2 = prod-ends(tables)[prod]

          println("Candidate ends for %_ token %_" % [format(grammar,range), token-index])
          println(result1)
          println(result2)
          
          result1

      ;Filter out the unfeasible ends
      filter(feasible-end?, candidate-ends)

    defmethod starts (this, range:ParsedRange, token-index:Int, token-end:Int) :
      expand-right-recursive-children(ParsedRule(rule-id(range), start(range), end(range)))
      
      ;Get the production at token-index.
      val tokens = tokens(rule(range))
      val prod = tokens[token-index] as GProduction

      ;Returns true if the current token can be parsed between
      ;the given start and token-end.
      defn feasible-start? (candidate-start:Int) -> True|False :
        if candidate-start <= token-end :
          val prod = ParsedProd(id(prod), candidate-start, token-end)
          not empty?(get-prod-rules(prod))
      
      ;Retrieve candidate starts.
      val candidate-starts =
        if first-production?(rule(range), token-index) :
          val num-leading-terminals = token-index
          List(start(range) + num-leading-terminals)
        else :
          val rs = RuleStart(rule-id(range), start(range))
          val result1 = match(get?(rule-ends(tables), rs)) :
            (ends:Array<List<Int>>) : reverse(ends[token-index - 1])
            (f:False) : List()

          val prod = ProdEnd(id(prod), token-end)
          val result2 = get-prod-starts(prod)

          println("Candidate starts for %_ token %_" % [format(grammar,range), token-index])
          println(result1)
          println(result2)

          result1
          
      ;Filter out the unfeasible starts
      filter(feasible-start?, candidate-starts)

    defmethod factored-starts (this, range:ParsedRange) :
      ;Precondition
      if params(rule(range)) is-not FactoredParams :
        fatal("Rule is not a factored production.")
      ;Typically either the left starts or right starts is short.
      ;If neither is short, then use their intersection.
      ;Get the starts as calculated from left
      val rule-start = RuleStart(rule-id(range), start(range))
      val left-starts = factor-starts(tables)[rule-start]
      if list-shorter-than(left-starts, 2) :
        left-starts
      else :
        ;Get the starts as calculated from right
        val last-index = length(tokens(rule(range))) - 1
        val right-starts = to-list(starts(this, range, last-index, end(range)))
        list-intersection(left-starts, right-starts)
      
    defmethod match? (this, term:GTerminal, position:Int) :
      if save-terminal-match?(term) :
        terminal-set(tables)[ParsedTerminal(term, position)]
      else :
        matches-input?(grammar, term, inputlist[position])
      
    defmethod get (this, prod:ParsedProd) :
      for rule in get-prod-rules(prod) map :
        ParsedRange(rule, start(prod), end(prod))

;------------------------------------------------------------
;----------------- Utility: List Length ---------------------
;------------------------------------------------------------

defn* list-shorter-than (xs:List, n:Int) -> True|False :
  if empty?(xs) : true
  else if n > 0 : list-shorter-than(tail(xs), n - 1)

;------------------------------------------------------------
;------- Utility: Intersection of Two Sorted Lists ----------
;------------------------------------------------------------

defn* list-intersection (xs:List<Int>, ys:List<Int>) -> List<Int> :
  if empty?(xs) or empty?(ys) :
    List()
  else :
    switch(compare(head(xs), head(ys))) :
      -1 : list-intersection(tail(xs), ys)
      0 : cons(head(xs), list-intersection(tail(xs), tail(ys)))
      1 : list-intersection(xs, tail(ys))

;============================================================
;================ Selecting the Parse Tree ==================
;============================================================

;------------------------------------------------------------
;------------------- Cache Utility --------------------------
;------------------------------------------------------------

deftype Cache<T>
defmulti value<?T> (cache:Cache<?T>) -> T
defn Cache<?T> (f:() -> ?T) :
  var value:Maybe<T> = None()
  new Cache<T> :
    defmethod value (this) :
      if empty?(value) :
        value = One(f())
      value!(value)

;------------------------------------------------------------
;--------------------- LazyParseNode ------------------------
;------------------------------------------------------------
defn LazyParseNode (prod:ParsedProd, compute:ParsedProd -> ParseNode) :
  val cache = Cache(compute{prod})
  new ParseNode :
    defmethod prod (this) : prod
    defmethod range (this) : range(value(cache))
    defmethod children (this) : children(value(cache))

defn LazyParseNode (prod:Int, range:ParsedRange, compute:ParsedRange -> ParseNode) :
  val cache = Cache(compute{range})
  new ParseNode :
    defmethod prod (this) : ParsedProd(prod, start(range), end(range))
    defmethod range (this) : range
    defmethod children (this) : children(value(cache))

defn LazyParseNode (prod:Int, sel:RuleSelection, compute:RuleSelection -> ParseNode) :
  val cache = Cache(compute{sel})
  new ParseNode :
    defmethod prod (this) : ParsedProd(prod, start(range(sel)), end(range(sel)))
    defmethod range (this) : range(value(cache))
    defmethod children (this) : children(value(cache))

;------------------------------------------------------------
;-------------------- Select Tree ---------------------------
;------------------------------------------------------------
defn select-tree (forest:ParseForest) -> ParseNode :
  ;Return all rules that can be used to parse the given production.
  defn select-rules (prod:ParsedProd) -> Tuple<RuleSelection> :
    defn select (range:ParsedRange) -> List<RuleSelection> :
      match(params(rule(range))) :
        (p:FactoredParams) :
          val child-index = length(tokens(rule(range))) - 1
          val child-starts = starts(forest, range, child-index, end(range))
          to-list $ for start in child-starts seq-cat :
            val prod = id(last-token(rule(range)) as GProduction)
            for sel in select(ParsedProd(prod, start, end(range))) seq :
              FactoredRule(range, sel)
        (p:TokenRuleParams) :
          List(LeafRule(range))
    defn select (prod:ParsedProd) -> List<RuleSelection> :
      seq-append(select, forest[prod])
    to-tuple(select(prod))

  ;Compute node from ParsedProd
  defn compute-node-from-prod (prod:ParsedProd) -> ParseNode :
    most-specific(seq(select, select-rules(prod)))

  ;Compute node from ParsedRange.
  defn compute-node-from-sel (sel:RuleSelection) -> ParseNode :
    ;Compute the total number of tokens for the rule selection.
    val num-tokens = num-tokens(sel)
    
    ;Compute the parsed nodes for all tokens at and after the token
    ;at the given index starting from the given input position.
    ;If there is no valid parse starting from that position, then None()
    ;is returned.
    defn compute-left-to-right (index:Int, position:Int) -> Maybe<List<ParseNode|Int>> :
      if index < num-tokens :
        val ri = sel[index]
        match(token(ri)) :
          (t:GProduction) :            
            val ends = ends(forest, range(ri), /index(ri), position)
            val end-entry = for end in ends first :
              val rest = compute-left-to-right(index + 1, end)
              if empty?(rest) : None()
              else : One(end => value!(rest))
            if empty?(end-entry) :
              None()
            else :
              val end = key(value!(end-entry))
              val rest = value(value!(end-entry))
              val node = select(ParsedProd(id(t), position, end))
              One(cons(node, rest))
          (t:GTerminal) :
            if match?(forest, t, position) :
              val result = compute-left-to-right(index + 1, position + 1)
              if empty?(result) : None()
              else : One(cons(position, value!(result)))
            else :
              None()
      else :
        fatal("Inconsistent end.") when position != end(range(sel))
        One(List())

    ;Compute the parsed nodes for all tokens at and before the token
    ;at the given index ending at the given input position.
    ;If there is no valid parse ending at that position, then None()
    ;is returned. Nodes are returned in right-to-left order.
    defn compute-right-to-left (index:Int, position:Int) -> Maybe<List<ParseNode|Int>> :
      if index >= 0 :
        val ri = sel[index]
        match(token(ri)) :
          (t:GProduction) :
            val starts = starts(forest, range(sel), /index(ri), position)
            val start-entry = for start in starts first :
              val rest = compute-right-to-left(index - 1, start)
              if empty?(rest) : None()
              else : One(start => value!(rest))
            if empty?(start-entry) :
              None()
            else :
              val start = key(value!(start-entry))
              val rest = value(value!(start-entry))
              val node = select(ParsedProd(id(t), start, position))
              One(cons(node, rest))
          (t:GTerminal) :
            if match?(forest, t, position - 1) :
              val result = compute-right-to-left(index - 1, position - 1)
              if empty?(result) : None()
              else : One(cons(position - 1, value!(result)))
            else :
              None()
      else :
        fatal("Inconsistent start.") when position != start(range(sel))
        One(List())

    ;Compute children
    defn compute-children () -> Tuple<ParseNode|Int> :
      defn left-to-right () :
        val cs = compute-left-to-right(0, start(range(sel)))
        to-tuple(value!(cs))
      defn right-to-left () :
        val cs = compute-right-to-left(num-tokens - 1, end(range(sel)))
        to-tuple(reverse(value!(cs)))
      val params = params(sel)
      match(operator-type(params), associativity(params)) :
        (opt:OperatorType, a) : right-to-left()
        (opt, a:LeftAssociative|NonAssociative) : left-to-right()
        (opt, a:RightAssociative) : right-to-left()
        
    ;Launch!
    ParseNode(prod, range, children) where :
      val grule = merged-rule(sel)
      val range = ParsedRange(grule, start(range(sel)), end(range(sel)))
      val prod = ParsedProd(prod(grule), start(range), end(range))
      val children = compute-children()

  ;Compute the appropriate parse node for the give range.
  defn select (sel:RuleSelection) -> ParseNode :
    val grule = rule(range(sel))
    LazyParseNode(prod(grule), sel, compute-node-from-sel)

  ;Compute the appropriate parse node for the given production.
  defn select (prod:ParsedProd) -> ParseNode :
    LazyParseNode(prod, compute-node-from-prod)

  ;Launch!
  val start-prod = ParsedProd(0, start(r), end(r)) where :
    val r = start(forest)
  val result = select(start-prod)
  let force (n:ParseNode = result) :
    do(force, filter-by<ParseNode>(children(n)))
  result

;------------------------------------------------------------
;--------------------- Last Token ---------------------------
;------------------------------------------------------------
defn last-token (rule:GTokenRule) -> GToken :
  val n = length(tokens(rule))
  tokens(rule)[n - 1]

;------------------------------------------------------------
;---------- Rule Selection for Factored Productions ---------
;------------------------------------------------------------
deftype RuleSelection
defmulti range (s:RuleSelection) -> ParsedRange
defstruct LeafRule <: RuleSelection :
  range: ParsedRange with: (as-method => true)
defstruct FactoredRule <: RuleSelection :
  range: ParsedRange with: (as-method => true)
  child: RuleSelection  

defstruct RuleIndex :
  range: ParsedRange
  index: Int

defn token (ri:RuleIndex) -> GToken :
  tokens(rule(range(ri)))[index(ri)]

defn num-tokens (r:RuleSelection) -> Int :
  val n = length(tokens(rule(range(r))))
  match(r) :
    (r:FactoredRule) : n - 1 + num-tokens(child(r))
    (r:LeafRule) : n

defn params (r:RuleSelection) -> TokenRuleParams :
  match(r) :
    (r:LeafRule) : params(rule(range(r))) as TokenRuleParams
    (r:FactoredRule) : params(child(r))

defn get (r:RuleSelection, i:Int) -> RuleIndex :
  match(r) :
    (r:LeafRule) :
      RuleIndex(range(r), i)
    (r:FactoredRule) :
      val n = length(tokens(rule(range(r)))) - 1
      if i < n : RuleIndex(range(r), i)
      else : child(r)[i - n]

;Merge the rule selection back into original
;unfactored rule.
defn merged-rule (sel:RuleSelection) -> GTokenRule :
  val tokenlist = Vector<GToken>()
  val leaf-rule = let loop (sel:RuleSelection = sel) :
    match(sel:FactoredRule) :
      val ts = tokens(rule(range(sel)))
      for i in 0 to length(ts) - 1 do :
        add(tokenlist, ts[i])
      loop(child(sel))
    else :
      add-all(tokenlist, tokens(rule(range(sel))))
      rule(range(sel))
  GTokenRule(id(leaf-rule),
             prod(rule(range(sel))),
             to-tuple(tokenlist),
             params(leaf-rule),
             order(leaf-rule))

defmethod print (o:OutputStream, r:LeafRule) :
  print(o, "LeafRule(%_)" % [range(r)])
defmethod print (o:OutputStream, r:FactoredRule) :
  val items = [
    "range = %_" % [range(r)]
    "child = %_" % [child(r)]]
  print(o, "FactoredRule(%_)" % [indented-list(items)])

defn indented-list (xs:Seqable) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, xs)

;------------------------------------------------------------
;---------- Utility: Retrieve Minima of Items ---------------
;------------------------------------------------------------
defn minima<?T> (input-xs:Seqable<?T>, compares:Tuple<((T,T) -> Int)>) -> Tuple<T> :
  ;Move minima from xs to ys.
  ;Assumes that xs has length > 1.
  defn move-minima (xs:Vector<T>, ys:Vector<T>, compare:(T,T) -> Int) :
    add(ys, xs[0])
    for i in 1 to length(xs) do :
      switch(compare(xs[i], ys[0])) :
        1 :
          false
        0 :
          add(ys, xs[i])
        -1 :
          clear(ys)
          add(ys, xs[i])

  ;Create state
  val xs = to-vector<T>(input-xs)
  val ys = Vector<T>()
  fatal("Cannot take minima of empty sequence.") when empty?(xs)

  ;Iterate through comparison functions.
  let loop (xs:Vector<T> = xs, ys:Vector<T> = ys, ci:Int = 0) :
    if ci < length(compares) :
      if length(xs) > 1 :
        move-minima(xs, ys, compares[ci])
        clear(xs)
        loop(ys, xs, ci + 1)
      else : to-tuple(xs)
    else : to-tuple(xs)

;------------------------------------------------------------
;---------- Choose the Most Specific ParseNode --------------
;------------------------------------------------------------

defn most-specific (nodes:Seqable<ParseNode>) -> ParseNode :
  ;Compute the lengths of the first and last child
  ;in the given nodes.
  defn child-length (cs:Tuple<ParseNode|Int>, i:Int) -> Int :
    if empty?(cs) :
      0
    else :
      match(cs[i]) :
        (c:Int) : 1
        (c:ParseNode) : length(c)
  defn first-child-length (n:ParseNode) -> Int :
    val cs = children(n)
    child-length(cs, 0)
  defn last-child-length (n:ParseNode) -> Int :
    val cs = children(n)
    val l = length(cs)
    child-length(cs, l - 1)

  ;Retrieve properties of a node
  defn rule (n:ParseNode) : /rule(range(n))
  defn params (n:ParseNode) : /params(rule(n)) as TokenRuleParams  

  ;Comparison functions ordered by importance.
  defn compare-length (a:ParseNode, b:ParseNode) -> Int :
    compare(length(b), length(a))

  defn compare-priority (a:ParseNode, b:ParseNode) -> Int :
    compare(priority(params(b)), priority(params(a)))

  defn compare-associativity (a:ParseNode, b:ParseNode) -> Int :
    compare(associativity(params(a)), associativity(params(b)))

  defn compare-associativity-length (a:ParseNode, b:ParseNode) -> Int :
    match(associativity(params(a)), associativity(params(b))) :
      (aa:NonAssociative, ab:NonAssociative) :
        0
      (aa:LeftAssociative, ab:LeftAssociative) :
        compare(first-child-length(b), first-child-length(a))
      (aa:RightAssociative, ab:RightAssociative) :
        compare(last-child-length(b), last-child-length(a))

  defn compare-order (a:ParseNode, b:ParseNode) -> Int :
    compare(order(rule(a)) as Int, order(rule(b)) as Int)

  ;Most most specific node
  val minima = minima(nodes, [compare-length,
                              compare-priority,
                              compare-associativity,
                              compare-associativity-length,
                              compare-order])
  minima[0]