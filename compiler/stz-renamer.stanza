defpackage stz/renamer :
   import core
   import verse
   import stz/il-ir
   import stz/namemap

;definterface Scope
;defmulti entries (s:Scope) -> Vector<Int>
;defstruct PScope <: Scope :
;   entries: Vector<Int> with: (as-method => true)
;defstruct BScope <: Scope :
;   entries: Vector<Int> with: (as-method => true)
;defstruct Group <: Scope :
;   entries: Vector<Int> with: (as-method => true)
;
;public defn rename (e:IExp) :
;   val namespace = NameMap()
;   val scopes = Vector<Scope>()
;   var visibility = Private()
;
;   defn rename-te (e:IExp) :
;      rename-e(flatten-te(e))
;
;   defn rename-e (e:IExp) :
;      match(e) :
;         (e:IDefType) :
;            val #class = run(rename-c+, class(e))
;            begin-bscope()
;            val #args = run(rename-t+, args(e))
;            end-bscope()
;            val #parent = parent(e)
;            val #info = info(e)
;            IDefType(#class, #args, #parent, #info)
;         (e:IDef) :
;            val #name = run(rename-l+, name(e))
;            val #type = type(e)
;            val #value = run(rename-e, value(e))
;            val #info = info(e)
;            IDef(#name, #type, #value, #info)
   


;   {...} means the following is in a new scope, and all following definitions are private.
;   public{...} means the following is defined public.
;   G{...} means the following is in a new grouping.
;   _:e means continue every single expression with that style.
;   *+ means every single ivar becomes a binder
;      where c+ means as a class entry
;            t+ means as a type variable entry
;            f+ means as a function entry
;            m+ means as a multi entry
;            l+ means as a value entry
;            v+ means as a variable entry

;   defrenamers :
   ;   custom te (e:IExp) :
   ;      rename-e(flatten-te(e))
   ;   
   ;   custom se (e:IExp) :
   ;      rename-e(flatten-se(e))
   ;   
   ;   e(rename-e) :
   ;      IDefType : (class:c+, {args:t+}, parent:?, info:?)
   ;      IDef : (name:l+, type:?, value:e, info:?)
   ;      IDefVar : (name:v+, type:?, value:e, info:?)
   ;      IDefn : (tail?:?, name:f+, {targs:t+, a1:t, a2:?, args:l+, body:se}, info:?)
   ;      IDefmulti : (name:m+, {targs:t+, a1:t}, a2:?, info:?)
   ;      IDefmethod : (tail?:?, multi:?, thisn:?, {targs:t+, a1:t, a2:?, args:l+, body:se}, info:?)
   ;      IFn : (tail?:?, a1:?, a2:?, {args:l+, body:se}, info:?)
   ;      IBranch : (types:?, {args:l+, body:se}, info:?)
   ;      IDo : (func:f, args:e, info:?)
   ;      INew : (class:?, methods:e, info:?)
   ;      ICast : (exp:e, type:?, info:?)
   ;      ISet : (name:?, value:e, info:?)
   ;      IPrim : (function:?, args:e, info:?)
   ;      ICallLS : (function:?, args:e, info:?)
   ;      LetRec : (group{defns:e}, body:e, info:?)
   ;      IExport : (public{exp:e}, info:?)
   ;      
   ;      ILSDefStruct : (name:c+, parents:?, types:?, rtypes:?, fields:?, rfield:?, info:?)
   ;      ILSExtern : (name:v+, type:?, info:?)
   ;      ILSExternFn : (name:f+, type:?, info:?)
   ;      ILSDefn : (name:f+, a1:?, a2:?, {args:v+, body:e}, info:?)   
   ;      ILSDef : (name:v+, type:?, exp:?, info:?)
   ;      ILSBegin : (comms:e, info:?)
   ;      ILSTCall : (_:?)
   ;      ILSSet : (_:?)
   ;      ILSLabel (_:?)
   ;      ILSGoto : (_:?)
   ;      ILSReturn : (_:?)
   ;      ILSLet : (comm:e, info:?)
   ;      ILSIf : (pred:?, conseq:e, alt:e, info:?)   
   ;      ILSMatch : (exp:?, branches:e, info:?)
   ;      ILSBranch : (types:?, body:e, info:?)
   ;      ILSDo : (_:?)
   ;      ILSCallC : (_:?)
   ;   
   ;      IExp : (_:e)
   ;   
   ;   t :
   ;      IOf : (class:?, args:t, info:?)
   ;      IAnd : (a:t, b:t, info:?)
   ;      IOr : (a:t, b:t, info:?)
   ;      IArrow : (a1:?, a2:t)
   ;      ICap : (name:t+, info:?)
   ;      IExp : (_:?)
   ;      
   ;   f :
   ;      IOf : (class:e, args:?, info:?)
   ;      IExp : goto e