defpackage stz/renamer :
   import core
   import verse
   import stz/il-ir
   import stz/namemap

(defn rename-exp (e : IExp eng : Engine) : (defn #map (@of (@cap S) (@cap T)) (f : T -> (@cap S) x : (@cap T)) : f (@do x) defn #map (@of (@cap S) (@cap T)) (f : T -> (@cap S) x : List (@of (@cap T))) : core/map (@do f x) ((defn gen106 (e : IExp) : (match (@do e) : ((e : IDefType) : (let : (val gen116 = class (@do e) (let : (val gen117 = #map (@do gen113 gen116) (push-scope (@do eng) (let : (val gen118 = args (@do e) (let : (val gen119 = #map (@do gen111 gen118) (pop-scope (@do eng) (let : (val gen120 = parent (@do e) (let : (val gen121 = info (@do e) (let : (val e = IDefType (@do gen117 gen119 gen120 gen121) e)))))))))))))))) (e : IDef) : (let : (val gen131 = name (@do e) (let : (val gen132 = #map (@do gen110 gen131) (let : (val gen133 = value (@do e) (let : (val gen134 = #map (@do gen106 gen133) (let : (val gen135 = type (@do e) (let : (val gen136 = info (@do e) (let : (val e = IDef (@do gen132 gen135 gen134 gen136) e)))))))))))))) (e : IDefVar) : (let : (val gen144 = name (@do e) (let : (val gen145 = #map (@do gen109 gen144) (let : (val gen146 = value (@do e) (let : (val gen147 = #map (@do gen106 gen146) (let : (val gen148 = type (@do e) (let : (val gen149 = info (@do e) (let : (val e = IDefVar (@do gen145 gen148 gen147 gen149) e)))))))))))))) (e : IDefn) : (let : (val gen157 = name (@do e) (let : (val gen158 = #map (@do gen115 gen157) (push-scope (@do eng) (let : (val gen159 = targs (@do e) (let : (val gen160 = #map (@do gen111 gen159) (let : (val gen161 = args (@do e) (let : (val gen162 = #map (@do gen110 gen161) (let : (val gen163 = body (@do e) (let : (val gen164 = #map (@do gen107 gen163) (pop-scope (@do eng) (let : (val gen165 = tail? (@do e) (let : (val gen166 = a1 (@do e) (let : (val gen167 = a2 (@do e) (let : (val gen168 = info (@do e) (let : (val e = IDefn (@do gen165 gen158 gen160 gen166 gen167 gen162 gen164 gen168) e)))))))))))))))))))))))))))) (e : IDefmulti) : (let : (val gen184 = name (@do e) (let : (val gen185 = #map (@do gen114 gen184) (push-scope (@do eng) (let : (val gen186 = targs (@do e) (let : (val gen187 = #map (@do gen111 gen186) (pop-scope (@do eng) (let : (val gen188 = a1 (@do e) (let : (val gen189 = a2 (@do e) (let : (val gen190 = info (@do e) (let : (val e = IDefmulti (@do gen185 gen187 gen188 gen189 gen190) e)))))))))))))))))) (e : IDefmethod) : (push-scope (@do eng) (let : (val gen201 = targs (@do e) (let : (val gen202 = #map (@do gen111 gen201) (let : (val gen203 = args (@do e) (let : (val gen204 = #map (@do gen110 gen203) (let : (val gen205 = body (@do e) (let : (val gen206 = #map (@do gen107 gen205) (pop-scope (@do eng) (let : (val gen207 = tail? (@do e) (let : (val gen208 = multi (@do e) (let : (val gen209 = thisn (@do e) (let : (val gen210 = a1 (@do e) (let : (val gen211 = a2 (@do e) (let : (val gen212 = info (@do e) (let : (val e = IDefmethod (@do gen207 gen208 gen209 gen202 gen210 gen211 gen204 gen206 gen212) e)))))))))))))))))))))))))))) (e : IFn) : (push-scope (@do eng) (let : (val gen228 = args (@do e) (let : (val gen229 = #map (@do gen110 gen228) (let : (val gen230 = body (@do e) (let : (val gen231 = #map (@do gen107 gen230) (pop-scope (@do eng) (let : (val gen232 = tail? (@do e) (let : (val gen233 = a1 (@do e) (let : (val gen234 = a2 (@do e) (let : (val gen235 = info (@do e) (let : (val e = IFn (@do gen232 gen233 gen234 gen229 gen231 gen235) e)))))))))))))))))))) (e : IBranch) : (push-scope (@do eng) (let : (val gen247 = args (@do e) (let : (val gen248 = #map (@do gen110 gen247) (let : (val gen249 = body (@do e) (let : (val gen250 = #map (@do gen107 gen249) (pop-scope (@do eng) (let : (val gen251 = types (@do e) (let : (val gen252 = info (@do e) (let : (val e = IBranch (@do gen251 gen248 gen250 gen252) e)))))))))))))))) (e : IDo) : (let : (val gen262 = func (@do e) (let : (val gen263 = #map (@do gen108 gen262) (let : (val gen264 = args (@do e) (let : (val gen265 = #map (@do gen106 gen264) (let : (val gen266 = info (@do e) (let : (val e = IDo (@do gen263 gen265 gen266) e)))))))))))) (e : INew) : (let : (val gen273 = methods (@do e) (let : (val gen274 = #map (@do gen106 gen273) (let : (val gen275 = class (@do e) (let : (val gen276 = info (@do e) (let : (val e = INew (@do gen275 gen274 gen276) e)))))))))) (e : ICast) : (let : (val gen282 = exp (@do e) (let : (val gen283 = #map (@do gen106 gen282) (let : (val gen284 = type (@do e) (let : (val gen285 = info (@do e) (let : (val e = ICast (@do gen283 gen284 gen285) e)))))))))) (e : ISet) : (let : (val gen291 = value (@do e) (let : (val gen292 = #map (@do gen106 gen291) (let : (val gen293 = name (@do e) (let : (val gen294 = info (@do e) (let : (val e = ISet (@do gen293 gen292 gen294) e)))))))))) (e : IPrim) : (let : (val gen300 = args (@do e) (let : (val gen301 = #map (@do gen106 gen300) (let : (val gen302 = function (@do e) (let : (val gen303 = info (@do e) (let : (val e = IPrim (@do gen302 gen301 gen303) e)))))))))) (e : ICallLS) : (let : (val gen309 = args (@do e) (let : (val gen310 = #map (@do gen106 gen309) (let : (val gen311 = function (@do e) (let : (val gen312 = info (@do e) (let : (val e = ICallLS (@do gen311 gen310 gen312) e)))))))))) (e : LetRec) : (push-group (@do eng) (let : (val gen318 = defns (@do e) (let : (val gen319 = #map (@do gen106 gen318) (pop-group (@do eng) (let : (val gen320 = body (@do e) (let : (val gen321 = #map (@do gen106 gen320) (let : (val gen322 = info (@do e) (let : (val e = LetRec (@do gen319 gen321 gen322) e)))))))))))))) (e : IPublic) : (push-visibility (@do eng Public (@do)) (let : (val gen331 = exp (@do e) (let : (val gen332 = #map (@do gen106 gen331) (pop-visibility (@do eng) (let : (val gen333 = info (@do e) (let : (val e = IPublic (@do gen332 gen333) e)))))))))) (e : IProtected) : (push-visibility (@do eng Protected (@do)) (let : (val gen340 = exp (@do e) (let : (val gen341 = #map (@do gen106 gen340) (pop-visibility (@do eng) (let : (val gen342 = info (@do e) (let : (val e = IProtected (@do gen341 gen342) e)))))))))) (e : ILSDefStruct) : (let : (val gen349 = name (@do e) (let : (val gen350 = #map (@do gen113 gen349) (let : (val gen351 = parents (@do e) (let : (val gen352 = types (@do e) (let : (val gen353 = rtype (@do e) (let : (val gen354 = fields (@do e) (let : (val gen355 = rfield (@do e) (let : (val gen356 = info (@do e) (let : (val e = ILSDefStruct (@do gen350 gen351 gen352 gen353 gen354 gen355 gen356) e)))))))))))))))))) (e : ILSExtern) : (let : (val gen366 = name (@do e) (let : (val gen367 = #map (@do gen109 gen366) (let : (val gen368 = type (@do e) (let : (val gen369 = info (@do e) (let : (val e = ILSExtern (@do gen367 gen368 gen369) e)))))))))) (e : ILSExternFn) : (let : (val gen375 = name (@do e) (let : (val gen376 = #map (@do gen115 gen375) (let : (val gen377 = type (@do e) (let : (val gen378 = info (@do e) (let : (val e = ILSExternFn (@do gen376 gen377 gen378) e)))))))))) (e : ILSDefn) : (let : (val gen384 = name (@do e) (let : (val gen385 = #map (@do gen115 gen384) (push-scope (@do eng) (let : (val gen386 = args (@do e) (let : (val gen387 = #map (@do gen109 gen386) (let : (val gen388 = body (@do e) (let : (val gen389 = #map (@do gen106 gen388) (pop-scope (@do eng) (let : (val gen390 = a1 (@do e) (let : (val gen391 = a2 (@do e) (let : (val gen392 = info (@do e) (let : (val e = ILSDefn (@do gen385 gen390 gen391 gen387 gen389 gen392) e)))))))))))))))))))))) (e : ILSDef) : (let : (val gen405 = name (@do e) (let : (val gen406 = #map (@do gen109 gen405) (let : (val gen407 = type (@do e) (let : (val gen408 = exp (@do e) (let : (val gen409 = info (@do e) (let : (val e = ILSDef (@do gen406 gen407 gen408 gen409) e)))))))))))) (e : ILSTCall) : e (e : ILSSet) : e (e : ILSLabel) : e (e : ILSGoto) : e (e : ILSReturn) : e (e : ILSIf) : (let : (val gen416 = conseq (@do e) (let : (val gen417 = #map (@do gen106 gen416) (let : (val gen418 = alt (@do e) (let : (val gen419 = #map (@do gen106 gen418) (let : (val gen420 = pred (@do e) (let : (val gen421 = info (@do e) (let : (val e = ILSIf (@do gen420 gen417 gen419 gen421) e)))))))))))))) (e : ILSMatch) : (let : (val gen429 = branches (@do e) (let : (val gen430 = #map (@do gen106 gen429) (let : (val gen431 = exp (@do e) (let : (val gen432 = info (@do e) (let : (val e = ILSMatch (@do gen431 gen430 gen432) e)))))))))) (e : ILSBranch) : (push-scope (@do eng) (let : (val gen438 = exp (@do e) (let : (val gen439 = #map (@do gen109 gen438) (let : (val gen440 = body (@do e) (let : (val gen441 = #map (@do gen106 gen440) (pop-scope (@do eng) (let : (val gen442 = type (@do e) (let : (val gen443 = info (@do e) (let : (val e = ILSBranch (@do gen439 gen442 gen441 gen443) e)))))))))))))))) (e : ILSDo) : e (e : ILSCallC) : e (e : IExp) : (let : (val e = map (@do gen106 e) e))))) (defn gen107 (e : IExp) : (match (@do e) : ((e : IExp) : (let : (val e = (flatten-se (@do e)) (let : (val e = gen106 (@do e) e))))))) (defn gen108 (e : IExp) : (match (@do e) : ((e : IOf) : (let : (val gen526 = class (@do e) (let : (val gen527 = #map (@do gen106 gen526) (let : (val gen528 = args (@do e) (let : (val gen529 = info (@do e) (let : (val e = IOf (@do gen527 gen528 gen529) e)))))))))) (e : IExp) : (let : (val e = gen106 (@do e) e))))) (defn gen109 (e : IExp) : (match (@do e) : ((e : IVar) : (let : (val e = register-mutable-var (@do eng e) e)) (e : ILSVar) : (let : (val e = register-ls-mutable-var (@do eng e) e))))) (defn gen110 (e : IExp) : (match (@do e) : ((e : IVar) : (let : (val e = register-var (@do eng e) e)) (e : ITuple) : (let : (val e = map (@do gen110 e) e))))) (defn gen111 (e : IExp) : (match (@do e) : ((e : IVar) : (let : (val e = register-tvar (@do eng e) e)) (e : ICap) : (let : (val gen556 = name (@do e) (let : (val gen557 = #map (@do gen112 gen556) (let : (val gen558 = info (@do e) (let : (val e = ICap (@do gen557 gen558) e))))))))))) (defn gen112 (e : IExp) : (match (@do e) : ((e : IVar) : (let : (val e = register-capvar (@do eng e) e))))) (defn gen113 (e : IExp) : (match (@do e) : ((e : IVar) : (let : (val e = register-class (@do eng e) e))))) (defn gen114 (e : IExp) : (match (@do e) : ((e : IVar) : (let : (val e = register-multi (@do eng e) e))))) (defn gen115 (e : IExp) : (match (@do e) : ((e : IVar) : (let : (val e = register-fn (@do eng e) e)) (e : ILSVar) : (let : (val e = register-ls-fn (@do eng e) e)))))) gen106 (@do e)))


;============================================================
;=================== Implementation =========================
;============================================================


defn flatten (e:IExp) -> List<IExp> :
   match(e) :
      (e:IBegin) : exps(e)
      (e) : list(e)

defn flatten-pe (e:IExp) :
   defn var-name! (e:IExp) :
      name(e as IVar)
   defn loop (es:List<IExp>) -> [List<IExp>, List<LetPackage>] :
      if empty?(es) :
         [List(), List()]
      else :
         match(head(es)) :
            (h:IPackage) :
               val [es, ps] = loop(tail(es))
               val p = LetPackage(var-name!(name(h)),
                                  imports(h),
                                  IBegin(es, info(h)),
                                  info(h))
               [List(), List(p, ps)]
            (h) :
               val [es, ps] = loop(tail(es))
               [List(h, es), ps]
   val [es, ps] = loop(flatten(e))
   ps

defn flatten-se (e:IExp) :
   defn loop (es:List<IExp>) -> IExp :
      if empty?(tail(es)) :
         head(es)
      else :
         match(head(es), loop(tail(es))) :
            (h:IDefn, t:LetRec) : LetRec(List(h, defns(t)), body(t), info(h))
            (h:IDefn, t) : LetRec(list(h), t, info(h))
            (h:IDef, t) : Let(h, t, info(h))
            (h, t:IBegin) : IBegin(List(h, exps(t)), info(h))
            (h, t) :IBegin(list(h, t), info(h))
   loop(flatten(e))

definterface Engine
defmulti push-scope (e:Engine) -> False
defmulti pop-scope (e:Engine) -> False
defmulti push-group (e:Engine) -> False
defmulti pop-group (e:Engine) -> False
defmulti push-visibility (e:Engine, v:Vis) -> False
defmulti pop-visibility (e:Engine) -> False
defmulti register-mutable-var (e:Engine, v:IVar) -> IVar
defmulti register-ls-mutable-var (e:Engine, v:ILSVar) -> ILSVar
defmulti register-var (e:Engine, v:IVar) -> IVar
defmulti register-tvar (e:Engine, v:IVar) -> IVar
defmulti register-capvar (e:Engine, v:IVar) -> IVar
defmulti register-class (e:Engine, v:IVar) -> IVar
defmulti register-multi (e:Engine, v:IVar) -> IVar
defmulti register-fn (e:Engine, v:IVar) -> IVar
defmulti register-ls-fn (e:Engine, v:ILSVar) -> ILSVar

public defn rename (e:IExp) :
   val packages = flatten-pe(e)
   val namemap = NameMap()
   val renamed = for p in packages map :
      val body* = rename-exp(body(p), eng) where :
         val eng = new Engine :
            defmethod push-scope (this) :
               println("push-scope")
            defmethod pop-scope (this) :
               println("pop-scope")
            defmethod push-group (this) :
               println("push-group")
            defmethod pop-group (this) :
               println("pop-group")
            defmethod push-visibility (this, vis:Vis) :
               println("push-visibility")
            defmethod pop-visibility (this) :
               println("pop-visibility")
            defmethod register-mutable-var (this, e:IVar) :
               println("register mutable var ~" << [e])
               e
            defmethod register-ls-mutable-var (this, e:ILSVar) :
               println("register ls mutable var ~" << [e])
               e
            defmethod register-var (this, e:IVar) :
               println("register var ~" << [e])
               e
            defmethod register-tvar (this, e:IVar) :
               println("register type var ~" << [e])
               e
            defmethod register-capvar (this, e:IVar) :
               println("register cap var ~" << [e])
               e
            defmethod register-class (this, e:IVar) :
               println("register class ~" << [e])
               e
            defmethod register-multi (this, e:IVar) :
               println("register multi ~" << [e])
               e
            defmethod register-fn (this, e:IVar) :
               println("register fn ~" << [e])
               e
            defmethod register-ls-fn (this, e:ILSVar) :
               println("register ls fn ~" << [e])
               e
      LetPackage(name(p), imports(p), body*, info(p))
   [namemap, IBegin(renamed, FileInfo())]

;definterface Space
;defstruct Scope <: Space :
;   entries: Vector<Space>
;   top: True|False
;defstruct Group <: Space :
;   entries: Vector<Elem>
;defstruct Elem <: Space :
;   n: Int
;
;#with-overlay(stz/rename-lang) :
;   public defn rename (e:IExp) :
;      ;======== Engine ========
;      val namespace = NameMap()
;      val scopes = Vector<Scope>()
;      val spaces = Vector<Scope|Group>()
;      var visibility = Private()
;      var package:Symbol
;      defn add-space (s:Space) : add(entries(peek(spaces)), s)
;      defn begin-package () : add(spaces, Scope(Vector<Space>(), true))
;      defn end-package () : add(scopes, pop(spaces) as Scope)
;      defn begin-scope () : add(spaces, Scope(Vector<Space>(), false))
;      defn end-scope () : add(scopes, pop(spaces) as Scope)
;      defn begin-group () : add(spaces, Group(Vector<Elem>()))
;      defn end-group () :add-space(pop(spaces))
;      defn register-elem (name:Symbol, type:EType, info:FileInfo) :
;         val n = register(namespace, package, name, visibility, type, info)
;         add-space(Elem(n))
;         n
;      defn reg-vars (e:IExp, type:EType, ltype:EType) :
;         match(e) :
;            (e:IVar) : VarN(register-elem(name(e), type, info(e)), info(e))
;            (e:ILSVar) : LSVarN(register-elem(name(e), ltype, info(e)), info(e))
;            (e) : map(reg-vars{_, type, ltype}, e)
;      defn reg-vars (e:IExp, type:EType) :
;         match(e) :
;            (e:IVar) : VarN(register-elem(name(e), type, info(e)), info(e))
;            (e) : map(reg-vars{_, type}, e)
;      defn #map (f: IExp -> IExp, e:IExp) : f(e)
;      defn #map (f: IExp -> IExp, e:List<IExp>) : map(f, e)
;
;      defn rename-pe (e:IExp) :
;         IBegin{_, FileInfo()} $ for e in flatten-pe(e) map :
;            package = name(e)
;            begin-package()
;            val body* = rename-e(body(e))
;            end-package()
;            LetPackage(package, imports(e), body*, info(e))
;
;      ;======== Renamers Specification ========
;      defrenamers :
;         custom se (e:IExp) : rename-e(flatten-se(e))
;         custom c+ (e:IExp) : reg-vars(e, TypeE(), LTypeE())
;         custom l+ (e:IExp) : reg-vars(e, ValE())
;         custom v+ (e:IExp) : reg-vars(e, VarE(), LVarE())
;         custom m+ (e:IExp) : reg-vars(e, MultiE())
;         custom f+ (e:IExp) : reg-vars(e, FnE(), LFnE())
;
;         t+ :
;            IVar : goto t++
;            ICap : goto cv++
;            IExp : (_:t+)
;         custom t++ (e:IVar) : reg-vars(e, TVarE())
;         custom cv++ (e:ICap) : reg-vars(e, CapVarE())
;
;         e(rename-e) :
;            IDefType : (class:c+, {args:t+}, parent:?, info:?)
;            IDef : (name:l+, type:?, value:e, info:?)
;            IDefVar : (name:v+, type:?, value:e, info:?)
;            IDefn : (tail?:?, name:f+, {targs:t+, a1:?, a2:?, args:l+, body:se}, info:?)
;            IDefmulti : (name:m+, {targs:t+, a1:?}, a2:?, info:?)
;            IDefmethod : (tail?:?, multi:?, thisn:?, {targs:t+, a1:?, a2:?, args:l+, body:se}, info:?)
;            IFn : (tail?:?, a1:?, a2:?, {args:l+, body:se}, info:?)
;            IBranch : (types:?, {args:l+, body:se}, info:?)
;            IDo : (func:f, args:e, info:?)
;            INew : (class:?, methods:e, info:?)
;            ICast : (exp:e, type:?, info:?)
;            ISet : (name:?, value:e, info:?)
;            IPrim : (function:?, args:e, info:?)
;            ICallLS : (function:?, args:e, info:?)
;            LetRec : (group{defns:e}, body:e, info:?)
;            IPublic : (public{exp:e}, info:?)
;            IProtected : (protected{exp:e}, info:?)
;
;            ILSDefStruct : (name:c+, parents:?, types:?, rtype:?, fields:?, rfield:?, info:?)
;            ILSExtern : (name:v+, type:?, info:?)
;            ILSExternFn : (name:f+, type:?, info:?)
;            ILSDefn : (name:f+, a1:?, a2:?, {args:v+, body:e}, info:?)
;            ILSDef : (name:v+, type:?, exp:?, info:?)
;            ILSBegin : (comms:e, info:?)
;            ILSTCall : (_:?)
;            ILSSet : (_:?)
;            ILSLabel : (_:?)
;            ILSGoto : (_:?)
;            ILSReturn : (_:?)
;            ILSLet : (comm:e, info:?)
;            ILSIf : (pred:?, conseq:e, alt:e, info:?)
;            ILSMatch : (exp:?, branches:e, info:?)
;            ILSBranch : ({exp:v+, type:?, body:e}, info:?)
;            ILSDo : (_:?)
;            ILSCallC : (_:?)
;
;            IExp : (_:e)
;
;         f :
;            IOf : (class:e, args:?, info:?)
;            IExp : goto e
;
;      ;======== Driver ========
;      val r = rename-pe(e)
;      check-duplicates(namespace, scopes)
;      [namespace, r]
;
;;======== Duplicate Checking Algorithm ========
;
;defstruct RenameError <: Exception
;
;defn check-duplicates (namemap:NameMap, scopes: Vector<Scope>) :
;   defn name! (i:Int) : name(namemap[i] as VarEntry)
;   defn info! (i:Int) : info(namemap[i] as VarEntry)
;   defn type! (i:Int) : type(namemap[i] as VarEntry)
;
;   val errors = Vector<?>()
;   defn duplicate! (e:Elem, es:List<Int>) :
;      val infos = for ei in es stream :
;         "\n   ~ as ~" << [info!(ei), name!(ei)]
;      val msg = "~: Duplicate definition of ~. Also defined at: ~@" << [info!(n(e)), name!(n(e)), infos]
;      add(errors, msg)
;
;   val elems = Array<HashTable<Symbol,List<Int>>>(5)
;   for i in 0 to length(elems) do :
;      elems[i] = HashTable<Symbol,List<Int>>(symbol-hash)
;   defn clear-elems () :
;      for i in 0 to length(elems) do :
;         clear(elems[i])
;   defn ensure-no-duplicates (e:Elem, g:Int) :
;      val name = name!(n(e))
;      if key?(elems[g], name) :
;         duplicate!(e, to-list(elems[g][name]))
;   defn add-elem (e:Elem, g:Int) :
;      val name = name!(n(e))
;      elems[g][name] = List(n(e), get?(elems[g], name, List()))
;
;   defn check-top-scope (s:Scope) :
;      clear-elems()
;      for e in entries(s) as Vector<Elem> do :
;         match(type!(n(e))) :
;            (t:ValE|VarE) :
;               ensure-no-duplicates(e, 0)
;               ensure-no-duplicates(e, 1)
;               add-elem(e, 0)
;            (t:FnE|MultiE) :
;               ensure-no-duplicates(e, 0)
;               add-elem(e, 1)
;            (t:TypeE) :
;               ensure-no-duplicates(e, 2)
;               add-elem(e, 2)
;            (t:LVarE|LFnE) :
;               ensure-no-duplicates(e, 3)
;               add-elem(e, 3)
;            (t:LTypeE) :
;               ensure-no-duplicates(e, 4)
;               add-elem(e, 4)
;            (t) :
;               false
;
;   defn check-local-scope (s:Scope) :
;      clear-elems()
;      defn ensure-no-dups (e:Elem) :
;         match(type!(n(e))) :
;            (t:ValE|VarE|FnE) : ensure-no-duplicates(e, 0)
;            (t:TVarE|CapVarE) : ensure-no-duplicates(e, 1)
;            (t:LVarE) : ensure-no-duplicates(e, 2)
;            (t) : false
;      defn add (e:Elem) :
;         match(type!(n(e))) :
;            (t:ValE|VarE|FnE) : add-elem(e, 0)
;            (t:TVarE|CapVarE) : add-elem(e, 1)
;            (t:LVarE) : add-elem(e, 2)
;            (t) : false
;      for e in entries(s) do :
;         match(e) :
;            (e:Elem) :
;               ensure-no-dups(e)
;               add(e)
;            (e:Group) :
;               do(ensure-no-dups, entries(e))
;               do(add, entries(e))
;
;   for s in scopes do :
;      if top(s) : check-top-scope(s)
;      else : check-local-scope(s)
;   if not empty?(errors) :
;      do(println, errors)
;      throw(RenameError())
;
