defpackage stz/renamer :
   import core
   import verse
   import stz/il-ir
   import stz/namemap

;============================================================
;================== Specification ===========================
;============================================================

#use-overlay(stz/renamer-lang)
defrenamer rename-exp (e:IExp, eng:Engine) :
   e :
      ;Stanza
      IDefType : (class:c+, {args:t+})
      IDef : (name:v+, value:e)            
      IDefVar : (name:mv+, value:e)
      IDefn : (name:f+, {targs:t+, args:v+, body:se})
      IDefmulti : (name:m+, {targs:t+})
      IDefmethod : ({targs:t+, args:v+, body:se})
      IFn : ({args:v+, body:se})
      IBranch : ({args:v+, body:se})
      IDo : (func:f, args:e)
      INew : (methods:e)
      ICast : (exp:e)
      ISet : (value:e)
      IPrim : (args:e)
      ICallLS : (args:e)
      LetRec : (group{defns:e}, body:e)
      IPublic : (public{exp:e})
      IProtected : (protected{exp:e})
      
      ;LoStanza
      ILSDefStruct : (name:c+)
      ILSExtern : (name:mv+)
      ILSExternFn : (name:f+)
      ILSDefn : (name:f+, {body:l+} {args:mv+, body:e})
      ILSDef : (name:mv+)
      ILSTCall : ()
      ILSSet : ()
      ILSLabel : ()
      ILSGoto : ()
      ILSReturn : ()
      ILSLet : ({comm:e})
      ILSIf : ({conseq:e}, {alt:e})
      ILSMatch : (branches:e)
      ILSBranch : ({exp:mv+, body:e})
      ILSDo : ()
      ILSCallC : ()
      
      ;Fall through
      IExp : (_:e)

   se :
      IExp :
         custom{flatten-se(e)}
         goto e

   f :
      IOf : (class:e)
      IExp : goto e

   l+ :
      ILSVar : register label
      ILSTCall : ()
      ILSSet : ()
      ILSLabel : (name:l+)
      ILSGoto : ()
      ILSReturn : ()
      ILSIf : (conseq:l+, alt:l+)
      ILSMatch : (branches:l+)
      ILSBranch : (body:l+)
      ILSDef : ()
      IExp : (_:l+)
      
   mv+ :
      IVar : register mutable-var
      ILSVar : register ls-mutable-var      
   v+ :
      IVar : register var
      ITuple : (_:v+)      
   t+ :
      IVar : register tvar
      ICap : (name:cv+)
   cv+ :
      IVar : register capvar
   c+ :
      IVar : register class
   m+ :
      IVar : register multi
   f+ :
      IVar : register fn
      ILSVar : register ls-fn



;============================================================
;=================== Implementation =========================
;============================================================
defn flatten (e:IExp) -> List<IExp> :
   match(e) :
      (e:IBegin) : exps(e)
      (e) : list(e)

defn flatten-pe (e:IExp) :
   defn var-name! (e:IExp) :
      name(e as IVar)
   defn loop (es:List<IExp>) -> [List<IExp>, List<LetPackage>] :
      if empty?(es) :
         [List(), List()]
      else :
         match(head(es)) :
            (h:IPackage) :
               val [es, ps] = loop(tail(es))
               val p = LetPackage(var-name!(name(h)),
                                  imports(h),
                                  IBegin(es, info(h)),
                                  info(h))
               [List(), List(p, ps)]
            (h) :
               val [es, ps] = loop(tail(es))
               [List(h, es), ps]
   val [es, ps] = loop(flatten(e))
   ps

defn flatten-se (e:IExp) :
   defn loop (es:List<IExp>) -> IExp :
      if empty?(tail(es)) :
         head(es)
      else :
         match(head(es), loop(tail(es))) :
            (h:IDefn, t:LetRec) : LetRec(List(h, defns(t)), body(t), info(h))
            (h:IDefn, t) : LetRec(list(h), t, info(h))
            (h:IDef, t) : Let(h, t, info(h))
            (h, t:IBegin) : IBegin(List(h, exps(t)), info(h))
            (h, t) :IBegin(list(h, t), info(h))
   loop(flatten(e))

definterface Engine
defmulti push-scope (e:Engine) -> False
defmulti pop-scope (e:Engine) -> False
defmulti push-group (e:Engine) -> False
defmulti pop-group (e:Engine) -> False
defmulti push-visibility (e:Engine, v:Vis) -> False
defmulti pop-visibility (e:Engine) -> False
defmulti register-mutable-var (e:Engine, v:IVar) -> VarN
defmulti register-ls-mutable-var (e:Engine, v:ILSVar) -> LSVarN
defmulti register-var (e:Engine, v:IVar) -> VarN
defmulti register-tvar (e:Engine, v:IVar) -> VarN
defmulti register-capvar (e:Engine, v:IVar) -> VarN
defmulti register-class (e:Engine, v:IVar) -> VarN
defmulti register-multi (e:Engine, v:IVar) -> VarN
defmulti register-fn (e:Engine, v:IVar) -> VarN
defmulti register-ls-fn (e:Engine, v:ILSVar) -> LSVarN
defmulti register-label (e:Engine, v:ILSVar) -> LSVarN

definterface Item
defstruct Scope <: Item :
   entries: Vector<Item>
   top: True|False
defstruct Group <: Item :
   entries: Vector<Atom>
defstruct Atom <: Item :
   n: Int

public defn rename (e:IExp) :
   val packages = flatten-pe(e)
   val namemap = NameMap()
   val scopes = Vector<Scope>()
   
   val renamed = for p in packages map :
      val items = Vector<Scope|Group>()
      add(items, Scope(Vector<Item>(), true))
      val visibilities = Vector<Vis>()
      add(visibilities, Private())
      
      defn register-elem (vname:Symbol, type:EType, info:FileInfo) :
         val n = register(namemap, name(p), vname, peek(visibilities), type, info)
         add(entries(peek(items)), Atom(n))
         n
         
      val body* = rename-exp(body(p), eng) where :
         val eng = new Engine :
            defmethod push-scope (this) :
               add(items, Scope(Vector<Item>(), false))
               push-visibility(this, Local())
            defmethod pop-scope (this) :
               pop-visibility(this)
               add(scopes, pop(items) as Scope)
            defmethod push-group (this) :
               add(items, Group(Vector<Atom>()))
            defmethod pop-group (this) :
               val g = pop(items)
               add(entries(peek(items)), g)
            defmethod push-visibility (this, vis:Vis) :
               add(visibilities, vis)
            defmethod pop-visibility (this) :
               pop(visibilities)
               false
            defmethod register-mutable-var (this, e:IVar) :
               VarN(register-elem(name(e), VarE(), info(e)), info(e))
            defmethod register-ls-mutable-var (this, e:ILSVar) :
               LSVarN(register-elem(name(e), LVarE(), info(e)), info(e))
            defmethod register-var (this, e:IVar) :
               VarN(register-elem(name(e), ValE(), info(e)), info(e))
            defmethod register-tvar (this, e:IVar) :
               VarN(register-elem(name(e), TVarE(), info(e)), info(e))
            defmethod register-capvar (this, e:IVar) :
               VarN(register-elem(name(e), CapVarE(), info(e)), info(e))
            defmethod register-class (this, e:IVar) :
               VarN(register-elem(name(e), TypeE(), info(e)), info(e))
            defmethod register-multi (this, e:IVar) :
               VarN(register-elem(name(e), MultiE(), info(e)), info(e))
            defmethod register-fn (this, e:IVar) :
               VarN(register-elem(name(e), FnE(), info(e)), info(e))
            defmethod register-ls-fn (this, e:ILSVar) :
               LSVarN(register-elem(name(e), LFnE(), info(e)), info(e))
            defmethod register-label (this, e:ILSVar) :
               LSVarN(register-elem(name(e), LabelE(), info(e)), info(e))

      add(scopes, pop(items) as Scope)
      LetPackage(name(p), imports(p), body*, info(p))

   check-duplicates(packages)
   check-duplicates(namemap, scopes)
   [namemap, IBegin(renamed, FileInfo())]

;======== Duplicate Checking Algorithm ========

defstruct RenameError <: Exception

defn check-duplicates (ps:List<LetPackage>) :
   val errors = Vector<?>()
   val table = HashTable<Symbol,LetPackage>(symbol-hash)
   
   defn duplicate! (fileinfo:FileInfo, name:Symbol, other:LetPackage) :
      add{errors, _} $
      "~: Duplicate definition of package ~. Also defined at ~." << [
         fileinfo, name, info(other)]

   for p in ps do :
      if key?(table, name(p)) :
         duplicate!(info(p), name(p), table[name(p)])
      else :
         table[name(p)] = p

   if not empty?(errors) :
      do(println, errors)
      throw(RenameError())

defn check-duplicates (namemap:NameMap, scopes: Vector<Scope>) :
   defn name! (i:Int) : name(namemap[i] as VarEntry)
   defn info! (i:Int) : info(namemap[i] as VarEntry)
   defn type! (i:Int) : type(namemap[i] as VarEntry)

   val errors = Vector<?>()
   defn duplicate! (e:Atom, es:List<Int>) :
      val infos = for ei in es stream :
         "\n   ~ as ~" << [info!(ei), name!(ei)]
      val msg = "~: Duplicate definition of ~. Also defined at: ~@" <<
         [info!(n(e)), name!(n(e)), infos]
      add(errors, msg)

   val elems = Array<HashTable<Symbol,List<Int>>>(5)
   for i in 0 to length(elems) do :
      elems[i] = HashTable<Symbol,List<Int>>(symbol-hash)
   defn clear-elems () :
      for i in 0 to length(elems) do :
         clear(elems[i])
   defn ensure-no-duplicates (e:Atom, g:Int) :
      val name = name!(n(e))
      if key?(elems[g], name) :
         duplicate!(e, to-list(elems[g][name]))
   defn add-elem (e:Atom, g:Int) :
      val name = name!(n(e))
      elems[g][name] = List(n(e), get?(elems[g], name, List()))

   defn check-top-scope (s:Scope) :
      clear-elems()
      for e in entries(s) as Vector<Atom> do :
         match(type!(n(e))) :
            (t:ValE|VarE) :
               ensure-no-duplicates(e, 0)
               ensure-no-duplicates(e, 1)
               add-elem(e, 0)
            (t:FnE|MultiE) :
               ensure-no-duplicates(e, 0)
               add-elem(e, 1)
            (t:TypeE) :
               ensure-no-duplicates(e, 2)
               add-elem(e, 2)
            (t:LVarE|LFnE) :
               ensure-no-duplicates(e, 3)
               add-elem(e, 3)
            (t:LTypeE) :
               ensure-no-duplicates(e, 4)
               add-elem(e, 4)
            (t) :
               false

   defn check-local-scope (s:Scope) :
      clear-elems()
      defn ensure-no-dups (e:Atom) :
         match(type!(n(e))) :
            (t:ValE|VarE|FnE) : ensure-no-duplicates(e, 0)
            (t:TVarE|CapVarE) : ensure-no-duplicates(e, 1)
            (t:LVarE) : ensure-no-duplicates(e, 2)
            (t:LabelE) : ensure-no-duplicates(e, 3)
            (t) : false
      defn add (e:Atom) :
         match(type!(n(e))) :
            (t:ValE|VarE|FnE) : add-elem(e, 0)
            (t:TVarE|CapVarE) : add-elem(e, 1)
            (t:LVarE) : add-elem(e, 2)
            (t:LabelE) : add-elem(e, 3)
            (t) : false
      for e in entries(s) do :
         match(e) :
            (e:Atom) :
               ensure-no-dups(e)
               add(e)
            (e:Group) :
               do(ensure-no-dups, entries(e))
               do(add, entries(e))

   for s in scopes do :
      if top(s) : check-top-scope(s)
      else : check-local-scope(s)
   if not empty?(errors) :
      do(println, errors)
      throw(RenameError())

