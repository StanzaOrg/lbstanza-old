defpackage stz/renamer :
   import core
   import verse
   import stz/il-ir
   import stz/namemap

defn flatten (e:IExp) -> List<IExp> :
   match(e) :
      (e:IBegin) : exps(e)
      (e) : list(e)

defn flatten-pe (e:IExp) :
   defn var-name! (e:IExp) : name(e as IVar)
   defn loop (es:List<IExp>) -> [List<IExp>, List<LetPackage>] :
      if empty?(es) :
         [List(), List()]
      else :
         match(head(es)) :
            (h:IPackage) :
               val [es, ps] = loop(tail(es))
               val p = LetPackage(var-name!(name(h)), imports(h), IBegin(es, info(h)), info(h))
               [List(), List(p, ps)]
            (h) :
               val [es, ps] = loop(tail(es))
               [List(h, es), ps]
   val [es, ps] = loop(flatten(e))
   ps

defn flatten-se (e:IExp) :
   defn loop (es:List<IExp>) -> IExp :
      if empty?(tail(es)) :
         head(es)
      else :
         match(head(es), loop(tail(es))) :
            (h:IDefn, t:LetRec) : LetRec(List(h, defns(t)), body(t), info(h))
            (h:IDefn, t) : LetRec(list(h), t, info(h))
            (h:IDef, t) : Let(h, t, info(h))
            (h, t:IBegin) : IBegin(List(h, exps(t)), info(h))
            (h, t) :IBegin(list(h, t), info(h))               
   loop(flatten(e))

definterface Space
defstruct Scope <: Space :
   entries: Vector<Space>
   top: True|False
defstruct Group <: Space :
   entries: Vector<Elem>
defstruct Elem <: Space :
   n: Int

#with-overlay(stz/rename-lang) :
   public defn rename (e:IExp) :
      ;======== Engine ========
      val namespace = NameMap()
      val scopes = Vector<Scope>()
      val spaces = Vector<Scope|Group>()
      var visibility = Private()
      var package:Symbol      
      defn add-space (s:Space) : add(entries(peek(spaces)), s)
      defn begin-package () : add(spaces, Scope(Vector<Space>(), true))
      defn end-package () : add(scopes, pop(spaces) as Scope)         
      defn begin-scope () : add(spaces, Scope(Vector<Space>(), false))
      defn end-scope () : add(scopes, pop(spaces) as Scope)
      defn begin-group () : add(spaces, Group(Vector<Elem>()))
      defn end-group () :add-space(pop(spaces))
      defn register-elem (name:Symbol, type:EType, info:FileInfo) :
         val n = register(namespace, package, name, visibility, type, info)
         add-space(Elem(n))
         n
      defn reg-vars (e:IExp, type:EType, ltype:EType) :
         match(e) :
            (e:IVar) : VarN(register-elem(name(e), type, info(e)), info(e))
            (e:ILSVar) : LSVarN(register-elem(name(e), ltype, info(e)), info(e))
            (e) : map(reg-vars{_, type, ltype}, e)
      defn reg-vars (e:IExp, type:EType) :
         match(e) :
            (e:IVar) : VarN(register-elem(name(e), type, info(e)), info(e))
            (e) : map(reg-vars{_, type}, e)
      defn #map (f: IExp -> IExp, e:IExp) : f(e)
      defn #map (f: IExp -> IExp, e:List<IExp>) : map(f, e)

      defn rename-pe (e:IExp) :
         IBegin{_, FileInfo()} $ for e in flatten-pe(e) map :
            package = name(e)
            begin-package()
            val body* = rename-e(body(e))
            end-package()
            LetPackage(package, imports(e), body*, info(e))
               
      ;======== Renamers Specification ========
      defrenamers :
         custom se (e:IExp) : rename-e(flatten-se(e))
         custom c+ (e:IExp) : reg-vars(e, TypeE(), LTypeE())
         custom t+ (e:IExp) : reg-vars(e, TVarE())
         custom l+ (e:IExp) : reg-vars(e, ValE())
         custom v+ (e:IExp) : reg-vars(e, VarE(), LVarE())
         custom m+ (e:IExp) : reg-vars(e, MultiE())
         custom f+ (e:IExp) : reg-vars(e, FnE(), LFnE())

         e(rename-e) :
            IDefType : (class:c+, {args:t+}, parent:?, info:?)
            IDef : (name:l+, type:?, value:e, info:?)
            IDefVar : (name:v+, type:?, value:e, info:?)
            IDefn : (tail?:?, name:f+, {targs:t+, a1:?, a2:?, args:l+, body:se}, info:?)
            IDefmulti : (name:m+, {targs:t+, a1:?}, a2:?, info:?)
            IDefmethod : (tail?:?, multi:?, thisn:?, {targs:t+, a1:?, a2:?, args:l+, body:se}, info:?)
            IFn : (tail?:?, a1:?, a2:?, {args:l+, body:se}, info:?)
            IBranch : (types:?, {args:l+, body:se}, info:?)
            IDo : (func:f, args:e, info:?)
            INew : (class:?, methods:e, info:?)
            ICast : (exp:e, type:?, info:?)
            ISet : (name:?, value:e, info:?)
            IPrim : (function:?, args:e, info:?)
            ICallLS : (function:?, args:e, info:?)
            LetRec : (group{defns:e}, body:e, info:?)
            IPublic : (public{exp:e}, info:?)
            IProtected : (protected{exp:e}, info:?)

            ILSDefStruct : (name:c+, parents:?, types:?, rtype:?, fields:?, rfield:?, info:?)
            ILSExtern : (name:v+, type:?, info:?)
            ILSExternFn : (name:f+, type:?, info:?)
            ILSDefn : (name:f+, a1:?, a2:?, {args:v+, body:e}, info:?)
            ILSDef : (name:v+, type:?, exp:?, info:?)
            ILSBegin : (comms:e, info:?)
            ILSTCall : (_:?)
            ILSSet : (_:?)
            ILSLabel : (_:?)
            ILSGoto : (_:?)
            ILSReturn : (_:?)
            ILSLet : (comm:e, info:?)
            ILSIf : (pred:?, conseq:e, alt:e, info:?)
            ILSMatch : (exp:?, branches:e, info:?)
            ILSBranch : ({exp:v+, type:?, body:e}, info:?)
            ILSDo : (_:?)
            ILSCallC : (_:?)

            IExp : (_:e)

         f :
            IOf : (class:e, args:?, info:?)
            IExp : goto e

      ;======== Driver ========
      val r = rename-pe(e)
      check-duplicates(namespace, scopes)
      [namespace, r]

;======== Duplicate Checking Algorithm ========

defstruct RenameError <: Exception

defn check-duplicates (namemap:NameMap, scopes: Vector<Scope>) :
   defn name! (i:Int) : name(namemap[i] as VarEntry)
   defn info! (i:Int) : info(namemap[i] as VarEntry)
   defn type! (i:Int) : type(namemap[i] as VarEntry)
   
   val errors = Vector<?>()
   defn duplicate! (e:Elem, es:List<Int>) :
      val infos = for ei in es stream :
         "\n   ~ as ~" << [info!(ei), name!(ei)]
      val msg = "~: Duplicate definition of ~. Also defined at: ~@" << [info!(n(e)), name!(n(e)), infos]
      add(errors, msg)

   val elems = Array<HashTable<Symbol,List<Int>>>(5)
   for i in 0 to length(elems) do :
      elems[i] = HashTable<Symbol,List<Int>>(symbol-hash)
   defn clear-elems () :
      for i in 0 to length(elems) do :
         clear(elems[i])
   defn ensure-no-duplicates (e:Elem, g:Int) :
      val name = name!(n(e))
      if key?(elems[g], name) :
         duplicate!(e, to-list(elems[g][name]))
   defn add-elem (e:Elem, g:Int) :
      val name = name!(n(e))
      elems[g][name] = List(n(e), get?(elems[g], name, List()))

   defn check-top-scope (s:Scope) :
      clear-elems()
      for e in entries(s) as Vector<Elem> do :
         match(type!(n(e))) :
            (t:ValE|VarE) :
               ensure-no-duplicates(e, 0)
               ensure-no-duplicates(e, 1)
               add-elem(e, 0)
            (t:FnE|MultiE) :
               ensure-no-duplicates(e, 0)
               add-elem(e, 1)
            (t:TypeE) :
               ensure-no-duplicates(e, 2)
               add-elem(e, 2)
            (t:LVarE|LFnE) :
               ensure-no-duplicates(e, 3)
               add-elem(e, 3)
            (t:LTypeE) :
               ensure-no-duplicates(e, 4)
               add-elem(e, 4)
            (t) :
               false

   defn check-local-scope (s:Scope) :
      clear-elems()
      defn ensure-no-dups (e:Elem) :
         match(type!(n(e))) :
            (t:ValE|VarE|FnE) : ensure-no-duplicates(e, 0)
            (t:TVarE) : ensure-no-duplicates(e, 1)
            (t:LVarE) : ensure-no-duplicates(e, 2)
            (t) : false
      defn add (e:Elem) :
         match(type!(n(e))) :
            (t:ValE|VarE|FnE) : add-elem(e, 0)
            (t:TVarE) : add-elem(e, 1)
            (t:LVarE) : add-elem(e, 2)
            (t) : false            
      for e in entries(s) do :
         match(e) :
            (e:Elem) :
               ensure-no-dups(e)
               add(e)
            (e:Group) :
               do(ensure-no-dups, entries(e))
               do(add, entries(e))

   for s in scopes do :
      if top(s) : check-top-scope(s)
      else : check-local-scope(s)
   if not empty?(errors) :
      do(println, errors)
      throw(RenameError())

