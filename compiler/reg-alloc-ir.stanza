defpackage stz/reg-alloc-ir :
  import core
  import collections
  import stz/printing-utils

;============================================================
;==================== IR Definition =========================
;============================================================

;------------------------------------------------------------
;-------------------- Program Model -------------------------
;------------------------------------------------------------

public defstruct Program :
  vars:Tuple<VarDef>
  stmts:Tuple<ProgramStmt>

public defstruct VarDef :
  id:Int
  type:RegisterType
  
public deftype ProgramStmt

public defstruct LabelStmt <: ProgramStmt :
  index:Int

public defstruct OperationStmt <: ProgramStmt :
  op-id:Int
  op-data
  args:Tuple<Int> with: (updater => sub-args)
  results:Tuple<Int>

public defstruct BranchStmt <: ProgramStmt :
  targets:Tuple<Int>

public defstruct GotoStmt <: ProgramStmt :
  target:Int

;Example:
;  (V7, V8, V10) = (V11, V9, V12)
;Arguments and variables must have identical lengths.
public defstruct SetStmt <: ProgramStmt :
  args:Tuple<Int> with: (updater => sub-args)
  results:Tuple<Int>

;------------------------------------------------------------
;-------------------- Operation Model -----------------------
;------------------------------------------------------------

public defstruct OperationModel :
  id:Int
  results:Tuple<ModelVar>
  args:Tuple<ModelVar>
  temp:Tuple<ModelVar>
  stmts:Tuple<ModelStmt>

public defstruct ModelVar :
  id:Int
  location:Location
  preference:Preference

public deftype ModelStmt

public defstruct Release <: ModelStmt :
  id:Int

public defstruct Assign <: ModelStmt :
  id:Int

public defstruct Return <: ModelStmt

public defstruct ClearRegisters <: ModelStmt

;------------------------------------------------------------
;-------------------- Location Specifiers -------------------
;------------------------------------------------------------

public deftype Location <: Hashable & Equalable

public deftype RegisterType <: Location

public deftype Register <: Location

public defstruct AnyReg <: RegisterType
with:
  hashable => true
  equalable => true

public defstruct AnyFReg <: RegisterType
with:
  hashable => true
  equalable => true

public defstruct Reg <: Register :
  index:Int
with:
  hashable => true
  equalable => true
  constructor => #Reg

public defstruct FReg <: Register :
  index:Int
with:
  hashable => true
  equalable => true
  constructor => #FReg

;------------------------------------------------------------
;-------------------- Cached Registers ----------------------
;------------------------------------------------------------

;Holds all the cached Reg and FReg objects.
var REG-CACHE:Tuple<Reg> = []
var FREG-CACHE:Tuple<FReg> = []

;Ensure that the REG-CACHE is at least length n.
defn enlarge-reg-cache (n:Int) -> False :
  val old-len = length(REG-CACHE)
  if n > old-len :
    val new-len = next-pow2(n)
    REG-CACHE = to-tuple $ for i in 0 to new-len seq :
      if i < old-len : REG-CACHE[i]
      else : #Reg(i)

;Ensure that the FREG-CACHE is at least length n.
defn enlarge-freg-cache (n:Int) -> False :
  val old-len = length(FREG-CACHE)
  if n > old-len :
    val new-len = next-pow2(n)
    FREG-CACHE = to-tuple $ for i in 0 to new-len seq :
      if i < old-len : FREG-CACHE[i]
      else : #FReg(i)

;Retrieve the given register.
public defn Reg (index:Int) -> Reg :
  enlarge-reg-cache(index + 1)
  REG-CACHE[index]

;Retrieve the given register.
public defn FReg (index:Int) -> FReg :
  enlarge-freg-cache(index + 1)
  FREG-CACHE[index]

;------------------------------------------------------------
;-------------------- Preference Specifiers -----------------
;------------------------------------------------------------

public deftype Preference

public defstruct PreferSame <: Preference :
  id:Int
with: (printer => true)

public defstruct PreferRegister <: Preference :
  reg:Register
with: (printer => true)

public defstruct NoPreference <: Preference
with: (printer => true)

;------------------------------------------------------------
;--------------------- Internal Usages ----------------------
;------------------------------------------------------------

;Used by annotation pass for an operation.
;- killed-args: Indicates which arguments are no longer live
;  after this operation.
;- result-prefs: Indicates the preferred registers for storing
;  the result. If the results are put in these registers, then
;  downstream code requires less shifting.
;- arg-uses/result-uses: If the argument/result is used again
;  after this operation, what is the next position of their usage?
public defstruct AnnotatedOperationStmt <: ProgramStmt :
  stmt: OperationStmt
  used-registers: UsedRegisters
  killed-args: Tuple<Int>
  arg-uses: Tuple<Int|False>
  result-uses: Tuple<Int|False>
  result-prefs: Tuple<Register|False>

;Used by annotation pass for a set statement.
;- killed-args: Indicates which arguments are no longer live
;  after this operation.
;- result-prefs: Indicates the preferred registers for storing
;  the result. If the results are put in these registers, then
;  downstream code requires less shifting.
;- arg-uses/result-uses: If the argument/result is used again
;  after this operation, what is the next position of their usage?
public defstruct AnnotatedSetStmt <: ProgramStmt :
  stmt: SetStmt
  killed-args: Tuple<Int>
  arg-uses: Tuple<Int|False>
  result-uses: Tuple<Int|False>
  result-prefs: Tuple<Register|False>

;Used by the assignment pass for an operation.
;- arg-regs/result-regs: The final concrete registers that was
;  chosen for the arguments and results.
public defstruct AssignedOperationStmt <: ProgramStmt :
  stmt: OperationStmt
  arg-regs: Tuple<Register>
  temp-regs: Tuple<Register>
  result-regs: Tuple<Register>

;Represents the number of used integer and floating-point
;registers.
;- arg-prefs: The preferred locations of the arguments
;  with respect to the results. 
;- results: The locations of the results of the operation.
public defstruct UsedRegisters :
  used-regs:Int
  used-fregs:Int
  arg-prefs:Tuple<Preference>
with:
  printer => true

;Used by annotation pass to greedily save a result immediately because
;the result is live across a clear-registers operation.
public defstruct Save <: ProgramStmt :
  id:Int
  reg:Location

;Used by annotation pass to greedily unload a result immediately
;because the result is live across a clear-registers operation,
;and not used before then.
public defstruct Unload <: ProgramStmt :
  id:Int

;Used by allocation pass to load a variable from its previously
;saved stack slot.
public defstruct Load <: ProgramStmt :
  id:Int
  reg:Location

;Used by assignment pass to move where a variable is stored.
public defstruct Relocate <: ProgramStmt :
  id:Int
  src:Register
  dst:Register

;============================================================
;==================== Convenience Accessors =================
;============================================================

;Returns the non-specific version of the given location.
public defn type (r:Location) -> RegisterType :
  match(r) :
    (r:Reg|AnyReg) : AnyReg()
    (r:FReg|AnyFReg) : AnyFReg()

;Forward function over to wrapped statement.
#for f in [op-id, args, results] :
  public defn f (s:AnnotatedOperationStmt) :
    f(stmt(s))

;============================================================
;====================== Printers ============================
;============================================================

defmethod print (o:OutputStream, p:Program) :
  val items = [
    named-list-fields("vars", vars(p))
    inline-fields(stmts(p))]
  print(o, named-list-fields("program", items))

defmethod print (o:OutputStream, v:VarDef) :
  print(o, "%_:%_" % [varid(id(v)), type(v)])

defmethod print (o:OutputStream, m:OperationModel) :
  val result-str = "" when empty?(results(m))
              else "(%,) = " % [results(m)]
  val temp-str = "" when empty?(temp(m))
            else " (temp %,)" % [temp(m)]
  print(o, "model %_op%_(%,)%_ %_" % [
    result-str
    id(m)
    args(m)
    temp-str,
    colon-list(stmts(m))])

defmethod print (o:OutputStream, v:ModelVar) :
  val pref-str = match(preference(v)) :
    (pref:NoPreference) : ""
    (pref:PreferSame) : " (prefer-same %_)"  % [varid(id(pref))]
    (pref:PreferRegister) : " (prefer %_)" % [reg(pref)]
  print(o, "%_:%_%_" % [varid(id(v)), location(v), pref-str])

defmethod print (o:OutputStream, s:ProgramStmt) :
  match(s) :
    (s:LabelStmt) :
      print(o, "label %_" % [labelid(index(s))])
    (s:OperationStmt) :
      val result-str = "" when empty?(results(s))
                  else "(%,) = " % [seq(varid,results(s))]
      print(o, "%_op%_(%,)" % [result-str, op-id(s), seq(varid,args(s))])
    (s:BranchStmt) :
      print(o, "branch (%,)" % [seq(labelid, targets(s))])
    (s:GotoStmt) :
      print(o, "goto %_" % [labelid(target(s))])
    (s:SetStmt) :
      print(o, "(%,) = (%,)" % [seq(varid,results(s)), seq(varid,args(s))])
    (s:AnnotatedOperationStmt) :
      val items = [
        simple-field("used-registers", used-registers(s))
        simple-field("killed-args", killed-args(s))
        simple-field("arg-uses", arg-uses(s))
        simple-field("result-uses", result-uses(s))
        simple-field("result-prefs", result-prefs(s))]
      print(o, "%_%_" % [stmt(s), colon-field-list(items)])
    (s:AnnotatedSetStmt) :
      val items = [
        simple-field("killed-args", killed-args(s))
        simple-field("arg-uses", arg-uses(s))
        simple-field("result-uses", result-uses(s))
        simple-field("result-prefs", result-prefs(s))]
      print(o, "%_%_" % [stmt(s), colon-field-list(items)])
    (s:AssignedOperationStmt) :
      val stmt = stmt(s)
      defn str (v:Int, r:Register) : "V%_:%_" % [v,r]
      val result-str = "" when empty?(results(stmt))
                  else "(%,) = " % [seq(str, results(stmt), result-regs(s))]
      val temp-str = "" when empty?(temp-regs(s))
                else " (temp %,)" % [temp-regs(s)]
      val arg-strs = seq(str, args(stmt), arg-regs(s))
      print(o, "%_op%_(%,)%_" % [result-str, op-id(stmt), arg-strs, temp-str])
    (s:Save) :
      print(o, "save %_ from %_" % [varid(id(s)), reg(s)])
    (s:Unload) :
      print(o, "unload %_" % [varid(id(s))])
    (s:Load) :
      print(o, "load %_ into %_" % [varid(id(s)), reg(s)])
    (s:Relocate) :
      print(o, "relocate %_ (%_ => %_)" % [varid(id(s)), src(s), dst(s)])

defmethod print (o:OutputStream, s:ModelStmt) :
  match(s) :
    (s:Assign) :
      print(o, "assign %_" % [varid(id(s))])
    (s:Release) :
      print(o, "release %_" % [varid(id(s))])
    (s:ClearRegisters) :
      print(o, "clear-registers")
    (s:Return) :
      print(o, "return")
    
defmethod print (o:OutputStream, l:Location) :
  print{o, _} $ match(l) :
    (l:AnyReg) : "Rx"
    (l:AnyFReg) : "Fx"
    (l:Reg) : "R%_" % [index(l)]
    (l:FReg) : "F%_" % [index(l)]

defn varid (x:Int) :
  "V%_" % [x]

defn labelid (x:Int) :
  "L%_" % [x]