defpackage stz/reg-alloc-ir :
  import core
  import collections
  import stz/printing-utils

;============================================================
;==================== IR Definition =========================
;============================================================

;------------------------------------------------------------
;-------------------- Program Model -------------------------
;------------------------------------------------------------

public defstruct Program :
  num-vars:Int  
  stmts:Tuple<ProgramStmt>
  
public deftype ProgramStmt

public defstruct LabelStmt <: ProgramStmt :
  index:Int

public defstruct OperationStmt <: ProgramStmt :
  op-id:Int
  op-data
  args:Tuple<Int>
  results:Tuple<Int>

public defstruct BranchStmt <: ProgramStmt :
  targets:Tuple<Int>

public defstruct GotoStmt <: ProgramStmt :
  target:Int

;------------------------------------------------------------
;-------------------- Operation Model -----------------------
;------------------------------------------------------------

public defstruct OperationModel :
  id:Int
  results:Tuple<Int>
  args:Tuple<ModelArg>
  temp:Tuple<Int>
  stmts:Tuple<ModelStmt>

public defstruct ModelArg :
  id:Int
  location:Location

public deftype ModelStmt

public defstruct Release <: ModelStmt :
  arg:Int

public defstruct Assign <: ModelStmt :
  arg:Int
  location:Location
  preference:Preference

public defstruct Return <: ModelStmt

public defstruct ClearRegisters <: ModelStmt

;------------------------------------------------------------
;-------------------- Location Specifiers -------------------
;------------------------------------------------------------

public deftype Location <: Hashable & Equalable

public defstruct AnyReg <: Location
with:
  hashable => true
  equalable => true

public defstruct AnyFReg <: Location
with:
  hashable => true
  equalable => true

public defstruct Reg <: Location :
  index:Int
with:
  hashable => true
  equalable => true

public defstruct FReg <: Location :
  index:Int
with:
  hashable => true
  equalable => true

;------------------------------------------------------------
;-------------------- Preference Specifiers -----------------
;------------------------------------------------------------

public deftype Preference

public defstruct PreferSame <: Preference :
  arg:Int
with: (printer => true)

public defstruct PreferRegister <: Preference :
  reg:Reg|FReg
with: (printer => true)

public defstruct NoPreference <: Preference
with: (printer => true)

;------------------------------------------------------------
;--------------------- Internal Usages ----------------------
;------------------------------------------------------------

;Used by annotation pass for an operation.
;- killed-args: Indicates which arguments are no longer live
;  after this operation.
;- result-prefs: Indicates the preferred registers for storing
;  the result. If the results are put in these registers, then
;  downstream code requires less shifting.
;- arg-uses/result-uses: If the argument/result is used again
;  after this operation, what is the next position of their usage?
public defstruct AnnotatedOperationStmt <: ProgramStmt :
  stmt: OperationStmt
  used-registers: UsedRegisters
  killed-args: Tuple<Int>
  result-prefs: Tuple<Reg|FReg|False>
  arg-uses: Tuple<Int|False>
  result-uses: Tuple<Int|False>

;Used by the assignment pass for an operation.
;- arg-regs/result-regs: The final concrete registers that was
;  chosen for the arguments and results.
public defstruct AssignedOperationStmt <: ProgramStmt :
  stmt: OperationStmt
  arg-regs: Tuple<Reg|FReg>
  temp-regs: Tuple<Reg|FReg>
  result-regs: Tuple<Reg|FReg>

;Represents the number of used integer and floating-point
;registers.
;- arg-prefs: The preferred locations of the arguments
;  with respect to the results. Either PreferSame|NoPreference.
;- results: The locations of the results of the operation.
public defstruct UsedRegisters :
  used-regs:Int
  used-fregs:Int
  arg-prefs:Tuple<Preference>
  results:Tuple<Location>
with:
  printer => true

;Used by annotation pass to greedily save a result immediately because
;the result is live across a clear-registers operation.
public defstruct Save <: ProgramStmt :
  arg:Int

;Used by annotation pass to greedily unload a result immediately
;because the result is live across a clear-registers operation,
;and not used before then.
public defstruct Unload <: ProgramStmt :
  arg:Int

;Used by allocation pass to load a variable from its previously
;saved stack slot.
public defstruct Load <: ProgramStmt :
  arg:Int
  reg:Location

;============================================================
;====================== Printers ============================
;============================================================

defmethod print (o:OutputStream, p:Program) :
  val items = [
    simple-field("num-vars", num-vars(p))
    inline-fields(stmts(p))]
  print(o, named-list-fields("program", items))

defmethod print (o:OutputStream, m:OperationModel) :
  val result-str = "" when empty?(results(m))
              else "(%,) = " % [seq(varid, results(m))]
  val temp-str = "" when empty?(temp(m))
            else " (temp %,)" % [seq(varid, temp(m))]
  print(o, "model %_op%_(%,)%_ %_" % [
    result-str
    id(m)
    args(m)
    temp-str,
    colon-list(stmts(m))])

defmethod print (o:OutputStream, a:ModelArg) :
  print(o, "%_:%_" % [varid(id(a)), location(a)])

defmethod print (o:OutputStream, s:ProgramStmt) :
  match(s) :
    (s:LabelStmt) :
      print(o, "label %_" % [labelid(index(s))])
    (s:OperationStmt) :
      val result-str = "" when empty?(results(s))
                  else "(%,) = " % [seq(varid,results(s))]
      print(o, "%_op%_(%,)" % [result-str, op-id(s), seq(varid,args(s))])
    (s:BranchStmt) :
      print(o, "branch (%,)" % [seq(labelid, targets(s))])
    (s:GotoStmt) :
      print(o, "goto %_" % [labelid(target(s))])
    (s:AnnotatedOperationStmt) :
      val items = [
        simple-field("used-registers", used-registers(s))
        simple-field("killed-args", killed-args(s))
        simple-field("result-prefs", result-prefs(s))
        simple-field("arg-uses", arg-uses(s))
        simple-field("result-uses", result-uses(s))]
      print(o, "%_%_" % [stmt(s), colon-field-list(items)])
    (s:AssignedOperationStmt) :
      val items = [
        simple-field("arg-regs", arg-regs(s))
        simple-field("temp-regs", temp-regs(s))
        simple-field("result-regs", result-regs(s))]
      print(o, "%_%_" % [stmt(s), colon-field-list(items)])
    (s:Save) :
      print(o, "save %_" % [varid(arg(s))])
    (s:Unload) :
      print(o, "unload %_" % [varid(arg(s))])
    (s:Load) :
      print(o, "load %_ into %_" % [varid(arg(s)), reg(s)])

defmethod print (o:OutputStream, s:ModelStmt) :
  match(s) :
    (s:Assign) :
      val pref-str = match(preference(s)) :
        (pref:NoPreference) : ""
        (pref:PreferSame) : " prefer-same-as %_"  % [varid(arg(pref))]
        (pref:PreferRegister) : " prefer %_" % [reg(pref)]
      print(o, "assign %_ to %_%_" % [location(s), varid(arg(s)), pref-str])
    (s:Release) :
      print(o, "release %_" % [varid(arg(s))])
    (s:ClearRegisters) :
      print(o, "clear-registers")
    (s:Return) :
      print(o, "return")
    
defmethod print (o:OutputStream, l:Location) :
  print{o, _} $ match(l) :
    (l:AnyReg) : "Rx"
    (l:AnyFReg) : "Fx"
    (l:Reg) : "R%_" % [index(l)]
    (l:FReg) : "F%_" % [index(l)]

defn varid (x:Int) :
  "V%_" % [x]

defn labelid (x:Int) :
  "L%_" % [x]