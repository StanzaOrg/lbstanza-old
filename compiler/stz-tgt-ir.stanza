defpackage stz/tgt-ir :
   import core
   import collections
   import stz/ids

;                 Operator Definition
;                 ===================

public deftype TgtOp <: Equalable
public defmulti id (n:TgtOp) -> Int

defmethod equal? (a:TgtOp, b:TgtOp) :
   id(a) == id(b)

defn SimpleTgtOp (name:Symbol) :
   val id = fresh-id()
   new TgtOp :
      defmethod id (this) : id
      defmethod print (o:OutputStream, this) : print(o, name)
   
public val ADD-OP = SimpleTgtOp(`ADD)
public val SUB-OP = SimpleTgtOp(`SUB)
public val MUL-OP = SimpleTgtOp(`MUL)
public val DIV-OP = SimpleTgtOp(`DIV)
public val MOD-OP = SimpleTgtOp(`MOD)
public val AND-OP = SimpleTgtOp(`AND)
public val OR-OP = SimpleTgtOp(`OR)
public val XOR-OP = SimpleTgtOp(`XOR)
public val SHL-OP = SimpleTgtOp(`SHL)
public val SHR-OP = SimpleTgtOp(`SHR)
public val ASHR-OP = SimpleTgtOp(`ASHR)
public val EQ-OP = SimpleTgtOp(`EQ)
public val NE-OP = SimpleTgtOp(`NE)
public val LT-OP = SimpleTgtOp(`LT)
public val GT-OP = SimpleTgtOp(`GT)
public val LE-OP = SimpleTgtOp(`LE)
public val GE-OP = SimpleTgtOp(`GE)
public val ULE-OP = SimpleTgtOp(`ULE)
public val ULT-OP = SimpleTgtOp(`ULT)
public val UGT-OP = SimpleTgtOp(`UGT)
public val UGE-OP = SimpleTgtOp(`UGE)
public val NOT-OP = SimpleTgtOp(`NOT)
public val NEG-OP = SimpleTgtOp(`NEG)

;Specific Instruction Groups
public val SWITCH-STACK-OP = SimpleTgtOp(`switch-stack)
public val STACK-HAS-SPACE = SimpleTgtOp(`stack-has-space)
public val RESTORE-RSP = SimpleTgtOp(`restore-rsp)

public deftype ArityNEqOp <: TgtOp
public defmulti arity (o:ArityNEqOp) -> Int
public defn ArityNEqOp (arity:Int) :
   val id = fresh-id()
   new ArityNEqOp :
      defmethod id (this) : id
      defmethod arity (this) : arity
      defmethod print (o:OutputStream, this) :
         print(o, "ARITY_NEQ(%~)" % [arity])   

;               Backend Specific Operators
;               ==========================

public val DIVMOD-OP = SimpleTgtOp(`DIVMOD)
public val NO-OP = SimpleTgtOp(`NOP)
public val CONV-OP = SimpleTgtOp(`CONV)
public val INTERPRET-OP = SimpleTgtOp(`INTER)

public deftype LoadOp <: TgtOp
public defmulti offset (o:LoadOp) -> Int
public defn LoadOp (offset:Int) :
   val id = fresh-id()
   new LoadOp :
      defmethod id (this) : id
      defmethod offset (this) : offset
      defmethod print (o:OutputStream, this) :
         print(o, "LOAD(%~)" % [offset])


public deftype StoreOp <: TgtOp
public defmulti offset (o:StoreOp) -> Int
public defn StoreOp (offset:Int) :
   val id = fresh-id()
   new StoreOp :
      defmethod id (this) : id
      defmethod offset (this) : offset
      defmethod print (o:OutputStream, this) :
         print(o, "STORE(%~)" % [offset])


public deftype AddrOp <: TgtOp
public defmulti n (o:AddrOp) -> Int
public defn AddrOp (n:Int) :
   val id = fresh-id()
   new AddrOp :
      defmethod id (this) : id
      defmethod n (this) : n
      defmethod print (o:OutputStream, this) :
         print(o, "ADDR(%~)" % [n])



;                    Type Definition
;                    ===============

public defstruct TgtType <: Equalable :
   id: Int
   name: Symbol
   int?: True|False
   
defmethod equal? (a:TgtType, b:TgtType) :
   id(a) == id(b)

defn TgtType (name:Symbol, int?:True|False) :
   TgtType(fresh-id(), name, int?)
public val BYTE-TYPE = TgtType(`BYTE, true)
public val INT-TYPE = TgtType(`INT, true)
public val LONG-TYPE = TgtType(`LONG, true)
public val FLOAT-TYPE = TgtType(`FLOAT, false)
public val DOUBLE-TYPE = TgtType(`DOUBLE, false)
public val REF-TYPE = TgtType(`REF, true)

public defn float? (t:TgtType) :
   not int?(t)

public defn size (t:TgtType) :
   switch {t == _} :
      BYTE-TYPE : 1
      INT-TYPE : 4
      LONG-TYPE : 8
      FLOAT-TYPE : 4
      DOUBLE-TYPE : 8
      REF-TYPE : 8

public defn IntType (size:Int) :
   switch {size == _} :
      1 : BYTE-TYPE
      4 : INT-TYPE
      8 : LONG-TYPE
      
public defn ref-mask (ts:Seqable<TgtType>) :
   val mask = Vector<True|False>()
   var accum = 0
   for t in ts do :
      accum = accum + size(t)
      if accum % 8 == 0 :
         add(mask, t == REF-TYPE)
   mask

public defn to-bitmask (xs:Seqable<True|False>) -> List<Long> :
   val sxs = to-seq(xs)
   val zero = to-long(0)
   defn bit (x:True|False) :
      to-long(1 when x else 0)
   defn loop (accum:Long, len:Int) :
      if len == 64 : cons(accum, loop(zero, 0))
      else if not empty?(sxs) : loop(accum + bit(next(sxs)) << to-long(len), len + 1)
      else if len > 0 : List(accum)
      else : List()
   loop(zero, 0)

;                      Immediates
;                      ==========

public deftype Imm
public defstruct ByteImm <: Imm :
   value:Byte
public defstruct IntImm <: Imm :
   value:Int
public defstruct LongImm <: Imm :
   value:Long
public defstruct RSP <: Imm
public defstruct Var <: Imm :
   n:Int
public defstruct Mem <: Imm :
   n:Int
   offset: Int
public defstruct ExMem <: Imm :
   name:Symbol
   offset: Int

;                Instruction Definition
;                ======================

public deftype Ins
public defstruct ArgsIns <: Ins :
   xs: List<Var>
public defstruct Return <: Ins :
   xs: List<Imm>
public defstruct CArgsIns <: Ins :
   xs: List<Var>
public defstruct CReturn <: Ins :
   xs: List<Imm>
public defstruct SetIns <: Ins :
   x: Var
   y: Imm
public defstruct ConvertIns <: Ins :
   x: Var
   y: Imm
public defstruct InterpretIns <: Ins :
   x: Var
   y: Imm
public defstruct BinOp <: Ins :
   x: Var
   op: TgtOp
   y: Imm
   z: Imm
public defstruct UnaOp <: Ins :
   x: Var
   op: TgtOp
   y: Imm
public defstruct Load <: Ins :
   x: Var
   y: Imm
   offset: Int
public defstruct Store <: Ins :
   x: Imm
   y: Imm
   offset: Int
public defstruct Addr <: Ins :
   x: Var
   n: Int
public defstruct Call <: Ins :
   arity: Int
   xs: List<Var>
   f: Imm
   ys: List<Imm>
   new-stack?: True|False
   info: False|FileInfo
public defstruct CallStack <: Ins :
   xs: List<Var>
   f: Imm
   ys: List<Imm>
   info: False|FileInfo
public defstruct TCall <: Ins :
   arity: Int
   f: Imm
   ys: List<Imm>
   new-stack?: True|False
public defstruct TCallStack <: Ins :
   f: Imm
   ys: List<Imm>
public defstruct CallC <: Ins :
   n: Int
   xs: List<Var>
   f: Imm
   ys: List<Imm>
public defstruct Label <: Ins :
   n:Int
public defstruct Goto <: Ins :
   n:Int
public defstruct Branch <: Ins :
   n: Int
   op: TgtOp
   x: Imm
   y: Imm
public defstruct SpecialBranch <: Ins :
   n: Int
   op: TgtOp
public defstruct SpecialOp <: Ins :
   op: TgtOp


;                   Global Definitions
;                   ==================

;     Structural Instructions
;     -----------------------
public deftype DefIns 
public defstruct DefFn <: DefIns :
   n: Int
   defs: Vector<DefVar>
   body: Vector<Ins>

public defstruct DefVar :
   n: Int
   type: TgtType

;     Data Instructions
;     -----------------
public defstruct DefData <: DefIns
public defstruct DefText <: DefIns
public defstruct DefByte <: DefIns :
   value: Byte
public defstruct DefInt <: DefIns :
   value: Int
public defstruct DefLong <: DefIns :
   value: Long
public defstruct DefFloat <: DefIns :
   value: Float
public defstruct DefDouble <: DefIns :
   value: Double
public defstruct DefString <: DefIns :
   value: String
public defstruct DefSpace <: DefIns :
   size: Int
public defstruct DefLabel <: DefIns :
   n: Int
public defstruct TLabel <: DefIns :
   n: Int

;     Program
;     -------
public defstruct Program :
   ins: Vector<DefIns>
   entry: Int

;                    Constructors
;                    ============

public defn CallC (xs: List<Var>, f: Imm, ys: List<Imm>) :
   CallC(0, xs, f, ys)

;                      Printer
;                      =======

defn cms (xs) : join(xs, ", ")

defmethod print (o:OutputStream, p:Program) :
   val io = IndentedStream(o,3)
   print(o, "program(%~) :" % [entry(p)])
   for i in ins(p) do :
      print(io, "\n%~" % [i])

defmethod print (o:OutputStream, t:TgtType) :
   print(o, name(t))

defmethod print (o:OutputStream, i:Imm) :
   print{o, _} $ match(i) :
      (i:IntImm) : "int(%~)" % [value(i)]
      (i:ByteImm) : "byte(%~)" % [value(i)]
      (i:LongImm) : "long(%~)" % [value(i)]
      (i:RSP) : "RSP"
      (i:Var) : "V%~" % [n(i)]
      (i:Mem) : "M%~(%~)" % [n(i), offset(i)]
      (i:ExMem) : "M(%~ + %~)" % [name(i), offset(i)]

defmethod print (o:OutputStream, i:Ins) :
   defn star? (x:True|False) : "*" when x else ""
   print{o, _} $ match(i) :
      (i:ArgsIns) : "(%,) = Args" % [xs(i)]
      (i:CArgsIns) : "(%,) = CArgs" % [xs(i)]
      (i:CReturn) : "creturn (%,)" % [xs(i)]   
      (i:SetIns) : "%~ = %~" % [x(i), y(i)]         
      (i:ConvertIns) : "%~ = convert %~" % [x(i), y(i)]
      (i:InterpretIns) : "%~ = interpret %~" % [x(i), y(i)]
      (i:BinOp) : "%~ = %~(%~, %~)" % [x(i), op(i), y(i), z(i)]
      (i:UnaOp) : "%~ = %~(%~)" % [x(i), op(i), y(i)]
      (i:Load) : "%~ = [%~ + %~]" % [x(i), y(i), offset(i)]
      (i:Store) : "[%~ + %~] = %~" % [x(i), offset(i), y(i)]
      (i:Addr) : "%~ = addr(%~)" % [x(i), n(i)]
      (i:Call) : "(%*) = call%_ %~(%*) / %~ @ %~" % [
         cms(xs(i)), star?(new-stack?(i)), f(i), cms(ys(i)), arity(i), info(i)]
      (i:CallStack) : "(%*) = call stack %~(%*) @ %~" % [
         cms(xs(i)), f(i), cms(ys(i)), info(i)]
      (i:TCall) : "tcall%_ %~(%*) / %~" % [
         star?(new-stack?(i)), f(i), cms(ys(i)), arity(i)]
      (i:TCallStack) : "tcall stack %~(%*)" % [f(i), cms(ys(i))]
      (i:CallC) : "(%*) = callc %~(%*)" % [cms(xs(i)), f(i), cms(ys(i))]
      (i:Return) : "return (%*)" % [cms(xs(i))]
      (i:Label) : "label %~" % [n(i)]
      (i:Goto) : "goto %~" % [n(i)]
      (i:Branch) : "branch %~ when %~(%~, %~)" % [n(i), op(i), x(i), y(i)]
      (i:SpecialBranch) : "branch* %~ when %~" % [n(i), op(i)]
      (i:SpecialOp) : op(i)
   
defmethod print (o:OutputStream, v:DefVar) :
   print(o, "V%~:%~" % [n(v), type(v)])

defmethod print (o:OutputStream, i:DefIns) :
   match(i) :
      (i:DefFn) :
         val io = IndentedStream(o, 3)
         print(o, "function F%~ :" % [n(i)])
         print(o, "\ndefs :")
         for d in defs(i) do :
            print(io, "\n%~" % [d])
         print(o, "\nbody :")
         for b in body(i) do :
            print(io, "\n%~" % [b])
      (i:DefData) : print(o, "   .data")
      (i:DefText) : print(o, "   .text")
      (i:DefByte) : print(o, "   .byte %~" % [value(i)])
      (i:DefInt) : print(o, "   .int %~" % [value(i)])
      (i:DefLong) : print(o, "   .long %~" % [value(i)])
      (i:DefFloat) : print(o, "   .float %~" % [value(i)])
      (i:DefDouble) : print(o, "   .double %~" % [value(i)])
      (i:DefString) : print(o, "   .string %~" % [value(i)])
      (i:DefSpace) : print(o, "   .space %~" % [size(i)])
      (i:DefLabel) : print(o, "   .label L<%~>" % [n(i)])
      (i:TLabel) : print(o, "label %~" % [n(i)])