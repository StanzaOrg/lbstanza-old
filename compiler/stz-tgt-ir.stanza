defpackage stz/tgt-ir :
   import core
   import verse

val id-counter = to-stream(0 to false)

;                 Operation Definition
;                 ====================

public defstruct TgtOp :
   id: Int
   name: Symbol

defmethod equal? (a:TgtOp, b:TgtOp) :
   id(a) == id(b)

defn TgtOp (name:Symbol) : TgtOp(next(id-counter), name)
public val ADD-OP = TgtOp(`ADD)
public val SUB-OP = TgtOp(`SUB)
public val MUL-OP = TgtOp(`MUL)
public val DIV-OP = TgtOp(`DIV)
public val MOD-OP = TgtOp(`MOD)
public val AND-OP = TgtOp(`AND)
public val OR-OP = TgtOp(`OR)
public val XOR-OP = TgtOp(`XOR)
public val SHL-OP = TgtOp(`SHL)
public val SHR-OP = TgtOp(`SHR)
public val ASHR-OP = TgtOp(`ASHR)
public val EQ-OP = TgtOp(`EQ)
public val NE-OP = TgtOp(`NE)
public val LT-OP = TgtOp(`LT)
public val GT-OP = TgtOp(`GT)
public val LE-OP = TgtOp(`LE)
public val GE-OP = TgtOp(`GE)
public val ULE-OP = TgtOp(`ULE)
public val ULT-OP = TgtOp(`ULT)
public val UGT-OP = TgtOp(`UGT)
public val UGE-OP = TgtOp(`UGE)


;                    Type Definition
;                    ===============

public defstruct TgtType :
   id: Int
   name: Symbol
   
defmethod equal? (a:TgtType, b:TgtType) :
   id(a) == id(b)

defn TgtType (name:Symbol) : TgtType(next(id-counter), name)   
public val BYTE-TYPE = TgtType(`BYTE)
public val INT-TYPE = TgtType(`INT)
public val LONG-TYPE = TgtType(`LONG)
public val FLOAT-TYPE = TgtType(`FLOAT)
public val DOUBLE-TYPE = TgtType(`DOUBLE)
public val REF-TYPE = TgtType(`REF)


;                      Immediates
;                      ==========

public definterface Imm
public defstruct ByteImm <: Imm :
   value:Int
public defstruct IntImm <: Imm :
   value:Int
public defstruct LongImm <: Imm :
   value:Int
public defstruct FloatImm <: Imm :
   value:Float
public defstruct DoubleImm <: Imm :
   value:Float
public defstruct Var <: Imm :
   name: Symbol
public defstruct Mem <: Imm :
   name: Symbol

;                Instruction Definition
;                ======================

public definterface Ins
public defstruct SetIns <: Ins :
   x: Var
   y: Imm
public defstruct ConvertIns <: Ins :
   x: Var
   y: Imm
   signed?: True|False
public defstruct BinOp <: Ins :
   x: Var
   op: TgtOp
   y: Imm
   z: Imm
public defstruct Load <: Ins :
   x: Var
   y: Imm
   offset: Int
public defstruct Store <: Ins :
   x: Imm
   y: Imm
   offset: Int
public defstruct Addr <: Ins :
   x: Var
   y: Imm
   offset: Int
public defstruct Call <: Ins :
   arity: Int
   xs: List<Var>
   f: Imm
   ys: List<Imm>
public defstruct TCall <: Ins :
   arity: Int
   f: Imm
   ys: List<Imm>
public defstruct Return <: Ins :
   xs: List<Imm>
public defstruct Label <: Ins :
   name: Symbol
public defstruct Goto <: Ins :
   name: Symbol
public defstruct Branch <: Ins :
   name: Symbol
   op: TgtOp
   x: Imm
   y: Imm


;                   Global Definitions
;                   ==================

public definterface DefIns 
public defstruct DefFn <: DefIns :
   name: Symbol
   arity: Int
   args: List<DefVar>
   locals: Vector<DefVar>
   body: Vector<Ins>

public defstruct DefVar :
   name: Symbol
   type: TgtType

public defstruct Program :
   ins: Vector<DefIns>
   entry: Symbol


;                      Printer
;                      =======

defmethod print (o:OutputStream, p:Program) :
   val io = IndentedStream(o,3)
   print(o, "program(~) :" << [entry(p)])   
   for i in ins(p) do :
      print(io, "\n~" << [i])

defmethod print (o:OutputStream, op:TgtOp) :
   print(o, name(op))

defmethod print (o:OutputStream, t:TgtType) :
   print(o, name(t))

defmethod print (o:OutputStream, i:Imm) :
   print{o, _} $ match(i) :
      (i:Int) : "int(~)" << [value(i)]
      (i:Byte) : "byte(~)" << [value(i)]
      (i:Long) : "long(~)" << [value(i)]
      (i:Float) : "float(~)" << [value(i)]
      (i:Double) : "double(~)" << [value(i)]
      (i:Var) : name(i)
      (i:Mem) : "mem<~>" << [name(i)]

defmethod print (o:OutputStream, i:Ins) :
   print{o, _} $ match(i) :
      (i:SetIns) : "~ = ~" << [x(i), y(i)]         
      (i:ConvertIns) : "~ = convert ~ (~)" << [
         x(i),
         y(i),
         "S" when signed?(i) else "U"]
      (i:BinOp) : "~ = ~(~, ~)" << [x(i), op(i), y(i), z(i)]
      (i:Load) : "~ = [~ + ~]" << [x(i), y(i), offset(i)]
      (i:Store) : "[~ + ~] = ~" << [x(i), offset(i), y(i)]
      (i:Addr) : "~ = addr(~) + ~" << [x(i), y(i), offset(i)]
      (i:Call) : "(~@) = call ~ (~@)" << [cms(xs(i)), f(i), cms(ys(i))]
      (i:TCall) : "tcall ~ (~@)" << [f(i), cms(ys(i))]
      (i:Return) : "return (~@)" << [cms(xs(i))]
      (i:Label) : "label ~" << [name(i)]
      (i:Goto) : "goto ~" << [name(i)]
      (i:Branch) : "branch ~ when ~(~, ~)" << [name(i), op(i), x(i), y(i)]
   
defmethod print (o:OutputStream, v:DefVar) :
   print(o, "~:~" << [name(v), type(v)])

defmethod print (o:OutputStream, i:DefIns) :
   match(i) :
      (i:DefFn) :
         val io = IndentedStream(o, 3)
         print(o, "function/~ ~ (~@) :" << [arity(i), name(i), cms(args(i))])
         print(io, "\nlocals: (~@)" << [cms(locals(i))])
         for bi in body(i) do :
            print(io, "\n~" << [bi])
         