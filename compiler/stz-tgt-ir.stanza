defpackage stz/tgt-ir :
   import core
   import verse

val id-counter = to-stream(0 to false)

;                 Operation Definition
;                 ====================

public defstruct TgtOp :
   id: Int
   name: Symbol

defmethod equal? (a:TgtOp, b:TgtOp) :
   id(a) == id(b)

defn TgtOp (name:Symbol) : TgtOp(next(id-counter), name)
public val ADD-OP = TgtOp(`ADD)
public val SUB-OP = TgtOp(`SUB)
public val MUL-OP = TgtOp(`MUL)
public val DIV-OP = TgtOp(`DIV)
public val MOD-OP = TgtOp(`MOD)
public val AND-OP = TgtOp(`AND)
public val OR-OP = TgtOp(`OR)
public val XOR-OP = TgtOp(`XOR)
public val SHL-OP = TgtOp(`SHL)
public val SHR-OP = TgtOp(`SHR)
public val ASHR-OP = TgtOp(`ASHR)
public val EQ-OP = TgtOp(`EQ)
public val NE-OP = TgtOp(`NE)
public val LT-OP = TgtOp(`LT)
public val GT-OP = TgtOp(`GT)
public val LE-OP = TgtOp(`LE)
public val GE-OP = TgtOp(`GE)
public val ULE-OP = TgtOp(`ULE)
public val ULT-OP = TgtOp(`ULT)
public val UGT-OP = TgtOp(`UGT)
public val UGE-OP = TgtOp(`UGE)


;                    Type Definition
;                    ===============

public defstruct TgtType :
   id: Int
   name: Symbol
   int?: True|False
   
defmethod equal? (a:TgtType, b:TgtType) :
   id(a) == id(b)

defn TgtType (name:Symbol, int?:True|False) :
   TgtType(next(id-counter), name, int?)
public val BYTE-TYPE = TgtType(`BYTE, true)
public val INT-TYPE = TgtType(`INT, true)
public val LONG-TYPE = TgtType(`LONG, true)
public val FLOAT-TYPE = TgtType(`FLOAT, false)
public val DOUBLE-TYPE = TgtType(`DOUBLE, false)
public val REF-TYPE = TgtType(`REF, true)

public defn float? (t:TgtType) :
   not int?(t)


;                      Immediates
;                      ==========

public definterface Imm
public defstruct ByteImm <: Imm :
   value:Int
public defstruct IntImm <: Imm :
   value:Int
public defstruct LongImm <: Imm :
   value:Int
public defstruct Var <: Imm :
   n:Int
public defstruct Mem <: Imm :
   n:Int

;                Instruction Definition
;                ======================

public definterface Ins
public defstruct SetIns <: Ins :
   x: Var
   y: Imm
public defstruct ConvertIns <: Ins :
   x: Var
   y: Imm
   signed?: True|False
public defstruct BinOp <: Ins :
   x: Var
   op: TgtOp
   y: Imm
   z: Imm
public defstruct Load <: Ins :
   x: Var
   y: Imm
   offset: Int
public defstruct Store <: Ins :
   x: Imm
   y: Imm
   offset: Int
public defstruct Addr <: Ins :
   x: Var
   y: Imm
   offset: Int
public defstruct Call <: Ins :
   arity: Int
   xs: List<Var>
   f: Imm
   ys: List<Imm>
public defstruct TCall <: Ins :
   arity: Int
   f: Imm
   ys: List<Imm>
public defstruct Return <: Ins :
   xs: List<Imm>
public defstruct Label <: Ins :
   n:Int
public defstruct Goto <: Ins :
   n:Int
public defstruct Branch <: Ins :
   n:Int
   op: TgtOp
   x: Imm
   y: Imm


;                   Global Definitions
;                   ==================

;     Structural Instructions
;     -----------------------
public definterface DefIns 
public defstruct DefFn <: DefIns :
   n: Int
   arity: Int
   args: List<DefVar>
   locals: Vector<DefVar>
   body: Vector<Ins>

public defstruct DefVar :
   n: Int
   type: TgtType

;     Data Instructions
;     -----------------
public defstruct DefData <: DefIns
public defstruct DefText <: DefIns
public defstruct DefByte <: DefIns :
   value: Int
public defstruct DefInt <: DefIns :
   value: Int
public defstruct DefLong <: DefIns :
   value: Int
public defstruct DefFloat <: DefIns :
   value: Float
public defstruct DefDouble <: DefIns :
   value: Float
public defstruct DefString <: DefIns :
   value: String
public defstruct DefSpace <: DefIns :
   size: Int
public defstruct DefLabel <: DefIns :
   n: Int

;     Program
;     -------
public defstruct Program :
   ins: Vector<DefIns>
   entry: Int


;                      Printer
;                      =======

defn cms (xs) : join(xs, ", ")

defmethod print (o:OutputStream, p:Program) :
   val io = IndentedStream(o,3)
   print(o, "program(~) :" << [entry(p)])   
   for i in ins(p) do :
      print(io, "\n~" << [i])

defmethod print (o:OutputStream, op:TgtOp) :
   print(o, name(op))

defmethod print (o:OutputStream, t:TgtType) :
   print(o, name(t))

defmethod print (o:OutputStream, i:Imm) :
   print{o, _} $ match(i) :
      (i:IntImm) : "int(~)" << [value(i)]
      (i:ByteImm) : "byte(~)" << [value(i)]
      (i:LongImm) : "long(~)" << [value(i)]
      (i:Var) : "V~" << [n(i)]
      (i:Mem) : "M~" << [n(i)]

defmethod print (o:OutputStream, i:Ins) :
   print{o, _} $ match(i) :
      (i:SetIns) : "~ = ~" << [x(i), y(i)]         
      (i:ConvertIns) : "~ = convert ~ (~)" << [
         x(i),
         y(i),
         "S" when signed?(i) else "U"]
      (i:BinOp) : "~ = ~(~, ~)" << [x(i), op(i), y(i), z(i)]
      (i:Load) : "~ = [~ + ~]" << [x(i), y(i), offset(i)]
      (i:Store) : "[~ + ~] = ~" << [x(i), offset(i), y(i)]
      (i:Addr) : "~ = addr(~) + ~" << [x(i), y(i), offset(i)]
      (i:Call) : "(~@) = call ~(~@) / ~" << [cms(xs(i)), f(i), cms(ys(i)), arity(i)]
      (i:TCall) : "tcall ~(~@) / ~" << [f(i), cms(ys(i)), arity(i)]
      (i:Return) : "return (~@)" << [cms(xs(i))]
      (i:Label) : "label ~" << [n(i)]
      (i:Goto) : "goto ~" << [n(i)]
      (i:Branch) : "branch ~ when ~(~, ~)" << [n(i), op(i), x(i), y(i)]
   
defmethod print (o:OutputStream, v:DefVar) :
   print(o, "V~:~" << [n(v), type(v)])

defmethod print (o:OutputStream, i:DefIns) :
   match(i) :
      (i:DefFn) :
         val io = IndentedStream(o, 3)
         print(o, "function/~ F~ (~@) :" << [arity(i), n(i), cms(args(i))])
         print(io, "\nlocals: (~@)" << [cms(locals(i))])
         for bi in body(i) do :
            print(io, "\n~" << [bi])
      (i:DefData) : print(o, "   .data")
      (i:DefText) : print(o, "   .text")
      (i:DefByte) : print(o, "   .byte ~" << [value(i)])
      (i:DefInt) : print(o, "   .int ~" << [value(i)])
      (i:DefLong) : print(o, "   .long ~" << [value(i)])
      (i:DefFloat) : print(o, "   .float ~" << [value(i)])
      (i:DefDouble) : print(o, "   .double ~" << [value(i)])
      (i:DefString) : print(o, "   .string ~" << [value(i)])
      (i:DefSpace) : print(o, "   .space ~" << [size(i)])
      (i:DefLabel) : print(o, "   .label L<~>" << [n(i)])