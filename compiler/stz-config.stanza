;See License.txt for details about licensing.

defpackage stz/config :
  import core
  import collections
  import reader
  import parser
  import stz/params

;============================================================
;================ Configuration Syntax ======================
;============================================================

defsyntax stanza-config :
  defn ut (x) : unwrap-token(x)

  defn PE (info:False|FileInfo, msg) :
    match(info) :
      (info:FileInfo) : Exception("%_: %_" % [info, msg])
      (info:False) : Exception(msg)

  defproduction sym: Symbol
  defrule sym = (?x) when ut(x) is Symbol : ut(x)
  
  defproduction string: String
  defrule string = (?x) when ut(x) is String : ut(x)

  defproduction string!: String
  defrule string! = (?s:#string) : s
  fail-if string! = () : PE(closest-info(), "Expected a string here.")

  defproduction long: Long
  defrule long = (?x) when ut(x) is Long : ut(x)

  defproduction long!: Long
  defrule long! = (?s:#long) : s
  fail-if long! = () : PE(closest-info(), "Expected a long here.")

  defproduction bool! : True|False
  defrule bool! = (?v) when unwrap-token(v) is True|False : unwrap-token(v)
  fail-if bool! = () : PE(closest-info(), "Expected a bool here.")

  defproduction platform!: Symbol
  defrule platform! = (?x:#sym) :
    try :
      ensure-supported-platform(x),
      x
    catch (e:Exception) :
      throw(PE(closest-info(), e))
  fail-if platform! = () :
    PE(closest-info(), "Expected a platform here.")

  public defproduction entry: False
  defrule entry = (install-dir = ?path:#string!) :
    STANZA-INSTALL-DIR = substitute-env-vars(closest-info(), path)
  defrule entry = (platform = ?p:#platform!) :
    OUTPUT-PLATFORM = p
  defrule entry = (pkg-dirs = (?paths:#string ...)) :
    val paths* = for p in paths map : substitute-env-vars(closest-info(), p)
    STANZA-PKG-DIRS = append(paths*, STANZA-PKG-DIRS)
  defrule entry = (proj-files = (?paths:#string ...)) :
    val paths* = for p in paths map : substitute-env-vars(closest-info(), p)
    add-all(STANZA-PROJ-FILES, paths*)
  defrule entry = (compiler-max-heap-size = ?sz:#long!) :
    val cur-heap = current-heap-size()
    if sz < current-heap-size() :
      val msg = "Cannot set maximum heap size to be smaller than default heap size (%_)."
      throw(PE(closest-info(), msg % [cur-heap]))
    STANZA-MAX-COMPILER-HEAP-SIZE = sz
  defrule entry = (experimental = ?b:#bool!) :
    EXPERIMENTAL = b
  fail-if entry = () :
    PE(closest-info(), "Invalid configuration rule.")

;============================================================
;================ Read Configuration File ===================
;============================================================

var STANZA-CONFIGURED? = false
public defn read-config-file () :
  if not STANZA-CONFIGURED? :
    ;Extract parameters from config file
    label<False> break :
      defn extract-from-file (filename:String) :
        if file-exists?(filename) :
          val forms = read-file(filename)
          parse-syntax[stanza-config / #entry ...](forms)
          break(false)

      defn extract-from-env (name:String) :
        match(get-env(name)) :
          (path:String) : extract-from-file(norm-path("%_/.stanza" % [path]))
          (path:False) : false

      extract-from-file(".stanza")
      extract-from-env("STANZA_CONFIG")
      extract-from-env("HOME")
      throw(Exception("Could not locate .stanza configuration file."))

    ;Verify parameters
    val license-file = norm-path("%_/License.txt" % [STANZA-INSTALL-DIR])
    if not file-exists?(license-file) :
      val msg = "Stanza install directory is set to %_, \
                 but could not locate license file at %_."
      throw $ Exception(msg % [STANZA-INSTALL-DIR, license-file])

    ;Set configured to true
    STANZA-CONFIGURED? = true

;============================================================
;============= Environment Variable Substitution ============
;============================================================
defn substitute-env-vars (info:FileInfo|False, s:String) -> String :
  within name = sub-curly(s) :
    match(get-env(name)) :
      (v:String) : v
      (f:False) : throw(EnvSubstitutionError(info,name))

defn sub-curly (f:String -> String, s:String) -> String :
  if index-of-char(s, '{') is False :
    s
  else :
    val buffer = StringBuffer()

    ;Iterate through the curlies
    let loop (start:Int = 0) :
      ;Determine curly bounds
      val [i, j] = let :
        val i = index-of-char(s, start to false, '{')
        match(i:Int) :
          [i, index-of-char(s, (i + 1) to false, '}')]
        else : [i, false]
      ;If there is a curly
      match(i:Int, j:Int) :
        ;Add string up to curly
        if start < i :
          add-all(buffer, s[start to i])
        ;Add replacement
        val replacement = f(s[(i + 1) through (j - 1)])
        add-all(buffer, replacement)
        ;Continue past } char
        loop(j + 1)
      else :
        ;End of string, add the rest
        if start < length(s) :
          add-all(buffer, s[start to false])

    ;Return spliced string
    to-string(buffer)

;============================================================
;====================== Errors ==============================
;============================================================

defstruct EnvSubstitutionError <: Exception :
  info:FileInfo|False
  name:String
  
defmethod print (o:OutputStream, e:EnvSubstitutionError) :
  val msg = "%_Could not determine value of environment variable %_."
  print(o, msg % [info-str(info(e)), name(e)])

defn info-str (info:FileInfo|False) :
  "" when info is False else "%_: " % [info]
