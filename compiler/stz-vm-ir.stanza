defpackage stz/vm-ir :
  import core
  import collections
  import reader
  import stz/dl-ir
  import stz/utils
  import stz/basic-ops
  import stz/typeset
  import core/stack-trace

;============================================================
;=================== Special Identifiers ====================
;============================================================

public val FALSE-TYPE = 0
public val TRUE-TYPE = 1
public val BYTE-TYPE = 2
public val CHAR-TYPE = 3
public val INT-TYPE = 4
public val FLOAT-TYPE = 5
public val STACK-TYPE = 6
public val FN-TYPE = 7
public val TYPE-TYPE = 8
public val LIVENESS-TRACKER-TYPE = 9
public val NUM-BUILTIN-CONCRETE-TYPES = 10
public val UNIQUE-TYPE = 10
public val NUM-BUILTIN-TYPES = 11

public val EXTEND-HEAP-FN = 0
public val EXTEND-STACK-FN = 1
public val INIT-CONSTS-FN = 2
public val EXECUTE-TOPLEVEL-COMMAND-FN = 3
public val NUM-BUILTIN-FNS = 4

;============================================================
;================== Design of Instructions ==================
;============================================================

public defstruct VMPackage :
  packageio: PackageIO
  init: Int|False
  globals: Tuple<VMGlobal> with: (updater => sub-globals)
  datas: Tuple<VMData> with: (updater => sub-datas)
  consts: Tuple<VMConst>
  classes: Tuple<VMClass>
  funcs: Tuple<VMDefn> with: (updater => sub-funcs)
  methods: Tuple<VMMethod>
  externs: Tuple<VMExtern>
  extern-defns: Tuple<VMExternDefn>
  debug-name-table: VMDebugNameTable
  debug-table: VMDebugInfoTable
  safepoint-table: VMSafepointTable

;A value that can be accessed directly within an instruction.
public deftype VMImm

;Virtual register.
public defstruct Local <: VMImm :
  index: Int
;Numeric primitive.
public defstruct NumConst <: VMImm :
  value: Char|Byte|Int|Long|Float|Double
;Stanza object that happens to have no fields at all, and therefore
;can be represented using a single word.
public defstruct Marker <: VMImm :
  typeid: Int
public defstruct Tag <: VMImm :
  typeid: Int
;Identifier of a piece of code. 
public defstruct CodeId <: VMImm :
  id: Int
;Identifier of a foreign memory location. 
public defstruct ExternId <: VMImm :
  id: Int
;Identifier of a piece of foreign code.
public defstruct ExternDefnId <: VMImm :
  id: Int
;Identifier of a global variable.
public defstruct GlobalId <: VMImm :
  id: Int
;Identifier of a piece of "data": e.g. a string of bytes for character
;strings in LoStanza.
public defstruct DataId <: VMImm :
  id: Int
;Identifier of a HiStanza interned constant object: e.g. String, Symbol
public defstruct ConstId <: VMImm :
  id: Int
;Special constant that indicates something is not yet populated or empty.
;Can be represented using single word.
public defstruct VoidMarker <: VMImm

public deftype VMType <: Hashable&Equalable
public defstruct VMByte <: VMType
public defstruct VMInt <: VMType
public defstruct VMLong <: VMType
public defstruct VMFloat <: VMType
public defstruct VMDouble <: VMType
public defstruct VMRef <: VMType

public deftype VMFunction

public defstruct VMMultifn <: VMFunction :
  arg: Int
  funcs: Tuple<KeyValue<Int, VMFunc>> with: (updater => sub-funcs)
  default: VMFunc

public defstruct VMFunc <: VMFunction :
  args: Tuple<Local|VMType>
  defs: Tuple<VMDef> with: (updater => sub-defs)
  ins: Tuple<VMIns> with: (updater => sub-ins)
  debug-name-table: VMDebugNameTable

public defstruct VMExtern :
  id: Int
  name: Symbol

public defstruct VMGlobal :
  id: Int
  size: Int
  roots: Tuple<Int>

public defstruct VMData :
  id: Int
  data: ByteArray

public defstruct VMConst :
  id: Int
  value: VMValue

public defstruct VMDef :
  id: Int
  type: VMType
  local: Int with: (default => 0, updater => sub-local)

public defstruct VMDefn :
  id: Int with: (updater => sub-id)
  dependencies: Tuple<Int> with: (default => [], updater => sub-dependencies)
  func: VMFunction with: (updater => sub-func)

public defstruct VMExternDefn :
  lbl: Symbol
  fid: Int with: (updater => sub-fid)
  a1: Tuple<VMType>
  a2: VMType

public defstruct VMMethod :
  instance?: True|False
  multi: Int
  types: Tuple<TypeSet>
  fid: Int

public deftype VMClass
public defmulti id (c:VMClass) -> Int
public defmulti sub-id (c:VMClass, id:Int) -> VMClass
public defmulti parents (c:VMClass) -> Tuple<Int>
public defmulti sub-parents (c:VMClass, parents:Tuple<Int>) -> VMClass

public defstruct VMArrayClass <: VMClass :
  id: Int with: (updater => sub-id, as-method => true)
  name: String
  dependencies: Tuple<Int>
  parents: Tuple<Int> with: (updater => sub-parents, as-method => true)
  base-size: Int
  item-size: Int
  base-roots: Tuple<Int>
  item-roots: Tuple<Int>
public defstruct VMLeafClass <: VMClass :
  id: Int with: (updater => sub-id, as-method => true)
  name: String
  dependencies: Tuple<Int>
  parents: Tuple<Int> with: (updater => sub-parents, as-method => true)
  size: Int
  roots: Tuple<Int>
public defstruct VMAbstractClass <: VMClass :
  id: Int with: (updater => sub-id, as-method => true)
  parents: Tuple<Int> with: (as-method => true)
  children: Tuple<Int>

public deftype VMIns
public defmulti trace-entry (ins:VMIns) -> StackTraceEntry|False
defmethod trace-entry (ins:VMIns) :
  fatal("Instruction %_ does not support stack trace information." % [ins])

public defstruct CallIns <: VMIns :
  xs: Tuple<Local|VMType>
  f: VMImm
  ys: Tuple<VMImm>
  trace-entry: StackTraceEntry|False with: (as-method => true)
public defstruct CallClosureIns <: VMIns :
  xs: Tuple<Local|VMType>
  f: VMImm
  ys: Tuple<VMImm>
  trace-entry: StackTraceEntry|False with: (as-method => true)
public defstruct TCallIns <: VMIns :
  f: VMImm
  ys: Tuple<VMImm>
public defstruct TCallClosureIns <: VMIns :
  f: VMImm
  ys: Tuple<VMImm>
public defstruct CallCIns <: VMIns :
  xs: Tuple<Local|VMType>
  f: VMImm
  ys: Tuple<VMImm>
  trace-entry: StackTraceEntry|False with: (as-method => true)
public defstruct YieldIns <: VMIns :
  enter?: True|False
  xs: Tuple<Local|VMType>
  f: VMImm
  ys: Tuple<VMImm>
  trace-entry: StackTraceEntry|False with: (as-method => true)
public defstruct SetIns <: VMIns :
  x: Local
  y: VMImm
public defstruct Op0Ins <: VMIns :
  x: Local|False
  op: VMOp
public defstruct Op1Ins <: VMIns :
  x: Local|False
  op: VMOp
  y: VMImm
public defstruct Op2Ins <: VMIns :
  x: Local|False
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LabelIns <: VMIns :
  n: Int
public defstruct GotoIns <: VMIns :
  n: Int with: (updater => sub-n)
public defstruct Branch0Ins <: VMIns :
  n1: Int with: (updater => sub-n1)
  n2: Int with: (updater => sub-n2)
  op: VMOp
public defstruct Branch1Ins <: VMIns :
  n1: Int with: (updater => sub-n1)
  n2: Int with: (updater => sub-n2)
  op: VMOp|False
  x: VMImm
public defstruct Branch2Ins <: VMIns :
  n1: Int with: (updater => sub-n1)
  n2: Int with: (updater => sub-n2)
  op: VMOp
  x: VMImm
  y: VMImm
public defstruct DispatchIns <: VMIns :
  ys: Tuple<VMImm>
  branches: Tuple<VMBranch>
  default: Int
  amb: Int
public defstruct MatchIns <: VMIns :
  ys: Tuple<VMImm>
  branches: Tuple<VMBranch>
  default: Int
public defstruct MethodDispatchIns <: VMIns :
  multi: Int
  ys: Tuple<VMImm>
  zs: Tuple<VMImm>
  default: Int
  amb: Int
public defstruct AllocIns <: VMIns :
  xs: Tuple<Local>
  types: Tuple<Int>
  sizes: Tuple<VMImm>
  trace-entry: StackTraceEntry|False with: (as-method => true)
;Represents x[y + offset] = z
;- class, if given, is the identifier of the object type of 'x'.
;- class is false if x does not represent a heap object.
public defstruct StoreIns <: VMIns :
  x: VMImm
  y: VMImm|False with: (default => false)
  offset: Int
  z: VMImm
  class: Int|False with: (default => false)  
;Represents x[y + offset] = z
;- class is the identifier of the object type of 'x'.
public defstruct StoreWithBarrierIns <: VMIns :
  x: VMImm
  y: VMImm|False with: (default => false)
  offset: Int
  z: VMImm
  class: Int
public defstruct LoadIns <: VMIns :
  x: Local
  y: VMImm
  z: VMImm|False with: (default => false)
  offset: Int
  class: Int|False with: (default => false)
public defstruct ReturnIns <: VMIns :
  xs: Tuple<VMImm>
public defstruct DumpIns <: VMIns :
  xs: Tuple<Local>
public defstruct RecordLiveIns <: VMIns :
  live: Tuple<Local>
public defstruct LiveIns <: VMIns :
  xs: Tuple<VMImm>
public defstruct CommentIns <: VMIns :
  message: String
public defstruct UnreachableIns <: VMIns
public defstruct SafepointIns <: VMIns :
  id:Int

public deftype VMValue :
  Char <: VMValue
  Byte <: VMValue
  Int <: VMValue
  Long <: VMValue
  Float <: VMValue
  Double <: VMValue
  String <: VMValue
  Symbol <: VMValue
  List<T> <: VMValue
  True <: VMValue
  False <: VMValue

public defstruct VMTypeObject <: VMValue & Hashable & Equalable :
  id: CodeId
public defstruct VMClosure <: VMValue & Hashable & Equalable :
  id: CodeId
public defstruct VMInternedConst <: VMValue & Hashable & Equalable :
  id: ConstId
public defstruct VMBranch :
  types: Tuple<TypeSet>
  n: Int with: (updater => sub-n)

public deftype VMOp :
  BasicOp <: VMOp
public defstruct InstanceofOp <: VMOp : (type:TypeSet)
public defstruct TagOp <: VMOp : (type:Int)
public defstruct DetagOp <: VMOp : (type:Int)
public defstruct ConvOp <: VMOp
public defstruct InterpretOp <: VMOp
public defstruct DerefOp <: VMOp

;------------------------------------------------------------
;------------------- VM Debug Names  ------------------------
;------------------------------------------------------------

;Represents a table of human-readable names for use by
;the debugger.
public defstruct VMDebugNameTable :
  entries: Tuple<VMDebugName>

;Represents a human-readable name for the given
;identifier.
public defstruct VMDebugName :
  id:Int
  name:String

;------------------------------------------------------------
;------------------- VM Debug Info --------------------------
;------------------------------------------------------------

;Table holding the definition information for identifiers.
public defstruct VMDebugInfoTable :
  entries: Tuple<VMDebugInfo>

;Represents the original name and definition location
;of each identifier.
public defstruct VMDebugInfo :
  id:Int
  name:String|False
  info:FileInfo|False

;------------------------------------------------------------
;--------------------- Safepoint Table ----------------------
;------------------------------------------------------------

public defstruct VMSafepointTable :
  files:Tuple<VMFileSafepoints>

public defstruct VMFileSafepoints :
  filename:String
  entries:Tuple<VMSafepointInfo>

public defstruct VMSafepointInfo :
  id:Int
  line:Int
  column:Int
  group:Int

;============================================================
;==================== Convenience ===========================
;============================================================

public defn StoreIns (x:VMImm, offset:Int, z:VMImm, class:Int|False) :
  StoreIns(x, false, offset, z, class)

public defn LoadIns (x:Local, y:VMImm, offset:Int, class:Int|False) :
  LoadIns(x, y, false, offset, class)

public defn package (vmp:VMPackage) :
  package(packageio(vmp))

public defn name (vmp:VMPackage) :
  package(packageio(vmp))

;============================================================
;================== Hashes and Equality =====================
;============================================================

defmethod hash (x:VMType) :
  match(x) :
    (x:VMByte) : 0
    (x:VMInt) : 1
    (x:VMLong) : 2
    (x:VMFloat) : 3
    (x:VMDouble) : 4
    (x:VMRef) : 5

defmethod equal? (a:VMType, b:VMType) :
  hash(a) == hash(b)

defmethod hash (x:VMTypeObject) : id(id(x))
defmethod hash (x:VMClosure) : id(id(x))
defmethod hash (x:VMInternedConst) : id(id(x))
defmethod equal? (a:VMTypeObject, b:VMTypeObject) : id(id(a)) == id(id(b))
defmethod equal? (a:VMClosure, b:VMClosure) : id(id(a)) == id(id(b))
defmethod equal? (a:VMInternedConst, b:VMInternedConst) : id(id(a)) == id(id(b))

;============================================================
;=================== Size Calculations ======================
;============================================================

public defn size (x:VMImm) :
  match(x) :
    (x:NumConst) :
      match(value(x)) :
        (v:Char) : 1
        (v:Byte) : 1
        (v:Int) : 4
        (v:Long) : 8
        (v:Float) : 4
        (v:Double) : 8
    (x:CodeId) : 8
    (x:ExternId) : 8
    (x:ExternDefnId) : 8
    (x:GlobalId) : 8
    (x:DataId) : 8
    (x:ConstId) : 8
    (x:Marker) : 8
    (x:VoidMarker) : 8
    (x:Tag) : 8

public defn type (x:VMImm) :
  match(x) :
    (x:NumConst) :
      match(value(x)) :
        (v:Char) : VMByte()
        (v:Byte) : VMByte()
        (v:Int) : VMInt()
        (v:Long) : VMLong()
        (v:Float) : VMFloat()
        (v:Double) : VMDouble()
    (x:CodeId) : VMLong()
    (x:ExternId) : VMLong()
    (x:ExternDefnId) : VMLong()
    (x:GlobalId) : VMLong()
    (x:DataId) : VMLong()
    (x:ConstId) : VMRef()
    (x:Marker) : VMRef()
    (x:VoidMarker) : VMRef()
    (x:Tag) : VMLong()

public defn size (t:VMType) :
  match(t) :
    (t:VMByte) : 1
    (t:VMInt) : 4
    (t:VMLong) : 8
    (t:VMFloat) : 4
    (t:VMDouble) : 8
    (t:VMRef) : 8

;============================================================
;===================== Mapper ===============================
;============================================================

public deftype VMItem :
  VMImm <: VMItem
  VMDef <: VMItem
  TypeSet <: VMItem
  VMBranch <: VMItem
  VMOp <: VMItem
  VMType <: VMItem
  VMValue <: VMItem
  VMIns <: VMItem
  VMGlobal <: VMItem
  VMData <: VMItem
  VMConst <: VMItem
  VMClass <: VMItem
  VMDefn <: VMItem
  VMMethod <: VMItem
  VMExtern <: VMItem
  VMExternDefn <: VMItem
  VMFunction <: VMItem
  VMDebugInfoTable <: VMItem
  VMDebugInfo <: VMItem
  VMSafepointTable <: VMItem
  VMFileSafepoints <: VMItem
  VMSafepointInfo <: VMItem
  VMDebugNameTable <: VMItem
  VMDebugName <: VMItem  
  
;Maps 'mapf' over all immediate VMItem fields in the given VMItem. 
public defn vm-map<?T> (mapf:VMItem -> VMItem, item:VMItem&?T) -> T :
  defn h<?T> (x:VMItem&?T) : mapf(x) as VMItem&T
  defn h<?T> (x:KeyValue<Int,VMItem&?T>) : key(x) => h(value(x))
  defn h<?T> (x:Tuple<VMItem&?T>) : map(h,x)
  defn h<?T> (x:Tuple<KeyValue<Int,VMItem&?T>>) : map(h,x)
  defn h? (x:Local|False) : match(x:Local) : h(x)

  {_ as VMItem&T} $ match(item) :
    (x:VMDef) : VMDef(id(x), h(type(x)), local(x))
    (x:VMImm) : x
    (x:VMType) : x
    (x:AndType) : AndType?(h(types(x)))
    (x:OrType) : OrType?(h(types(x)))
    (x:TypeSet) : x
    (x:VMBranch) : VMBranch(h(types(x)), n(x))
    (x:InstanceofOp) : InstanceofOp(h(type(x)))
    (x:VMOp) : x
    (x:List<VMValue>) : core/map(h,x)
    (x:VMTypeObject) : VMTypeObject(h(id(x)))
    (x:VMClosure) : VMClosure(h(id(x)))
    (x:VMInternedConst) : VMInternedConst(h(id(x)))
    (x:VMValue) : x
    (x:VMGlobal) : x
    (x:VMData) : x
    (x:VMConst) : VMConst(id(x), h(value(x)))
    (x:VMClass) : x
    (x:VMDefn) : VMDefn(id(x), dependencies(x), h(func(x)))
    (x:VMMethod) : VMMethod(instance?(x), multi(x), h(types(x)), fid(x))
    (x:VMExtern) : x
    (x:VMExternDefn) : VMExternDefn(lbl(x), fid(x), h(a1(x)), h(a2(x)))
    (x:VMMultifn) : VMMultifn(arg(x), h(funcs(x)), h(default(x)))
    (x:VMFunc) : VMFunc(h(args(x)), h(defs(x)), h(ins(x)), h(debug-name-table(x)))
    ;Instructions
    (x:CallIns) : CallIns(h(xs(x)), h(f(x)), h(ys(x)), trace-entry(x))
    (x:CallClosureIns) : CallClosureIns(h(xs(x)), h(f(x)), h(ys(x)), trace-entry(x))
    (x:TCallIns) : TCallIns(h(f(x)), h(ys(x)))
    (x:TCallClosureIns) : TCallClosureIns(h(f(x)), h(ys(x)))
    (x:CallCIns) : CallCIns(h(xs(x)), h(f(x)), h(ys(x)), trace-entry(x))
    (x:YieldIns) : YieldIns(enter?(x), h(xs(x)), h(f(x)), h(ys(x)), trace-entry(x))
    (x:SetIns) : SetIns(h(/x(x)), h(y(x)))
    (x:Op0Ins) : Op0Ins(h?(/x(x)), h(op(x)))
    (x:Op1Ins) : Op1Ins(h?(/x(x)), h(op(x)), h(y(x)))
    (x:Op2Ins) : Op2Ins(h?(/x(x)), h(op(x)), h(y(x)), h(z(x)))
    (x:Branch0Ins) : Branch0Ins(n1(x), n2(x), h(op(x)))
    (x:Branch1Ins) : Branch1Ins(n1(x), n2(x), h(op(x)), h(/x(x)))
    (x:Branch2Ins) : Branch2Ins(n1(x), n2(x), h(op(x)), h(/x(x)), h(y(x)))
    (x:DispatchIns) : DispatchIns(h(ys(x)), h(branches(x)), default(x), amb(x))
    (x:MatchIns) : MatchIns(h(ys(x)), h(branches(x)), default(x))
    (x:MethodDispatchIns) : MethodDispatchIns(multi(x), h(ys(x)), h(zs(x)), default(x), amb(x))
    (x:AllocIns) : AllocIns(h(xs(x)), h(types(x)), h(sizes(x)), trace-entry(x))
    (x:StoreIns) : StoreIns(h(/x(x)), h(y(x)), offset(x), h(z(x)), class(x))
    (x:StoreWithBarrierIns) : StoreWithBarrierIns(h(/x(x)), h(y(x)), offset(x), h(z(x)), class(x))
    (x:LoadIns) : LoadIns(h(/x(x)), h(y(x)), h(z(x)), offset(x), class(x))
    (x:ReturnIns) : ReturnIns(h(xs(x)))
    (x:DumpIns) : DumpIns(h(xs(x)))
    (x:RecordLiveIns) : RecordLiveIns(h(live(x)))
    (x:LiveIns) : LiveIns(h(xs(x)))
    (x:VMDebugInfoTable) : VMDebugInfoTable(h(entries(x)))
    (x:VMDebugInfo) : x
    (x:VMSafepointTable) : VMSafepointTable(h(files(x)))
    (x:VMFileSafepoints) : VMFileSafepoints(filename(x), h(entries(x)))
    (x:VMSafepointInfo) : x
    (x:VMIns) : x

;Maps f over any immediate "global identifiers" contained within the given VMItem.
;A global identifier is any Int that refers to a global VMPackage definition.
;Note that function-local identifiers are not mapped over:
;- VMDef identifiers are not included.
;- Label/Goto/Branch identifiers are not included.
public defn map-id<?T> (f:Int -> Int, item:VMItem&?T) -> T :
  defn h (x:Int) : f(x)
  defn h (x:False) : x
  defn h (x:Tuple<Int>) : map(h,x)
  {_ as VMItem&T} $ match(item) :
    ;Immediates
    (x:Marker) : Marker(h(typeid(x)))
    (x:Tag) : Tag(h(typeid(x)))
    (x:CodeId) : CodeId(h(id(x)))
    (x:ExternId) : ExternId(h(id(x)))
    (x:ExternDefnId) : ExternDefnId(h(id(x)))
    (x:GlobalId) : GlobalId(h(id(x)))
    (x:DataId) : DataId(h(id(x)))
    (x:ConstId) : ConstId(h(id(x)))
    (x:VMImm) : x
    ;TypeSet
    (x:SingleType) : SingleType(h(type(x)))
    (x:TypeSet) : x
    ;Ops
    (x:TagOp) : TagOp(h(type(x)))
    (x:DetagOp) : DetagOp(h(type(x)))
    (x:VMOp) : x
    ;Singles
    (x:VMDef) : x
    (x:VMBranch) : x
    (x:VMType) : x
    (x:VMValue) : x
    (x:VMFunction) : x
    ;Definitions
    (x:VMGlobal) : VMGlobal(h(id(x)), size(x), roots(x))
    (x:VMData) : VMData(h(id(x)), data(x))
    (x:VMConst) : VMConst(h(id(x)), value(x))
    (x:VMArrayClass) : VMArrayClass(h(id(x)), name(x), h(dependencies(x)), h(parents(x)), base-size(x), item-size(x), base-roots(x), item-roots(x))
    (x:VMLeafClass) : VMLeafClass(h(id(x)), name(x), h(dependencies(x)), h(parents(x)), size(x), roots(x))
    (x:VMAbstractClass) : VMAbstractClass(h(id(x)), h(parents(x)), h(children(x)))
    (x:VMDefn) : VMDefn(h(id(x)), h(dependencies(x)), func(x))
    (x:VMMethod) : VMMethod(instance?(x), h(multi(x)), types(x), h(fid(x)))
    (x:VMExtern) : VMExtern(h(id(x)), name(x))
    (x:VMExternDefn) : VMExternDefn(lbl(x), h(fid(x)), a1(x), a2(x))
    ;Instructions
    (x:MethodDispatchIns) : MethodDispatchIns(h(multi(x)), ys(x), zs(x), default(x), amb(x))
    (x:AllocIns) : AllocIns(xs(x), h(types(x)), sizes(x), trace-entry(x))
    (x:StoreIns) : StoreIns(/x(x), y(x), offset(x), z(x), h(class(x)))
    (x:LoadIns) : LoadIns(/x(x), y(x), z(x), offset(x), h(class(x)))
    (x:SafepointIns) : SafepointIns(h(id(x)))
    (x:VMIns) : x
    ;Tables
    (x:VMDebugInfoTable) : x
    (x:VMDebugInfo) : x
    (x:VMSafepointTable) : x
    (x:VMFileSafepoints) : x
    (x:VMSafepointInfo) : VMSafepointInfo(h(id(x)), line(x), column(x), h(group(x)))

public defn map-label<?T> (f:Int -> Int, ins:VMIns&?T) -> T :
  defn h (x:Int) : f(x)
  defn h (x:VMBranch) : VMBranch(types(x), h(n(x)))
  defn h (x:Tuple<VMBranch>) : map(h,x)
  {_ as VMIns&T} $ match(ins) :
    (ins:LabelIns) : LabelIns(h(n(ins)))
    (ins:GotoIns) : GotoIns(h(n(ins)))
    (ins:Branch0Ins) : Branch0Ins(h(n1(ins)), h(n2(ins)), op(ins))
    (ins:Branch1Ins) : Branch1Ins(h(n1(ins)), h(n2(ins)), op(ins), x(ins))
    (ins:Branch2Ins) : Branch2Ins(h(n1(ins)), h(n2(ins)), op(ins), x(ins), y(ins))
    (ins:DispatchIns) : DispatchIns(ys(ins), h(branches(ins)), h(default(ins)), h(amb(ins)))
    (ins:MatchIns) : MatchIns(ys(ins), h(branches(ins)), h(default(ins)))
    (ins:MethodDispatchIns) : MethodDispatchIns(multi(ins), ys(ins), zs(ins), h(default(ins)), h(amb(ins)))
    (ins:VMIns) : ins

;============================================================
;==================== Printer ===============================
;============================================================

defn arg-string (xs:Tuple<Local|VMType>) :
  val xs* = for x in xs seq :
    match(x:VMType) : "_:%_" % [x]
    else : x
  "(%,)" % [xs*]

defmethod print (o:OutputStream, p:VMPackage) :
  val io = packageio(p)
  print(o, "package %~ :" % [package(io)])
  val o2 = IndentedStream(o)
  match(init(p):Int) :
    lnprint(o2, "init = %_" % [init(p)])
  val xs = cat-all $ [
    imports(io)
    exports(io)
    globals(p)
    datas(p)
    consts(p)
    externs(p)
    classes(p)
    funcs(p)
    methods(p)
    extern-defns(p)
    entries(debug-table(p))
    [debug-name-table(p)
     safepoint-table(p)]]
  do(lnprint{o2, _}, xs)

defmethod print (o:OutputStream, d:VMDef) :
  print(o, "def %_ : %_ (local %_)" % [Local(id(d)), type(d), local(d)])

defmethod print (o:OutputStream, g:VMGlobal) :
  print(o, "global %_ (size = %_, roots = (%,))" % [GlobalId(id(g)), size(g), roots(g)])

defmethod print (o:OutputStream, d:VMData) :
  print(o, "data %_ %~" % [DataId(id(d)), data(d)])

defmethod print (o:OutputStream, d:VMConst) :
  defn printable (v:VMValue) :
    match(v) :
      (v:List) : "list(%@)" % [seq(printable, v)]
      (v:Symbol) : "\\|:|" when v == `\|:|
              else "%~" % [v]
      (v) : "%~" % [v]
  print(o, "const %_ %~" % [ConstId(id(d)), printable(value(d))])

defmethod print (o:OutputStream, d:VMExtern) :
  print(o, "extern %_ %~" % [ExternId(id(d)), name(d)])

defmethod print (o:OutputStream, d:VMExternDefn) :
  print(o, "extern defn %_ %~ : (%,) -> %_" % [fid(d), lbl(d), a1(d), a2(d)])

defmethod print (o:OutputStream, m:VMMethod) :
  val istr = " instance" when instance?(m) else ""
  print(o, "method%_ %_ (%,) : goto %_" % [istr, multi(m), types(m), fid(m)])

defmethod print (o:OutputStream, f:VMDefn) :
  print(o, "defn %_" % [CodeId(id(f))])
  if not empty?(dependencies(f)) :
    print(o, " depends-on (%,)" % [dependencies(f)])
  print(o, " %_" % [func(f)])

defmethod print (o:OutputStream, m:VMMultifn) :
  print(o, "multifn (%_) :" % [arg(m)])
  for entry in funcs(m) do :
    lnprint(o, "  %_ => " % [key(entry)])
    print-func(o, value(entry), 4)
  lnprint(o, "  else => ")
  print-func(o, default(m), 4)

defmethod print (o:OutputStream, f:VMFunc) :
  print-func(o, f, 2)

defn print-func (o:OutputStream, f:VMFunc, indent:Int) :
  print(o, "func %_ :" % [arg-string(args(f))])
  val o2 = IndentedStream(o, indent)
  do(lnprint{o2, _}, defs(f))
  do(lnprint{o2, _}, ins(f))
  lnprint(o2, debug-name-table(f))

defmethod print (o:OutputStream, c:VMAbstractClass) :
  print(o, "class %_ (%,) (children = (%,))" % [id(c), parents(c), children(c)])

defmethod print (o:OutputStream, c:VMLeafClass) :
  val dstr = "" when empty?(dependencies(c))
        else ", depends-on (%,)" % [dependencies(c)]
  print(o, "class %_ (%,) (name = %~, size = %_, roots = (%,)%_)" % [id(c), parents(c), name(c), size(c), roots(c), dstr])

defmethod print (o:OutputStream, c:VMArrayClass) :
  val dstr = "" when empty?(dependencies(c))
        else ", depends-on (%,)" % [dependencies(c)]
  print(o, "class %_ (%,) (name = %~, base-size = %_, item-size = %_, base-roots = (%,), item-roots = (%,)%_)" % [
    id(c), parents(c), name(c), base-size(c), item-size(c), base-roots(c), item-roots(c), dstr])

defmethod print (o:OutputStream, x:VMImm) :
  print{o, _} $ match(x) :
    (x:Local) : "L%_" % [index(x)]
    (x:NumConst) : "%~" % [value(x)]
    (x:Marker) : "M%_" % [typeid(x)]
    (x:VoidMarker) : "void"
    (x:Tag) : "T%_" % [typeid(x)]
    (x:CodeId) : "F%_" % [id(x)]
    (x:ExternId) : "E%_" % [id(x)]
    (x:ExternDefnId) : "EF%_" % [id(x)]
    (x:GlobalId) : "G%_" % [id(x)]
    (x:DataId) : "D%_" % [id(x)]
    (x:ConstId) : "C%_" % [id(x)]

defmethod print (o:OutputStream, t:VMSafepointTable) :
  val o2 = IndentedStream(o)
  print(o, "safepoint table :")
  do(lnprint{o2, _}, files(t))

defmethod print (o:OutputStream, f:VMFileSafepoints) :
  val o2 = IndentedStream(o)
  print(o, "file %~ :" % [filename(f)])
  do(lnprint{o2, _}, entries(f))

defmethod print (o:OutputStream, e:VMSafepointInfo) :
  print(o, "safepoint %_ (line = %_, column = %_, group = %_)" % [id(e), line(e), column(e), group(e)])

defmethod print (o:OutputStream, t:VMDebugNameTable) :
  if empty?(entries(t)) :
    print(o, "debugname table : ()")  
  else :
    val o2 = IndentedStream(o)
    print(o, "debugname table :")  
    do(lnprint{o2, _}, entries(t))

defmethod print (o:OutputStream, e:VMDebugName) :
  print(o, "debugname L%_ (name = %~)" % [id(e), name(e)])

defmethod print (o:OutputStream, x:VMDebugInfoTable) :
  if empty?(entries(x)) :
    print(o, "debuginfo table : ()")
  else :
    val o2 = IndentedStream(o)
    print(o, "debuginfo table :")
    do(lnprint{o2, _}, entries(x))

defmethod print (o:OutputStream, x:VMDebugInfo) :
  print(o, "debuginfo %_ (name = %~)" % [id(x), name(x)])

defmethod print (o:OutputStream, i:VMIns) :
  defn P (x) : print(o, x)
  defn class? (x:Int|False) :
    "" when x is False else " (class = %_)" % [x]
  defn x=? (x:VMImm|False) :
    "" when x is False else "%_ = " % [x]
  match(i) :
    (i:TCallIns) : P $ "return call %_ (%,)" % [f(i), ys(i)]
    (i:TCallClosureIns) : P $ "return call-closure %_ (%,)" % [f(i), ys(i)]
    (i:CallIns) : P $ "%_ = call %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:CallCIns) : P $ "%_ = call-c %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:CallClosureIns): P $ "%_ = call-closure %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:UnreachableIns) : P $ "unreachable"
    (i:YieldIns) :
      val enter-str = " (enter)" when enter?(i) else ""
      P $ "%_ = yield%_ %_ (%,)" % [arg-string(xs(i)), enter-str, f(i), ys(i)]
    (i:SetIns) : P $ "%_ = %_" % [x(i), y(i)]
    (i:Op0Ins) : P $ "%_%_" % [x=?(x(i)), op(i)]
    (i:Op1Ins) : P $ "%_%_ %_" % [x=?(x(i)), op(i), y(i)]
    (i:Op2Ins) : P $ "%_%_ %_ %_" % [x=?(x(i)), op(i), y(i), z(i)]
    (i:LabelIns) : P $ "label %_" % [n(i)]
    (i:GotoIns) : P $ "goto %_" % [n(i)]
    (i:Branch0Ins) : P $ "goto %_ when %_ else %_" % [n1(i), op(i), n2(i)]
    (i:Branch1Ins) :
      val op-str = match(op(i)) :
        (op:VMOp) : " %_" % [op]
        (op:False) : ""
      P $ "goto %_ when%_ %_ else %_" % [n1(i), op-str, x(i), n2(i)]
    (i:Branch2Ins) : P $ "goto %_ when %_ %_ %_ else %_" % [n1(i), op(i), x(i), y(i), n2(i)]
    (i:AllocIns) : P $ "(%,) = alloc<%,> (%,)" % [xs(i), types(i), sizes(i)]
    (i:StoreIns) :
      val ystr = "" when y(i) is False
            else "%_ + " % [y(i)]
      P $ "%_[%_%_] = %_%_" % [x(i), ystr, offset(i), z(i), class?(class(i))]
    (i:StoreWithBarrierIns) :
      val ystr = "" when y(i) is False
            else "%_ + " % [y(i)]
      P $ "%_[%_%_] = %_ (with write-barrier, class = %_)" % [x(i), ystr, offset(i), z(i), class(i)]      
    (i:LoadIns) :
      val zstr = "" when z(i) is False
            else "%_ + " % [z(i)]
      P $ "%_ = %_[%_%_]%_" % [x(i), y(i), zstr, offset(i), class?(class(i))]
    (i:ReturnIns) : P $ "return (%,)" % [xs(i)]
    (i:DumpIns) : P $ "dump (%,)" % [xs(i)]
    (i:RecordLiveIns) : P $ "live (%,)" % [live(i)]
    (i:LiveIns) : P $ "mark-live (%,)" % [xs(i)]
    (i:CommentIns) : P $ "comment: %~" % [message(i)]
    (i:SafepointIns) : P $ "safepoint %_" % [id(i)]
    (i:MatchIns) :
      print(o, "match(%,) :" % [ys(i)])
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, branches(i))
      lnprint(o2, "else : goto %_" % [default(i)])
    (i:DispatchIns) :
      print(o, "dispatch(%,) :" % [ys(i)])
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, branches(i))
      lnprint(o2, "else : goto %_" % [default(i)])
      lnprint(o2, "amb : goto %_" % [amb(i)])
    (i:MethodDispatchIns) :
      print(o, "method-dispatch[%_](%,)(%,) :" % [multi(i), ys(i), zs(i)])
      val o2 = IndentedStream(o)
      lnprint(o2, "else : goto %_" % [default(i)])
      lnprint(o2, "amb : goto %_" % [amb(i)])

defmethod print (o:OutputStream, op:VMOp) :
  print{o, _} $ match(op) :
    (op:InstanceofOp) : "instanceof<%_>" % [type(op)]
    (op:TagOp) : "tag<%_>" % [type(op)]
    (op:DetagOp) : "detag<%_>" % [type(op)]
    (op:ConvOp) : "conv"
    (op:InterpretOp) : "interpret"
    (op:DerefOp) : "deref"

defmethod print (o:OutputStream, t:VMType) :
  print{o, _} $ match(t) :
    (t:VMByte) : "byte"
    (t:VMInt) : "int"
    (t:VMLong) : "long"
    (t:VMFloat) : "float"
    (t:VMDouble) : "double"
    (t:VMRef) : "ref"

defmethod print (o:OutputStream, v:VMTypeObject) :
  print(o, "type(%_)" % [id(v)])

defmethod print (o:OutputStream, v:VMClosure) :
  print(o, "closure(%_)" % [id(v)])

defmethod print (o:OutputStream, v:VMInternedConst) :
  print(o, "interned-const(%_)" % [id(v)])

defmethod print (o:OutputStream, b:VMBranch) :
  print(o, "(%,) : goto %_" % [types(b), n(b)])

;============================================================
;======================= Reader =============================
;============================================================

defsyntax vmcode :
  import (basic-op0, basic-op1, basic-op2) from basic-ops

  defproduction op0 : VMOp
  defrule op0 = (?x:#basic-op0) : x

  defproduction op1 : VMOp
  defrule op1 = (?x:#basic-op1) : x
  defrule op1 = (instanceof<?t:#typeset>) : InstanceofOp(t)
  defrule op1 = (tag<?t:#int!>) : TagOp(t)
  defrule op1 = (detag<?t:#int!>) : DetagOp(t)
  defrule op1 = (conv) : ConvOp()
  defrule op1 = (interpret) : InterpretOp()
  defrule op1 = (deref) : DerefOp()

  defproduction op2 : VMOp
  defrule op2 = (?x:#basic-op2) : x

  defproduction type : VMType
  defrule type = (byte) : VMByte()
  defrule type = (int) : VMInt()
  defrule type = (long) : VMLong()
  defrule type = (float) : VMFloat()
  defrule type = (double) : VMDouble()
  defrule type = (ref) : VMRef()

  defproduction typeset : TypeSet
  defrule typeset = (?n:#int) : SingleType(n)
  defrule typeset = (?) : TopType()
  defrule typeset = (and(?ts:#typeset ...)) : AndType?(ts)
  defrule typeset = (or(?ts:#typeset ...)) : OrType?(ts)

  defn char-prefix? (x, c:Char) :
    unwrap-token(x) is Symbol and to-string(x)[0] == c
  defn str-prefix? (x, s:String) :
    unwrap-token(x) is Symbol and prefix?(to-string(x), s)
  defn char-index! (info:FileInfo|False, x:Symbol|Token) :
    suffix-index!(info, x, 1)
  defn suffix-index! (info:FileInfo|False, x:Symbol|Token, n:Int) :
    val i = to-int(to-string(x)[n to false])
    match(i:Int) : i
    else : throw(VME(info, "Invalid name: %~" % [x]))

  defproduction local : Local
  defrule local = (?r) when char-prefix?(r, 'L') : Local(char-index!(closest-info(), r))
  defproduction externdefnid : ExternDefnId
  defrule externdefnid = (?r) when str-prefix?(r, "EF") : ExternDefnId(suffix-index!(closest-info(), r, 2))
  defproduction externid : ExternId
  defrule externid = (?r) when char-prefix?(r, 'E') : ExternId(char-index!(closest-info(), r))
  defproduction globalid : GlobalId
  defrule globalid = (?r) when char-prefix?(r, 'G') : GlobalId(char-index!(closest-info(), r))
  defproduction dataid : DataId
  defrule dataid = (?r) when char-prefix?(r, 'D') : DataId(char-index!(closest-info(), r))
  defproduction constid : ConstId
  defrule constid = (?r) when char-prefix?(r, 'C') : ConstId(char-index!(closest-info(), r))
  defproduction marker : Marker
  defrule marker = (?r) when char-prefix?(r, 'M') : Marker(char-index!(closest-info(), r))
  defproduction tag : Tag
  defrule tag = (?r) when char-prefix?(r, 'T') : Tag(char-index!(closest-info(), r))
  defproduction codeid : CodeId
  defrule codeid = (?r) when char-prefix?(r, 'F') : CodeId(char-index!(closest-info(), r))

  defproduction imm : VMImm
  defrule imm = (?x) when unwrap-token(x) is Char|Byte|Int|Long|Float|Double : NumConst(unwrap-token(x))
  defrule imm = (void) : VoidMarker()
  defrule imm = (?x:#externdefnid) : x
  defrule imm = (?x:#local) : x
  defrule imm = (?x:#externid) : x
  defrule imm = (?x:#globalid) : x
  defrule imm = (?x:#dataid) : x
  defrule imm = (?x:#constid) : x
  defrule imm = (?x:#marker) : x
  defrule imm = (?x:#tag) : x
  defrule imm = (?x:#codeid) : x

  defproduction ins : VMIns
  defrule ins = (?xs:#args = call ?f:#imm! (?ys:#imm! ...)) : CallIns(xs, f, to-tuple(ys), StackTraceEntry(`nopackage, false, closest-info()))
  defrule ins = (?xs:#args = call-c ?f:#imm! (?ys:#imm! ...)) : CallCIns(xs, f, to-tuple(ys), StackTraceEntry(`nopackage, false, closest-info()))
  defrule ins = (?xs:#args = call-closure ?f:#imm! (?ys:#imm! ...)) : CallClosureIns(xs, f, to-tuple(ys), StackTraceEntry(`nopackage, false, closest-info()))
  defrule ins = (?xs:#args = yield ?e:#enter? ?f:#imm! (?ys:#imm! ...)) : YieldIns(e, xs, f, to-tuple(ys), StackTraceEntry(`nopackage, false, closest-info()))
  defrule ins = ((?xs:#local ...) = alloc<?ts:#int! ...> (?sizes:#imm! ...)) : AllocIns(to-tuple(xs), to-tuple(ts), to-tuple(sizes), StackTraceEntry(`nopackage, false, closest-info()))
  defrule ins = (?x:#local = ?y:#imm[?z:#offset? ?o:#int!] ?c:#class?) : LoadIns(x, y, z, o, c)
  defrule ins = (?x:#imm[?y:#offset? ?o:#int!] = ?z:#imm! ?c:#class?) : StoreIns(x, y, o, z, c)
  defrule ins = (?x:#local = ?o:#op0) : Op0Ins(x, o)
  defrule ins = (?x:#local = ?o:#op1 ?y:#imm!) : Op1Ins(x, o, y)
  defrule ins = (?x:#local = ?o:#op2 ?y:#imm! ?z:#imm!) : Op2Ins(x, o, y, z)
  defrule ins = (?x:#local = ?y:#imm!) : SetIns(x,y)
  defrule ins = (?o:#op0) : Op0Ins(false, o)
  defrule ins = (?o:#op1 ?y:#imm!) : Op1Ins(false, o, y)
  defrule ins = (?o:#op2 ?y:#imm! ?z:#imm!) : Op2Ins(false, o, y, z)
  defrule ins = (label ?n:#int!) : LabelIns(n)
  defrule ins = (goto ?n1:#int! when ?o:#op0 else ?n2:#int!) : Branch0Ins(n1, n2, o)
  defrule ins = (goto ?n1:#int! when ?o:#op2 ?x:#imm! ?y:#imm! else ?n2:#int!) : Branch2Ins(n1, n2, o, x, y)
  defrule ins = (goto ?n1:#int! when ?o:#op1 ?x:#imm! else ?n2:#int!) : Branch1Ins(n1, n2, o, x)
  defrule ins = (goto ?n1:#int! when ?x:#imm! else ?n2:#int!) : Branch1Ins(n1, n2, false, x)
  defrule ins = (goto ?n:#int!) : GotoIns(n)
  defrule ins = (return call ?f:#imm! (?ys:#imm! ...)) : TCallIns(f, to-tuple(ys))
  defrule ins = (unreachable) : UnreachableIns()
  defrule ins = (return call-closure ?f:#imm! (?ys:#imm! ...)) : TCallClosureIns(f, to-tuple(ys))
  defrule ins = (return (?xs:#imm! ...)) : ReturnIns(to-tuple(xs))
  defrule ins = (dump (?xs:#local ...)) : DumpIns(to-tuple(xs))
  defrule ins = (live (?xs:#local ...)) : RecordLiveIns(to-tuple(xs))
  defrule ins = (mark-live (?xs:#imm! ...)) : LiveIns(to-tuple(xs))
  defrule ins = (comment: ?x:#string!) : CommentIns(x)
  defrule ins = (safepoint ?id:#int!) : SafepointIns(id)
  defrule ins = (match(?ys:#imm! ...) : (?bs:#vmbranch ... ?d:#defaultbranch)) : MatchIns(to-tuple(ys), to-tuple(bs), d)
  defrule ins = (dispatch(?ys:#imm! ...) : (?bs:#vmbranch ... ?d:#defaultbranch ?a:#ambbranch)) :
    DispatchIns(to-tuple(ys), to-tuple(bs), d, a)
  defrule ins = (method-dispatch[?m:#int!](?ys:#imm! ...)(?zs:#imm! ...) : (?d:#defaultbranch ?a:#ambbranch)) :
    MethodDispatchIns(m, to-tuple(ys), to-tuple(zs), d, a)

  defproduction enter? : True|False
  defrule enter? = ((enter)) : true
  defrule enter? = () : false

  defproduction class? : Int|False
  defrule class? = ((class = ?n:#int)) : n
  defrule class? = () : false

  defproduction offset? : VMImm|False
  defrule offset? = (?x:#imm +) : x
  defrule offset? = () : false

  defproduction args : Tuple<Local|VMType>
  defrule args = ((?xs:#arg ...)) : to-tuple(xs)
  defproduction arg : Local|VMType
  defrule arg = (?x:#local) : x
  defrule arg = (_:?t:#type) : t

  defproduction def : VMDef
  defrule def = (def ?n:#local : ?t:#type! (local ?l:#int!)) : VMDef(index(n), t, l)

  defproduction extern : VMExtern
  defrule extern = (extern ?x:#externid ?name:#symbol!) : VMExtern(id(x), name)

  defproduction extern-defn : VMExternDefn
  defrule extern-defn = (extern defn ?fid:#int! ?lbl:#symbol! : (?a1:#type! ...) -> ?a2:#type!) :
    VMExternDefn(lbl, fid, to-tuple(a1), a2)

  defproduction global : VMGlobal
  defrule global = (global ?x:#globalid (size = ?size:#int!,
                                         roots = (?rs:#int! ...))) :
    VMGlobal(id(x), size, to-tuple(rs))

  defn to-byte-array (bs:List<Byte>) :
    val b = ByteArray(length(bs))
    b[0 to false] = bs
    b

  defproduction data : VMData
  defrule data = (data ?x:#dataid [?bytes:#byte! ...]) :
    VMData(id(x), to-byte-array(bytes))

  defproduction const : VMConst
  defrule const = (const ?x:#constid ?v:#vmvalue) :
    VMConst(id(x), v)

  defproduction vmbranch : VMBranch
  defrule vmbranch = ((?ts:#typeset ...) : goto ?n:#int) : VMBranch(to-tuple(ts), n)
  defproduction defaultbranch : Int
  defrule defaultbranch = (else : goto ?n:#int) : n
  defproduction ambbranch : Int
  defrule ambbranch = (amb : goto ?n:#int) : n

  defproduction func : VMFunction
  defrule func = (multifn (?arg:#int!) : (?bs:#branch ... ?eb:#elsebranch)) :
    VMMultifn(arg, to-tuple(bs), eb)
  defrule func = (?f:#func1) :
    f
  defproduction branch : KeyValue<Int, VMFunc>
  defrule branch = (?n:#int => ?f:#func1) :
    n => f
  defproduction elsebranch : VMFunc
  defrule elsebranch = (else => ?f:#func1) : f

  defproduction func1 : VMFunc
  defrule func1 = (func ?args:#args :
                     ?defs:#def ...
                     ?ins:#ins! ...
                     ?debug-table:#vmdebug-name-table) :
    VMFunc(args, to-tuple(defs), to-tuple(ins), debug-table)

  defproduction vmdefn : VMDefn
  defrule vmdefn = (defn ?x:#codeid ?deps:#dependencies ?f:#func!) :
    VMDefn(id(x), deps, f)

  defproduction dependencies : Tuple<Int>
  defrule dependencies = (depends-on (?ns:#int ...)) : to-tuple(ns)
  defrule dependencies = () : []

  defproduction vmvalue : VMValue
  defrule vmvalue = (type(?id:#codeid)) : VMTypeObject(id)
  defrule vmvalue = (closure(?id:#codeid)) : VMClosure(id)
  defrule vmvalue = (interned-const(?id:#constid)) : VMInternedConst(id)
  defrule vmvalue = (list(?xs:#vmvalue ...)) : unwrap-token(xs)
  defrule vmvalue = (?x) when unwrap-token(x) is VMValue : unwrap-all(x)

  defproduction class : VMClass
  defrule class = (class ?id:#int! (?parents:#int! ...) (
                     name = ?name:#string!
                     base-size = ?base:#int!,
                     item-size = ?item:#int!,
                     base-roots = (?brs:#int! ...),
                     item-roots = (?irs:#int! ...),
                     ?deps:#dependencies)) :
    VMArrayClass(id, name, deps, to-tuple(parents), base, item, to-tuple(brs), to-tuple(irs))
  defrule class = (class ?id:#int! (?parents:#int! ...) (
                     name = ?name:#string!
                     size = ?size:#int!,
                     roots = (?rs:#int! ...),
                     ?deps:#dependencies)) :
    VMLeafClass(id, name, deps, to-tuple(parents), size, to-tuple(rs))
  defrule class = (class ?id:#int! (?parents:#int! ...) (children = (?cs:#int! ...))) :
    VMAbstractClass(id, to-tuple(parents), to-tuple(cs))

  defproduction vmmethod : VMMethod
  defrule vmmethod = (method instance ?multi:#int (?types:#typeset ...) : goto ?fid:#int) :
    VMMethod(true, multi, to-tuple(types), fid)
  defrule vmmethod = (method ?multi:#int (?types:#typeset ...) : goto ?fid:#int) :
    VMMethod(false, multi, to-tuple(types), fid)

  defproduction vmdebug-name-table: VMDebugNameTable
  defrule vmdebug-name-table = (debugname table : (?es:#vmdebug-name ...)) :
    VMDebugNameTable(to-tuple(es))

  defproduction vmdebug-name: VMDebugName
  defrule vmdebug-name = (debugname ?l:#local (name = ?name:#string!)) :
    VMDebugName(index(l), name)

  defproduction vmsafepoint-info : VMSafepointInfo
  defrule vmsafepoint-info = (safepoint ?id:#int! (line = ?line:#int!, column = ?col:#int!, group = ?group:#int!)) :
    VMSafepointInfo(id, line, col, group)

  defproduction vmfile-safepoints : VMFileSafepoints
  defrule vmfile-safepoints = (file ?filename:#string : (?infos:#vmsafepoint-info ...)) :
    VMFileSafepoints(filename, to-tuple(infos))

  defproduction debuginfo : VMDebugInfo
  defrule debuginfo = (debuginfo ?id:#int! (name = ?name:#string-or-false)) :
    VMDebugInfo(id, name, closest-info())

  import (import export) from dl-ir
  public defproduction vmpackage : VMPackage
  defrule vmpackage = (package ?name:#symbol :
                         ?init:#init?
                         ?stmts:#tstmt ...) :
    val ins = to-tuple(filter-by<Import>(stmts))
    val exs = to-tuple(filter-by<Export>(stmts))
    val io = PackageIO(name, [], ins, exs, false)
    val gs = to-tuple(filter-by<VMGlobal>(stmts))
    val ds = to-tuple(filter-by<VMData>(stmts))
    val cts = to-tuple(filter-by<VMConst>(stmts))
    val cs = to-tuple(filter-by<VMClass>(stmts))
    val fs = to-tuple(filter-by<VMDefn>(stmts))
    val es = to-tuple(filter-by<VMExtern>(stmts))
    val efs = to-tuple(filter-by<VMExternDefn>(stmts))
    val ms = to-tuple(filter-by<VMMethod>(stmts))
    val debug-name-table = find-by<VMDebugNameTable>(stmts)
    val dbg = to-tuple(filter-by<VMDebugInfo>(stmts))
    val sptable = find-by<VMSafepointTable>(stmts)
    throw(VME(closest-info(), "No safepoint table")) when sptable is False
    VMPackage(io, init, gs, ds, cts, cs, fs, ms, es, efs,
              debug-name-table as VMDebugNameTable
              VMDebugInfoTable(dbg),
              sptable as VMSafepointTable)

  defproduction init? : Int|False
  defrule init? = (init = ?n:#int) : n
  defrule init? = () : false

  defproduction tstmt : VMGlobal|VMClass|VMDefn|VMExtern|VMExternDefn|VMData|
                        VMConst|VMMethod|Import|Export|VMDebugInfo|
                        VMSafepointTable|VMDebugNameTable
  defrule tstmt = (?x:#global) : x
  defrule tstmt = (?x:#data) : x
  defrule tstmt = (?x:#const) : x
  defrule tstmt = (?x:#extern-defn) : x
  defrule tstmt = (?x:#extern) : x
  defrule tstmt = (?x:#class) : x
  defrule tstmt = (?x:#vmdefn) : x
  defrule tstmt = (?x:#vmmethod) : x
  defrule tstmt = (?x:#import) : x
  defrule tstmt = (?x:#export) : x
  defrule tstmt = (?x:#vmdebug-name-table) : x
  defrule tstmt = (?x:#debuginfo) : x  
  defrule tstmt = (safepoint table : (?files:#vmfile-safepoints ...)) :
    VMSafepointTable(to-tuple(files))    
  fail-if tstmt = () : VME(closest-info(), "Expected a top-level statement here.")

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

  defproduction string-or-false: String|False
  defrule string-or-false = (?x) when unwrap-token(x) is String|False : unwrap-token(x)

  ;===== Failure =====
  defproduction imm! : VMImm
  defrule imm! = (?x:#imm) : x
  fail-if imm! = () : VME(closest-info(), "Expected an immediate here.")

  defproduction int! : Int
  defrule int! = (?x:#int) : x
  fail-if int! = () : VME(closest-info(), "Expected an integer here.")

  defproduction byte! : Byte
  defrule byte! = (?x:#byte) : x
  fail-if byte! = () : VME(closest-info(), "Expected a byte here.")

  defproduction ins! : VMIns
  defrule ins! = (?x:#ins) : x
  fail-if ins! = () : VME(closest-info(), "Expected an instruction here.")

  defproduction func! : VMFunction
  defrule func! = (?x:#func) : x
  fail-if func! = () : VME(closest-info(), "Expected a function here.")

  defproduction type! : VMType
  defrule type! = (?x:#type) : x
  fail-if type! = () : VME(closest-info(), "Expected a type here.")

  defproduction string! : String
  defrule string! = (?x:#string) : x
  fail-if string! = () : VME(closest-info(), "Expected a string here.")

  defproduction symbol! : Symbol
  defrule symbol! = (?x:#symbol) : x
  fail-if symbol! = () : VME(closest-info(), "Expected a symbol here.")


;============================================================
;====================== Errors ==============================
;============================================================

public defstruct VMError <: Exception :
  info: FileInfo|False
  msg

public defn VME (info:FileInfo|False, msg) :
  VMError(info, msg)

defmethod print (o:OutputStream, e:VMError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [info-str, msg(e)])

;============================================================
;=============== Convenient File Operations =================
;============================================================

public defn read-vm-package (filename:String) :
  val forms = read-file(filename)
  parse-syntax[vmcode / #vmpackage](forms)

public defn read-vm-packages (filename:String) :
  val forms = read-file(filename)
  to-tuple(parse-syntax[vmcode / #vmpackage ...](forms))

public defn dump (p:VMPackage, path:String, suffix:String|False) :
  val suffix-str = "" when suffix is False else ".%_" % [suffix]
  val filename = norm-path("%_/%_.vm%_" % [path, mangle-as-filename(package(p)), suffix-str])
  spit(filename, p)

public defn dump (p:VMPackage, suffix:String|False) :
  dump(p, ".", suffix)

public defn dump (p:VMPackage) :
  dump(p, false)