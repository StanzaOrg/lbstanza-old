defpackage stz/el-reordering :
  import core
  import collections
  import stz/type-fargs
  import stz/el-ir

;============================================================
;=================== Representation =========================
;============================================================

;- num-non-dispatch: The number of optional/vararg arguments
;  in front that do not participate in multi dispatch.
;- indices: E.g. indices[2] = 4 means that the new argument 2
;  corresponds to the previous argument 4.
;- args: The reordered arguments, with postprocessed types.
public defstruct OrderedArgs<T> :
  num-non-dispatch:Int
  indices:Tuple<Int>
  args:Tuple<FArg<T>>

;============================================================
;=========== Check Whether Reordering Needed ================
;============================================================

;Returns true if the arguments needs to be reordered or processed.
public defn requires-ordering? (args:Tuple<FArg>) -> True|False :
  for arg in args any? :
    match(arg) :
      (arg:PositionalArg) : optional?(arg)
      (arg:KeywordArg) : true
      (arg:VarArg) : true

;============================================================
;================ Reordering with Wrapping ==================
;============================================================

;Compute the new ordering of the given arguments.
public defn reorder-args<?T> (args:Tuple<FArg<?T>>,
                              wrap-maybe:T -> T,
                              wrap-tuple:T -> T) -> OrderedArgs<T> :
  ;Classify arguments into groups:
  ;- OPTIONAL POS ARGS
  ;- OPTIONAL KEY ARGS
  ;- VARARG?
  ;- REQUIRED POS ARGS
  ;- REQUIRED KEY ARGS
  ;(Keyword arguments are always sorted by name within
  ; their group.)
  val optional-pos-args = Vector<Int>()
  val optional-key-args = Vector<Int>()
  var vararg:Int|False = false
  val required-pos-args = Vector<Int>()
  val required-key-args = Vector<Int>()
  for (arg in args, i in 0 to false) do :
    match(arg) :
      (arg:PositionalArg<T>) :
        if optional?(arg) : add(optional-pos-args, i)
        else : add(required-pos-args, i)
      (arg:KeywordArg<T>) :
        if optional?(arg) : add(optional-key-args, i)
        else : add(required-key-args, i)
      (arg:VarArg<T>) :
        vararg = i
        
  ;Sort keyword arguments by name.
  defn sort-keywords (vs:Vector<Int>) :
    defn name! (i:Int) : name(args[i] as KeywordArg)
    qsort!(name!, vs)
  sort-keywords(optional-key-args)
  sort-keywords(required-key-args)

  ;Generate final ordering.
  val new-indices = Vector<Int>()
  val new-args = Vector<PositionalArg<T>>()
  defn identity (t:T) : t
  defn process-arg (f:T -> T, i:Int) :
    add(new-indices, i)
    add(new-args, PositionalArg<T>(false, f(type(args[i]))))  
  do(process-arg{wrap-maybe, _}, optional-pos-args)
  do(process-arg{wrap-maybe, _}, optional-key-args)
  match(vararg:Int) : process-arg(wrap-tuple, vararg)
  do(process-arg{identity, _}, required-pos-args)
  do(process-arg{identity, _}, required-key-args)

  ;Bundle result in OrderedArgs.
  val vararg-count = 1 when vararg is Int else 0
  val num-non-dispatch = length(optional-pos-args)
                       + length(optional-key-args)
                       + vararg-count
  OrderedArgs<T>(num-non-dispatch,
                 to-tuple(new-indices),
                 to-tuple(new-args))

;============================================================
;================ Applying a Previous Order =================
;============================================================

;Reorder a tuple of items according to the indices in 'ordered'.
public defn reorder<?T> (ordered:OrderedArgs, xs:Tuple<?T>) -> Tuple<T> :
  for i in indices(ordered) map :
    xs[i]

;============================================================
;================== Simple Reordering =======================
;============================================================

;Compute the new ordering of the given arguments.
public defn reorder-args<?T> (args:Tuple<FArg<?T>>) -> Tuple<FArg<T>> :
  ;Classify arguments into groups:
  ;- OPTIONAL POS ARGS
  ;- OPTIONAL KEY ARGS
  ;- VARARG?
  ;- REQUIRED POS ARGS
  ;- REQUIRED KEY ARGS
  ;(Keyword arguments are always sorted by name within
  ; their group.)
  val optional-pos-args = Vector<PositionalArg<T>>()
  val optional-key-args = Vector<KeywordArg<T>>()
  var vararg:Tuple<VarArg<T>> = []
  val required-pos-args = Vector<PositionalArg<T>>()
  val required-key-args = Vector<KeywordArg<T>>()
  for arg in args do :
    match(arg) :
      (arg:PositionalArg<T>) :
        if optional?(arg) : add(optional-pos-args, arg)
        else : add(required-pos-args, arg)
      (arg:KeywordArg<T>) :
        if optional?(arg) : add(optional-key-args, arg)
        else : add(required-key-args, arg)
      (arg:VarArg<T>) :
        vararg = [arg]
        
  ;Sort keyword arguments by name.
  qsort!(name, optional-key-args)
  qsort!(name, required-key-args)

  ;Return the ordered arguments.
  to-tuple $ cat-all $ [
    optional-pos-args,
    optional-key-args,
    vararg,
    required-pos-args,
    required-key-args]