defpackage stz/reg-alloc-model-analysis :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-engine
  import stz/utils

;============================================================
;=============== Model Properties Analysis ==================
;============================================================

;Analyze the given operation models.
public defn analyze-models (models:Tuple<OperationModel>)
                         -> Vector<ModelProperties> :
  to-vector<ModelProperties>(seq(analyze, models))

;Analyze a single operation model.
defn analyze (m:OperationModel) -> ModelProperties :
  val returns? = any?({_ is Return}, stmts(m))
  val clears-registers? = any?({_ is ClearRegisters}, stmts(m))
  val arg-types = map(type{location(_)}, args(m))
  val result-types = map(type{location(_)}, results(m))
  ModelProperties(id(m),
                  returns?,
                  clears-registers?
                  arg-types,
                  result-types)

;============================================================
;===================== Model Analyzer =======================
;============================================================
;We do not want to greedily analyze every model under all
;circumstances, so use an analyzer to do on-demand analysis
;of the models.
public deftype ModelAnalyzer

;Retrieve the used registers for the given operation in the given context.
public defmulti used-registers (a:ModelAnalyzer, op-id:Int, ctxt:UsageContext) -> UsedRegisters

;Create the ModelAnalyzer.
public defn ModelAnalyzer (models:Tuple<OperationModel>,
                           mprops:Vector<ModelProperties>) -> ModelAnalyzer :
  new ModelAnalyzer :
    defmethod used-registers (this, op-id:Int, ctxt:UsageContext) -> UsedRegisters :
      val model = models[op-id]
      used-registers(model, ctxt)

;============================================================
;================== Model Interpretation ====================
;============================================================

;Compute the maximum number of used registers required
;to complete the given operation. This is the number
;of registers that must be free before beginning the
;operation. It does *not* imply anything about the number
;of used registers by the end of the operation (because
;of clear-registers).

;Represents the context in which an operation is used.
;This is necessary to compute the UsedRegisters.
;- args: Contains information about which arguments
;  are duplicated.
;- killed: Indicates which arguments are not live
;  after the instruction.
public defstruct UsageContext <: Hashable&Equalable :
  args:Tuple<Int>
  killed:Tuple<Int>
with:
  hashable => true
  equalable => true
  printer => true

;Compute the used registers by the model in the given usage context.
public defn used-registers (m:OperationModel, ctxt:UsageContext) -> UsedRegisters :
  ;Holds the type of each variable.  
  val loc-table = IntTable<Location>()

  ;Holds the registers that became available due to
  ;releasing arguments.
  val available-registers = Vector<Location>()

  ;Holds the registers that were newly created due
  ;to not having enough available registers.
  val fresh-registers = Vector<Location>()

  ;Holds the mapping from variables to their location.
  val variable-table = IntTable<Location|False>(false)

  ;Helper: Assign the given register to the given variable.
  defn assign-register (id:Int, reg:Location) :
    if variable-table[id] is-not False :
      fatal("Variable %_ is already assigned." % [id])
    variable-table[id] = reg

  ;Helper: Return true if the context specifies that the variable with
  ;the given id is killed.
  defn variable-killed? (id:Int) -> True|False :
    for index in killed(ctxt) any? :
      val arg = args(m)[index]
      /id(arg) == id

  ;Helper: Release the register currently assigned to the given variable.
  ;Return the register that was assigned.
  defn release-register (id:Int) -> False :
    if variable-table[id] is False :
      fatal("Variable %_ was not assigned." % [id])
    val reg = variable-table[id] as Location
    remove(variable-table, id)
    add(available-registers, reg)

  ;Helper: Assign the new register to the given variable,
  ;and return the register that was previously assigned
  ;to the variable.
  defn swap-register (id:Int, reg:Location) -> Location :
    if variable-table[id] is False :
      fatal("Variable %_ does not have an assigned register." % [id])
    val prev-reg = variable-table[id]
    variable-table[id] = reg
    prev-reg as Location

  ;Helper: If the given specific register is already assigned
  ;to a variable, then return the id of that variable.
  defn assigned-to-variable? (reg:Register) -> Int|False :
    value? $ for entry in variable-table first :
      if value(entry) == reg : One(key(entry))
      else : None()

  ;Helper: Retrieve an available register
  defn retrieve-available-register (loc:Location) -> Location :

    ;Compute the variable, if any, that currently occupies the
    ;given location.
    val assigned-variable = match(loc:Register) :
                              assigned-to-variable?(loc)

    ;Case: The location is occupied, so swap it out with some other location.
    match(assigned-variable:Int) :
      val general-reg = retrieve-available-register(type(loc))
      swap-register(assigned-variable, general-reg)
    ;Case: The location is not occupied, so choose a suitable available register.
    else :
      ;First look when the list of available registers.
      val available = index-when(matches-loc?{_, loc}, available-registers)
      match(available:Int) :
        val reg = available-registers[available]
        remove(available-registers, available)
        reg
      ;We didn't find one, so just create a fresh register.
      else :
        add(fresh-registers, loc)
        loc

  ;Helper: Return true if the given register matches against
  ;the desired register.
  defn matches-loc? (given:Location, desired:Location) -> True|False :
    match(given, desired) :
      (given:AnyReg|Reg, desired:AnyReg) : true
      (given:AnyFReg|FReg, desired:AnyFReg) : true
      (given:Reg, desired:Reg) : index(given) == index(desired)
      (given:FReg, desired:FReg) : index(given) == index(desired)
      (given, desired) : false

  ;Helper: Compute the number of used integer and floating-point registers
  ;based upon the current state.
  defn count-fresh-registers () -> [Int, Int] :
    var num-regs:Int = 0
    var num-fregs:Int = 0
    for loc in fresh-registers do :
      match(loc) :
        (loc:Reg|AnyReg) : num-regs = num-regs + 1
        (loc:FReg|AnyFReg) : num-fregs = num-fregs + 1
    [num-regs, num-fregs]

  ;Helper: Return true if 'v' is an argument.
  defn arg? (v:Int) -> True|False :
    v >= length(results(m)) and
    v < length(results(m)) + length(args(m))

  ;Helper: Compute the arg preferences in terms of the results.
  defn compute-arg-preferences () -> Tuple<Preference> :
    ;Store computed preferences in this table.
    val arg-pref-table = IntTable<Preference>(NoPreference())
    ;First look through results, and check whether any result
    ;prefers to be the same as the argument, and store an entry
    ;in arg-pref-table if so.
    for r in results(m) do :
      val pref = preference(r)
      match(pref:PreferSame) :
        if arg?(id(pref)) :
          arg-pref-table[id(pref)] = PreferSame(id(r))
    ;Then look through args, and check whether any argument requires
    ;or prefers a specific register. If so, this would override any
    ;computed PreferSame preference.
    for a in args(m) do :
      ;Requires specific register.
      match(location(a)) :
        (r:Register) : arg-pref-table[id(a)] = PreferRegister(r)
        (l) : false
      ;Prefers specific register.        
      val pref = preference(a)
      match(pref:PreferRegister) :
        arg-pref-table[id(a)] = pref
    ;Compute the tuple of preferences.
    for a in args(m) map :
      arg-pref-table[id(a)]

  ;Initialize the location table.
  for v in cat-all $ [results(m), args(m), temp(m)] do :
    loc-table[id(v)] = location(v)


  ;State: Store the computed number of registers here
  ;when ClearRegisters is executed.
  ;var used-regs:False|[Int,Int] = false

  ;For each of the arguments, put them in the variable table.
  for arg in args(m) do :
    assign-register(id(arg), location(arg))

  ;Evaluate each statement in the model in turn.
  label break :
    for stmt in stmts(m) do :
      match(stmt) :
        (stmt:Assign) :
          ;Assign a new register to a variable.
          ;Retrieve an appropriate register, and mark
          ;the variable as being assigned to that register.
          val loc = loc-table[id(stmt)]
          val reg = retrieve-available-register(loc)
          assign-register(id(stmt), reg)

        (stmt:Release) :
          ;Release a variable if it is killed.
          ;Retrieve the register that is currently assigned
          ;to that variable.
          ;Make the register available for later assignments.
          if variable-killed?(id(stmt)) :
            release-register(id(stmt))

        (stmt:ClearRegisters) :
          ;Nothing after the clear-registers affects the
          ;register-usage of the operation. So we're done.
          break()

        (stmt:Return) :
          ;No action. The function stops here.
          break()

  ;Return the result.
  val [num-regs, num-fregs] = count-fresh-registers()
  UsedRegisters(num-regs,
                num-fregs,
                compute-arg-preferences())
