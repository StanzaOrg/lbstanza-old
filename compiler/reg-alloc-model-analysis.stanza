defpackage stz/reg-alloc-model-analysis :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-engine

;Analyze the given operation models.
public defn analyze-models (models:Tuple<OperationModel>)
                         -> Vector<ModelProperties> :
  to-vector<ModelProperties>(seq(analyze, models))

;Analyze a single operation model.
defn analyze (m:OperationModel) -> ModelProperties :
  val returns? = any?({_ is Return}, stmts(m))
  val clears-registers? = any?({_ is ClearRegisters}, stmts(m))
  ModelProperties(id(m),
                  returns?,
                  clears-registers?)

;============================================================
;================== Model Interpretation ====================
;============================================================


;Compute the maximum number of used registers required
;to complete the given operation. This is the number
;of registers that must be free before beginning the
;operation. It does *not* imply anything about the number
;of used registers by the end of the operation (because
;of clear-registers).

;Represents the number of used integer and floating-point
;registers.
public defstruct UsedRegisters :
  used-regs:Int
  used-fregs:Int
  results:Tuple<Location>
with:
  printer => true

;Represents the context in which an operation is used.
;This is necessary to compute the UsedRegisters.
;- args: Contains information about which arguments
;  are duplicated.
;- killed: Indicates which arguments are not live
;  after the instruction.
public defstruct UsageContext <: Hashable&Equalable :
  args:Tuple<Int>
  killed:Tuple<Int>
with:
  hashable => true
  equalable => true
  printer => true

;Compute the used registers by the model in the given usage context.
public defn used-registers (m:OperationModel, ctxt:UsageContext) -> UsedRegisters :
  val available-registers = Vector<Location>()
  val fresh-registers = Vector<Location>()
  val variable-table = IntTable<Location|False>(false)

  ;Helper: Assign the given register to the given variable.
  defn assign-register (id:Int, reg:Location) :
    if variable-table[id] is-not False :
      fatal("Variable %_ is already assigned." % [id])
    variable-table[id] = reg

  ;Helper: Assign the new register to the given variable,
  ;and return the register that was previously assigned
  ;to the variable.
  defn swap-register (id:Int, reg:Location) -> Location :
    if variable-table[id] is False :
      fatal("Variable %_ does not have an assigned register." % [id])
    val prev-reg = variable-table[id]
    variable-table[id] = reg
    prev-reg as Location

  ;Helper: Retrieve the register that a given variable is in.
  defn variable-register (id:Int) -> Location :
    if variable-table[id] is False :
      fatal("Variable %_ was not assigned." % [id])
    variable-table[id] as Location

  ;Helper: If the given specific register is already assigned
  ;to a variable, then return the id of that variable.
  defn assigned-to-variable? (reg:Reg|FReg) -> Int|False :
    value? $ for entry in variable-table first :
      if value(entry) == reg : One(key(entry))
      else : None()

  ;Helper: Release the register currently assigned to the given variable.
  ;Return the register that was assigned.
  defn release-register (id:Int) -> Location :
    if variable-table[id] is False :
      fatal("Variable %_ was not assigned." % [id])
    val reg = variable-table[id]
    remove(variable-table, id)
    reg as Location

  ;Helper: Return true if the context specifies that the variable with
  ;the given id is killed.
  defn variable-killed? (id:Int) -> True|False :
    if contains?(temp(m), id) :
      true
    else :
      for index in killed(ctxt) any? :
        val arg = args(m)[index]
        /id(arg) == id

  ;Helper: Indicate that the given location is
  ;now available to be used.
  defn make-available (loc:Location) -> False :
    add(available-registers, loc)

  ;Helper: Retrieve an available register
  defn retrieve-available-register (loc:Location) -> Location :
    ;If we are requesting a specific register, and the register
    ;is already assigned to a variable.
    ;  Retrieve a general register and swap with
    ;  that variable.
    ;Otherwise:
    ;  Look within available-registers for a matching register.
    ;  If found, then return it, and remove from available registers.
    ;  If not found, create a fresh register, and return that.
    
    val assigned-variable = match(loc:Reg|FReg) :
                              assigned-to-variable?(loc)
    match(assigned-variable:Int) :
      val general-loc = AnyReg() when loc is Reg
                   else AnyFReg()
      val general-reg = retrieve-available-register(general-loc)
      swap-register(assigned-variable, general-reg)
    else :
      val available = index-when(matches-loc?{_, loc}, available-registers)
      match(available:Int) :
        val reg = available-registers[available]
        remove(available-registers, available)
        reg
      else :
        add(fresh-registers, loc)
        loc

  ;Helper: Return true if the given register matches against
  ;the desired register.
  defn matches-loc? (given:Location, desired:Location) -> True|False :
    match(given, desired) :
      (given:AnyReg|Reg, desired:AnyReg) : true
      (given:AnyFReg|FReg, desired:AnyFReg) : true
      (given:Reg, desired:Reg) : index(given) == index(desired)
      (given:FReg, desired:FReg) : index(given) == index(desired)
      (given, desired) : false

  ;Helper: Clear all registers
  defn clear-all-registers () -> False :
    clear(available-registers)
    clear(fresh-registers)
    clear(variable-table)

  ;Helper: Compute the number of used integer and floating-point registers
  ;based upon the current state.
  defn used-registers () -> [Int, Int] :
    var num-regs:Int = 0
    var num-fregs:Int = 0
    for loc in fresh-registers do :
      match(loc) :
        (loc:Reg|AnyReg) : num-regs = num-regs + 1
        (loc:FReg|AnyFReg) : num-fregs = num-fregs + 1
    [num-regs, num-fregs]

  ;State: Store the computed number of registers here
  ;when ClearRegisters is executed.
  var used-regs:False|[Int,Int] = false

  ;For each of the arguments, put them in the variable table.
  for arg in args(m) do :
    assign-register(id(arg), location(arg))

  ;Evaluate each statement in the model in turn.
  for stmt in stmts(m) do :
    match(stmt) :
      (stmt:Assign) :
        ;Assign a new register to a variable.
        ;Retrieve an appropriate register, and mark
        ;the variable as being assigned to that register.
        val reg = retrieve-available-register(location(stmt))
        assign-register(arg(stmt), reg)

      (stmt:Release) :
        ;Release a variable if it is killed.
        ;Retrieve the register that is currently assigned
        ;to that variable.
        ;Make the register available for later assignments.
        if variable-killed?(arg(stmt)) :
          val reg = release-register(arg(stmt))
          make-available(reg)

      (stmt:ClearRegisters) :
        ;Compute the UsedRegisters from current state
        ;of algorithm, and then clear all the registers.
        used-regs = used-registers()
        clear-all-registers()

      (stmt:Return) :
        ;No action.
        ;But assume that the function stops here.

        false

  ;If used-regs hasn't already been calculated due to ClearRegisters,
  ;then calculate it now.
  if used-regs is False :
    used-regs = used-registers()

  ;Record which register each result is in.
  val result-regs = for arg in results(m) map :
    variable-register(arg)

  ;Return the result.
  val [num-regs, num-fregs] = used-regs as [Int,Int]
  UsedRegisters(num-regs, num-fregs, result-regs)
