defpackage stz/reg-alloc-model-analysis :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-engine

;Analyze the given operation models.
public defn analyze-models (models:Tuple<OperationModel>)
                         -> Vector<ModelProperties> :
  to-vector<ModelProperties>(seq(analyze, models))

;Analyze a single operation model.
defn analyze (m:OperationModel) -> ModelProperties :
  val returns? = any?({_ is Return}, stmts(m))
  val clears-registers? = any?({_ is ClearRegisters}, stmts(m))
  ModelProperties(id(m),
                  returns?,
                  clears-registers?)

;============================================================
;================== Model Interpretation ====================
;============================================================


;Compute the maximum number of used registers required
;to complete the given operation. This is the number
;of registers that must be free before beginning the
;operation. It does *not* imply anything about the number
;of used registers by the end of the operation (because
;of clear-registers).

;Represents the number of used integer and floating-point
;registers.
public defstruct UsedRegisters :
  used-regs:Int
  used-fregs:Int
  results:Tuple<Location>
with:
  printer => true

;Represents the context in which an operation is used.
;This is necessary to compute the UsedRegisters.
;- args: Contains information about which arguments
;  are duplicated.
;- killed: Indicates which arguments are not live
;  after the instruction.
public defstruct UsageContext <: Hashable&Equalable :
  args:Tuple<Int>
  killed:Tuple<Int>
with:
  hashable => true
  equalable => true
  printer => true

;Compute the used registers by the model in the given usage context.
public defn used-registers (m:OperationModel, ctxt:UsageContext) -> UsedRegisters :
  val available-registers = Vector<Location>()
  val fresh-registers = Vector<Location>()
  val variable-table = IntTable<Location|False>(false)

  ;Helper: Assign the given register to the given variable.
  defn assign-register (id:Int, reg:Location) :
    if variable-table[id] is-not False :
      fatal("Variable %_ is already assigned." % [id])
    variable-table[id] = reg

  ;Helper: Retrieve the register that a given variable is in.
  defn variable-register (id:Int) -> Location :
    if variable-table[id] is False :
      fatal("Variable %_ was not assigned." % [id])
    variable-table[id] as Location

  ;Helper: Release the register currently assigned to the given variable.
  ;Return the register that was assigned.
  defn release-register (id:Int) -> Location :
    if variable-table[id] is False :
      fatal("Variable %_ was not assigned." % [id])
    val reg = variable-table[id]
    remove(variable-table, id)
    reg as Location

  ;Helper: Indicate that the given location is
  ;now available to be used.
  defn make-available (loc:Location) -> False :
    add(available-registers, loc)

  ;Helper: Retrieve an available register
  defn retrieve-available-register (loc:Location) -> Location :
    ;Iterate through available-registers and find
    ;one that satisfies the request.
    val available = index-when(matches-loc?{_, loc}, available-registers)

    ;If one is found, then return it, and remove it
    ;from the list of available.
    match(available:Int) :
      val reg = available-registers[available]
      remove(available-registers, available)
      reg
    ;If one is not found, then create a fresh variable.
    else :
      add(fresh-registers, loc)
      loc

  ;Helper: Return true if the given register matches against
  ;the desired register.
  defn matches-loc? (given:Location, desired:Location) -> True|False :
    match(given, desired) :
      (given:AnyReg|Reg, desired:AnyReg) : true
      (given:AnyFReg|FReg, desired:AnyFReg) : true
      (given:AnyReg, desired:Reg) : true
      (given:Reg, desired:Reg) : index(given) == index(desired)
      (given:AnyFReg, desired:FReg) : true
      (given:FReg, desired:FReg) : index(given) == index(desired)

  ;Helper: Clear all registers
  defn clear-all-registers () -> False :
    clear(available-registers)
    clear(fresh-registers)
    clear(variable-table)

  ;Helper: Compute the number of used integer and floating-point registers
  ;based upon the current state.
  defn used-registers () -> [Int, Int] :
    var num-regs:Int = 0
    var num-fregs:Int = 0
    for loc in fresh-registers do :
      match(loc) :
        (loc:Reg|AnyReg) : num-regs = num-regs + 1
        (loc:FReg|AnyFReg) : num-fregs = num-fregs + 1
    [num-regs, num-fregs]

  ;State: Store the computed number of registers here
  ;when ClearRegisters is executed.
  var used-regs:False|[Int,Int] = false

  ;For each of the arguments, put them in the variable table.
  for arg in args(m) do :
    assign-register(id(arg), location(arg))

  ;Evaluate each statement in the model in turn.
  for stmt in stmts(m) do :
    match(stmt) :
      (stmt:Assign) :
        ;Assign a new register to a variable.
        ;Retrieve an appropriate register, and mark
        ;the variable as being assigned to that register.
        val reg = retrieve-available-register(location(stmt))
        assign-register(arg(stmt), reg)

      (stmt:Release) :
        ;Release a variable.
        ;Retrieve the register that is currently assigned
        ;to that variable.
        ;Make the register available for later assignments.
        val reg = release-register(arg(stmt))
        make-available(reg)

      (stmt:ClearRegisters) :
        ;Compute the UsedRegisters from current state
        ;of algorithm, and then clear all the registers.
        used-regs = used-registers()
        clear-all-registers()

      (stmt:Return) :
        ;No action.
        ;But assume that the function stops here.

        false

  ;If used-regs hasn't already been calculated due to ClearRegisters,
  ;then calculate it now.
  if used-regs is False :
    used-regs = used-registers()

  ;Record which register each result is in.
  val result-regs = for arg in results(m) map :
    variable-register(arg)

  ;Return the result.
  val [num-regs, num-fregs] = used-regs as [Int,Int]
  UsedRegisters(num-regs, num-fregs, result-regs)
