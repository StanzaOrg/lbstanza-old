defpackage stz/reg-alloc-model-analysis :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-engine

;Analyze the given operation models.
public defn analyze-models (models:Tuple<OperationModel>)
                         -> Vector<ModelProperties> :
  to-vector<ModelProperties>(seq(analyze, models))

;Analyze a single operation model.
defn analyze (m:OperationModel) -> ModelProperties :
  val returns? = any?({_ is Return}, stmts(m))
  val clears-registers? = any?({_ is ClearRegisters}, stmts(m))
  ModelProperties(id(m),
                  returns?,
                  clears-registers?)
  
;============================================================
;================== Model Interpretation ====================
;============================================================


;Compute the maximum number of used registers required
;to complete the given operation. This is the number
;of registers that must be free before beginning the
;operation. It does *not* imply anything about the number
;of used registers by the end of the operation (because
;of clear-registers). 

;Represents the number of used integer and floating-point
;registers.
public defstruct UsedRegisters :
  used-regs:Int
  used-fregs:Int
with:
  printer => true

;Represents the context in which an operation is used.
;This is necessary to compute the UsedRegisters.
;- args: Contains information about which arguments
;  are duplicated.
;- killed: Indicates which arguments are not live
;  after the instruction.
public defstruct UsageContext <: Hashable&Equalable :
  args:Tuple<Int>
  killed:Tuple<Int>
with:
  hashable => true
  equalable => true
  printer => true

;Compute the used registers by the model in the given usage context.
;defn used-registers (m:OperationModel, ctxt:UsageContext) -> UsedRegisters :
;  var num-required-regs:Int = 0
;  var num-available-regs:Int = 0
;  val used-regs:
;  
;  val table = fatal("make table")
;  for stmt in stmts(m) do :
;    match(stmt) :
;      (stmt:Require) :
;        match(location(stmt)) :
;          (l:AnyReg|Reg) : used-regs = used-regs + 1
;          (l:AnyFReg|FReg) : used-fregs = used-fregs + 1
;      (stmt:Release) :
;        match(location-table[arg(stmt)]) :
;          (l:AnyReg|Reg) : add(free-reg, arg(stmt))
;          (l:AnyFReg|FReg) : add(free-freg, arg(stmt))
;      (stmt:Return) :
;        false
;      (stmt:ClearRegisters) :
;        false
