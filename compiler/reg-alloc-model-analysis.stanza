defpackage stz/reg-alloc-model-analysis :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-engine

;Analyze the given operation models.
public defn analyze-models (models:Tuple<OperationModel>)
                         -> Vector<ModelProperties> :
  to-vector<ModelProperties>(seq(analyze, models))

;Analyze a single operation model.
defn analyze (m:OperationModel) -> ModelProperties :
  val returns? = any?({_ is Return}, stmts(m))
  val clears-registers? = any?({_ is ClearRegisters}, stmts(m))
  ModelProperties(id(m),
                  returns?,
                  clears-registers?)
  
;============================================================
;================== Model Interpretation ====================
;============================================================
;<comment>
;Compute the maximum number of registers required for the
;given operation. The output is represented like this:
;
;  2 - (1 for each [V0, V1] killed)
;
;which means to calculate the maximum number of registers, start
;with 2, and then subtract 1 if V0 is killed during this operation,
;and then subtract 1 if V1 is killed during this operation.

;- used-regs/used-fregs: These indicate the
;  number of registers required for invoking the operation.
defstruct MaximumRegisters :
  used-regs:NumRegs
  used-fregs:NumRegs
  
;- value: The starting number of registers.
;- subtract-for-each-killed: Subtract 1 for each of the arguments
;  that appear in the list that are killed.
defstruct NumRegs :
  value:Int
  subtract-for-each-killed:Tuple<Int>

defn maximum-used-registers (m:OperationModel) -> MaximumRegisters :
  var num-required-regs:Int = 0
  var num-available-regs:Int = 0
  val used-regs:
  
  val table = fatal("make table")
  for stmt in stmts(m) do :
    match(stmt) :
      (stmt:Require) :
        match(location(stmt)) :
          (l:AnyReg|Reg) : used-regs = used-regs + 1
          (l:AnyFReg|FReg) : used-fregs = used-fregs + 1
      (stmt:Release) :
        match(location-table[arg(stmt)]) :
          (l:AnyReg|Reg) : add(free-reg, arg(stmt))
          (l:AnyFReg|FReg) : add(free-freg, arg(stmt))
      (stmt:Return) :
        false
      (stmt:ClearRegisters) :
        false
        
;<comment>