defpackage stz/earley-syntax-package :
  import core
  import collections
  import stz/earley-lang
  import stz/algorithms
  import stz/utils

;============================================================
;================= AnalyzedSyntaxPackage ====================
;============================================================
public defstruct AnalyzedSyntaxPackage :
  name: Symbol
  exps: Tuple<SyntaxExp> with: (updater => sub-exps)
  idtable: Tuple<KeyValue<Symbol,Int>>

;============================================================
;================== Pattern Resolution ======================
;============================================================

deftype SyntaxPackageTables
defmulti get (t:SyntaxPackageTables, name:Symbol) -> SyntaxPackage|False

defn resolve (base:SyntaxPackage, overlays:Tuple<SyntaxPackage>, tables:SyntaxPackageTables) -> AnalyzedSyntaxPackage|PatternResolutionErrors :
  ;Error Buffer
  val errors = Vector<PatternResolutionError>()
  defn error! (e:PatternResolutionError) : add(errors, e)

  ;Gather table of all imported packages
  defn gather-imported-packages () -> HashTable<Symbol,SyntaxPackage|False> :
    val packages = HashTable<Symbol,SyntaxPackage|False>()

    ;Gather transitively imported packages
    defn gather (e:ImportExp) :
      ;Bring in package if not already loaded.
      if not key?(packages, package(e)) :
        val pkg = tables[package(e)]
        packages[package(e)] = pkg
        match(pkg:SyntaxPackage) :
          do(gather, filter-by<ImportExp>(exps(pkg)))
      if get?(packages, package(e)) is False :
        error!(MissingImportedPackage(info(e), package(e)))

    ;Initialize package table with initial packages.
    defn put-in-table (p:SyntaxPackage) : packages[name(p)] = p
    put-in-table(base)
    do(put-in-table, overlays)
    
    ;Call gather on all initial import expressions    
    val initial-imports = 
      for p in values(packages) seq-cat :
        filter-by<ImportExp>(exps(p as SyntaxPackage))
    do(gather, initial-imports)

    ;Return package table
    packages

  ;Assign unique ids for all packages
  defn assign-ids (packages:HashTable<Symbol,SyntaxPackage|False>) -> ProductionTable :
    val prodtable = ProductionTable()
    defn assign-ids (pkg:SyntaxPackage) -> SyntaxPackage :
      defn register-id (info:FileInfo|False, prod-name:Symbol, public?:True|False) -> Int|False :
        match(register(prodtable, name(pkg), prod-name, public?)) :
          (id:Int) :
            id
          (e:ProductionExists) :
            error!(CannotDefineDuplicateProduction(info, prod-name))
            false
      val exps* = for e in exps(pkg) map :
        match(e) :
          (e:DefProductionExp) :
            sub-id(e, register-id(info(e), name(e), public?(e)))
          (e:DefKeywordsExp) :
            sub-id(e, register-id(info(e), name(e), public?(e)))
          (e:DefProductionsExp) :
            val clones* = for e in clones(e) map :
              sub-id(e, register-id(info(e), name(e), public?(e)))
            sub-clones(e, clones*)
          (e) : e
      SyntaxPackage(name(pkg), exps*)
    for entry in packages map! :
      match(value(entry)) :
        (pkg:SyntaxPackage) : assign-ids(pkg)
        (f:False) : false
    prodtable

  ;Resolve ids
  defn resolve-ids (p:SyntaxPackage, prodtable:ProductionTable) -> SyntaxPackage :
    ;Create idtable to use for resolving ids in this package.
    defn build-idtable () :
      ;Get initial entries
      val entries = for e in exps(p) seq-cat :
        match(e) :
          (e:DefProductionExp) :
            [name(e) => id(e)]
          (e:DefKeywordsExp) :
            [name(e) => id(e)]
          (e:DefProductionsExp) :
            for e in clones(e) seq :
              name(e) => id(e)
          (e:ImportExp) :
            match(prodtable[package(e), name(e), true]) :
              (id:Int) :
                [name(e) => id]
              (s:ProductionMissing) :
                error!(CannotResolveImportedProduction(info(e), package(e), name(e)))
                []
              (s:ProductionNotPublic) :
                error!(CannotImportNonPublicProduction(info(e), package(e), name(e)))
                []
      ;Filter and build table
      to-hashtable<Symbol,Int>(filtered-entries as Seq<KeyValue<Symbol,Int>>) where :
        val filtered-entries = filter({value(_) is Int}, entries)

    ;Use the following idtable to resolve expressions
    val idtable = build-idtable()

    ;Try to resolve the given production. Issues an error if
    ;it cannot be resolved.
    defn resolve-id (info:FileInfo|False, prod:Symbol) -> Int|False :
      val id = get?(idtable,prod)
      match(id:False) :
        error!(CannotResolveProduction(info, prod))
      id

    ;Resolve all productions in the given pattern.    
    defn resolve (info:FileInfo|False, p:Pattern) -> Pattern :
      let loop (p:Pattern = p) :
        match(p:Production) : sub-id(p, resolve-id(info, name(p)))
        else : map(loop, p)

    ;Resolve all productions in the given expression.
    defn resolve (e:SyntaxExp) -> SyntaxExp :
      match(e) :
        (e:DefProductionsExp) :
          val clones* = for e in clones(e) map :
            sub-prod-id(e, resolve-id(info(e), prod(e)))
          sub-clones(e, clones*)
        (e:DefKeywordRuleExp) :
          val id* = resolve-id(info(e), production(e))
          val pattern* = resolve(info(e), pattern(e))
          sub-pattern(sub-id(e, id*), pattern*)
        (e:DefNotRuleExp) :
          val id* = resolve-id(info(e), production(e))
          val pattern* = resolve(info(e), pattern(e))
          sub-pattern(sub-id(e, id*), pattern*)
        (e:DefRuleExp) :
          val id* = resolve-id(info(e), production(e))
          val pattern* = resolve(info(e), pattern(e))
          sub-pattern(sub-id(e, id*), pattern*)
        (e:ImportExp) :
          sub-id(e, get?(idtable, name(e)))
          
    ;Launch!      
    SyntaxPackage(name(p), map(resolve, exps(p)))

  ;Retrieve all public ids in syntax package
  defn public-ids (p:SyntaxPackage) -> Tuple<KeyValue<Symbol,Int>> :
    to-tuple $ for e in exps(p) seq-cat :
      match(e) :
        (e:DefProductionExp) :
          if public?(e) : [name(e) => id(e) as Int]
          else : []
        (e:DefKeywordsExp) :
          if public?(e) : [name(e) => id(e) as Int]
          else : []
        (e:DefProductionsExp) :
          for e in clones(e) seq? :
            if public?(e) : One(name(e) => id(e) as Int)
            else : None()
        (e) : []

  ;Main algorithm
  defn main () :
    val packages = gather-imported-packages()
    val prodtable = assign-ids(packages)
    for entry in packages map! :
      val pkg = value(entry)
      match(pkg:SyntaxPackage) :
        resolve-ids(pkg, prodtable)
    if empty?(errors) :
      val all-exps = to-tuple $
        for package in values(packages) seq-cat :
          for e in exps(package as SyntaxPackage) filter :
            e is-not ImportExp
      AnalyzedSyntaxPackage(name(base), all-exps, public-ids(base))
    else :
      PatternResolutionErrors(to-tuple(errors))

  ;Launch!
  main()
  
;============================================================
;================ Resolve Against Base ======================
;============================================================

defn resolve (package:AnalyzedSyntaxPackage, p:Pattern, info:FileInfo|False) -> Pattern|PatternResolutionErrors :
  ;Public identifier table of package  
  val idtable = to-hashtable<Symbol,Int>(idtable(package))

  ;Accumulate errors here.
  val errors = Vector<PatternResolutionError>()  
  
  ;Try to resolve the given production. Issues an error if
  ;it cannot be resolved.
  defn resolve-id (prod:Symbol) -> Int|False :
    val id = get?(idtable,prod)
    match(id:False) :
      add(errors, CannotResolveProduction(info, prod))
    id

  ;Resolve all productions in the given pattern.    
  defn resolve (p:Pattern) -> Pattern :
    match(p:Production) : sub-id(p, resolve-id(name(p)))
    else : map(resolve, p)

  ;Launch!
  val p* = resolve(p)
  if empty?(errors) : p*
  else : PatternResolutionErrors(to-tuple(errors))

;============================================================
;==================== Production Table ======================
;============================================================

deftype ProductionTable
defmulti register (t:ProductionTable, package:Symbol, prod:Symbol, public?:True|False) -> Int|ProductionStatus
defmulti get (t:ProductionTable, package:Symbol, prod:Symbol, only-public?:True|False) -> Int|ProductionStatus

defn ProductionTable () :
  val idtable = HashTable<[Symbol,Symbol],ProductionId|False>()
  new ProductionTable :
    defmethod register (this, package:Symbol, prod:Symbol, public?:True|False) :
      val k = [package,prod]
      if key?(idtable,k) :
        ProductionExists
      else :
        val id = genid()
        idtable[[package,prod]] = ProductionId(id, public?)
        id
    defmethod get (this, package:Symbol, prod:Symbol, only-public?:True|False) :
      match(get?(idtable, [package,prod])) :
        (pid:ProductionId) :
          if only-public? and not public?(pid) : ProductionNotPublic
          else : id(pid)
        (f:False) :
          ProductionMissing

defstruct ProductionId :
  id: Int
  public?: True|False

defenum ProductionStatus :
  ProductionMissing
  ProductionNotPublic
  ProductionExists

;============================================================
;================= Pattern Cloning ==========================
;============================================================

defn clone-patterns (p:AnalyzedSyntaxPackage) -> AnalyzedSyntaxPackage|PatternResolutionErrors :
  ;Check for cycles in cloning graph.
  defn check-cloning-cycles () -> PatternResolutionErrors|False :
    ;Collect information about clones and
    ;cloning edges.
    val clone-def = IntTable<CloneDef>()
    val entries = Vector<KeyValue<Int,Int>>()
    for e in exps(p) do :
      match(e:DefProductionsExp) :
        for e in clones(e) do :
          val clone-id = id(e) as Int
          val prod-id = prod-id(e) as Int
          add(entries, clone-id => prod-id)
          clone-def[clone-id] = CloneDef(info(e), name(e))
    ;Create cyclic cloning errors if any.
    val errors = Vector<MutuallyCyclicClones>()
    val cycles = filter-by<List<Int>>(strong-components(entries*)) where :
      val entries* = for e in entries seq :
        key(e) => List(value(e))
    for ids in cycles do :
      val clones = to-tuple $ seq({clone-def[_]}, ids)
      add(errors, MutuallyCyclicClones(clones))
    PatternResolutionErrors(to-tuple(errors)) when not empty?(errors)

  ;Discover cloning groups.
  ;Entry (a, b, c) means that productions 'a', 'b', and 'c' reference each other,
  ;and must be cloned together.
  defn clone-groups () -> Tuple<List<Int>> :
    ;Gather cloning edges
    val edges = HashSet<KeyValue<Int,Int>>()
    defn scan (e:SyntaxExp) :
      match(e) :
        (e:DefKeywordRuleExp) : scan(id(e) as Int, pattern(e))
        (e:DefNotRuleExp) : scan(id(e) as Int, pattern(e))
        (e:DefRuleExp) : scan(id(e) as Int, pattern(e))
        (e) : false
    defn scan (prod:Int, p:Pattern) :
      match(p:Production) : add(edges, prod => id(p) as Int)
      else : do(scan{prod, _}, p)
    do(scan, exps(p))
    
    ;Discover reference cycles
    val grouped-edges = group-by(key, value, edges)
    to-tuple(filter-by<List<Int>>(strong-components(grouped-edges)))

  ;Find all clone substitutions.
  defn clone-substitutions (cycles:Tuple<List<Int>>) -> Vector<CloneSubstitution> :
    ;Accumulate all substitutions
    val subs = Vector<CloneSubstitution>()
    
    ;Compute cycle index of each clone.
    val cycle-ids = IntTable<Int>()
    for (ids in cycles, index in 0 to false) do :
      for id in ids do :
        cycle-ids[id] = index

    ;Create substitutions for given productions exp.
    defn create-subs (e:DefProductionsExp) :
      ;Categorize as cycle clones and no-cycle clones.
      val no-cycle-clones = to-tuple $
        for c in clones(e) filter :
          not key?(cycle-ids, prod-id(c) as Int)
      val cycle-clones = to-tuple $
        for c in clones(e) group-by :
          cycle-ids[prod-id(c) as Int]
      ;Create substitutions for non-cycle clones.
      for clone in no-cycle-clones do :
        val new-id = id(clone) as Int
        val old-id = prod-id(clone) as Int
        add(subs, CloneSubstitution(new-id, old-id, false))
      ;Create substitutions for cycle clones.
      for entries in cycle-clones do :
        val index = key(entries)
        val clones = value(entries)
        ;Construct substitution table.
        val subtable = IntTable<Int>()
        for c in clones do :
          subtable[prod-id(c) as Int] = id(c) as Int
        for id in cycles[index] do :
          if not key?(subtable, id) :
            subtable[id] = genid()
        ;Create substitutions
        for entry in subtable do :
          add(subs, CloneSubstitution(value(entry), key(entry), subtable))

    ;Create all substitutions
    do(create-subs, filter-by<DefProductionsExp>(exps(p)))
    subs
    
  ;Perform clone substitutions
  defn perform-substitutions (subs:Vector<CloneSubstitution>) -> Tuple<SyntaxExp> :

    ;Perform given substitutions on pattern 'p' if table is given.
    defn make-substitutions (p:Pattern, f:False) :
      p
    defn make-substitutions (p:Pattern, table:IntTable<Int>) :
      match(p:Production) : sub-id(p, get?(table, id(p) as Int, id(p) as Int))
      else : map(make-substitutions{_, table}, p)
      
    ;Create a new SyntaxExp resulting from applying the given
    ;CloneSubstitution.
    defn make-clone (e:DefProductionExp, s:CloneSubstitution) :
      sub-id(e, new-id(s))
    defn make-clone (e:DefKeywordsExp, s:CloneSubstitution) :
      sub-id(e, new-id(s))
    defn make-clone (e:DefKeywordRuleExp, s:CloneSubstitution) :
      val pattern* = make-substitutions(pattern(e), subtable(s))
      sub-pattern(sub-id(e, new-id(s)), pattern*)
    defn make-clone (e:DefNotRuleExp, s:CloneSubstitution) :
      val pattern* = make-substitutions(pattern(e), subtable(s))
      sub-pattern(sub-id(e, new-id(s)), pattern*)
    defn make-clone (e:DefRuleExp, s:CloneSubstitution) :
      val pattern* = make-substitutions(pattern(e), subtable(s))
      sub-pattern(sub-id(e, new-id(s)), pattern*)
    defn make-clone (e:SyntaxExp, f:False) :
      false

    ;Add a new expression to the given vector if it is not false.
    defn add? (es:Vector<SyntaxExp>, e:SyntaxExp|False) :
      match(e:SyntaxExp) : add(es, e)

    ;Table of all substitutions keyed by their old-id.
    val sub-table = to-inttable(old-id, subs)

    ;Hold final accumulated expressions.
    val accum = Vector<SyntaxExp>()

    ;Hold working queue of expressions.
    val queue = Queue<SyntaxExp>()

    ;Process every expression
    do(add{queue, _}, exps(p))
    while not empty?(queue) :
      match(pop(queue)) :
        (e:DefProductionExp) :
          add(accum, e)
          add?(accum, make-clone(e, get?(sub-table, id(e) as Int)))
        (e:DefKeywordsExp) :
          add(accum, e)
          add?(accum, make-clone(e, get?(sub-table, id(e) as Int)))
        (e:DefKeywordRuleExp) :
          add(accum, e)
          add?(accum, make-clone(e, get?(sub-table, id(e) as Int)))
        (e:DefNotRuleExp) :
          add(accum, e)
          add?(accum, make-clone(e, get?(sub-table, id(e) as Int)))
        (e:DefRuleExp) :
          add(accum, e)
          add?(accum, make-clone(e, get?(sub-table, id(e) as Int)))
        (e:DefProductionsExp) :
          false
          
    ;Return final expressions      
    to-tuple(accum)      

  ;Main algorithm
  defn main () :
    match(check-cloning-cycles()) :
      (es:PatternResolutionErrors) :
        es
      (f:False) :
        val clone-subs = clone-substitutions(clone-groups())
        val exps* = perform-substitutions(clone-subs)
        sub-exps(p, exps*)
       
  ;Launch! 
  main()

;This object means that production 'old-id' should be cloned as
;production 'new-id' and the table 'subtable' should be used as
;substitutions.
defstruct CloneSubstitution :
  new-id: Int
  old-id: Int
  subtable: IntTable<Int>|False

;============================================================
;===================== Errors ===============================
;============================================================

public deftype PatternResolutionError <: Exception

public defstruct PatternResolutionErrors <: Exception :
  errors: Tuple<PatternResolutionError>

public defstruct CannotResolveProduction <: PatternResolutionError :
  info: FileInfo|False
  production: Symbol

public defstruct CannotResolveImportedProduction <: PatternResolutionError :
  info: FileInfo|False
  package: Symbol
  production: Symbol

public defstruct CannotImportNonPublicProduction <: PatternResolutionError :
  info: FileInfo|False
  package: Symbol
  production: Symbol

public defstruct MissingImportedPackage <: PatternResolutionError :
  info: FileInfo|False
  package: Symbol

public defstruct CannotDefineDuplicateProduction <: PatternResolutionError :
  info: FileInfo|False
  production: Symbol

public defstruct MutuallyCyclicClones <: PatternResolutionError :
  clones: Tuple<CloneDef>

public defstruct CloneDef :
  info: FileInfo|False
  name: Symbol