defpackage stz/earley-syntax-package :
  import core
  import collections
  import stz/earley-lang
  import stz/algorithms
  import stz/utils
  import stz/earley-grammar

;============================================================
;================= Analysis Launcher ========================
;============================================================

public defn analyze (base:SyntaxPackage,
                     overlays:Tuple<SyntaxPackage>,
                     tables:SyntaxPackageTables) -> AnalyzedSyntaxPackage|
                                                    PatternResolutionErrors|
                                                    KeywordProductionErrors :
  match(resolve(lift-clones(base), map(lift-clones,overlays), tables)) :
    (e:PatternResolutionErrors) :
      e
    (p:AnalyzedSyntaxPackage) :
      match(clone-patterns(p)) :
        (e:PatternResolutionErrors) :
          e
        (p:AnalyzedSyntaxPackage) :
          analyze-keyword-sets(p)

;============================================================
;================= AnalyzedSyntaxPackage ====================
;============================================================
public defstruct AnalyzedSyntaxPackage :
  name: Symbol
  exps: Tuple<SyntaxExp> with: (updater => sub-exps)
  idtable: Tuple<KeyValue<Symbol,Int>>

;============================================================
;================= Simple Preprocessing =====================
;============================================================

defn lift-clones (p:SyntaxPackage) -> SyntaxPackage :
  val exps* = for e in exps(p) map :
    match(e:DefCloneExp) :
      DefProductionsExp(info(e), [e])
    else : e
  sub-exps(p, exps*)

;============================================================
;================== Pattern Resolution ======================
;============================================================

public deftype SyntaxPackageTables
public defmulti get (t:SyntaxPackageTables, name:Symbol) -> SyntaxPackage|False

defn resolve (base:SyntaxPackage, overlays:Tuple<SyntaxPackage>, tables:SyntaxPackageTables) -> AnalyzedSyntaxPackage|PatternResolutionErrors :
  ;Error Buffer
  val errors = Vector<PatternResolutionError>()
  defn error! (e:PatternResolutionError) : add(errors, e)

  ;Gather table of all imported packages
  defn gather-imported-packages () -> HashTable<Symbol,SyntaxPackage|False> :
    val packages = HashTable<Symbol,SyntaxPackage|False>()

    ;Gather transitively imported packages
    defn gather (e:ImportExp) :
      ;Bring in package if not already loaded.
      if not key?(packages, package(e)) :
        val pkg = tables[package(e)]
        packages[package(e)] = pkg
        match(pkg:SyntaxPackage) :
          do(gather, filter-by<ImportExp>(exps(pkg)))
      if get?(packages, package(e)) is False :
        error!(MissingImportedPackage(info(e), package(e)))

    ;Initialize package table with initial packages.
    defn put-in-table (p:SyntaxPackage) : packages[name(p)] = p
    put-in-table(base)
    do(put-in-table, overlays)
    
    ;Call gather on all initial import expressions    
    val initial-imports = 
      for p in values(packages) seq-cat :
        filter-by<ImportExp>(exps(p as SyntaxPackage))
    do(gather, initial-imports)

    ;Return package table
    packages

  ;Assign unique ids for all packages
  defn assign-ids (packages:HashTable<Symbol,SyntaxPackage|False>) -> ProductionTable :
    val prodtable = ProductionTable()
    defn assign-ids (pkg:SyntaxPackage) -> SyntaxPackage :
      defn register-id (info:FileInfo|False, prod-name:Symbol, public?:True|False) -> Int|False :
        match(register(prodtable, name(pkg), prod-name, public?)) :
          (id:Int) :
            id
          (e:ProductionExists) :
            error!(CannotDefineDuplicateProduction(info, prod-name))
            false
      val exps* = for e in exps(pkg) map :
        match(e) :
          (e:DefProductionExp) :
            sub-id(e, register-id(info(e), name(e), public?(e)))
          (e:DefKeywordsExp) :
            sub-id(e, register-id(info(e), name(e), public?(e)))
          (e:DefProductionsExp) :
            val clones* = for e in clones(e) map :
              sub-id(e, register-id(info(e), name(e), public?(e)))
            sub-clones(e, clones*)
          (e) : e
      SyntaxPackage(name(pkg), exps*)
    for entry in packages map! :
      match(value(entry)) :
        (pkg:SyntaxPackage) : assign-ids(pkg)
        (f:False) : false
    prodtable

  ;Resolve ids
  defn resolve-ids (p:SyntaxPackage, prodtable:ProductionTable) -> SyntaxPackage :
    ;Create idtable to use for resolving ids in this package.
    defn build-idtable () :
      ;Get initial entries
      val entries = Vector<KeyValue<Symbol,Int|False>>()
      for e in exps(p) do :
        match(e) :
          (e:DefProductionExp) :
            add(entries, name(e) => id(e))
          (e:DefKeywordsExp) :
            add(entries, name(e) => id(e))
          (e:DefProductionsExp) :
            for e in clones(e) do :
              add(entries, name(e) => id(e))
          (e:ImportExp) :
            match(prodtable[package(e), name(e), true]) :
              (id:Int) :
                add(entries, name(e) => id)
              (s:ProductionMissing) :
                error!(CannotResolveImportedProduction(info(e), package(e), name(e)))
              (s:ProductionNotPublic) :
                error!(CannotImportNonPublicProduction(info(e), package(e), name(e)))
          (e) :
            false
      ;Filter and build table
      to-hashtable<Symbol,Int>(filtered-entries as Seq<KeyValue<Symbol,Int>>) where :
        val filtered-entries = filter({value(_) is Int}, entries)

    ;Use the following idtable to resolve expressions
    val idtable = build-idtable()

    ;Try to resolve the given production. Issues an error if
    ;it cannot be resolved.
    defn resolve-id (info:FileInfo|False, prod:Symbol) -> Int|False :    
      val id = get?(idtable,prod)
      match(id:False) :
        error!(CannotResolveProduction(info, prod))
      id

    ;Resolve all productions in the given pattern.    
    defn resolve (info:FileInfo|False, p:Pattern) -> Pattern :
      let loop (p:Pattern = p) :
        match(p:Production) : sub-id(p, resolve-id(info, name(p)))
        else : map(loop, p)

    ;Resolve all productions in the given expression.
    defn resolve (e:SyntaxExp) -> SyntaxExp :
      match(e) :
        (e:DefProductionExp) :
          sub-id(e, get?(idtable, name(e)))
        (e:DefKeywordsExp) :
          sub-id(e, get?(idtable, name(e)))        
        (e:DefProductionsExp) :
          val clones* = for e in clones(e) map :
            val id* = get?(idtable, name(e))
            val prod-id* = resolve-id(info(e), prod(e))
            sub-id(sub-prod-id(e, prod-id*), id*)            
          sub-clones(e, clones*)
        (e:DefKeywordRuleExp) :
          val id* = resolve-id(info(e), production(e))
          val pattern* = resolve(info(e), pattern(e))
          sub-pattern(sub-id(e, id*), pattern*)
        (e:DefNotRuleExp) :
          val id* = resolve-id(info(e), production(e))
          val pattern* = resolve(info(e), pattern(e))
          sub-pattern(sub-id(e, id*), pattern*)
        (e:DefRuleExp) :
          val id* = resolve-id(info(e), production(e))
          val pattern* = resolve(info(e), pattern(e))
          sub-pattern(sub-id(e, id*), pattern*)
        (e:ImportExp) :
          sub-id(e, get?(idtable, name(e)))
        (e) :
          e
          
    ;Launch!      
    SyntaxPackage(name(p), map(resolve, exps(p)))

  ;Retrieve all public ids in syntax package
  defn public-ids (p:SyntaxPackage) -> Tuple<KeyValue<Symbol,Int>> :
    to-tuple $ for e in exps(p) seq-cat :
      match(e) :
        (e:DefProductionExp) :
          if public?(e) : [name(e) => id(e) as Int]
          else : []
        (e:DefKeywordsExp) :
          if public?(e) : [name(e) => id(e) as Int]
          else : []
        (e:DefProductionsExp) :
          for e in clones(e) seq? :
            if public?(e) : One(name(e) => id(e) as Int)
            else : None()
        (e) : []

  ;Main algorithm
  defn main () :
    val packages = gather-imported-packages()
    val prodtable = assign-ids(packages)
    for entry in packages map! :
      val pkg = value(entry)
      match(pkg:SyntaxPackage) :
        resolve-ids(pkg, prodtable)
    if empty?(errors) :
      val all-exps = to-tuple $
        for package in values(packages) seq-cat :
          for e in exps(package as SyntaxPackage) filter :
            e is-not ImportExp
      val base* = packages[name(base)] as SyntaxPackage      
      AnalyzedSyntaxPackage(name(base), all-exps, public-ids(base*))
    else :
      PatternResolutionErrors(to-tuple(errors))

  ;Launch!
  main()
  
;============================================================
;================ Resolve Against Base ======================
;============================================================

public defn resolve (package:AnalyzedSyntaxPackage, p:Pattern, info:FileInfo|False) -> Pattern|PatternResolutionErrors :
  ;Public identifier table of package  
  val idtable = to-hashtable<Symbol,Int>(idtable(package))

  ;Accumulate errors here.
  val errors = Vector<PatternResolutionError>()  
  
  ;Try to resolve the given production. Issues an error if
  ;it cannot be resolved.
  defn resolve-id (prod:Symbol) -> Int|False :
    val id = get?(idtable,prod)
    match(id:False) :
      add(errors, CannotResolveProduction(info, prod))
    id

  ;Resolve all productions in the given pattern.    
  defn resolve (p:Pattern) -> Pattern :
    match(p:Production) : sub-id(p, resolve-id(name(p)))
    else : map(resolve, p)

  ;Launch!
  val p* = resolve(p)
  if empty?(errors) : p*
  else : PatternResolutionErrors(to-tuple(errors))

;============================================================
;==================== Production Table ======================
;============================================================

deftype ProductionTable
defmulti register (t:ProductionTable, package:Symbol, prod:Symbol, public?:True|False) -> Int|ProductionStatus
defmulti get (t:ProductionTable, package:Symbol, prod:Symbol, only-public?:True|False) -> Int|ProductionStatus

defn ProductionTable () :
  val idtable = HashTable<[Symbol,Symbol],ProductionId|False>()
  new ProductionTable :
    defmethod register (this, package:Symbol, prod:Symbol, public?:True|False) :
      val k = [package,prod]
      if key?(idtable,k) :
        ProductionExists
      else :
        val id = genid()
        idtable[[package,prod]] = ProductionId(id, public?)
        id
    defmethod get (this, package:Symbol, prod:Symbol, only-public?:True|False) :
      match(get?(idtable, [package,prod])) :
        (pid:ProductionId) :
          if only-public? and not public?(pid) : ProductionNotPublic
          else : id(pid)
        (f:False) :
          ProductionMissing

defstruct ProductionId :
  id: Int
  public?: True|False

defenum ProductionStatus :
  ProductionMissing
  ProductionNotPublic
  ProductionExists

;============================================================
;================= Pattern Cloning ==========================
;============================================================

defn clone-patterns (p:AnalyzedSyntaxPackage) -> AnalyzedSyntaxPackage|PatternResolutionErrors :
  ;Check for cycles in cloning graph.
  defn check-cloning-cycles () -> PatternResolutionErrors|False :
    ;Collect information about clones and
    ;cloning edges.
    val clone-def = IntTable<CloneDef>()
    val entries = Vector<KeyValue<Int,Int>>()
    for e in exps(p) do :
      match(e:DefProductionsExp) :
        for e in clones(e) do :
          val clone-id = id(e) as Int
          val prod-id = prod-id(e) as Int
          add(entries, clone-id => prod-id)
          clone-def[clone-id] = CloneDef(info(e), name(e))
    ;Create cyclic cloning errors if any.
    val errors = Vector<MutuallyCyclicClones>()
    val cycles = filter-by<List<Int>>(strong-components(entries*)) where :
      val entries* = for e in entries seq :
        key(e) => List(value(e))
    for ids in cycles do :
      val clones = to-tuple $ seq({clone-def[_]}, ids)
      add(errors, MutuallyCyclicClones(clones))
    PatternResolutionErrors(to-tuple(errors)) when not empty?(errors)

  ;Discover cloning groups.
  ;Entry (a, b, c) means that productions 'a', 'b', and 'c' reference each other,
  ;and must be cloned together.
  defn clone-groups () -> Tuple<List<Int>> :
    ;Gather cloning edges
    val edges = HashSet<KeyValue<Int,Int>>()
    defn scan (e:SyntaxExp) :
      match(e) :
        (e:DefKeywordRuleExp) : scan(id(e) as Int, pattern(e))
        (e:DefNotRuleExp) : scan(id(e) as Int, pattern(e))
        (e:DefRuleExp) : scan(id(e) as Int, pattern(e))
        (e) : false
    defn scan (prod:Int, p:Pattern) :
      match(p:Production) : add(edges, prod => id(p) as Int)
      else : do(scan{prod, _}, p)
    do(scan, exps(p))
    
    ;Discover reference cycles
    val grouped-edges = group-by(key, value, edges)
    to-tuple(filter-by<List<Int>>(strong-components(grouped-edges)))

  ;Find all clone substitutions.
  defn clone-substitutions (cycles:Tuple<List<Int>>) -> Vector<CloneSubstitution> :
    ;Accumulate all substitutions
    val subs = Vector<CloneSubstitution>()
    
    ;Compute cycle index of each clone.
    val cycle-ids = IntTable<Int>()
    for (ids in cycles, index in 0 to false) do :
      for id in ids do :
        cycle-ids[id] = index

    ;Create substitutions for given productions exp.
    defn create-subs (e:DefProductionsExp) :
      ;Categorize as cycle clones and no-cycle clones.
      val no-cycle-clones = to-tuple $
        for c in clones(e) filter :
          not key?(cycle-ids, prod-id(c) as Int)
      val cycle-clones = to-tuple $
        for c in clones(e) group-by :
          cycle-ids[prod-id(c) as Int]
      ;Create substitutions for non-cycle clones.
      for clone in no-cycle-clones do :
        val new-id = id(clone) as Int
        val old-id = prod-id(clone) as Int
        add(subs, CloneSubstitution(new-id, old-id, false))
      ;Create substitutions for cycle clones.
      for entries in cycle-clones do :
        val index = key(entries)
        val clones = value(entries)
        ;Construct substitution table.
        val subtable = IntTable<Int>()
        for c in clones do :
          subtable[prod-id(c) as Int] = id(c) as Int
        for id in cycles[index] do :
          if not key?(subtable, id) :
            subtable[id] = genid()
        ;Create substitutions
        for entry in subtable do :
          add(subs, CloneSubstitution(value(entry), key(entry), subtable))

    ;Create all substitutions
    do(create-subs, filter-by<DefProductionsExp>(exps(p)))
    subs
    
  ;Perform clone substitutions
  defn perform-substitutions (subs:Vector<CloneSubstitution>) -> Tuple<SyntaxExp> :

    ;Perform given substitutions on pattern 'p' if table is given.
    defn make-substitutions (p:Pattern, f:False) :
      p
    defn make-substitutions (p:Pattern, table:IntTable<Int>) :
      match(p:Production) : sub-id(p, get?(table, id(p) as Int, id(p) as Int))
      else : map(make-substitutions{_, table}, p)
      
    ;Create a new SyntaxExp resulting from applying the given
    ;CloneSubstitution.
    defn make-clone (e:DefProductionExp, s:CloneSubstitution) :
      sub-id(e, new-id(s))
    defn make-clone (e:DefKeywordsExp, s:CloneSubstitution) :
      sub-id(e, new-id(s))
    defn make-clone (e:DefKeywordRuleExp, s:CloneSubstitution) :
      val pattern* = make-substitutions(pattern(e), subtable(s))
      sub-pattern(sub-id(e, new-id(s)), pattern*)
    defn make-clone (e:DefNotRuleExp, s:CloneSubstitution) :
      val pattern* = make-substitutions(pattern(e), subtable(s))
      sub-pattern(sub-id(e, new-id(s)), pattern*)
    defn make-clone (e:DefRuleExp, s:CloneSubstitution) :
      val pattern* = make-substitutions(pattern(e), subtable(s))
      sub-pattern(sub-id(e, new-id(s)), pattern*)
    defn make-clone (e:SyntaxExp, f:False) :
      false

    ;Add a new expression to the given vector if it is not false.
    defn add? (es:Vector<SyntaxExp>, e:SyntaxExp|False) :
      match(e:SyntaxExp) : add(es, e)

    ;Table of all substitutions keyed by their old-id.
    val sub-table = to-inttable(old-id, subs)

    ;Hold final accumulated expressions.
    val accum = Vector<SyntaxExp>()

    ;Hold working queue of expressions.
    val queue = Queue<SyntaxExp>()

    ;Process every expression
    do(add{queue, _}, exps(p))
    while not empty?(queue) :
      match(pop(queue)) :
        (e:DefProductionExp) :
          add(accum, e)
          add?(accum, make-clone(e, get?(sub-table, id(e) as Int)))
        (e:DefKeywordsExp) :
          add(accum, e)
          add?(accum, make-clone(e, get?(sub-table, id(e) as Int)))
        (e:DefKeywordRuleExp) :
          add(accum, e)
          add?(accum, make-clone(e, get?(sub-table, id(e) as Int)))
        (e:DefNotRuleExp) :
          add(accum, e)
          add?(accum, make-clone(e, get?(sub-table, id(e) as Int)))
        (e:DefRuleExp) :
          add(accum, e)
          add?(accum, make-clone(e, get?(sub-table, id(e) as Int)))
        (e:DefProductionsExp) :
          false
          
    ;Return final expressions      
    to-tuple(accum)      

  ;Main algorithm
  defn main () :
    match(check-cloning-cycles()) :
      (es:PatternResolutionErrors) :
        es
      (f:False) :
        val clone-subs = clone-substitutions(clone-groups())
        val exps* = perform-substitutions(clone-subs)
        sub-exps(p, exps*)
       
  ;Launch! 
  main()

;This object means that production 'old-id' should be cloned as
;production 'new-id' and the table 'subtable' should be used as
;substitutions.
defstruct CloneSubstitution :
  new-id: Int
  old-id: Int
  subtable: IntTable<Int>|False

;<doc>=======================================================
;=================== Keyword Analysis =======================
;============================================================

Given that P is a keyword production, all rules for P must be either:
  DefKeywordRuleExp, or
  DefNotRuleExp

For a DefKeywordRuleExp, the allowed patterns are:  
  Production if production is a keyword production.
  Keyword
  ChoicePat if all patterns are allowed patterns.
A DefKeywordRuleExp can only be used for a keyword production.

For a DefNotRuleExp, the allowed patterns are:
  Production if production is a keyword production.
  Keyword
  ChoicePat if all patterns are allowed patterns.
A DefNotRuleExp can only be used for:
  1. Keyword productions.
  2. Single form productions.

Given that P is a single form production, all rules for P must be either:
  DefRuleExp where pattern is a single form pattern
  DefNotRuleExp

A single form pattern is:
  Prim
  Form
  Keyword

;============================================================
;=======================================================<doc>

;A KeywordSet represents all possible keywords to match.
deftype KeywordSet
defstruct LeafKeyword <: KeywordSet :
  value: Symbol
defstruct NamedKeywordSet <: KeywordSet :
  id: Int
defstruct KeywordUnion <: KeywordSet :
  sets: Tuple<KeywordSet>
defstruct KeywordDifference <: KeywordSet :
  a: KeywordSet
  b: KeywordSet
defstruct EmptyKeywordSet <: KeywordSet

defn analyze-keyword-sets (p:AnalyzedSyntaxPackage) ->
                           AnalyzedSyntaxPackage|KeywordProductionErrors :
  ;Convert a single pattern into a keyword set.
  defn to-keyword-set (p:Pattern) -> KeywordSet :
    match(p) :
      (p:Production) : NamedKeywordSet(id(p) as Int)
      (p:Keyword) : LeafKeyword(value(p))
      (p:ChoicePat) : KeywordUnion(map(to-keyword-set, patterns(p)))

  ;Gather all keyword definitions and subtractions
  ;defined by the expressions in package 'p'.
  defn gather-keyword-sets () -> [Tuple<KeywordDefinition>, Tuple<KeywordSubtraction>] :
    ;Gather all positive and negative sets.
    val positive-sets = IntTable<List<KeywordSet>>(List())
    val negative-sets = IntTable<List<KeywordSet>>(List())
    val keyword-prods = IntTable<DefKeywordsExp>()
    for e in exps(p) do :
      match(e) :
        (e:DefKeywordRuleExp) :
          val kset = to-keyword-set(pattern(e))
          update(positive-sets, cons{kset, _}, id(e) as Int)
        (e:DefNotRuleExp) :
          val kset = to-keyword-set(pattern(e))
          update(negative-sets, cons{kset, _}, id(e) as Int)
        (e:DefKeywordsExp) :
          keyword-prods[id(e) as Int] = e
        (e) : false
    ;Create a keyword union from list of keyword sets.
    defn make-union (ss:List<KeywordSet>) -> KeywordSet :
      fatal("Illegal argument.") when empty?(ss)
      if empty?(tail(ss)) : head(ss)
      else : KeywordUnion(to-tuple(ss))
    ;Construct definitions
    val keyword-defs = to-tuple $
      for e in values(keyword-prods) seq :
        val pos = positive-sets[id(e) as Int]
        val neg = negative-sets[id(e) as Int]
        val kset = match(empty?(pos), empty?(neg)) :
          (ep:True, en) : EmptyKeywordSet()
          (ep:False, en:True) : make-union(pos)
          (ep:False, en:False) : KeywordDifference(make-union(pos), make-union(neg))
        KeywordDefinition(e, kset)
    ;Construct subtractions
    val keyword-subs = to-tuple $
      for e in negative-sets seq? :
        val id = key(e)
        val neg = value(e)
        if key?(keyword-prods, id) : None()
        else if empty?(neg) : None()
        else : One(KeywordSubtraction(id, make-union(neg)))
    ;Return definitions and subtractions
    [keyword-defs, keyword-subs]

  ;Ensure no keyword cycles
  defn check-keyword-cycles (defs:Tuple<KeywordDefinition>) ->
                            Tuple<KeywordDefinition>|KeywordProductionErrors :
    ;Return all referenced keyword ids.
    defn referenced-ids (kset:KeywordSet) -> List<Int> :
      val ids = IntSet()
      let loop (kset:KeywordSet = kset) :
        match(kset) :
          (kset:KeywordUnion) :
            do(loop, sets(kset))
          (kset:KeywordDifference) :
            loop(a(kset))
            loop(b(kset))
          (kset:NamedKeywordSet) :
            add(ids, id(kset))
          (kset) :
            false
      to-list(ids)
    ;Create table of defs
    val deftable = to-inttable({id(def(_)) as Int}, defs)
    ;Find strong-connected components in keyword definitions.
    val components = strong-components $
      for d in defs seq :
        val id = id(def(d)) as Int
        id => referenced-ids(kset(d))
    ;Find cycles in components
    val errors = Vector<MutuallyCyclicKeywords>()
    for cycle in filter-by<List<Int>>(components) do :
      val proddefs = to-tuple $ for id in cycle seq :
        val def = def(deftable[id])
        CloneDef(info(def), name(def))
      add(errors, MutuallyCyclicKeywords(proddefs))
    ;Return definitions in topological order if there
    ;are no cycles.
    if empty?(errors) :
      to-tuple $
        for id in components as List<Int> seq :
          deftable[id]
    else :
      KeywordProductionErrors(to-tuple(errors))

  ;Given that all referenced keywords exist in the given table in simplified form,
  ;compute the simplified form of the given keyword set.
  ;The simplified form of a keyword set is either:
  ;  1. The empty keyword set.
  ;  2. A single LeafKeyword.
  ;  3. A union of LeafKeyword.
  defn simplify (kset:KeywordSet, keyword-table:IntTable<KeywordSet>) -> KeywordSet :
    ;Return all values in the given simplified keyword set.
    defn all-values (kset:KeywordSet) -> Seqable<Symbol> :
      match(kset) :
        (kset:LeafKeyword) :
          [value(kset)]
        (kset:EmptyKeywordSet) :
          []
        (kset:KeywordUnion) :
          seq(value, sets(kset) as Tuple<LeafKeyword>)

    ;Convert a set of symbols into a simplified KeywordSet
    defn make-keyword-set (values:HashSet<Symbol>) -> KeywordSet :
      switch(length(values)) :
        0 : EmptyKeywordSet()
        1 : LeafKeyword(next(to-seq(values)))
        else : KeywordUnion(to-tuple(seq(LeafKeyword, values)))

    ;Construct the simplified version of the given keyword set.
    defn simplify (kset:KeywordSet) -> KeywordSet :
      match(kset) :
        (kset:LeafKeyword) : kset
        (kset:EmptyKeywordSet) : kset
        (kset:NamedKeywordSet) : keyword-table[id(kset)]
        (kset:KeywordUnion) :
          make-keyword-set $ to-hashset<Symbol> $
            seq-cat(all-values{simplify(_)}, sets(kset))          
        (kset:KeywordDifference) :
          val values = to-hashset<Symbol> $
            all-values(simplify(a(kset)))
          for v in all-values(simplify(b(kset))) do :
            remove(values,v)
          make-keyword-set(values)
          
    ;Launch!
    simplify(kset)

  ;Compute the simplified versions of the given definitions
  ;and subtractions. The definitions must be given in topological order.
  defn simplify (defs:Tuple<KeywordDefinition>,
                 subs:Tuple<KeywordSubtraction>) ->
                 [Tuple<KeywordDefinition>, Tuple<KeywordSubtraction>] :
    val keyword-table = IntTable<KeywordSet>()
    val defs* = for d in defs map :
      val kset* = simplify(kset(d), keyword-table)
      keyword-table[id(def(d)) as Int] = kset*
      sub-kset(d, kset*)
    val subs* = for sub in subs map :
      val kset* = simplify(kset(sub), keyword-table)
      sub-kset(sub, kset*)
    [defs*, subs*]

  ;Transform all expressions to using the computed keyword definitions
  defn transformed-exps (defs:Tuple<KeywordDefinition>,
                         subs:Tuple<KeywordSubtraction>) -> Tuple<SyntaxExp> :
    ;Put defs and subs in tables first.
    val deftable = to-inttable<KeywordSet> $
      for d in defs seq :
        (id(def(d)) as Int) => kset(d)        
    val subtable = to-inttable<KeywordSet> $
      for s in subs seq :
        id(s) => kset(s)

    ;Create a predicate for representing when a value matches the
    ;given keyword set.
    defn make-predicate (kset:KeywordSet) -> (? -> True|False) :
      match(kset) :
        (kset:LeafKeyword) :
          val v = value(kset)
          {unwrap-token(_) == v}
        (kset:KeywordUnion) :
          val vs = to-hashset<?> $
            seq(value{_ as LeafKeyword}, sets(kset))
          {vs[unwrap-token(_)]}

    ;Add a guard to the given expression such that
    ;it passes only if value is not in keyword set.
    defn add-subtraction (e:DefRuleExp, kset:KeywordSet) -> DefRuleExp :
      val in-kset? = make-predicate(kset)
      val guard* =
        if empty?(guard(e)) :
          fn (x) : not in-kset?(x)
        else :
          val g = value!(guard(e))
          fn (x) : g(x) and not in-kset?(x)
      sub-guard(e, One(guard*)) 

    ;Second, iterate through existing expressions and transform each.
    val exps* = Vector<SyntaxExp>()
    for e in exps(p) do :
      match(e) :
        ;Transform into DefProduction with DefRule
        (e:DefKeywordsExp) :
          val kset = deftable[id(e) as Int]
          add(exps*, DefProductionExp(
            info(e), name(e), id(e) as Int, public?(e)))
          if kset is-not EmptyKeywordSet :
            defn return-x (b:ParsedBinders) : b[`x]
            add(exps*, DefRuleExp(
              info(e), name(e), id(e) as Int, Binder(`x,Form()),
              One(make-predicate(kset)), return-x, 100, NonAssociative, false))
        ;Discard if rule for keyword set.
        ;Add guard if it has subtraction.
        (e:DefRuleExp) :
          if not key?(deftable, id(e) as Int) :
            match(get?(subtable, id(e) as Int)) :
              (kset:EmptyKeywordSet) : add(exps*, e)
              (kset:KeywordSet) : add(exps*, add-subtraction(e, kset))
              (f:False) : add(exps*, e)
        ;Keep unchanged      
        (e:DefProductionExp) : add(exps*, e)
        ;No longer necessary
        (e:DefKeywordRuleExp) : false
        ;No longer necessary
        (e:DefNotRuleExp) : false

    ;Return new expressions
    to-tuple(exps*)

  ;Main algorithm
  defn main () :
    val [defs, subs] = gather-keyword-sets()
    match(check-keyword-cycles(defs)) :
      (defs:Tuple<KeywordDefinition>) :
        val [simple-defs, simple-subs] = simplify(defs, subs)
        val exps* = transformed-exps(simple-defs, simple-subs)
        sub-exps(p, exps*)
      (e:KeywordProductionErrors) :
        e

  ;Launch!
  main()

;Represents a keyword production definition using a KeywordSet.
defstruct KeywordDefinition :
  def: DefKeywordsExp
  kset: KeywordSet with: (updater => sub-kset)
  
;Represents a guard that must be added 
defstruct KeywordSubtraction :
  id: Int
  kset: KeywordSet with: (updater => sub-kset)

;============================================================
;===================== Errors ===============================
;============================================================

defn info-str (info:FileInfo|False) :
  if info is False : ""
  else : "%_: " % [info]

public deftype PatternResolutionError <: Exception

public defstruct PatternResolutionErrors <: Exception :
  errors: Tuple<PatternResolutionError>

defmethod print (o:OutputStream, e:PatternResolutionErrors) :
  print(o, "%n" % [errors(e)])

public defstruct CannotResolveProduction <: PatternResolutionError :
  info: FileInfo|False
  production: Symbol

defmethod print (o:OutputStream, e:CannotResolveProduction) :
  print(o, "%_Cannot resolve production '%~'." % [
    info-str(info(e)), production(e)])

public defstruct CannotResolveImportedProduction <: PatternResolutionError :
  info: FileInfo|False
  package: Symbol
  production: Symbol

defmethod print (o:OutputStream, e:CannotResolveImportedProduction) :
  print(o, "%_Cannot resolve production '%~', imported from syntax package '%~'." % [
    info-str(info(e)), production(e), package(e)])

public defstruct CannotImportNonPublicProduction <: PatternResolutionError :
  info: FileInfo|False
  package: Symbol
  production: Symbol

defmethod print (o:OutputStream, e:CannotImportNonPublicProduction) :
  print(o, "%_Cannot import non-public production '%~' from syntax package '%~'." % [
    info-str(info(e)), production(e), package(e)])

public defstruct MissingImportedPackage <: PatternResolutionError :
  info: FileInfo|False
  package: Symbol

defmethod print (o:OutputStream, e:MissingImportedPackage) :
  print(o, "%_Cannot import from syntax package '%~'. There is no such package." % [
    info-str(info(e)), package(e)])  

public defstruct CannotDefineDuplicateProduction <: PatternResolutionError :
  info: FileInfo|False
  production: Symbol

defmethod print (o:OutputStream, e:CannotDefineDuplicateProduction) :
  print(o, "%_Duplicate definition of production '%~'." % [
    info-str(info(e)), production(e)])  

public defstruct MutuallyCyclicClones <: PatternResolutionError :
  defs: Tuple<CloneDef>

defmethod print (o:OutputStream, e:MutuallyCyclicClones) :
  print(o, "The following productions are mutually cyclic clones of each other:")
  val o2 = IndentedStream(o)
  do(lnprint{o2, _}, defs(e))

public defstruct CloneDef :
  info: FileInfo|False
  name: Symbol

defmethod print (o:OutputStream, d:CloneDef) :
  val info-str = "" when info(d) is False
            else " at %_" % [info(d)]
  print(o, "Production '%~'%_" % [name(d), info-str])

public deftype KeywordProductionError <: Exception

public defstruct KeywordProductionErrors <: Exception :
  errors: Tuple<KeywordProductionError>

defmethod print (o:OutputStream, e:KeywordProductionErrors) :
  print(o, "%n" % [errors(e)])

public defstruct MutuallyCyclicKeywords <: KeywordProductionError :
  defs: Tuple<CloneDef>

defmethod print (o:OutputStream, e:MutuallyCyclicKeywords) :
  print(o, "The following keywords are cyclically dependent upon each other:")
  val o2 = IndentedStream(o)
  do(lnprint{o2, _}, defs(e))
  
