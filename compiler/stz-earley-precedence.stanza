defpackage stz/earley-precedence :
  import core
  import collections
  import stz/earley-grammar
  import stz/earley-parse-tree
  import stz/earley-shuntyard with:
    prefix(OperatorType,Binary,Prefix,Postfix,
           Associativity, LeftAssociative, RightAssociative) => SH

;============================================================
;==== Main Algorithm: Rearrange For Operator Precedence =====
;============================================================

public defn reorder-operators (node:ParseNode) -> ParseNode :
  ;Initialize buffers for shuntyard algorithm.
  val chain = Vector<ShuntItem>()
  val shuntyard = Shuntyard()

  ;Main recursive algorithm
  defn reorder-operators (node:ParseNode) -> ParseNode :
    val node* = map-non-ops(reorder-operators, node)
    match(operator-type(node*)) :
      (op:OperatorType) :
        clear(chain)
        collect-operator-chain-items(chain, node*)
        process(shuntyard, chain)
      (op:False) :
        node*
        
  ;Launch!
  reorder-operators(node)

;============================================================
;====== Reorder a Single Level of the Operator Chain ========
;============================================================

;Assume that all non-operators have already been recursively
;reordered. The given node is part of an operator chain,
;scan items in the correct order. 
defn collect-operator-chain-items (items:Vector<ShuntItem>, node:ParseNode) -> False :
  defn emit (item:ShuntItem) : add(items, item)
  defn scan (node:ParseNode) :
    match(operator-type(node)) :
      (op:Prefix) :
        emit $ new Operator :
          defmethod priority (this) : priority(node)
          defmethod associativity (this) : associativity(node)
          defmethod type (this) : SHPrefix
          defmethod value (this, x:ParseNode) : sub-right(node, op, x)
          defmethod print (o:OutputStream, this) :
            print(o, "Prefix[%_]" % [rule(node)])
        do-ops(scan, node, Right)
      (op:Postfix) :
        do-ops(scan, node, Left)
        emit $ new Operator :
          defmethod priority (this) : priority(node)
          defmethod associativity (this) : associativity(node)
          defmethod type (this) : SHPostfix
          defmethod value (this, x:ParseNode) : sub-left(node, op, x)
          defmethod print (o:OutputStream, this) : 
            print(o, "Postfix[%_]" % [rule(node)])
      (op:Binary) :
        do-ops(scan, node, Left)
        emit $ new Operator :
          defmethod priority (this) : priority(node)
          defmethod associativity (this) : associativity(node)
          defmethod type (this) : SHBinary
          defmethod value (this, x:ParseNode, y:ParseNode) : sub-left-right(node, op, x, y)
          defmethod print (o:OutputStream, this) : 
            print(o, "Binary[%_]" % [rule(node)])
        do-ops(scan, node, Right)
      (op:False) :
        emit $ new Item :
          defmethod value (this) : node
          defmethod print (o:OutputStream, this) : 
            print(o, "Item[%_]" % [rule(node)])
  scan(node)
  false

;============================================================
;=============== Substitute Operator Arguments ==============
;============================================================

defn sub-left (node:ParseNode, op:Postfix, left:ParseNode) -> ParseNode :
  within (node, pos) = map(node, op) :
    left when pos == Left else node

defn sub-right (node:ParseNode, op:Prefix, right:ParseNode) -> ParseNode :
  within (node, pos) = map(node, op) :
    right when pos == Right else node

defn sub-left-right (node:ParseNode, op:Binary, left:ParseNode, right:ParseNode) -> ParseNode :
  within (node, pos) = map(node, op) :
    switch(pos) :
      Left : left
      Right : right
      NonOp : node

;============================================================
;=================== Do Over Operators ======================
;============================================================

;Assuming that the given node is an operator, call f on
;the subnode at the given position.
defn do-ops (f:ParseNode -> ?, node:ParseNode, node-pos:NodePosition) -> False :
  val op = operator-type!(node)
  within (node, pos) = map(node, op) :
    f(node) when pos == node-pos
    node
  false  

;Assuming that the given node is an operator, call f on
;all subnodes that are operator nodes.
defn do-ops (f:ParseNode -> ?, node:ParseNode) -> False :
  val op = operator-type!(node)
  within (node, pos) = map(node, op) :
    f(node) when pos != NonOp
    node
  false  

;============================================================
;================ Map Over Non-Operators ====================
;============================================================

;Apply f to all nodes that are not an operator.
defn map-non-ops (f:ParseNode -> ParseNode, node:ParseNode) -> ParseNode :
  val op = operator-type(node)
  within (node, pos) = map(node, op) :
    if pos == NonOp : f(node)
    else : map-non-ops(f, node)

;============================================================
;================= Compute Node Position ====================
;============================================================

defenum NodePosition :
  Left
  Right
  NonOp

defn map (f:(ParseNode, NodePosition) -> ParseNode,
          node:ParseNode,
          op:OperatorType|False) -> ParseNode :
  ;Retrieve node production.
  val tokens = tokens(rule(node))
  val num-children = length(children(node))
  val children* = to-tuple $
    for (c in children(node), i in 0 to false) seq :
      match(c:ParseNode) :
        val child-prod = id(tokens[i] as GProduction)
        match(op) :
          (op:Prefix) :
            if i == num-children - 1 :
              if child-prod == id(op) : f(c, Right)
              else : map(f, c, op)
            else : f(c, NonOp)
          (op:Postfix) :
            if i == 0 :
              if child-prod == id(op) : f(c, Left)
              else : map(f, c, op)
            else : f(c, NonOp)
          (op:Binary) :
            if i == 0 and i == num-children - 1 :
              if child-prod == left(op) or child-prod == right(op) :
                fatal("Illegal binary node.")
              map(f, c, op)
            else if i == 0 :
              if child-prod == left(op) : f(c, Left)
              else : map(f, c, Postfix(left(op)))            
            else if i == num-children - 1 :
              if child-prod == right(op) : f(c, Right)
              else : map(f, c, Prefix(right(op)))
            else : f(c, NonOp)
          (op:False) :
            f(c, NonOp)
      else : c
  sub-children(node, children*)

;============================================================
;===================== Utilities ============================
;============================================================

defn call<?T> (f:TokenRuleParams -> ?T, node:ParseNode) -> T :
  val grule = rule(node)
  val params = params(grule) as TokenRuleParams
  f(params)

defn operator-type (node:ParseNode) -> OperatorType|False :
  call(operator-type, node)

defn operator-type! (node:ParseNode) -> OperatorType :
  val type = operator-type(node)
  if type is False :
    fatal("The following node is not an operator.\n%_" % [node])
  type as OperatorType

defn priority (node:ParseNode) -> Int :
  call(priority, node)

defn associativity (node:ParseNode) -> SHAssociativity :
  switch(call(associativity, node)) :
    LeftAssociative : SHLeftAssociative
    NonAssociative : SHLeftAssociative
    RightAssociative : SHRightAssociative