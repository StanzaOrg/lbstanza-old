defpackage stz/earley-precedence :
  import core
  import collections
  import stz/earley-grammar
  import stz/earley-parse-tree
  import stz/earley-shuntyard with:
    prefix(OperatorType,Binary,Prefix,Postfix,
           Associativity, LeftAssociative, RightAssociative) => SH

;============================================================
;==== Main Algorithm: Rearrange For Operator Precedence =====
;============================================================

public defn reorder-operators (node:ParseNode) -> ParseNode :
  ;Initialize buffers for shuntyard algorithm.
  val chain = Vector<ShuntItem>()
  val shuntyard = Shuntyard()

  ;Main recursive algorithm
  defn reorder-operators (node:ParseNode) -> ParseNode :
    val node* = map-non-ops(reorder-operators, node)
    match(operator-type(node*)) :
      (op:OperatorType) :
        clear(chain)
        collect-operator-chain-items(chain, node*)
        process(shuntyard, chain)
      (op:False) :
        node*

  ;Launch!
  reorder-operators(node)

;============================================================
;====== Reorder a Single Level of the Operator Chain ========
;============================================================

;Assume that all non-operators have already been recursively
;reordered. The given node is part of an operator chain,
;scan items in the correct order.
defn collect-operator-chain-items (items:Vector<ShuntItem>, node:ParseNode) -> False :
  defn emit (item:ShuntItem) : add(items, item)
  defn scan (node:ParseNode) :
    match(operator-type(node)) :
      (op:Prefix) :
        emit $ new Operator :
          defmethod priority (this) : priority(node)
          defmethod associativity (this) : associativity(node)
          defmethod type (this) : SHPrefix
          defmethod value (this, x:ParseNode) : sub-right(node, x)
          defmethod print (o:OutputStream, this) :
            print(o, "Prefix[%_]" % [rule(node)])
        do-single-link(scan, node, Right)
      (op:Postfix) :
        do-single-link(scan, node, Left)
        emit $ new Operator :
          defmethod priority (this) : priority(node)
          defmethod associativity (this) : associativity(node)
          defmethod type (this) : SHPostfix
          defmethod value (this, x:ParseNode) : sub-left(node, x)
          defmethod print (o:OutputStream, this) :
            print(o, "Postfix[%_]" % [rule(node)])
      (op:Binary) :
        do-single-link(scan, node, Left)
        emit $ new Operator :
          defmethod priority (this) : priority(node)
          defmethod associativity (this) : associativity(node)
          defmethod type (this) : SHBinary
          defmethod value (this, x:ParseNode, y:ParseNode) : sub-left-right(node, x, y)
          defmethod print (o:OutputStream, this) :
            print(o, "Binary[%_]" % [rule(node)])
        do-single-link(scan, node, Right)
      (op:False) :
        emit $ new Item :
          defmethod value (this) : node
          defmethod print (o:OutputStream, this) :
            print(o, "Item[%_]" % [rule(node)])
  scan(node)
  false

;============================================================
;=============== Substitute Operator Arguments ==============
;============================================================

defn sub-left (node:ParseNode, left:ParseNode) -> ParseNode :
  fatal("Illegal argument.") when operator-type(node) is-not Postfix
  within (node, pos) = map-single-link(node) :
    left when pos == Left else node

defn sub-right (node:ParseNode, right:ParseNode) -> ParseNode :
  fatal("Illegal argument.") when operator-type(node) is-not Prefix
  within (node, pos) = map-single-link(node) :
    right when pos == Right else node

defn sub-left-right (node:ParseNode, left:ParseNode, right:ParseNode) -> ParseNode :
  fatal("Illegal argument.") when operator-type(node) is-not Binary
  within (node, pos) = map-single-link(node) :
    switch(pos) :
      Left : left
      Right : right
      NonOp : node

;============================================================
;================ Map Over Non-Operators ====================
;============================================================

;Apply f to all nodes in the operator chain that is not an operator node.
defn map-non-ops (f:ParseNode -> ParseNode, node:ParseNode) -> ParseNode :
  within (node, pos) = map-single-link(node) :
    if pos == NonOp : f(node)
    else : map-non-ops(f, node)

;============================================================
;=================== Do Over Operators ======================
;============================================================

;Assuming that the given node is an operator, call f on
;the subnode at the given position.
defn do-single-link (f:ParseNode -> ?, node:ParseNode, node-pos:NodePosition) -> False :
  within (node, pos) = map-single-link(node) :
    f(node) when pos == node-pos
    node
  false

;============================================================
;========== Map Over Single Operator Chain Link =============
;============================================================

defenum NodePosition :
  Left
  Right
  NonOp

defn map-single-link (f:(ParseNode, NodePosition) -> ParseNode,
                      node:ParseNode) -> ParseNode :
  let loop (node:ParseNode = node,
            op:OperatorType|False = operator-type(node)) :
    ;Retrieve node production.
    val tokens = tokens(rule(node))
    val num-children = length(children(node))
    val children* = to-tuple $
      for (c in children(node), i in 0 to false) seq :
        match(c:ParseNode) :
          val child-prod = id(tokens[i] as GProduction)
          match(op) :
            (op:Prefix) :
              if i == num-children - 1 :
                if child-prod == id(op) : f(c, Right)
                else : loop(c, op)
              else : f(c, NonOp)
            (op:Postfix) :
              if i == 0 :
                if child-prod == id(op) : f(c, Left)
                else : loop(c, op)
              else : f(c, NonOp)
            (op:Binary) :
              if i == 0 and i == num-children - 1 :
                if child-prod == left(op) or child-prod == right(op) :
                  fatal("Illegal binary node.")
                loop(c, op)
              else if i == 0 :
                if child-prod == left(op) : f(c, Left)
                else : loop(c, Postfix(left(op)))
              else if i == num-children - 1 :
                if child-prod == right(op) : f(c, Right)
                else : loop(c, Prefix(right(op)))
              else : f(c, NonOp)
            (op:False) :
              f(c, NonOp)
        else : c
    sub-children(node, children*)

;============================================================
;===================== Utilities ============================
;============================================================

defn call<?T> (f:TokenRuleParams -> ?T, node:ParseNode) -> T :
  val grule = rule(node)
  val params = params(grule) as TokenRuleParams
  f(params)

defn operator-type (node:ParseNode) -> OperatorType|False :
  call(operator-type, node)

defn operator-type! (node:ParseNode) -> OperatorType :
  val type = operator-type(node)
  if type is False :
    fatal("The following node is not an operator.\n%_" % [node])
  type as OperatorType

defn priority (node:ParseNode) -> Int :
  call(priority, node)

defn associativity (node:ParseNode) -> SHAssociativity :
  switch(call(associativity, node)) :
    LeftAssociative : SHLeftAssociative
    NonAssociative : SHLeftAssociative
    RightAssociative : SHRightAssociative