defpackage stz/earley-precedence :
  import core
  import collections
  import stz/earley-grammar
  import stz/earley-parse-tree
  import stz/earley-shuntyard with:
    prefix(OperatorType,Binary,Prefix,Postfix,
           Associativity, LeftAssociative, RightAssociative) => SH

;============================================================
;==== Main Algorithm: Rearrange For Operator Precedence =====
;============================================================

public defn reorder-operators (grammar:Grammar, node:ParseNode) -> ParseNode :
  val node* = map-non-ops(reorder-operators{grammar, _}, grammar, node)
  match(operator-type(grammar,node*)) :
    (op:OperatorType) : reorder-operator-chain(grammar, node*)
    (op:False) : node*

;============================================================
;====== Reorder a Single Level of the Operator Chain ========
;============================================================

;Assume that all non-operators have already been recursively
;reordered. The given node is part of an operator chain,
;scan items in the correct order. 
defn reorder-operator-chain (grammar:Grammar, node:ParseNode) -> ParseNode :
  val items = Vector<ShuntItem>()
  defn emit (item:ShuntItem) : add(items, item)
  defn scan (node:ParseNode) :
    match(operator-type(grammar,node)) :
      (op:Prefix) :
        emit $ new Operator :
          defmethod priority (this) : priority(grammar,node)
          defmethod associativity (this) : associativity(grammar,node)
          defmethod type (this) : SHPrefix
          defmethod value (this, x:ParseNode) : sub-right(grammar, node, op, x)
          defmethod print (o:OutputStream, this) :
            print(o, "Prefix[%_]" % [format(grammar, range(node))])
        do-ops(scan, grammar, node, Right)
      (op:Postfix) :
        do-ops(scan, grammar, node, Left)
        emit $ new Operator :
          defmethod priority (this) : priority(grammar,node)
          defmethod associativity (this) : associativity(grammar,node)
          defmethod type (this) : SHPostfix
          defmethod value (this, x:ParseNode) : sub-left(grammar, node, op, x)
          defmethod print (o:OutputStream, this) : 
            print(o, "Postfix[%_]" % [format(grammar, range(node))])
      (op:Binary) :
        do-ops(scan, grammar, node, Left)
        emit $ new Operator :
          defmethod priority (this) : priority(grammar,node)
          defmethod associativity (this) : associativity(grammar,node)
          defmethod type (this) : SHBinary
          defmethod value (this, x:ParseNode, y:ParseNode) : sub-left-right(grammar, node, op, x, y)
          defmethod print (o:OutputStream, this) : 
            print(o, "Binary[%_]" % [format(grammar, range(node))])
        do-ops(scan, grammar, node, Right)
      (op:False) :
        emit $ new Item :
          defmethod value (this) : node
          defmethod print (o:OutputStream, this) : 
            print(o, "Item[%_]" % [format(grammar, range(node))])
  scan(node)
  do(println, items)
  shuntyard(items)

;============================================================
;=============== Substitute Operator Arguments ==============
;============================================================

defn sub-left (grammar:Grammar, node:ParseNode, op:Postfix, left:ParseNode) -> ParseNode :
  within (node, pos) = map(grammar, node, op) :
    left when pos == Left else node

defn sub-right (grammar:Grammar, node:ParseNode, op:Prefix, right:ParseNode) -> ParseNode :
  within (node, pos) = map(grammar, node, op) :
    right when pos == Right else node

defn sub-left-right (grammar:Grammar, node:ParseNode, op:Binary, left:ParseNode, right:ParseNode) -> ParseNode :
  within (node, pos) = map(grammar, node, op) :
    switch(pos) :
      Left : left
      Right : right
      NonOp : node

;============================================================
;=================== Do Over Operators ======================
;============================================================

;Assuming that the given node is an operator, call f on
;the subnode at the given position.
defn do-ops (f:ParseNode -> ?, grammar:Grammar, node:ParseNode, node-pos:NodePosition) -> False :
  val op = operator-type!(grammar,node)
  within (node, pos) = map(grammar, node, op) :
    f(node) when pos == node-pos
    node
  false  

;Assuming that the given node is an operator, call f on
;all subnodes that are operator nodes.
defn do-ops (f:ParseNode -> ?, grammar:Grammar, node:ParseNode) -> False :
  val op = operator-type!(grammar,node)
  within (node, pos) = map(grammar, node, op) :
    f(node) when pos != NonOp
    node
  false  

;============================================================
;================ Map Over Non-Operators ====================
;============================================================

;Apply f to all nodes that are not an operator.
defn map-non-ops (f:ParseNode -> ParseNode, grammar:Grammar, node:ParseNode) -> ParseNode :
  val op = operator-type(grammar,node)
  within (node, pos) = map(grammar, node, op) :
    if pos == NonOp : f(node)
    else : map-non-ops(f, grammar, node)

;============================================================
;================= Compute Node Position ====================
;============================================================

defenum NodePosition :
  Left
  Right
  NonOp

defn map (f:(ParseNode, NodePosition) -> ParseNode,
          grammar:Grammar,
          node:ParseNode,
          op:OperatorType|False) -> ParseNode :
  ;Retrieve node production.
  val tokens = tokens(grammar[rule(range(node))])
  val num-children = length(children(node))
  val children* = to-tuple $
    for (c in children(node), i in 0 to false) seq :
      match(c:ParseNode) :
        val child-prod = id(tokens[i] as GProduction)
        match(op) :
          (op:Prefix) :
            if i == num-children - 1 :
              if child-prod == id(op) : f(c, Right)
              else : map(f, grammar, c, op)
            else : f(c, NonOp)
          (op:Postfix) :
            if i == 0 :
              if child-prod == id(op) : f(c, Left)
              else : map(f, grammar, c, op)
            else : f(c, NonOp)
          (op:Binary) :
            if i == 0 and i == num-children - 1 :
              if child-prod == left(op) or child-prod == right(op) :
                fatal("Illegal binary node.")
              map(f, grammar, c, op)
            else if i == 0 :
              if child-prod == left(op) : f(c, Left)
              else : map(f, grammar, c, Postfix(left(op)))            
            else if i == num-children - 1 :
              if child-prod == right(op) : f(c, Right)
              else : map(f, grammar, c, Prefix(right(op)))
            else : f(c, NonOp)
          (op:False) :
            f(c, NonOp)
      else : c
  ParseNode(prod(node), range(node), children*)

;============================================================
;===================== Utilities ============================
;============================================================

defn call<?T> (f:TokenRuleParams -> ?T, grammar:Grammar, node:ParseNode) -> T :
  val grule = grammar[rule(range(node))]
  val params = params(grule) as TokenRuleParams
  f(params)

defn operator-type (grammar:Grammar, node:ParseNode) -> OperatorType|False :
  call(operator-type, grammar, node)

defn operator-type! (grammar:Grammar, node:ParseNode) -> OperatorType :
  val type = operator-type(grammar, node)
  if type is False :
    fatal("The following node is not an operator.\n%_" % [format(grammar,node)])
  type as OperatorType

defn priority (grammar:Grammar, node:ParseNode) -> Int :
  call(priority, grammar, node)

defn associativity (grammar:Grammar, node:ParseNode) -> SHAssociativity :
  switch(call(associativity, grammar, node)) :
    LeftAssociative : SHLeftAssociative
    NonAssociative : SHLeftAssociative
    RightAssociative : SHRightAssociative