;See License.txt for details about licensing.

defpackage stz/core-macros :
   import core
   import parser
   import macro-utils
   import collections
   import stz/params
   import stz/utils

;============================================================
;==================== Exceptions ============================
;============================================================

public deftype CoreSyntaxError <: Exception

defn CSE (info:False|FileInfo, msg) :
  new CoreSyntaxError :
    defmethod print (o:OutputStream, this) :
      print{o, _} $ match(info) :
        (info:FileInfo) : "%_: Syntax Error: %_" % [info msg]
        (info:False) : "Syntax Error: %_" % [msg]

;============================================================
;==================== Utilities =============================
;============================================================

defstruct ForBinding :
  name:Symbol
  values:List

defn wrap-info (info:False|FileInfo, x) :
   match(info) :
      (info:FileInfo) : Token(x, info)
      (info:False) : x

;============================================================
;============== Anonymous Function Compilation ==============
;============================================================

deftype AfnArg
defstruct AfnNumberedArg <: AfnArg: (index:Int)
defstruct AfnStandardArg <: AfnArg

defstruct AfnArgEntry :
  arg: AfnArg
  type: Maybe

defsyntax anonymous-function-body :
  import type! from core
  
  ;Classify form as an anonymous function argument.
  ;Returns false if not an argument.
  ;Either _ or _0 is accepted as arguments.
  defn classify-arg (x) -> AfnArg|False :
    match(unwrap-token(x)) :
      (s:StringSymbol) :
        if s == `_ :
          AfnStandardArg()
        else if prefix?(name(s), "_") :
          val index-str = name(s)[1 to false]
          match(to-int(index-str)) :
            (x:Int) : AfnNumberedArg(x) when x >= 0 and x < 256
            (x) : false
      (f) :
        false

  ;Returns true if the given form is an appropriate
  ;argument placeholder.
  defn placeholder? (x) -> True|False :
    classify-arg(x) is-not False  

  ;Syntax of anonymous function form
  public defproduction aform
  defrule aform = (?h:((@afn | @do-afn | @quote | $quote) _ ...)) :
    h
  defrule aform = (?p:#placeholder ~ : ?t:#type!) :
    AfnArgEntry(p, One(t))
  defrule aform = (?p:#placeholder) :
    AfnArgEntry(p, None())
  defrule aform = ((?p:#aform ...)) :
    p
  defrule aform = (?x) :
    x

  ;Represents a _ or _n
  defproduction placeholder: AfnArg
  defrule placeholder = (?p) when placeholder?(p) :
    classify-arg(p) as AfnArg

defn compile-afn-body (afn-info:FileInfo|False, body:List) :
  ;Create arguments.
  val arg-table = IntTable-init<Symbol>(gensym{`arg})
  val arg-list = Vector<AfnArgEntry>()
  defn make-arg (e:AfnArgEntry) -> Symbol :
    add(arg-list, e)
    val index = match(arg(e)) :
      (a:AfnNumberedArg) : index(a)
      (a:AfnStandardArg) : length(arg-list) - 1
    arg-table[index]

  ;Verify proper form.
  defn verify-form () -> True|False :
    ;Verify that either the user uses standard arguments
    ;or numbered arguments but not both.
    val standard-arg? = any?({arg(_) is AfnStandardArg}, arg-list)
    val numbered-arg? = any?({arg(_) is AfnNumberedArg}, arg-list)
    if standard-arg? and numbered-arg? :
      val msg = "Anonymous function cannot contain both standard placeholder \
                 arguments as well as numbered placeholder arguments."
      throw(CSE(afn-info, msg))

  ;Assuming that it is a anonymous function using numbered arguments,
  ;construct the type table. Ensure that all types are consistent.
  defn type-table () :
    val table = IntTable<?>()
    defn arg-index (e:AfnArgEntry) : index(arg(e) as AfnNumberedArg)
    defn arg-type (e:AfnArgEntry) : value!(type(e))
    defn typed? (e:AfnArgEntry) : not empty?(type(e))
    for group in group-by(arg-index, arg-type, filter(typed?,arg-list)) do :
      val types = unique(seq(unwrap-all,value(group)))
      if length(types) > 1 :
        val msg = "Argument %_ in anonymous function is declared repeatedly with \
                   different types: %,."
        throw(CSE(afn-info, msg % [key(group), types]))
      table[key(group)] = head(value(group))
    table

  ;Construct arg list, for functions with one argument or more.
  defn make-arg-list () -> List :
    match(arg(arg-list[0])) :
      (a:AfnStandardArg) :
        for (entry in arg-list, index in 0 to false) seq-append :
          val name = arg-table[index]
          if empty?(type(entry)) : List(name)
          else : List(name, `:, value!(type(entry)))
      (a:AfnNumberedArg) :
        val max-arg = maximum(keys(arg-table))
        for i in 0 through max-arg seq-append :
          val types = type-table()
          val name = arg-table[i]
          if key?(types, i) : List(name, `:, types[i])
          else : List(name)

  ;Create the modified body.
  ;Calls `make-arg` on each occurrence of a placeholder.
  defn replace (xs) -> ? :
    match(unwrap-token(xs)) :
      (xs*:List) : sub-token-item?(xs, map(replace, xs*))
      (xs*:AfnArgEntry) : make-arg(xs*)
      (xs*) : xs

  ;Perform substitutions on body
  val aform = parse-syntax[anonymous-function-body / #aform](List(body))
  val replaced = replace(aform)
  verify-form()
  val body* = parse-syntax[core + current-overlays / #exp$](replaced)
  if empty?(arg-list) :
    val template = `(
       multifn :
          () : body
          (x:?) : body)
    parse-syntax[core / #exp](      
       fill-template(template, [
          `body => body*
          `x => gensym(`x)]))
  else :
    val template = `(fn args : body)
    parse-syntax[core / #exp](
       fill-template(template, [
          `body => body*,
          `args => make-arg-list()]))

;============================================================
;====================== DefStruct Compilation ===============
;============================================================

deftype StructField
defmulti bindings (s:StructField, sname:Token|Symbol) -> Tuple
defmulti argument? (s:StructField) -> True|False|Symbol
defmulti voidable? (s:StructField) -> True|False
defmulti has-default? (s:StructField) -> True|False
defmulti has-updater? (s:StructField) -> True|False
defmulti has-init? (s:StructField) -> True|False
defmulti has-ensure? (s:StructField) -> True|False

defn StructField (name:Token|Symbol,              ;Name of field
                  doc-string:Maybe,               ;Doc String
                  type,                           ;Type of field
                  as-method?:True|False,          ;Define as method?
                  setter:Maybe,                   ;Setter for field
                  updater:Maybe,                  ;Updater for field
                  ensure:Maybe,                   ;Precondition for field
                  init:Maybe,                     ;Initial value for field
                  default:Maybe) :                ;Default value for field
  val box? = not empty?(setter)
  val local-name = gensym(name) when box? else name
  val init-value = match(init, default) :
    (i:One, d) : value!(i)
    (i, d:One) : value!(d)
    (i, d) : false
  new StructField :
    defmethod argument? (this) :
      match(init, default) :
        (i:One, d) : false
        (i, d:One) : `optional
        (i, d) : true
    defmethod voidable? (this) :
      defn void? (x:Maybe) : unwrap-token(value?(x)) == `void
      void?(init) or void?(default)
    defmethod has-default? (this) :
      not empty?(default)
    defmethod has-updater? (this) :
      not empty?(updater)
    defmethod has-init? (this) :
      not empty?(init)
    defmethod has-ensure? (this) :
      not empty?(ensure)
    defmethod bindings (this, sname:Token|Symbol) :
     [`name => name
      `type => type
      `doc-string => value?(doc-string)
      `doc-string? => choice(not empty?(doc-string))
      `description => to-string("field %_/%_" % [sname, name])
      `full-name => to-string("%_/%_" % [sname, name])
      `method? => choice(as-method?)
      `setter? => choice(not empty?(setter))
      `setter => value?(setter)
      `updater? => choice(not empty?(updater))
      `updater => value?(updater)
      `ensure? => choice(not empty?(ensure))
      `ensure => value?(ensure)
      `voidable? => choice(voidable?(this))
      `box? => choice(box?)
      `local-name => local-name
      `init? => choice(not empty?(init))
      `init-value => init-value]

defn gen-defstruct (sname:Token|Symbol,
                    targs:List
                    parent:Maybe
                    fields:List<StructField>,
                    constructor:Maybe
                    printer?:True|False) :
  ;===== Bindings =====
  val field-bindings = map(bindings{_, sname}, fields)

  ;===== Subconstructors =====
  defn mark-optional (num-opt-args:Int) :
    defn cons (entry:Symbol, value:?, bs:Tuple<KeyValue<Symbol,?>>) :
      to-tuple(cat([entry => value], bs))
    val counter = to-seq(0 to false)
    for (bs in field-bindings, f in fields) map :
      val arg? = switch(argument?(f)) :
        true : true
        false : false
        `optional : next(counter) < num-opt-args
      val new-bs = [
        `arg? => choice(arg?)
        `initialized? => choice(arg? or not voidable?(f))]
      to-tuple(cat(new-bs, bs))
      
  val num-optional = count({argument?(_) == `optional}, fields)
  val sub-constructors = for n in 0 through num-optional map :
    [`fields => nested(mark-optional(n))]

  ;Do we need sub-constructors?
  val sub-constructors? = (has-defaults? or (has-updaters? and (has-inits? or has-ensures?))) where :
    val has-defaults? = any?(has-default?, fields)
    val has-updaters? = any?(has-updater?, fields)
    val has-inits? = any?(has-init?, fields)
    val has-ensures? = any?(has-ensure?, fields)

  ;===== Define Template =====
  val template = `((
    ;Type declaration
    deftype Struct<targs{name}> parent?{<: Parent}{}
    
    sub-constructors?{      
      ;Main constructor
      defn MainConstructor<targs{name}> (fields{name:voidable?{type|Uninitialized}{type}}) :
        ;Local variables      
        fields{box?{
          var local-name:voidable?{type|Uninitialized}{type} = name
        }{}}
        
        new Struct<targs{name}> :
          fields{
            defmethod name (this) :
              voidable?{
                fatal("Field %_ has not been initialized." % [full-name]) when local-name is Uninitialized
                local-name as type
              }{
                local-name
              }
            setter?{
              defmethod setter (this, value:type) :
                ensure?{
                  #if-not-defined(OPTIMIZE) :
                    ensure(description, value)
                }{}
                local-name = value
            }{}
            updater?{
              defmethod updater (this, local-name:type) :
                ensure?{
                  #if-not-defined(OPTIMIZE) :
                    ensure(description, local-name)
                }{}
                MainConstructor<targs{name}>(fields{local-name})
            }{}
          }
          printer?{
            defmethod print (o:OutputStream, this) :
              val print-items = [
                fields{
                  voidable?{
                    if local-name is Uninitialized : "%~ = void" % [`name]
                    else : "%~ = %~" % [`name, local-name]
                  }{
                    "%~ = %~" % [`name, local-name]
                  }
                }
              ]            
              print(o, "%~(%,)" % [`Struct, print-items])
          }{}
          
      ;Sub constructors
      sub-constructors{
        defn Constructor<targs{name}> (fields{arg?{name:type}{}}) :
          ;Initialize arguments
          fields{
            arg?{}{
              voidable?{
                var name:type
              }{
                val name:type = init-value
              }            
            }
          }
          
          ;Check preconditions
          fields{ensure?{
            initialized?{
              ;If it is passed in explicitly, then check it
              #if-not-defined(OPTIMIZE) :
                ensure(description, name)
            }{}
          }{}}

          ;Call main constructor
          MainConstructor<targs{name}>(fields{initialized?{name}{uninitialized}})
      }
    }{      
      ;Main constructor
      defn Constructor<targs{name}> (fields{init?{}{name:type}}) :
        ;Initialize init fields
        fields{
          init?{
            voidable?{
              var name:type
            }{
              val name:type = init-value
            }            
          }{}
        }

        ;Check preconditions
        fields{ensure?{
          voidable?{}{
            ;If it is not void, then check it
            #if-not-defined(OPTIMIZE) :
              ensure(description, name)            
          }
        }{}}

        ;Initialize boxes
        fields{box?{
          voidable?{
            var local-name:type|Uninitialized = uninitialized
          }{
            var local-name:type = name
          }
        }{}}
        
        new Struct<targs{name}> :
          fields{
            defmethod name (this) :
              voidable?{
                fatal("Field %_ has not been initialized." % [full-name]) when local-name is Uninitialized
                local-name as type
              }{
                local-name
              }
            setter?{
              defmethod setter (this, value:type) :
                ensure?{
                  #if-not-defined(OPTIMIZE) :
                    ensure(description, value)
                }{}
                local-name = value
            }{}
            updater?{
              defmethod updater (this, local-name:type) :
                ensure?{
                  #if-not-defined(OPTIMIZE) :
                    ensure(description, local-name)
                }{}
                Constructor<targs{name}>(fields{local-name})
            }{}
          }
          printer?{
            defmethod print (o:OutputStream, this) :
              val print-items = [
                fields{
                  voidable?{
                    if local-name is Uninitialized : "%~ = void" % [`name]
                    else : "%~ = %~" % [`name, local-name]
                  }{
                    "%~ = %~" % [`name, local-name]
                  }
                }
              ]            
              print(o, "%~(%,)" % [`Struct, print-items])
          }{}
    }

    ;Multi declarations
    fields{method?{}{
      doc-string?{ doc-string }{ }
      defmulti name<targs{?name}> (x:Struct<targs{?name}>) -> type
      setter?{defmulti setter<targs{?name}> (x:Struct<targs{?name}>, v:type) -> False}{}
      updater?{defmulti updater<targs{?name}> (x:Struct<targs{?name}>, v:type) -> Struct<targs{name}>}{}
    }}
    
  ))

  ;===== Fill Template =====
  val targ-bindings = nested $
    for targ in targs map : [
      `name => targ]
      
  val filled = fill-template(template, [
    `Struct => sname
    `targs => targ-bindings
    `parent? => choice(not empty?(parent))
    `Parent => value?(parent)
    `fields => nested(field-bindings)
    `value => gensym(`value)
    `MainConstructor => gensym(sname)
    `Constructor => value?(constructor, sname)
    `sub-constructors? => choice(sub-constructors?)
    `sub-constructors => nested(sub-constructors)
    `Uninitialized => `core/Uninitialized
    `uninitialized => `core/uninitialized
    `OutputStream => `core/OutputStream
    `print => `core/print
    `o => gensym(`o)
    `printer? => choice(printer?)
    `print-items => gensym(`print-items)])

  ; println(filled)

  filled

;============================================================
;==================== Enum Compilation ======================
;============================================================

defstruct EnumDef :
  name
  parent: Maybe
  args: Tuple

defn compile (def:EnumDef) :
  defn compile-arg (arg, index:Int) :
    [`Name => arg
     `to-string-Name => to-string(arg)
     `index => index]
  defn compile-args (args:Tuple) :
    nested $ to-tuple $ seq(compile-arg, args, 0 to false)  

  ;Compile Pattern
  val template = `((
    deftype Enum <: Equalable & Hashable parent?{& parent}{}
    defmulti to-int (x:Enum) -> Int
    args{
      deftype Name <: Enum
      val Name = new Name :
        defmethod to-int (this) : index
        defmethod print (o:OutputStream, this) : print(o, to-string-Name)
    }
    defmethod equal? (a:Enum, b:Enum) : to-int(a) == to-int(b)
    defmethod hash (x:Enum) : to-int(x)

    val Enum-length = num-args
    val enum-vals = [args{Name}]
    defn Enum? (i:Int) :
      enum-vals[i] when i >= 0 and i < num-args
    defn Enum (i:Int) :
      if i >= 0 and i < num-args : enum-vals[i]
      else : fatal("Cannot convert int %_ into enum %_." % [i, to-string-Enum])))
  fill-template(template, [
    ;Place holders
    `Enum => name(def)
    `Enum? => symbol-join([name(def), "?"])
    `Enum-length => symbol-join([name(def), "-length"])
    `to-string-Enum => to-string(name(def))
    `parent? => choice(not empty?(parent(def)))
    `parent => value?(parent(def))
    `args => compile-args(args(def))
    `num-args => length(args(def))
    ;Unique
    `enum-vals => gensym(`enum-vals)    
    ;Core Qualified
    `Equalable => `core/Equalable
    `Hashable => `core/Hashable
    `print => `core/print
    `OutputStream => `core/OutputStream
    `equal? => `core/equal?
    `hash => `core/hash])

;============================================================
;================= Core Syntax Package ======================
;============================================================
defsyntax core :
   ;               Tags
   ;               ====

   val TAG-TABLE = HashSet<Symbol>()
   for tag in `(
      $package $import $prefix-of $prefix $public $protected $private $doc $deftype $defchild $def
      $defvar $defn $defn* $defmulti $defmethod $defmethod* $fn $fn*
      $multi $begin $let $match $branch $new $as $as? $set $do
      $prim $tuple $quote $none $of $and $or $->
      $cap $void $? $ls-new $ls-struct $ls-addr $ls-addr! $ls-deref
      $ls-slot $ls-field $ls-do $ls-call-c $ls-prim $ls-sizeof $ls-tagof $ls-as
      $ls-letexp $ls-and $ls-or $ls-set $ls-labels $ls-block $ls-goto $ls-return
      $ls-let $ls-if $ls-match $ls-branch $ls-func $ls-def $ls-defvar $ls-deftype $ls-deffield
      $ls-defn $ls-defn* $ls-defmethod $ls-defmethod* $ls-extern $ls-extern-fn $ls-byte $ls-int $ls-long $ls-float $ls-double
      $ls-? $ls-of $ls-ptr $ls-ref $ls-fn) do :
      add(TAG-TABLE, tag)

   public defproduction stanza-tag: Symbol|Token
   defn stanza-tag? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : TAG-TABLE[x]
         (x) : false
   defrule stanza-tag = (?x) when stanza-tag?(x) : x

   ;                Lexer Tags
   ;                ==========

   val LEXER-TAG-TABLE = HashSet<Symbol>()
   for tag in `(@do @do-afn @afn @get @tuple @of @cap @quote :) do :
      add(LEXER-TAG-TABLE, tag)
   defn lexer-tag? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : LEXER-TAG-TABLE[x]
         (x) : false
   public defproduction lexer-tag: Symbol|Token      
   defrule lexer-tag = (?x) when lexer-tag?(x) : x

   ;                   Primitives
   ;                   ==========
   defproduction bool : Token|True|False
   defrule bool = (?v:true) : v
   defrule bool = (?v:false) : v

   defproduction string : Token|String
   defrule string = (?x) when unwrap-token(x) is String : x

   defproduction symbol : Token|Symbol
   defrule symbol = (?x) when unwrap-token(x) is Symbol : x

   ;                Error Handling
   ;                ==============

   defproduction bool! : Token|True|False
   defrule bool! = (?v:#bool) : v
   fail-if bool! = () : CSE(closest-info(), "Expected a true/false value here.")

   public defproduction type!
   public defproduction type$
   public defproduction types!
   defrule type! = (?x:#type) : x
   fail-if type! = () : CSE(closest-info(), "Type expected here.")
   defrule type$ = (?x:#type! (! _)) : x
   fail-if type$ = () : CSE(closest-info(), "Expected a single type here.")      
   defrule types! = (?x:#type! ...) : x

   public defproduction id!
   public defproduction id$
   public defproduction ids!
   defrule id! = (?x:#id) : x
   fail-if id! = () : CSE(closest-info(), "Identifier expected here.")
   defrule id$ = (?x:#id! (! _)) : x
   fail-if id$ = () : CSE(closest-info(), "Expected an identifier here.")
   defrule ids! = (?x:#id! ...) : x

   public defproduction exp!
   public defproduction exp$
   public defproduction exps!
   defrule exp! = (?x:#exp) : x
   fail-if exp! = () : CSE(closest-info(), "Expression expected here.")
   defrule exp$ = (?x:#exp! (! _)) : x
   fail-if exp$ = () : CSE(closest-info(), "Expected a single expression here.")
   defrule exps! = (?x:#exp! ...) : x

   public defproduction :!
   defrule :! = (?x: ~ :) : x
   fail-if :! = () : CSE(closest-info(), "Colon expected here.")

   defproduction type1!
   defrule type1! = (?x:#type1) : x
   fail-if type1! = () : CSE(closest-info(), "Expected a type here.")

   defproduction exp0!
   defrule exp0! = (?x:#exp0) : x
   fail-if exp0! = () : CSE(closest-info(), "Expected an expression here.")

   defproduction exp1!
   defrule exp1! = (?x:#exp1) : x
   fail-if exp1! = () : CSE(closest-info(), "Expected an expression here.")

   defproduction exp2!
   defrule exp2! = (?x:#exp2) : x
   fail-if exp2! = () : CSE(closest-info(), "Expected an expression here.")

   defproduction exp3!
   defrule exp3! = (?x:#exp3) : x
   fail-if exp3! = () : CSE(closest-info(), "Expected an expression here.")

   defproduction exp4!
   defrule exp4! = (?x:#exp4) : x
   fail-if exp4! = () : CSE(closest-info(), "Expected an expression here.")

   ;                Type Definitions
   ;                ================

   public defproduction type
   public defproduction type0
   public defproduction type1

   defrule type = (?x:#type0 -> ?y:#type!) : qquote($-> (~ x) ~ y)
   defrule type = ((?x:#types!) -> ?y:#type!) : qquote($-> ~ x ~ y)
   defrule type = (?x:#type0) : x

   defrule type0 = (?x:#type0 & ?y:#type1!) : qquote($and ~ x ~ y)
   defrule type0 = (?x:#type0 ~ | ?y:#type1!) : qquote($or ~ x ~ y)
   defrule type0 = (?x:#type1) : x

   defrule type1 = (?x:(#stanza-tag _ ...)) : x
   defrule type1 = ((~ @cap ?x:#id$)) : qquote($cap ~ x)
   defrule type1 = ([?xs:#types!]) : qquote($tuple ~@ xs)
   defrule type1 = ((?x:#type)) : x
   defrule type1 = (?x:#id<?ys:#types!>) : qquote($of ~ x ~@ ys)
   defrule type1 = (Void) : `($void)
   defrule type1 = (?) : `($?)
   defrule type1 = (?x:#id) : x

   defrule id != (-> | & | ~ | | Void | ?)

   ;                Operator Definitions
   ;                ====================

   public defproduction exp  ; and / or
   public defproduction exp0 ; not, ==, !=, <, <=, >, >=
   public defproduction exp1 ; +, -, |
   public defproduction exp2 ; *, %, /, &, ^
   public defproduction exp3 ; <<, >>, >>>
   public defproduction exp4 ; others

   ;Logical Operators
   defrule exp = (?x:#exp and ?y:#exp0!) :
      parse-syntax[core / #exp](qquote(if ~ x : ~ y upcast-as core/True|core/False))
   defrule exp = (?x:#exp or ?y:#exp0!) :
      val template = `(
         if x : true
         else : y upcast-as core/True|core/False)
      parse-syntax[core / #exp](
         fill-template(template, [
            `x => x
            `y => y]))
   defrule exp = (?e:#exp0) : e

   ;Comparison Operators
   public defproduction op0 : Symbol
   defrule op0 = (==) : `equal?
   defrule op0 = (!=) : `not-equal?
   defrule op0 = (<) : `less?
   defrule op0 = (<=) : `less-eq?
   defrule op0 = (>) : `greater?
   defrule op0 = (>=) : `greater-eq?
   defrule exp0 = (?x:#exp0 ?f:#op0 ?y:#exp1!) : qquote($do ~ f ~ x ~ y)
   defrule exp0 = (not ?x:#exp0!) : qquote($do core/complement ~ x)
   defrule exp0 = (?x:#exp1) : x

   ;Additive Operators
   public defproduction op1 : Symbol
   defrule op1 = (+) : `plus
   defrule op1 = (-) : `minus
   defrule op1 = (~ |) : `bit-or
   defrule exp1 = (?x:#exp1 ?f:#op1 ?y:#exp2!) : qquote($do ~ f ~ x ~ y)
   defrule exp1 = (?x:#exp2) : x

   ;Multiplicative Operators
   public defproduction op2 : Symbol
   defrule op2 = (*) : `times
   defrule op2 = (%) : `modulo
   defrule op2 = (/) : `divide
   defrule op2 = (&) : `bit-and
   defrule op2 = (^) : `bit-xor
   defrule exp2 = (?x:#exp2 ?f:#op2 ?y:#exp3!) : qquote($do ~ f ~ x ~ y)
   defrule exp2 = (?x:#exp3) : x

   ;Shift Operators
   public defproduction op3 : Symbol
   defrule op3 = (<<) : `shift-left
   defrule op3 = (>>) : `shift-right
   defrule op3 = (>>>) : `arithmetic-shift-right
   defrule exp3 = (?x:#exp3 ?f:#op3 ?y:#exp4!) : qquote($do ~ f ~ x ~ y)
   defrule exp3 = (?x:#exp4) : x

   defrule id != (and | or | not | #op0 | #op1 | #op2 | #op3)

   ;               Expressions
   ;               ===========
   defrule exp4 = (?x:(#stanza-tag _ ...)) : x

   ;          User Defined Expressions
   ;          ========================
   import exp4 rules as user-exp4
   defrule exp4 = inline #user-exp4

   ;                 Tuple Call
   ;                 ==========
   ;Not yet implemented
   

   ;                Doc String
   ;                ==========

   defproduction doc-string
   defrule doc-string = (doc : ?x:#string) : qquote($doc ~ x)

   defproduction doc-string? : Maybe
   defrule doc-string? = (?x:#doc-string) : One(x)
   defrule doc-string? = () : None()

   defrule exp4 = (?x:#doc-string) : x

   ;                Function Call
   ;                =============
   defrule exp4 = (?x:#exp4(?ys:#exps!)) : qquote($do ~ x ~@ ys)

   ;               Type Application
   ;               ================
   defrule exp4 = (?x:#exp4<?ys:#types!>) : qquote($of ~ x ~@ ys)

   ;                 Curried Functions
   ;                 =================
   defrule exp4 = (?x:#exp4{?body ...}) :
      parse-syntax[core + current-overlays / #exp](qquote({~ x(~@ body)}))

   ;                  Set and Get
   ;                  ===========
   defrule exp4 = (?x:#exp4[?es:#exps!] = ?v:#exp!) : qquote($do set ~ x ~@ es ~ v)
   defrule exp4 = (?x:#exp4[?es:#exps!]) : qquote($do get ~ x ~@ es)

   ;                   Casts
   ;                   =====
   defrule exp4 = (?x:#exp4 as? ?t:#type!) :
     val template = `(
      (match(x) :
         (r:type) : r
         (r) : core/fail()) as type)
     parse-syntax[core / #exp](
       fill-template(template, [
         `x => x
         `r => gensym(`r)
         `type => t]))

   defrule exp4 = (?x:#exp4 as ?t:#type!) : qquote($as ~ x ~ t)
   defrule exp4 = (?x:#exp4 upcast-as ?t:#type!) : qquote($as? ~ x ~ t)
   defrule id != (as | upcast-as | as?)

   ;                   Functions
   ;                   =========
   defproduction $binder!
   defrule $binder! = (?x:#$binder) : x
   fail-if $binder! = (?x:#symbol) : CSE(closest-info(), "'%~' is a reserved keyword or an invalid identifier and cannot be used as an argument name." % [x])
   fail-if $binder! = () : CSE(closest-info(), "Expected a binder here.")

   defproduction $binder
   defrule $binder = (?x:#id) : x
   defrule $binder = ([?xs:#$binder! ...]) : qquote($tuple ~@ xs)

   defproduction argbinding : KeyValue
   defrule argbinding = (?x:#$binder : ?t:#type!) : x => t
   defrule argbinding = (?x:#$binder) : x => `($none)
   fail-if argbinding = (?x:#symbol) : CSE(closest-info(), "'%~' is a reserved keyword or an invalid identifier and cannot be used as an argument name." % [x])
   fail-if argbinding = () : CSE(closest-info(), "Expected an argument declaration here.")

   defproduction arglist : [? ?]
   defrule arglist = ((?xs:#argbinding ...)) : [map(key, xs), map(value, xs)]

   defproduction fnheader! : [List List ?]
   fail-if fnheader! = ((@do _ ...)) : 
      CSE(closest-info(), BAD-ARGLIST-MSG)
   defrule fnheader! = (?args:#arglist -> ?a2:#type!) :
      val [xs, a1] = args
      [xs, a1, a2]
   defrule fnheader! = (?args:#arglist) :
      val [xs, a1] = args
      [xs, a1, `($none)]
   fail-if fnheader! = () :
      CSE(closest-info(), "Expected argument list here.")

   defproduction fn-tag: Symbol
   defrule fn-tag = (fn) : `$fn
   defrule fn-tag = (fn*) : `$fn*
   defrule exp4 = (?tag:#fn-tag ?header:#fnheader! #:! ?body:#exp!) :
      val [xs, a1, a2] = header
      qquote(~ tag ~ xs ~ a1 ~ a2 ~ body)

   defproduction type-arg
   defrule type-arg = ((~ @cap ?x:#id$)) : qquote($cap ~ x)
   defrule type-arg = (?x:#id) : x

   defproduction type-arg!
   defrule type-arg! = (?x:#type-arg) : x
   fail-if type-arg! = () : CSE(closest-info(), "Type argument expected here.")
   
   defproduction fn-name!   
   defrule fn-name! = (?x:#id<?ts:#type-arg! ...>) : qquote($of ~ x ~@ ts)
   defrule fn-name! = (?x:#id) : x
   fail-if fn-name! = () : CSE(closest-info(), "Expected a function name here.")

   defproduction defn-tag: Symbol
   defrule defn-tag = (defn) : `$defn
   defrule defn-tag = (defn*) : `$defn*
   defrule exp4 = (?tag:#defn-tag ?name:#fn-name! ?header:#fnheader! #:! ?body:#exp!) :
      val [xs, a1, a2] = header
      qquote(~ tag ~ name ~ xs ~ a1 ~ a2 ~ body)

   defproduction defmethod-tag: Symbol
   defrule defmethod-tag = (defmethod) : `$defmethod
   defrule defmethod-tag = (defmethod*) : `$defmethod*
   defproduction defmethod
   defrule defmethod = (?tag:#defmethod-tag ?name:#fn-name! ?header:#fnheader! #:! ?body:#exp!) :
      val [xs, a1, a2] = header
      qquote(~ tag ~ name ~ xs ~ a1 ~ a2 ~ body)
   defrule exp4 = inline #defmethod

   defrule exp4 = (defmulti ?name:#fn-name! ?header:#fnheader!) :
      val [xs, a1, a2] = header
      qquote($defmulti ~ name ~ a1 ~ a2)

   defproduction multifn-tag
   defrule multifn-tag = (multifn) : `$fn
   defrule multifn-tag = (multifn*) : `$fn*
   defrule exp4 = (?tag:#multifn-tag #:! ((?headers:#fnheader! #:! ?bodies:#exp!) @...)) :
      val template =
         `($multi
            funcs{
               ($fn xs a1 a2 body)
            })
      fill-template(template, [
         `$fn => tag
         `funcs => nested $
            for ([xs, a1, a2] in headers, body in bodies) map :
               [`a1 => a1
                `a2 => a2
                `xs => xs
                `body => body]])
   fail-if exp4 = (?tag:#multifn-tag #:! ?rest ...) :
      CSE(closest-info(rest), "Expected a list of function branches here.")

   defrule id != (#fn-tag | #defn-tag | defmulti | #multifn-tag) 

   ;              Variables
   ;              =========
   defrule exp4 = (var ?name:#$binder : ?type:#type! = ?value:#exp!) :
      qquote($defvar ~ name ~ type ~ value)
   defrule exp4 = (var ?name:#$binder : ?type:#type!) :
      qquote($defvar ~ name ~ type ($none))
   defrule exp4 = (var ?name:#$binder = ?value:#exp!) :
      qquote($defvar ~ name ($none) ~ value)
   defrule exp4 = (var ?name:#$binder) :
      qquote($defvar ~ name ($none) ($none))
   fail-if exp4 = (var) :
      CSE(closest-info(), "Expected variable name after var keyword.")
      
   defrule id != (var)

   ;                Values
   ;                ======
   defrule exp4 = (val ?name:#$binder : ?type:#type! = ?value:#exp!) :
      qquote($def ~ name ~ type ~ value)
   fail-if exp4 = (val ?name:#$binder : #type! ?rest ...) :
      CSE(closest-info(rest), "No initializing value given to val %_." % [name])
   defrule exp4 = (val ?name:#$binder = ?value:#exp!) :
      qquote($def ~ name ($none) ~ value)
   fail-if exp4 = (val ?name:#$binder) :
      CSE(closest-info(), "No initializing value given to val %_." % [name])
   fail-if exp4 = (val) :
      CSE(closest-info(), "Expected value name after val keyword.")

   defrule id != (val)

   ;               Set Variable
   ;               ============
   defrule exp4 = (?x:#exp4 = ?y:#exp!) : qquote($set ~ x ~ y)
   defrule id != (=)

   ;               Visibilities
   ;               ============
   defproduction visibility
   defrule visibility = (public) : `$public
   defrule visibility = (protected) : `$protected
   defrule visibility = (private) : `$private
   
   defrule exp4 = (?tag:#visibility : ?e:#exp!) :
      List(tag, e)
   defrule exp4 = (?tag:#visibility ?e:#exp!) :
      List(tag, e)
      
   defrule id != (#visibility)   

   ;                Conditional Visibility
   ;                ======================
   defproduction visibility-when
   defrule visibility-when = (public-when) : `$public
   defrule visibility-when = (protected-when) : `$protected
   defrule visibility-when = (private-when) : `$private
   
   defrule exp4 = (?tag:#visibility-when(?flag:#id$) : ?e:#exp!) :
     if flag-defined?(unwrap-token(flag)) : List(tag, e)
     else : e
   defrule exp4 = (?tag:#visibility-when(?flag:#id$) ?e:#exp!) :
     if flag-defined?(unwrap-token(flag)) : List(tag, e)
     else : e   

   ;                   New Objects
   ;                   ===========
   defproduction defmethod!
   defrule defmethod! = (?x:#defmethod) : x
   fail-if defmethod! = () : CSE(closest-info(), "Expected a defmethod statement here.")
   
   defrule exp4 = (new ?t:#type! : (?methods:#defmethod! ...)) : qquote($new ~ t ~@ methods)
   fail-if exp4 = (new ?t:#type! : ?rest ...) :
      CSE(closest-info(rest), "Expected a list of defmethod statements following new keyword.")
   defrule exp4 = (new ?t:#type!) : qquote($new ~ t)

   defrule id != (new)

   ;                    DefType
   ;                    =======
   defproduction type-name!
   defrule type-name! = (?x:#id<?ts:#ids!>) : qquote($of ~ x ~@ ts)
   defrule type-name! = (?x:#id) : x
   fail-if type-name! = () : CSE(closest-info(), "Expected the name of a type here.")

   defproduction defchild!
   defrule defchild! = (?a:#type-name! <: ?b:#type!) : qquote($defchild ~ a ~ b)
   fail-if defchild! = () : CSE(closest-info(), "Invalid syntax for child type declaration.")
      
   defrule exp4 = (deftype ?t:#type-name! <: ?p:#type!) :
      qquote($deftype ~ t ~ p)
   defrule exp4 = (deftype ?t:#type-name! : (?cs:#defchild! ...)) :
      qquote($deftype ~ t ($none) ~@ cs)
   defrule exp4 = (deftype ?t:#type-name!) :
      qquote($deftype ~ t ($none))
      
   defrule id != (deftype)   

   ;                    Type Objects
   ;                    ============
   defrule exp4 = (TypeObject<?type-form ...>()) :
     val type = parse-syntax[core + current-overlays / #type$](type-form)
     val type-name = string-join(type-form)
     val template = `(
       new TypeObject<T> :
         defmethod typeof? (x, this) : x is T
         defmethod name (this) : type-name)
     val filled = fill-template(template, [
       `x => gensym(`x)
       `T => type
       `TypeObject => `core/TypeObject
       `typeof? => `core/typeof?
       `name => `core/name
       `type-name => type-name])
     parse-syntax[core / #exp](filled)
 


   ;                    Tuples
   ;                    ======
   defrule exp4 = ([?es:#exps!]) :
      qquote($tuple ~@ es)

   ;                 Quick Match
   ;                 ===========
   defproduction match-alt
   defrule match-alt = (else #:! ?alt:#exp!) : alt
   defrule match-alt = () : false
   
   ;QuickMatch using identifiers
   defrule exp4 = (match((?es:#exp! : ?ts:#type!) @...) #:! ?conseq:#exp! ?alt:#match-alt) :
      val template = `(
         match(args{e}) :
            (args{x : t}) : conseq
            (args{#x}) : alt)
      defn id? (e) :
         match(unwrap-token(e)) :
           (x:Symbol) : e
           (x) : gensym(`x)
      parse-syntax[core / #exp](      
         fill-template(template, [
            `args => repeated $ [
               `e => es
               `t => ts
               `x => map(id?, es)
               `#x => map(gensym{}, es)]
            `conseq => conseq
            `alt => alt]))      

   ;                    Match
   ;                    =====
   defproduction match-clause! : [[? ?] ?]
   defrule match-clause! = (?arglist:#arglist #:! ?body:#exp!) : [arglist, body]
   fail-if match-clause! = () : CSE(closest-info(), "Expected match clause here.")
   
   defrule exp4 = (match(?xs:#exps!) #:! (?cs:#match-clause! ...)) :
      val template =
         `($match xs
              branch{
                 ($branch args types body)
              })
      fill-template(template, [
         `xs => xs
         `branch => nested $
            for [[xs, ts] b] in cs map :
               [`types => ts
                `args => xs
                `body => b]])
   fail-if exp4 = (match (_ ...)) :
      CSE(closest-info(), BAD-MATCH-MSG)
   fail-if exp4 = (match) :
      CSE(closest-info(), "Invalid syntax for match expression.")
      
   defrule id != (match)

   ;                    If
   ;                    ==
   defproduction if-exp
   
   ;Alternate branch
   defproduction if-alt
   defrule if-alt = (else : ?alt:#exp!) : alt
   defrule if-alt = (else ?alt:#if-exp) : alt
   defrule if-alt = () : false
   
   ;General case with generic predicate
   defrule if-exp = (if ?pred:#exp! #:! ?conseq:#exp! ?alt:#if-alt) :
      val template = `(
         match(pred upcast-as core/True|core/False) :
            (x:core/True) : conseq
            (x:core/False) : alt)
      parse-syntax[core / #exp](      
         fill-template(template, [
            `x => gensym(`x)
            `pred => pred
            `conseq => conseq
            `alt => alt]))

   defrule exp4 = inline #if-exp
   defrule id != (if | else)

   ;                 #For
   ;                 ====
   defproduction for-binding : ForBinding
   defrule for-binding = (?x:#id in [?vs ...]) :
     ForBinding(unwrap-token(x), vs)
   defrule for-binding = (?x:#id in splice([?vs ...])) :
     ForBinding(unwrap-token(x), map(splice, vs))
   fail-if for-binding = (?x:#id in) :
     CSE(closest-info(), "Expected a list of expressions for binding.")

   defproduction for-binding! : ForBinding
   defrule for-binding! = (?x:#for-binding) : x
   fail-if for-binding! = () : CSE(closest-info(), "Binding expected here.")

   defproduction for-bindings : List<ForBinding>
   defrule for-bindings = (?b:#for-binding) : List(b)
   defrule for-bindings = ((?bs:#for-binding! ...)) : bs
   fail-if for-bindings = () : CSE(closest-info(), "For bindings expected here.")

   defrule exp4 = (~ #for ?bs:#for-bindings #:! ?body) :
     val vals = map(to-seq{values(_)}, bs)
     val body* = to-list $ repeat-while $ fn () :
       if all?(empty?, vals) :
         None()
       else :
         One{fill-template(body, _)} $
           for (b in bs, v in vals) map :
             name(b) => next(v)
     parse-syntax[core + current-overlays / #exp](List(body*))

   ;                Named Let
   ;                =========
   defproduction let-binding! : KeyValue ;arg => init
   defrule let-binding! = (?x:#binder : ?t:#type! #=! ?v:#exp!) : splice(List(x, `:, t)) => v
   defrule let-binding! = (?x:#binder #=! ?v:#exp!) : x => v
   fail-if let-binding! = () : CSE(closest-info(), "Expected a let binding here.")

   defproduction let-bindings! : List<KeyValue>
   defrule let-bindings! = ((?bs:#let-binding! ...)) : bs
   fail-if let-bindings! = () : CSE(closest-info(), "Expected a let binding here.")
   
   defrule exp4 = (let ?f:#id ?bs:#let-bindings! #:! ?body:#exp!) :
      val template = `(
         f(vs) where :
            defn* f args : body)
      parse-syntax[core / #exp](      
         fill-template(template, [
            `f => f
            `args => map(key,bs)
            `body => body
            `vs => splice(map(value,bs))]))

   ;                   Let
   ;                   ===
   defrule exp4 = (let #:! ?body:#exp!) :
      qquote($let ~ body)
   defrule id != (let)     

   ;                   Where
   ;                   =====
   defrule exp4 = (?x:#exp4 where #:! ?defs:#exp!) :
      parse-syntax[core / #exp](
         qquote(let : (~ defs ~ x)))
   defrule id != (where)

   ;                     For
   ;                     ===
   defproduction in!
   defrule in! = (in) : `in
   fail-if in! = () : CSE(closest-info(), "Expected the in keyword here.")

   defproduction binder!
   defrule binder! = (?x:#binder) : x
   fail-if binder! = () : CSE(closest-info(), "Expected a binder here.")
   
   defproduction binder
   defrule binder = (?x:#id) : x
   defrule binder = (?x:[#binder! ...]) : x

   defproduction binders : List
   defrule binders = ((?xs:#binder ...)) : xs
   defrule binders = (?x:#binder) : List(x)

   defproduction in-binding : KeyValue ;arg => collection
   defrule in-binding = (?x:#binder : ?t:#type! #in! ?y:#exp!) : splice(List(x `: t)) => y
   defrule in-binding = (?x:#binder #in! ?y:#exp!) : x => y

   defproduction in-binding! : KeyValue
   defrule in-binding! = (?x:#in-binding) : x
   fail-if in-binding! = () : CSE(closest-info(), "Expected a binding form here for the for expression.")

   defproduction in-bindings! : List<KeyValue>
   defrule in-bindings! = ((?b0:#in-binding ?bn:#in-binding! ...)) : cons(b0, bn)
   defrule in-bindings! = (?b:#in-binding!) : List(b)
   
   fail-if exp4 = (for #in-binding :) :
      CSE(closest-info(), BAD-FOR-MSG)         
   defrule exp4 = (for ?bs:#in-bindings! ?f:#exp! #:! ?body:#exp!) :
      val template = `(f(fn xs : body, ys))
      parse-syntax[core / #exp](
         fill-template(template, [
            `f => f
            `xs => map(key, bs)
            `body => body
            `ys => splice(map(value, bs))]))
      
   defrule id != (for)

   ;                   Within
   ;                   ======
   defrule exp4 = (within ?bs:#binders = ?e:#exp! #:! ?body:#exp!) :
     if not tagged-list?(e, `$do) :
       throw(CSE(closest-info(e), "Expected a function call form."))
     val f = unwrap-token(e)[1]
     val args = tailn(unwrap-token(e), 2)
     parse-syntax[core / #exp](
       qquote((~ f)((fn* ~ bs : ~ body) ~@ args)))

   defrule exp4 = (within ?e:#exp! #:! ?body:#exp!) :
     if not tagged-list?(e, `$do) :
       throw(CSE(closest-info(e), "Expected a function call form."))
     val f = unwrap-token(e)[1]
     val args = tailn(unwrap-token(e), 2)
     parse-syntax[core / #exp](
       qquote((~ f)((fn* () : ~ body) ~@ args)))

   ;                   While
   ;                   =====
   defrule exp4 = (while ?pred:#exp! #:! ?body:#exp!) :
      val template = `(
         let :
            defn* loop () :
               if (pred upcast-as core/True|core/False) :
                  body
                  loop()
            loop())
      parse-syntax[core / #exp](
         fill-template(template, [
            `loop => gensym(`loop)
            `pred => pred
            `body => body]))

   defrule id != (while)

   ;                   When
   ;                   ====         
   ;General case for general predicate      
   defrule exp4 = (?x:#exp4 when ?pred:#exp! else ?y:#exp!) :
      parse-syntax[core / #exp](
         qquote(if ~ pred : ~ x else : ~ y))         
   defrule exp4 = (?x:#exp4 when ?pred:#exp!) :
      parse-syntax[core / #exp](
         qquote(if ~ pred : ~ x))

   defrule id != (when)

   ;                Filter-By
   ;                =========
   defrule exp4 = (filter-by<?T:#type$>(?e:#exp$)) :
      val template = `(core/filter({_ is T}, e) as core/Seq<T>)
      parse-syntax[core / #exp](
         fill-template(template, [
            `T => T
            `e => e]))
   fail-if exp4 = (filter-by<?T:#type$> ?rest ...) :
      CSE(closest-info(rest), "Expected a single argument here for filter-by form.")
   fail-if exp4 = (filter-by ?rest ...) :
      CSE(closest-info(rest), "Expected a single type argument here for filter-by form.")

   ;                  Find-By
   ;                  =======
   defrule exp4 = (find-by<?T:#type$>(?e:#exp$)) :
      val template = `(core/find({_ is T}, e) as T|False)
      parse-syntax[core / #exp](
         fill-template(template, [
            `T => T
            `e => e]))
   fail-if exp4 = (find-by<?T:#type$> ?rest ...) :
      CSE(closest-info(rest), "Expected a single argument here for find-by form.")
   fail-if exp4 = (find-by ?rest ...) :
      CSE(closest-info(rest), "Expected a single type argument here for find-by form.")

   defrule exp4 = (find-by!<?T:#type$>(?e:#exp$)) :
      val template = `(core/find!({_ is T}, e) as T)
      parse-syntax[core / #exp](
         fill-template(template, [
            `T => T
            `e => e]))
   fail-if exp4 = (find-by!<?T:#type$> ?rest ...) :
      CSE(closest-info(rest), "Expected a single argument here for find-by! form.")
   fail-if exp4 = (find-by! ?rest ...) :
      CSE(closest-info(rest), "Expected a single type argument here for find-by! form.")
      

   ;                    To/Through
   ;                    ==========
   defproduction range-op
   defrule range-op = (to) : false
   defrule range-op = (through) : true
   
   defrule exp4 = (?start:#exp4 ?inc:#range-op ?end:#exp! by ?step:#exp!) :
      parse-syntax[core / #exp](
         qquote(core/Range(~ start, ~ end, ~ step, ~ inc)))
   defrule exp4 = (?start:#exp4 ?inc:#range-op ?end:#exp!) :            
      parse-syntax[core / #exp](
         qquote(core/Range(~ start, ~ end, 1, ~ inc)))

   defrule id != (#range-op)

   ;                 Function Application
   ;                 ====================
   defrule exp4 = (?f:#exp4 $ ?v:#exp!) :
      qquote($do ~ f ~ v)
      
   defrule id != ($)   

   ;                  Anonymous Functions
   ;                  ===================
   defrule exp4 = ({?body ...}) :
     compile-afn-body(closest-info(), body)

   ;                       Is/Is-Not
   ;                       =========
   defrule exp4 = (?x:#exp4 is ?t:#type!) :
      parse-syntax[core / #exp](
         qquote(
            match(~ x) :
               (x: ~ t) : true
               (x) : false))
               
   defrule exp4 = (?x:#exp4 is-not ?t:#type!) :
      parse-syntax[core / #exp](
         qquote(
            match(~ x) :
               (x: ~ t) : false
               (x) : true))

   defrule id != (is | is-not)

   ;                        Label
   ;                        =====
   defrule exp4 = (label<?t:#type$> ?break:#id! #:! ?body:#exp!) :
      parse-syntax[core / #exp](
         qquote(core/LabeledScope<~ t>((fn (~ break) -> ~ t : ~ body))))
   defrule exp4 = (label ?break:#id! #:! ?body:#exp!) :
      parse-syntax[core / #exp](
         qquote(core/LabeledScope*(fn (~ break) : ~ body)))
         
   defrule id != (label)      

   ;                      Generate
   ;                      ========   
   defrule exp4 = (generate<?t:#type$> #:! ?body:#exp!) :
      parse-syntax[core / #exp](
         qquote(core/Generator<~ t>((fn (yield, break) : ~ body))))
   defrule exp4 = (generate #:! ?body:#exp!) :
      parse-syntax[core / #exp](
         qquote(generate<?> : ~ body))
         
   defrule id != (generate)      

   ;                      KeyValue
   ;                      ========
   defrule exp4 = (?k:#exp4 => ?v:#exp!) :
      parse-syntax[core / #exp](
         qquote(core/KeyValue(~ k ~ v)))

   defrule id != (=>)

   ;           Switch Using Equality Predicate
   ;           ===============================
   ;Switch clauses
   defproduction switch-clause! : [? ?]
   defrule switch-clause! = ((! else) ?v:#exp! #:! ?body:#exp!) :
      [v, body]
      
   ;Special case using equality predicate
   defn gen-switch-equal-exp (x, clauses:List, alt) -> ? :
      if empty?(clauses) :
         alt
      else :
         val [v, body] = head(clauses)
         val rest = gen-switch-equal-exp(x, tail(clauses), alt)
         qquote(if ~ x == ~ v : ~ body else : ~ rest)

   defrule exp4 = (switch(?form:#exp$) #:! (
                      ?cs:#switch-clause! ...
                      else #:! ?alt:#exp$)) :
      val template = `(let : (val x = form upcast-as core/Equalable, exp))
      val x = gensym(`x)
      parse-syntax[core / #exp](
         fill-template(template, [
            `x => x
            `form => form
            `exp => gen-switch-equal-exp(x, cs, alt)]))
            
   defrule exp4 = (switch(?form:#exp$) #:! (
                      ?cs:#switch-clause! ...)) :
      val alt = qquote(core/fatal("No appropriate switch clause."))                
      val template = `(let : (val x = form upcast-as core/Equalable, exp))
      val x = gensym(`x)
      parse-syntax[core / #exp](
         fill-template(template, [
            `x => x
            `form => form
            `exp => gen-switch-equal-exp(x, cs, alt)]))         


   ;           Switch Using General Predicate
   ;           ==============================
   defn gen-switch-exp (pred, clauses:List, alt) -> ? :
      if empty?(clauses) :
         alt
      else :
         val [v, body] = head(clauses)
         val rest = gen-switch-exp(pred, tail(clauses), alt)
         qquote(if ~ pred(~ v) : ~ body else : ~ rest)

   defrule exp4 = (switch ?pred:#exp! #:! (
                      ?cs:#switch-clause! ...
                      else #:! ?alt:#exp$)) :
      parse-syntax[core / #exp](                
         gen-switch-exp(pred, cs, alt))

   defrule exp4 = (switch ?pred:#exp! #:! (
                      ?cs:#switch-clause! ...)) :
      val alt = qquote(core/fatal("No appropriate switch clause."))
      parse-syntax[core / #exp](
         gen-switch-exp(pred, cs, alt))

   defrule id != (switch)

   ;                     Let-Var
   ;                     =======
   defrule exp4 = (let-var ?x:#id! = ?e:#exp! #:! ?body:#exp!) :
      val template = `(
         let :
            val oldv = x
            val v = e
            core/dynamic-wind(
               fn () : x = v
               fn () : body
               fn (f) : x = oldv))
      parse-syntax[core / #exp](         
         fill-template(template, [
            `x => x
            `e => e
            `v => gensym(`v)
            `f => gensym(`f)
            `oldv => gensym(`oldv)
            `body => body]))

   defrule id != (let-var)

   ;                      Resource
   ;                      ========
   defrule exp4 = (resource ?name:#id! : ?type:#type! = ?value:#exp! ?rest:#exps!) :
      val template = `(
         core/with-resource(
            fn (x:type) : body
            value))
      parse-syntax[core / #exp](      
         fill-template(template, [
            `x => name
            `type => type
            `value => value
            `body => rest]))
   defrule exp4 = (resource ?name:#id! = ?value:#exp! ?rest:#exps!) :
      val template = `(
         core/with-resource(
            fn (x) : body
            value))
      parse-syntax[core / #exp](      
         fill-template(template, [
            `x => name
            `value => value
            `body => rest]))
            
   defrule id != (resource)

   ;                      Try
   ;                      ===
   defproduction catch-clause : Splice
   fail-if catch-clause = (catch (@do _ ...)) :
      CSE(closest-info(), "Invalid catch clause. Did you forget a space between the catch keyword and the argument list?")
   defrule catch-clause = (catch ?arglist:(_ ...) #:! ?body:#exp!) :
      splice(List(arglist `: body))
   fail-if catch-clause = (catch) :
      CSE(closest-info(), "Expected an argument list after catch keyword.")
      
   defrule exp4 = (try #:! ?body:#exp!
                   ?clauses:#catch-clause ...
                   finally #:! ?fbody:#exp!) :
      val template = `(
         core/with-finally(
            fn () :
               core/with-exception-handler(
                  fn () :
                     body
                  fn (e) :
                     catch{
                        core/throw(e)
                     }{
                        match(e) :
                           clauses
                           (e) : core/throw(e)
                     })
            fn (f) :
               fbody))
      parse-syntax[core / #exp](         
         fill-template(template, [
            `body => body
            `e => gensym(`e)
            `f => gensym(`f)
            `catch => choice(empty?(clauses))
            `clauses => splice(clauses)
            `fbody => fbody]))

   defrule exp4 = (try #:! ?body:#exp! ?clauses0:#catch-clause ?clausesn:#catch-clause ...) :
      val template = `(
         core/with-exception-handler(
            fn () :
               body
            fn (e) :
               match(e) :
                  clauses
                  (e) : core/throw(e)))
      parse-syntax[core / #exp](
         fill-template(template, [
            `body => body
            `e => gensym(`e)
            `clauses => splice(cons(clauses0, clausesn))]))
   fail-if exp4 = (try #:! #exp!) :
      CSE(closest-info(), "Try expression without any catch or finally clauses.")

   defrule id != (try)

   ;                      Attempt
   ;                      =======
   defn compile-attempt (conseq, alt) :
      val template = `(
         core/with-attempt(
            fn* () : conseq,
            fn* () : alt))
      parse-syntax[core / #exp](      
         fill-template(template, [
            `conseq => conseq,
            `alt => alt]))

   defproduction attempt-exp
   defrule attempt-exp = (attempt #:! ?conseq:#exp! else : ?alt:#exp!) :
      compile-attempt(conseq, alt)
   defrule attempt-exp = (attempt #:! ?conseq:#exp! else ?alt:#attempt-exp) :
      compile-attempt(conseq, alt)
   defrule attempt-exp = (attempt #:! ?conseq:#exp!) :
      compile-attempt(conseq, false)
   defrule exp4 = inline #attempt-exp

   defrule id != (attempt)

   ;                      DefPackage
   ;                      ==========
   defproduction prefix-clause!
   defrule prefix-clause! = (prefix => ?p:#id!) :
      qquote($prefix ~ p)
   defrule prefix-clause! = (prefix(?xs:#id! ...) => ?p:#id!) :
      qquote($prefix-of ~ xs ~ p)
   fail-if prefix-clause! = () :
      CSE(closest-info(), "Expected prefix clause here.")

   defproduction import-clause!
   defrule import-clause! = (import ?name:#id! with #:! (?ps:#prefix-clause! ...)) :
      qquote($import ~ name ~@ ps)
   defrule import-clause! = (import ?name:#id!) :
      qquote($import ~ name)
   fail-if import-clause! = () :
      CSE(closest-info(), "Expected import clause here.")

   defrule exp4 = (defpackage ?name:#id! : (?imports:#import-clause! ...)) :
      qquote($package ~ name ~@ imports)
   defrule exp4 = (defpackage ?name:#id!) :
      qquote($package ~ name)

   defrule id != (defpackage)


   ;                      DefStruct
   ;                      =========
   defrule exp4 = (defstruct ?name:#id! ?targs:#struct-targs ?parent:#struct-parent
                   ?fields:#struct-fields ?options:#struct-options) :
     val constructor = lookup?(options, `constructor, None())
     val printer = unwrap-token(value?(lookup?(options, `printer, None())))
     parse-syntax[core / #exp](
       gen-defstruct(name, targs, parent, fields, constructor, printer))

   defproduction struct-targs:List
   defrule struct-targs = ((@of ?xs:#id! ...)) : xs
   defrule struct-targs = () : List()

   defproduction struct-fields:List<StructField>
   defrule struct-fields = (: (?fs:#struct-field! ...)) : fs
   defrule struct-fields = () : List()

   defproduction struct-parent:Maybe
   defrule struct-parent = (<: ?p:#type!) : One(p)
   defrule struct-parent = () : None()

   defproduction struct-options:List<KeyValue<Symbol,?>>
   defrule struct-options = (with: (?options:#struct-option! ...)) : options
   defrule struct-options = () : List()

   defproduction struct-option!:KeyValue<Symbol,?>
   defrule struct-option! = (constructor => ?name:#id!) : `constructor => One(name)
   defrule struct-option! = (printer => ?v:#bool!) : `printer => One(v)
   fail-if struct-option! = () : CSE(closest-info(), "Expected struct option declaration here.")

   defproduction struct-field!:StructField
   defrule struct-field! = (?ds:#doc-string? ?name:#id! ?t:#field-type ?ops:#field-options) :
     val init = lookup?(ops, `init, None())
     val default = lookup?(ops, `default, None())
     val setter = lookup?(ops, `setter, None())
     val updater = lookup?(ops, `updater, None())
     defn void? (x:Maybe) : unwrap-token(value?(x)) == `void
     match(init:One, default:One) :
       throw(CSE(closest-info(), "Field '%~' cannot have both an initialization and a default value." % [name]))
     if void?(init) and empty?(setter) and empty?(updater) :
       throw(CSE(closest-info(), "Field '%~' is uninitialized and has no setter or updater." % [name]))     
     StructField(name, ds, t,
       lookup?(ops, `as-method),
       setter,
       updater,
       lookup?(ops, `ensure, None()),
       init, default)
   fail-if struct-field! = () : CSE(closest-info(), "Expected a field declaration here.")

   defproduction field-type
   defrule field-type = (: ?t:#type!) : t
   defrule field-type = () : `?

   defproduction field-options:List<KeyValue<Symbol,?>>
   defrule field-options = (with: (?options:#field-option! ...)) : options
   defrule field-options = () : List()

   defproduction field-option!:KeyValue<Symbol,?>
   defrule field-option! = (as-method => ?v:#bool!) : `as-method => unwrap-token(v)
   defrule field-option! = (setter => ?v:#id!) : `setter => One(v)
   defrule field-option! = (updater => ?v:#id!) : `updater => One(v)
   defrule field-option! = (init => ?v:#exp!) : `init => One(v)
   defrule field-option! = (default => ?v:#exp!) : `default => One(v)
   defrule field-option! = (ensure => ?v:#exp!) : `ensure => One(v)
   fail-if field-option! = () : CSE(closest-info(), "Expected a field option declaration here.")

   defrule id != (defstruct)

   ;                      defenum
   ;                      =======
   defrule exp4 = (defenum ?name:#id! ?parent:#struct-parent #:! (?args:#id! ...)) :
     val def = EnumDef(name, parent, to-tuple(args))
     parse-syntax[core / #exp!](compile(def))
   defrule id != (defenum)

   ;                      #define
   ;                      #======
   defrule exp4 = (~ #define(?flag:#id$)) :
      add-flag(unwrap-token(flag))
      `($begin)
   fail-if exp4 = (~ #define) :
      CSE(closest-info(), "Incorrect syntax for #define.")

   defrule id != (~ #define)

   ;               #if-defined/#if-not-defined
   ;               ===========================
   defproduction list!
   defrule list! = ((?xs ...)) : xs
   fail-if list! = () : CSE(closest-info(), "Expected a list here.")

   defrule exp4 = (~ #if-defined(?flag:#id$) #:! ?conseq:#list! ~ #else #:! ?alt:#list!) :
      val body = if flag-defined?(unwrap-token(flag)) : conseq
                 else : alt
      parse-syntax[core + current-overlays / #exp](List(body))
   defrule exp4 = (~ #if-defined(?flag:#id$) #:! ?conseq:#list!) :
      if flag-defined?(unwrap-token(flag)) : parse-syntax[core + current-overlays / #exp](List(conseq))
      else : `($begin)
   fail-if exp4 = (~ #if-defined) :
      CSE(closest-info(), "Incorrect syntax for #if-defined.")

   defrule exp4 = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list! ~ #else #:! ?alt:#list!) :
      val body = if not flag-defined?(unwrap-token(flag)) : conseq
                 else : alt
      parse-syntax[core + current-overlays / #exp](List(body))
   defrule exp4 = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list!) :
      if not flag-defined?(unwrap-token(flag)) : parse-syntax[core + current-overlays / #exp](List(conseq))
      else : `($begin)
   fail-if exp4 = (~ #if-not-defined) :
      CSE(closest-info(), "Incorrect syntax for #if-not-defined.")

   defrule id != (~ #if-defined | ~ #if-not-defined)

   ;                      Quasiquote
   ;                      ==========
   defrule exp4 = (qquote(?sexp ...)) :
      defn fill (sexp:List) -> List :
         match-syntax(sexp) :
            (~ ~ ?x ?rest ...) :
               qquote(core/cons(~ x, ~ (fill(rest))))
            (~@ ?x ?rest ...) :
               qquote(core/append(~ x, ~ (fill(rest))))
            ((?fs ...) ?rest ...) :
               qquote(core/cons(~ (fill(fs)), ~ (fill(rest))))
            (?x ?rest ...) :
               qquote(core/cons((@quote ~ x), ~ (fill(rest))))
            () :
               qquote(core/List())
      parse-syntax[core + current-overlays / #exp](fill(sexp))         
   fail-if exp4 = (qquote) :
      CSE(closest-info(), "Incorrect syntax for qquote.")
      
   defrule id != (qquote)

   ;                      DefSyntax
   ;                      =========
   defproduction rule : ExpRule
   ;Import rule
   defrule rule = (import (?names:#ids!) from ?package:#id!) : ImportRule(names, package)
   defrule rule = (import ?name:#id! from ?package:#id!) : ImportRule(List(name), package)

   ;Forwarding Rule
   defrule rule = (import ?name:#id! rules as ?new-name:#id!) : ImportRulesRule(name, new-name)

   ;Failed import rule
   fail-if rule = (import _ ?rest ...) : CSE(closest-info(rest), "Expected either 'from' keyword or 'rules as' keywords here.")

   ;Defproduction rule
   defproduction public? : True|False
   defrule public? = (public) : true
   defrule public? = () : false
   defrule rule = (?p:#public? defproduction ?name:#id! : ?type:#type!) : DefProductionRule(name, type, p)
   defrule rule = (?p:#public? defproduction ?name:#id!) : DefProductionRule(name, `?, p)

   ;Defrule rule
   defn prod? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : prefix?(x, "#")
         (x) : false
   defproduction prod! : Symbol|Token
   defrule prod! = (?x) when prod?(x) : x
   fail-if prod! = () : CSE(closest-info(), "Expected a production pattern here.")

   defproduction guard : Maybe
   defrule guard = (when ?guard:#exp!) : One(guard)
   defrule guard = () : None()
   
   defproduction lazy-binders : True|False
   defrule lazy-binders = (with lazy-binders) : true
   defrule lazy-binders = () : false

   defrule rule = (defrule ?e:#id! = (?pat ...) ?guard:#guard ?lb:#lazy-binders #:! ?body:#exp!) : DefActionRule(e, pat, guard, body, lb)
   defrule rule = (defrule ?e:#id! != (?pat ...) ?guard:#guard) : DefNotRule(e, pat, guard)   
   defrule rule = (defrule ?e:#id! = inline ?ie:#prod!) : DefInlineRule(e, ie)
   fail-if rule = (defrule ?e:#id! (!= | =)) : CSE(closest-info(), "Expected a pattern definition for rule.")
   fail-if rule = (defrule ?e:#id!) : CSE(closest-info(), "Expected either = or != operator after defrule.")

   ;Failif rule
   defproduction =!
   defrule =! = (=) : false
   fail-if =! = () : CSE(closest-info(), "Expected the = operator here.")
   defrule rule = (fail-if ?e:#id! #=! (?pat ...) ?guard:#guard ?lb:#lazy-binders #:! ?body:#exp!) : DefFailRule(e, pat, guard, body, lb)
   fail-if rule = (fail-if ?e:#id! #=!) : CSE(closest-info(), "Expected a pattern definition for fail-if rule.")

   ;Stanza expression rule
   defrule rule = (?e:#exp) : StanzaExpressionRule(e)

   ;Rule!
   defproduction rule! : ExpRule
   defrule rule! = (?r:#rule) : r
   fail-if rule! = () : CSE(closest-info(), "Expected either rule definition or expression.")

   ;Defsyntax rule
   defrule exp4 = (defsyntax ?name:#id! #:! (?rs:#rule! ...)) :
      parse-syntax[core / #exp](compile(DefSyntaxRule(name, rs)))

   defrule id != (defsyntax)

   ;                      MatchSyntax
   ;                      ===========
   ;Match pattern
   defproduction match-pat! : MatchPattern
   defrule match-pat! = ((?pat ...) when ?guard:#exp! #:! ?body:#exp!) : MatchPattern(pat, One(guard), body)
   defrule match-pat! = ((?pat ...) #:! ?body:#exp!) : MatchPattern(pat, None(), body)
   fail-if match-pat! = () : CSE(closest-info(), "Expected match pattern here.")
   
   ;Match packages
   defproduction match-pkg! : [Symbol|Token List<Symbol|Token>]
   defrule match-pkg! = (?base:#id! + ?overlays:#ids!) : [base, overlays]
   fail-if match-pkg! = (?base:#id! _) : CSE(closest-info(), "Expected + operator following base package.")
   defrule match-pkg! = (?base:#id!) : [base, List()]

   defrule exp4 = (match-syntax[?pkgs:#match-pkg!](?arg:#exp$) #:! (?ps:#match-pat! ...)) :
      val [base, overlays] = pkgs
      parse-syntax[core / #exp](
         compile(MatchSyntaxRule(base, overlays, arg, ps)))
   defrule exp4 = (match-syntax(?arg:#exp$) #:! (?ps:#match-pat! ...)) :
      parse-syntax[core / #exp](
         compile(MatchSyntaxRule(`empty, List(), arg, ps)))
   fail-if exp4 = (match-syntax) :
      CSE(closest-info(), "match-syntax must be followed by form to match upon in parenthesis.")

   defrule id != (match-syntax)

   ;                      ParseSyntax
   ;                      ===========
   defproduction parse-pat : List
   defrule parse-pat = (?e:#id! ~ ...) : List(e, `...)
   defrule parse-pat = (?e:#id!) : List(e)

   defproduction parse-props : [Symbol|Token, List<Symbol|Token>, List]
   defrule parse-props = (?base:#id + ((! /) ?overlays:#id) @... / ?pat:#parse-pat) :
      [base, overlays, pat]
   fail-if parse-props = (?base:#id + ((! /) ?overlays:#id) @...) :
      CSE(closest-info(), "parse-syntax is missing specified pattern.")
   defrule parse-props = (?base:#id / ?pat:#parse-pat) :
      [base, List(), pat]
   fail-if parse-props = () :
      CSE(closest-info(), "parse-syntax requires packages followed by pattern.")

   defrule exp4 = (parse-syntax[?props:#parse-props](?arg:#exp$)) :
      val [base, overlays, pattern] = props
      val template = `(
         match-syntax[base + overlays](form) :
            (?x:pattern) : x)
      parse-syntax[core / #exp](      
         fill-template(template, [
            `base => base
            `overlays => splice(overlays)
            `form => arg
            `pattern => splice(pattern)]))
            
   defrule id != (parse-syntax)

   ;                      #use-syntax
   ;                      #==========
   defn with-syntax (info:FileInfo|False, pkgs:List<Symbol>, f:() -> ?) :
     try :
       /with-syntax(pkgs, f)
     catch (e:NoSyntaxPackage) :
       throw(CSE(info, e))
       
   defn with-added-syntax (info:FileInfo|False, pkgs:List<Symbol>, f:() -> ?) :
     try :
       /with-added-syntax(pkgs, f)
     catch (e:NoSyntaxPackage) :
       throw(CSE(info, e))

   defproduction use-syntax-func : (FileInfo|False, List<Symbol>, () -> ?) -> ?
   defrule use-syntax-func = (~ #use-syntax) : with-syntax
   defrule use-syntax-func = (~ #use-added-syntax) : with-added-syntax

   defrule exp4 = (?f:#use-syntax-func(?names:#ids!) ?rest ...) :
      f{closest-info(), unwrap-all(names), _} $ fn () :
         parse-syntax[core + current-overlays / #exp](List(rest))
   fail-if exp4 = (#use-syntax-func) :
      CSE(closest-info(), "Invalid syntax for #use-syntax/#use-added-syntax.")
      
   defrule id != (#use-syntax-func)   

   ;                      #with-syntax
   ;                      #===========
   defproduction with-syntax-func : (FileInfo|False, List<Symbol>, () -> ?) -> ?
   defrule with-syntax-func = (~ #with-syntax) : with-syntax
   defrule with-syntax-func = (~ #with-added-syntax) : with-added-syntax

   defrule exp4 = (?f:#with-syntax-func(?names:#ids!) #:! ?body) :
      f{closest-info(), unwrap-all(names), _} $ fn () :
         parse-syntax[core + current-overlays / #exp](List(body))
   fail-if exp4 = (#with-syntax-func) :
      CSE(closest-info(), "Invalid syntax for #with-syntax/#with-added-syntax.")
      
   defrule id != (#with-syntax-func)   

   ;                 Negation Operators
   ;                 ==================
   defrule exp4 = ((- ?x:#exp$)) : qquote($do negate ~ x)
   defrule exp4 = ((~ ~ ?x:#exp$)) : qquote($do bit-not ~ x)
   defrule id != (~ ~)

   ;                  Quote Syntax
   ;                  ============
   defrule exp4 = ((@quote ?rest ...)) :
      if length(rest) == 1 : qquote($quote ~ (head(rest)))
      else : CSE(closest-info(rest), "Expected a single form here.")

   ;                   #FILEINFO
   ;                   =========
   defrule exp4 = (~ #FILEINFO) :
     match(closest-info()) :
       (info:FileInfo) :
         val filled = fill-template(`(core/FileInfo(filename, line, column)), [
           `filename => filename(info),
           `line => line(info),
           `column => column(info)])
         parse-syntax[core / #exp](filled)
       (f:False) :
         false
   defrule id != (~ #FILEINFO)

   ;                  Begin Expression
   ;                  ================
   defrule exp4 = ((?x:#exp ?xs:#exps!)) :
      if empty?(xs) : x
      else : qquote($begin ~ x ~@ xs)
   defrule exp4 = (()) : wrap-info(closest-info(), `($begin))

   ;                        LoStanza Externs
   ;                        ================
   defproduction ->!
   defrule ->! = (?x: ->) : true
   fail-if ->! = () : CSE(closest-info(), "Expected -> operator here.")
   
   defrule exp4 = (extern defn ?name:#id! ((?xs:#id! #:! ?ts:#ls-type!) @...) #->! ?rt:#ls-type! #:! ?c:#ls-stmt!) :
      qquote($ls-extern-fn ~ name ~ xs ~ ts ~ rt ~ c)
   defrule exp4 = (extern ?name:#id! #:! ?t:#ls-type!) :
      qquote($ls-extern ~ name ~ t)

   ;                      LoStanza DefType
   ;                      ================
   defproduction ls-deffield-mut
   defrule ls-deffield-mut = (var) : true
   defrule ls-deffield-mut = () :    false

   defproduction ls-deffield!
   defrule ls-deffield! = ((! ~ ...) ?mut:#ls-deffield-mut ?name:#id! #:! ?t:#ls-type!) :
      qquote($ls-deffield ~ mut ~ t ~ name)

   defproduction ls-type-name
   defrule ls-type-name = (?name:#id!<?targs:#ids!>) : qquote($ls-of ~ name ~@ targs)
   defrule ls-type-name = (?name:#id!) : name

   defproduction ls-type-parent
   defrule ls-type-parent = (<: ?t:#type!) : t
   defrule ls-type-parent = () : `($none)

   fail-if exp4 = (lostanza deftype ?name:#ls-type-name ?p:#ls-type-parent : ?x:(~ ...)) :
      CSE(closest-info(x), "Rest field ellipsis must be preceded by field declaration.")
   defrule exp4 = (lostanza deftype ?name:#ls-type-name ?p:#ls-type-parent :
                     ?fields:#ls-deffield! ... ~ ...) :
      qquote($ls-deftype ~ name ~ p ~ (but-last(fields)) ~ (last(fields)))
   defrule exp4 = (lostanza deftype ?name:#ls-type-name ?p:#ls-type-parent :
                     ?fields:#ls-deffield! ...) :
      qquote($ls-deftype ~ name ~ p ~ fields ($none))
   defrule exp4 = (lostanza deftype ?name:#ls-type-name ?p:#ls-type-parent) :
      qquote($ls-deftype ~ name ~ p () ($none))

   defrule id != (~ ...)

   
   ;                        LoStanza Defn
   ;                        =============

   defproduction ls-defn-tag : Symbol
   defrule ls-defn-tag = (defn) : `$ls-defn
   defrule ls-defn-tag = (defn*) : `$ls-defn*
   
   defrule exp4 = (lostanza ?tag:#ls-defn-tag ?name:#id!<?targs:#type-arg! ...>
                      ((?xs:#id! #:! ?ts:#ls-type!) @...) #->! ?rt:#ls-type! #:! ?c:#ls-stmt!) :
      qquote(~ tag ($ls-of ~ name ~@ targs) ~ xs ~ ts ~ rt ~ c)
   defrule exp4 = (lostanza ?tag:#ls-defn-tag ?name:#id!
                      ((?xs:#id! #:! ?ts:#ls-type!) @...) #->! ?rt:#ls-type! #:! ?c:#ls-stmt!) :
      qquote(~ tag ~ name ~ xs ~ ts ~ rt ~ c)

   ;                        LoStanza Defmethod
   ;                        ==================
   defproduction ls-defmethod-tag : Symbol
   defrule ls-defmethod-tag = (defmethod) : `$ls-defmethod
   defrule ls-defmethod-tag = (defmethod*) : `$ls-defmethod*
   
   defrule exp4 = (lostanza ?tag:#ls-defmethod-tag ?multi:#id!<?targs:#type-arg! ...>
                      ((?xs:#id! #:! ?ts:#ls-type!) @...) #->! ?rt:#ls-type! #:! ?c:#ls-stmt!) :
      qquote(~ tag ($ls-of ~ multi ~@ targs) ~ xs ~ ts ~ rt ~ c)

   defrule exp4 = (lostanza ?tag:#ls-defmethod-tag ?multi:#id!
                      ((?xs:#id! #:! ?ts:#ls-type!) @...) #->! ?rt:#ls-type! #:! ?c:#ls-stmt!) :
      qquote(~ tag ~ multi ~ xs ~ ts ~ rt ~ c)

   ;                        LoStanza Vars
   ;                        =============
   defrule exp4 = (lostanza var ?name:#id! : ?type:#ls-type! = ?e:#ls-exp!) :
      qquote($ls-defvar ~ name ~ type ~ e)
   defrule exp4 = (lostanza var ?name:#id! : ?type:#ls-type!) :
      qquote($ls-defvar ~ name ~ type ($none))

   ;                        LoStanza Vals
   ;                        =============
   defrule exp4 = (lostanza val ?name:#id! : ?type:#ls-type! = ?e:#ls-exp!) :
      qquote($ls-def ~ name ~ type ~ e)
   defrule exp4 = (lostanza val ?name:#id! = ?e:#ls-exp!) :
      qquote($ls-def ~ name ($none) ~ e)

   ;                        LoStanza Let
   ;                        ============   
   defrule exp4 = (lostanza let #:! ?c:#ls-stmt!) :
      qquote($ls-let ~ c)   

   ;                    Atoms
   ;                    =====
   defrule exp4 = (?x:#literal) : x
   defrule exp4 = (?x:#id) : x

   ;                      LoStanza Error Handling
   ;                      =======================
   public defproduction ls-type!
   public defproduction ls-type$
   public defproduction ls-types!
   defrule ls-type! = (?x:#ls-type) : x
   fail-if ls-type! = () : CSE(closest-info(), "LoStanza type expected here.")
   defrule ls-type$ = (?x:#ls-type! (! _)) : x
   fail-if ls-type$ = () : CSE(closest-info(), "Expected a single LoStanza type here.")
   defrule ls-types! = (?x:#ls-type! ...) : x

   public defproduction ls-exp!
   public defproduction ls-exp$
   public defproduction ls-exps!
   defrule ls-exp! = (?x:#ls-exp) : x
   fail-if ls-exp! = () : CSE(closest-info(), "LoStanza expression expected here.")
   defrule ls-exp$ = (?x:#ls-exp! (! _)) : x
   fail-if ls-exp$ = () : CSE(closest-info(), "Expected a single LoStanza expression here.")
   defrule ls-exps! = (?x:#ls-exp! ...) : x

   public defproduction ls-stmt!
   public defproduction ls-stmt$
   public defproduction ls-stmts!
   defrule ls-stmt! = (?x:#ls-stmt) : x
   fail-if ls-stmt! = () : CSE(closest-info(), "LoStanza statement expected here.")
   defrule ls-stmt$ = (?x:#ls-stmt! (! _)) : x
   fail-if ls-stmt$ = () : CSE(closest-info(), "Expected a single LoStanza statement here.")
   defrule ls-stmts! = (?x:#ls-stmt! ...) : x

   defproduction ls-exp0!
   defrule ls-exp0! = (?x:#ls-exp0) : x
   fail-if ls-exp0! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp1!
   defrule ls-exp1! = (?x:#ls-exp1) : x
   fail-if ls-exp1! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp2!
   defrule ls-exp2! = (?x:#ls-exp2) : x
   fail-if ls-exp2! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp3!
   defrule ls-exp3! = (?x:#ls-exp3) : x
   fail-if ls-exp3! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp4!
   defrule ls-exp4! = (?x:#ls-exp4) : x
   fail-if ls-exp4! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp5!
   defrule ls-exp5! = (?x:#ls-exp5) : x
   fail-if ls-exp5! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   ;                      LoStanza Types
   ;                      ==============
   public defproduction ls-type
   public defproduction ls-type0

   ;Precedence level 0      
   defrule ls-type = (?a:#ls-type0 -> ?b:#ls-type!) : qquote($ls-fn (~ a) ($none) ~ b)
   defrule ls-type = ((((! ~ ...) ?xs:#ls-type) @... ~ ...) -> ?b:#ls-type!) :
      val a = but-last(xs)
      val r = last(xs)
      qquote($ls-fn ~ a ~ r ~ b)
   defrule ls-type = ((?a:#ls-types!) -> ?b:#ls-type!) : qquote($ls-fn ~ a ($none) ~ b)
   defrule ls-type = (?x:#ls-type0) : x

   ;Precedence level 0
   defrule ls-type0 = (?x:(#stanza-tag _ ...)) : x
   defrule ls-type0 = (byte) : wrap-info(closest-info(), `($ls-byte))
   defrule ls-type0 = (int) : wrap-info(closest-info(), `($ls-int))
   defrule ls-type0 = (long) : wrap-info(closest-info(), `($ls-long))
   defrule ls-type0 = (float) : wrap-info(closest-info(), `($ls-float))
   defrule ls-type0 = (double) : wrap-info(closest-info(), `($ls-double))
   defrule ls-type0 = (?) : wrap-info(closest-info(), `($ls-?))
   defrule ls-type0 = (ptr<?x:#ls-type$>) : qquote($ls-ptr ~ x)
   defrule ls-type0 = (ref<?x:#type$>) : qquote($ls-ref ~ x)
   defrule ls-type0 = (?x:#id<?ts:#types!>) : qquote($ls-of ~ x ~@ ts)
   defrule ls-type0 = (?x:#id) : x
   defrule ls-type0 = ((?x:#ls-type)) : x

   ;                      LoStanza Expressions
   ;                      ====================
   public defproduction ls-exp  ; and / or
   public defproduction ls-exp0 ; ==, !=, <, <=, >, >=
   public defproduction ls-exp1 ; +, -
   public defproduction ls-exp2 ; *, %, /
   public defproduction ls-exp3 ; <<, >>, >>>
   public defproduction ls-exp4 ; others
   public defproduction ls-exp5

   defproduction ls-op0 : Symbol
   defproduction ls-op1 : Symbol
   defproduction ls-op2 : Symbol
   defproduction ls-op3 : Symbol
   defproduction ls-op4 : Symbol

   defrule ls-op0 = (<) : `lt
   defrule ls-op0 = (<=) : `le
   defrule ls-op0 = (>) : `gt
   defrule ls-op0 = (>=) : `ge
   defrule ls-op0 = (!=) : `ne
   defrule ls-op0 = (==) : `eq

   defrule ls-op1 = (+) : `add
   defrule ls-op1 = (-) : `sub
   defrule ls-op1 = (~ |) : `or

   defrule ls-op2 = (*) : `mul
   defrule ls-op2 = (/) : `div
   defrule ls-op2 = (%) : `mod
   defrule ls-op2 = (&) : `and
   defrule ls-op2 = (^) : `xor

   defrule ls-op3 = (<<) : `shl
   defrule ls-op3 = (>>) : `shr
   defrule ls-op3 = (>>>) : `ashr

   defrule ls-exp = (?x:#ls-exp and ?y:#ls-exp0!) : qquote($ls-and ~ x ~ y)
   defrule ls-exp = (?x:#ls-exp or ?y:#ls-exp0!) : qquote($ls-or ~ x ~ y)
   defrule ls-exp = (?x:#ls-exp0) : x

   defrule ls-exp0 = (?x:#ls-exp0 ?f:#ls-op0 ?y:#ls-exp1!) : qquote($ls-prim ~ f ~ x ~ y)
   defrule ls-exp0 = (?x:#ls-exp1) : x
   defrule ls-exp1 = (?x:#ls-exp1 ?f:#ls-op1 ?y:#ls-exp2!) : qquote($ls-prim ~ f ~ x ~ y)
   defrule ls-exp1 = (?x:#ls-exp2) : x
   defrule ls-exp2 = (?x:#ls-exp2 ?f:#ls-op2 ?y:#ls-exp3!) : qquote($ls-prim ~ f ~ x ~ y)
   defrule ls-exp2 = (?x:#ls-exp3) : x
   defrule ls-exp3 = (?x:#ls-exp3 ?f:#ls-op3 ?y:#ls-exp4!) : qquote($ls-prim ~ f ~ x ~ y)
   defrule ls-exp3 = (?x:#ls-exp4) : x

   ;                      Suffix Operators
   ;                      ================
   defrule ls-exp4 = (?x:#ls-exp4 as ?t:#ls-type!) : qquote($ls-as ~ x ~ t)
   defrule ls-exp4 = (?x:#ls-exp4[?i:#ls-exp!]) : qquote($ls-slot ~ x ~ i)
   defrule ls-exp4 = (?x:#ls-exp4 . ?f:#id!) : qquote($ls-field ~ x ~ f)
   defrule ls-exp4 = (?x:#ls-exp4(?ys:#ls-exps!)) : qquote($ls-do ~ x ~@ ys)
   defrule ls-exp4 = (?x:#ls-exp4<?ts:#types!>(?ys:#ls-exps!)) : qquote($ls-do ($ls-of ~ x ~@ ts) ~@ ys)
   defrule ls-exp4 = (?x:#ls-exp5) : x

   ;                    Prefix Operators
   ;                    ================
   defrule ls-exp5 = (?x:(#stanza-tag _ ...)) : x

   defrule ls-exp5 = (sizeof(?t:#ls-type$)) : qquote($ls-sizeof ~ t)
   
   defrule ls-exp5 = (tagof(?tag:#id$)) : qquote($ls-tagof ~ tag)
   
   defrule ls-exp5 = (new ?name:#id!{?xs:#ls-exps!}) : qquote($ls-new ~ name ~@ xs)
   defrule ls-exp5 = (new ?name:#id!<?ts:#types!>{?xs:#ls-exps!}) : qquote($ls-new ($ls-of ~ name ~@ ts) ~@ xs)
   
   defrule ls-exp5 = (addr(?e:#ls-exp$)) : qquote($ls-addr ~ e)
   defrule ls-exp5 = (addr!(?e:#ls-exp$)) : qquote($ls-addr! ~ e)
   fail-if ls-exp5 = (?x:(addr | addr!)) : CSE(closest-info(), "Expected one argument after %_ operator." % [x])

   defproduction end!
   defrule end! = (! _) : true
   fail-if end! = () : CSE(closest-info(), "Unexpected symbol here.")   

   defrule ls-exp5 = (?name:#id{?xs:#ls-exps!}) : qquote($ls-struct ~ name ~@ xs)
   defrule ls-exp5 = (?name:#id<?ts:#types!>{?xs:#ls-exps!}) : qquote($ls-struct ($ls-of ~ name ~@ ts) ~@ xs)
   
   defrule ls-exp5 = (call-c ?f:#ls-exp5!(?ys:#ls-exps!)) : qquote($ls-call-c ~ f ~@ ys)
   fail-if ls-exp5 = (call-c) : CSE(closest-info(), "Expected function call after call-c keyword.")
   
   defrule ls-exp5 = (call-prim ?f:#id!(?ys:#ls-exps!)) : qquote($ls-prim ~ f ~@ ys)
   fail-if ls-exp5 = (call-prim) : CSE(closest-info(), "Expected function call after call-prim keyword.")
   
   defrule ls-exp5 = (fn(?x:#id$)) : qquote($ls-func ~ x)
   fail-if ls-exp5 = (fn) : CSE(closest-info(), "Expected identifier of referenced function after fn keyword.")
   
   defrule ls-exp5 = (let #:! ?c:#ls-stmt! in ?e:#ls-exp!) : qquote($ls-letexp ~ c ~ e)
   fail-if ls-exp5 = (let #:! ?c:#ls-stmt! ?rest ...) : CSE(closest-info(rest), "Expected the in keyword here.")

   defrule ls-exp5 = ([?x:#ls-exp$]) : qquote($ls-deref ~ x)
   defrule ls-exp5 = ((- ?x:#ls-exp$)) : qquote($ls-prim neg ~ x)
   defrule ls-exp5 = ((~ ~ ?x:#ls-exp$)) : qquote($ls-prim not ~ x)      
   defrule ls-exp5 = ((?x:#ls-exp)) : x
   defrule ls-exp5 = (?x:#literal) : x
   defrule ls-exp5 = (?x:#id) : x


   ;                     LoStanza Statements
   ;                     ===================
   public defproduction ls-stmt

   ;                        Block Tags
   ;                        ==========
   defrule ls-stmt = (?x:(#stanza-tag _ ...)) : x

   ;                        Values
   ;                        ======
   defrule ls-stmt = (val ?x:#id! : ?t:#ls-type! = ?e:#ls-exp!) :
      qquote($ls-def ~ x ~ t ~ e)
   defrule ls-stmt = (val ?x:#id! : ?t:#ls-type!) :
      CSE(closest-info(), "Missing initialization value for val %_." % [x])
   defrule ls-stmt = (val ?x:#id! = ?e:#ls-exp!) :
      qquote($ls-def ~ x ($none) ~ e)
   defrule ls-stmt = (val ?x:#id!) :
      CSE(closest-info(), "Missing initialization value for val %_." % [x])
      
   ;                        Variables
   ;                        =========
   defrule ls-stmt = (var ?x:#id! #:! ?t:#ls-type! = ?e:#ls-exp!) :
      qquote($ls-defvar ~ x ~ t ~ e)
   defrule ls-stmt = (var ?x:#id! #:! ?t:#ls-type!) :
      qquote($ls-defvar ~ x ~ t ($none))

   ;                        Return
   ;                        ======
   defrule ls-stmt = (return ?e:#ls-exp!) : qquote($ls-return ~ e)

   ;                        Labels
   ;                        ======
   defproduction ls-block
   defrule ls-block = (?name:#id! ((?xs:#id! #:! ?ts:#ls-type!) @...) #:! ?body:#ls-stmt!) :
      qquote($ls-block ~ name ~ xs ~ ts ~ body)
   defrule ls-block = (?name:#id! #:! ?body:#ls-stmt!) :
      qquote($ls-block ~ name () () ~ body)         
   defrule ls-stmt = (labels #:! (?bs:#ls-block ...)) :
      qquote($ls-labels ~@ bs)

   ;                        Goto
   ;                        ====
   defrule ls-stmt = (goto ?x:#id!(?args:#ls-exps!)) : qquote($ls-goto ~ x ~@ args)
   defrule ls-stmt = (goto ?x:#id!) : qquote($ls-goto ~ x)
   
   ;                        Let
   ;                        ===
   defrule ls-stmt = (let #:! ?c:#ls-stmt!) : qquote($ls-let ~ c)

   ;                        If
   ;                        ==
   defproduction ls-if
   defrule ls-if = (if ?pred:#ls-exp! #:! ?conseq:#ls-stmt! else : ?alt:#ls-stmt!) :
      qquote($ls-if ~ pred ~ conseq ~ alt)
   defrule ls-if = (if ?pred:#ls-exp! #:! ?conseq:#ls-stmt! else ?alt:#ls-if) :
      qquote($ls-if ~ pred ~ conseq ~ alt)
   defrule ls-if = (if ?pred:#ls-exp! #:! ?conseq:#ls-stmt!) :
      qquote($ls-if ~ pred ~ conseq ($begin))
   defrule ls-stmt = (?c:#ls-if) : c

   ;                        While
   ;                        =====
   defrule ls-stmt = (while ?pred:#ls-exp! #:! ?body:#ls-stmt!) :
      val template = `(
         labels :
            loop :
               if pred :
                  body
                  goto loop)
      parse-syntax[core / #ls-stmt](            
         fill-template(template, [
            `pred => pred
            `body => body
            `loop => gensym(`loop)]))

   ;                        Match
   ;                        =====
   defproduction branch-arg : KeyValue
   defrule branch-arg = (?x:#id! : ?t:#ls-type!) : x => t
   defrule branch-arg = (?x:#id!) : x => `($none)
   defrule ls-stmt = (match(?es:#ls-exps!) #:! (
                         ((?argss:#branch-arg ...) #:! ?bodies:#ls-stmt!) @...)) :
      val template =
         `($ls-match args
            branches{
               ($ls-branch xs ts body)
            })
      fill-template(template, [
         `args => es
         `branches => nested $ for (args in argss, body in bodies) map : [
            `xs => map(key, args)
            `ts => map(value, args)
            `body => body]])
   fail-if ls-stmt = (match) :
      CSE(closest-info(), "Expected list of arguments after match keyword.")

   
   ;                        For
   ;                        ===
   defrule ls-stmt = (for (?def:#ls-stmt!, ?pred:#ls-exp!, ?step:#ls-stmt!) #:!
                         ?body:#ls-stmt!) :
      val template = `(
         let :
            def
            labels :
               loop :
                  if pred :
                     body
                     step
                     goto loop)
      parse-syntax[core / #ls-stmt](            
         fill-template(template, [
            `def => def
            `loop => gensym(`loop)
            `pred => pred
            `body => body
            `step => step]))
   fail-if ls-stmt = (for) :
      CSE(closest-info(), "Expected list after for keyword.")   

   ;                        Set
   ;                        ===
   defrule ls-stmt = (?x:#ls-exp = ?y:#ls-exp!) : qquote($ls-set ~ x ~ y)

   ;              Side-Effecting Expressions
   ;              ==========================
   defrule ls-stmt = (?x:#ls-exp) : x

   ;                   Statement Groups
   ;                   ================
   defrule ls-stmt = ((?c:#ls-stmt ?cs:#ls-stmts!)) : qquote($begin ~ c ~@ cs)
   defrule ls-stmt = (()) : `($begin)


   ;                    #if-defined/#if-not-defined
   ;                    ===========================
   defrule ls-stmt = (~ #if-defined(?flag:#id$) #:! ?conseq:#list! ~ #else #:! ?alt:#list!) :
      val body = 
         if flag-defined?(unwrap-token(flag)) : conseq
         else : alt
      parse-syntax[core + current-overlays / #ls-stmt](List(body))   
   defrule ls-stmt = (~ #if-defined(?flag:#id$) #:! ?conseq:#list!) :
      if flag-defined?(unwrap-token(flag)) : parse-syntax[core + current-overlays / #ls-stmt](List(conseq))   
      else : `($begin)
   fail-if ls-stmt = (~ #if-defined) :
      CSE(closest-info(), "Incorrect syntax for #if-defined.")

   defrule ls-stmt = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list! ~ #else #:! ?alt:#list!) :
      val body = 
         if not flag-defined?(unwrap-token(flag)) : conseq
         else : alt
      parse-syntax[core + current-overlays / #ls-stmt](List(body))   
   defrule ls-stmt = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list!) :
      if not flag-defined?(unwrap-token(flag)) : parse-syntax[core + current-overlays / #ls-stmt](List(conseq))   
      else : `($begin)
   fail-if ls-stmt = (~ #if-not-defined) :
      CSE(closest-info(), "Incorrect syntax for #if-not-defined.")

   ;                   Literal
   ;                   =======
   public defproduction literal : Token|Char|String|Byte|Int|Long|Float|Double|True|False
   defrule literal = (?x) when unwrap-token(x) is Char|String|Byte|Int|Long|Float|Double|True|False : x

   ;                Identifier
   ;                ==========
   public defproduction id : Symbol|Token
   defrule id != (#stanza-tag)
   defrule id != (#lexer-tag)
   defrule id = (?x) when unwrap-token(x) is Symbol : x


;============== Error Messages ============================
val BAD-ARGLIST-MSG = "Incorrect syntax for argument list. Did you forget to put a space between the function name and the argument list?"
val BAD-MATCH-MSG = "Incorrect syntax for match expression. Is there an extra space between match and the argument list?"
val BAD-FOR-MSG = "Missing operating function in for expression. Did you forget to put a do after the bindings?"

