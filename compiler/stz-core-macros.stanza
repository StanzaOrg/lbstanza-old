;See License.txt for details about licensing.

defpackage stz/core-macros :
   import core
   import macro-utils
   import collections
   import stz/parser ;TODO: WHY IS THIS NECESSARY?
   import stz/params

defn first-info (form) -> FileInfo|False :
   defn loop (form) -> Maybe<FileInfo> :
      match(form) :
         (form:Token) : One(info(form))
         (form:List) : first(loop, form)
         (form) : None()
   value?(loop(form))      

defn CSE (form, msg) :
   throw $ new Exception :
      defmethod print (o:OutputStream, this) :
         match(first-info(form)) :
            (info:FileInfo) : print(o, "%_: Syntax Error: %_" % [info msg])
            (info:False) : print(o, "Syntax Error: %_ Received %~." % [msg, form])

defn atom? (x) :
   unwrap-token(x) is-not List

val tags = `(
   $package $import $prefix-of $prefix $public $protected $deftype $defchild $def
   $defvar $defn $defn* $defmulti $defmethod $defmethod* $fn $fn*
   $multi $begin $let $match $branch $new $as $as? $set $do
   $prim $tuple $quote $none $of $and $or $->
   $cap $void $? $ls-new $ls-struct $ls-addr $ls-addr! $ls-deref
   $ls-slot $ls-field $ls-do $ls-do-in-stack $ls-do-stack $ls-call-c $ls-prim $ls-sizeof $ls-tagof $ls-as
   $ls-letexp $ls-and $ls-or $ls-set $ls-labels $ls-block $ls-goto $ls-return
   $ls-let $ls-if $ls-match $ls-branch $ls-func $ls-def $ls-defvar $ls-deftype
   $ls-defn $ls-defn* $ls-defmethod $ls-defmethod* $ls-extern $ls-byte $ls-int $ls-long $ls-float $ls-double
   $ls-? $ls-of $ls-ptr $ls-ref $ls-fn)
      
defn tagged? (x) :
   match(x) :
      (x:Token) : tagged?(item(x))
      (x:FullList) :
         match(unwrap-token(head(x))) :
            (h:Symbol) : contains?(tags, h)
            (h) : false
      (x) : false

defn identifier? (x) :
   val special = `(@do @do-afn @get @of @cap @quote @tuple :)
   match(unwrap-token(x)) :
      (x:Symbol) : (not contains?(tags, x)) and (not contains?(special, x))
      (x) : false

defn expande (form) :
   with-syntax(core) :
      match-syntax(form) :
         (?e:#exp) : e

defn expandc (form) :
   with-syntax(core) :
      match-syntax(form) :
         (?c:#ls-comm) : c

defn continue-expand (form) :
   match-syntax(form) :
      (?e:#exp) : e

defn* apply-suffix-ops (x, fs:List) :
   if empty?(fs) : x
   else : apply-suffix-ops(head(fs)(x), tail(fs))

defstruct StructField :
   name
   type
   as-method?: True|False
   setter
   box

;==== PARSING RULES ====
defsyntax core :
   ;Immediates
   defrule :
      type! = (?x:#type) : x
      type! != () : CSE(form, "Type expected here.")

      type$ = (?x:#type ?rest ...) :
         if empty?(rest) : x
         else : CSE(form, "Expected a single type here.")
      type$ != () : CSE(form, "Expected a single type here.")
      
      types! = (?xs:#type ... ?rest ...) :
         if empty?(rest) : xs
         else : CSE(rest, "Expected a type here.")
      
      t1! = (?x:#t1) : x
      t1! != () : CSE(form, "Expected a type here.")

      id = (?x) when identifier?(x) : x
      id! = (?x) :
         if identifier?(x) : x
         else : CSE(form, "Expected an identifier here.")
         
      id$ = (?x:#id! ?rest ...) :
         if empty?(rest) : x
         else : CSE(form, "Expected a single identifier here.")
      id$ != () : CSE(form, "Expected a single identifier here.")

      exp! = (?x:#exp) : x
      exp! != () : CSE(form, "Expected an expression here.")
      
      exps! = (?xs:#exp ... ?rest ...) :
         if empty?(rest) : xs
         else : CSE(rest, "Expected an expression here.")
         
      exp$ = (?x:#exp ?rest ...) :
         if empty?(rest) : x
         else : CSE(form, "Expected a single expression here.")
      exp$ != () : CSE(form, "Expected a single expression here.")

      :! = (:) : (`:)
      :! != () : CSE(form, "Expected a colon here.")
   
   ;Type Definitions
   defrule :
      type = (?x:#t0 -> ?y:#type!) : qquote($-> (~ x) ~ y)
      type = ((?xs:#types!) -> ?y:#type!) : qquote($-> ~ xs ~ y)
      type = (?x:#t0) : x

      t0 = (?x:#t1 ?ops:#tops ...) : apply-suffix-ops(x, ops)
      tops = (& ?y:#t1!) : {qquote($and ~ _ ~ y)}
      tops = (~ | ?y:#t1!) : {qquote($or ~ _ ~ y)}

      t1 = (?x) when tagged?(x) : x
      t1 = ((~ @cap ?x:#id$)) : qquote($cap ~ x)
      t1 = ([?xs:#types!]) : qquote($tuple ~@ xs)
      t1 = ((?x:#type)) : x
      t1 = (?x:#id!<?ys:#types!>) : qquote($of ~ x ~@ ys)
      t1 = (?) : `($?)
      t1 = (Void) : `($void)
      t1 = (?x) when atom?(x) :
         if identifier?(x) : x
         else : CSE(form, "Expected identifier here.")

   ;Expression Structure
   defrule :
      ;Precedence Levels
      exp = (?x:#e0 ?ops:#eop0 ...) : apply-suffix-ops(x, ops)
      e0 = (?x:#e1 ?ops:#eop1 ...) : apply-suffix-ops(x, ops)
      e1 = (?x:#e2 ?ops:#eop2 ...) : apply-suffix-ops(x, ops)
      e2 = (?x:#e3 ?ops:#eop3 ...) : apply-suffix-ops(x, ops)
      e3 = (?x:#e4 ?ops:#eop4 ...) : apply-suffix-ops(x, ops)
      e4 = (?x:#e5 ?ops:#eop5 ...) : apply-suffix-ops(x, ops)
      e5 = (?x:#term ?ops:#suffix-op ...) : apply-suffix-ops(x, ops)

      ;Expression Terms
      term = (?x) when tagged?(x) : x
      term = (?x:#prefix-op) : x
      term = ((@quote ?rest ...)) :
         if length(rest) == 1 : qquote($quote ~ (head(rest)))
         else : CSE(form, "Expected a single form here.")
      term = ((- ?x:#exp$)) : qquote($do negate ~ x)
      term = ((~ ~ ?x:#exp$)) : qquote($do bit-not ~ x)
      
      term = ((?x:#exp ?xs:#exps!)) :
         if empty?(xs) : x
         else : qquote($begin ~ x ~@ xs)
      term = (()) : `($begin)
      term = (?x) when atom?(x) : x

   ;Operators
   defrule :
      ;And/Or Operators
      eop0 = (and ?y:#e0) :
         fn (x) :
            expande $ qquote(if ~ x : ~ y as? core/True|core/False)            
      eop0 = (or ?y:#e0) :
         fn (x) : 
            val template = `(
               if x : true
               else : y as? core/True|core/False)
            expande $ fill-template(template, [
               `x => x
               `y => y])

      ;Comparison Operators
      op1 = (==) : `equal?
      op1 = (!=) : `not-equal?
      op1 = (<) : `less?
      op1 = (<=) : `less-eq?
      op1 = (>) : `greater?
      op1 = (>=) : `greater-eq?
      
      eop1 = (?f:#op1 ?y:#e1) : (fn (x) : qquote($do ~ f ~ x ~ y))         
      eop1 != (#op1 | !=) : CSE(form, "Expected expression after operand %~." % [head(form)])

      ;Addition Operators
      op2 = (+) : `plus
      op2 = (-) : `minus      
      eop2 = (?f:#op2 ?y:#e2) : (fn (x) : qquote($do ~ f ~ x ~ y))
      eop2 != (#op2) : CSE(form, "Expected expression after operand %~." % [head(form)])
      
      ;Multiplication Operators
      op3 = (*) : `times
      op3 = (%) : `modulo
      op3 = (/) : `divide      
      eop3 = (?f:#op3 ?y:#e3) : (fn (x) : qquote($do ~ f ~ x ~ y))
      eop3 != (#op3) : CSE(form, "Expected expression after operand %~." % [head(form)])

      ;Shift Operators
      op4 = (<<) : `shift-left
      op4 = (>>) : `shift-right
      op4 = (>>>) : `arithmetic-shift-right
      eop4 = (?f:#op4 ?y:#e4) : (fn (x) : qquote($do ~ f ~ x ~ y))
      eop4 != (#op4) : CSE(form, "Expected expression after operand %~" % [head(form)])

      ;Bitwise Operators
      op5 = (&) : `bit-and
      op5 = (~ |) : `bit-or
      op5 = (^) : `bit-xor      
      eop5 = (?f:#op5 ?y:#e5) : (fn (x) : qquote($do ~ f ~ x ~ y))
      eop5 != (#op5) : CSE(form, "Expected expression after operand %~" % [head(form)])

   ;Apply operator
   defrule do :
      suffix-op = ((@do ?ys:#exps!)) :
         fn (x) : qquote($do ~ x ~@ ys)

   ;Type Apply operator
   defrule of :
      suffix-op = ((@of ?ys:#types!)) :
         fn (x) : qquote($of ~ x ~@ ys)

   ;Set Operator
   defrule set :
      suffix-op = ((@get ?es:#exps!) = ?v:#exp!) :
         fn (x) : qquote($do set ~ x ~@ es ~ v)
            
   ;Get Operator
   defrule get :
      suffix-op = ((@get ?ys:#exps!)) :
         fn (x) : qquote($do get ~ x ~@ ys)

   ;Delayed Apply Operator
   defrule do-afn :
      suffix-op = ((@do-afn ?body ...)) :
         fn (x) : expande $ qquote({~ x(~@ body)})

   ;Cast operator
   defrule as :
      suffix-op = (as ?t:#type!) :
         {qquote($as ~ _ ~ t)}

   ;Upcast operator
   defrule as? :
      suffix-op = (as? ?t:#type!) :
         {qquote($as? ~ _ ~ t)}

   ;Argument Lists
   defrule :
      binder = ([?xs:#binder ...]) : qquote($tuple ~@ xs)
      binder = (?x:#id!) : x

      argbinding = (?x:#binder : ?t:#type!) : x => t
      argbinding = (?x:#binder) : x => `($none)
      
      arglist != ((@do _ ...)) :
         CSE(form, BAD-ARGLIST-MSG)
      arglist = ((?xs:#argbinding ... ?rest ...)) :
         if empty?(rest) : [map(key, xs), map(value, xs)]
         else : CSE(rest, "Expected an argument declaration here.")
      
      fnheader = (?args:#arglist -> ?a2:#type!) :
         val [xs, a1] = args
         [xs, a1, a2]
      fnheader = (?args:#arglist) :
         val [xs, a1] = args
         [xs, a1, `($none)]

      fnheader! = (?h:#fnheader) : h
      fnheader! != () : CSE(form, "Expected argument list here.")

   ;Prefix Operators
   defrule not :
      prefix-op = (not ?x:#exp!) : qquote($do core/complement ~ x)

   defrule fn :
      fn-tag = (fn) : `$fn
      fn-tag = (fn*) : `$fn*      
      prefix-op = (?tag:#fn-tag ?header:#fnheader! #:! ?body:#exp!) :
         val [xs, a1, a2] = header
         qquote(~ tag ~ xs ~ a1 ~ a2 ~ body)
      prefix-op != (#fn-tag) :
         CSE(form, "Incorrect syntax for anonymous function.")

   defrule defn :
      defn-tag = (defn) : `$defn
      defn-tag = (defn*) : `$defn*
      defn-tag = (defmethod) : `$defmethod
      defn-tag = (defmethod*) : `$defmethod*
      
      prefix-op = (?tag:#defn-tag ?name:#type! ?header:#fnheader! #:! ?body:#exp!) :
         val [xs, a1, a2] = header
         qquote(~ tag ~ name ~ xs ~ a1 ~ a2 ~ body)
      prefix-op != (#defn-tag) :
         CSE(form, "Incorrect syntax for function definition.")

   defrule defmulti :
      prefix-op = (defmulti ?name:#type! ?header:#fnheader!) :
         val [xs, a1, a2] = header
         qquote($defmulti ~ name ~ a1 ~ a2)
      prefix-op != (defmulti) :
         CSE(form, "Incorrect syntax for multi definition.")

   defrule multifn :
      multifn-tag = (multifn) : `$fn
      multifn-tag = (multifn*) : `$fn*      
      prefix-op = (?tag:#multifn-tag #:! ((?headers:#fnheader : ?bodies:#exp!) @... ?rest ...)) :
         if not empty?(rest) :
            CSE(rest, "Expected multi function clause here.")
            
         val template =
            `($multi
               funcs{
                  ($fn xs a1 a2 body)
               })
         fill-template(template, [
            `$fn => tag
            `funcs => nested $            
               for ([xs, a1, a2] in headers, body in bodies) map :
                  [`a1 => a1
                   `a2 => a2
                   `xs => xs
                   `body => body]])
      prefix-op != (#multifn-tag) :
         CSE(form, "Incorrect syntax for multi function definition.")

   defrule var :
      prefix-op = (var ?name:#binder : ?type:#type! = ?value:#exp!) :
         qquote($defvar ~ name ~ type ~ value)
      prefix-op = (var ?name:#binder : ?type:#type!) :
         qquote($defvar ~ name ~ type ($none))
      prefix-op = (var ?name:#binder = ?value:#exp!) :
         qquote($defvar ~ name ($none) ~ value)
      prefix-op = (var ?name:#binder) :
         qquote($defvar ~ name ($none) ($none))
      prefix-op != (var) :
         CSE(form, "Incorrect syntax for var definition.")

   defrule val :
      prefix-op = (val ?name:#binder : ?type:#type! = ?value:#exp!) :
         qquote($def ~ name ~ type ~ value)
      prefix-op = (val ?name:#binder : #type! ?rest ...) :
         CSE(rest, "No initializing value given to val %~" % [name])
      prefix-op = (val ?name:#binder = ?value:#exp!) :
         qquote($def ~ name ($none) ~ value)
      prefix-op != (val ?name:#binder) :
         CSE(form, "No initializing value given to val %~" % [name])
      prefix-op != (val) :
         CSE(form, "Incorrect syntax for val definition.")

   defrule set-var :
      suffix-op = (= ?y:#exp!) :
         {qquote($set ~ _ ~ y)}

   defrule public :
      prefix-op = (public : ?e:#exp!) :
         qquote($public ~ e)
      prefix-op = (public ?e:#exp!) :
         qquote($public ~ e)
      prefix-op != (public) :
         CSE(form, "Invalid syntax for public declaration.")

   defrule protected :
      prefix-op = (protected : ?e:#exp!) :
         qquote($protected ~ e)
      prefix-op = (protected ?e:#exp!) :
         qquote($protected ~ e)
      prefix-op != (protected) :
         CSE(form, "Invalid syntax for protected declaration.")

   defrule new :
      prefix-op = (new ?t:#type! : (?ms:#exps!)) :
         qquote($new ~ t ~@ ms)
      prefix-op != (new #type! :) :
         CSE(form, "Expected a list of methods following new keyword.")
      prefix-op = (new ?t:#type!) :
         qquote($new ~ t)
      prefix-op != (new) :
         CSE(form, "Invalid syntax for new declaration.")

   defrule deftype :
      prefix-op = (deftype ?t:#type! <: ?p:#type!) :
         qquote($deftype ~ t ~ p)
      prefix-op = (deftype ?t:#type! : (?cs:#defchild ...)) :      
         qquote($deftype ~ t ($none) ~@ cs)
      prefix-op = (deftype ?t:#type!) :
         qquote($deftype ~ t ($none))
      prefix-op != (deftype) :
         CSE(form, "Invalid syntax for deftype declaration.")
      defchild = (?a:#type! <: ?b:#type!) :
         qquote($defchild ~ a ~ b)
      defchild != () :
         CSE(form, "Invalid syntax for child type declaration.")

   defrule tuple :
      prefix-op = ([?es:#exps!]) :
         qquote($tuple ~@ es)
      
   defrule match :
      prefix-op = (match(?xs:#exps!) :
                      (?arglists:#arglist : ?bodies:#exp!) @...
                      ?rest ...) :
         if not empty?(rest) :
            CSE(rest, "Expected match clause here.")
            
         val template =
            `($match xs
                 branch{
                    ($branch args types body)
                 })
         fill-template(template, [
            `xs => xs
            `branch => nested $
               for ([xs, ts] in arglists, b in bodies) map :
                  [`types => ts
                   `args => xs
                   `body => b]])
      prefix-op != (match) :
         CSE(form, BAD-MATCH-MSG)

   defrule if :
      prefix-op = (?e:#if-exp) : e
      if-exp = (if ?pred:#exp! #:! ?conseq:#exp! else : ?alt:#exp!) :
         val template = `(
            match(pred as? core/True|core/False) :
               (x:core/True) : conseq
               (x:core/False) : alt)
         expande $ fill-template(template, [
            `x => gensym(`x)
            `pred => pred
            `conseq => conseq
            `alt => alt])
      if-exp = (if ?pred:#exp! : ?conseq:#exp! else ?alt:#if-exp) :
         expande $ qquote(if ~ pred : ~ conseq else : ~ alt)
      if-exp = (if ?pred:#exp! : ?conseq:#exp!) :
         expande $ qquote(if ~ pred : ~ conseq else : false)
      if-exp != (if) :
         CSE(form, "Incorrect syntax for if expression.")

   defrule let :
      prefix-op = (let : ?body:#exp!) :
         expande $ qquote(($let ~ body))
      prefix-op != (let) :
         CSE(form, "Invalid syntax for let expression.")

   defrule where :
      suffix-op = (where : ?defs:#exp!) :
         fn (x) :
            expande $ qquote(let : (~ defs ~ x))
      suffix-op != (where) :
         CSE(form, "Invalid syntax for where expression.")

   defrule for :
      prefix-op != (for _ in #exp! :) :
         CSE(form, BAD-FOR-MSG)
      prefix-op = (for ?x in ?y:#exp! ?f:#exp! #:! ?body:#exp!) :
         expande $ qquote(for (~ x in ~ y) ~ f : ~ body)
      prefix-op = (for ((?xs in ?ys:#exp!) @... ?rest ...) ?f:#exp! #:! ?body:#exp!) :
         if not empty?(rest) :
            CSE(rest, "Expected a binding form here for for expression.")
         expande $ qquote(~ f((fn ~ xs : ~ body) ~@ ys))
      prefix-op != (for) :
         CSE(form, "Invalid syntax for for expression.")

   defrule while :
      prefix-op = (while ?pred:#exp! #:! ?body:#exp!) :
         val template = `(
            let :
               defn* loop () :
                  if (pred as? core/True|core/False) :
                     body
                     loop()
               loop())
         expande $ fill-template(template, [
            `loop => gensym(`loop)
            `pred => pred
            `body => body])
      prefix-op != (while) :
         CSE(form, "Invalid syntax for while expression.")

   defrule when :
      suffix-op = (when ?pred:#exp! else ?y:#exp!) :
         fn (x) :
            expande $ qquote(if ~ pred : ~ x else : ~ y)
      suffix-op = (when ?pred:#exp!) :
         fn (x) :
            expande $ qquote(if ~ pred : ~ x)

   defrule to :
      suffix-op = (to ?end:#exp! by ?step:#exp!) :
         fn (start) :
            expande $ qquote(core/Range(~ start, ~ end, ~ step, false))
      suffix-op = (to ?end:#exp!) :
         fn (start) :
            expande $ qquote(core/Range(~ start, ~ end, 1, false))

   defrule through :
      suffix-op = (through ?end:#exp! by ?step:#exp!) :
         fn (start) :
            expande $ qquote(core/Range(~ start, ~ end, ~ step, true))
      suffix-op = (through ?end:#exp!) :
         fn (start) :
            expande $ qquote(core/Range(~ start, ~ end, 1, true))

   defrule chain :
      suffix-op = ($ ?v:#exp!) :
         fn (f) :
            qquote($do ~ f ~ v)

   defrule afn :
      prefix-op = ({?body ...}) :
         val args = Vector<Symbol>()
         val types = Vector<?>()
         defn new-arg (t) :
            val a = gensym(`arg)
            add(args, a)
            add(types, t)
            a
            
         defn replace (xs:List) :
            match-syntax(xs) :
               (((@afn | @do-afn | @quote | $quote) _ ...) ?rest ...) :
                  cons(head(form), replace(rest))
               ((?h ...) ?rest ...) :
                  cons(replace(h), replace(rest))
               (~ _ : ?t:#type! ?rest ...) :
                  cons(new-arg(t), replace(rest))
               (~ _ ?rest ...) :
                  cons(new-arg(false), replace(rest))
               (?h ?rest ...) :
                  cons(h, replace(rest))
               () :
                  List()

         val body* = continue-expand(replace(List(body)))
         if empty?(args) :
            val template = `(
               multifn :
                  () : body
                  (x:?) : body)
            expande $ fill-template(template, [
               `body => body*
               `x => gensym(`x)])
         else :
            val template = `(fn args : (body))
            expande $ fill-template(template, [
               `body => body*
               `args => for (x in args, t in types) seq-append :
                  if t is False : List(x)
                  else : qquote(~ x : ~ t)])

   defrule is :
      suffix-op = (is ?t:#type!) :
         fn (x) :
            expande $ qquote(
               match(~ x) :
                  (x: ~ t) : true
                  (x) : false)

   defrule is-not :
      suffix-op = (is-not ?t:#type!) :
         fn (x) :
            expande $ qquote(
               match(~ x) :
                  (x: ~ t) : false
                  (x) : true)

   defrule label :
      prefix-op = (label<?t:#type$> ?break:#id! #:! ?body:#exp!) :
         expande $ qquote(core/LabeledScope<~ t>((fn (~ break) -> ~ t : ~ body)))
      prefix-op != (label<#type$> :) :
         CSE(form, "Missing name of break function in label expression.")
      prefix-op = (label ?break:#id! : ?body:#exp!) :
         expande $ qquote(label<?> ~ break : ~ body)
      prefix-op != (label :) :
         CSE(form, "Missing name of break function in label expression.")
      prefix-op != (label) :
         CSE(form, "Invalid syntax for label expression.")

   defrule generate :
      prefix-op = (generate<?t:#type$> #:! ?body:#exp!) :
         expande $ qquote(core/Generator<~ t>((fn (yield, break) : ~ body)))
      prefix-op = (generate #:! ?body:#exp!) :
         expande $ qquote(generate<?> : ~ body)
      prefix-op != (generate) :
         CSE(form, "Invalid syntax for generate expression.")

   defrule keyvalue :
      suffix-op = (=> ?v:#exp!) :
         fn (k) :
            expande $ qquote(core/KeyValue(~ k ~ v))

   defn gen-switch-exp (pred, clauses:List, alt) -> ? :
      if empty?(clauses) :
         alt
      else :
         val [v, body] = head(clauses)
         val rest = gen-switch-exp(pred, tail(clauses), alt)
         qquote(if ~ pred(~ v) : ~ body else : ~ rest)
      
   defrule switch :
      switch-clause = ((! else) ?v:#exp : ?body:#exp!) :
         [v, body]
         
      prefix-op = (switch ?pred:#exp! :
                      ?cs:#switch-clause ...
                      else : ?alt:#exp!
                      ?rest ...) :
         if not empty?(rest) :
            CSE(rest, "Else must be last clause in switch expression.")
         expande $ gen-switch-exp(pred, cs, alt)
                     
      prefix-op = (switch ?pred:#exp! :
                      ?cs:#switch-clause ...
                      ?rest ...) :                      
         if not empty?(rest) :
            CSE(rest, "Expected switch expression clause here.")
         val alt = qquote(core/fatal("No appropriate switch clause."))
         expande $ gen-switch-exp(pred, cs, alt)
                     
      prefix-op != (switch) :
         CSE(form, "Invalid syntax for switch expression.")
         
   ;TODO: Multiple variables
   defrule let-var :
      prefix-op = (let-var ?x:#id! = ?e:#exp! #:! ?body:#exp!) :
         val template = `(
            let :
               val oldv = x
               val v = e
               core/dynamic-wind(
                  fn () : x = v
                  fn () : body
                  fn (f) : x = oldv))
         expande $ fill-template(template, [
            `x => x
            `e => e
            `v => gensym(`v)
            `f => gensym(`f)
            `oldv => gensym(`oldv)
            `body => body])
      prefix-op != (let-var) :
         CSE(form, "Invalid syntax for let-var expression.")            

   defrule try :
      prefix-op = (try #:! ?body:#exp!
                   (catch ?carglists:_ #:! ?cbodies:#exp!) @...
                   finally #:! ?fbody:#exp!) :                   
         val template = `(
            core/with-finally(
               fn () :
                  core/with-exception-handler(
                     fn () :
                        body
                     fn (e) :
                        catch{
                           core/throw(e)
                        }{
                           match(e) :
                              clause{carglist : cbody}
                              (e) : core/throw(e)
                        })
               fn (f) :
                  fbody))
         expande $ fill-template(template, [
            `body => body
            `e => gensym(`e)
            `f => gensym(`f)
            `catch => choice(empty?(cbodies))
            `clause => collect $ [
               `carglist => carglists
               `cbody => cbodies]
            `fbody => fbody])
                        
      prefix-op = (try #:! ?body:#exp!
                   (catch ?carglists:_ #:! ?cbodies:#exp!) @...) :
         if empty?(cbodies) :
            CSE(form, "Try expression without any catch or finally clauses.")
         val template = `(
            core/with-exception-handler(
               fn () :
                  body
               fn (e) :
                  match(e) :
                     clause{carglist : cbody}
                     (e) : core/throw(e)))
         expande $ fill-template(template, [
            `body => body
            `e => gensym(`e)
            `clause => collect $ [
               `carglist => carglists
               `cbody => cbodies]])
                           
      prefix-op != (try) :
         CSE(form, "Invalid syntax for try expression.")

   defn compile-attempt (conseq, alt) :
      val template = `(
         core/with-attempt(
            fn* () : conseq,
            fn* () : alt))
      expande $ fill-template(template, [
         `conseq => conseq,
         `alt => alt])
         
   defrule attempt :
      prefix-op = (?e:#attempt) : e
      attempt = (attempt #:! ?conseq:#exp! else : ?alt:#exp!) :
         compile-attempt(conseq, alt)
      attempt = (attempt #:! ?conseq:#exp! else ?alt:#attempt) :
         compile-attempt(conseq, alt)
      attempt = (attempt #:! ?conseq:#exp!) :
         compile-attempt(conseq, false)

;   defrule #include :
;      prefix-op = (~ #include(?filename)) :
;         if unwrap-token(filename) is-not String :
;            CSE(filename, "String expected here.")
;         val lexed = lex-file(unwrap-token(filename))
;         match-syntax(list(lexed)) :
;            (?e:#exp) : e
;      prefix-op = (~ #include<?filename>) :
;         if unwrap-token(filename) is-not String :
;            CSE(filename, "String expected here.")
;         val lexed = lex-file(system-file!(unwrap-token(filename)))
;         match-syntax(list(lexed)) :
;            (?e:#exp) : e
;      prefix-op != (~ #include) :
;         CSE(form, BAD-INCLUDE-MSG)

   defrule defpackage :
      prefix-clause = (prefix => ?p:#id!) :
         qquote($prefix ~ p)
      prefix-clause = (prefix(?xs:#id! ...) => ?p:#id!) :
         qquote($prefix-of ~ xs ~ p)

      import-clause = (import ?name:#id! with : (?ps:#prefix-clause ...)) :
         qquote($import ~ name ~@ ps)
      import-clause = (import ?name:#id!) :
         qquote($import ~ name)
      
      prefix-op = (defpackage ?name:#id! : (?imports:#import-clause ... ?rest ...)) :
         if not empty?(rest) :
            CSE(rest, "Import clause expected here.")
         qquote($package ~ name ~@ imports)
      prefix-op = (defpackage ?name:#id!) :
         qquote($package ~ name)
      prefix-op != (defpackage) :
         CSE(form, "Invalid syntax for defpackage.")

   defn parse-struct-field (name, type, ops, vs) :
      val options = map(KeyValue, ops, vs)
      val setter = unwrap-token(lookup?(options, `setter))
      if setter is-not Symbol|False :
         CSE(name, "Setter name is expected to be either false or a symbol.")
      val as-method? = unwrap-token(lookup?(options, `as-method))
      if as-method? is-not True|False :
         CSE(name, "As-method option is expected to be either true or false.")
      StructField(name, type, as-method?, setter, gensym(name))

   defn gen-struct-exp (sname, targs, parent,
                        fields:List<StructField>,
                        options:List<KeyValue<Symbol, ?>>) :
      val template = `((
         class-def{
            deftype Name<Targs>
         }{
            deftype Name<Targs> <: Parent
         }      
         getter-multis{
            defmulti field<Cargs> (x: Name<Cargs>) -> type
         }
         setter-multis{
            defmulti set-field<Cargs> (x: Name<Cargs>, field:type) -> core/False
         }
         defn Constructor<Targs> (args{field : type}) :
            boxes{
               var @field : type = field
            }
            new Name<Targs> :
               getters{
                  defmethod field (this) : value
               }
               setters{
                  defmethod set-field (this, field:type) :
                     @field = field
               }))
      expande $ fill-template(template, [
         `class-def => choice(unwrap-token(parent) is False)
         `Name => sname
         `Constructor => lookup?(options, `constructor, sname)
         `Targs => splice(targs)
         `Cargs => splice $ for v in targs map :
                      List(`@cap, v)
         `Parent => parent
         `getter-multis => nested $ to-list $ generate :
            for f in fields do :
               if not as-method?(f) :
                  yield $ [`field => name(f)
                           `type => type(f)]
         `setter-multis => nested $ to-list $ generate :
            for f in fields do :
               if (not as-method?(f)) and setter(f) != false :
                  yield $ [`set-field => setter(f)
                           `field => name(f)
                           `type => type(f)]
         `args => nested $
            for f in fields map :
               [`field => name(f)
                `type => type(f)]
         `boxes => nested $ to-list $ generate :
            for f in fields do :
               if setter(f) != false :
                  yield $ [`@field => box(f)
                           `type => type(f)
                           `field => name(f)]
         `getters => nested $
            for f in fields map :
               [`field => name(f)
                `value => if setter(f) is False : name(f)
                          else : box(f)]
         `setters => nested $ to-list $ generate :
            for f in fields do :
               if setter(f) != false :
                  yield $ [`set-field => setter(f)
                           `@field => box(f)
                           `field => name(f)
                           `type => type(f)]])       

   defrule defstruct :
      field-option = (?x: (as-method | setter)) :
         unwrap-token(head(x))

      struct-name = (?name:#id!<?targs:#id! ...>) :
         [name, targs]
      struct-name = (?name:#id!) :
         [name, List()]

      struct-parent = (<: ?parent:#type!) : parent
      struct-parent = () : false
         
      struct-field = (?name:#id! : ?type:#type! with :
                         (?ops:#field-option => ?vs) @...
                         ?rest ...) :                         
         if not empty?(rest) :
            CSE(rest, "Invalid struct field option.")
         parse-struct-field(name, type, ops, vs)
                        
      struct-field = (?name:#id! with :
                         (?ops:#field-option => ?vs) @...
                         ?rest ...) :                         
         if not empty?(rest) :
            CSE(rest, "Invalid struct field option.")
         parse-struct-field(name, `?, ops, vs)                        
      struct-field = (?name:#id! : ?type:#type!) :
         parse-struct-field(name, type, List(), List())
      struct-field = (?name:#id!) :
         parse-struct-field(name, `?, List(), List())

      struct-option = (constructor => ?name:#id!) :
         `constructor => name
      struct-options = (with :
                           ?ops:#struct-option ...
                           ?rest-ops ...) :
         if not empty?(rest-ops) :
            CSE(rest-ops, "Expected struct option declaration here.")
         ops
      struct-options = () :
         List()

      prefix-op = (defstruct ?struct-name:#struct-name ?parent:#struct-parent :
                      ?fields:#struct-field ...
                      ?rest ...
                   ?ops:#struct-options) :                      
         if not empty?(rest) :
            CSE(rest, "Expected struct field declaration here.")
         val [name, targs] = struct-name
         gen-struct-exp(name, targs, parent, fields, ops)                     
      prefix-op = (defstruct ?struct-name:#struct-name ?parent:#struct-parent ?ops:#struct-options) :
         val [name, targs] = struct-name
         gen-struct-exp(name, targs, parent, List(), ops)                     
      prefix-op != (defstruct) :
         CSE(form, "Invalid syntax for defstruct.")

   defrule #define :
      prefix-op = (~ #define(?flag:#id$)) :
         add-flag(unwrap-token(flag))
         `($begin)
      prefix-op != (~ #define) :
         CSE(form, "Incorrect syntax for #define.")

   defrule :
      list-exp = ((?xs ...)) : xs
      list-exp != () : CSE(form, "Expected a list here.")
      
   defrule #if-defined :      
      prefix-op = (~ #if-defined(?flag:#id$) #:! ?conseq:#list-exp ~ #else #:! ?alt:#list-exp) :
         if flag-defined?(unwrap-token(flag)) : expande(List(conseq))
         else : expande(List(alt))
      prefix-op = (~ #if-defined(?flag:#id$) #:! ?conseq:#list-exp) :
         if flag-defined?(unwrap-token(flag)) : expande(List(conseq))
         else : `($begin)
      prefix-op != (~ #if-defined) :
         CSE(form, "Incorrect syntax for #if-defined.")

   defrule #if-not-defined :
      prefix-op = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list-exp ~ #else #:! ?alt:#list-exp) :
         if flag-defined?(unwrap-token(flag)) : expande(List(alt))
         else : expande(List(conseq))
      prefix-op = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list-exp) :
         if flag-defined?(unwrap-token(flag)) : `($begin)
         else : expande(List(conseq))
      prefix-op != (~ #if-not-defined) :
         CSE(form, "Incorrect syntax for #if-not-defined.")

   defrule qquote :
      prefix-op = (qquote(?sexp ...)) :
         defn fill (sexp:List) :
            match-syntax(sexp) :
               (~ ~ ?x ?rest ...) :
                  qquote(core/cons(~ x, ~ (fill(rest))))
               (~@ ?x ?rest ...) :
                  qquote(core/append(~ x, ~ (fill(rest))))
               ((?fs ...) ?rest ...) :
                  qquote(core/cons(~ (fill(fs)), ~ (fill(rest))))
               (?x ?rest ...) :
                  qquote(core/cons((@quote ~ x), ~ (fill(rest))))
               () :
                  qquote(core/List())
         expande $ fill(sexp)
      prefix-op != (qquote) :
         CSE(form, "Incorrect syntax for qquote")

   ;Name of vector holding rule groups
   val #RULE-GROUPS = gensym(`rule-groups)
   defn gen-rule-body (p:List, body) :
      val template = `(
         fn (bindings) :
            val form = core/lookup(bindings, `form)
            bind{val x = core/lookup(bindings, `x)}
            body)
      expande $ fill-template(template, [
         `bindings => gensym(`bindings)
         `bind => collect $ [
            `x => pattern-bindings(p)]
         `body => body])

   defrule defsyntax :      
      prefix-op = (defsyntax ?name:#id! #:! (?body ...)) :
         val template = `(
            let :
               val rulegroups = collections/Vector<stz/parser/MatchGroup>()
               body
               stz/parser/new-syntax-package(`name, rulegroups))
         val body* = with-overlay(defsyntax/body) :
            match-syntax(List(body)) :
               (?e:#exp) : e         
         expande $ fill-template(template, [
            `rulegroups => #RULE-GROUPS
            `body => body*
            `name => name])
      prefix-op != (defsyntax) :
         CSE(form, "Invalid syntax for defsyntax expression.")

   defsyntax defsyntax/body :
      defrule defrule :
         syntax/op = (=) : `stz/parser/MatchAction
         syntax/op = (!=) : `stz/parser/MatchFail
         
         syntax/p = (?op:#syntax/op (?p ...) when ?pred:#exp! #:! ?body:#exp!) :
            val template = `(
               action(body,
               stz/parser/MatchGuard(pred,
               stz/parser/MPattern(`pattern))))
            fill-template(template, [
               `action => op
               `body => gen-rule-body(p, body)
               `pred => gen-rule-body(p, pred)
               `pattern => p])
         syntax/p = (?op:#syntax/op (?p ...) #:! ?body:#exp!) :
            val template = `(
               action(body,
               stz/parser/MPattern(`pattern)))
            fill-template(template, [
               `action => op
               `body => gen-rule-body(p, body)
               `pattern => p])
         
         syntax/rule = (?name:#id! ?p:#syntax/p) :
            val template = `(stz/parser/MatchRule(`name, pattern))
            fill-template(template, [
               `name => name
               `pattern => p])
         syntax/rule != (_) :
            CSE(form, "Invalid syntax for defrule clause.")
         
         defrule-name = (:) : false
         defrule-name = (?name:#id! #:!) : name
         prefix-op = (defrule ?name:#defrule-name (?rs:#syntax/rule ...)) :
            val template = `(collections/add(rulegroups, stz/parser/MatchGroup(`name, [rules])))
            expande $ fill-template(template, [
               `rulegroups => #RULE-GROUPS
               `name => name
               `rules => splice(rs)])
         prefix-op != (defrule) :
            CSE(form, "Invalid syntax for defrule expression.")

   defrule match-syntax :
      prefix-op = (match-syntax(?arg:#exp$) #:! (
                      ((?ps ...) : ?es:#exp!) @...
                      ?rest ...)) :                      
         if not empty?(rest) :
            CSE(rest, "Expected a match-syntax clause here.")
         val bodies = map(gen-rule-body, ps, es)
         val template = `(stz/parser/pattern-match(arg, `PAT, `patterns, [actions]))
         expande $ fill-template(template, [
            `PAT => gensym(`P)
            `arg => arg
            `patterns => ps
            `actions => splice(bodies)])                        
      prefix-op != (match-syntax) :
         CSE(form, "Invalid syntax for match-syntax expression.")

   defrule use-syntax :
      use-syntax-tag = (use-syntax) : `stz/parser/set-syntax-package
      use-syntax-tag = (use-overlay) : `stz/parser/set-syntax-overlay      
      prefix-op = (?tag:#use-syntax-tag(?names ...)) :
         val template = `(tag(qquote(names)))
         expande $ fill-template(template, [
            `tag => tag
            `names => splice(names)])
      prefix-op != (#use-syntax-tag) :
         CSE(form, "Invalid syntax for use-syntax/use-overlay")

   defrule with-syntax :
      with-syntax-tag = (with-syntax) : `stz/parser/with-syntax-package
      with-syntax-tag = (with-overlay) : `stz/parser/with-syntax-overlay
      prefix-op = (?tag:#with-syntax-tag(?names ...) #:! ?body:#exp!) :
         val template = `(tag(qquote(names), fn () : body))
         expande $ fill-template(template, [
            `tag => tag
            `names => splice(names)
            `body => body])
      prefix-op != (#with-syntax-tag) :
         CSE(form, "Invalid syntax for with-syntax/with-overlay.")

   defrule #use-syntax :
      use-syntax-func = (~ #use-syntax) : with-syntax-package
      use-syntax-func = (~ #use-overlay) : with-syntax-overlay      
      
      prefix-op = (?f:#use-syntax-func(?names:#id! ...) ?rest ...) :
         f{unwrap-all(names), _} $ fn () :
            match-syntax(List(rest)) :
               (?e:#exp) : e
      prefix-op != (#use-syntax-func) :
         CSE(form, "Invalid syntax for #use-syntax/#use-overlay.")

   defrule #with-syntax :
      with-syntax-func = (~ #with-syntax) : with-syntax-package
      with-syntax-func = (~ #with-overlay) : with-syntax-overlay      
      prefix-op = (?f:#with-syntax-func(?names:#id! ...) #:! ?body) :
         f{unwrap-all(names), _} $ fn () :
            match-syntax(List(body)) :
               (?e:#exp) : e
      prefix-op != (#with-syntax-func) :
         CSE(form, "Invalid syntax for #with-syntax/#with-overlay.")

   ;Types
   defrule types :
      ;Errors
      ls-t0! = (?t:#ls-t0) : t
      ls-t0! != () : CSE(form, "Expected a type here.")
      
      ls-t0$ = (?x:#ls-t0 ?rest ...) when empty?(rest) : x
      ls-t0$ != () : CSE(form, "Expected a type here.")
      
      ls-ts! = (?y:#ls-t0 ... ?rest ...) :
         if empty?(rest) : y
         else : CSE(rest, "Expected a type here.")
         
      ;Precedence level 0
      ls-t0 = ((((! ~ ...) ?xs:#ls-t0) @... ~ ...) -> ?b:#ls-t0!) :
         val a = but-last(xs)
         val r = last(xs)
         qquote($ls-fn ~ a ~ r ~ b)
      ls-t0 = (?a:#ls-t1 -> ?b:#ls-t0!) :
         qquote($ls-fn (~ a) ($none) ~ b)
      ls-t0 = ((?a:#ls-ts!) -> ?b:#ls-t0!) :
         qquote($ls-fn ~ a ($none) ~ b)
      ls-t0 = (?x:#ls-t1) : x
      
      ;Prefix Operators
      ls-t1 = (?x) when tagged?(x) : x
      ls-t1 = (ptr<?x:#ls-t0$>) : qquote($ls-ptr ~ x)
      ls-t1 = (ref<?x:#type>) : qquote($ls-ref ~ x)

      ;Primitive types
      ls-t1 = (byte) : `($ls-byte)
      ls-t1 = (int) : `($ls-int)
      ls-t1 = (long) : `($ls-long)
      ls-t1 = (float) : `($ls-float)
      ls-t1 = (double) : `($ls-double)
      ls-t1 = (?) : `($ls-?)
      ls-t1 = (?x:#id<?ts:#type ...>) : qquote($ls-of ~ x ~@ ts)
      
      ;List Operators
      ls-t1 = ((?x:#ls-t0)) : x
      
      ;Atom Forms
      ls-t1 = (?x) when atom?(x) :
         val x* = unwrap-token(x)
         if identifier?(x*) : x*
         else : CSE(form, "%~ is not a valid type." % [x])

   ;LoStanza Top level
   defrule lostanza-top :
      prefix-op = (extern defn ?name:#id! ((?xs:#id! : ?ts:#ls-t0) @...) -> ?rt:#ls-t0 : ?c:#ls-comm) :
         qquote($ls-extern-fn ~ name ~ xs ~ ts ~ rt ~ c)
      prefix-op = (extern ?name:#id! : ?t:#ls-t0!) :
         qquote($ls-extern ~ name ~ t)

      ;Deftype
      deftype-name = (?name:#id!<?targs:#id! ...>) :
         qquote($ls-of ~ name ~@ targs)
      deftype-name = (?name:#id!) :
         name
      deftype-parent = (<: ?t:#type) :
         t
      deftype-parent = () :
         `($none)

      ;Deftype
      prefix-op = (lostanza deftype ?name:#deftype-name ?p:#deftype-parent :
                      (?fields:#id! : ?types:#ls-t0! (! ~ ...)) @...
                      ?rfield:#id! : ?rtype:#ls-t0! ~ ...) :
         qquote($ls-deftype ~ name ~ p
                   ~ fields ~ rfield
                   ~ types ~ rtype)
      prefix-op = (lostanza deftype ?name:#deftype-name ?p:#deftype-parent :
                      (?fields:#id! : ?types:#ls-t0! (! ~ ...)) @...) :
         qquote($ls-deftype ~ name ~ p
                   ~ fields ($none)
                   ~ types ($none))
      prefix-op = (lostanza deftype ?name:#deftype-name ?p:#deftype-parent) :
         qquote($ls-deftype ~ name ~ p () ($none) () ($none))

      ;Defn
      prefix-op = (lostanza defn ?name:#id! ((?xs:#id! : ?ts:#ls-t0) @...) -> ?rt:#ls-t0 : ?c:#ls-comm) :
         qquote($ls-defn ~ name ~ xs ~ ts ~ rt ~ c)
      prefix-op = (lostanza defn ?name:#id!<?targs:#type ...> ((?xs:#id! : ?ts:#ls-t0) @...) -> ?rt:#ls-t0 : ?c:#ls-comm) :
         qquote($ls-defn ($ls-of ~ name ~@ targs) ~ xs ~ ts ~ rt ~ c)
      prefix-op = (lostanza defn* ?name:#id! ((?xs:#id! : ?ts:#ls-t0) @...) -> ?rt:#ls-t0 : ?c:#ls-comm) :
         qquote($ls-defn* ~ name ~ xs ~ ts ~ rt ~ c)
      prefix-op = (lostanza defn* ?name:#id!<?targs:#type ...> ((?xs:#id! : ?ts:#ls-t0) @...) -> ?rt:#ls-t0 : ?c:#ls-comm) :
         qquote($ls-defn* ($ls-of ~ name ~@ targs) ~ xs ~ ts ~ rt ~ c)
      prefix-op != (lostanza defn) :
         CSE(form, "Invalid lostanza defn form.")

      ;Defmethod
      prefix-op = (lostanza defmethod ?multi:#id! ((?xs:#id! : ?ts:#ls-t0) @...) -> ?rt:#ls-t0 : ?c:#ls-comm) :
         qquote($ls-defmethod ~ multi ~ xs ~ ts ~ rt ~ c)
      prefix-op = (lostanza defmethod ?multi:#id!<?targs:#type ...> ((?xs:#id! : ?ts:#ls-t0) @...) -> ?rt:#ls-t0 : ?c:#ls-comm) :
         qquote($ls-defmethod ($ls-of ~ multi ~@ targs) ~ xs ~ ts ~ rt ~ c)
      prefix-op = (lostanza defmethod* ?multi:#id! ((?xs:#id! : ?ts:#ls-t0) @...) -> ?rt:#ls-t0 : ?c:#ls-comm) :
         qquote($ls-defmethod* ~ multi ~ xs ~ ts ~ rt ~ c)
      prefix-op = (lostanza defmethod* ?multi:#id!<?targs:#type ...> ((?xs:#id! : ?ts:#ls-t0) @...) -> ?rt:#ls-t0 : ?c:#ls-comm) :
         qquote($ls-defmethod* ($ls-of ~ multi ~@ targs) ~ xs ~ ts ~ rt ~ c)
      prefix-op != (lostanza defmethod) :
         CSE(form, "Invalid lostanza defmethod form.")

      ;Vals and Vars
      prefix-op = (lostanza var ?name:#id! : ?type:#ls-t0! = ?e:#ls-e0!) :
         qquote($ls-defvar ~ name ~ type ~ e)
      prefix-op = (lostanza var ?name:#id! : ?type:#ls-t0!) :
         qquote($ls-defvar ~ name ~ type ($none))
      prefix-op = (lostanza val ?name:#id! : ?type:#ls-t0! = ?e:#ls-e0!) :
         qquote($ls-def ~ name ~ type ~ e)
      prefix-op = (lostanza val ?name:#id! = ?e:#ls-e0!) :
         qquote($ls-def ~ name ($none) ~ e)

      ;Commands
      prefix-op = (lostanza : ?c:#ls-comm) :
         qquote($ls-let ~ c)

   ;LoStanza operators
   defrule ls-operators :   
      ls-op2 = (<) : `lt
      ls-op2 = (<=) : `le
      ls-op2 = (>) : `gt
      ls-op2 = (>=) : `ge
      ls-op2 = (!=) : `ne
      ls-op2 = (==) : `eq
      
      ls-op3 = (+) : `add
      ls-op3 = (-) : `sub
      
      ls-op4 = (*) : `mul
      ls-op4 = (/) : `div
      ls-op4 = (%) : `mod
      ls-op4 = (&) : `and
      ls-op4 = (~ |) : `or
      ls-op4 = (^) : `xor
      ls-op4 = (<<) : `shl
      ls-op4 = (>>) : `shr
      ls-op4 = (>>>) : `ashr

   ;LoStanza expressions   
   defrule ls-expressions :
      ;Errors
      ls-e0! = (?x:#ls-e0) : x
      ls-e0! != () : CSE(form, "Expected an expression here.")
      
      ls-e0$ = (?x:#ls-e0 ?rest ...) when empty?(rest) : x
      ls-e0$ != () : CSE(form, "Expected an expression here.")
      
      ls-es! = (?y:#ls-e0 ... ?rest ...) :
         if empty?(rest) : y
         else : CSE(rest, "Expected an expression here.")
         
      ;Precedence Levels
      ls-e0 = (?x:#ls-e1 ?ops:#ls-eop1 ...) : apply-suffix-ops(x, ops)
      ls-e1 = (?x:#ls-e2 ?ops:#ls-eop2 ...) : apply-suffix-ops(x, ops)
      ls-e2 = (?x:#ls-e3 ?ops:#ls-eop3 ...) : apply-suffix-ops(x, ops)
      ls-e3 = (?x:#ls-e4 ?ops:#ls-eop4 ...) : apply-suffix-ops(x, ops)
      ls-e4 = (?x:#ls-term ?ops:#ls-suffix-op ...) : apply-suffix-ops(x, ops)

      ;Precedence level 0
      ls-eop1 = (and ?y:#ls-e1) : (fn (x) : qquote($ls-and ~ x ~ y))
      ls-eop1 != (and) : CSE(form, "No second operand given to and operator.")
      
      ls-eop1 = (or ?y:#ls-e1) : (fn (x) : qquote($ls-or ~ x ~ y))
      ls-eop1 != (or) : CSE(form, "No second operand given to or operator.")

      ;Precedence level 1
      ls-eop2 = (?op:#ls-op2 ?y:#ls-e2) : (fn (x) : qquote($ls-prim ~ op ~ x ~ y))
      ls-eop2 != (?op:#ls-op2) : CSE(form, "No second operand given to operator: %~" % [op])
         
      ls-eop2 = (as ?t:#ls-t0!) : (fn (x) : qquote($ls-as ~ x ~ t))
      ls-eop2 != (as) : CSE(form, "No type given to cast operator.")
      
      ;Precedence level 2
      ls-eop3 = (?op:#ls-op3 ?y:#ls-e3) : (fn (x) : qquote($ls-prim ~ op ~ x ~ y))
      ls-eop3 != (?op:#ls-op3) : CSE(form, "No second operand given to operator: %~" % [op])

      ;Precedence level 3
      ls-eop4 = (?op:#ls-op4 ?y:#ls-e4) : (fn (x) : qquote($ls-prim ~ op ~ x ~ y))
      ls-eop4 != (?op:#ls-op4) : CSE(form, "No second operand given to operator: %~" % [op])

      ;Suffix Operators
      ls-suffix-op = ((@get ?i:#ls-e0$)) : (fn (x) : qquote($ls-slot ~ x ~ i))
      ls-suffix-op = (. ?f:#id!) : (fn (x) : qquote($ls-field ~ x ~ f))
      ls-suffix-op = ((@do ?ys:#ls-es!)) : (fn (x) : qquote($ls-do ~ x ~@ ys))
      ls-suffix-op = ((@of ?ts:#type ...)(?ys:#ls-es!)) : (fn (x) : qquote($ls-do ($ls-of ~ x ~@ ts) ~@ ys))
      
      ;Prefix Operators
      ls-term = (?x) when tagged?(x) : x
      ls-term = (sizeof(?t:#ls-t0$)) : qquote($ls-sizeof ~ t)
      ls-term = (tagof(?tag:#id$)) : qquote($ls-tagof ~ tag)
      ls-term = (new ?name:#id{?xs:#ls-es!}) : qquote($ls-new ~ name ~@ xs)
      ls-term = (new ?name:#id<?ts:#type ...>{?xs:#ls-es!}) : qquote($ls-new ($ls-of ~ name ~@ ts) ~@ xs)
      ls-term != (new) : CSE(form, "Invalid new expression.")
      ls-term = (addr(?e:#ls-e0$)) : qquote($ls-addr ~ e)
      ls-term = (addr!(?e:#ls-e0$)) : qquote($ls-addr! ~ e)
      ls-term = (new-stack<?ret:#ls-t0>{?f:#ls-term(?ys:#ls-es!)}) : qquote($ls-do-in-stack ~ ret ~ f ~@ ys)      
      ls-term = (new-stack<?ret:#ls-t0>{?f:#ls-term<?ts:#type ...>(?ys:#ls-es!)}) : qquote($ls-do-in-stack ~ ret ($ls-of ~ f ~@ ts) ~@ ys)
      ls-term != (new-stack) : CSE(form, "Invalid syntax for new-stack")
      ls-term = (switch-stack<?ret:#ls-t0>{?f:#ls-e0, ?ys:#ls-es!}) : qquote($ls-do-stack ~ ret ~ f ~@ ys)
      ls-term != (switch-stack) : CSE(form, "Invalid syntax for switch-stack")
      ls-term = (?name:#id{?xs:#ls-es!}) : qquote($ls-struct ~ name ~@ xs)
      ls-term = (?name:#id<?ts:#type ...>{?xs:#ls-es!}) : qquote($ls-struct ($ls-of ~ name ~@ ts) ~@ xs)
      ls-term = (call-c ?f:#ls-term(?ys:#ls-es!)) : qquote($ls-call-c ~ f ~@ ys)
      ls-term = (call-prim ?f:#id!(?ys:#ls-es!)) : qquote($ls-prim ~ f ~@ ys)      
      ls-term = (fn(?x:#id!)) : qquote($ls-func ~ x)
      ls-term = (let : (?c:#ls-comm, ?e:#ls-e0)) : qquote($ls-letexp ~ c ~ e)
      
      ;List Forms
      ls-term = ([?x:#ls-e0$]) : qquote($ls-deref ~ x)
      ls-term = ((- ?x:#ls-e0$)) : qquote($ls-prim neg ~ x)
      ls-term = ((~ ~ ?x:#ls-e0$)) : qquote($ls-prim not ~ x)
      ls-term = ((?x:#ls-e0)) : x
      
      ;Atom Forms
      ls-term = (?x) when atom?(x) :
         val x* = unwrap-token(x)
         if identifier?(x*) : x
         else if x* is Byte|Char|Int|Long|Float|Double|String|True|False : x
         else : CSE(x, "%~ is not a valid expression." % [x])

   defrule #ls-if-defined :      
      ls-comm = (~ #if-defined(?flag:#id$) #:! ?conseq:#list-exp ~ #else #:! ?alt:#list-exp) :
         if flag-defined?(unwrap-token(flag)) : expandc(List(conseq))
         else : expandc(List(alt))
      ls-comm = (~ #if-defined(?flag:#id$) #:! ?conseq:#list-exp) :
         if flag-defined?(unwrap-token(flag)) : expandc(List(conseq))
         else : `($begin)
      ls-comm != (~ #if-defined) :
         CSE(form, "Incorrect syntax for #if-defined.")

   defrule #ls-if-not-defined :
      ls-comm = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list-exp ~ #else #:! ?alt:#list-exp) :
         if flag-defined?(unwrap-token(flag)) : expandc(List(alt))
         else : expandc(List(conseq))
      ls-comm = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list-exp) :
         if flag-defined?(unwrap-token(flag)) : `($begin)
         else : expandc(List(conseq))
      ls-comm != (~ #if-not-defined) :
         CSE(form, "Incorrect syntax for #if-not-defined.")         
      
   ;LoStanza commands
   defrule ls-commands :
      ls-comm = (?x) when tagged?(x) : x
      ls-comm = (val ?x:#id! : ?t:#ls-t0 = ?e:#ls-e0!) : qquote($ls-def ~ x ~ t ~ e)
      ls-comm = (val ?x:#id! = ?e:#ls-e0!) : qquote($ls-def ~ x ($none) ~ e)
      ls-comm = (var ?x:#id! : ?t:#ls-t0 = ?e:#ls-e0!) : qquote($ls-defvar ~ x ~ t ~ e)
      ls-comm = (var ?x:#id! : ?t:#ls-t0) : qquote($ls-defvar ~ x ~ t ($none))
      ls-comm = (return ?e:#ls-e0!) : qquote($ls-return ~ e)
      ls-comm = (labels : (?bs:#ls-block ... ?rest ...)) :
         CSE(rest, "Expected a labeled block here.") when not empty?(rest)
         qquote($ls-labels ~@ bs)
      ls-comm = (goto ?x:#id!(?args:#ls-es!)) : qquote($ls-goto ~ x ~@ args)
      ls-comm = (goto ?x:#id!) : qquote($ls-goto ~ x)
      ls-comm = (let : ?c:#ls-comm) : qquote($ls-let ~ c)
      ls-comm = (?c:#ls-if) : c
      ls-comm = (?c:#ls-while) : c
      ls-comm = (?c:#ls-match) : c
      ls-comm = (?c:#ls-for) : c      
      ls-comm = (?x:#ls-e0 = ?y:#ls-e0!) : qquote($ls-set ~ x ~ y)
      ls-comm = (?e:#ls-e0) : e
      ls-comm = ((?c:#ls-comm ?cs:#ls-comm ...)) : qquote($begin ~ c ~@ cs)
      ls-comm = (()) : `($begin)

      ls-block = (?name:#id ((?xs:#id! : ?ts:#ls-t0) @...) : ?body:#ls-comm) :
         qquote($ls-block ~ name ~ xs ~ ts ~ body)
      ls-block = (?name:#id : ?body:#ls-comm) :
         qquote($ls-block ~ name () () ~ body)

      ls-if = (if ?pred:#ls-e0! : ?conseq:#ls-comm else : ?alt:#ls-comm) : qquote($ls-if ~ pred ~ conseq ~ alt)
      ls-if = (if ?pred:#ls-e0! : ?conseq:#ls-comm else ?alt:#ls-if) : qquote($ls-if ~ pred ~ conseq ~ alt)
      ls-if = (if ?pred:#ls-e0! : ?conseq:#ls-comm) : qquote($ls-if ~ pred ~ conseq ($begin))
      ls-if != (if) : CSE(form, "Incorrect syntax for if statement.")

      ls-while = (while ?pred:#ls-e0! : ?body:#ls-comm) :
         val template = `(
            labels :
               loop :
                  if pred :
                     body
                     goto loop)
         expandc $ fill-template(template, [
            `pred => pred
            `body => body
            `loop => gensym(`loop)])
      ls-while != (while) :
         CSE(form, "Incorrect syntax for while loop.")

      ls-branch-argt = (: ?t:#ls-t0!) : t
      ls-branch-argt = () : `($none)
      
      ls-match = (match(?es:#ls-es!) :
                     (((?xs:#id! ?ts:#ls-branch-argt) @...) : ?bodies:#ls-comm) @...) :
         val template =
            `($ls-match args
               branches{
                  ($ls-branch xs ts body)
               })
         fill-template(template, [
            `args => es
            `branches => nested $ for (xs in xs, ts in ts, body in bodies) map : [
               `xs => xs
               `ts => ts
               `body => body]])
      ls-match != (match) :
         CSE(form, "Incorrect syntax for match statement.")

      ls-for = (for (?def:#ls-comm, ?pred:#ls-e0, ?step:#ls-comm) : ?body:#ls-comm) :
         val template = `(
            let :
               def
               labels :
                  loop :
                     if pred :
                        body
                        step
                        goto loop)
         expandc $ fill-template(template, [
            `def => def
            `loop => gensym(`loop)
            `pred => pred
            `body => body
            `step => step])
      ls-for != (for) :
         CSE(form, "Incorrect syntax for for loop.")  

      
            

;============== Error Messages ============================
val BAD-ARGLIST-MSG = "Incorrect syntax for argument list. Did you forget to put a space between the function name and the argument list?"
val BAD-MATCH-MSG = "Incorrect syntax for match expression. Is there an extra space between match and the argument list?"
val BAD-FOR-MSG = "Missing operating function in for expression. Did you forget to put a do after the bindings?"
val BAD-INCLUDE-MSG = "Incorrect syntax for include expression. Do you have a space between include and the filename?"         


