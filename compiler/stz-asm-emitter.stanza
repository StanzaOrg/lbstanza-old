#if-defined(ASM-STANDALONE) :
   #include<"core/stringeater.stanza">
   #include<"compiler/stz-algorithms.stanza">
   #include<"compiler/stz-lexer.stanza">
   #include<"compiler/stz-parser.stanza">
   #include("compiler/stz-utils.stanza")
   #include("compiler/stz-asm-ir.stanza")

defpackage stz/asm-emitter :
   import core
   import verse
   import stz/asm-ir
   import stz/lexer
   import stz/utils


;                      Parser
;                      ======

defsyntax asm-ir :
   val ut = unwrap-token

   defrule :
      sym = (?x) when ut(x) typeof Symbol : ut(x)
      int = (?x) when ut(x) typeof Int : ut(x)
      str = (?x) when ut(x) typeof String : ut(x)
      flo = (?x) when ut(x) typeof Float : ut(x)

      op = (+) : ADD-OP
      op = (-) : SUB-OP
      op = (*) : MUL-OP
      op = (/) : DIV-OP      
      op = (%) : MOD-OP
      op = (/%) : DIVMOD-OP
      op = (&) : AND-OP
      op = (~ |) : OR-OP
      op = (^) : XOR-OP
      op = (<<) : SHL-OP
      op = (>>) : SHR-OP
      op = (>>>) : ASHR-OP
      op = (==) : EQ-OP
      op = (!=) : NE-OP
      op = (<) : LT-OP
      op = (>) : GT-OP
      op = (<=) : LE-OP
      op = (>=) : GE-OP
      op = (ule) : ULE-OP
      op = (ult) : ULT-OP
      op = (ugt) : UGT-OP
      op = (uge) : UGE-OP

      type = (B) : BYTE-TYPE
      type = (I) : INT-TYPE
      type = (L) : LONG-TYPE
      type = (F) : FLOAT-TYPE
      type = (D) : DOUBLE-TYPE

      ins = (?t:#type : ?x:#loc = ?y:#imm ?op:#op ?z:#imm) : BinOp(t, x, op, y, z)
      ins = (?t:#type : (?x1:#loc ?x2:#loc) = ?y:#imm ?op:#op ?z:#imm) : DualOp(t, x1, x2, op, y, z)
      ins = (?t:#type : ?x:#loc = [?y:#imm + ?o:#int]) : Load(t, x, y, o)
      ins = (?t:#type : ?x:#loc = [?y:#imm]) : Load(t, x, y, 0)
      ins = (?t:#type : [?x:#imm + ?o:#int] = ?y:#imm) : Store(t, x, y, o)
      ins = (?t:#type : [?x:#imm] = ?y:#imm) : Store(t, x, y, 0)
      ins = (?t:#type : ?x:#loc = ?y:#imm) : SetIns(t, x, y)
      ins = (?t:#type : ?x:#loc <=> ?y:#loc) : XchgIns(t, x, y)
      ins = (L<?n:#int>) : Label(n)
      ins = (L<?n:#sym>) : ExLabel(n)
      ins = (goto ?x:#imm) : Goto(x)
      ins = (?t:#type : branch ?x:#imm when ?y:#imm ?op:#op ?z:#imm) : Branch(t, x, op, y, z)
      ins = (call ?x:#imm) : Call(x)
      ins = (?x:#loc = addr(?y:#imm)) : Addr(x, y, 0)
      ins = (?x:#loc = addr(?y:#imm + ?o:#int)) : Addr(x, y, o)
      ins = (?xt:#type : ?x:#loc = ?yt:#type : ?y:#imm (S)) : ConvertIns(xt, x, yt, y, true)
      ins = (?xt:#type : ?x:#loc = ?yt:#type : ?y:#imm (U)) : ConvertIns(xt, x, yt, y, false)
      ins = (return) : Return()
      ins = (.data) : DefData()
      ins = (.text) : DefText()
      ins = (.byte ?x:#int) : DefByte(x)
      ins = (.int ?x:#int) : DefInt(x)
      ins = (.long ?x:#int) : DefLong(x)
      ins = (.float ?x:#flo) : DefFloat(x)
      ins = (.double ?x:#flo) : DefDouble(x)
      ins = (.string ?x:#str) : DefString(x)
      ins = (.space ?x:#int) : DefSpace(x)
      ins = (.label ?n:#int) : DefLabel(n)

      imm = (?i:#int) : IntImm(i)
      imm = (L<?n:#int>) : Mem(n)
      imm = (L<?n:#sym>) : ExMem(n)
      imm = (?l:#loc) : l
      loc = (R0) : Reg(0)
      loc = (R1) : Reg(1)
      loc = (R2) : Reg(2)
      loc = (R3) : Reg(3)
      loc = (R4) : Reg(4)
      loc = (R5) : Reg(5)
      loc = (R6) : Reg(6)
      loc = (R7) : Reg(7)
      loc = (R8) : Reg(8)
      loc = (R9) : Reg(9)
      loc = (R10) : Reg(10)
      loc = (R11) : Reg(11)
      loc = (R12) : Reg(12)
      loc = (R13) : Reg(13)
      loc = (R14) : Reg(14)
      loc = (F0) : FReg(0)
      loc = (F1) : FReg(1)
      loc = (F2) : FReg(2)
      loc = (F3) : FReg(3)
      loc = (F4) : FReg(4)
      loc = (F5) : FReg(5)
      loc = (F6) : FReg(6)
      loc = (F7) : FReg(7)
      loc = (F8) : FReg(8)
      loc = (F9) : FReg(9)
      loc = (F10) : FReg(10)
      loc = (F11) : FReg(11)
      loc = (F12) : FReg(12)
      loc = (F13) : FReg(13)
      loc = (F14) : FReg(14)
      loc = (F15) : FReg(15)
      loc = (RSP) : RegSP()

defn parse-asm-ir (filename:String) -> List<Ins> :
   val lexed = lex-file(filename)
   with-syntax(asm-ir) :
      match-syntax(lexed) :
         (?ins:#ins ... ?rest ...) :
            if not empty?(rest) :
               error("Not instructions: ~" % [rest])
            ins



;                  Restrictions
;                  ============

val SHF-OPS = [SHL-OP, SHR-OP, ASHR-OP]
val DIV-OPS = [DIV-OP, MOD-OP]
val COM-OPS = [ADD-OP, MUL-OP, AND-OP, OR-OP, XOR-OP]
val NCOM-OPS = [SUB-OP]
val CMP-OPS = [EQ-OP, NE-OP, LT-OP, GT-OP, LE-OP,
               GE-OP, ULE-OP, ULT-OP, UGT-OP, UGE-OP]
val FCOM-OPS = [ADD-OP, MUL-OP]
val FNCOM-OPS = [SUB-OP, DIV-OP]
val FCMP-OPS = [EQ-OP, NE-OP, LT-OP, GT-OP, LE-OP, GE-OP]

defn check-restriction (ins:Ins) :
   ;     Error
   ;     -----
   defn RE () : error("Instruction ~ does not satisfy restrictions." % [ins])
      
   ;     Types of Types
   ;     --------------
   defn #L (t:AsmType) : t == LONG-TYPE
   defn #I (t:AsmType) : t == INT-TYPE
   defn #B (t:AsmType) : t == BYTE-TYPE
   defn #BI (t:AsmType) : contains?([BYTE-TYPE, INT-TYPE], t)
   defn #IL (t:AsmType) : contains?([INT-TYPE, LONG-TYPE], t)
   defn #i (t:AsmType) : contains?([BYTE-TYPE, INT-TYPE, LONG-TYPE], t)
   defn #f (t:AsmType) : contains?([FLOAT-TYPE, DOUBLE-TYPE], t)

   ;     Assumptions about Immediates
   ;     ----------------------------
   defn #SR! (x:Imm) : RE() when x not-typeof RegSP|Reg
   defn #SRI! (x:Imm) : RE() when x not-typeof RegSP|Reg|IntImm
   defn #R! (x:Imm) : RE() when x not-typeof Reg
   defn #RI! (x:Imm) : RE() when x not-typeof Reg|IntImm
   defn #F! (x:Imm) : RE() when x not-typeof FReg
   defn #SRM! (x:Imm) : RE() when x not-typeof RegSP|Reg|Mem|ExMem
   defn #RM! (x:Imm) : RE() when x not-typeof Reg|Mem|ExMem
   defn #M! (x:Imm) : RE() when x not-typeof Mem|ExMem
   defn #R! (x:Imm, num:Int) :
      #R!(x)
      RE() when n(x as Reg) != num
   defn #R0! (x:Imm) : #R!(x, 0)
   defn #R3! (x:Imm) : #R!(x, 3)
   defn #IR2! (x:Imm) :
      match(x) :
         (x:Reg) : RE() when n(x) != 2
         (x:IntImm) : false
         (x) : RE()

   ;     Assumptions about Operators
   ;     ---------------------------
   defn #DIVMOD! (op:AsmOp) : RE() when op != DIVMOD-OP

   ;     Assumptions about Options
   ;     -------------------------
   defn #true! (x:True|False) : RE() when not x

   ;     Compound Assumptions
   ;     --------------------
   defn #nII! (x:Imm, y:Imm) :
      match(x, y) :
         (x:IntImm, y:IntImm) : RE()
         (x, y) : false
   defn #neq! (x:Imm, y:Imm) :
      RE() when x == y
   defn #neq! (x:AsmType, y:AsmType) :
      RE() when x == y

   ;     Dispatch on type of instruction
   ;     -------------------------------
   match(ins) :
      (ins:SetIns) :
         val [t, x, y] = [type(ins), x(ins), y(ins)]
         switch _{t} :
            #L : (#SR!(x), #SRI!(y))
            #i : (#R!(x), #RI!(y))
            #f : (#F!(x), #F!(y))
      (ins:XchgIns) :
         val [t, x, y] = [type(ins), x(ins), y(ins)]
         switch _{t} :
            #i : (#R!(x), #R!(y))
            else : RE()
      (ins:ConvertIns) :
         val [xt, yt, x, y, s] = [xtype(ins), ytype(ins), x(ins), y(ins), signed?(ins)]         
         if #i(xt) :
            #R!(x)
            if #i(yt) : (#R!(y), #neq!(xt,yt))
            else if #f(yt) : (#F!(y), #true!(s))
            else : RE()
         else if #f(xt) :
            #F!(x)
            if #BI(yt) : #R!(y)
            else if #L(yt) : (#R!(y), #true!(s))
            else if #f(yt) : (#F!(y), #neq!(xt,yt), #true!(s))
            else : RE()
         else : RE()
      (ins:BinOp) :
         val [t, x, y, z, op] = [type(ins), x(ins), y(ins), z(ins), op(ins)]
         if #i(t) :
            switch contains?{_, op} :
               COM-OPS :
                  if #L(t) : (#SR!(x), #SRI!(y), #SRI!(z))
                  else : (#R!(x), #RI!(y), #RI!(z))
               NCOM-OPS :
                  if #L(t) : (#SR!(x), #SRI!(y), #SRI!(z), #neq!(x,z))
                  else : (#R!(x), #RI!(y), #RI!(z), #neq!(x,z))
               SHF-OPS :
                  if #L(t) : (#SR!(x), #SRI!(y), #IR2!(z))
                  else : (#R!(x), #RI!(y), #IR2!(z))
               DIV-OPS :
                  if #B(t) : (#R0!(x), #R!(y), #R!(z))
                  else : RE()
               CMP-OPS :
                  if #L(t) : (#R!(x), #SRI!(y), #SRI!(z), #nII!(y,z))
                  else : (#R!(x), #RI!(y), #RI!(z), #nII!(y,z))
               else : RE()                  
         else if #f(t) :
            switch contains?{_, op} :
               FCOM-OPS : (#F!(x), #F!(y), #F!(z))                  
               FNCOM-OPS : (#F!(x), #F!(y), #F!(z), #neq!(x,z))
               FCMP-OPS : (#F!(x), #F!(y), #F!(z))
               else : RE()
         else : RE()
      (ins:DualOp) :
         val [t, x1, x2, op, y, z] = [type(ins), x1(ins), x2(ins), op(ins), y(ins), z(ins)]
         if #IL(t) : (#R0!(x1), #R3!(x2), #R!(y), #R!(z), #DIVMOD!(op))
         else : RE()
      (ins:Load) :
         val [t, x, y] = [type(ins), x(ins), y(ins)]
         if #L(t) : (#SR!(x), #SRM!(y))
         else if #i(t) : (#R!(x), #SRM!(y))
         else if #f(t) : (#F!(x), #SRM!(y))
         else : RE()
      (ins:Store) :
         val [t, x, y] = [type(ins), x(ins), y(ins)]
         if #L(t) : (#SRM!(x), #SRI!(y))
         else if #i(t) : (#SRM!(x), #RI!(y))
         else if #f(t) : (#SRM!(x), #F!(y))
         else : RE()
      (ins:Addr) :
         val [x, y] = [x(ins), y(ins)]
         #SR!(x), #SRM!(y)
      (ins:Call) :
         #RM!(x(ins))
      (ins:Return) :
         false
      (ins:Goto) :
         #RM!(x(ins))
      (ins:Branch) :
         val [t, x, op, y, z] = [type(ins), x(ins), op(ins), y(ins), z(ins)]
         if #L(t) : (#M!(x), #SRI!(y), #SRI!(z), #nII!(y,z))
         else if #i(t) : (#M!(x), #RI!(y), #RI!(z), #nII!(y,z))
         else if #f(t) : (#M!(x), #F!(y), #F!(z))
         else : RE()
      (ins:Label|ExLabel) :
         false
      (ins:DefData|DefText|DefByte|DefInt|DefLong|
           DefFloat|DefDouble|DefString|DefSpace|DefLabel) :
         false      


;                     Emitter
;                     =======

;     Names of Registers for Different Types
;     --------------------------------------
val REG-LONG-NAMES = [
   "%rax", "%rbx", "%rcx", "%rdx", "%rsi", "%rdi", "%rbp", "%r8",
   "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15"]

val REG-INT-NAMES = [
   "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi", "%ebp", "%r8d",
   "%r9d", "%r10d", "%r11d", "%r12d", "%r13d", "%r14d", "%r15d"]

val REG-BYTE-NAMES = [
   "%al", "%bl", "%cl", "%dl", "%sil", "%dil", "%bpl", "%r8b",
   "%r9b", "%r10b", "%r11b", "%r12b", "%r13b", "%r14b", "%r15b"]

val REG-FLOAT-NAMES = [
   "%xmm0", "%xmm1", "%xmm2", "%xmm3",
   "%xmm4", "%xmm5", "%xmm6", "%xmm7",
   "%xmm8", "%xmm9", "%xmm10", "%xmm11",
   "%xmm12", "%xmm13", "%xmm14", "%xmm15"]

;     Generation of Instructions
;     --------------------------

val SWAP-LBL = fresh-id()

defn gen (ins:Ins) :
   ;     Utilities
   ;     ---------
   defn pr (x) : println(x)
   defn cms (xs:Streamable) : join(xs, ", ")
   defn chars (s:String) : concat(stream(to-int, s), [0])
   defn #lbl (n:Int) : "__L~" << [n]

   ;     Predicates for Types
   ;     --------------------
   defn #B (t:AsmType) : t == BYTE-TYPE
   defn #i (t:AsmType) : contains?([BYTE-TYPE, INT-TYPE, LONG-TYPE], t)
   defn #f (t:AsmType) : contains?([FLOAT-TYPE, DOUBLE-TYPE], t)

   ;     Size Suffix
   ;     -----------
   defn size-suffix (t:AsmType) :
      switch {t == _} :
         BYTE-TYPE : "b"
         INT-TYPE : "l"
         LONG-TYPE : "q"
         FLOAT-TYPE : "s"
         DOUBLE-TYPE : "d"


   ;     Immediate Names
   ;     ---------------
   defn #imm (t:AsmType, x:Imm) :
      match(x) :
         (x:IntImm) :
            "$~" << [value(x)]
         (x:Reg) :
            switch {t == _} :
               BYTE-TYPE : REG-BYTE-NAMES[n(x)]
               INT-TYPE : REG-INT-NAMES[n(x)]
               LONG-TYPE : REG-LONG-NAMES[n(x)]
         (x:FReg) :
            REG-FLOAT-NAMES[n(x)]
         (x:RegSP) :
            "%rsp"

   ;     Set Instruction
   ;     ---------------
   defn #set (t:AsmType, x:Loc, y:Imm) :
      pr("   mov~ ~, ~" << [size-suffix(t), #imm(t,y), #imm(t,x)])
      
   defn #fset (t:AsmType, x:Loc, y:Imm) :
      pr("   movs~ ~, ~" << [size-suffix(t), #imm(t,y), #imm(t,x)])

   ;     Scratch Space
   ;     -------------
   defn #save (x:Imm) :
      #store(LONG-TYPE, Mem(SWAP-LBL), x, 0)
      
   defn #restore (x:Loc) :
      #load(LONG-TYPE, x, Mem(SWAP-LBL), 0)

   ;     Convert Instruction
   ;     -------------------
   defn #conv (x:Loc, y:Imm, xtype:AsmType, ytype:AsmType, signed?:True|False) :
      val xsz = size-suffix(xtype)
      val ysz = size-suffix(ytype)
      if #i(xtype) and #i(ytype) :
         val mov = "movs" when signed? else "movz"
         pr("   ~~~ ~, ~" << [mov, ysz, xsz, #imm(ytype, y), #imm(xtype, x)])
      else if #f(xtype) and #f(ytype) :
         pr("   cvts~2s~ ~, ~" << [ysz, xsz, #imm(ytype, y), #imm(xtype, x)])
      else if #i(xtype) and #f(ytype) :
         if #B(xtype) :
            #conv(x, y, INT-TYPE, ytype, signed?)
         else :
            pr("   cvts~2si~ ~, ~" << [ysz, xsz, #imm(ytype, y), #imm(xtype, x)])
      else if #f(xtype) and #i(ytype) :
         if signed? :
            if #B(ytype) :
               #conv(y as Reg, y, LONG-TYPE, ytype, signed?)
               #conv(x, y, xtype, LONG-TYPE, true)
            else :   
               pr("   cvtsi2s~~ ~, ~" << [xsz, ysz, #imm(ytype, y), #imm(xtype, x)])
         else :
            #conv(y as Reg, y, LONG-TYPE, ytype, signed?)
            #conv(x, y, xtype, LONG-TYPE, true)
      else :
         error("Unreachable")

   ;     Save/Load Instructions
   ;     ----------------------
   defn #load (t:AsmType, x:Loc, y:Imm, o:Int) :
      val sz = size-suffix(t)
      val mov = if #i(t) : "mov"
                else if #f(t) : "movs"
                else : error("Unreachable")
      match(y) :
         (y:Reg|RegSP) : pr("   ~~ ~(~), ~" << [mov, sz, o, #imm(LONG-TYPE, y), #imm(t, x)])
         (y:Mem) : pr("   ~~ (~ + ~)(%rip), ~" << [mov, sz, #lbl(n(y)), o, #imm(t, x)])
         (y:ExMem) : pr("   ~~ (~ + ~)(%rip), ~" << [mov, sz, name(y), o, #imm(t, x)])

   defn #store (t:AsmType, x:Imm, y:Imm, o:Int) :
      val sz = size-suffix(t)
      val mov = if #i(t) : "mov"
                else if #f(t) : "movs"
                else : error("Unreachable")
      match(x) :
         (x:Reg|RegSP) : pr("   ~~ ~, ~(~)" << [mov, sz, #imm(t, y), o, #imm(LONG-TYPE, x)])
         (x:Mem) : pr("   ~~ ~, (~ + ~)(%rip)" << [mov, sz, #imm(t, y), #lbl(n(x)), o])
         (x:ExMem) : pr("   ~~ ~, (~ + ~)(%rip)" << [mov, sz, #imm(t, y), name(x), o])   

   ;     Binary Operators
   ;     ----------------
   defn div-op? (x:AsmOp) : contains?(DIV-OPS, x)
   defn cmp-op? (x:AsmOp) : contains?(CMP-OPS, x)
   defn com-op? (x:AsmOp) : contains?(COM-OPS, x)
   defn ncom-op? (x:AsmOp) : contains?(NCOM-OPS, x)
   defn shf-op? (x:AsmOp) : contains?(SHF-OPS, x)
   defn fcmp-op? (x:AsmOp) : contains?(FCMP-OPS, x)
   defn fcom-op? (x:AsmOp) : contains?(FCOM-OPS, x)
   defn fncom-op? (x:AsmOp) : contains?(FNCOM-OPS, x)
   defn divmod-op? (x:AsmOp) : x == DIVMOD-OP

   defn #com (t:AsmType, x:Loc, y:Imm, op:AsmOp, z:Imm) :
      val sz = size-suffix(t)
      val comm = switch {op == _} :
         ADD-OP : "add"
         MUL-OP : "imul"
         AND-OP : "and"
         OR-OP : "or"
         XOR-OP : "xor"
      if x == y :
         pr("   ~~ ~, ~" << [comm, sz, #imm(t,z), #imm(t,x)])
      else if x == z :
         pr("   ~~ ~, ~" << [comm, sz, #imm(t,y), #imm(t,x)])
      else :
         #set(t, x, y)
         #com(t, x, x, op, z)

   defn #ncom (t:AsmType, x:Loc, y:Imm, op:AsmOp, z:Imm) :
      val sz = size-suffix(t)
      val comm = switch {op == _} :
         SUB-OP : "sub"
      if x == y :
         pr("   ~~ ~, ~" << [comm, sz, #imm(t,z), #imm(t,x)])
      else :
         #set(t, x, y)
         #ncom(t, x, x, op, z)

   defn #shf (t:AsmType, x:Loc, y:Imm, op:AsmOp, z:Imm) :
      val sz = size-suffix(t)
      val comm = switch {op == _} :
         SHL-OP : "shl"
         SHR-OP : "shr"
         ASHR-OP : "sar"
      if x == y :
         pr("   ~~ ~, ~" << [comm, sz, #imm(BYTE-TYPE, z), #imm(t,x)])
      else :
         #set(t, x, y)
         #shf(t, x, x, op, z)

   defn #div (t:AsmType, x:Loc, y:Imm, op:AsmOp, z:Imm) :
      if x == z :
         val tmp = if y == Reg(2) : Reg(1)
                   else : Reg(2)
         #save(tmp)
         #set(LONG-TYPE, tmp, z)
         #div(t, x, y, op, tmp)
         #restore(tmp)
      else :
         pr("   movzbw ~, %ax" << [#imm(t, y)])
         pr("   idivb ~" << [#imm(t, z)])
         pr("   shrw $8, %ax") when op == MOD-OP

   defn #cmp (t:AsmType, x:Loc, y:Imm, op:AsmOp, z:Imm) :
      val comm = cmp-suffix(op)
      val sz = size-suffix(t)
      match(y, z) :
         (y:Reg, z) :
            pr("   cmp~ ~, ~" << [sz, #imm(t,z), #imm(t,y)])
            pr("   movq $0, ~" << [#imm(LONG-TYPE, x)])
            pr("   set~ ~" << [comm, #imm(BYTE-TYPE, x)])
         (y, z:Reg) :
            #cmp(t, x, z, cmp-invert(op), y)

   defn cmp-suffix (op:AsmOp) :
      switch {op == _} :
         EQ-OP : "e"
         NE-OP : "ne"
         LT-OP : "l"
         GT-OP : "g"
         LE-OP : "le"
         GE-OP : "ge"
         ULE-OP : "be"
         ULT-OP : "b"
         UGT-OP : "a"
         UGE-OP : "ae"

   defn cmp-invert (op:AsmOp) :
      switch {op == _} :
         EQ-OP : NE-OP
         NE-OP : EQ-OP
         LT-OP : GE-OP
         GT-OP : LE-OP
         LE-OP : GT-OP
         GE-OP : LT-OP
         ULE-OP : UGT-OP
         ULT-OP : UGE-OP
         UGT-OP : ULE-OP
         UGE-OP : ULT-OP

   defn #fcom (t:AsmType, x:Loc, y:Imm, op:AsmOp, z:Imm) :
      val sz = size-suffix(t)
      val comm = switch {op == _} :
         ADD-OP : "adds"
         MUL-OP : "muls"
      if x == y :
         pr("   ~~ ~, ~" << [comm, sz, #imm(t,z), #imm(t,x)])
      else if x == z :
         pr("   ~~ ~, ~" << [comm, sz, #imm(t,y), #imm(t,x)])
      else :
         #fset(t, x, y)
         #fcom(t, x, x, op, z)

   defn #fncom (t:AsmType, x:Loc, y:Imm, op:AsmOp, z:Imm) :
      val sz = size-suffix(t)
      val comm = switch {op == _} :
         SUB-OP : "subs"
         DIV-OP : "divs"
      if x == y :
         pr("   ~~ ~, ~" << [comm, sz, #imm(t,z), #imm(t,x)])
      else :
         #fset(t, x, y)
         #fncom(t, x, x, op, z)

   defn fcmp-suffix (op:AsmOp) :
      switch {op == _} :
         EQ-OP : "e"
         NE-OP : "ne"
         LE-OP : "be"
         LT-OP : "b"
         GT-OP : "a"
         GE-OP : "ae"

   defn #fcmp (t:AsmType, x:Loc, y:Imm, op:AsmOp, z:Imm) :
      val comm = fcmp-suffix(op)
      val sz = size-suffix(t)
      match(y, z) :
         (y:FReg, z:FReg) :
            pr("   ucomis~ ~, ~" << [sz, #imm(t,z), #imm(t,y)])
            pr("   movq $0, ~" << [#imm(LONG-TYPE, x)])
            pr("   set~ ~" << [comm, #imm(BYTE-TYPE, x)])

   defn #br (t:AsmType, x:Imm, y:Imm, op:AsmOp, z:Imm) :
      val sz = size-suffix(t)
      val comm = cmp-suffix(op)
      match(y, z) :
         (y:Reg, z) :
            pr("   cmp~ ~, ~" << [sz, #imm(t,z), #imm(t,y)])
            match(x) :
               (x:Mem) : pr("   j~ ~" << [comm, #lbl(n(x))])
               (x:ExMem) : pr("   j~ ~" << [comm, name(x)])
         (y, z:Reg) :
            #br(t, x, z, cmp-invert(op), y)

   defn #fbr (t:AsmType, x:Imm, y:Imm, op:AsmOp, z:Imm) :
      val sz = size-suffix(t)
      val comm = fcmp-suffix(op)
      match(y, z) :
         (y:FReg, z:FReg) :
            pr("   ucomis~ ~, ~" << [sz, #imm(t,z), #imm(t,y)])
            match(x) :
               (x:Mem) : pr("   j~ ~" << [comm, #lbl(n(x))])
               (x:ExMem) : pr("   j~ ~" << [comm, name(x)])

   ;     Dual Divide Operator
   ;     --------------------
   defn #divmod (t:AsmType, x1:Loc, x2:Loc, y:Imm, op:AsmOp, z:Imm) :
      val sz = size-suffix(t)
      if x1 == y :
         switch {t == _} :
            LONG-TYPE : pr("   cqo")
            INT-TYPE : pr("   cdq")
         pr("   idiv~ ~" << [sz, #imm(t,z)])
      else if x1 == z :
         val tmp = if y == Reg(1) : Reg(2)
                   else : Reg(1)
         #save(tmp)
         #set(t, tmp, z)
         #divmod(t, x1, x2, y, op, tmp)
         #restore(tmp)
      else :
         #set(t, x1, y)
         #divmod(t, x1, x2, x1, op z)

   ;====== Driver ======
   match(ins) :
      (ins:XchgIns) :         
         val [t, x, y] = [type(ins), x(ins), y(ins)]
         val sz = size-suffix(t)
         pr("   xchg~ ~, ~" << [sz, #imm(t,x), #imm(t,y)])
      (ins:SetIns) :
         val [t, x, y] = [type(ins), x(ins), y(ins)]
         if #i(t) : #set(t, x, y)
         else if #f(t) : #fset(t, x, y)
         else : error("Unreachable")
      (ins:BinOp) :
         val [t, x, op, y, z] = [type(ins), x(ins), op(ins), y(ins), z(ins)]
         if #i(t) :
            switch _{op} :
               div-op? : #div(t, x, y, op, z)
               cmp-op? : #cmp(t, x, y, op, z)
               com-op? : #com(t, x, y, op, z)
               ncom-op? : #ncom(t, x, y, op, z)
               shf-op? : #shf(t, x, y, op, z)
               else : error("Invalid integer operator.")
         else if #f(t) :
            switch _{op} :
               fcmp-op? : #fcmp(t, x, y, op, z)
               fcom-op? : #fcom(t, x, y, op, z)
               fncom-op? : #fncom(t, x, y, op, z)
               else : error("Invalid float operator.")
         else : error("Unreachable.")
      (ins:DualOp) :
         val [t, x1, x2, op, y, z] = [type(ins), x1(ins), x2(ins), op(ins), y(ins), z(ins)]
         if divmod-op?(op) : #divmod(t, x1, x2, y, op, z)
         else : error("Unreachable")
      (ins:Load) :
         #load(type(ins), x(ins), y(ins), offset(ins))
      (ins:Store) :
         #store(type(ins), x(ins), y(ins), offset(ins))
      (ins:Label) :
         pr("~:" << [#lbl(n(ins))])
      (ins:ExLabel) :
         pr("   .globl ~" << [name(ins)])
         pr("~:" << [name(ins)])
      (ins:Goto) :
         match(x(ins)) :
            (x:Reg) : pr("   jmp *~" << [#imm(LONG-TYPE, x)])
            (x:Mem) : pr("   jmp ~" << [#lbl(n(x))])
            (x:ExMem) : pr("   jmp ~" << [name(x)])
      (ins:Branch) :
         val [t, x, op, y, z] = [type(ins), x(ins), op(ins), y(ins), z(ins)]
         if #i(t) : #br(t, x, y, op, z)
         else if #f(t) : #fbr(t, x, y, op, z)
         else : error("Unreachable")
      (ins:Call) :
         match(x(ins)) :
            (x:Reg) : pr("   call *~" << [#imm(LONG-TYPE, x)])
            (x:Mem) : pr("   call ~" << [#lbl(n(x))])
            (x:ExMem) : pr("   call ~" << [name(x)])
      (ins:Addr) :
         val xloc = #imm(LONG-TYPE, x(ins))
         val o = offset(ins)
         match(y(ins)) :
            (y:Reg|RegSP) : pr("   leaq ~(~), ~" << [o, #imm(LONG-TYPE, y), xloc])
            (y:Mem) : pr("   leaq (~ + ~)(%rip), ~" << [#lbl(n(y)), o, xloc])
            (y:ExMem) : pr("   leaq (~ + ~)(%rip), ~" << [name(y), o, xloc])
      (ins:ConvertIns) :
         #conv(x(ins), y(ins), xtype(ins), ytype(ins), signed?(ins))
      (ins:Return) : pr("   ret")
      (ins:DefByte) : pr("   .byte ~" << [value(ins)])
      (ins:DefInt) : pr("   .long ~" << [value(ins)])
      (ins:DefLong) : pr("   .quad ~" << [value(ins)])
      (ins:DefFloat) : pr("   .long ~" << [as-int(value(ins))])
      (ins:DefDouble) : pr("   .quad ~" << [as-int(value(ins))])
      (ins:DefString) : pr("   .byte ~@" << [cms(chars(value(ins)))])
      (ins:DefSpace) : pr("   .space ~" << [size(ins)])
      (ins:DefLabel) : pr("   .quad ~" << [#lbl(n(ins))])
      (ins:DefData) : pr("   .data")
      (ins:DefText) : pr("   .text")

;                      Driver
;                      ======

public defn emit (ins:Streamable<Ins>) :
   ;     Check Restrictions
   ;     ------------------
   do(check-restriction, ins)

   ;     Scratch Space
   ;     -------------
   gen $ DefData()
   gen $ Label(SWAP-LBL)
   gen $ DefLong(0)
   gen $ DefText()

   ;     Generate instructions
   ;     ---------------------
   do(gen, ins)


;                     Testing
;                     =======
#if-defined(ASM-STANDALONE) :
   defn main () :
      val filename = commandline-arguments()[1]
      val outfile = commandline-arguments()[2]
      println("Reading assembly file: ~" << [filename])
      val ins = parse-asm-ir(filename)
      with-output-file{outfile, _} $ fn () :
         emit(ins)

   main()

