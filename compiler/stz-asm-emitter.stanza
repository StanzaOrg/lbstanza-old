#include<"core/stringeater.stanza">
#include<"compiler/stz-algorithms.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">
#include("compiler/stz-asm-ir.stanza")

defpackage stz/asm-emitter :
   import core
   import verse
   import stz/asm-ir
   import stz/lexer

;====== Reader ======
defsyntax asm-ir :
   val ut = unwrap-token

   defrule :
      sym = (?x) when ut(x) typeof Symbol : ut(x)
      int = (?x) when ut(x) typeof Int : ut(x)
      str = (?x) when ut(x) typeof String : ut(x)

      op = (+) : ADD-OP
      op = (-) : MINUS-OP
      op = (*) : TIMES-OP
      op = (/) : DIVIDE-OP
      op = (%) : MODULO-OP
      op = (&) : AND-OP
      op = (~ |) : OR-OP
      op = (^) : XOR-OP
      op = (<) : SHL-OP
      op = (>) : SHR-OP
      op = (>>) : ASHR-OP
      op = (==) : EQ-OP
      op = (!=) : NE-OP
      op = (<) : LT-OP
      op = (>) : GT-OP
      op = (<=) : LE-OP
      op = (>=) : GE-OP
      op = (ule) : ULE-OP
      op = (ult) : ULT-OP
      op = (ugt) : UGT-OP
      op = (uge) : UGE-OP

      type = (B) : BYTE-TYPE
      type = (I) : INT-TYPE
      type = (L) : LONG-TYPE
      type = (F) : FLOAT-TYPE
      type = (D) : DOUBLE-TYPE

      ins = (?t:#type : ?x:#loc = ?y:#imm) : SetIns(t, x, y)
      ins = (?t:#type : ?x:#loc = ?y:#imm ?op:#op ?z:#imm) : BinOp(t, x, op, y, z)
      ins = (?t:#type : ?x:#loc = [?y:#imm + ?o:#int]) : Load(t, x, y, o)
      ins = (?t:#type : ?x:#loc = [?y:#imm]) : Load(t, x, y, 0)
      ins = (?t:#type : [?x:#loc + ?o:#int] = ?y:#imm) : Store(t, x, y, o)
      ins = (?t:#type : [?x:#loc] = ?y:#imm) : Store(t, x, y, 0)
      ins = (label ?n:#int) : Label(n)
      ins = (exlabel ?n:#sym) : ExLabel(n)
      ins = (goto ?n:#int) : Goto(n)
      ins = (branch ?n:#int when ?t:#type : ?x:#imm ?op:#op ?y:#imm) : Branch(t, n, op, x, y)
      ins = (call ?n:#int) : Call(n)
      ins = (calli ?x:#imm) : CallI(x)
      ins = (jump ?x:#imm) : Jump(x)
      ins = (?x:#loc = addr(?y:#loc)) : Addr(x, y)
      ins = (.data) : DefData()
      ins = (.text) : DefText()
      ins = (.long ?x:#int) : DefLong(x)
      ins = (.string ?x:#str) : DefString(x)
      ins = (.space ?x:#int) : DefSpace(x)
      ins = (.label ?n:#int) : DefLabel(n)

      imm = (?i:#int) : IntImm(i)
      imm = (?l:#loc) : l
      loc = (R0) : Reg(0)
      loc = (R1) : Reg(1)
      loc = (R2) : Reg(2)
      loc = (R3) : Reg(3)
      loc = (R4) : Reg(4)
      loc = (R5) : Reg(5)
      loc = (R6) : Reg(6)
      loc = (R7) : Reg(7)
      loc = (R8) : Reg(8)
      loc = (R9) : Reg(9)
      loc = (Mem[?n:#int + ?o:#int]) : Mem(n, o)
      loc = (Mem[?n:#int]) : Mem(n, 0)
      loc = (Mem[?n:#sym + ?o:#int]) : ExMem(n, o)
      loc = (Mem[?n:#sym]) : ExMem(n, 0)
      loc = (Stk[?o:#int]) : Stack(o)
      loc = (RSP) : RegSP()      
      
defn parse-asm-ir (filename:String) -> List<Ins> :
   val lexed = lex-file(filename)
   with-syntax(asm-ir) :
      match-syntax(lexed) :
         (?ins:#ins ...) : ins      

;;====== Binops ======
;val BAD-NON-COMM-OP =
;   "Return and operand equivalent on non-commutative op: ~, ~, ~"
;   
;
;x = x < z
;
;x = y < x
;
;defn gen-binop (t:AsmType, op:AsmOp, x:Loc, y:Imm, z:Imm) :
;   if comparative?(op) :
;      if x == z :
;         x = y < x
;         println("   cmp~ ~, ~" << [sz, y, x])
;      else if x == y :
;         gen-binop(t, invert-cmp(op), x, z, y)
;      else :
;         println("   mov~ ~, ~" << [sz, z, x])
;         
;   else if commutative?(op) :
;      if x == y :
;         println("   ~~ ~, ~" << [comm, sz, z, x])
;      else if x == z :
;         println("   ~~ ~, ~" << [comm, sz, y, x])
;      else :
;         println("   mov~ ~, ~" << [sz, y, x])
;         println("   ~~ ~, ~" << [comm, sz, z, x])
;   else :
;      if x == y :
;         println("   ~~ ~, ~" << [comm, sz, z, x])
;      else :
;         error(BAD-NON-COMM-OP << [op, x, y]) when x == z
;         println("   mov~ ~, ~" << [sz, y, x])
;         println("   ~~ ~, ~" << [comm, sz, z, x])      
;
;;====== Generate Gen Function ======
;defn gen (ins:Streamable<Ins>) :
;   do(gen, ins)
;
defn gen (ins:Ins) :
   ;====== Utilities ======
   defn pr (x) : println(x)
   defn cms (xs:Streamable) : join(xs, ", ")
   defn chars (s:String) : concat(stream(to-int, s), [0])
   defn #lbl (n:Int) : "__L~" << [n]
   
   ;====== Driver ======
   match(ins) :
      (ins:DefLong) : pr("   .quad ~" << [value(ins)])
      (ins:DefString) : pr("   .byte ~@" << [cms(chars(value(ins)))])
      (ins:DefSpace) : pr("   .space ~" << [size(ins)])
      (ins:DefLabel) : pr("   .quad ~" << [#lbl(n(ins))])
      (ins:DefData) : pr("   .data")
      (ins:DefText) : pr("   .text")
      
      ;(ins:SetIns) : gen-set(type(ins), x(ins), y(ins))
      ;   val t = type(ins)
      ;   println("   mov~ ~, ~" << [
      ;      size-suffix(t),
      ;      imm(y(ins), t),
      ;      imm(x(ins), t)])
      ;(ins:BinOp) : gen-binop(type(ins), op(ins), x(ins), y(ins), z(ins))
      ;(ins:Load) :
      ;(ins:Store) :
      ;(ins:Label) :
      ;(ins:ExLabel) :
      ;(ins:Goto) :
      ;(ins:Branch) :


;====== Driver ======

defn main () :
   val filename = commandline-arguments()[1]
   println("Reading assembly file: ~" << [filename])
   val ins = parse-asm-ir(filename)
   do(gen, ins)

main()