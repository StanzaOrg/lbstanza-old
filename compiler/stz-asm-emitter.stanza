defpackage stz/asm-emitter :
   import core
   import verse
   import stz/asm-ir

;====== Binops ======
val BAD-NON-COMM-OP =
   "Return and operand equivalent on non-commutative op: ~, ~, ~"
   

x = x < z

x = y < x

defn gen-binop (t:AsmType, op:AsmOp, x:Loc, y:Imm, z:Imm) :
   if comparative?(op) :
      if x == z :
         x = y < x
         println("   cmp~ ~, ~" << [sz, y, x])
      else if x == y :
         gen-binop(t, invert-cmp(op), x, z, y)
      else :
         println("   mov~ ~, ~" << [sz, z, x])
         
   else if commutative?(op) :
      if x == y :
         println("   ~~ ~, ~" << [comm, sz, z, x])
      else if x == z :
         println("   ~~ ~, ~" << [comm, sz, y, x])
      else :
         println("   mov~ ~, ~" << [sz, y, x])
         println("   ~~ ~, ~" << [comm, sz, z, x])
   else :
      if x == y :
         println("   ~~ ~, ~" << [comm, sz, z, x])
      else :
         error(BAD-NON-COMM-OP << [op, x, y]) when x == z
         println("   mov~ ~, ~" << [sz, y, x])
         println("   ~~ ~, ~" << [comm, sz, z, x])      

;====== Generate Gen Function ======
defn gen (ins:Streamable<Ins>) :
   do(gen, ins)

defn gen (ins:Ins) :
   match(ins) :
      (ins:SetIns) : gen-set(type(ins), x(ins), y(ins))
         val t = type(ins)
         println("   mov~ ~, ~" << [
            size-suffix(t),
            imm(y(ins), t),
            imm(x(ins), t)])
      (ins:BinOp) : gen-binop(type(ins), op(ins), x(ins), y(ins), z(ins))
      (ins:Load) :
      (ins:Store) :
      (ins:Label) :
      (ins:ExLabel) :
      (ins:Goto) :
      (ins:Branch) :
