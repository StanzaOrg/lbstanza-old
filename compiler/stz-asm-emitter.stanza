#include<"core/stringeater.stanza">
#include<"compiler/stz-algorithms.stanza">
#include<"compiler/stz-lexer.stanza">
#include<"compiler/stz-parser.stanza">
#include("compiler/stz-asm-ir.stanza")

defpackage stz/asm-emitter :
   import core
   import verse
   import stz/asm-ir
   import stz/lexer

;====== Reader ======
defsyntax asm-ir :
   val ut = unwrap-token

   defrule :
      sym = (?x) when ut(x) typeof Symbol : ut(x)
      int = (?x) when ut(x) typeof Int : ut(x)
      str = (?x) when ut(x) typeof String : ut(x)

      op = (+) : ADD-OP
      op = (-) : SUB-OP
      op = (*) : MUL-OP
      op = (/) : DIV-OP
      op = (%) : MOD-OP
      op = (&) : AND-OP
      op = (~ |) : OR-OP
      op = (^) : XOR-OP
      op = (<<) : SHL-OP
      op = (>>) : SHR-OP
      op = (>>>) : ASHR-OP
      op = (==) : EQ-OP
      op = (!=) : NE-OP
      op = (<) : LT-OP
      op = (>) : GT-OP
      op = (<=) : LE-OP
      op = (>=) : GE-OP
      op = (ule) : ULE-OP
      op = (ult) : ULT-OP
      op = (ugt) : UGT-OP
      op = (uge) : UGE-OP

      type = (B) : BYTE-TYPE
      type = (I) : INT-TYPE
      type = (L) : LONG-TYPE
      type = (F) : FLOAT-TYPE
      type = (D) : DOUBLE-TYPE

      ins = (?t:#type : ?x:#loc = ?y:#imm ?op:#op ?z:#imm) : BinOp(t, x, op, y, z)
      ins = (?t:#type : ?x:#loc = [?y:#imm + ?o:#int]) : Load(t, x, y, o)
      ins = (?t:#type : ?x:#loc = [?y:#imm]) : Load(t, x, y, 0)
      ins = (?t:#type : [?x:#loc + ?o:#int] = ?y:#imm) : Store(t, x, y, o)
      ins = (?t:#type : [?x:#loc] = ?y:#imm) : Store(t, x, y, 0)
      ins = (?t:#type : ?x:#loc = ?y:#imm) : SetIns(t, x, y)
      ins = (L<?n:#int>) : Label(n)
      ins = (L<?n:#sym>) : ExLabel(n)
      ins = (goto ?n:#int) : Goto(n)
      ins = (branch ?n:#int when ?t:#type : ?x:#imm ?op:#op ?y:#imm) : Branch(t, n, op, x, y)
      ins = (call ?n:#int) : Call(n)
      ins = (calli ?x:#imm) : CallI(x)
      ins = (jump ?x:#imm) : Jump(x)
      ins = (?x:#loc = addr(?y:#loc)) : Addr(x, y)
      ins = (.data) : DefData()
      ins = (.text) : DefText()
      ins = (.long ?x:#int) : DefLong(x)
      ins = (.string ?x:#str) : DefString(x)
      ins = (.space ?x:#int) : DefSpace(x)
      ins = (.label ?n:#int) : DefLabel(n)

      imm = (?i:#int) : IntImm(i)
      imm = (L<?n:#int>) : Mem(n)
      imm = (L<?n:#sym>) : ExMem(n)
      imm = (?l:#loc) : l
      loc = (R0) : Reg(0)
      loc = (R1) : Reg(1)
      loc = (R2) : Reg(2)
      loc = (R3) : Reg(3)
      loc = (R4) : Reg(4)
      loc = (R5) : Reg(5)
      loc = (R6) : Reg(6)
      loc = (R7) : Reg(7)
      loc = (R8) : Reg(8)
      loc = (R9) : Reg(9)
      loc = (RSP) : RegSP()
      
defn parse-asm-ir (filename:String) -> List<Ins> :
   val lexed = lex-file(filename)
   with-syntax(asm-ir) :
      match-syntax(lexed) :
         (?ins:#ins ... ?rest ...) :
            if not empty?(rest) :
               error("Not instructions: ~" % [rest])
            ins      

val REG-LONG-NAMES = [
   "%rax", "%rbx", "%rcx", "%rdx", "%rsi", "%rdi", "%rbp", "%r8",
   "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15"]
   
val REG-INT-NAMES = [
   "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi", "%ebp", "%r8d",
   "%r9d", "%r10d", "%r11d", "%r12d", "%r13d", "%r14d", "%r15d"]
   
val REG-BYTE-NAMES = [
   "%al", "%bl", "%cl", "%dl", "%sil", "%dil", "%bpl", "%r8b",
   "%r9b", "%r10b", "%r11b", "%r12b", "%r13b", "%r14b", "%r15b"]

val DIV-OPS = [DIV-OP, MOD-OP]
val CMP-OPS = [EQ-OP, NE-OP, LT-OP, GT-OP, LE-OP,
               GE-OP, ULE-OP, ULT-OP, UGT-OP, UGE-OP]
val COM-OPS = [ADD-OP, MUL-OP, AND-OP, OR-OP, XOR-OP]
val NCOM-OPS = [SUB-OP]
val SHF-OPS = [SHL-OP, SHR-OP, ASHR-OP]

defn gen (ins:Ins) :
   ;====== Utilities ======
   defn pr (x) : println(x)
   defn cms (xs:Streamable) : join(xs, ", ")
   defn chars (s:String) : concat(stream(to-int, s), [0])
   defn #lbl (n:Int) : "__L~" << [n]

   ;====== Type and Size of Instruction ======
   defn #type () :
      type(ins as SetIns|BinOp|Load|Store|Branch)
      
   defn #size-suffix () :
      val t = #type()
      switch {t == _} :
         BYTE-TYPE : "b"
         INT-TYPE : "l"
         LONG-TYPE : "q"

   ;====== Immediate Names ======
   defn #imm (t:AsmType, x:Imm) :
      match(x) :
         (x:IntImm) :
            "$~" << [value(x)]
         (x:Reg) :
            switch {t == _} :
               BYTE-TYPE : REG-BYTE-NAMES[n(x)]
               INT-TYPE : REG-INT-NAMES[n(x)]
               LONG-TYPE : REG-LONG-NAMES[n(x)]
         (x:RegSP) :
            "%rsp"            
      
   defn #imm (x:Imm) :
      #imm(#type(), x)        

   ;====== Set Instruction ======
   defn #set (x:Loc, y:Imm) :
      pr("   mov~ ~, ~" << [#size-suffix(), #imm(y), #imm(x)])

   ;====== Binary Operators ======
   defn div-op? (x:AsmOp) : contains?(DIV-OPS, x)
   defn cmp-op? (x:AsmOp) : contains?(CMP-OPS, x)
   defn com-op? (x:AsmOp) : contains?(COM-OPS, x)
   defn ncom-op? (x:AsmOp) : contains?(NCOM-OPS, x)
   defn shf-op? (x:AsmOp) : contains?(SHF-OPS, x)

   defn #div (x:Loc, y:Imm, op:AsmOp, z:Imm) :
      if #type() != BYTE-TYPE :
         error("Binary div operator not supported for non-byte type.")
      if x != Reg(0) :
         error("Binary div operator must have R0 as return register.")
      if z == Reg(0) :
         error("Binary div operator cannot have R0 as return register.")
      if z not-typeof Reg :
         error("Binary div operator must have a register as second operand.")
      pr("   movzbw ~, %ax" << [#imm(y)])
      pr("   idivb ~" << [#imm(z)])
      pr("   shrw $8, %ax") when op == MOD-OP

   defn #cmp-comm (op:AsmOp) :
      switch {op == _} :
         EQ-OP : "e"
         NE-OP : "ne"
         LT-OP : "l"
         GT-OP : "g"
         LE-OP : "le"
         GE-OP : "ge"
         ULE-OP : "be"
         ULT-OP : "b"
         UGT-OP : "a"
         UGE-OP : "ae"   

   defn invert (op:AsmOp) :
      switch {op == _} :
         EQ-OP : NE-OP
         NE-OP : EQ-OP
         LT-OP : GE-OP
         GT-OP : LE-OP
         LE-OP : GT-OP
         GE-OP : LT-OP
         ULE-OP : UGT-OP
         ULT-OP : UGE-OP
         UGT-OP : ULE-OP
         UGE-OP : ULT-OP

   defn #cmp (x:Loc, y:Imm, op:AsmOp, z:Imm) :
      val comm = #cmp-comm(op)
      val sz = #size-suffix()
      match(y, z) :
         (y:Reg, z) :
            pr("   cmp~ ~, ~" << [sz, #imm(z), #imm(y)])
            pr("   movq $0, ~" << [#imm(LONG-TYPE, x)])
            pr("   set~ ~" << [comm, #imm(BYTE-TYPE, x)])
         (y, z:Reg) :
            #cmp(x, z, invert(op), y)
         (y, z) :
            error("Comparison operator requires at least one register operand.")

   defn #br (n:Int, y:Imm, op:AsmOp, z:Imm) :
      val sz = #size-suffix()
      match(y, z) :
         (y:Reg, z) :
            pr("   cmp~ ~, ~" << [sz, #imm(z), #imm(y)])
            pr("   j~ ~" << [comm, #lbl(n)])
         (y, z:Reg) :
            #br(n, z, invert(op), y)
         (y, z) :
            error("Branch requires at least one register operand.")

   defn #com (x:Loc, y:Imm, op:AsmOp, z:Imm) :
      val sz = #size-suffix()
      val comm = switch {op == _} :
         ADD-OP : "add"
         MUL-OP : "imul"
         AND-OP : "and"
         OR-OP : "or"
         XOR-OP : "xor"
      if x == y :
         pr("   ~~ ~, ~" << [comm, sz, #imm(z), #imm(x)])
      else if x == z :
         pr("   ~~ ~, ~" << [comm, sz, #imm(y), #imm(x)])
      else :
         #set(x, y)
         #com(x, x, op, z)

   defn #ncom (x:Loc, y:Imm, op:AsmOp, z:Imm) :
      val sz = #size-suffix()
      val comm = switch {op == _} :
         SUB-OP : "sub"
      if x == z :
         error("Non-commutative binary operator cannot have return register be identical to second operand.")
      if x == y :
         pr("   ~~ ~, ~" << [comm, sz, #imm(z), #imm(x)])
      else :
         #set(x, y)
         #ncom(x, x, op, z)

   defn #shf (x:Loc, y:Imm, op:AsmOp, z:Imm) :
      val sz = #size-suffix()
      val comm = switch {op == _} :
         SHL-OP : "shl"
         SHR-OP : "shr"
         ASHR-OP : "sar"         
      if (z typeof Reg) and z != Reg(2) :
         error("Shift operator must have R2 has second operand.")
      if x == y :
         pr("   ~~ ~, ~" << [comm, sz, #imm(BYTE-TYPE, z), #imm(x)])
      else :
         #set(x, y)
         #shf(x, x, op, z)         
   
   ;====== Driver ======
   match(ins) :
      (ins:SetIns) : #set(x(ins), y(ins))
      (ins:BinOp) :
         switch _{op(ins)} :
            div-op? : #div(x(ins), y(ins), op(ins), z(ins))
            cmp-op? : #cmp(x(ins), y(ins), op(ins), z(ins))
            com-op? : #com(x(ins), y(ins), op(ins), z(ins))
            ncom-op? : #ncom(x(ins), y(ins), op(ins), z(ins))
            shf-op? : #shf(x(ins), y(ins), op(ins), z(ins))
      (ins:Load) :
         val sz = #size-suffix()
         val xloc = #imm(x(ins))
         val o = offset(ins)
         match(y(ins)) :
            (y:Reg) : pr("   mov~ ~(~), ~" << [sz, o, #imm(LONG-TYPE, y), xloc])
            (y:RegSP) : pr("   mov~ ~(%rsp), ~" << [sz, o, xloc])
            (y:Mem) : pr("   mov~ (~ + ~)(%rip), ~" << [sz, #lbl(n(y)), o, xloc])
            (y:ExMem) : pr("   mov~ (~ + ~)(%rip), ~" << [sz, name(y), o, xloc])
      (ins:Store) :
         val sz = #size-suffix()
         val yimm = #imm(y(ins))
         val o = offset(ins)
         match(x(ins)) :
            (x:Reg) : pr("   mov~ ~, ~(~)" << [sz, yimm, o, #imm(LONG-TYPE, x)])
            (x:RegSP) : pr("   mov~ ~, ~(%rsp)" << [sz, yimm, o])
      (ins:Label) : pr("~:" << [#lbl(n(ins))])
      (ins:ExLabel) :
         pr("   .globl ~" << [name(ins)])
         pr("~:" << [name(ins)])
      (ins:Goto) : pr("   jmp ~" << [#lbl(n(ins))])
      (ins:Jump) : pr("   jmp *~" << [#imm(LONG-TYPE, x(ins))])
      (ins:Branch) : #br(n(ins), y(ins), op(ins), z(ins))
      (ins:Call) : pr("   call ~" << [#lbl(n(ins))])
      (ins:CallI) : pr("   call *~" << [#imm(LONG-TYPE, x(ins))])
      (ins:Addr) :
         val xloc = #imm(LONG-TYPE, x(ins))
         val o = offset(ins)
         match(y(ins)) :
            (y:Reg) : pr("   leaq ~(~), ~" << [o, #imm(LONG-TYPE, y), xloc])
            (y:RegSP) : pr("   leaq ~(%rsp), ~" << [o, xloc])
            (y:Mem) : pr("   leaq (~ + ~)(%rip), ~" << [#lbl(n(y)), o, xloc])
            (y:ExMem) : pr("   leaq (~ + ~)(%rip), ~" << [name(y), o, xloc])
      (ins:DefLong) : pr("   .quad ~" << [value(ins)])
      (ins:DefString) : pr("   .byte ~@" << [cms(chars(value(ins)))])
      (ins:DefSpace) : pr("   .space ~" << [size(ins)])
      (ins:DefLabel) : pr("   .quad ~" << [#lbl(n(ins))])
      (ins:DefData) : pr("   .data")
      (ins:DefText) : pr("   .text")

;====== Driver ======

defn main () :
   val filename = commandline-arguments()[1]
   println("Reading assembly file: ~" << [filename])
   val ins = parse-asm-ir(filename)
   do(gen, ins)

main()