defpackage stz/el-ir :
  import core
  import collections
  import stz/utils
  import stz/dl-ir
  import stz/basic-ops

;============================================================
;========================= Types ============================
;============================================================

public deftype EType <: Hashable & Equalable & Comparable<EType>

;LoStanza Types
public defstruct EByte <: EType
public defstruct EInt <: EType
public defstruct ELong <: EType
public defstruct EFloat <: EType
public defstruct EDouble <: EType
public defstruct EUnknown <: EType
public defstruct EPtrT <: EType
public defstruct EFnT <: EType : (a:Tuple<EType>, r:False|EType, b:EType)
public defstruct EStructT <: EType : (n:Int)

;HiStanza Types
public defstruct EOf <: EType: (n:Int)
public defstruct ETVar <: EType: (n:Int)
public defstruct EAnd <: EType: (a:EType, b:EType)
public defstruct EOr <: EType: (a:EType, b:EType)
public defstruct ETop <: EType
public defstruct EBot <: EType

;============================================================
;======================= Wrapper ============================
;============================================================

public defstruct EPackage :
  packageio: PackageIO with: (updater => sub-packageio)
  exps: Tuple<ETExp> with: (updater => sub-exps)

public defn name (e:EPackage) :
  package(packageio(e))

;============================================================
;================== Top-Level Expressions ===================
;============================================================

public deftype ETExp
public defstruct EDefGlobal <: ETExp :
  n: Int with: (updater => sub-n)
  type: EType
  mutable?: True|False
  lostanza?: True|False
  
public defstruct EDefn <: ETExp :
  n: Int with: (updater => sub-n)
  func: EFunction with: (updater => sub-func)
  lostanza?: True|False

public defstruct EDefClosure <: ETExp :
  n: Int with: (updater => sub-n)
  closure: Int with: (updater => sub-closure)
  ntargs: Int with: (updater => sub-ntargs)
  nargs: Int
  func: EFunction with: (updater => sub-func)

public defstruct EDefmulti <: ETExp :
  n: Int with: (updater => sub-n)
  targs: Tuple<Int> with: (updater => sub-targs)
  a1: Tuple<EType>
  a2: EType
  info: False|FileInfo

public defstruct EDefmethod <: ETExp :
  n: Int with: (updater => sub-n)
  multi: Int with: (updater => sub-multi)
  targs: Tuple<EType>
  func: EFn with: (updater => sub-func)
  lostanza?: True|False

public defstruct EDefStruct <: ETExp :
  n: Int with: (updater => sub-n)
  parent: False|EType
  base:Tuple<EType>
  items:EType|False

public defstruct EExternFn <: ETExp :
  n: Int with: (updater => sub-n)
  lbl: Symbol
  func: EFn with: (updater => sub-func)

public defstruct EExtern <: ETExp :
  n: Int with: (updater => sub-n)
  lbl: Symbol
  type: EType
  
public defstruct EInit <: ETExp :
  body: EBody with: (updater => sub-body)
  lostanza?: True|False

public defstruct EDefType <: ETExp :
  n: Int with: (updater => sub-n)
  parent: False|EType
  children: Tuple<Int> with: (updater => sub-children)

public defstruct EDefObject <: ETExp :
  n: Int with: (updater => sub-n)
  parent: EType 
  ntargs: Int with: (updater => sub-ntargs)
  nargs: Int
  methods: Tuple<Int> with: (updater => sub-n)

public defstruct EDefTypeObject <: ETExp :
  n: Int with: (updater => sub-n)
  nargs: Int
  type: EType

;============================================================
;======================== Functions =========================
;============================================================

public deftype EFunction

public defstruct EMultifn <: EFunction :
  funcs: Tuple<EFn>

public defstruct EFn <: EFunction :
  tail?: True|False
  targs: Tuple<Int> with: (updater => sub-targs)
  args: Tuple<Int> with: (updater => sub-args)
  a1: Tuple<EType>
  a2: EType with: (updater => sub-a2)
  body: EBody with: (updater => sub-body)
  info: False|FileInfo
  free?: Free|False with: (default => false, updater => sub-free)  

public defn free (e:EFn) :
  match(free?(e)) :
    (f:Free) : f
    (f:False) : fatal("Field EFn/free is uninitialized.")

public defstruct ELocal :
  n: Int with: (updater => sub-n)
  type: EType
  mutable?: True|False

public defstruct ELocalType :
  n: Int with: (updater => sub-n)

public defstruct ELocalFn :
  n: Int with: (updater => sub-n)
  func: EFunction with: (updater => sub-func)

public defstruct ELocalObj :
  n: Int with: (updater => sub-n)
  type: EType
  methods: Tuple<EMethod> with: (updater => sub-methods)
public defstruct EMethod :
  multi: Int with: (updater => sub-multi)
  targs: Tuple<EType> with: (updater => sub-targs)
  thisn: Int with: (updater => sub-thisn)
  func: EFn with: (updater => sub-func)

public defstruct EBody :
  locals: Tuple<ELocal> with: (updater => sub-locals)
  localtypes: Tuple<ELocalType> with: (updater => sub-localtypes)
  localfns: Tuple<ELocalFn> with: (updater => sub-localfns)
  localobjs: Tuple<ELocalObj> with: (updater => sub-localobjs)
  ins: Tuple<EIns> with: (updater => sub-ins)

public defstruct Free :
  vars: Tuple<Int>
  tvars: Tuple<Int>
with:
  printer => true

public defn empty? (f:Free) :
  empty?(vars(f)) and empty?(tvars(f))

;============================================================  
;======================= Instructions =======================
;============================================================  

public deftype EImm
public defstruct ELSLiteral <: EImm :
  value
public defstruct ELiteral <: EImm :
  value
public defstruct EVar <: EImm :
  n: Int with: (updater => sub-n)
  info: False|FileInfo with: (default => false)
  name: False|String with: (default => false)
public defstruct EMix <: EImm :
  funcs: Tuple<EVar|ECurry>
public defstruct ECurry <: EImm :
  x: EVar
  targs: Tuple<EType>
public defstruct ESizeof <: EImm :
  type: EType
public defstruct ETagof <: EImm :
  n: Int with: (updater => sub-n)
public defstruct EConstClosure <: EImm :
  n: Int with: (updater => sub-n)
public defstruct EConstType <: EImm :
  n: Int with: (updater => sub-n)

public deftype ELoc
public defstruct EVarLoc <: ELoc :
  n: Int with: (updater => sub-n)
public defstruct EDeref <: ELoc :
  y: EImm
public defstruct EDeptr <: ELoc :
  y: EImm
public defstruct EField <: ELoc :
  loc: ELoc
  n: Int with: (updater => sub-n)
  index: Int
public defstruct ESlot <: ELoc :
  loc: ELoc
  type: EType  ;type of result
  index: EImm
  
public defstruct ETVarLoc :
  n: Int with: (updater => sub-n)

public deftype EIns
public defstruct EDef <: EIns :
  x: EVarLoc
  y: EImm|False
  info: FileInfo|False with: (default => false)
public defstruct EInitClosures <: EIns :
  xs: Tuple<EVarLoc>
  info: FileInfo|False
public defstruct ENew <: EIns :
  x: EVarLoc
  n: Int with: (updater => sub-n)
  info: FileInfo|False
public defstruct ETuple <: EIns :
  x: EVarLoc
  ys: Tuple<EImm>
  info: FileInfo|False
public defstruct EVoidTuple <: EIns :
  x: EVarLoc
  length: Int
  info: FileInfo|False
public defstruct ETupleGet <: EIns :
  x: EVarLoc
  y: EImm
  index: Int
  info: FileInfo|False
public defstruct ETupleSet <: EIns :
  y: EImm
  index: Int
  z: EImm
public defstruct EObject <: EIns :
  x: EVarLoc
  n: Int with: (updater => sub-n)
  ys: Tuple<EImm>
  info: FileInfo|False
public defstruct EArray <: EIns :
  x: EVarLoc
  n: Int with: (updater => sub-n)
  ys: Tuple<EImm>
  info: FileInfo|False
public defstruct EStruct <: EIns :
  x: EVarLoc
  n: Int with: (updater => sub-n)
  ys: Tuple<EImm>
public defstruct EPtr <: EIns :
  x: EVarLoc
  loc: ELoc
public defstruct ELoad <: EIns :
  x: EVarLoc
  xtype: EType with: (updater => sub-xtype)
  loc: ELoc
public defstruct EStore <: EIns :
  loc: ELoc
  y: EImm
  ytype: EType with: (default => ETop(), updater => sub-ytype)
  info: FileInfo|False
public defstruct ELabel <: EIns :
  n: Int with: (updater => sub-n)
public defstruct ETCall <: EIns :
  f: EImm with: (updater => sub-f)
  ys: Tuple<EImm> with: (updater => sub-ys)
  calltype: CallType with: (updater => sub-calltype)
  info: FileInfo|False
public defstruct ECall <: EIns :
  x: EVarLoc|False
  f: EImm with: (updater => sub-f)
  ys: Tuple<EImm> with: (updater => sub-ys)
  calltype: CallType with: (updater => sub-calltype)
  info: FileInfo|False
public defstruct EDump <: EIns :
  ys: Tuple<EImm>
public defstruct EInterpret <: EIns :
  x: EVarLoc
  y: EImm
public defstruct EConv <: EIns :
  x: EVarLoc
  y: EImm
public defstruct EGoto <: EIns :
  n: Int with: (updater => sub-n)
public defstruct EPrim <: EIns :
  x: EVarLoc
  op: EOp
  ys: Tuple<EImm>
  info: FileInfo|False
public defstruct EIf <: EIns :
  n1: Int with: (updater => sub-n1)
  n2: Int with: (updater => sub-n2)
  op: EOp|False
  ys: Tuple<EImm>
public defstruct EMatch <: EIns :
  ys: Tuple<EImm>
  branches: Tuple<EBranch> with: (updater => sub-branches)
  covered?: True|False with: (updater => sub-covered?, default => false)
  info: FileInfo|False
public defstruct EDispatch <: EIns :
  ys: Tuple<EImm>
  branches: Tuple<EBranch> with: (updater => sub-branches)
  info: FileInfo|False
public defstruct ECheckLength <: EIns :
  y: EImm
  length: Int
  info: FileInfo|False
public defstruct ECheck <: EIns :
  y: EImm
  type: EType
  ctxt: CastErrorContext
  info: FileInfo|False  
public defstruct ECheckSet <: EIns :
  y: EImm
  name: String|False
  info: FileInfo|False
public defstruct EBox <: EIns :
  x: EVarLoc
  y: EImm|False
public defstruct EBoxGet <: EIns :
  x: EVarLoc
  y: EImm
public defstruct EBoxSet <: EIns :
  y: EImm
  z: EImm  
public defstruct EReturn <: EIns :
  y: EImm
public defstruct ENewObject <: EIns :
  x: EVarLoc
  n: Int with: (updater => sub-n)
  targs: Tuple<EType> with: (updater => sub-targs)
  ys: Tuple<EImm>
  info: FileInfo|False
public defstruct EObjectGet <: EIns :
  x: EVarLoc
  y: EImm
  n: Int with: (updater => sub-n)
  index: Int
public defstruct EObjectTGet <: EIns :
  x: ETVarLoc
  y: EImm
  n: Int with: (updater => sub-n)
  index: Int
public defstruct EClosureGet <: EIns :
  x: EVarLoc
  y: EImm
  n: Int with: (updater => sub-n)
  index: Int
public defstruct EClosureTGet <: EIns :
  x: ETVarLoc
  y: EImm
  n: Int with: (updater => sub-n)
  index: Int
public defstruct ETDef <: EIns :
  x: ETVarLoc
  y: EImm
public defstruct ELetRec <: EIns :
  xs: Tuple<EVarLoc>
  ys: Tuple<EClosure> with: (updater => sub-ys)
  info: FileInfo|False
public defstruct ETypeObject <: EIns :
  x: ETVarLoc
  n: Int with: (updater => sub-n)
  targs: Tuple<EType>
public defstruct EEnd <: EIns :
  info: FileInfo|False
public defstruct ELive <: EIns :
  xs: Tuple<EImm>
public defstruct ETypeof <: EIns :
  n1: Int with: (updater => sub-n1)
  n2: Int with: (updater => sub-n2)
  type:EType
  y: EImm
public defstruct ECheckFail <: EIns :
  type:EType
  y: EImm
  ctxt: CastErrorContext
  info: FileInfo|False

public defstruct EBranch :
  types: Tuple<EType> with: (updater => sub-types)
  n: Int with: (updater => sub-n)
  info: FileInfo|False

public defstruct EClosure :
  n: Int with: (updater => sub-n)
  targs: Tuple<EType> with: (updater => sub-targs)
  ys: Tuple<EImm>

public deftype CallType
public defstruct CallGuarded <: CallType : (a1:Tuple<EType>, a2:EType)
public defstruct CallC <: CallType
public defstruct CallStanza <: CallType
public defstruct CallPtr <: CallType

public deftype CastErrorContext
public defstruct CastContext <: CastErrorContext
public defstruct ArgContext <: CastErrorContext
public defstruct ReturnContext <: CastErrorContext
public defstruct DefContext <: CastErrorContext
public defstruct SetContext <: CastErrorContext
public defstruct FuncContext <: CastErrorContext
public defstruct DetupleContext <: CastErrorContext
public defstruct GetVarContext <: CastErrorContext
public defstruct BranchContext <: CastErrorContext

;============================================================
;======================= Primitives =========================
;============================================================

public deftype EOp :
  BasicOp <: EOp
public defstruct EnterStackOp <: EOp
public defstruct YieldOp <: EOp

;============================================================
;========================= Printer ==========================
;============================================================

defmethod print (o:OutputStream, op:EOp) :
  print{o, _} $ match(op) :
    (op:EnterStackOp) : "enter-stack"
    (op:YieldOp) : "yield"

defmethod print (o:OutputStream, t:EType) :
  print{o, _} $ match(t) :
    (t:EByte) : "byte"
    (t:EInt) : "int"
    (t:ELong) : "long"
    (t:EFloat) : "float"
    (t:EDouble) : "double"
    (t:EUnknown) : "?"
    (t:ETop) : "top"
    (t:EBot) : "bot"
    (t:EPtrT) : "ptr"
    (t:EFnT) :
      match(r(t)) :
        (r:EType) : "fn<(%,), %_, %_>" % [a(t), r, b(t)]
        (r:False) : "fn<(%,), %_>" % [a(t), b(t)]
    (t:EStructT) : "T%_" % [n(t)]      
    (t:EOf) : "ref<T%_>" % [n(t)]
    (t:ETVar) : "TV%_" % [n(t)]
    (t:EAnd) : "and(%_, %_)" % [a(t), b(t)]
    (t:EOr) : "or(%_, %_)" % [a(t), b(t)]
    
defmethod print (o:OutputStream, e:EDefGlobal) :
  val valstr = "var" when mutable?(e) else "val"
  val ls-str = " lostanza" when lostanza?(e) else ""
  print(o, "def%_%_ V%_:%_" % [valstr, ls-str, n(e), type(e)])

defmethod print (o:OutputStream, e:EDefn) :
  val ls-str = " lostanza" when lostanza?(e) else ""
  print(o, "defn%_ V%_ %_" % [ls-str, n(e), func(e)])

defmethod print (o:OutputStream, e:EDefClosure) :
  print(o, "defclosure V%_ (closure = V%_, ntargs = %_, nargs = %_) %_" % [
    n(e), closure(e), ntargs(e), nargs(e), func(e)])

defmethod print (o:OutputStream, e:EDefmulti) :
  print(o, "defmulti V%_<%,> (%,) -> %_" % [n(e), seq(ETVar,targs(e)), a1(e), a2(e)])

defmethod print (o:OutputStream, e:EDefmethod) :
  val ls-str = " lostanza" when lostanza?(e) else ""
  print(o, "defmethod%_ V%_<%,> (id = V%_) %_" % [
    ls-str, multi(e), targs(e), n(e), func(e)])

defmethod print (o:OutputStream, e:EDefStruct) :
  val pstr = "" when parent(e) is False else " <: %_" % [parent(e)]
  match(items(e)) :
    (items:EType) :
      print(o, "defstruct T%_%_ : (%, ...)" % [n(e), pstr, cat(base(e), [items])])
    (items:False) :
      print(o, "defstruct T%_%_ : (%,)" % [n(e), pstr, base(e)])

defmethod print (o:OutputStream, e:EExternFn) :
  print(o, "externfn %~ V%_ %_" % [lbl(e), n(e), func(e)])

defmethod print (o:OutputStream, e:EExtern) :
  print(o, "extern %~ V%_:%_" % [lbl(e), n(e), type(e)])

defmethod print (o:OutputStream, e:EInit) :
  val ls-str = " lostanza" when lostanza?(e) else ""
  print(o, "init%_ :%_" % [ls-str, body(e)])

defmethod print (o:OutputStream, e:EDefType) :
  val pstr = "" when parent(e) is False
        else " <: %_" % [parent(e)]
  defn tstr (x:Int) : "T%_" % [x]
  print(o, "deftype T%_%_ (%,)" % [n(e), pstr, seq(tstr,children(e))])

defmethod print (o:OutputStream, e:EDefObject) :
  print(o, "defobject T%_ <: %_ (ntargs = %_, nargs = %_, methods = %_)" % [
    n(e), parent(e), ntargs(e), nargs(e), methods(e)])

defmethod print (o:OutputStream, e:EDefTypeObject) :
  print(o, "deftypeobj T%_<%_> = %_" % [n(e), nargs(e), type(e)])

defmethod print (o:OutputStream, f:EFn) :
  val tagstr = "fn*" when tail?(f) else "fn"
  defn astr (x:Int,t:EType) : "V%_:%_" % [x,t]  
  print(o, "%_<%,> (%,) -> %_ :%_" % [tagstr, seq(ETVar,targs(f)), seq(astr, args(f), a1(f)), a2(f), body(f)])

defmethod print (o:OutputStream, b:EBody) :
  bprint(o, cat-all $ [locals(b), localfns(b), localobjs(b), ins(b)])

defmethod print (o:OutputStream, f:EMultifn) :
  print(o, "multifn :")
  bprint(o, funcs(f))

defmethod print (o:OutputStream, l:ELocal) :
  val varstr = "var" when mutable?(l) else "val"
  print(o, "def%_ V%_:%_" % [varstr, n(l), type(l)])

defmethod print (o:OutputStream, l:ELocalType) :
  print(o, "type T%_" % [n(l)])

defmethod print (o:OutputStream, e:ELocalFn) :
  print(o, "defn V%_ %_" % [n(e), func(e)])

defmethod print (o:OutputStream, e:ELocalObj) :
  print(o, "defobj O%_ <: %_ :" % [n(e), type(e)])
  bprint(o, methods(e))

defmethod print (o:OutputStream, e:EMethod) :
  print(o, "defmethod V%_<%,> (this = V%_) %_" % [multi(e), targs(e), thisn(e), func(e)])

defmethod print (o:OutputStream, e:EImm) :
  print{o, _} $ match(e) :
    (e:EVar) : "V%_" % [n(e)]
    (e:ECurry) : "%_<%,>" % [x(e), targs(e)]
    (e:ELSLiteral) : "LV{%~}" % [value(e)]
    (e:ELiteral) : "V{%~}" % [value(e)]
    (e:EMix) : "mix(%,)" % [funcs(e)]
    (e:ESizeof) : "sizeof(%_)" % [type(e)]
    (e:ETagof) : "tagof(T%_)" % [n(e)]
    (e:EConstClosure) : "const-closure(V%_)" % [n(e)]
    (e:EConstType) : "const-type(T%_)" % [n(e)]

defmethod print (o:OutputStream, e:EIns) :
  defn P (x) : print(o, x)
  match(e) : 
    (e:EDef) :
      match(y(e)) :
        (y:EImm) : P $ "%_ = %_" % [x(e), y]
        (y:False) : P $ "def %_" % [x(e)]
    (e:ETDef) : P $ "tdef %_ = %_" % [x(e), y(e)]
    (e:EInitClosures) : P $ "init-closures (%,)" % [xs(e)]
    (e:ENew) : P $ "%_ = new O%_" % [x(e), n(e)]
    (e:ETuple) : P $ "%_ = tuple [%,]" % [x(e), ys(e)]
    (e:EVoidTuple) : P $ "%_ = void-tuple(%_)" % [x(e), length(e)]
    (e:ETupleGet) : P $ "%_ = tuple-get %_[%_]" % [x(e), y(e), index(e)]
    (e:ETupleSet) : P $ "tuple-set %_[%_] = %_" % [y(e),index(e), z(e)]
    (e:ECheckLength) : P $ "check-length(%_) == %_" % [y(e), length(e)]
    (e:EObject) : P $ "%_ = object T%_ (%,)" % [x(e), n(e), ys(e)]
    (e:EArray) : P $ "%_ = array T%_ (%,)" % [x(e), n(e), ys(e)]
    (e:EStruct) : P $ "%_ = struct T%_ (%,)" % [x(e), n(e), ys(e)]
    (e:EPtr) : P $ "%_ = addr(%_)" % [x(e), loc(e)]
    (e:ELoad) : P $ "%_:%_ = load %_" % [x(e), xtype(e), loc(e)]
    (e:EStore) :
      match(ytype(e)) :
        (t:ETop) : P $ "store %_ = %_" % [loc(e), y(e)]
        (t:EType) : P $ "store %_ = %_:%_" % [loc(e), y(e), t]
    (e:ELabel) : P $ "label L%_" % [n(e)]
    (e:ECall) :
      val xstr = "" when x(e) is False
            else "%_ = " % [x(e)]
      P $ "%_call %_ %_(%,)" % [xstr, calltype(e), f(e), ys(e)]
    (e:ETCall) :
      P $ "tcall %_ %_(%,)" % [calltype(e), f(e), ys(e)]
    (e:EInterpret) : P $ "%_ = interpret %_" % [x(e), y(e)]
    (e:EConv) : P $ "%_ = conv %_" % [x(e), y(e)]
    (e:ECheck) : P $ "check(%_) %_ : %_" % [ctxt(e), y(e), type(e)]
    (e:EGoto) : P $ "goto L%_" % [n(e)]
    (e:EPrim) : P $ "%_ = prim %_(%,)" % [x(e), op(e), ys(e)]
    (e:EIf) :
      P $ match(op(e)) :
        (op:EOp) : "goto L%_ when prim %_(%,) else L%_" % [n1(e), op, ys(e), n2(e)]
        (op:False) : "goto L%_ when %_ else L%_" % [n1(e), ys(e)[0], n2(e)]
    (e:EMatch) :
      P $ "match(%,) :" % [ys(e)]
      bprint(o, branches(e))
    (e:EDispatch) :
      P $ "dispatch(%,) :" % [ys(e)]
      bprint(o, branches(e))
    (e:ECheckSet) : P $ "check-set(%~) %_" % [name(e), y(e)]
    (e:EBox) :
      P $ "%_ = box(%_)" % [x(e), vstr] where :
        val vstr = "" when y(e) is False else y(e)
    (e:EBoxGet) : P $ "%_ = box-get %_" % [x(e), y(e)]
    (e:EBoxSet) : P $ "box-set %_ = %_" % [y(e), z(e)]        
    (e:EReturn) : P $ "return %_" % [y(e)]
    (e:ENewObject) : P $ "%_ = new-object T%_<%,> (%,)" % [x(e), n(e), targs(e), ys(e)]
    (e:EObjectGet) : P $ "%_ = object-get<%_> %_[%_]" % [x(e), n(e), y(e), index(e)]
    (e:EObjectTGet) : P $ "%_ = object-tget<%_> %_[%_]" % [x(e), n(e), y(e), index(e)]
    (e:EClosureGet) : P $ "%_ = closure-get<%_> %_[%_]" % [x(e), n(e), y(e), index(e)]
    (e:EClosureTGet) : P $ "%_ = closure-tget<%_> %_[%_]" % [x(e), n(e), y(e), index(e)]
    (e:ELetRec) : P $ "letrec (%,) = (%,)" % [xs(e), ys(e)]
    (e:EDump) :  P $ "dump (%,)" % [ys(e)]
    (e:ETypeObject) : P $ "%_ = type-object T%_<%,>" % [x(e), n(e), targs(e)]
    (e:EEnd) : P $ "end"
    (e:ELive) : P $ "live(%,)" % [xs(e)]
    (e:ETypeof) : P $ "goto L%_ when typeof(%_, %_) else L%_" % [n1(e), y(e), type(e), n2(e)]
    (e:ECheckFail) : P $ "check-fail(%_) %_ : %_" % [ctxt(e), y(e), type(e)]

defmethod print (o:OutputStream, t:CallType) :
  print{o, _} $ match(t) :
    (t:CallGuarded) : "guarded((%,) -> %_)" % [a1(t), a2(t)]
    (t:CallC) : "c"
    (t:CallStanza) : "stanza"
    (t:CallPtr) : "ptr"

defmethod print (o:OutputStream, c:CastErrorContext) :
  print{o, _} $ match(c) :
    (c:CastContext) : "cast"
    (c:ArgContext) : "arg"
    (c:ReturnContext) : "return"
    (c:DefContext) : "def"
    (c:SetContext) : "set"
    (c:DetupleContext) : "detuple"
    (c:GetVarContext) : "get-var"
    (c:FuncContext) : "func"
    (c:BranchContext) : "branch"

defmethod print (o:OutputStream, e:EClosure) :
  print(o, "closure V%_<%,>(%,)" % [n(e), targs(e), ys(e)])

defmethod print (o:OutputStream, e:EBranch) :
  print(o, "(%,) : goto L%_" % [types(e), n(e)])

defmethod print (o:OutputStream, p:EPackage) :  
  print(o, "package %~ :" % [name(p)])
  val io = packageio(p)
  bprint(o, cat-all $ [imports(io), exports(io), exps(p)])

defmethod print (o:OutputStream, e:ELoc) :
  print{o, _} $ match(e) :
    (e:EVarLoc) : "V%_" % [n(e)]
    (e:EDeref) : "deref(%_)" % [y(e)]
    (e:EDeptr) : "deptr(%_)" % [y(e)]
    (e:EField) : "field(%_, T%_[%_])" % [loc(e), n(e), index(e)]
    (e:ESlot) : "slot(%_[%_] : %_)" % [loc(e), index(e), type(e)]    

defmethod print (o:OutputStream, t:ETVarLoc) :
  print(o, "TV%_" % [n(t)])

defn bprint (o:OutputStream, xs:Seqable) :
  val xs-seq = to-seq(xs)
  if empty?(xs-seq) : print(o, " ()")
  else : lnprints(IndentedStream(o), xs-seq)

;============================================================
;========================= Reader ===========================
;============================================================

defsyntax el-ir :
  defn prefix-id? (x, s:String) :
    match(unwrap-token(x)) :
      (x:Symbol) : prefix?(x, s)
      (x) : false
  defn id-prefix (info:FileInfo|False, x:Symbol|Token, len:Int) :
    match(to-int(to-string(unwrap-token(x))[len to false])) :
      (i:Int) : i
      (i) : throw(ELE(info, "Invalid name: %~" % [x]))

  import (import export) from dl-ir
  import (basic-op) from basic-ops

  defproduction tvid : Int
  defrule tvid = (?x) when prefix-id?(x,"TV") : id-prefix(closest-info(), x, 2)
  defproduction tid : Int
  defrule tid = (?x) when prefix-id?(x,"T") : id-prefix(closest-info(), x, 1)
  defproduction vid : Int
  defrule vid = (?x) when prefix-id?(x,"V") : id-prefix(closest-info(), x, 1)
  defproduction oid : Int
  defrule oid = (?x) when prefix-id?(x,"O") : id-prefix(closest-info(), x, 1)
  defproduction lid : Int
  defrule lid = (?x) when prefix-id?(x,"L") : id-prefix(closest-info(), x, 1)  

  defproduction eop : EOp
  defrule eop = (?x:#basic-op) : x
  defrule eop = (enter-stack) : EnterStackOp()
  defrule eop = (yield) : YieldOp()

  defproduction etype : EType
  defrule etype = (byte) : EByte()
  defrule etype = (int) : EInt()
  defrule etype = (long) : ELong()
  defrule etype = (float) : EFloat()
  defrule etype = (double) : EDouble()
  defrule etype = (?) : EUnknown()
  defrule etype = (top) : ETop()
  defrule etype = (bot) : EBot()
  defrule etype = (ptr) : EPtrT()
  defrule etype = (fn<(?a:#etype ...), ?r:#etype, ?b:#etype>) : EFnT(to-tuple(a), r, b)
  defrule etype = (fn<(?a:#etype ...), ?b:#etype>) : EFnT(to-tuple(a), false, b)
  defrule etype = (?n:#tvid) : ETVar(n)
  defrule etype = (?n:#tid) : EStructT(n)
  defrule etype = (ref<?n:#tid>) : EOf(n)
  defrule etype = (and(?a:#etype,?b:#etype)) : EAnd(a,b)
  defrule etype = (or(?a:#etype,?b:#etype)) : EOr(a,b)

  defproduction lostanza? : True|False
  defrule lostanza? = (lostanza) : true
  defrule lostanza? = () : false

  defproduction etexp : ETExp
  defrule etexp = (defval ?ls:#lostanza? ?n:#vid : ?t:#etype) : EDefGlobal(n, t, false, ls)
  defrule etexp = (defvar ?ls:#lostanza? ?n:#vid : ?t:#etype) : EDefGlobal(n, t, true, ls)
  defrule etexp = (defn ?ls:#lostanza? ?n:#vid ?f:#efunc) : EDefn(n, f, ls)
  defrule etexp = (defclosure ?n:#vid
                              (closure = ?c:#vid, ntargs = ?ntargs:#int, nargs = ?nargs:#int)
                              ?f:#efunc) :
    EDefClosure(n, c, ntargs, nargs, f)
  defrule etexp = (defmulti ?n:#vid<?targs:#tvid ...> (?a1:#etype ...) -> ?a2:#etype) :
    EDefmulti(n, to-tuple(targs), to-tuple(a1), a2, closest-info())
  defrule etexp = (defmethod ?ls:#lostanza? ?multi:#vid<?targs:#etype ...> (id = ?n:#vid) ?f:#efn) :
    EDefmethod(n, multi, to-tuple(targs), f, ls)
  defrule etexp = (defstruct ?n:#tid ?p:#parent? : (?ts:#etype ... ~ ...)) :
    EDefStruct(n, p to-tuple(but-last(ts)), last(ts))
  defrule etexp = (defstruct ?n:#tid ?p:#parent? : (?ts:#etype ...)) :
    EDefStruct(n, p, to-tuple(ts), false)
  defrule etexp = (externfn ?lbl:#symbol ?n:#vid ?f:#efn) : EExternFn(n, lbl, f)
  defrule etexp = (extern ?lbl:#symbol ?n:#vid : ?t:#etype) : EExtern(n, lbl, t)
  defrule etexp = (init ?ls:#lostanza? : ?b:#ebody) :
    EInit(b, ls)
  defrule etexp = (deftype ?n:#tid ?p:#parent? (?cs:#tid ...)) : EDefType(n, p, to-tuple(cs))
  defrule etexp = (defobject ?n:#tid <: ?p:#etype
                             (ntargs = ?ntargs:#int, nargs = ?nargs:#int, methods = (?ms:#int ...))) :
    EDefObject(n, p, ntargs, nargs, to-tuple(ms))
  defrule etexp = (deftypeobj ?n:#tid<?nargs:#int> = ?t:#etype) :
    EDefTypeObject(n, nargs, t)

  defproduction ebody : EBody
  defrule ebody = ((?locals:#elocal ...
                    ?localtypes:#elocaltype ...
                    ?localfns:#elocalfn ...
                    ?localobjs:#elocalobj ...
                    ?ins:#eins ... #E)) :
    EBody(to-tuple(locals), to-tuple(localtypes), to-tuple(localfns), to-tuple(localobjs), to-tuple(ins))                

  defproduction parent? : False|EType
  defrule parent? = (<: ?t:#etype) : t
  defrule parent? = () : false

  defproduction elocal : ELocal
  defrule elocal = (defvar ?n:#vid : ?t:#etype) : ELocal(n, t, true)
  defrule elocal = (defval ?n:#vid : ?t:#etype) : ELocal(n, t, false)

  defproduction elocaltype : ELocalType
  defrule elocaltype = (type ?n:#tid) : ELocalType(n)

  defproduction elocalfn : ELocalFn
  defrule elocalfn = (defn ?n:#vid ?f:#efunc) : ELocalFn(n, f)

  defproduction elocalobj : ELocalObj
  defrule elocalobj = (defobj ?n:#oid <: ?t:#etype : (?ms:#emethod ... #E)) : ELocalObj(n,t,to-tuple(ms))
  defproduction emethod : EMethod
  defrule emethod = (defmethod ?multi:#vid<?targs:#etype ...> (this = ?thisn:#vid) ?f:#efn) :
    EMethod(multi, to-tuple(targs), thisn, f)

  defproduction efunc : EFunction
  defrule efunc = (?f:#efn) : f
  defrule efunc = (multifn : (?fs:#efn ... #E)) : EMultifn(to-tuple(fs))
  
  defproduction efn : EFn
  defrule efn = (?tail:#fntag<?targs:#tvid ...> ((?args:#vid : ?a1:#etype) @...) -> ?a2:#etype : ?b:#ebody) :
    EFn(tail, to-tuple(targs), to-tuple(args), to-tuple(a1), a2, b, closest-info())

  defproduction fntag : True|False
  defrule fntag = (fn) : false
  defrule fntag = (fn*) : true

  defproduction eins : EIns
  defrule eins = (def ?x:#vloc) : EDef(x, false)
  defrule eins = (tdef ?x:#tvloc = ?y:#eimm) : ETDef(x, y)
  defrule eins = (init-closures (?xs:#vloc ...)) : EInitClosures(to-tuple(xs), closest-info())
  defrule eins = (letrec (?xs:#vloc ...) = (?cs:#eclosure ...)) : ELetRec(to-tuple(xs), to-tuple(cs), closest-info())
  defrule eins = (box-set ?y:#eimm = ?z:#eimm) : EBoxSet(y, z)
  defrule eins = (return ?y:#eimm) : EReturn(y)
  defrule eins = (tuple-set ?y:#eimm[?i:#int] = ?z:#eimm) : ETupleSet(y, i, z)
  defrule eins = (check-length(?y:#eimm) == ?len:#int) : ECheckLength(y, len, closest-info())
  defrule eins = (check(?c:#cast-error-ctxt) ?y:#eimm : ?t:#etype) : ECheck(y,t,c,closest-info())
  defrule eins = (check-fail(?c:#cast-error-ctxt) ?y:#eimm : ?t:#etype) : ECheckFail(t,y,c,closest-info())
  defrule eins = (dump (?ys:#eimm ...)) : EDump(to-tuple(ys))
  defrule eins = (store ?loc:#eloc = ?y:#eimm : ?t:#etype) : EStore(loc, y, t, closest-info())  
  defrule eins = (store ?loc:#eloc = ?y:#eimm) : EStore(loc, y, ETop(), closest-info())  
  defrule eins = (label ?n:#lid) : ELabel(n)
  defrule eins = (call ?t:#calltype ?f:#eimm(?ys:#eimm ...)) : ECall(false, f, to-tuple(ys), t, closest-info())
  defrule eins = (tcall ?t:#calltype ?f:#eimm(?ys:#eimm ...)) : ETCall(f, to-tuple(ys), t, closest-info())
  defrule eins = (goto ?n1:#lid when prim ?op:#eop(?ys:#eimm ...) else ?n2:#lid) : EIf(n1, n2, op, to-tuple(ys))
  defrule eins = (goto ?n1:#lid when typeof(?y:#eimm, ?t:#etype) else ?n2:#lid) : ETypeof(n1, n2, t, y)
  defrule eins = (goto ?n1:#lid when ?y:#eimm else ?n2:#lid) : EIf(n1, n2, false, [y])
  defrule eins = (goto ?n:#lid) : EGoto(n)
  defrule eins = (end) : EEnd(closest-info())
  defrule eins = (live(?ys:#eimm ...)) : ELive(to-tuple(ys))
  defrule eins = (match(?ys:#eimm ...) : (?bs:#ebranch ...)) : EMatch(to-tuple(ys), to-tuple(bs), closest-info())
  defrule eins = (dispatch(?ys:#eimm ...) : (?bs:#ebranch ...)) : EDispatch(to-tuple(ys), to-tuple(bs), closest-info())
  defrule eins = (check-set(?name:#string?) ?y:#eimm) : ECheckSet(y, name, closest-info())  
  defrule eins = (?x:#vloc = interpret ?y:#eimm) : EInterpret(x,y)
  defrule eins = (?x:#vloc = conv ?y:#eimm) : EConv(x,y)
  defrule eins = (?x:#vloc = prim ?op:#eop(?ys:#eimm ...)) : EPrim(x, op, to-tuple(ys), closest-info())
  defrule eins = (?x:#vloc = box()) : EBox(x,false)
  defrule eins = (?x:#vloc = box(?y:#eimm)) : EBox(x,y)
  defrule eins = (?x:#vloc = box-get ?y:#eimm) : EBoxGet(x,y)
  defrule eins = (?x:#vloc = new ?n:#oid) : ENew(x, n, closest-info())
  defrule eins = (?x:#vloc = new-object ?n:#tid<?targs:#etype ...> (?ys:#eimm ...)) : ENewObject(x, n, to-tuple(targs), to-tuple(ys), closest-info())
  defrule eins = (?x:#vloc = object-get<?n:#int> ?y:#eimm[?i:#int]) : EObjectGet(x, y, n, i)
  defrule eins = (?x:#tvloc = object-tget<?n:#int> ?y:#eimm[?i:#int]) : EObjectTGet(x, y, n, i)
  defrule eins = (?x:#vloc = closure-get<?n:#int> ?y:#eimm[?i:#int]) : EClosureGet(x, y, n, i)
  defrule eins = (?x:#tvloc = closure-tget<?n:#int> ?y:#eimm[?i:#int]) : EClosureTGet(x, y, n, i)
  defrule eins = (?x:#tvloc = type-object ?n:#tid<?ts:#etype ...>) : ETypeObject(x, n, to-tuple(ts))
  defrule eins = (?x:#vloc = tuple [?ys:#eimm ...]) : ETuple(x, to-tuple(ys), closest-info())
  defrule eins = (?x:#vloc = void-tuple(?len:#int)) : EVoidTuple(x, len, closest-info())
  defrule eins = (?x:#vloc = tuple-get ?y:#eimm[?i:#int]) : ETupleGet(x, y, i, closest-info())
  defrule eins = (?x:#vloc = object ?n:#tid (?ys:#eimm ...)) : EObject(x, n, to-tuple(ys), closest-info())
  defrule eins = (?x:#vloc = array ?n:#tid (?ys:#eimm ...)) : EArray(x, n, to-tuple(ys), closest-info())
  defrule eins = (?x:#vloc = struct ?n:#tid (?ys:#eimm ...)) : EStruct(x, n, to-tuple(ys))
  defrule eins = (?x:#vloc = addr(?loc:#eloc)) : EPtr(x, loc)  
  defrule eins = (?x:#vloc : ?xt:#etype = load ?loc:#eloc) : ELoad(x, xt, loc)
  defrule eins = (?x:#vloc = call ?t:#calltype ?f:#eimm(?ys:#eimm ...)) : ECall(x, f, to-tuple(ys), t, closest-info())
  defrule eins = (?x:#vloc = ?y:#eimm) : EDef(x, y)

  defproduction calltype : CallType
  defrule calltype = (guarded((?a1:#etype ...) -> ?a2:#etype)) : CallGuarded(to-tuple(a1), a2)
  defrule calltype = (c) : CallC()
  defrule calltype = (stanza) : CallStanza()
  defrule calltype = (ptr) : CallPtr()

  defproduction cast-error-ctxt : CastErrorContext
  defrule cast-error-ctxt = (cast) : CastContext()
  defrule cast-error-ctxt = (arg) : ArgContext()
  defrule cast-error-ctxt = (return) : ReturnContext()
  defrule cast-error-ctxt = (def) : DefContext()
  defrule cast-error-ctxt = (set) : SetContext()
  defrule cast-error-ctxt = (detuple) : DetupleContext()
  defrule cast-error-ctxt = (get-var) : GetVarContext()
  defrule cast-error-ctxt = (func) : FuncContext()
  defrule cast-error-ctxt = (branch) : BranchContext()

  defproduction eclosure : EClosure
  defrule eclosure = (closure ?n:#vid<?targs:#etype ...>(?ys:#eimm ...)) :
    EClosure(n, to-tuple(targs), to-tuple(ys))

  defproduction ebranch : EBranch
  defrule ebranch = ((?ts:#etype ...) : goto ?n:#lid) : EBranch(to-tuple(ts), n, closest-info())

  defproduction eimm : EImm
  defrule eimm = (LV{?x}) : ELSLiteral(unwrap-all(x))
  defrule eimm = (V{?x}) : ELiteral(unwrap-all(x))
  defrule eimm = (mix(?fs:#ecurry ...)) : EMix(to-tuple(fs))
  defrule eimm = (sizeof(?t:#etype)) : ESizeof(t)
  defrule eimm = (tagof(?n:#tid)) : ETagof(n)
  defrule eimm = (const-closure(?n:#vid)) : EConstClosure(n)
  defrule eimm = (const-type(?n:#tid)) : EConstType(n)
  defrule eimm = (?x:#ecurry) : x

  defproduction ecurry : EVar|ECurry
  defrule ecurry = (?n:#vid<?targs:#etype ...>) : ECurry(EVar(n,closest-info()), to-tuple(targs))
  defrule ecurry = (?n:#vid) : EVar(n, closest-info())

  defproduction vloc : EVarLoc
  defrule vloc = (?n:#vid) : EVarLoc(n)

  defproduction tvloc : ETVarLoc
  defrule tvloc = (?n:#tvid) : ETVarLoc(n)

  defproduction eloc : ELoc
  defrule eloc = (?x:#vloc) : x
  defrule eloc = (deref(?y:#eimm)) : EDeref(y)
  defrule eloc = (deptr(?y:#eimm)) : EDeptr(y)
  defrule eloc = (field(?loc:#eloc, ?n:#tid[?i:#int])) : EField(loc, n, i)
  defrule eloc = (slot(?loc:#eloc[?i:#eimm] : ?t:#etype)) : ESlot(loc, t, i)

  defproduction E : False
  fail-if E = (_) : ELE(closest-info(), "Unrecognized input here.")
  defrule E = () : false

  defproduction tstmt : ETExp|Import|Export
  defrule tstmt = (?e:#etexp) : e
  defrule tstmt = (?e:#import) : e
  defrule tstmt = (?e:#export) : e

  public defproduction epackage : EPackage
  defrule epackage = (package ?name:#symbol : (?ss:#tstmt ... #E)) :
    val ins = to-tuple(filter-by<Import>(ss))
    val exs = to-tuple(filter-by<Export>(ss))
    val io = PackageIO(name, [], ins, exs)                
    val es = to-tuple(filter-by<ETExp>(ss))
    EPackage(io, to-tuple(es))

  defproduction string? : String|False
  defrule string? = (false) : false
  defrule string? = (?s:#string) : s

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)
  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

;============================================================
;====================== Errors ==============================
;============================================================

public defstruct ELError <: Exception :
  info: FileInfo|False
  msg

public defn ELE (info:FileInfo|False, msg) :
  ELError(info, msg)

defmethod print (o:OutputStream, e:ELError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [info-str, msg(e)])

;============================================================
;============== Type Hash, Equality, Comparison =============
;============================================================

defn rank (t:EType) :
  match(t) :
    (t:EByte) : 0 
    (t:EInt) : 1 
    (t:ELong) : 2 
    (t:EFloat) : 3 
    (t:EDouble) : 4 
    (t:EUnknown) : 5 
    (t:EPtrT) : 6
    (t:EFnT) : 7
    (t:EStructT) : 8
    (t:EOf) : 9
    (t:ETVar) : 10
    (t:EAnd) : 11
    (t:EOr) : 12
    (t:ETop) : 13 
    (t:EBot) : 14 

defmethod hash (t:EType) :
  val base = rank(t) * 13
  defn H (y) : base + hash(y)
  match(t) :
    (t:EFnT) : H $ [a(t), r(t), b(t)]
    (t:EStructT) : H $ n(t)
    (t:EOf) : H $ n(t)
    (t:ETVar) : H $ n(t)
    (t:EAnd) : H $ [a(t), b(t)]
    (t:EOr) : H $ [a(t), b(t)]
    (t) : base

defmethod equal? (x:EType, y:EType) :
  match(x, y) :
    (x:EByte, y:EByte) : true
    (x:EInt, y:EInt) : true
    (x:ELong, y:ELong) : true
    (x:EFloat, y:EFloat) : true
    (x:EDouble, y:EDouble) : true
    (x:EUnknown, y:EUnknown) : true
    (x:EPtrT, y:EPtrT) : true
    (x:EFnT, y:EFnT) : a(x) == a(y) and b(x) == b(y) and r(x) == r(y)
    (x:EStructT, y:EStructT) : n(x) == n(y)
    (x:EOf, y:EOf) : n(x) == n(y)
    (x:ETVar, y:ETVar) : n(x) == n(y)
    (x:EAnd, y:EAnd) : a(x) == a(y) and b(x) == b(y)
    (x:EOr, y:EOr) : a(x) == a(y) and b(x) == b(y)
    (x:ETop, y:ETop) : true
    (x:EBot, y:EBot) : true
    (x, y) : false

defmethod compare (x:EType, y:EType) :
  defn compare? (x:Comparable|False, y:Comparable|False) :
    match(x, y) :
      (x:Comparable, y:Comparable) : compare(x,y)
      (x:False, y:False) : 0
      (x:Comparable, y:False) : 1
      (x:False, y:Comparable) : -1

  match(x, y) :
    (x:EFnT, y:EFnT) :
      val c = compare?(r(x), r(y))
      if c == 0 : compare([a(x), b(x)], [a(y), b(y)])
      else : c
    (x:EStructT, y:EStructT) : compare(n(x), n(y))
    (x:EOf, y:EOf) : compare(n(x), n(y))
    (x:ETVar, y:ETVar) : compare(n(x), n(y))
    (x:EAnd, y:EAnd) : compare([a(x), b(x)], [a(y), b(y)])
    (x:EOr, y:EOr) : compare([a(x), b(x)], [a(y), b(y)])
    (x, y) : compare(rank(x), rank(y))

public defn normalize (t:EType) :
  match(t) :
    (t:EAnd) :
      label<EType> return :
        val ts = Vector<EType>()
        let loop (e:EType = t) :
          match(e:EAnd) :
            loop(a(e))
            loop(b(e))
          else :
            match(normalize(e)) :
              (t:ETop) : false
              (t:EBot) : return(t)
              (t) : add(ts, t)
        qsort!(ts)
        remove-duplicates!(ts)
        switch(length(ts)) :
          0 : EBot()
          1 : ts[0]
          else : and-absorption-law(ts)      
    (t:EOr) :
      label<EType> return :
        val ts = Vector<EType>()
        let loop (e:EType = t) :
          match(e:EOr) :
            loop(a(e))
            loop(b(e))
          else :
            match(normalize(e)) :
              (t:ETop) : return(t)
              (t:EBot) : false
              (t) : add(ts, t)
        qsort!(ts)
        remove-duplicates!(ts)
        switch(length(ts)) :
          0 : ETop()
          1 : ts[0]
          else : or-absorption-law(ts)      
    (t) :
      map(normalize,t)

defn and-absorption-law (type-list:Vector<EType>) :
  ;Make set of absorbing types
  val type-set = to-hashset<EType>(type-list)
  ;Check whether a type is absorbed
  defn absorbed? (t:EType) :
    match(t:EOr) : type-set[a(t)] or type-set[b(t)]
  ;Return non-absorbed types
  remove-when(absorbed?, type-list)
  reduce(EAnd, type-list)

defn or-absorption-law (type-list:Vector<EType>) :
  ;Make set of absorbing types
  val type-set = to-hashset<EType>(type-list)
  ;Check whether a type is absorbed
  defn absorbed? (t:EType) :
    match(t:EAnd) : type-set[a(t)] or type-set[b(t)]
  ;Return non-absorbed types
  remove-when(absorbed?, type-list)
  reduce(EOr, type-list)

;============================================================
;===================== Classification =======================
;============================================================

public defn reftype? (t:EType) :
  t is EOf|ETVar|EAnd|EOr|ETop|EBot

public defn bottom? (t:EType) :
  match(t) :
    (t:EBot) : true
    (t:EAnd) : bottom?(a(t)) or bottom?(b(t))
    (t:EOr) : bottom?(a(t)) and bottom?(b(t))
    (t) : false

;============================================================
;==================== Specific Mappers ======================
;============================================================

public defn do* (f:EType -> ?, item:ELItem) :
  defn f* (x:EType) : (f(x), x)
  map(f*, item)
  false

public defn do* (f:EImm -> ?, item:ELItem) :
  defn f* (x:EImm) : (f(x), x)
  map(f*, item)
  false

public defn do* (f:ELBigItem -> ?, item:ELItem) :
  defn f* (x:ELBigItem) : (f(x), x)
  map(f*, item)
  false

public defn map<?T> (f:EType -> EType, item:ELItem&?T) :
  defn f* (x:ELItem) -> ELItem :
    match(x) :
      (x:EType) : f(x)
      (x) : map(f*, x)
  map(f*, item)

public defn map<?T> (f:EImm -> EImm, item:ELItem&?T) :
  defn f* (x:ELItem) -> ELItem :
    match(x) :
      (x:EImm) : f(x)
      (x:EType) : x
      (x) : map(f*, x)
  map(f*, item)

public defn map<?T> (f:ELBigItem -> ELBigItem, item:ELItem&?T) -> T :
  ;Will be called on every item
  defn map-big (f:ELItem -> ELItem, item:ELItem) :
    defn f*<?T> (x:ELItem&?T) : f(x) as ELItem&T
    match(item) :
      (x:EBody) : EBody(locals(x), localtypes(x), map(f*,localfns(x)), map(f*,localobjs(x)), ins(x))
      (x:ELBigItem) : map(f, x)
      (x) : x
  defn f* (x:ELItem) :
    match(x:ELBigItem) : f(x)
    else : map-big(f*, x)
  map-big(f*, item) as ELItem&T

;============================================================
;====================== Mappers =============================
;============================================================

public deftype ELBigItem :
  EPackage <: ELBigItem
  ETExp <: ELBigItem
  EFunction <: ELBigItem
  EMethod <: ELBigItem
  EBody <: ELBigItem
  ELocalFn <: ELBigItem
  ELocalObj <: ELBigItem

public deftype ELItem :
  EType <: ELItem
  ELocal <: ELItem
  ELocalType <: ELItem
  EImm <: ELItem
  EIns <: ELItem
  ELoc <: ELItem
  ETVarLoc <: ELItem
  EBranch <: ELItem
  EClosure <: ELItem
  ELBigItem <: ELItem  

public defn do (f:ELItem -> ?, item:ELItem) :
  defn g (x:ELItem) : (f(x), x)
  map(g, item)
  false

public defmulti map<?T> (f:ELItem -> ELItem, item:ELItem&?T) -> T
defmethod map<?T> (f:ELItem -> ELItem, item:ELItem&?T) -> ELItem&T :
  defn h<?T> (x:ELItem&?T) : f(x) as ELItem&T
  defn h<?T> (x:Tuple<ELItem&?T>) : map(h,x)
  defn h (x:CallType) :
    match(x:CallGuarded) : CallGuarded(h(a1(x)), h(a2(x)))
    else : x
  defn h? (x:False) : false
  defn h? (x:EType) : h(x)
  defn h? (x:EImm) : h(x)
  defn h? (x:EVarLoc) : h(x)

  {_ as ELItem&T} $ match(item) :
    ;Types
    (t:EByte) : t
    (t:EInt) : t
    (t:ELong) : t
    (t:EFloat) : t
    (t:EDouble) : t
    (t:EUnknown) : t
    (t:EPtrT) : t
    (t:EFnT) : EFnT(h(a(t)), h?(r(t)), h(b(t)))
    (t:EStructT) : t
    (t:EOf) : t
    (t:ETVar) : t
    (t:EAnd) : EAnd(h(a(t)), h(b(t)))
    (t:EOr) : EOr(h(a(t)), h(b(t)))
    (t:ETop) : t
    (t:EBot) : t

    ;EPackage
    (e:EPackage) : EPackage(packageio(e), h(exps(e)))

    ;ETExps    
    (e:EDefGlobal) : EDefGlobal(n(e), h(type(e)), mutable?(e), lostanza?(e))
    (e:EDefn) : EDefn(n(e), h(func(e)), lostanza?(e))
    (e:EDefClosure) : EDefClosure(n(e), closure(e), ntargs(e), nargs(e), h(func(e)))
    (e:EDefmulti) : EDefmulti(n(e), targs(e), h(a1(e)), h(a2(e)), info(e))
    (e:EDefmethod) : EDefmethod(n(e), multi(e), h(targs(e)), h(func(e)), lostanza?(e))
    (e:EDefStruct) : EDefStruct(n(e), h?(parent(e)), h(base(e)), h?(items(e)))
    (e:EExternFn) : EExternFn(n(e), lbl(e), h(func(e)))
    (e:EExtern) : EExtern(n(e), lbl(e), h(type(e)))
    (e:EInit) : EInit(h(body(e)), lostanza?(e))
    (e:EDefType) : EDefType(n(e), h?(parent(e)), children(e))
    (e:EDefObject) : EDefObject(n(e), h(parent(e)), ntargs(e), nargs(e), methods(e))
    (e:EDefTypeObject) : EDefTypeObject(n(e), nargs(e), h(type(e)))

    ;Functions
    (e:EMultifn) : EMultifn(h(funcs(e)))
    (e:EFn) : EFn(tail?(e), targs(e), args(e), h(a1(e)), h(a2(e)), h(body(e)), info(e), free?(e))

    ;Bodies
    (e:EBody) : EBody(h(locals(e)), h(localtypes(e)), h(localfns(e)), h(localobjs(e)), h(ins(e)))

    ;Locals
    (e:ELocal) : ELocal(n(e), h(type(e)), mutable?(e))
    (e:ELocalType) : e
    (e:ELocalFn) : ELocalFn(n(e), h(func(e)))
    (e:ELocalObj) : ELocalObj(n(e), h(type(e)), h(methods(e)))

    ;Methods
    (e:EMethod) : EMethod(multi(e), h(targs(e)), thisn(e), h(func(e)))

    ;Imms
    (e:ELSLiteral) : e
    (e:ELiteral) : e
    (e:EVar) : e
    (e:ECurry) : ECurry(h(x(e)), h(targs(e)))
    (e:EMix) : EMix(h(funcs(e)))
    (e:ESizeof) : ESizeof(h(type(e)))
    (e:ETagof) : e
    (e:EConstClosure) : e
    (e:EConstType) : e

    ;Ins
    (e:EDef) : EDef(h(x(e)), h?(y(e)))
    (e:ETDef) : ETDef(h(x(e)), h(y(e)))
    (e:EInitClosures) : EInitClosures(h(xs(e)), info(e))
    (e:ECall) : ECall(h?(x(e)), h(/f(e)), h(ys(e)), h(calltype(e)), info(e))
    (e:ETCall) : ETCall(h(/f(e)), h(ys(e)), h(calltype(e)), info(e))
    (e:ENew) : ENew(h(x(e)), n(e), info(e))
    (e:ENewObject) : ENewObject(h(x(e)), n(e), h(targs(e)), h(ys(e)), info(e))
    (e:EObjectGet) : EObjectGet(h(x(e)), h(y(e)), n(e), index(e))
    (e:EObjectTGet) : EObjectTGet(h(x(e)), h(y(e)), n(e), index(e))
    (e:EClosureGet) : EClosureGet(h(x(e)), h(y(e)), n(e), index(e))
    (e:EClosureTGet) : EClosureTGet(h(x(e)), h(y(e)), n(e), index(e))
    (e:ETuple) : ETuple(h(x(e)), h(ys(e)), info(e))
    (e:EVoidTuple) : EVoidTuple(h(x(e)), length(e), info(e))
    (e:ETupleGet) : ETupleGet(h(x(e)), h(y(e)), index(e), info(e))
    (e:ETupleSet) : ETupleSet(h(y(e)), index(e), h(z(e)))
    (e:ECheckLength) : ECheckLength(h(y(e)), length(e), info(e))
    (e:EObject) : EObject(h(x(e)), n(e), h(ys(e)), info(e))
    (e:EArray) : EArray(h(x(e)), n(e), h(ys(e)), info(e))
    (e:EStruct) : EStruct(h(x(e)), n(e), h(ys(e)))
    (e:EPtr) : EPtr(h(x(e)), h(loc(e)))
    (e:ELoad) : ELoad(h(x(e)), h(xtype(e)), h(loc(e)))
    (e:EStore) : EStore(h(loc(e)), h(y(e)), h(ytype(e)), info(e))
    (e:ELabel) : e
    (e:EDump) : EDump(h(ys(e)))
    (e:EInterpret) : EInterpret(h(x(e)), h(y(e)))
    (e:EConv) : EConv(h(x(e)), h(y(e)))
    (e:ECheck) : ECheck(h(y(e)), h(type(e)), ctxt(e), info(e))
    (e:ECheckFail) : ECheckFail(h(type(e)), h(y(e)), ctxt(e), info(e))
    (e:EGoto) : e
    (e:EEnd) : e
    (e:EPrim) : EPrim(h(x(e)), op(e), h(ys(e)), info(e))
    (e:EIf) : EIf(n1(e), n2(e), op(e), h(ys(e)))
    (e:ETypeof) : ETypeof(n1(e), n2(e), h(type(e)), h(y(e)))
    (e:EMatch) : EMatch(h(ys(e)), h(branches(e)), covered?(e), info(e))
    (e:EDispatch) : EDispatch(h(ys(e)), h(branches(e)), info(e))
    (e:ECheckSet) : ECheckSet(h(y(e)), name(e), info(e))
    (e:EBox) : EBox(h(x(e)), h?(y(e)))
    (e:EBoxGet) : EBoxGet(h(x(e)), h(y(e)))
    (e:EBoxSet) : EBoxSet(h(y(e)), h(z(e)))
    (e:EReturn) : EReturn(h(y(e)))
    (e:ELetRec) : ELetRec(h(xs(e)), h(ys(e)), info(e))
    (e:ETypeObject) : ETypeObject(h(x(e)), n(e), h(targs(e)))
    (e:ELive) : ELive(h(xs(e)))

    ;Locations
    (e:EVarLoc) : e
    (e:EDeref) : EDeref(h(y(e)))
    (e:EDeptr) : EDeptr(h(y(e)))
    (e:EField) : EField(h(loc(e)), n(e), index(e))
    (e:ESlot) : ESlot(h(loc(e)), h(type(e)), h(index(e)))

    ;Type Locations
    (e:ETVarLoc) : e

    ;Branches
    (e:EBranch) : EBranch(h(types(e)), n(e), info(e))

    ;Closures
    (e:EClosure) : EClosure(n(e), h(targs(e)), h(ys(e)))

;============================================================
;==================== Dump to File ==========================
;============================================================

public defn dump (e:EPackage, path:String, suffix:String|False) :
  val suffix-str = "" when suffix is False else ".%_" % [suffix]
  val filename = norm-path("%_/%_.el%_" % [path, mangle-as-filename(name(e)), suffix-str])
  spit(filename, e)

public defn dump (e:EPackage, suffix:String|False) :
  dump(e, ".", suffix)

public defn dump (e:EPackage) :
  dump(e, false)
