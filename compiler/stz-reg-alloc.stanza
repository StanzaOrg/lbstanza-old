;See License.txt for details about licensing.

;<doc>=======================================================
;=================== Documentation ==========================
;============================================================

INPUT:
  One single normalized VMFunction.
  An emitter for outputting the generated assembly instructions.
  The backend upon which to perform the allocation.
  The assembly stubs which contain all of the labels needed to generate the
  assembly instructions.
OUTPUT:
  The allocated abstract instructions. 

Constructs that must be handled, and their variants:
  
  Args - (StanzaContext / CContext)
  Return - (StanzaContext / CContext)
  Call - (StanzaCall / StanzaTCall / CCall / YieldCall / CollectGarbage / ExtendStack)
  Op - (AddOp / SubOp / MulOp / AndOp / OrOp / XorOp / NotOp / ShlOp / ShrOp /
        AshrOp / NegOp / EqOp / NeOp / LtOp / GtOp / LeOp / GeOp / UleOp / UltOp /
        UgtOp / UgeOp / FlushVMOp / CRSPOp / DivModOp / NoOp / RecordLiveOp / LoadOp /
        StoreOp / StoreArgOp / StoreCArgOp / LoadArgOp / AllocOp / InstanceofOp)
  Branch - (EqOp / NeOp / LtOp / GtOp / LeOp / GeOp / UleOp / UltOp /
            UgtOp / UgeOp / HasHeapOp / HasStackOp / ArgEqOp)
  Set
  Match
  MethodDispatch
  Save
  Load

Implementations:

  Args - StanzaContext:
    The arguments are assumed to be located in their preassigned registers.
  Args - CContext:
    ???
  Return - StanzaContext:
    Return values are stored in their preassigned registers.
  Return - CContext:
    ???
  Call - StanzaCall:
    Arguments are already stored.
    Push stack frame
    Call function
    Pop stack frame
    
    RSP += frame-size + 8
    call F
    RSP -= frame-size + 8    
  Call - StanzaTCall :  
    Arguments are already stored.
    Jump to function
    
    goto F
  Call - CCall :
    Push stack frame.
    Save RSP in stack-pointer temporary
    Restore C Context: C preserved registers, CRSP
    Push CRSP down
    Set number of floating point arguments
    Call function
    Restore RSP.
    Pop stack frame.
    
    RSP += frame-size + 8
    [saved-stack-pointer] = RSP
    
    R2 = [saved-CR2]
    ...
    Rn = [saved-CRn]
    
    RSP = [saved-CRsp]
    
    RSP -= c-frame-size
    
    R0 = num floating-point arguments
    
    call F
    
    RSP = [saved-stack-pointer]
    RSP -= frame-size + 8
  Call - YieldCall :
    Save current stack progress
    Load given stack
    Goto saved PC

    TMP = [current-stack]
    [TMP.pc] = &lbl
      (TMP2 = &lbl
       [TMP.pc] = TMP2)
    [TMP.sp] = RSP
    
    [current-stack] = F
    RSP = F.sp or F.frames (depending on enter?)
    [stack-limit] = F.frames + F.size
      (TMP = F.frames
       TMP2 = F.size
       TMP += TMP2
       [stack-limit] = TMP)
    
    goto F.pc
      (TMP = F.pc
       goto TMP)
    label lbl:
  Call - CollectGarbage :
    Assume size is in first argument
    Set return address
    
    R0 = &lbl
    goto collect-garbage
    label lbl:
  Call - ExtendStack :
    Set return address
    R0 = &lbl
    goto extend-stack
    label lbl:
  Op - FlushVMOp :
    save stack-pointer into current stack

    x = [current-stack]
    [x.sp] = RSP
    x = &vmstate

  Op - AllocOp :
    Load heap-top
    Return pointer tagged with tag-bits
    Add size to pointer and save back into heap-top

    TMP = [heap-top]
    TMP2 = size
    x = TMP + ref-tag-bits(1)
    [heap-top] = TMP + TMP2

  Op - InstanceofOp :
    Ensure two scratch registers for compilation.

  Branch - HasHeapOp :
    Load heap-top
    Add requested size to heap-top.
    Compare against heap-limit

    TMP = [heap-top]
    TMP += size
    TMP2 = [heap-limit]
    compare TMP TMP2

  Branch - HasStackOp :
    Add RSP to frame-size + 8
    Load stack-limit

    TMP = RSP + frame-size + 8
    TMP2 = [stack-limit]
    compare TMP TMP2

    HasStackOp is guaranteed for TMP/TMP2 in R0/R1 to be free because
    it is used during the function prelude, and registers still
    obey the calling convention.    
    
  Match :
    Ensure two scratch registers for trie compilation

  MethodDispatch :
    Ensure two scratch registers for trie compilation.
    
    MethodDispatch is guaranteed for TMP/TMP2 in R0/R1 to be free because
    it is used during the function prelude, and registers still
    obey the calling convention.    

Allocation of Classes:
  This pass handles spilling, saving, and loading of registers so that every
  instruction has the necessary number of register available to it during
  register assignment. 

  Thus, for each construct, we need to know how many extra registers we need
  for its stub.

  

;============================================================
;=======================================================<doc>

defpackage stz/reg-alloc :
  import core
  import collections with :
    prefix(Set) => collections-
  import stz/algorithms
  import stz/backend
  import stz/padder
  import stz/vm-ir
  import stz/basic-ops
  import stz/typeset
  import stz/asm-ir with :
    prefix => asm-
  import stz/vm-normalize with :
    prefix(CallType, StanzaCall, StanzaTCall, CCall, YieldCall) => vm-
  import stz/utils
  import stz/codegen
  import stz/basic-blocks with :
    prefix(Block) => Basic

;============================================================
;===================== Driver ===============================
;============================================================

public defn allocate-registers (ins:VMFunction, emitter:CodeEmitter, backend:Backend, stubs:AsmStubs, print?:True|False) -> False :
  take-ids(ins)
  
  if print? :
    println("==== Input ====")
    println(ins)

  load-instructions(ins as VMFunc, backend)
  if print? :
    println("==== Load Instructions ====")
    print-prog()
  ;
  ;normalize(backend)
  ;if flag-defined?(`PRINT-REG-ALLOC):
  ;  println("==== Normalize ====")
  ;  print-prog()
  ;
  remove-critical-edges()
  ;if print? :
  ;  println("==== Remove Critical Edges ====")
  ;  print-prog() 
  
  reverse-post-order()
  ;if print? :
  ;  println("==== Reverse Post Order ====")
  ;  print-prog()
  
  compute-predecessors()
  liveness-analysis()
  add-annotations()
  if print? :
    println("==== Added Annotations ====")
    print-prog()
  
  allocate-classes(backend)
  if print? :
    println("==== Allocated Classes ====")
    print-prog()

  register-assignment(backend)
  if print? :
    println("==== Assigned Registers ====")
    print-prog()
  
  val smap = stack-map()
  ;if print? :
  ;  println("==== Stack Map ====")
  ;  println(smap)
  
  collapse-blocks()
  if print? :
    println("==== Collapse Blocks ====")
    print-prog()

  assemble(emitter, smap, stubs)
  clear-working-set()

;============================================================
;========================== IR ==============================
;============================================================

;==============================
;==== Variable Definitions ====
;==============================

public deftype Imm
public defstruct Var <: Imm :
  n: Int
  reg? : False|Reg|FReg with: (default => false)
public defstruct Val <: Imm :
  value: VMImm

public deftype Loc
public defstruct Reg <: Loc&Equalable :
  n: Int
public defstruct FReg <: Loc&Equalable :
  n: Int

;======================
;==== Constructors ====
;======================
defn XReg (t:VMType, n:Int) :
  match(t:VMType&IntegerT) : Reg(n)
  else : FReg(n)

;==================
;==== Equality ====
;==================

defmethod equal? (a:Reg, b:Reg) :
  n(a) == n(b)

defmethod equal? (a:FReg, b:FReg) :
  n(a) == n(b)
  
;=================================
;==== Instruction Definitions ====
;=================================
public deftype Ins
defmulti killed? (i:Ins) -> False|List<Int>

public defstruct Def <: Ins :
  x: Var
  killed?: False|List<Int> with: (default => false, as-method => true)

public defstruct Set <: Ins :
  x: Var
  y: Imm
  killed?: False|List<Int> with: (default => false, as-method => true)

public defstruct Args <: Ins :
  xs: List<Var>
  ctxt: FnContext
  killed?: False|List<Int> with: (default => false, as-method => true)

public defstruct Return <: Ins :
  xs: List<Imm>
  ctxt: FnContext
  killed?: False|List<Int> with: (default => false, as-method => true)

public defstruct Call <: Ins :
  xs: List<Var> with: (updater => sub-xs)
  f: Imm with: (updater => sub-f)
  ys: List<Imm> with: (updater => sub-ys)
  type: CallType with: (updater => sub-type)
  killed?: False|List<Int> with: (default => false, as-method => true)

public defstruct Op <: Ins :
  op: VMOp with: (updater => sub-op)
  xs: List<Var> with: (updater => sub-xs)
  ys: List<Imm> with: (updater => sub-ys)
  killed?: False|List<Int> with: (default => false, as-method => true) 

public defstruct Branch <: Ins :
  op: VMOp
  xs: List<Imm>
  killed?: False|List<Int> with: (default => false, as-method => true)

public defstruct Match <: Ins :
  dispatch?: True|False
  type-lists: List<List<TypeSet>>
  xs: List<Imm>
  killed?: False|List<Int> with: (default => false, as-method => true)
  ns?: False|List<Int> with: (default => false)

public defstruct MethodDispatch <: Ins :
  multi: Int
  num-header-args: Int
  default?: Int|False with: (default => false)
  amb?: Int|False with: (default => false)
  killed?: False|List<Int> with: (default => false, as-method => true)

public defstruct Save <: Ins :
  x: Var

public defstruct Load <: Ins :
  x: Var

public defstruct Unload <: Ins :
  n: Int

public defstruct NextUsed <: Ins :
  n: Int
  pos: Int

public defstruct Xchg <: Ins :
  x: Var
  y: Var
  swap: False|Reg|FReg
  
public defstruct ShuffleReg <: Ins :
  xs: List<Int>
  ys: List<Int>

public defstruct ShuffleFReg <: Ins :
  xs: List<Int>
  ys: List<Int>

public defstruct Label <: Ins :
  n: Int

public defstruct Goto <: Ins :
  n: Int

public defstruct Break <: Ins :
  n: Int
  op: VMOp
  xs: List<Imm>

defmethod killed? (i:Save|Load|Unload|NextUsed|Xchg|
                     ShuffleReg|ShuffleFReg|Label|Goto|Break) :
  false

;==========================
;==== Function Context ====
;==========================

public deftype FnContext
public defmulti regs (c:FnContext) -> List<Loc>
public defstruct StanzaContext <: FnContext :
  regs: List<Loc> with: (as-method => true)
public defstruct CContext <: FnContext :
  regs: List<Loc> with: (as-method => true)

;===================
;==== Call Type ====
;===================

public deftype CallType

public defstruct StanzaCall <: CallType :
  info: False|FileInfo
  func-reg: False|Loc 
  arg-regs: List<Loc>
  ret-regs: List<Loc>
  
public defstruct StanzaTCall <: CallType :
  func-reg: False|Loc
  arg-regs: List<Loc>

public defstruct CCall <: CallType :
  num-mem-args: Int
  func-reg: False|Loc
  arg-regs: List<Loc>
  ret-regs: List<Loc>
  
public defstruct YieldCall <: CallType :
  enter?: True|False
  info: False|FileInfo
  func-reg: Loc
  arg-regs: List<Loc>
  ret-regs: List<Loc>
  scratch-regs: List<Loc>

public defstruct CollectGarbage <: CallType :
  info: False|FileInfo
  arg-regs: List<Loc>
  ret-regs: List<Loc>
  
public defstruct ExtendStack <: CallType

;==========================
;==== Block Definition ====
;==========================
public defstruct Block :
  ins: Vector<Ins>
  next: List<Int>

;========================
;=== Port Definition ====
;========================
defstruct Port :
  n: Int
  saved?: True|False
  loaded?: True|False
  reg: False|Reg|FReg
  dist: Int

;=============================
;==== Convenience Getters ====
;=============================
defn killed (i:Ins) : killed?(i) as List<Int>
defn ns (m:Match) : ns?(m) as List<Int>
defn reg (v:Var) : reg?(v) as Reg|FReg
defn default (m:MethodDispatch) : default?(m) as Int
defn amb (m:MethodDispatch) : amb?(m) as Int

;=====================
;==== Special Ops ====
;=====================
public defstruct NoOp <: VMOp
defmethod print (o:OutputStream, op:NoOp) :
  print(o, "nop")

public defstruct SaveCContextOp <: VMOp
defmethod print (o:OutputStream, op:SaveCContextOp) :
  print(o, "save-c-ctxt")

public defstruct RecordLiveOp <: VMOp :
  live-vars: Tuple<Var>
defmethod print (o:OutputStream, op:RecordLiveOp) :
  print(o, "live(%,)" % [live-vars(op)])

public defstruct LoadOp <: VMOp : (offset:Int)
defmethod print (o:OutputStream, op:LoadOp) :
  print(o, "load/%_" % [offset(op)])

public defstruct StoreOp <: VMOp : (offset:Int) ;[4]
defmethod print (o:OutputStream, op:StoreOp) :
  print(o, "store/%_" % [offset(op)])

public defstruct StoreArgOp <: VMOp : (index:Int)
defmethod print (o:OutputStream, op:StoreArgOp) :
  print(o, "storearg/%_" % [index(op)])

public defstruct LoadCArgOp <: VMOp : (index:Int, num-mem-args:Int)
defmethod print (o:OutputStream, op:LoadCArgOp) :
  print(o, "loadcarg/%_ (num-mem-args = %_)" % [index(op), num-mem-args(op)])

public defstruct StoreCArgOp <: VMOp : (index:Int, num-mem-args:Int)
defmethod print (o:OutputStream, op:StoreCArgOp) :
  print(o, "storecarg/%_ (num-mem-args = %_)" % [index(op), num-mem-args(op)])
  
public defstruct LoadArgOp <: VMOp : (index:Int)
defmethod print (o:OutputStream, op:LoadArgOp) :
  print(o, "loadarg/%_" % [index(op)])

public defstruct AllocOp <: VMOp
defmethod print (o:OutputStream, op:AllocOp) :
  print(o, "alloc")  

public defstruct StoreCRSPOp <: VMOp
with: (printer => true)

public defstruct FlipOp <: VMOp : (op:VMOp)
defmethod print (o:OutputStream, x:FlipOp) :
  print(o, "flip(%_)" % [op(x)])

;============================================================
;===================== Working Set ==========================
;============================================================

val BLOCKS = Vector<Block>()
val VAR-TYPES = Vector<VMType>()
val IN-PORTS = Vector<List<Port>>()
val OUT-PORTS = Vector<List<Port>>()
val PREDECESSORS = Vector<List<Int>>()

defn nblocks () : length(BLOCKS)
defn nvars () : length(VAR-TYPES)

defn clear-working-set () :
  clear(BLOCKS)
  clear(VAR-TYPES)

defn type (i:Imm) :
  match(i) :
    (i:Var) : VAR-TYPES[n(i)]
    (i:Val) : type(value(i))

defn make-var (t:VMType) :
  val n = length(VAR-TYPES)
  add(VAR-TYPES, t)
  Var(n)

;============================================================
;====================== Printing ============================
;============================================================

defn print-prog () :
  for i in 0 to nvars() do :
    println("val %_ : %_" % [i, VAR-TYPES[i]])
  for i in 0 to nblocks() do :
    println("block %_ :" % [i])
    indented $ fn () :
      if length(IN-PORTS) == nblocks() :
        println("input ports:")
        indented $ fn () :
          do(println, IN-PORTS[i])
      println("instructions:")
      indented $ fn () :
        if length(PREDECESSORS) == nblocks() :
          println("prev: %," % [PREDECESSORS[i]])
        println(BLOCKS[i])
      if length(OUT-PORTS) == nblocks() :
        println("output ports:")
        indented $ fn () :
          do(println, OUT-PORTS[i])

defmethod print (o:OutputStream, v:Imm) :
  print{o, _} $ match(v) :
    (v:Var) :
      val reg = match(reg?(v)) :
        (r:False) : ""
        (r) : ":%_" % [r]
      "V%_%_" % [n(v), reg]
    (v:Val) :
      value(v)

defmethod print (o:OutputStream, r:Reg) :
  print(o, "R%_" % [n(r)])

defmethod print (o:OutputStream, r:FReg) :
  print(o, "F%_" % [n(r)])

defmethod print (o:OutputStream, i:Ins) :
  val ks = match(killed?(i)) :
             (ks:False) : ""
             (ks:List<Int>) : " killed: %," % [ks]
  print{o, _} $ match(i) :
    (i:Def) : "def %_" % [x(i)]
    (i:Set) : "%_ = %_%_" % [x(i), y(i), ks]
    (i:Args) : "(%,) = Args%_" % [xs(i), ks]
    (i:Call) : "(%,) = %_(%,) %_%_" % [xs(i), f(i), ys(i), type(i), ks]
    (i:Return) : "return (%,)%_" % [xs(i), ks]
    (i:Op) : "(%,) = %_(%,)%_" % [xs(i), op(i), ys(i), ks]
    (i:Branch) : "branch when %_(%,)%_" % [op(i), xs(i), ks]
    (i:Save) : "save %_" % [x(i)]
    (i:Load) : "load %_" % [x(i)]
    (i:Unload) : "unload V%_" % [n(i)]
    (i:NextUsed) : "next used %_ at %_" % [n(i), pos(i)]
    (i:Xchg) : "xchg %_ with %_ through %_" % [x(i), y(i), swap(i)]
    (i:Match) :
      val op = "dispatch" when dispatch?(i) else "match"
      "%_(%,)[%,]%_" % [op, xs(i), type-lists(i), ks]
    (i:MethodDispatch) :
      "method-dispatch(%_)%_" % [multi(i), ks]
    (i:ShuffleReg) : "shuffle (%,) = (%,)" % [xs(i), ys(i)]
    (i:ShuffleFReg) : "fshuffle (%,) = (%,)" % [xs(i), ys(i)]
    (i:Label) : "label %_" % [n(i)]
    (i:Goto) : "goto %_" % [n(i)]
    (i:Break) : "break %_ when %_(%,)" % [n(i), op(i), xs(i)]

defmethod print (o:OutputStream, c:FnContext) :
  print{o, _} $ match(c) :
    (c:StanzaContext) : "ST(%_)" % [regs(c)]
    (c:CContext) : "C(%_)" % [regs(c)]

defmethod print (o:OutputStream, c:CallType) :
  print{o, _} $ match(c) :
    (c:StanzaCall) : "S(%_, %_, %_)" % [func-reg(c), arg-regs(c), ret-regs(c)]
    (c:StanzaTCall) : "ST(%_, %_)" % [func-reg(c), arg-regs(c)]
    (c:CCall) : "C(%_, %_, %_, %_)" % [num-mem-args(c), func-reg(c), arg-regs(c), ret-regs(c)]
    (c:YieldCall) : "Y(%_, %_, %_, %_, %_)" % [enter?(c), func-reg(c), arg-regs(c), ret-regs(c), scratch-regs(c)]
    (c:CollectGarbage) : "CollectGarbage"
    (c:ExtendStack) : "ExtendStack"

defmethod print (o:OutputStream, b:Block) :
  do(println{o, _}, ins(b))
  print(o, "next: %," % [next(b)])

defmethod print (o:OutputStream, p:Port) :
   print(o, "%~ (s:%~, l:%~, at:%~, dist:%~)" % [n(p), saved?(p), loaded?(p), reg(p), dist(p)])

;============================================================
;=================== Working Functions ======================
;============================================================

defn do-defined (f: Var -> ?, e:Ins) :
  match(e) :
    (e:Def) : f(x(e))
    (e:Set) : f(x(e))
    (e:Args) : do(f, xs(e))
    (e:Call) : do(f, xs(e))
    (e:Return) : false
    (e:Op) : do(f, xs(e))
    (e:Branch) : false
    (e:Save) : false
    (e:Load) : f(x(e))
    (e:Match) : false
    (e:MethodDispatch) : false
  false

defn do-used (gv: Var -> ?, e:Ins) :
  defn g (i:Imm) : match(i:Var) : gv(i)
  match(e) :
    (e:Def) : false
    (e:Set) : g(y(e))
    (e:Args) : false
    (e:Call) : (g(f(e)), do(g, ys(e)))
    (e:Return) : do(g, xs(e))
    (e:Op) : do(g, ys(e))
    (e:Branch) : do(g, xs(e))
    (e:Save) : g(x(e))
    (e:Load) : false
    (e:Match) : do(g, xs(e))
    (e:MethodDispatch) : false
  false

defn used-vars (e:Ins) :
  generate<Int> :
    do-used(yield{n(_)}, e)

defn do-vars (f: Var -> ?, e:Ins) :
  do-defined(f, e)
  do-used(f, e)

defn reverse-sweep (e:Ins, define:Var -> ?, emit:Ins -> ?, use-var:Var -> ?) :
  defn use (x:Imm) :
    match(x:Var) :
      use-var(x)
  match(e) :
    (e:Def) :
      define(x(e))
      emit(e)
    (e:Set) :
      define(x(e))
      emit(e)
      use(y(e))
    (e:Args) :
      do(define, xs(e))
      emit(e)
    (e:Call) :
      do(define, xs(e))
      emit(e)
      use(f(e))
      do(use, ys(e))
    (e:Return) :
      emit(e)
      do(use, xs(e))
    (e:Op) :
      do(define, xs(e))
      emit(e)
      do(use, ys(e))
    (e:Branch) :
      emit(e)
      do(use, xs(e))
    (e:Match) :
      emit(e)
      do(use, xs(e))
    (e:MethodDispatch) :
      emit(e)

defn attach-killed (e:Ins, ks:List<Int>) :
  match(e) :
    (e:Def) : Def(x(e), ks)
    (e:Set) : Set(x(e), y(e), ks)
    (e:Args) : Args(xs(e), ctxt(e), ks)
    (e:Return) : Return(xs(e), ctxt(e), ks)
    (e:Call) : Call(xs(e), f(e), ys(e), type(e), ks)
    (e:Op) : Op(op(e), xs(e), ys(e), ks)
    (e:Branch) : Branch(op(e), xs(e), ks)
    (e:Match) : Match(dispatch?(e), type-lists(e), xs(e), ks, ns?(e))
    (e:MethodDispatch) : MethodDispatch(multi(e), num-header-args(e), default?(e), amb?(e), ks)

;============================================================
;=================== Unique Labels ==========================
;============================================================
val TAKEN-IDS = IntSet()
var ID-COUNTER:Seq<Int>

defn take-ids (f:VMFunction) :
  clear(TAKEN-IDS)
  ID-COUNTER = to-seq(0 to false)
  
  defn take-ids (f:VMFunc) :
    add-all(TAKEN-IDS, seq(id, defs(f)))
    add-all(TAKEN-IDS, seq(n,filter-by<LabelIns>(ins(f))))
    
  match(f) :
    (f:VMFunc) :
      take-ids(f)
    (f:VMMultifn) :
      do(take-ids{value(_)}, funcs(f))
      take-ids(default(f))

defn unique-id () :
  let loop () :
    val i = next(ID-COUNTER)
    if TAKEN-IDS[i] : loop()
    else : i

;============================================================
;================= Load into Working Set ====================
;============================================================
  
defn load-instructions (function:VMFunc, backend:Backend) :
  ;========================
  ;==== Variable Table ====
  ;========================
  val var-table = IntTable<Int>()
  defn make-var (n:Int, t:VMType) :
    fatal("Variable %_ already exists." % [n]) when key?(var-table,n)
    var-table[n] = length(VAR-TYPES)
    add(VAR-TYPES, t)
;    if flag-defined?(`PRINT-REG-ALLOC) :
;      println("V%_ = $v%_" % [var-table[n], n])
  defn make-var (t:VMType) :
    val n = length(VAR-TYPES)
    add(VAR-TYPES, t)
    Var(n)
  defn get-var (v:Int) :
    Var(var-table[v])
  defn get-var (v:Local) :
    get-var(index(v))
  defn get-imm (v:VMImm) :
    match(v:Local) : get-var(v)
    else : Val(v)
  defn get-vars (vs:Seqable<Local>) :
    to-list(seq(get-var, vs))
  defn get-imms (vs:Seqable<VMImm>) :
    to-list(seq(get-imm, vs))

  ;=========================
  ;====== Convenience ======
  ;=========================
  defn locals (r:RetRecords) :
    seq(x, records(r))
  defn to-reg (r:CallReg|CallFReg) :
    match(r) :
      (r:CallReg) : Reg(index(r))
      (r:CallFReg) : FReg(index(r))          
  defn regs (r:RetRecords) :
    to-list $ for r in records(r) seq :
      to-reg(loc(r) as CallReg|CallFReg)
  defn imms (r:CallRecords) :
    for r in records(r) seq :
      arg(r) as VMImm
  defn regs (r:CallRecords) :
    to-list $ for r in records(r) seq :
      to-reg(loc(r) as CallReg|CallFReg)

  ;================================
  ;===== Basic Block Analysis =====
  ;================================

  val blocks = analyze-basic-blocks $
    new Instructions :
      defmethod length (this) : length(ins(function))
      defmethod unique-label (this) : unique-id()
      defmethod classify (this, i:Int) :
        match(ins(function)[i]) :
          (ins:CallRecordIns) :
            if type(ins) is vm-StanzaTCall : JumpInstruction([])
            else : StandardInstruction()
          (ins:ReturnRecordIns) :
            JumpInstruction([])
          (ins:MatchRecordIns) :
            val branch-ns = seq(n, branches(ins))
            JumpInstruction{to-tuple(_)} $ match(amb(ins)) :
              (amb:Int) : cat([default(ins), amb], branch-ns)
              (amb:False) : cat([default(ins)], branch-ns)
          (ins:Branch0Ins) : JumpInstruction([n1(ins), n2(ins)])
          (ins:Branch1Ins) : JumpInstruction([n1(ins), n2(ins)])
          (ins:Branch2Ins) : JumpInstruction([n1(ins), n2(ins)])
          (ins:MethodDispatchIns) : JumpInstruction([default(ins), amb(ins)])
          (ins:UnreachableIns) : JumpInstruction([])          
          (ins:LabelIns) : LabelInstruction(n(ins))
          (ins:GotoIns) : GotoInstruction(n(ins))
          (ins) : StandardInstruction()

  ;Convert basic block into RegAlloc IR
  defn to-block (b:BasicBlock) :
    defn R (n:Int) : renamed-label(blocks, n)
    val ins-buffer = Vector<Ins>()
    defn push (i:Ins) : add(ins-buffer, i)
    if index(b) == 0 :
      for d in defs(function) do :
        make-var(id(d), type(d))
        push(Def(get-var(id(d))))
    for i in start(b) to start(b) + length(b) do :
      match(ins(function)[i]) :
        (e:ArgIns) :
          val r = ret(e)
          val xs = get-vars(locals(r))
          val ctxt = match(type(e)) :
            (t:StanzaArg) : StanzaContext(regs(r))
            (t:CArg) : CContext(regs(r))
          push(Args(xs, ctxt))
        (e:CallRecordIns) :
          ;Retrieve a func register if necessary
          defn func-reg? (f:VMImm, used:Seqable<Loc>) :
            match(f:Local) : unused-regs(used, 1, backend)[0]            

          val r = ret(e)
          val a = args(e)
          val a-regs = regs(a)
          val calltype = match(type(e)) :
            (t:vm-StanzaCall) :
              StanzaCall(info(e), func-reg?(f(e), a-regs), a-regs, regs(r))
            (t:vm-StanzaTCall) :
              StanzaTCall(func-reg?(f(e), a-regs), a-regs)
            (t:vm-CCall) :
              val freg = func-reg?(f(e), cat-all $ [a-regs, seq(Reg,c-preserved-regs(backend)), [Reg(0)]])
              CCall(num-mem-args(t), freg, a-regs, regs(r))              
            (t:vm-YieldCall) :
              val rs = unused-regs(a-regs, 3, backend)
              YieldCall(enter?(t), info(e), rs[0], a-regs, regs(r), List(rs[1], rs[2]))
          push(Call(get-vars(locals(r)), get-imm(f(e)), get-imms(imms(a)), calltype))
        (e:ReturnRecordIns) :
          val r = args(e)
          val xs = get-imms(imms(r))
          val ctxt = match(type(e)) :
            (t:vm-StanzaCall) : StanzaContext(regs(r))
            (t:vm-CCall) : CContext(regs(r))
          push(Return(xs, ctxt))
        (e:MatchRecordIns) :
          val type-lists = to-list(seq(to-list{types(_)}, branches(e)))
          val r = args(e)
          push(Match(dispatch?(e), type-lists, get-imms(imms(r))))
        (e:ExtendStackIns) :
          push(Call(List(), Val(VoidMarker()), List(), ExtendStack()))
        (e:AllocOnHeap) :
          val size = get-imm(size(e))
          push(Op(AllocOp(), List(get-var(x(e))), List(size)))
        (e:SetIns) :
          push(Set(get-var(x(e)), get-imm(y(e))))
        (e:Op0Ins) :
          push(Op(op(e), List(get-var(x(e))), List()))
        (e:Op1Ins) :
          match(op(e)) :
            (op:GCOp) :
              val x = get-var(x(e))
              val size = get-imm(y(e))
              val a-regs = List(Reg(head(call-regs(backend))))
              val r-regs = List(Reg(head(call-regs(backend))))
              push(Call(List(x), Val(VoidMarker()), List(size), CollectGarbage(false, a-regs, r-regs)))              
            (op) :
              push(Op(op, List(get-var(x(e))), List(get-imm(y(e)))))
        (e:Op2Ins) :
          push(Op(op(e), List(get-var(x(e))), List(get-imm(y(e)), get-imm(z(e)))))
        (e:DualOp2Ins) :
          push(Op(op(e), List(get-var(x(e)), get-var(y(e))), List(get-imm(z(e)), get-imm(w(e)))))
        (e:LoadArgIns) :
          push(Op(LoadArgOp(index(e)), List(get-var(x(e))), List()))      
        (e:StoreArgIns) :
          push(Op(StoreArgOp(index(e)), List(), List(get-imm(y(e)))))
        (e:StoreCArgIns) :
          push(Op(StoreCArgOp(index(e), num-mem-args(e)), List(), List(get-imm(crsp(e)), get-imm(y(e)))))
        (e:LoadCArgIns) :
          push(Op(LoadCArgOp(index(e), num-mem-args(e)), List(get-var(x(e))), List(get-imm(crsp(e)))))
        (e:CRSPIns) :
          push(Op(CRSPOp(), List(get-var(x(e))), List()))
        (e:StoreCRSPIns) :
          push(Op(StoreCRSPOp(), List(), List(get-imm(y(e)))))
        (e:Branch0Ins) :
          push(Branch(op(e), List()))
        (e:Branch1Ins) :
          val op* = op(e) as VMOp
          push(Branch(op*, List(get-imm(x(e)))))
        (e:Branch2Ins) :
          push(Branch(op(e), List(get-imm(x(e)), get-imm(y(e)))))
        (e:MethodDispatchIns) :
          push(MethodDispatch(multi(e), length(ys(e))))
        (e:StoreIns) :      
          push(Op(StoreOp(offset(e)), List(), List(get-imm(x(e)), get-imm(z(e)))))
        (e:LoadIns) :
          push(Op(LoadOp(offset(e)), List(get-var(x(e))), List(get-imm(y(e)))))
        (e:DumpIns) :
          false
        (e:LiveIns) :
          push(Op(NoOp(), List(), get-imms(xs(e))))
        (e:RecordLiveIns) :
          false
        (e:SaveCContextIns) :
          push(Op(SaveCContextOp(), List(), List()))
        (e:CommentIns) :
          false
        (e:UnreachableIns) :
          false
    val next = to-list $
      for s in succs(b) seq :
        index(blocks[s])
    Block(ins-buffer, next)

  ;Add blocks to working set
  add-all(BLOCKS, seq(to-block, /blocks(blocks)))

;Take num 'number' of unused registers
defn unused-regs (used:Seqable<Loc>, num:Int, backend:Backend) :
  val used-set = IntSet()
  for x in used do :
    match(x:Reg) : add(used-set, n(x))
  defn find-unused () :
    for i in 0 to num-regs(backend) find! :
      not used-set[i]
  val unused = Vector<Reg>()
  for i in 0 to num do :
    val n = find-unused()
    add(unused, Reg(n))
    add(used-set, n)
  unused

;============================================================
;================= Critical Edge Removal ====================
;============================================================

defn remove-critical-edges () :
  ;Count predecessors
  val num-preds-table = Array<Int>(nblocks(),0)
  for (b in BLOCKS, i in 0 to false) do :
    for n in next(b) do :
      num-preds-table[n] = 1 + num-preds-table[n]

  ;Create safe blocks
  defn safe-block (n:Int) :
    add(BLOCKS, Block(Vector<Ins>(), List(n)))
    length(BLOCKS) - 1

  ;Create safe blocks for critical edges
  for (blk in BLOCKS, b in 0 to false) do :
    if length(next(blk)) > 1 :
      val next* = for n in next(blk) map :
        if num-preds-table[n] > 1 : safe-block(n)
        else : n
      BLOCKS[b] = Block(ins(blk), next*)

;============================================================
;================== Reverse Post Ordering ===================
;============================================================
defn reverse-post-order () :
  ;Compute ordering
  val blocks = Vector<Block>()
  val mapping = IntTable<False|Int>()
  let order (n:Int = 0) :
    if not key?(mapping, n) :
      mapping[n] = false
      val blk = BLOCKS[n]
      do(order, next(blk))
      mapping[n] = length(blocks)
      add(blocks, blk)

  ;if flag-defined?(`PRINT-REG-ALLOC) :
  ;  println("Reverse post order mapping:")
  ;  do(println, mapping)

  ;New mapping
  val num-blocks = length(blocks)
  defn next* (b:Block) :
    for n in next(b) map :
      val i = mapping[n] as Int
      num-blocks - 1 - i

  ;Update block list
  clear(BLOCKS)
  for b in in-reverse(blocks) do :
    add(BLOCKS, Block(ins(b), next*(b)))

;============================================================
;================= Compute Predecessors =====================
;============================================================
defn compute-predecessors () :
  clear(PREDECESSORS, nblocks(), List())
  for (b in BLOCKS, i in 0 to false) do :
    for n in next(b) do :
      PREDECESSORS[n] = cons(i, PREDECESSORS[n])

;============================================================
;==================== Two Index Map =========================
;============================================================

deftype BitMatrix
defmulti get (m:BitMatrix, r:Int, c:Int) -> True|False
defmulti set (m:BitMatrix, r:Int, c:Int, v:True|False) -> False

public defn BitMatrix (rows:Int, cols:Int) :
  val n = rows * cols
  if n >= 0 and n < 8 * 1024 * 1024 :
    val array = BitArray(rows * cols, false)
    new BitMatrix :
      defmethod get (this, r:Int, c:Int) : array[r * cols + c]
      defmethod set (this, r:Int, c:Int, v:True|False) : array[r * cols + c] = v
  else :
    val hashset = HashSet<Long>()
    new BitMatrix :
      defmethod get (this, r:Int, c:Int) :
        hashset[cat-ints(r,c)]
      defmethod set (this, r:Int, c:Int, v:True|False) :
        if v : add(hashset, cat-ints(r,c))
        else : remove(hashset, cat-ints(r,c))
        false

lostanza defn cat-ints (a:ref<Int>, b:ref<Int>) -> ref<Long> :
  return new Long{(a.value << 32L) | b.value}

;============================================================
;================== Liveness Analysis =======================
;============================================================

defstruct VarUse :
  block: Int
  dist: Int

defn crosses-boundary? (i:Ins) :
  match(i:Call) :
    type(i) is-not ExtendStack

defn liveness-analysis () :
  ;Clear state
  val var-uses = Array<List<VarUse>>(nvars(), List())
  val block-defs = BitMatrix(nblocks(), nvars())

  ;Mark uses and defs
  for (blk in BLOCKS, i in 0 to false) do :
    ;Marking functions
    defn mark-defined (v:Var) : block-defs[i, n(v)] = true
    defn defined? (v:Var) : block-defs[i, n(v)]
    defn mark-used (v:Var, d:Int) :
      if not defined?(v) :
        val use = VarUse(i,d)
        var-uses[n(v)] = cons(use, var-uses[n(v)])
    ;Mark instructions
    for (e in ins(blk), i in 0 to false) do :
      do-used(mark-used{_, i}, e)
      do-defined(mark-defined, e)

  ;Propagate liveness
  clear(IN-PORTS, nblocks(), List())
  clear(OUT-PORTS, nblocks(), List())
  val in-dists = Array<Int>(nblocks(), INT-MAX)
  val out-dists = Array<Int>(nblocks(), INT-MAX)
  val in-dirty = Vector<Int>()
  val out-dirty = Vector<Int>()

  ;For each variable
  for (v in 0 to nvars(), uses in var-uses) do :
    if not empty?(uses) :
      ;Mark all usages of the variable
      clear(in-dirty)
      clear(out-dirty)
      for use in uses do :
        mark-live-in(block-defs, in-dists, out-dists, in-dirty, out-dirty,
                     block(use), v, dist(use))
      ;Record all live in ports
      for b in in-dirty do :
        val p = Port(v, false, false, false, in-dists[b])
        IN-PORTS[b] = cons(p, IN-PORTS[b])
        in-dists[b] = INT-MAX
      ;Record all live in ports
      for b in out-dirty do :
        val p = Port(v, false, false, false, out-dists[b])
        OUT-PORTS[b] = cons(p, OUT-PORTS[b])
        out-dists[b] = INT-MAX

;Mark that variable v is live-in to block b with distance d
lostanza defn mark-live-in (defs:ref<BitMatrix>,
                            in-dists:ref<Array<Int>>,
                            out-dists:ref<Array<Int>>,
                            in-dirty:ref<Vector<Int>>,
                            out-dirty:ref<Vector<Int>>,
                            b:ref<Int>,
                            v:ref<Int>,
                            d:ref<Int>) -> ref<False> :
  ;Only mark if distance is smaller
  val old-value = get(in-dists, b).value
  if d.value >= old-value : return false
  set(in-dists, b, d)

  ;Note that block b has been marked
  if old-value == INT-MAX.value :
    add(in-dirty, b)

  ;Loop through all predecessors of block
  ;and mark variable v as live-out from them
  labels :
    begin :
      goto loop(get(PREDECESSORS, b))
    loop (preds:ref<List<Int>>) :
      if empty?(preds) == false :
        mark-live-out(defs, in-dists, out-dists, in-dirty, out-dirty, head(preds), v, d)
        goto loop(tail(preds))

  ;Done
  return false


;Mark that variable v is live-out from block b with distance d
lostanza defn mark-live-out (defs:ref<BitMatrix>,
                             in-dists:ref<Array<Int>>,
                             out-dists:ref<Array<Int>>,
                             in-dirty:ref<Vector<Int>>,
                             out-dirty:ref<Vector<Int>>,
                             b:ref<Int>,
                             v:ref<Int>,
                             d:ref<Int>) -> ref<False> :
  ;Only mark if distance is smaller
  val old-value = get(out-dists, b).value
  if d.value >= old-value : return false
  set(out-dists, b, d)

  ;Note that block b has been marked
  if old-value == INT-MAX.value :
    add(out-dirty, b)

  ;Mark variable v as live-in to block if not defined in block
  if get(defs, b, v) == false :
    val d* = new Int{d.value + length(ins(get(BLOCKS, b))).value}
    mark-live-in(defs, in-dists, out-dists, in-dirty, out-dirty, b, v, d*)

  ;Done
  return false

;============================================================
;===================== Add Annotations ======================
;============================================================

defn add-annotations () :
  do(add-annotations, BLOCKS, 0 to false)
  
  ;Sanity check
  val p0 = IN-PORTS[0]  
  if not empty?(p0) :
    fatal("Variables %, are live upon entry." % [seq(n, p0)])  

defn add-annotations (blk:Block, b:Int) :
  ;===========================
  ;==== Liveness Tracking ====
  ;===========================
  val usages = Array<False|Int>(nvars(), false)
  val live-dirty = Vector<Int>()

  defn mark-used (n:Int, dist:Int) :
    add(live-dirty, n)
    usages[n] = dist

  defn mark-defined (n:Int) :
    usages[n] = false

  defn live? (n:Int) :
    usages[n] is Int

  defn do-live (f: Int -> ?) :
    for x in live-dirty remove-when :
      if live?(x) : (f(x), false)
      else : true

  ;=============================
  ;==== Preference Tracking ====
  ;=============================
  ;The remaining code prefers the variable to be loaded.
  val prefers-load = Array<True|False>(nvars(), true)

  ;The remaining code expects the variable to be saved.
  val requires-save = Array<True|False>(nvars(), false)

  ;============================
  ;==== Instruction Buffer ====
  ;============================
  val instructions = Vector<Ins>()
  defn emit (e:Ins) : add(instructions, e)

  ;==========================
  ;==== Port Information ====
  ;==========================
  defn annotate (p:Port) :
    val v = n(p)
    Port(v, requires-save[v], prefers-load[v], reg(p), dist(p))

  ;===================
  ;==== Algorithm ====
  ;===================
  ;Note usages of output ports
  val num-ins = length(ins(blk))
  for p in OUT-PORTS[b] do :
    mark-used(n(p), num-ins + dist(p))

  for (e in in-reverse(ins(blk)), i in (num-ins - 1) through 0 by -1) do :
    ;Return true if e is a dead Def instruction?
    defn dead-def? (e:Ins) :
      match(e:Def) :
        not live?(n(x(e)))
      
    ;Notate next usages of variables
    for x in e do-vars :
      if live?(n(x)) :
        emit(NextUsed(n(x), usages[n(x)] as Int))
        
    if not dead-def?(e) :    
      reverse-sweep(e
        ;Defined
        fn (x:Var):
          ;Unload the variable if it is never used
          if not live?(n(x)) :
            emit(Unload(n(x)))
          ;Otherwise unload the variable if it doesn't prefer to be loaded.
          else if not prefers-load[n(x)] :
            emit(Unload(n(x)))
          ;Save the variable if it needs to be saved
          if requires-save[n(x)] :
            emit(Save(x))
          ;Variable is no longer live
          mark-defined(n(x))
          requires-save[n(x)] = false
          prefers-load[n(x)] = false
        ;Emit
        fn (e:Ins) :
          val killed = to-list(filter({not live?(_)}, used-vars(e)))
          emit(attach-killed(e, to-list(killed)))
          ;Cross call boundary
          if crosses-boundary?(e) :
            val live-set = IntSet()
            do-live $ fn (x) :
              add(live-set, x)
              requires-save[x] = true
              prefers-load[x] = false
            val live-vars = to-tuple(seq(Var,live-set))
            emit(Op(RecordLiveOp(live-vars), List(), List(), List()))
        ;Used
        fn (x:Var) :
          mark-used(n(x), i)
          prefers-load[n(x)] = true)

  ;Update block/ports
  reverse!(instructions)
  BLOCKS[b] = Block(instructions, next(blk))
  IN-PORTS[b] = map(annotate, IN-PORTS[b])

;============================================================
;===================== Allocate Classes =====================
;============================================================

;Note over-provisioning of AllocOp/InstanceofOp/HasHeapOp/Match
;due to bug in register assignment.
;Occurs when registers are completedly used (max register pressure)
;and the argument to match is killed during the match statement.
defn num-scratch-registers (i:Ins) :
  match(i) :
    (i:Call) :
      match(type(i)) :
        (t:YieldCall) : 2
        (t) : 0
    (i:Op) :
      match(op(i)) :
        (op:AllocOp) : 4
        (op:InstanceofOp) : 4
        (op) : 0
    (i:Branch) :
      match(op(i)) :
        (op:HasHeapOp) : 4
        (op) : 0
    (i:Match) : 4
    (i:MethodDispatch) : 0
    (i) : 0

defn allocate-classes (backend:Backend) :
  for (blk in BLOCKS, b in 0 to false) do :
    allocate-classes(blk, b, backend)

defn allocate-classes (blk:Block, b:Int, backend:Backend) :
  ;================================
  ;==== Free Register Tracking ====
  ;================================
  ;Track number of registers used
  var num-free-reg = num-regs(backend)
  var num-free-freg = num-fregs(backend)
  defn inc-reg (n:Int, delta:Int) :
    match(VAR-TYPES[n]) :
      (t:VMType&IntegerT) : num-free-reg = num-free-reg + delta
      (t:VMType&RealT) : num-free-freg = num-free-freg + delta
  defn num-free (integer?:True|False) :
    if integer? : num-free-reg
    else : num-free-freg

  ;============================
  ;==== Load/Save Tracking ====
  ;============================
  ;Track whether a variable has been loaded/saved
  val loaded = BitArray(nvars())
  val saved = BitArray(nvars())
  val dirty-loaded = Vector<Int>()
  ;Mark variable n as loaded, returns true if the variable wasn't
  ;already loaded.
  defn mark-loaded (n:Int) -> True|False :
    if not loaded[n] :
      add(dirty-loaded, n)
      loaded[n] = true
      inc-reg(n, -1)
      true
  defn mark-unloaded (n:Int) -> True|False :
    if loaded[n] :
      loaded[n] = false
      inc-reg(n, 1)
      true
  defn mark-saved (n:Int) -> True|False :
    if not saved[n] :
      saved[n] = true
      true
  defn mark-defined (n:Int) -> False :
    mark-loaded(n)
    saved[n] = false
  ;Return all currently loaded variables
  defn loaded-vars () -> Seq<Int> :
    filter({loaded[_]}, dirty-loaded)
  ;Mark all variables as unloaded
  defn mark-all-unloaded () :
    do(mark-unloaded, loaded-vars())
    clear(dirty-loaded)

  ;========================
  ;==== Usage Tracking ====
  ;========================
  val usages = Array<Int|False>(nvars(), false)
  defn mark-next-use (n:Int, pos:Int) :
    usages[n] = pos
  defn next-use (n:Int) :
    usages[n]

  ;=================
  ;==== Actions ====
  ;=================
  defn add?<?T> (xs:False|Vector<?T>, x:T) :
    match(xs:Vector<T>) : add(xs, x)
  defn ensure-saved (n:Int, buffer:False|Vector<Ins>) :
    add?(buffer, Save(Var(n))) when mark-saved(n)
  defn ensure-loaded (n:Int, buffer:False|Vector<Ins>) :
    add?(buffer, Load(Var(n))) when mark-loaded(n)
  defn ensure-unloaded (n:Int, buffer:False|Vector<Ins>) :
    add?(buffer, Unload(n)) when mark-unloaded(n)

  ;==================
  ;==== Spilling ====
  ;==================
  ;Find next variable to spill
  defn next-spill-var (integer?:True|False) :
    defn right-type? (n:Int) :
      if integer? : VAR-TYPES[n] is VMType&IntegerT
      else : VAR-TYPES[n] is VMType&RealT
    argmax(next-use, filter(right-type?, loaded-vars()))
  ;Spill one register
  defn spill-reg (integer?:True|False, buffer:False|Vector<Ins>) :
    val v = next-spill-var(integer?)
    ensure-saved(v, buffer)
    ensure-unloaded(v, buffer)
  ;Ensure free register for var
  defn ensure-reg-for-var (n:Int, buffer:False|Vector<Ins>) :
    if not loaded[n] :
      val int? = VAR-TYPES[n] is VMType&IntegerT
      if num-free(int?) < 1 :
        spill-reg(int?, buffer)

  ;==========================
  ;==== Port Information ====
  ;==========================
  defn annotate (p:Port) :
    val v = n(p)
    Port(v, saved[v], loaded[v], reg(p), dist(p))

  ;===================
  ;==== Algorithm ====
  ;===================
  ;Load as many input ports into registers as possible
  for p in IN-PORTS[b] do :
    val v = n(p)
    mark-loaded(v) when loaded?(p)
    mark-saved(v) when saved?(p)
    mark-next-use(v, dist(p))
  ;Spill overcommitted registers
  while num-free-reg < 0 : spill-reg(true, false)
  while num-free-freg < 0 : spill-reg(false, false)
  ;Annotate input ports
  IN-PORTS[b] = map(annotate, IN-PORTS[b])

  ;Sweep through instructions
  val instructions = Vector<Ins>()
  val buffer = Vector<Ins>()
  for e in ins(blk) do :
    match(e) :
      (e:NextUsed) :
        mark-next-use(n(e), pos(e))
      (e:Unload) :
        ensure-unloaded(n(e), instructions)
      (e:Save) :
        ensure-saved(n(x(e)), instructions)
      (e) :
        ;Load arguments
        for x in e do-used :
          ensure-reg-for-var(n(x), instructions)
          ensure-loaded(n(x), buffer)
        ;Emit instruction
        add(buffer, e)
        ;Unload registers
        if crosses-boundary?(e) : mark-all-unloaded()
        else : do(mark-unloaded, killed(e))
        ;Define new variables
        for x in e do-defined :
          ensure-reg-for-var(n(x), instructions)
          mark-defined(n(x))
        ;Reserve scratch registers
        val num-scratch = num-scratch-registers(e)
        while num-free-reg < num-scratch :
          spill-reg(true, instructions)
        ;Flush buffer instructions
        add-all(instructions, buffer)
        clear(buffer)

  ;Update block and output ports
  BLOCKS[b] = Block(instructions, next(blk))
  OUT-PORTS[b] = map(annotate, OUT-PORTS[b])

;Utility
defn argmax<?T> (f:T -> False|Int, xs:Seqable<?T>) -> T :
  var best-x
  var best-v = INT-MIN
  for x in xs do :
    val v = f(x)
    match(v:Int) :
      if v > best-v :
        best-x = x
        best-v = v
  best-x

;============================================================
;================== Register Assignment =====================
;============================================================

;=======================
;==== Free Register ====
;=======================
defstruct FreeReg <: Loc :
  prefer: List<Int>

defn FreeReg () :
  FreeReg(List())

defn PrefReg (xs:List<Imm>) :
  val regs = for x in xs seq? :
    match(x:Var) :
      match(reg?(x)) :
        (r:Reg|FReg) : One(n(r))
        (r:False) : None()
    else : None()
  FreeReg(to-list(regs))

defn PrefReg (x:Imm) :
  PrefReg(List(x))

defmethod print (o:OutputStream, r:FreeReg) :
  print(o, "FreeReg(%,)" % [prefer(r)])
  
;===================
;==== Algorithm ====
;===================
defn register-assignment (backend:Backend) :
  for (blk in BLOCKS, b in 0 to false) do :
    register-assignment(blk, b, backend)

defn register-assignment (blk:Block, b:Int, backend:Backend) :
  ;============================
  ;==== Instruction Buffer ====
  ;============================
  val instructions = Vector<Ins>()
  defn emit (e:Ins) : add(instructions ,e)

  ;===========================
  ;==== Register Tracking ====
  ;===========================
  val var-locs = Array<False|Reg|FReg>(nvars(), false)
  val reg-slots = Array<False|Int>(num-regs(backend), false)
  val freg-slots = Array<False|Int>(num-fregs(backend), false)
  val reg-list = FreeList(num-regs(backend))
  val freg-list = FreeList(num-fregs(backend))

  ;Set and retrieve variable occupying a register      
  defn free-slot (r:Reg|FReg) :
    match(r) :
      (r:Reg) : (reg-slots[n(r)] = false, remove(reg-list, n(r)))
      (r:FReg) : (freg-slots[n(r)] = false, remove(freg-list, n(r)))

  defn assign-slot (r:Reg|FReg, x:Int) :
    match(r) :
      (r:Reg) : (reg-slots[n(r)] = x, add(reg-list, n(r)))
      (r:FReg) : (freg-slots[n(r)] = x, add(freg-list, n(r)))

  defn slot (r:Reg|FReg) :
    match(r) :
      (r:Reg) : reg-slots[n(r)]
      (r:FReg) : freg-slots[n(r)]

  ;Retrieve register listing
  defn all-regs (t:VMType) :
    match(t:VMType&IntegerT) : seq(Reg, cat(free(reg-list), reg-list))
    else : seq(FReg, cat(free(freg-list), freg-list))

  ;Free the variable x from its register, if it is in one
  defn free-var (x:Int) :
    match(var-locs[x]) :
      (reg:Reg|FReg) :
        free-slot(reg)
        var-locs[x] = false
      (reg:False) :
        false

  ;Free the contents of a register
  defn free-reg (r:Reg|FReg) :
    match(slot(r)) :
      (v:Int) :
        free-slot(r)
        var-locs[v] = false
      (v:False) :
        false

  ;Free all registers
  defn free-all-regs () :
    for n in reg-list do :
      val v = reg-slots[n] as Int
      reg-slots[n] = false
      var-locs[v] = false
    for n in freg-list do :
      val v = freg-slots[n] as Int
      freg-slots[n] = false
      var-locs[v] = false
    clear(reg-list)
    clear(freg-list)

  ;Find an available register (assumes that one is available).
  defn free-reg? (t:VMType) :
    match(t) :
      (t:VMType&IntegerT) :
        val rs = free(reg-list)
        Reg(next(rs)) when not empty?(rs)
      (t:VMType&RealT) :
        val rs = free(freg-list)
        FReg(next(rs)) when not empty?(rs)    
  defn available-reg? (t:VMType, pref:List<Int>) :
    val pref-regs = seq(XReg{t, _}, pref)
    val r = find({slot(_) is False}, pref-regs)
    match(r:Reg|FReg) : r
    else : free-reg?(t)
  defn available-reg (t:VMType, pref:List<Int>) :
    available-reg?(t,pref) as Reg|FReg

  ;Assign a variable to a location
  defn assign (x:Int, r:Loc) :
    match(r) :
      (r:Reg|FReg) :
        fatal("Register %_ is occupied" % [r]) when slot(r) is-not False
        var-locs[x] = r
        assign-slot(r, x)
      (r:FreeReg) :
        assign(x, available-reg(VAR-TYPES[x], prefer(r)))

  ;Convenience
  defn assign (x:Var|Port, r:Loc) :
    assign(n(x), r)
  defn assign (xs:List<Var|Port>, r:Loc) :
    do(assign{_, r}, xs)

  ;Assign several locations
  defn assign (xs:List<Var|Port>, rs:List<Loc>) :
    for (x in xs, r in rs) do :
      assign(x, r) when r is-not FreeReg
    for (x in xs, r in rs) do :
      assign(x, r) when r is FreeReg

  ;==============================
  ;==== Port/Var Information ====
  ;==============================
  defn annotate (p:Port) :
    var reg = var-locs[n(p)]
    Port(n(p), saved?(p), reg is Reg|FReg, reg, dist(p))
  defn annotate<?T> (x:?T&Imm) -> T :
    match(x:Var) : Var(n(x), var-locs[n(x)]) as T&Imm
    else : x

  ;===========================
  ;==== Register Swapping ====
  ;===========================
  ;Move contents of src into dst.
  ;If dst is occupied, then swap the contents of the two registers.
  defn swap-reg (src:Reg|FReg, dst:Reg|FReg) :    
    val x = slot(src) as Int
    match(slot(dst)) :
      ;Dst is unoccupied: Emit move
      (y:False) :
        emit(Set(Var(x,dst), Var(x,src)))
        free-var(x)
        assign(x,dst)
      ;Dst is occupied: Emit swap
      (y:Int) :
        match(src:Reg) :
          emit(Xchg(Var(x,src), Var(y,dst), false))
        else :        
          val swap = available-reg?(VMFloat(), List())
          emit(Xchg(Var(x,src), Var(y,dst), swap))        
        free-var(x)
        free-var(y)
        assign(x,dst)
        assign(y,src)

  ;Ensure that regs will be available once xs are freed
  defn ensure-available (regs:List<Reg|FReg>, xs:List<Int>) :
    ;Will be available
    defn available? (r:Reg|FReg) :
      match(slot(r)) :
        (x:Int) : contains?(xs,x)
        (x:False) : true
    ;Swap candidates
    defn safe-swap? (r:Reg|FReg) :
      available?(r) and not contains?(regs, r)

    ;Compute swap registers
    val swaps = lazy(filter{safe-swap?, all-regs(VMInt())})
    val fswaps = lazy(filter{safe-swap?, all-regs(VMFloat())})
      
    ;Swap out registers
    for r in regs do :
      if not available?(r) :
        swap-reg{r, next(_)} $
          match(r:Reg) : swaps()
          else : fswaps()

  ;Ensure that value x is in register r
  defn ensure-location (x:Int, reg:Reg|FReg) :
    val src = var-locs[x] as Reg|FReg
    swap-reg(src, reg) when src != reg

  ;===================
  ;==== Shuffling ====
  ;===================
  defn par-mov (xs:List<Loc>, ys:List<Var>) :
    ;Categorize
    val shuffles = Vector<KeyValue<Int,Int>>() ;dst => src
    val fshuffles = Vector<KeyValue<Int,Int>>() ;dst => src
    for (x in xs, y in ys) do :
      match(x) :
        (x:Reg) : add(shuffles, n(x) => n(reg(y)))
        (x:FReg) : add(fshuffles, n(x) => n(reg(y)))
    ;Emit shuffles
    emit(ShuffleReg(keys(shuffles), values(shuffles)))
    emit(ShuffleFReg(keys(fshuffles), values(fshuffles)))
    ;Update table
    do(free-reg, xs as List<Reg|FReg>) ;Free all destination registers
    do(free-var{n(_)}, ys)             ;Free all source variables
    assign(ys, xs)                     ;Assign to destination registers

  ;===================
  ;==== Algorithm ====
  ;===================
  ;Assign input ports
  val in-ports = IN-PORTS[b]
  if not empty?(in-ports) :
    ;Retrieve output ports of predecessor block
    val pred = find!({_ < b}, PREDECESSORS[b])
    val port-table = Array<Port>(nvars())
    for p in OUT-PORTS[pred] do : port-table[n(p)] = p
    ;Calculate port locations
    val port-assigns = to-list $ for p in in-ports seq? :
      match(loaded?(p), reg(port-table[n(p)])) :
        (l1:True, r:Reg|FReg) : One(p => r)
        (l1:True, r:False) : One(p => FreeReg())
        (l1:False, r) : None()
    ;Assign ports
    assign(map(key, port-assigns), map(value, port-assigns))
    IN-PORTS[b] = map(annotate, in-ports)

  ;Constants
  val list-r0-r1 = List(Reg(0), Reg(1))

  ;Sweep through instructions
  for e in ins(blk) do :
    match(e) :
      (e:Def) :
        assign(x(e), FreeReg())
        emit(Def(annotate(x(e)), killed?(e)))
      (e:Set) :
        val y* = annotate(y(e))
        do(free-var, killed(e))
        assign(x(e), PrefReg(y*))
        emit(Set(annotate(x(e)), y*, killed?(e)))
      (e:Branch) :
        match(op(e)) :
          (op:HasHeapOp) : ensure-available(list-r0-r1, List())
          (op) : false        
        emit(Branch(op(e), map(annotate, xs(e)), killed?(e)))
        do(free-var, killed(e))
      (e:Return) :
        par-mov(regs(ctxt(e)), map(annotate,xs(e)) as List<Var>)
        val xs* = map(annotate, xs(e))
        emit(Return(xs*, ctxt(e), killed?(e)))
        do(free-var, killed(e))
      (e:Args) :
        do(free-var, killed(e))
        assign(xs(e), regs(ctxt(e)))
        emit(Args(map(annotate,xs(e)), ctxt(e), killed?(e)))
      (e:Call) :
        val f* = annotate(f(e))
        val ys* = map(annotate,ys(e)) as List<Var>

        ;Retrieve special registers
        defn func-reg! (t:CallType) :
          func-reg(t as StanzaCall|CCall|YieldCall|StanzaTCall) as Reg
        defn arg-regs! (t:CallType) :
          match(t) :
            (t:StanzaCall|CCall|YieldCall|StanzaTCall|CollectGarbage) : arg-regs(t)
            (t) : List()
        defn ret-regs! (t:CallType) :
          match(t) :
            (t:StanzaCall|CCall|YieldCall|CollectGarbage) : ret-regs(t)
            (t) : List()            

        ;Move arguments into place
        match(f*) :
          (f*:Var) :
            val freg = func-reg!(type(e))
            par-mov(cons(freg, arg-regs!(type(e))), cons(f*,ys*))
          (f*:Val) :
            par-mov(arg-regs!(type(e)), ys*)
            
        ;New shuffled arguments
        val f** = annotate(f(e))
        val ys** = map(annotate, ys(e))
        ;Free all registers
        free-all-regs()
        ;Move return values into place
        assign(xs(e), ret-regs!(type(e)))
        ;Emit
        emit(Call(map(annotate,xs(e)), f**, ys**, type(e), killed?(e)))
      (e:Save) :
        emit(Save(annotate(x(e))))
      (e:Load) :
        assign(x(e), FreeReg())
        emit(Load(annotate(x(e))))
      (e:Unload) :
        free-var(n(e))
      (e:Match) :
        ensure-available(list-r0-r1, List())
        val xs* = map(annotate, xs(e))
        emit(Match(dispatch?(e), type-lists(e), xs*, killed?(e), ns?(e)))
        do(free-var, killed(e))        
      (e:MethodDispatch) :
        emit(e)
      (e:Op) :
        defn assign-prefs (pref:List<Imm> -> Loc|List<Loc>) :
          val ys* = map(annotate, ys(e))
          do(free-var, killed(e))
          assign(xs(e), pref(ys*))
          val xs* = map(annotate, xs(e))
          emit(Op(op(e), xs*, ys*, killed?(e)))
        defn assign-prefs (loc:Loc|List<Loc>) :
          assign-prefs({loc})

        match(op(e)) :
          ;Prefers first argument
          (op:SubOp|DivOp|ModOp) :
            assign-prefs(PrefReg{head(_)})
          ;Prefers any argument
          (op:LoadOp|AddOp|MulOp|AndOp|OrOp|XorOp|
              NotOp|NegOp|ConvOp|InterpretOp) :
            assign-prefs(PrefReg)
          ;Second argument in R2, prefer first argument
          (op:ShlOp|ShrOp|AshrOp) :
            val y = ys(e)[1]
            match(y:Var) : ensure-location(n(y), Reg(2))
            assign-prefs(PrefReg{head(_)})
          ;Requires R0,R3
          (op:DivModOp) :
            val rs = List(Reg(0), Reg(3))
            ensure-available(rs, killed(e))
            assign-prefs(rs)
          ;AllocOp
          (op:AllocOp|InstanceofOp) :
            ensure-available(List(Reg(0), Reg(1)), List())
            assign-slot(Reg(0), -1)
            assign-slot(Reg(1), -1)
            assign-prefs(FreeReg())
            free-slot(Reg(0))
            free-slot(Reg(1))
          ;Noop
          (op:NoOp) :
            do(free-var, killed(e))
          ;Any register will do
          (op) :
            assign-prefs(FreeReg())
      (e) :
        fatal("%_ not supported." % [e])

  ;Update block/ports
  BLOCKS[b] = Block(instructions, next(blk))
  OUT-PORTS[b] = map(annotate, OUT-PORTS[b])

;============================================================
;==================== Stack Intervals =======================
;============================================================

;=======================
;==== Datastructure ====
;=======================

deftype Interval
defstruct StartInterval <: Interval : (n:Int)
defstruct EndInterval <: Interval : (n:Int)

defmethod print (o:OutputStream, i:Interval) :
  print{o, _} $ match(i) :
    (i:StartInterval) : "V%_ starts" % [n(i)]
    (i:EndInterval) : "V%_ ends" % [n(i)]

;===================
;==== Algorithm ====
;===================

defn stack-intervals () -> Seq<Interval> :
  ;========================
  ;==== Port Positions ====
  ;========================
  val in-port-pos = Array<Int>(nblocks())
  val out-port-pos = Array<Int>(nblocks())
  val num-pos = let :
    val pos-counter = Counter(0)
    for (blk in BLOCKS, b in 0 to false) do :
      in-port-pos[b] = next(pos-counter, 1 + length(ins(blk)))
      out-port-pos[b] = value(pos-counter)
    value(pos-counter) + 1

  ;===========================
  ;==== Interval Tracking ====
  ;===========================
  val var-start = Array<Int>(nvars(), INT-MAX)
  val var-end = Array<Int>(nvars(), INT-MIN)

  defn note-usage (v:Int, i:Int) :
    var-start[v] = min(i, var-start[v])
    var-end[v] = max(i, var-end[v])

  defn note-in-port-usage (b:Int, v:Int) :
    note-usage(v, in-port-pos[b])
    for b in PREDECESSORS[b] do :
      note-usage(v, out-port-pos[b])

  defn note-out-port-usage (b:Int, v:Int) :
    note-usage(v, out-port-pos[b])
    for b in next(BLOCKS[b]) do :
      note-usage(v, in-port-pos[b])

  defn sorted-intervals () :
    val ints = Array<List<Interval>>(num-pos, List())
    defn add-interval (i:Int, x:Interval) :
      ints[i] = cons(x, ints[i])
    for v in 0 to nvars() do :
      if var-start[v] <= var-end[v] :
        add-interval(var-end[v], EndInterval(v))
    for v in 0 to nvars() do :
      if var-start[v] <= var-end[v] :
        add-interval(var-start[v], StartInterval(v))
    cat-all(ints)

  ;===================
  ;==== Algorithm ====
  ;===================
  val pos-counter = Counter(0)
  for (blk in BLOCKS, b in 0 to false) do :
    ;In port usages
    for p in IN-PORTS[b] do :
      note-in-port-usage(b, n(p)) when saved?(p)
    next(pos-counter, 1)

    ;Instruction usages
    for e in ins(blk) do :
      val pos = next(pos-counter, 1)
      match(e) :
        (e:Save) : note-usage(n(x(e)), pos)
        (e:Load) : note-usage(n(x(e)), pos)
        (e:Op) :
          match(op(e)) :
            (op:RecordLiveOp) : do(note-usage{n(_), pos}, live-vars(op))
            (op) : false
        (e) : false

    ;Out port usages
    for p in OUT-PORTS[b] do :
      note-out-port-usage(b, n(p)) when saved?(p)

  ;Return intervals
  sorted-intervals()

;============================================================
;===================== Stack Map ============================
;============================================================

deftype StackMap
defmulti location (m:StackMap, n:Int) -> False|Int
defmulti offset (m:StackMap, n:Int) -> Int
defmulti locations (m:StackMap) -> Vector<VMType>
defmulti offsets (m:StackMap) -> Vector<Int>
defmulti size (m:StackMap) -> Int

defn int-type-matching-size (t:VMType) :
  match(t) :
    (t:VMFloat) : VMInt()
    (t:VMDouble) : VMLong()
    (t:VMType&IntegerT) : t

defn stack-map () :
  ;===========================
  ;==== Location Tracking ====
  ;===========================
  val occupied-locs = Vector<True|False>()
  val loc-types = Vector<VMType>()
  val var-locs = Array<False|Int>(nvars(), false)

  ;Get next available location
  defn available-loc (t:VMType) :
    val t* = int-type-matching-size(t)
    val n = length(occupied-locs)
    val i = for i in 0 to n find :
      (not occupied-locs[i]) and
      (loc-types[i] == t*)
    match(i) :
      (i:Int) :
        i
      (i:False) :
        add(occupied-locs, false)
        add(loc-types, t*)
        n

  ;Place variable v in location loc
  defn assign-var (v:Int, loc:Int) :
    var-locs[v] = loc
    occupied-locs[loc] = true

  ;Release variable v from its location
  defn release-var (v:Int) :
    val l = var-locs[v] as Int
    occupied-locs[l] = false

  ;===================
  ;==== Algorithm ====
  ;===================
  for int in stack-intervals() do :
    match(int) :
      (int:StartInterval) :
        val t = VAR-TYPES[n(int)]
        assign-var(n(int), available-loc(t))
      (int:EndInterval) :
        release-var(n(int))

  ;=====================================
  ;==== Size and Offset Computation ====
  ;=====================================
  val offsets = Vector<Int>()
  val stack-size = let :
    val [padded, alignment] = pad(size, size, loc-types, 8)
    val offset-counter = Counter(16) ;RET + STACK-MAP
    for x in padded do :
      match(x) :
        (x:Padding) : next(offset-counter, size(x))
        (x:VMType) : add(offsets, next(offset-counter, size(x)))
    value(offset-counter)

  ;Return Map
  new StackMap :
    defmethod location (this, n:Int) : var-locs[n]
    defmethod locations (this) : loc-types
    defmethod offsets (this) : offsets
    defmethod size (this) : stack-size
    defmethod offset (this, n:Int) : offsets[var-locs[n] as Int]

defmethod print (o:OutputStream, s:StackMap) :
  ;Discover vars per location
  val vars = Array<List<Int>>(length(locations(s)), List())
  for v in 0 to nvars() do :
    val loc = location(s, v)
    match(loc:Int) :
      vars[loc] = cons(v, vars[loc])
  ;Print
  print(o, "Stackmap:")
  for (t in locations(s), i in 0 to false) do :
    defn V# (i:Int) : "V%_" % [i]
    print(o, "\n  loc %_ : %_ (%,)" % [i, t, seq(V#, vars[i])])

defn num-locations (s:StackMap) :
  length(locations(s))

defn refmask (s:StackMap) :
  val mask = Array<True|False>(size(s) / 8, false)
  for (t in locations(s), offset in offsets(s)) do :
    match(t:VMRef) : mask[offset / 8] = true
  [length(mask), to-bitmask(mask)]

defn ref-offsets (s:StackMap) :
  for (offset in offsets(s), t in locations(s)) filter :
    t is VMRef
    


;============================================================
;==================== Shuffling Engine ======================
;============================================================

;=====================
;==== Root Finder ====
;=====================
defn roots (nreg:Int, xs:List<Int>, ys:List<Int>) :
  ;Compute all sources
  val srcs = Array<False|Int>(nreg, false)
  val dsts = Array<List<Int>>(nreg, List())
  for (x in xs, y in ys) do :
    srcs[x] = y
    dsts[y] = cons(x, dsts[y])

  ;Compute the source
  val visited = Array<True|False>(nreg, false)
  defn root (x:Int) :
    visit(x)
    match(srcs[x]) :
      (s:Int) :
        if visited[s] : x
        else : root(s)
      (s:False) : x
  defn visit (x:Int) :
    if not visited[x] :
      visited[x] = true
      do(visit, dsts[x])

  ;Return all roots
  for y in ys seq? :
    if visited[y] : None()
    else : One(root(y))

;=========================================
;==== Shuffling with Swap Instruction ====
;=========================================
defn shuffle (nreg:Int, xs:List<Int>, ys:List<Int>,
              emit-move: (Int, Int) -> False
              emit-swap: (Int, Int) -> False) :
  ;Compute all destinations
  val dsts = Array<List<Int>>(nreg, List())
  for (x in xs, y in ys) do :
    dsts[y] = cons(x, dsts[y])

  val visited = Array<False|True>(nreg, false)
  defn move (src:Int) -> True|False :
    ;Mark visited
    visited[src] = true
    ;Track swapped
    var swapped? = false
    ;Move all destinations
    for dst in dsts[src] do :
      if dst != src :
        if visited[dst] :
          swapped? = true
        else if move(dst) :
          emit-swap(src, dst)
          swapped? = true
        else :
          emit-move(src, dst)
    ;Return whether swapped?
    swapped?

  ;Start from roots
  do(move, roots(nreg, xs, ys))

;======================================
;==== Shuffling with Swap Register ====
;======================================
defn shuffle (nreg:Int, xs:List<Int>, ys:List<Int>, swap:Int
              emit-move: (Int, Int) -> False) :
  ;Compute destinations
  val dsts = Array<List<Int>>(nreg, List())
  for (x in xs, y in ys) do :
    dsts[y] = cons(x, dsts[y])

  val visited = Array<False|True>(nreg, false)
  defn move (src:Int) -> True|False :
    ;Mark visited
    visited[src] = true
    ;Track whether swap used
    var swapped? = false
    ;Move all destinations
    for dst in dsts[src] do :
      if dst != src :
        if visited[dst] :
          emit-move(src, swap)
          swapped? = true
        else :
          swapped? = move(dst) or swapped?
          emit-move(src, dst)
    ;Return whether swap used?
    swapped?

  ;Start from roots
  for y in roots(nreg, xs, ys) do :
    emit-move(swap, y) when move(y)

;=========================================
;==== Shuffling without Swap Register ====
;=========================================
defn shuffle (nreg:Int, xs:List<Int>, ys:List<Int>
              emit-move: (Int, Int) -> False,
              emit-save: Int -> False,
              emit-load: Int -> False) :
  ;Find a register with no destination
  defn free? (x:Int) : not contains?(cat(xs, ys), x)
  match(find(free?, 0 to nreg)) :
    (swap:Int) :
      shuffle(nreg, xs, ys, swap, emit-move)
    (swap:False) :
      shuffle(nreg, xs, ys, -1,
        fn (src:Int, dst:Int) :
          if dst == -1 : emit-save(src)
          else if src == -1 : emit-load(dst)
          else : emit-move(src, dst))

;============================================================
;=============== Flipped Comparison Operators ===============
;============================================================

defn flip (o:VMOp) -> VMOp :
  match(o) :
    (o:EqOp) : NeOp()
    (o:NeOp) : EqOp()
    (o:LtOp) : GeOp()
    (o:GtOp) : LeOp()
    (o:LeOp) : GtOp()
    (o:GeOp) : LtOp()
    (o:UleOp) : UgtOp()
    (o:UltOp) : UgeOp()
    (o:UgtOp) : UleOp()
    (o:UgeOp) : UltOp()
    (o:FlipOp) : op(o)
    (o) : FlipOp(o)

;============================================================
;=================== Block Collapsing =======================
;============================================================

defn collapse-blocks () :
  ;============================
  ;==== Instruction Buffer ====
  ;============================
  val instructions = Vector<Ins>()
  defn emit (e:Ins) : add(instructions, e)
  defn emit (es:Seqable<Ins>) : add-all(instructions, es)

  ;===================
  ;==== Port Glue ====
  ;===================
  ;Perform xs = ys in parallel
  defn glue-ports (xs:List<Port>, ys:List<Port>) :
    ;Instructions buffers
    val saves = Vector<Ins>()
    val loads = Vector<Ins>()
    val shuffles = Vector<KeyValue<Int,Int>>()
    val fshuffles = Vector<KeyValue<Int,Int>>()

    ;Populate port table
    val port-table = Array<Port>(nvars())
    for y in ys do : port-table[n(y)] = y

    ;Populate instruction buffers
    for x in xs do :
      ;Retrieve corresponding port
      val y = port-table[n(x)]
      val vx = Var(n(x), reg(x))
      val vy = Var(n(y), reg(y))
      ;Saves
      match(saved?(x), saved?(y)) :
        (sx:True, sy:False) : add(saves, Save(vy))
        (sx, sy) : false
      ;Loads
      match(loaded?(x), loaded?(y)) :
        (lx:True, ly:False) : add(loads, Load(vx))
        (lx, ly) : false
      ;Shuffles
      match(reg(x), reg(y)) :
        (rx:Reg, ry:Reg) : add(shuffles, n(ry) => n(rx))
        (rx:FReg, ry:FReg) : add(fshuffles, n(ry) => n(rx))
        (rx, ry) : false

    ;Output to main instruction buffer
    emit(saves)
    emit(ShuffleReg(values(shuffles), keys(shuffles)))
    emit(ShuffleFReg(values(fshuffles), keys(fshuffles)))
    emit(loads)

  ;=======================
  ;==== Glue Location ====
  ;=======================
  defn input-glue (b:Int) :
    if length(PREDECESSORS[b]) == 1 :
      val p = head(PREDECESSORS[b])
      OUT-PORTS[p]

  defn output-glue (blk:Block) :
    if length(next(blk)) == 1 :
      val n = head(next(blk))
      if length(PREDECESSORS[n]) > 1 :
        IN-PORTS[n]
        
  ;====================
  ;==== Goto Block ====
  ;====================
  defn ends-with-goto? (blk:Block) :
    ;A block ends with a goto if it has exactly 1 successor,
    ;and its last instruction is not a jumping instruction (Branch|Match|MethodDispatch).
    if length(next(blk)) == 1 :
      if empty?(ins(blk)) :
        true
      else :
        val e = ins(blk)[length(ins(blk)) - 1]
        e is-not Branch|Match|MethodDispatch

  ;======================
  ;==== Block Labels ====
  ;======================
  val lbls = Array<Int>(nblocks())
  lbls[0 to false] = repeatedly(unique-id{})

  ;===================
  ;==== Algorithm ====
  ;===================
  for (blk in BLOCKS, b in 0 to false) do :
    ;Is block i coming up next?
    defn upcoming? (i:Int) : i == b + 1

    ;Emit block label
    emit(Label(lbls[b]))

    ;Emit entry glue
    match(input-glue(b)) :
      (ps:List<Port>) : glue-ports(IN-PORTS[b], ps)
      (ps:False) : false

    ;Emit instructions
    for e in ins(blk) do :
      match(e) :
        (e:Branch) :
          val conseq = next(blk)[0]
          val alt = next(blk)[1]
          match(upcoming?(conseq), upcoming?(alt)) :
            (a:True, b:False) :
              emit(Break(lbls[alt], flip(op(e)), xs(e)))
            (a:False, b:True) :
              emit(Break(lbls[conseq], op(e), xs(e)))
            (a:False, b:False) :
              emit(Break(lbls[conseq], op(e), xs(e)))
              emit(Goto(lbls[alt]))
        (e:Match) :
          val ns = map({lbls[_]}, next(blk))
          emit(Match(dispatch?(e), type-lists(e), xs(e), false, ns))
        (e:MethodDispatch) :
          val default = lbls[next(blk)[0]]
          val amb = lbls[next(blk)[1]]
          emit(MethodDispatch(multi(e), num-header-args(e), default, amb))
        (e:Def) :
          false
        (e) :
          emit(e)

    ;Emit exit glue
    match(output-glue(blk)) :
      (ps:List<Port>) : glue-ports(ps, OUT-PORTS[b])
      (ps:False) : false
      
    ;Goto next block
    if ends-with-goto?(blk) :
      val n = head(next(blk))
      emit(Goto(lbls[n])) when not upcoming?(n)

  ;Return instruction buffer
  clear(BLOCKS)
  add(BLOCKS, Block(instructions, List()))

;============================================================
;================== Backend Properties ======================
;============================================================
defn frame-size (num-mem-args:Int, backend:Backend) :
  match(backend) :
    (backend:W64Backend) :
      val num-ctxt = length(c-preserved-regs(backend))
      8 * ((num-ctxt + num-mem-args + 4) | 1)
    (backend) :
      val num-ctxt = length(c-preserved-regs(backend))
      8 * ((num-ctxt + num-mem-args) | 1)

defn store-mem-arg-offset (op:StoreCArgOp, backend:Backend) :
  match(backend) :
    (backend:W64Backend) :
      val frame-size = frame-size(num-mem-args(op), backend)
      (- frame-size) + (8 * index(op)) + 32
    (backend) :
      val frame-size = frame-size(num-mem-args(op), backend)
      (- frame-size) + (8 * index(op))    
  
defn load-mem-arg-offset (op:LoadCArgOp, backend:Backend) :
  8 * (index(op) + 1)

;============================================================
;====================== Assemble ============================
;============================================================

defn assemble (emitter:CodeEmitter, stackmap:StackMap, stubs:AsmStubs) :
  ;============================
  ;==== Assembly Utilities ====
  ;============================
  defn E (i:asm-Ins) : emit(emitter, i)  
  defn T (x:Imm) : asm-type(x)
  defn I (x:Imm) : to-asm-imm(x)
  defn V (x:Var) : to-asm-loc(x)

  ;====================
  ;==== Label Pool ====
  ;====================
  val label-table = IntTable-init<asm-LocalMem>(asm-LocalMem{unique-id(stubs)})

  ;=========================
  ;==== Special Offsets ====
  ;=========================
  val stack-offset-counter = Counter(-1 + 8)
  val size-offset = next(stack-offset-counter, 8)
  val frames-offset = next(stack-offset-counter, 8)
  val sp-offset = next(stack-offset-counter, 8)
  val pc-offset = next(stack-offset-counter, 8)

  ;==============
  ;==== Body ====
  ;==============
  for e in ins(BLOCKS[0]) do :
    ;println("//Assembling: %_" % [e])
    match(e) :
      (e:Set) :
        match(y(e)) :
          (v:Val) :
            match(value(v)) :
              (v:ConstId) : load-const(id(v))
              (v) : set-value(y(e))
          (v) : set-value(v)
        where :
          defn load-const (id:Int) :
            val x = V(x(e))
            E $ LoadL(x, asm-LinkId(id))
          defn set-value (v:Imm) :
            val t = T(x(e))
            val x = V(x(e))
            val y = I(v)
            E(asm-SetIns(t, x, y)) when x != y            
      (e:Return) :
        match(ctxt(e)) :
          (c:StanzaContext) :
            E $ asm-Return()
          (c:CContext) :
            ;Save current context
            E $ StoreL(M(stack-pointer(stubs)), RSP)

            ;Restore C context
            E $ SetL(RSP, R(c-rsp-arg(backend(stubs))))
            for (reg in c-preserved-regs(backend(stubs)), i in 0 to false) do :
              val o = -8 - (8 * i)
              E $ LoadL(R(reg), RSP, o)
            E $ asm-Return()
      (e:Args) :
        match(ctxt(e)) :
          (ctxt:StanzaContext) :
            ;Everything is set up already
            false
          (ctxt:CContext) :
            false
      (e:Call) :
        match(type(e)) :
          (t:ExtendStack) :
            val return-lbl = unique-id(stubs)
            E $ SetL(R0, LM(return-lbl))
            E $ SetL(R1, INT(size(stackmap) + 8))
            E $ asm-Goto(M(extend-stack(stubs)))
            E $ asm-Label(return-lbl)
          (t:CollectGarbage) :
            val return-lbl = unique-id(stubs)
            E $ SetL(R0, LM(return-lbl))
            E $ asm-Goto(M(collect-garbage(stubs)))
            E $ asm-Label(return-lbl)
          (t:StanzaCall) :
            val frame-size = INT(size(stackmap) + 8)
            E $ AddL(RSP, RSP, frame-size)
            E $ asm-Call(I(f(e)))
            match(info(t):FileInfo) :
              E $ asm-Label(unique-id(stubs), info(t))
            E $ SubL(RSP, RSP, frame-size)
          (t:StanzaTCall) :
            E $ asm-Goto(I(f(e)))
          (t:CCall) :
            ;Push frame:
            E $ AddL(RSP, RSP, INT(size(stackmap)))

            ;Save RSP
            E $ StoreL(M(stack-pointer(stubs)), RSP)
            
            ;Restore the C context:
            E $ LoadL(RSP, M(saved-c-rsp(stubs)))
              
            ;Call C function with right convention
            val num-float-args = for y in ys(e) count : reg?(y as Var) is FReg
            E $ SubL(RSP, RSP, INT(frame-size(num-mem-args(t), backend(stubs))))
            E $ SetL(R0, INT(num-float-args))
            E $ asm-Call(I(f(e)))

            ;Load RSP
            E $ LoadL(RSP, M(stack-pointer(stubs)))

            ;Pop frame:
            E $ SubL(RSP, RSP, INT(size(stackmap)))
          (t:YieldCall) :            
            val lbl = unique-id(stubs)
            val TMP = to-asm-loc(scratch-regs(t)[0])
            val TMP2 = to-asm-loc(scratch-regs(t)[1])
            val F = I(f(e))

            ;Save current stack progress
            val size-offset = -1 + 8 
            val frames-offset = -1 + 8 + 8
            val sp-offset = -1 + 8 + 8 + 8
            val pc-offset = -1 + 8 + 8 + 8 + 8
            E $ LoadL(TMP, M(current-stack(stubs)))
            E $ SetL(TMP2, LM(lbl))
            E $ StoreL(TMP, TMP2, pc-offset)
            E $ StoreL(TMP, RSP, sp-offset)

            ;Load given stack
            E $ StoreL(M(current-stack(stubs)), F)
            if enter?(t) : E $ LoadL(RSP, F, frames-offset)
            else : E $ LoadL(RSP, F, sp-offset)
            E $ LoadL(TMP, F, frames-offset)            
            E $ LoadL(TMP2, F, size-offset)
            E $ AddL(TMP, TMP, TMP2)
            E $ StoreL(M(stack-limit(stubs)), TMP)
            
            E $ LoadL(TMP, F, pc-offset)
            E $ asm-Goto(TMP)            
            E $ asm-Label(lbl, info(t))
      (e:Op) : ;[2]
        match(op(e)) :
          (op:SaveCContextOp) :
            ;Save C preserved registers
            for (reg in c-preserved-regs(backend(stubs)), i in 0 to false) do :
              val o = -8 - (8 * i)
              E $ StoreL(RSP, R(reg), o)
            ;Move RSP to special register for holding CRSP
            E $ SetL(R(c-rsp-arg(backend(stubs))), RSP)
            ;Load Stanza RSP
            E $ LoadL(RSP, M(stack-pointer(stubs)))
          (op:RecordLiveOp) :
            val indices = qsort $
              for v in live-vars(op) seq? :
                if type(v) is VMRef :
                  val o = offset(stackmap, n(v)) - 16
                  fatal("Wrong alignment for ref on stack.") when o % 8 != 0
                  One(o / 8)
                else : None()
            E $ StoreL(RSP, asm-StackMap(size(stackmap), indices), 8)
          (op:AllocOp) :
            val x = V(xs(e)[0])
            val size = I(ys(e)[0])
            val TMP = R0
            val TMP2 = R1
            E $ LoadL(TMP, M(heap-top(stubs)))
            E $ SetL(TMP2, size)
            E $ AddL(x, TMP, INT(1))
            E $ AddL(TMP, TMP, TMP2)
            E $ StoreL(M(heap-top(stubs)), TMP)
          (op:NoOp) :
            false
          (op:ConvOp) :
            val [x, y] = [head(xs(e)), head(ys(e))]
            E $ asm-ConvertIns(T(x), V(x), T(y), I(y))
          (op:InterpretOp) :
            val [x, y] = [head(xs(e)), head(ys(e))]
            E $ asm-InterpretIns(T(x), V(x), T(y), I(y))
          (op:LoadOp) :
            val [x, y, o] = [head(xs(e)), head(ys(e)), offset(op)]
            E $ asm-Load(T(x), V(x), I(y), o)
          (op:StoreOp) :
            val [x, y, o] = [ys(e)[0], ys(e)[1], offset(op)]
            E $ asm-Store(T(y), I(x), I(y), o)
          (op:LoadArgOp) :
            val x = xs(e)[0]
            E $ asm-Load(T(x), V(x), M(registers(stubs)), 8 * index(op))
          (op:StoreArgOp) :
            val y = ys(e)[0]            
            E $ asm-Store(T(y), M(registers(stubs)), I(y), 8 * index(op))
          (op:StoreCArgOp) :
            val crsp = ys(e)[0]
            val y = ys(e)[1]
            E $ asm-Store(T(y), I(crsp), I(y), store-mem-arg-offset(op,backend(stubs)))
          (op:LoadCArgOp) :
            val crsp = ys(e)[0]
            val x = xs(e)[0]
            E $ asm-Load(T(x), V(x), I(crsp), load-mem-arg-offset(op,backend(stubs)))
          (op:CRSPOp) :
            val x = xs(e)[0]
            E $ LoadL(V(x), M(saved-c-rsp(stubs)))
          (op:StoreCRSPOp) :
            val y = ys(e)[0]
            E $ StoreL(M(saved-c-rsp(stubs)), I(y))
          (op:VMOp&Binary) :
            val [x, y, z] = [head(xs(e)), ys(e)[0], ys(e)[1]]
            E $ asm-BinOp(T(y), V(x), to-asm-op(op), I(y), I(z))
          (op:VMOp&Unary) :
            val [x, y] = [head(xs(e)), head(ys(e))]
            E $ asm-UnaOp(T(x), V(x), to-asm-op(op), I(y))
          (op:DivModOp) :
            val [x1, x2, y, z] = [xs(e)[0], xs(e)[1], ys(e)[0], ys(e)[1]]
            E $ asm-DualOp(T(x1), V(x1), V(x2), to-asm-op(op), I(y), I(z))
          (op:InstanceofOp) :
            val [x, y] = [head(xs(e)), head(ys(e))]
            E $ asm-UnaOp(T(x), V(x), to-asm-op(op), I(y))
          (op:FlushVMOp) :
            val x = V(head(xs(e)))
            val stack-pointer-offset = -1 + 8 + 16
            E $ LoadL(x, M(current-stack(stubs)))
            E $ StoreL(x, RSP, stack-pointer-offset)
            E $ SetL(x, M(vmstate(stubs)))
          (op) :
            fatal("Not yet implemented")

      (e:Save) :
        val x = x(e)
        val offset = offset(stackmap, n(x))
        E $ asm-Store(T(x), RSP, I(x), offset)
      (e:Load) :
        val x = x(e)
        val offset = offset(stackmap, n(x))
        E $ asm-Load(T(x), V(x), RSP, offset)
      (e:Xchg) :
        val [x, y] = [x(e), y(e)]
        match(swap(e)) :
          (s:FReg) :
            E $ SetD(F(n(s)), I(x))
            E $ SetD(V(x), I(y))
            E $ SetD(V(y), F(n(s)))
          (s:False) :
            E $ asm-XchgIns(V(x), V(y))
      (e:ShuffleReg) :
        if xs(e) != ys(e) :
          shuffle(num-regs(backend(stubs)), xs(e), ys(e),
            fn (src:Int, dst:Int) :
              E $ asm-SetIns(LT, R(dst), R(src))
            fn (src:Int, dst:Int) :
              E $ asm-XchgIns(R(dst), R(src)))
      (e:ShuffleFReg) :
        if xs(e) != ys(e) :
          shuffle(num-fregs(backend(stubs)), xs(e), ys(e),
            fn (src:Int, dst:Int) :
              E $ asm-SetIns(DT, F(dst), F(src))
            fn (n:Int) :
              E $ asm-Store(DT, M(swap-lbl(stubs)), F(n), 0)
            fn (n:Int) :
              E $ asm-Load(DT, F(n), M(swap-lbl(stubs)), 0))
      (e:Label) :
        val l = label-table[n(e)]
        E $ asm-Label(asm-n(l))
      (e:Goto) :
        E $ asm-Goto(label-table[n(e)])
      (e:Break) : ;[1]
        defn cmp-stack-limit (le-op:asm-Op) :
          val TMP = R0
          val TMP2 = R1
          E $ AddL(TMP, RSP, INT(size(stackmap) + 8))
          E $ LoadL(TMP2, M(stack-limit(stubs)))
          E $ BreakL(label-table[n(e)], le-op, TMP, TMP2)
        defn cmp-heap-limit (le-op:asm-Op) :
          val TMP = R0
          val TMP2 = R1
          val size = I(xs(e)[0])
          E $ LoadL(TMP, M(heap-top(stubs)))
          E $ AddL(TMP, TMP, size)
          E $ LoadL(TMP2, M(heap-limit(stubs)))
          E $ BreakL(label-table[n(e)], le-op, TMP, TMP2)
        defn cmp-arity (arg:Int, value:Int, eq-op:asm-Op) :
          val arg-reg = R(call-regs(backend(stubs))[arg])
          E $ BreakL(label-table[n(e)], eq-op, arg-reg, INT(value))

        match(op(e)) :
          (op:HasStackOp) :
            cmp-stack-limit(asm-UleOp())
          (op:HasHeapOp) :
            cmp-heap-limit(asm-UleOp())
          (op:ArgEqOp) :
            cmp-arity(arg(op), value(op), asm-EqOp())
          (fop:FlipOp) :
            match(op(fop)) :
              (op:HasStackOp) :
                cmp-stack-limit(asm-flip(asm-UleOp()))
              (op:HasHeapOp) :
                cmp-heap-limit(asm-flip(asm-UleOp()))
              (op:ArgEqOp) :
                cmp-arity(arg(op), value(op), asm-flip(asm-EqOp()))
          (op) :
            val [x, y] = [xs(e)[0], xs(e)[1]]
            E $ asm-Break(T(x), label-table[n(e)], to-asm-op(op), I(x), I(y))
      (e:Match) :
        if dispatch?(e) :
          val no-branch = label-table[ns(e)[0]]
          val amb-branch = label-table[ns(e)[1]]
          val branch-ns = tailn(ns(e), 2)          
          val bs = map(asm-Branch{_, label-table[_]}, type-lists(e), branch-ns)          
          val xs = map(I, xs(e))
          E $ asm-Dispatch(xs, bs, no-branch, amb-branch)
        else :
          val no-branch = label-table[head(ns(e))]
          val branch-ns = tail(ns(e))          
          val bs = map(asm-Branch{_, label-table[_]}, type-lists(e), branch-ns)          
          val xs = map(I, xs(e))
          E $ asm-Match(xs, bs, no-branch)
      (e:MethodDispatch) :
        val no-branch = label-table[default(e)]
        val amb-branch = label-table[amb(e)]
        E $ asm-MethodDispatch(multi(e), num-header-args(e), no-branch, amb-branch)        
      (e) : fatal("Not yet implemented: %_" % [e])

defn asm-type (x:Imm) :
  to-asm-type(type(x))

defn to-asm-type (t:VMType) -> asm-ASMType :
  match(t) :
    (t:VMByte) : asm-ByteT()
    (t:VMInt) : asm-IntT()
    (t:VMLong) : asm-LongT()
    (t:VMRef) : asm-LongT()
    (t:VMFloat) : asm-FloatT()
    (t:VMDouble) : asm-DoubleT()

defn to-asm-loc (x:Imm) :
  to-asm-imm(x) as asm-Loc

defn to-asm-imm (x:Imm) -> asm-Imm :
  match(x) :
    (x:Var) : to-asm-loc(reg(x))
    (x:Val) : to-asm-imm(value(x))

defn to-asm-loc (x:Loc) -> asm-Loc :
  match(x) :
    (x:Reg) : asm-Reg(n(x))
    (x:FReg) : asm-FReg(n(x))

defn to-asm-imm (i:VMImm) -> asm-Imm :
  match(i) :
    (i:NumConst) :
      match(value(i)) :
        (v:Byte|Int|Long) : asm-IntImm(v)
        (v:Char) : asm-IntImm(to-byte(v))
        (v:Float|Double) : fatal("Not yet implemented: Need interpret instruction")
    (i:Marker) : asm-TagImm(typeid(i), true)
    (i:Tag) : asm-TagImm(typeid(i), false)
    (i:CodeId) : asm-LinkId(id(i))
    (i:ExternId) : asm-LinkId(id(i))
    (i:ExternDefnId) : asm-LinkId(id(i))
    (i:GlobalId) : asm-LinkId(id(i))
    (i:DataId) : asm-LinkId(id(i))
    (i:VoidMarker) : asm-IntImm(-8 + 2)
    (i:ConstId) : fatal("Constants must be loaded")

defn to-asm-op (op:VMOp) -> asm-Op :
  match(op) :
    (op:AddOp) : asm-AddOp()
    (op:SubOp) : asm-SubOp()
    (op:MulOp) : asm-MulOp()
    (op:DivOp) : asm-DivOp()
    (op:ModOp) : asm-ModOp()
    (op:AndOp) : asm-AndOp()
    (op:OrOp) : asm-OrOp()
    (op:XorOp) : asm-XorOp()
    (op:ShlOp) : asm-ShlOp()
    (op:ShrOp) : asm-ShrOp()
    (op:AshrOp) : asm-AshrOp()
    (op:EqOp) : asm-EqOp()
    (op:NeOp) : asm-NeOp()
    (op:LtOp) : asm-LtOp()
    (op:GtOp) : asm-GtOp()
    (op:LeOp) : asm-LeOp()
    (op:GeOp) : asm-GeOp()
    (op:UleOp) : asm-UleOp()
    (op:UltOp) : asm-UltOp()
    (op:UgtOp) : asm-UgtOp()
    (op:UgeOp) : asm-UgeOp()
    (op:NotOp) : asm-NotOp()
    (op:NegOp) : asm-NegOp()
    (op:DivModOp) : asm-DivModOp()
    (op:InstanceofOp) : asm-TypeofOp(type(op))

;============================================================
;===================== Utilities ============================
;============================================================

defn keys<?T> (xs:Vector<KeyValue<?T,?>>) : to-list(seq(key,xs))
defn values<?T> (xs:Vector<KeyValue<?,?T>>) : to-list(seq(value,xs))