defpackage stz/lang-serializer :
   import core
   import reader
   import collections
   import macro-utils
   import stz/parser
   import stz/params
   import stz/core-macros

#use-overlay(stz/printer-lang)

;============================================================
;================= Parse Structures =========================
;============================================================

defstruct DefSerializer :
   out
   out-type
   in
   in-type
   nodes: List<DefNode>

deftype DefNode
defmulti name (n:DefNode) -> Symbol
defmulti type (n:DefNode) -> ?

defstruct DefAtom <: DefNode :
   name: Symbol with: (as-method => true)
   arg
   type with: (as-method => true)
   writer
   reader

defstruct DefUnion <: DefNode :
   name: Symbol with: (as-method => true)
   type with: (as-method => true)
   branches: List<Branch>

defstruct Branch :
   type
   fields: List<KeyValue<?,Symbol>>

;============================================================
;================= Printing =================================
;============================================================

defprinter (d:DefSerializer) :
   DefSerializer :
      ($defserializer out out-type in in-type nodes ...)

defprinter (d:DefNode) :
   DefAtom :
      ($defatom name arg type writer reader)
   DefUnion :
      ($defunion name branches ...)

defprinter (b:Branch) :
   Branch :
      ($branch type fields ...)

;============================================================
;================== Parsing =================================
;============================================================

defsyntax stz/serializer-lang :
   defn sym? (x) :
      unwrap-token(x) is Symbol

   defrule :
      sym = (?x) when sym?(x) : x
      uw-sym = (?x) when sym?(x) : unwrap-token(x)
         
      prefix-op = (defserializer (?out:#sym : ?out-type:#type, ?in:#sym : ?in-type:#type) :
                      ?nodes:#node ...) :
         if empty?(nodes) : fatal("Serializer must have at least one node.")             
         val parsed = DefSerializer(out, out-type, in, in-type, nodes)
         println("=========================")
         println(compile-serializer(parsed))
         println("=========================")
         false
      prefix-op != (defserializer) :
         fatal("Invalid syntax for defserializer.")

      node = (defatom ?name:#uw-sym (?arg:#sym : ?arg-type:#type) :
                 writer : ?writer:#exp
                 reader : ?reader:#exp) :
         DefAtom(name, arg, arg-type, writer, reader)
         
      node = (defunion ?name:#uw-sym (?type:#type) :
                 ?branches:#branch ...) :
         DefUnion(name, type, branches)
         
      branch = (?type:#type : ((?ks:#sym : ?ts:#uw-sym) @...)) :
         Branch(type, map(KeyValue, ks, ts))      

;============================================================
;================== Compilation =============================
;============================================================

defn compile-serializer (def:DefSerializer) :
   defn write-prefix (x) :
      symbol-join(["write-", x])
   defn compile-atom (d:DefAtom) :
      val template = `(defn name (x:Type) : body)
      fill-template(template, [
         `name => write-prefix(name(d))
         `x => arg(d)
         `Type => type(d)
         `body => writer(d)])

   defn compile-branch (b:Branch, branch-tag:Int) :
      val template = `(
         (x:Type) :
            core/put(out, tag)
            fields{write-type(field(x))})
      fill-template(template, [
         `Type => type(b)
         `x => gensym("x")
         `out => out(def)
         `tag => to-byte(branch-tag)
         `fields => nested $ for f in fields(b) map :
            [`write-type => write-prefix(value(f))
             `field => key(f)]])
         
   defn compile-union (d:DefUnion) :
      val template = `(defn name (x:Type) :
                          match(x) :
                             branches)
      fill-template(template, [
         `name => write-prefix(name(d))
         `x => gensym("x")
         `Type => type(d)
         `branches => splice $
            seq-append(compile-branch, branches(d), 0 to false)])
            
   defn compile-node (d:DefNode) :
      match(d) :
         (d:DefAtom) : compile-atom(d)
         (d:DefUnion) : compile-union(d)
         
   val template = `(
      defn serialize (out:OutType, x:Type) :
         nodes
         write-type(x))
   val n0 = head(nodes(def))      
   fill-template(template, [
      `out => out(def)
      `OutType => out-type(def)
      `x => gensym("x")
      `Type => type(n0)
      `nodes => splice(map(compile-node, nodes(def)))
      `write-type => write-prefix(name(n0))])        

;============================================================ 
;==================== Testing ===============================
;============================================================
   

defn main () :
   val filename = command-line-arguments()[1]
   with-syntax(core, stz/serializer-lang) :
      match-syntax(read-file(filename)) :
         (?es:#exp ...) :
            false

main()