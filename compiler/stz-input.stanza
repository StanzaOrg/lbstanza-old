defpackage stz/input :
   import core
   import verse
;   import stz/il-ir

;============================================================
;================== DESIGN ==================================
;============================================================

;For each form, there is an associated reader function which may or may not
;
;def-reader read-exp (form, inf) :
;   List :
;      ($deftype name args parent) => DefError :
;         name <= read-symbol (DefTypeNameError)
;         args <= read-vars (DefTypeArgError)
;         parent <= read-parent
;      else :
;         body
;   Symbol :
;      asdf
;   ? :
;      asdf


#use-syntax(core, stz/input-lang)

defn read (form) :
   val read-errors = Vector<ReadError>()

   defn read-symbol (x, inf:FileInfo) :
      error("Reading symbol")

   defreader read-exp (form, inf) :
      List :
         ($deftype name args parent) :
            name => read-symbol
            args => read-symbol
            parent => read-symbol
            error("List Clause")
         else :
            error("Default List Clause")
      Symbol :
         error("Symbol thing")
      ? :
         error("Gradual thing")

   error("End of scope")

;============================================================
;==================== FILE INFO =============================
;============================================================

defn first-info (a:FileInfo, b:FileInfo) :
   match(a) :
      (a:NoFileInfo) : b
      (a) : a

defn first-info (x) :
   defn infos (x) :
      generate<FileInfo> :
         defn loop (x) :
            match(x) :
               (x:Token) :
                  yield(info(x))
                  loop(item(x))
               (x:List) : do(loop, x)
               (x) : false
         loop(x)      
   reduce(first-info, FileInfo(), infos(x))

;============================================================
;==================== ERRORS ================================
;============================================================

definterface ReadError <: Exception
defn ReadError () :
   new ReadError :
      defmethod print (o:OutputStream, this) :
         print(o, "ReadError")

defn ReadError (msg, info) :
   new ReadError :
      defmethod print (o:OutputStream, this) :
         print(o, "~: ~" << [info, msg])

defn ArityError (form:List, n:Int, info:FileInfo) :
   ReadError{_, info} $
   "Stanza form ~ expects ~ arguments, but found ~." << [head(form), n, length(form) - 1]

defn MinArityError (form:List, n:Int, info:FileInfo) :
   ReadError{_, info} $
   "Stanza form ~ expects at least ~ arguments, but found only ~." << [head(form), n, length(form) - 1]

;============================================================
;================== READING =================================
;============================================================   

;defn read-exp (form, inf:FileInfo) :
;   match(form) :
;      (form:Token) :
;         read-exp(token(form), inf(form))
;      (form:List) :
;         ;Attempt to call f with x, otherwise add error to error list
;         defn try-read<?T,?S> (error: (List, FileInfo) -> ReadError, f: S -> ?T, x: ?S) :
;            try :
;               f(x)
;            catch (e) :
;               add(read-errors, error(form, inf))
;               throw(ReadError())
;               
;         switch tagged-list?{form, _} :
;            `$defpackage :
;               ensure-min-arity(1)
;               val name = try-read(PackageNameError, read-symbol, form[1])
;               val imports = read-imports(tailn(form,2))
;               IPackage(name, imports, inf)
;            `$import :
;               ensure-min-arity(1)
;               val name = try-read(ImportNameError, read-symbol, form[1])
;               val prefixes = read-prefixes(tailn(form,2))
;               IImport(name, prefixes, inf)
;            `$prefix :
;               ensure-arity(2)
;               val names = try-read(PrefixNamesError, read-symbols?, forms[1])
;               val prefix = try-read(PrefixError, read-symbol, form[2])
;               IPrefix(names, prefix, inf)
;            `$export :
;               ensure-arity(1)               
;               val exp = read-exp(form[1])
;               IExport(exp, inf)
;            `$deftype :               
;               ensure-arity(3)
;               val name = try-read(TypeNameError, read-symbol, form[1])
;               val args = try-read(TypeArgsError, read-vars, form[2])
;               val parent = read-parent(form[3])
;               IDefType(name, args, parent, inf)
;            `$def :
;               ensure-arity(3)
;               val name = read-binder(form[1])
;               val type = read-type?(form[2])
;               val value = read-exp(form[3])
;               IDef(name, type, value, inf)
;            `$defvar :
;               ensure-arity(3)
;               val name = try-read(VarNameError, read-symbol, form[1])
;               val type = read-type?(form[2])
;               val value = read-exp?(form[3])
;               IDefVar(name, type, value, inf)
;            `$defn :
;               ensure-arity(6)
;               val name = try-read(DefnNameError, read-symbol, form[1])
;               val targs = try-read(DefnTArgsError, read-vars, form[2])
;               val func = read-fn(false, form[3], form[4], form[5], form[6])
;               IDefn(name, targs, func, inf)               
;            `$defn* :
;               ensure-arity(6)
;               val name = try-read(DefnNameError, read-symbol, form[1])
;               val targs = try-read(DefnTArgsError, read-vars, form[2])
;               val func = read-fn(true, form[3], form[4], form[5], form[6])
;               IDefn(name, targs, func, inf)               
;            `$defmethod :
;               ensure-arity(6)
;               val name = try-read(DefmethodNameError, read-var, form[1])
;               val targs = try-read(DefmethodTArgsError, read-vars, form[2])
;               val func = read-fn(false, form[3], form[4], form[5], form[6])
;               IDefmethod(name, false, targs, func, inf)               
;            `$defmethod* :
;               ensure-arity(6)
;               val name = try-read(DefmethodNameError, read-var, form[1])
;               val targs = try-read(DefmethodTArgsError, read-vars, form[2])
;               val func = read-fn(true, form[3], form[4], form[5], form[6])
;               IDefmethod(name, false, targs, func, inf)
;            `$defmulti :
;               ensure-arity(4)
;               val name = try-read(DefmultiNameError, read-symbol, form[1])
;               val targs = try-read(DefmultiTArgsError, read-vars, form[2])
;               val a1 = read-types?(form[3])
;               val a2 = read-type?(form[4])
;               IDefmulti(name, targs, a1, a2, inf)
;            `$fn :
;               ensure-arity(4)
;               read-fn(false, form[1], form[2], form[3], form[4])
;            `$fn* :
;               ensure-arity(4)
;               read-fn(true, form[1], form[2], form[3], form[4])
;            `$multi :
;               ensure-min-arity(1)
;               read-fns(tailn(form, 1))
;            `$begin :
;               val exps = read-exps(tailn(form, 1))
;               IBegin(exps, inf)
;            `$match :
;               ensure-min-arity(2)
;               val exps = read-exps(form[1])
;               val bs = read-branches(tailn(form,2))
;               IMatch(exps, bs, inf)
;            `$new :
;               ensure-min-arity(1)
;               val type = read-type(form[1])
;               val ms = read-methods(tailn(form, 2))
;               INew(type, ms, inf)
;            `$as :
;               ensure-arity(2)
;               val exp = read-exp(form[1])
;               val type = read-type(form[2])
;               ICast(exp, type, inf)
;            `$set :
;               ensure-arity(2)
;               val name = try-read(SetNameError, read-symbol, form[1])
;               val exp = read-exp(form[2])
;               ISet(name, exp, inf)
;            `$do :
;               ensure-min-arity(1)
;               val [f, targs] = read-do-fn(form[1])
;               val args = read-exps(tailn(form,2))
;               IDo(f, targs, args, inf)
;            `$prim :
;               ensure-min-arity(1)
;               val f = try-read(PrimNameError, read-symbol, form[1])
;               val args = read-exps(tailn(form, 2))
;               IPrim(f, args, inf)
;            `$call-ls :
;               ensure-min-arity(1)
;               val [f, targs] = read-call-ls-fn(form[1])
;               val args = read-args(tailn(form,2))
;               ICallLS(f, targs, args, inf)
;            `$tuple :
;               val exps = read-exps(tailn(form, 1))
;               ITuple(exps, inf)
;            `$quote :
;               ensure-arity(1)
;               read-lit(form[1])
;            else :
;               add(read-errors, BadExpError(form, inf))
;               throw(ReadError())            
;      (form:Symbol) :
;         IVar(form, inf)
;      (form) :
;         read-lit(form, inf)
;      