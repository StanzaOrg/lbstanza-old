defpackage stz/input :
   import core
   import verse
   import stz/il-ir

                ;Reader
                ;======


defn flatten (es:List<IExp>) :
   for e in es map-append :
      match(e) :
         (e:IBegin) : exps(e)
         (e) : list(e)

defn IBegin (e:IExp, es:List<IExp>, info:FileInfo) :
   if empty?(es) : e
   else : IBegin(flatten(List(e, es)), info)

defn name-args (e:IExp) -> [IExp, List<IExp>] :
   match(e) :
      (e:IOf) : [class(e), args(e)]
      (e) : [e, List()]

defn ls-name-args (e:IExp) -> [IExp, List<IExp>] :
   match(e) :
      (e:ILSOfT) : [class(e), args(e)]
      (e) : [e, List()]

#with-overlay(stz/reader-lang) :
   public defreader read (e) -> IExp :
      ;Package Forms
      ($package name:e imports:e ...) :
         IPackage(name, imports, info)
      ($import name:e prefixes:e ...) :
         IImport(name, prefixes, info)
      ($prefix-of (names:e ...) p:e) :
         IPrefix(names, p, info)
      ($prefix p:e) :
         IPrefix(false, p, info)
      ($public e:e es:e ...) :
         val es* = IBegin(e, es, info)
         IPublic(es*, info)
      ($protected e:e es:e ...) :
         val es* = IBegin(e, es, info)
         IProtected(es*, info)
         
      ;Stanza Declaration Forms
      ($deftype name:e parent:e) :
         val [name*, args*] = name-args(name)
         IDefType(name*, args*, parent, info)
      ($def name:e type:e value:e) :
         IDef(name, type, value, info)
      ($defvar name:e type:e value:e) :
         IDefVar(name, type, value, info)      
      ($defn name:e (args:e ...) (a1:e ...) a2:e body0:e bodyn:e ...) :
         val [name*, targs*] = name-args(name)
         val body = IBegin(body0, bodyn, info)
         IDefn(false, name*, targs*, a1, a2, args, body, info)
      ($defn* name:e (args:e ...) (a1:e ...) a2:e body0:e bodyn:e ...) :
         val [name*, targs*] = name-args(name)
         val body = IBegin(body0, bodyn, info)
         IDefn(true, name*, targs*, a1, a2, args, body, info)         
      ($defmulti name:e (a1:e ...) a2:e) :
         val [name*, targs*] = name-args(name)
         IDefmulti(name*, targs*, a1, a2, info)
      ($defmethod name:e (args:e ...) (a1:e ...) a2:e body0:e bodyn:e ...) :
         val [name*, targs*] = name-args(name)
         val body = IBegin(body0, bodyn, info)
         IDefmethod(false, name*, false, targs*, a1, a2, args, body, info)
      ($defmethod* name:e (args:e ...) (a1:e ...) a2:e body0:e bodyn:e ...) :
         val [name*, targs*] = name-args(name)
         val body = IBegin(body0, bodyn, info)
         IDefmethod(true, name*, false, targs*, a1, a2, args, body, info)
         
      ;Stanza Expression Forms
      ($fn (args:e ...) (a1:e ...) a2:e body0:e bodyn:e ...) :
         val body = IBegin(body0, bodyn, info)
         IFn(false, a1, a2, args, body, info)
      ($fn* (args:e ...) (a1:e ...) a2:e body0:e bodyn:e ...) :
         val body = IBegin(body0, bodyn, info)
         IFn(true, a1, a2, args, body, info)
      ($multi f:e fs:e ...) :
         IMulti(List(f, fs), info)
         
      ($begin es:e ...) :
         val es* = flatten(es)
         if length(es*) == 1 : head(es*)
         else : IBegin(es*, info)
      ($let e:e) :
         ILet(e, info)
      ($match (es:e ...) bs:e ...) :
         IMatch(es, bs, info)
      ($branch (args:e ...) (ts:e ...) body0:e bodyn:e ...) :
         val body = IBegin(body0, bodyn, info)
         IBranch(ts, args, body, info)
      ($new type:e methods:e ...) :
         INew(type, methods, info)
      ($as exp:e type:e) :
         ICast(exp, type, info)
      ($as? exp:e type:e) :
         IUpCast(exp, type, info)
      ($set name:e exp:e) :
         ISet(name, exp, info)
      ($do f:e args:e ...) :
         IDo(f, args, info)
      ($prim f:e args:e ...) :
         IPrim(f, args, info)
      ($tuple es:e ...) :
         ITuple(es, info)
      ($quote v:?) :
         ILiteral(unwrap-all(v), INone(info), info)
      ($none) :
         INone(info)
      x :
         IVar(x, info)
      v :
         ILiteral(v, INone(info), info)
         
      ;Stanza Type Forms   
      ($of name:e args:e ...) :
         IOf(name, args, info)
      ($and a:e b:e) :
         IAnd(a, b, info)
      ($or a:e b:e) :
         IOr(a, b, info)
      ($-> (a1:e ...) a2:e) :
         IArrow(a1, a2, info)
      ($cap x:e) :
         ICap(x, info)
      ($void) :
         IVoid(info)
      ($?) :
         IGradual(info)

      ;LoStanza Expressions
      ($ls-new type:e args:e ...) :
         ILSNew(type, args, info)
      ($ls-array type:e (args:e ...) length:e) :
         ILSArray(type, args, length, info)
      ($ls-struct type:e args:e ...) :
         ILSStruct(type, args, info)
      ($ls-addr exp:e) :
         ILSAddr(exp, info)
      ($ls-deref exp:e) :
         ILSDeref(exp, info)
      ($ls-slot exp:e i:e) :
         ILSSlot(exp, i, info)
      ($ls-field exp:e name:e) :
         ILSField(exp, name, info)
      ($ls-do f:e args:e ...) :
         ILSDo(f, args, info)
      ($ls-do-in-stack ret:e f:e args:e ...) :
         ILSDoInStack(ret, f, args, info)
      ($ls-do-stack ret:e f:e arg:e) :
         ILSDoStack(ret, f, arg, info)
      ($ls-call-c f:e args:e ...) :
         ILSCallC(f, args, info)
      ($ls-prim f:e args:e ...) :
         ILSPrim(f, args, info)
      ($ls-sizeof type:e) :
         ILSSizeof(type, info)
      ($ls-tagof name:e) :
         ILSTagof(name, info)
      ($ls-as exp:e type:e) :
         ILSAs(exp, type, info)
      ($ls-letexp e:e es:e ...) :
         if empty?(es) :
            val c* = IBegin(List(), info)
            ILSLetExp(IBegin(List(), info), e, info)
         else :               
            val c* = IBegin(e, but-last(es), info)
            val e* = last(es)
            ILSLetExp(c*, e*, info)
      ($ls-and a:e b:e) :
         ILSAnd(a, b, info)
      ($ls-or a:e b:e) :
         ILSOr(a, b, info)

      ;Commands
      ($ls-set x:e y:e) :
         ILSSet(x, y, info)
      ($ls-labels (names:e ...) body0:e bodyn:e ...) :
         val body = IBegin(body0, bodyn, info)
         ILSLabels(names, body, info)
      ($ls-label name:e) :
         ILSLabel(name, info)
      ($ls-goto name:e) :
         ILSGoto(name, info)
      ($ls-return e:e) :
         ILSReturn(e, info)
      ($ls-let c:e cs:e ...) :
         val c* = IBegin(c, cs, info)
         ILSLet(c*, info)
      ($ls-if p:e c:e a:e) :
         ILSIf(p, c, a, info)
      ($ls-match (args:e ...) bs:e ...) :
         ILSMatch(args, bs, info)
      ($ls-branch (args:e ...) (ts:e ...) body0:e bodyn:e ...) :
         val body = IBegin(body0, bodyn, info)
         ILSBranch(ts, args, body, info)
      ($ls-func x:e) :
         ILSFn(x, info)
         
      ;Declarations   
      ($ls-def name:e type:e exp:e) :
         ILSDef(name, type, exp, info)
      ($ls-defvar name:e type:e exp:e) :
         ILSDefVar(name, type, exp, info)
      ($ls-deftype name:e parent:e (fs:e ...) fr:e (ts:e ...) tr:e) :
         val [name*, args*] = ls-name-args(name)
         ILSDefType(name*, args*, parent, ts, tr, fs, fr, info)
      ($ls-defn name:e (args:e ...) (a1:e ...) a2:e body0:e bodyn:e ...) :
         val [name*, targs*] = ls-name-args(name)
         val body = IBegin(body0, bodyn, info)
         ILSDefn(false, name*, targs*, a1, a2, args, body, info)
      ($ls-defn* name:e (args:e ...) (a1:e ...) a2:e body0:e bodyn:e ...) :
         val [name*, targs*] = ls-name-args(name)
         val body = IBegin(body0, bodyn, info)
         ILSDefn(true, name*, targs*, a1, a2, args, body, info)
      ($ls-defmethod multi:e (args:e ...) (a1:e ...) a2:e body0:e bodyn:e ...) :
         val [multi*, targs*] = ls-name-args(multi)
         val body = IBegin(body0, bodyn, info)
         ILSDefmethod(false, multi*, targs*, a1, a2, args, body, info)
      ($ls-defmethod* multi:e (args:e ...) (a1:e ...) a2:e body0:e bodyn:e ...) :
         val [multi*, targs*] = ls-name-args(multi)
         val body = IBegin(body0, bodyn, info)
         ILSDefmethod(true, multi*, targs*, a1, a2, args, body, info)
      ($ls-extern name:e type:e) :
         ILSExtern(name, type, info)

      ;Types
      ($ls-byte) :
         ILSByteT(info)
      ($ls-int) :
         ILSIntT(info)
      ($ls-long) :
         ILSLongT(info)
      ($ls-float) :
         ILSFloatT(info)
      ($ls-double) :
         ILSDoubleT(info)
      ($ls-?) :
         ILSUnknownT(info)
      ($ls-of name:e args:e ...) :
         ILSOfT(name, args, info)
      ($ls-ptr t:e) :
         ILSPtrT(t, info)
      ($ls-ref t:e) :
         ILSRefT(t, info)
      ($ls-fn (a1:e ...) ar:e a2:e) :
         ILSFnT(a1, ar, a2, info)


   
;============================================================      
;================= Syntax Restrictions ======================
;============================================================

;                      Checker
;                      =======

#with-overlay(stz/check-lang) :
   public defcheck check (e:IExp) :
      ;======== Stanza Language ========
      pe*("package level form") :
         + pe
         custom{ensure-package(e)}
         
      pe("package level form") :
         IPackage: {name:v imports:(imp ...)}
         IBegin: {exps:(pe ...)}
         + te
   
      imp("import form") :
         IImport: {package:v prefix:(pr ...)}
   
      pr("prefix form") :
         IPrefix :
            if (names(e) == false) : {prefix:v}
            else : {names:(v ...) prefix:v}
   
      te("top level form") :
         IPublic: {exp:te}
         IProtected: {exp:te}
         IDefType: {class:v args:(v ...) parent:pt?}
         IDefmulti :
            {name:v targs:(targ ...) a1:(ct? ...) a2:t?}
            custom{ensure-ordered-targs(targs(e))}
            custom{ensure-capturing-position(targs(e), a1(e))}
         IDefmethod :
            {multi:v targs:(targ ...) a1:(ct? ...) a2:t? args:(b ...) body:se}
            custom{ensure-no-this-param(e)}
            custom{ensure-ordered-targs(targs(e))}
            custom{ensure-matched-a1-args(info(e), a1(e), args(e))}
            custom{ensure-capturing-position(targs(e), a1(e))}
         IBegin: {exps:(te ...)}
         + tse
         + ltc
      tse("top level form") :
         + se*
         custom{ensure-impure(e)}

      se("scope level form") :
         + se*
         custom{ensure-body(e)}         
      se*("scope level form") :
         IDef: {name:b type:t? value:e}
         IDefVar: {name:v type:t? value:e?}
         IDefn :
            {name:v targs:(targ ...) a1:(ct? ...) a2:t? args:(b ...) body:se}
            custom{ensure-matched-a1-args(info(e), a1(e), args(e))}
            custom{ensure-ordered-targs(targs(e))}
            custom{ensure-capturing-position(targs(e), a1(e))}
         IBegin: {exps:(se*, se* ...)}
         + e
   
      e("expression") :
         ILet: {exp:se}
         IMulti: {funcs:(func func ...)}
         IBegin: {exps:(e e ...)}
         IMatch :
            {args:(e e ...) branches:(br br ...)}
            custom{ensure-branch-arity(e)}
         INew: {class:pt methods:(m ...)}
         IVar: ()
         ICast: {exp:e type:t}
         IUpCast: {exp:e type:t}
         ISet: {name:v value:e}
         IDo: {func:farg args:(e ...)}
         IPrim: {function:farg, args:(e ...)}
         ILiteral: custom{ensure-literal(e)}
         ITuple: {exps:(e ...)}
         + func
   
      e?("optional expression") :
         INone: ()
         + e
   
      func("function expression") :
         IFn :
            {a1:(t? ...) a2:t? args:(b ...) body:se}
            custom{ensure-matched-a1-args(info(e), a1(e), args(e))}
   
      farg("function argument") :
         IOf: {class:v args:(t ...)}
         + e

      br("branch expression") :
         IBranch :
            {types:(t? ...) args:(b ...) body:se}
            custom{ensure-matched-a1-args(info(e), types(e), args(e))}
   
      m("method expression") :
         IDefmethod :
            {multi:v targs:(targ ...) a1:(ct? ...) a2:t? args:(b ...) body:se}
            custom{ensure-matched-a1-args(info(e), a1(e), args(e))}
            custom{ensure-this-param(e)}
            custom{ensure-ordered-targs(targs(e))}
            custom{ensure-capturing-position(targs(e), a1(e))}
   
      b("binder expression") :
         IVar: ()
         ITuple: {exps:(b ...)}
   
      pt("parent type") :
         IOf: {class:v args:(t ...)}
         IAnd: {a:pt b:pt}
         IVar: ()
         
      pt?("optional parent type") :
         INone: ()
         + pt
   
      ct("type") :
         IOf: {class:v args:(ct ...)}
         IAnd: {a:ct b:ct}
         IOr: {a:ct b:ct}
         IArrow: {a1:(t ...) a2:ct}
         ICap: {name:v}
         IGradual: ()
         IVoid: ()
         IVar: ()
         ITuple: {exps:(ct ...)}
   
      ct?("optional type") :
         INone: ()
         + ct
   
      t("type") :
         + ct
         custom{ensure-no-cap(e)}
      t?("optional type") :
         INone: ()
         + t
   
      v("symbol") :
         IVar : ()

      targ("type argument") :
         ICap: {name:v}
         IVar: ()      
         
      ;======== LoStanza Language ========
      ltc("LoStanza top level command") :
         + ltc*
         custom{ensure-no-return(e)}
      ltc*("LoStanza top level command") :
         IBegin: {exps:(ltc* ...)}          
         ILSDef: {name:v type:lt exp:le}
         ILSDefVar: {name:v type:lt exp:le?}
         ILSDefType :
             {name:v args:(v ...) parent:t? types:(lt ...) rtype:lt? fields:(v ...) rfield:rf}
             custom{ensure-matched-type-fields(info(e), types(e), fields(e))}
             custom{ensure-matched-rtype-rfield(info(e), rtype(e), rfield(e))}
         ILSExtern: {name:v type:lt}
         ILSDefn :
            {name:v targs:(targ ...) a1:(lct ...) a2:lt args:(b ...) body:lc}
            custom{ensure-matched-a1-args(info(e), a1(e), args(e))}
            custom{ensure-ordered-targs(targs(e))}
            custom{ensure-return(body(e))}
            custom{ensure-capturing-position(targs(e), a1(e))}
         ILSDefmethod :
            {multi:v targs:(targ ...) a1:(lct ...) a2:lt args:(b ...) body:lc}
            custom{ensure-matched-a1-args(info(e), a1(e), args(e))}
            custom{ensure-ordered-targs(targs(e))}
            custom{ensure-return(body(e))}
            custom{ensure-capturing-position(targs(e), a1(e))}
            
         ILSSet: {exp:lval value:le}
         ILSLet: {comm:lc}
         ILSLabels: {names:(v ...), body:lc}
         ILSIf: {pred:le conseq:lc alt:lc}
         ILSMatch: {args:(le le ...) branches:(lbr lbr ...)}
         + lcalls

      rf("LoStanza rest field") :
         INone: ()
         IVar: ()

      lc("LoStanza command") :   
         IBegin: {exps:(lc ...)}
         ILSDef: {name:v type:lt? exp:le}
         ILSDefVar: {name:v type:lt exp:le?}
         ILSSet: {exp:lval value:le}
         ILSLet: {comm:lc}
         ILSIf: {pred:le conseq:lc alt:lc}
         ILSMatch: {args:(le le ...) branches:(lbr lbr ...)}
         ILSLabels: {names:(v ...), body:lc}
         ILSLabel: {name:v}
         ILSGoto: {name:v}
         ILSReturn: {exp:le}
         + lcalls

      lbr("LoStanza branch") :
         ILSBranch:
            {types:(lbt? ...) args:(b ...) body:lc}
            custom{ensure-matched-a1-args(info(e), types(e), args(e))}
   
      le("LoStanza expression") :
         ILSNew: {type:lclass args:(le ...)}
         ILSArray: {type:lclass args:(le ...) length:le}
         ILSStruct: {type:lclass args:(le ...)}
         ILSAddr: {exp:lval}
         ILSDeref: {exp:le}
         ILSSlot: {exp:le index:le}
         ILSField: {exp:le name:v}
         ILSSizeof: {type:lt}
         ILSTagof: {name:v}
         ILSAs: {exp:le type:lt}
         ILSAnd: {a:le, b:le}
         ILSOr: {a:le, b:le}
         ILSLetExp: {comm:lc, exp:le}
         ILSFn: {ref:v}
         IVar: ()
         ILiteral: custom{ensure-ls-literal(e)}
         + lcalls
      lcalls("LoStanza call") :
         ILSDo: {func:lfarg args:(le ...)}
         ILSDoInStack: {ret:lt func:lfarg args:(le ...)}
         ILSDoStack: {ret:lt func:le arg:le}
         ILSPrim: {op:v args:(le ...)}
         ILSCallC: {func:le args:(le ...)}

      lfarg("LoStanza function argument") :
         ILSOfT: {class:v args:(t ...)}
         + le
   
      le?("optional LoStanza expression") :
         INone: ()
         + le
   
      lval("LoStanza lvalue expression") :
         IVar: ()
         ILSDeref: {exp:le}
         ILSSlot: {exp:le index:le}
         ILSField: {exp:le name:v}

      lclass("LoStanza object type") :
         ILSOfT: {class:v, args:(t ...)}
         IVar: ()

      lct("LoStanza argument type") :
         ILSByteT: ()
         ILSIntT: ()
         ILSLongT: ()
         ILSFloatT: ()
         ILSDoubleT: ()
         ILSUnknownT: ()
         ILSOfT: {class:v args:(ct ...)}
         ILSPtrT: {type:lct}
         ILSRefT: {type:ct}
         ILSFnT: {a1:(lt ...) ar:lt? a2:lct}
         IVar: ()
      lt("LoStanza type") :
         + lct
         custom{ensure-no-cap(e)}
      lt?("optional LoStanza type") :
         INone: ()
         + lt
      lbt?("LoStanza branch type") :
         ILSRefT: {type:lt}
         INone: ()

defn var? (e:IExp, s:Symbol) :
   match(e) :
      (e:IVar) : name(e) == s
      (e) : false

;                   Error Checkers
;                   ==============

defn ensure-package (e:IExp) :
   defn first-exp (e:IExp) :
      match(e) :
         (e:IBegin) : head(exps(e)) when not empty?(exps(e))
         (e) : e
   match(first-exp(e)) :
      (e:False|IPackage) : false
      (e:IExp) : lang/check/error!(info(e), "First expression in a program must be a package declaration.")

defn ensure-no-cap (e:IExp) :
   match(e) :
      (e:ICap) : lang/check/error!(info(e), "Capture variable ?~ cannot be used in this context." << [name(e)])
      (e) : do(ensure-no-cap, e)   

defn ensure-ordered-targs (es:List<IExp>) :
   defn loop* (es:List<IExp>) :
      if not empty?(es) :
         match(head(es)) :
            (e:ICap) :
               if not all?({_ typeof ICap}, es) :
                  lang/check/error!(info(e), "Capture variables must appear after all explicit type arguments.")
            (e) : loop*(tail(es))
   loop*(es)

defn ensure-capturing-position (targs:List<IExp>, a1:List<IExp>) :
   defn captures? (x:Symbol, e:IExp) :
      match(e) :
         (e:ICap) :
            match(name(e)) :
               (v:IVar) : name(v) == x
               (v) : false
         (e) : any?(captures?{x, _}, children(e))
   defn ensure-captured? (info:FileInfo, x:Symbol) :
      val captured? = any?(captures?{x, _}, a1)
      if not captured? :
         lang/check/error!(info, "Captured type argument ~ has no capturing position." << [x])
         
   val cargs = filter({_ typeof ICap}, targs) as Streamable<ICap>   
   for a in cargs do :
      val v = name(name(a) as IVar)
      ensure-captured?(info(a), v)

defn ensure-matched-a1-args (info:FileInfo, a1:List<IExp>, args:List<IExp>) :
   if length(a1) != length(args) :
      lang/check/error!(info, "The number of argument types do not match the number of arguments.")

defn ensure-no-this-param (e:IDefmethod) :
   if any?(var?{_, `this}, args(e)) :
      lang/check/error!(info(e), "Top level method cannot have a this argument.")

defn ensure-this-param (e:IDefmethod) :
   val n = count(var?{_, `this}, args(e))
   if n == 0 :
      lang/check/error!(info(e), "Instance method requires a this argument.")
   else if n > 1 :
      lang/check/error!(info(e), "Instance method cannot have multiple this arguments.")
   else :   
      val i = index-when(var?{_, `this}, args(e)) as Int
      if a1(e)[i] not-typeof INone :
         lang/check/error!(info(e), "Cannot give the this argument an explicit type.")

defn pure-expression? (e:IExp) :
   e typeof IFn|IMulti|INew|IVar|ILiteral|ITuple

defn ensure-impure (e:IExp) :
   if pure-expression?(e) :
      lang/check/error!(info(e), "Expected statement but received pure expression ~." << [e])
         
defn ensure-body (e:IExp) :
   val es = match(e) :
      (e:IBegin) : exps(e)
      (e) : list(e)

   do(ensure-impure, but-last(es))
   match(last(es)) :
      (e:IDef|IDefVar|IDefn) :
         lang/check/error!(info(e), "Declaration cannot be last expression in body." << [e])
      (e) : false

defn ensure-branch-arity (e:IMatch) :
   val bs = branches(e) as List<IBranch>
   val n = length(args(e))
   for b in bs do :
      if length(args(b)) != n :
         lang/check/error!(info(b), "The number of branch arguments does not match number of arguments given to match.")

defn ensure-literal (e:ILiteral) :
   defn lit? (v) :
      match(v) :
         (v:Byte|Char|Int|Long|Float|Double|String|Symbol|True|False) : true
         (v:List) : all?(lit?, v)
         (v) : false
   if not lit?(value(e)) :
      lang/check/error!(info(e), "Value ~ is not a valid Stanza literal." << [value(e)])

defn ensure-matched-type-fields (info:FileInfo, ts:List<IExp>, fs:List<IExp>) :
   if length(ts) != length(fs) :
      lang/check/error!(info, "The number of field types does not match the number of fields.")

defn ensure-matched-rtype-rfield (info:FileInfo, t:IExp, f:IExp) :
   match(t, f) :
      (t:INone, f:INone) : false
      (t:INone, f) : lang/check/error!(info, "No type given for rest field ~." << [f])
      (t, f:INone) : lang/check/error!(info, "Type ~ given for rest field, but no rest field given." << [t])
      (t, f) : false

defn ensure-no-return (body:IExp) :
   match(body) :
      (body:ILSDefn|ILSDefmethod) :
         false
      (body:ILSReturn) :
         lang/check/error!(info(body), "Invalid return statement in top level context.")
      (body) :
         do(ensure-no-return, body)

defn ensure-return (exp:IExp) :
   ;Apply function for every body in e
   defn do-last (f: IExp -> ?, e:IExp) :
      match(e) :
         (e:IBegin) :
            do-last(f, last(exps(e)))
         (e:ILSLet) :
            do-last(f, comm(e))
         (e:ILSLabels) :
            do-last(f, body(e))
         (e:ILSIf) :
            do-last(f, conseq(e))
            do-last(f, alt(e))
         (e:ILSMatch) :
            for b in branches(e) as List<ILSBranch> do :
               do-last(f, body(b))
         (e) : f(e)

   ;Check last statement
   for e in exp do-last :
      match(e) :
         (e:ILSReturn|ILSGoto) : false
         (e) : lang/check/error!(info(e), "Return statement expected here for end of function body.")

defn ensure-ls-literal (e:ILiteral) :
   defn lit? (v) :
      v typeof Int|Float|String|True|False
   if not lit?(value(e)) :
      lang/check/error!(info(e), "Value ~ is not a valid LoStanza literal." << [value(e)])


