defpackage stz/input :
   import core
   import verse
   import stz/il-ir

;============================================================
;================== DECLARATION =============================
;============================================================

#use-overlay(stz/reader-lang)

defn flatten (es:List<IExp>) :
   for e in es map-append :
      match(e) :
         (e:IBegin) : exps(e)
         (e:ILSBegin) : comms(e)
         (e) : list(e)

defreader SEXP-TABLE :
   e -> IExp :
      ;Package Forms
      ($package name:e imports:e ...) :
         IPackage(name, imports, info)
      ($import name:e prefixes:e ...) :
         IImport(name, prefixes, info)
      ($prefix-of (names:e ...) p:e) :
         IPrefix(names, p, info)
      ($prefix p:e) :
         IPrefix(false, p, info)
      ($public e:e) :
         IPublic(e, info)
      ($protected e:e) :
         IProtected(e, info)
         
      ;Stanza Declaration Forms
      ($deftype name:e (args:e ...) parent:e) :
         IDefType(name, args, parent, info)
      ($def name:e type:e value:e) :
         IDef(name, type, value, info)
      ($defvar name:e type:e value:e) :
         IDefVar(name, type, value, info)      
      ($defn name:e (targs:e ...) (a1:e ...) a2:e (args:e ...) body:e) :
         IDefn(false, name, targs, a1, a2, args, body, info)
      ($defn* name:e (targs:e ...) (a1:e ...) a2:e (args:e ...) body:e) :
         IDefn(true, name, targs, a1, a2, args, body, info)         
      ($defmulti name:e (targs:e ...) (a1:e ...) a2:e) :
         IDefmulti(name, targs, a1, a2, info)
      ($defmethod name:e (targs:e ...) (a1:e ...) a2:e (args:e ...) body:e) :
         IDefmethod(false, name, false, targs, a1, a2, args, body, info)
      ($defmethod* name:e (targs:e ...) (a1:e ...) a2:e (args:e ...) body:e) :
         IDefmethod(true, name, false, targs, a1, a2, args, body, info)
         
      ;Stanza Expression Forms
      ($fn (a1:e ...) a2:e (args:e ...) body:e) :
         IFn(false, a1, a2, args, body, info)
      ($fn* (a1:e ...) a2:e (args:e ...) body:e) :
         IFn(true, a1, a2, args, body, info)
      ($multi f:e fs:e ...) :
         IMulti(List(f, fs), info)
      ($begin es:e ...) :
         IBegin(flatten(es), info)
      ($match (es:e ...) bs:e ...) :
         IMatch(es, bs, info)
      ($branch (ts:e ...) (args:e ...) body:e) :
         IBranch(ts, args, body, info)
      ($new type:e methods:e ...) :
         INew(type, methods, info)
      ($as exp:e type:e) :
         ICast(exp, type, info)
      ($set name:e exp:e) :
         ISet(name, exp, info)
      ($do f:e args:e ...) :
         IDo(f, args, info)
      ($prim f:e args:e ...) :
         IPrim(f, args, info)
      ($call-ls f:e args:e ...) :
         ICallLS(f, args, info)
      ($tuple es:e ...) :
         ITuple(es, info)
      ($quote v:?) :
         ILiteral(unwrap-all(v), INone(info), info)
      ($none) :
         INone(info)
      x :
         IVar(x, info)
      v :
         ILiteral(v, INone(info), info)
         
      ;Stanza Type Forms   
      ($of name:e args:e ...) :
         IOf(name, args, info)
      ($and a:e b:e) :
         IAnd(a, b, info)
      ($or a:e b:e) :
         IOr(a, b, info)
      ($-> (a1:e ...) a2:e) :
         IArrow(a1, a2, info)
      ($cap x:e) :
         ICap(x, info)
      ($void) :
         IVoid(info)
      ($?) :
         IGradual(info)

      ;LoStanza Expressions
      ($ls-new type:e args:e ...) :
         ILSNew(type, args, info)
      ($ls-array type:e (args:e ...) length:e) :
         ILSArray(type, args, length, info)
      ($ls-struct type:e args:e ...) :
         ILSStruct(type, args, info)
      ($ls-addr exp:e) :
         ILSAddr(exp, info)
      ($ls-deref exp:e) :
         ILSDeref(exp, info)
      ($ls-slot exp:e i:e) :
         ILSSlot(exp, i, info)
      ($ls-field exp:e name:e) :
         ILSField(exp, name, info)
      ($ls-do f:e args:e ...) :
         ILSDo(f, args, info)
      ($ls-call-c f:e args:e ...) :
         ILSCallC(f, args, info)
      ($ls-prim f:e args:e ...) :
         ILSPrim(f, args, info)
      ($ls-sizeof type:e) :
         ILSSizeof(type, info)
      ($ls-tagof name:e) :
         ILSTagof(name, info)
      ($ls-as exp:e type:e) :
         ILSAs(exp, type, info)
      ($ls-letexp c:e e:e) :
         ILSLetExp(c, e, info)
      ($ls-and a:e b:e) :
         ILSAnd(a, b, info)
      ($ls-or a:e b:e) :
         ILSOr(a, b, info)

      ;Commands
      ($ls-set x:e y:e) :
         ILSSet(x, y, info)
      ($ls-label name:e) :
         ILSLabel(name, info)
      ($ls-goto name:e) :
         ILSGoto(name, info)
      ($ls-return e:e) :
         ILSReturn(e, info)
      ($ls-let c:e) :
         ILSLet(c, info)
      ($ls-if p:e c:e a:e) :
         ILSIf(p, c, a, info)
      ($ls-begin es:e ...) :
         ILSBegin(flatten(es), info)
      ($ls-match (args:e ...) bs:e ...) :
         ILSMatch(args, bs, info)
      ($ls-branch (ts:e ...) (args:e ...) body:e) :
         ILSBranch(ts, args, body, info)
         
      ;Declarations   
      ($ls-def name:e type:e exp:e) :
         ILSDef(name, type, exp, info)
      ($ls-defvar name:e type:e exp:e) :
         ILSDefVar(name, type, exp, info)
      ($ls-deftype name:e (targs:e ...) parent:e (ts:e ...) tr:e (fs:e ...) fr:e) :
         ILSDefType(name, targs, parent, ts, tr, fs, fr, info)
      ($ls-defn name:e (targs:e ...) (a1:e ...) a2:e (args:e ...) body:e) :
         ILSDefn(false, name, targs, a1, a2, args, body, info)
      ($ls-defn* name:e (targs:e ...) (a1:e ...) a2:e (args:e ...) body:e) :
         ILSDefn(true, name, targs, a1, a2, args, body, info)
      ($ls-extern name:e type:e) :
         ILSExtern(name, type, info)
      ($ls-externfn name:e type:e) :
         ILSExternFn(name, type, info)

      ;Types
      ($ls-byte) :
         ILSByteT(info)
      ($ls-int) :
         ILSIntT(info)
      ($ls-long) :
         ILSLongT(info)
      ($ls-float) :
         ILSFloatT(info)
      ($ls-double) :
         ILSDoubleT(info)
      ($ls-?) :
         ILSUnknownT(info)
      ($ls-ptr t:e) :
         ILSPtrT(t, info)
      ($ls-ref t:e) :
         ILSRefT(t, info)
      ($ls-fn (a1:e ...) ar:e a2:e) :
         ILSFnT(a1, ar, a2, info)
         



;============================================================
;================== IMPLEMENTATION ==========================
;============================================================


;               Token Information Propagation
;               =============================

defn fill-info (form) :
   ;Find the first informative info
   defn first-info (a:FileInfo, b:FileInfo) :
      match(a) :
         (a:NoFileInfo) : b
         (a) : a
   defn first-info (x) :
      defn infos (x) :
         generate<FileInfo> :
            defn loop (x) :
               match(x) :
                  (x:Token) :
                     yield(info(x))
                     loop(item(x))
                  (x:List) : do(loop, x)
                  (x) : false
            loop(x)      
      reduce(first-info, FileInfo(), infos(x))

   ;Fill file information up tree
   defn fill-up (x, info:FileInfo) -> Token :
      match(x) :
         (x:Token) :
            fill-up(item(x), core/info(x))
         (x:List) :
            val x* = map(fill-up{_, FileInfo()}, x)
            val info* = first-info(info, first-info(x*))
            Token(x*, info*)
         (x) :
            Token(x, info)

   ;Fill file information down tree
   defn fill-down (x, info:FileInfo) -> Token :
      match(x) :
         (x:Token) :
            fill-down(item(x), first-info(core/info(x), info))
         (x:List) :
            val x* = map(fill-down{_, info}, x)
            Token(x*, info)
         (x) :
            Token(x, info)

   ;Driver
   fill-down(fill-up(form, FileInfo()), FileInfo())


;               FormTable Datastructures
;               ========================

defstruct FormTable :
   types: Tuple<KeyValue<Symbol, Tuple<Form>>>

definterface Form
defstruct TagForm <: Form :
   tag: Symbol
   fields: Tuple<Field>
   body: (Array, FileInfo) -> ?
defstruct SForm <: Form :
   body: (Symbol, FileInfo) -> ?
defstruct VForm <: Form :
   body: (?, FileInfo) -> ?

definterface Field
defstruct SField <: Field : (type: Symbol)
defstruct LField <: Field : (type: Symbol)
defstruct RField <: Field : (type: Symbol)   


;               Production Table Analysis
;               =========================

defstruct ProdTable :
   tagforms: HashTable<Symbol, TagForm>
   sform: False|SForm
   vform: False|VForm

defn tag? (t:ProdTable, x:Symbol) :
   key?(tagforms(t), x)

defn ProdTable (forms:Tuple<Form>) :
   val tagforms = HashTable<Symbol,TagForm>(symbol-hash)
   var sform = false
   var vform = false
   for f in forms do :
      match(f) :
         (f:TagForm) :
            if key?(tagforms, tag(f)) :
               error("Duplicate production for form ~." % [tag(f)])
            tagforms[tag(f)] = f
         (f:SForm) :
            error("Duplicate symbol form.") when sform != false
            sform = f   
         (f:VForm) :
            error("Duplicate value form.") when vform != false
            vform = f
   ProdTable(tagforms, sform, vform)


;                 Read Form to Input IR
;                 =====================

public defn read (form) :
   ;               Analyse productions
   ;               ===================
   val prod-tables = HashTable<Symbol, ProdTable>(symbol-hash)
   for entry in types(SEXP-TABLE) do :
      prod-tables[key(entry)] = ProdTable(value(entry))

   defn stanza-tag? (tag:Symbol) :
      for t in values(prod-tables) any? :
         tag?(t, tag)

   ;                   Error Buffer
   ;                   ============

   val read-errors = Vector<ReadError>()
   defn error! (e:ReadError) :
      add(read-errors, e)
      throw(e)

   defn read-prod (form, prod:Symbol) :
      if prod == `? : unwrap-all(form)
      else : read-prod(form, prod-tables[prod])
      
   defn read-prod (form, table:ProdTable) :
      ;Ensure proper form
      defn ensure-min-arity! (form:List, n:Int) :
         error!(MinArityError(form, n)) when (length(form) - 1) < n
      defn ensure-arity! (form:List, n:Int) :
         error!(ArityError(form, n)) when (length(form) - 1) != n

      ;Read form according to the field descriptors
      defn read-fields (fs:Tuple<Field>, form:List) :
         ;Ensure that x at position i is a list.
         defn list! (x, i:Int) :
            match(unwrap-token(x)) :
               (x:List) : x
               (x) : error!(NotListError(head(form), i, x))

         ;Ensure proper arity of form
         val n = length(fs)
         if any?({_ typeof RField}, fs) :
            ensure-min-arity!(form, n - 1)
         else :
            ensure-arity!(form, n)

         ;Read production and track whether it passed.
         var pass? = true
         defn read-prod? (form, prod:Symbol) :
            try :
               read-prod(form, prod)
            catch (e) :
               pass? = false
         defn read-prods? (form:List, prod:Symbol) :
            map(read-prod?{_, prod}, form)

         ;Read all values according to their field descriptors.
         val values = Array<?>(n)
         defn* loop (i:Int, form:List) :
            if i < n :
               values[i] = match(fs[i]) :
                  (f:SField) : read-prod?(head(form), type(f))
                  (f:LField) : read-prods?(list!(head(form), i), type(f))                     
                  (f:RField) : read-prods?(form, type(f))
               loop(i + 1, tail(form)) when fs[i] not-typeof RField
         loop(0, tail(form))

         ;Return read values, unless they did not pass reading
         if pass? : values
         else : throw(ReadError())

      ;Retrieve the tagform for a given form, or fail
      defn tagform-of (form:List, info:FileInfo) :
         if not empty?(form) :
            match(unwrap-token(head(form))) :
               (tag:Symbol) :
                  match(get?(tagforms(table), tag, false)) :
                     (t:TagForm) :
                        t
                     (t:False) :
                        if stanza-tag?(tag) : error!(InvalidContext(form, info))
                        else : error!(InvalidForm(form, info))
               (tag) : error!(InvalidForm(form, info))
         else : error!(InvalidForm(form, info))

      ;Dispatch based upon the type of the form
      defn r (form, info:FileInfo) :
         match(form) :
            (form:Token) :
               r(item(form), core/info(form))
            (form:List) :
               val f = tagform-of(form, info)
               val values = read-fields(fields(f), form)
               body(f)(values, info)
            (form:Symbol) :
               match(sform(table)) :
                  (f:SForm) : body(f)(form, info)
                  (f:False) : error!(InvalidContext(form, info))
            (form) :
               match(vform(table)) :
                  (f:VForm) : body(f)(form, info)
                  (f:False) : error!(InvalidContext(form, info))                  
      r(form, FileInfo())

   val prod1 = key(types(SEXP-TABLE)[0])
   try :
      read-prod(fill-info(form), prod1)
   catch (e:ReadError) :
      do(println, read-errors)
      throw(ReadError())

;============================================================
;================= Errors ===================================
;============================================================

definterface ReadError <: Exception
defn ReadError () :
   new ReadError :
      defmethod print (o:OutputStream, this) :
         print(o, "ReadError")

defn ReadError (msg, info) :
   new ReadError :
      defmethod print (o:OutputStream, this) :
         print(o, "~: ~" << [info, msg])

defn MinArityError (form:List, n:Int) :
   val info = info(head(form) as Token)
   ReadError{_, info} $
      "Stanza form ~ expects at least ~ arguments, but found only ~." << [
         head(form), n, length(form) - 1]

defn ArityError (form:List, n:Int) :
   val info = info(head(form) as Token)
   ReadError{_, info} $
      "Stanza form ~ expects ~ arguments, but found ~." << [
         head(form), n, length(form) - 1]

defn InvalidForm (form:List, info:FileInfo) :
   ReadError{_, info} $
      "Form ~ is not a valid Stanza core form." << [form]

defn NotListError (tag:Token, i:Int, x) :
   ReadError{_, info(tag)} $
      "Stanza form ~ expects a list in argument position ~, but received ~." << [tag, i, x]

defn InvalidContext (form, info:FileInfo) :
   ReadError{_, info} $
      "Inappropriate form ~ for in this context." << [form]

   
;============================================================      
;================= Syntax Restrictions ======================
;============================================================
;

#with-overlay(stz/check-lang) :
   public defcheck check (e:IExp) :
      ;======== Stanza Language ========
      pe*("package level form") :
         + pe
         custom{ensure-package(e)}
         
      pe("package level form") :
         IPackage: {name:v imports:(imp ...)}
         IBegin: {exps:(pe ...)}
         + te
   
      imp("import form") :
         IImport: {package:v prefix:(pr ...)}
   
      pr("prefix form") :
         IPrefix :
            if (names(e) == false) : {prefix:v}
            else : {names:(v ...) prefix:v}
   
      te("top level form") :
         IPublic: {exp:te}
         IProtected: {exp:te}
         IDefType: {class:v args:(v ...) parent:pt?}
         IDefmulti :
            {targs:(targ ...) a1:(ct? ...) a2:t?}
            custom{(ensure-ordered-targs(targs(e)))}
            custom{(ensure-capturing-position(targs(e), a1(e)))}
;         IDefmethod :
;            {multi:v targs:(targ ...) a1:(ct? ...) a2:t? args:(b ...) body:se}
;            custom{(ensure-no-this-param(e))}
;            custom{(ensure-ordered-targs(targs(e)))}
;            custom{(ensure-matched-a1-args(info(e), a1(e), args(e)))}
;            custom{(ensure-capturing-position(targs(e), a1(e)))}
;         IBegin: {exps:(te ...)}
;         ILoStanza (exp:ltc)
;         + tse
;      tse("top level form") :
;         + se*
;         after{ensure-impure(e)}
;
;      se("scope level form") :
;         + se*
;         after{ensure-body(e)}         
;      se*("scope level form") :
;         IDef (name:b type:t? value:e)
;         IDefVar (name:v type:t? value:e?)
;         IDefn :
;            (name:v targs:(targ ...) a1:(ct? ...) a2:t? args:(b ...) body:se)
;            custom{(ensure-matched-a1-args(info(e), a1(e), args(e)))}
;            custom{(ensure-ordered-targs(targs(e)))}
;            custom{(ensure-capturing-position(targs(e), a1(e)))}
;         IBegin (exps:(se* ...))
;         + e
;   
;      e("expression") :
;         IMulti (funcs:(func ...))
;         IBegin (exps:(e e ...))
;         IMatch :
;            (args:(b ...) branches:(br br ...))
;            custom{(ensure-branch-arity(e))}
;         INew (class:pt methods:(m ...))
;         IVar ()
;         ICast (exp:e type:t)
;         ISet (name:v value:e)
;         IDo (func:farg args:(e ...))
;   ;      IPrim :
;   ;         switch(function) :
;   ;            add : (args:(e, e))
;   ;            sub : (args:(e, e))
;   ;            else : custom{(unrecognized-prim(e))}
;         ICallLS (function:lfarg args:(e ...))
;         ILiteral :
;            custom{(ensure-literal(e))}
;         ITuple (exps:(e ...))
;         + func
;   
;      e?("optional expression") :
;         INone ()
;         + e
;   
;      func("function expression") :
;         IFn :
;            (a1:(t? ...) a2:t? args:(b ...) body:se)
;            custom{(ensure-matched-a1-args(info(e), a1(e), args(e)))}
;   
;      farg("function argument") :
;         IOf (class:v args:(t ...))
;         + e
;   
;      lfarg("lostanza function expression") :
;         IOf (class:v args:(t ...))
;         IVar ()
;   
;      br("branch expression") :
;         IBranch :
;            (types:(t? ...) args:(b ...) body:se)
;            custom{(ensure-matched-a1-args(info(e), types(e), args(e)))}
;   
;      m("method expression") :
;         IDefmethod :
;            (multi:v targs:(targ ...) a1:(ct? ...) a2:t? args:(b ...) body:se)
;            custom{(ensure-matched-a1-args(info(e), a1(e), args(e)))}
;            custom{(ensure-this-param(e))}
;            custom{(ensure-ordered-targs(targs(e)))}
;            custom{(ensure-capturing-position(targs(e), a1(e)))}
;   
;      b("binder expression") :
;         IVar ()
;         ITuple (exps:(b ...))
;   
      pt("parent type") :
         IOf: {class:v args:(t ...)}
         IAnd: {a:pt b:pt}
         IVar: ()
         
;      pt?("optional parent type") :
;         INone: ()
;         + pt
   
      ct("type") :
         IOf: {class:v args:(ct ...)}
         IAnd: {a:ct b:ct}
         IOr: {a:ct b:ct}
         IArrow: {a1:(t ...) a2:ct}
         ICap: {name:v}
         IGradual: ()
         IVoid: ()
         IVar: ()
         ITuple: {exps:(ct ...)}
   
;      ct?("optional type") :
;         INone: ()
;         + ct
   
      t("type") :
         + ct
         custom{ensure-no-cap(e)}
;      t?("optional type") :
;         INone: ()
;         + t
   
      v("symbol") :
         IVar : ()

      targ("type argument") :
         ICap (name:v)
         IVar ()      
;         
;      ;======== LoStanza Language ========
;      ltc("LoStanza top level command") :   
;         ILSDef (name:lv type:lt exp:le?)
;         ILSDefStruct :
;             (name:lv parents:(lv ...) types:(lt ...) rtype:lt? fields:(lv ...) rfield:lv?)
;             custom{(ensure-matched-type-fields(info(e), types(e), fields(e)))}
;             custom{(ensure-matched-rtype-rfield(info(e), rtype(e), rfield(e)))}             
;         ILSExtern (name:lv type:lt)
;         ILSExternFn (name:lv type:lft)
;         ILSDefn :
;            (name:lv a1:(lt ...) a2:lt args:(lv ...) body:lc)
;            custom{(ensure-matched-a1-args(info(e), a1(e), args(e)))}
;            custom{(ensure-return(body(e)))}
;         ILSBegin (comms:(ltc ...))
;         ILSSet (exp:lval value:le)
;         ILSLet (comm:lc)
;         ILSIf (pred:le conseq:lc alt:lc)
;         ILSMatch (exp:le branches:(lbr lbr ...))
;         ILSDo (func:le args:(le ...))
;         ILSCallC (func:lv args:(le ...))
;   
;      lc("LoStanza command") :
;         ILSDef :
;            (name:lv type:lt? exp:le?)
;            custom{(ensure-type-inferable(e))}
;         ILSBegin (comms:(lc ...))
;         ILSTCall (exp:call)
;         ILSSet (exp:lval value:le)
;         ILSLabel (name:lv)
;         ILSGoto (name:lv)
;         ILSReturn (exp:le)
;         ILSLet (comm:lc)
;         ILSIf (pred:le conseq:lc alt:lc)
;         ILSMatch (exp:le branches:(lbr lbr ...))
;         ILSDo (func:le args:(le ...))
;         ILSCallC (func:lv args:(le ...))   
;   
;      lbr("LoStanza branch") :
;         ILSBranch (exp:lv type:lv body:lc)
;   
;      call("LoStanza do expression") :
;         ILSDo (func:le args:(le ...))
;   
;      le("LoStanza expression") :
;         ILSVar ()
;         ILSRef (name:lv args:(le ...))
;         ILSRefArray (name:lv length:le args:(le ...))
;         ILSStruct (name:lv args:(le ...))
;         ILSPtr (exp:lval)
;         ILSDeref (exp:le)
;         ILSSlot (exp:le index:le)
;         ILSField (exp:le name:lv)
;         ILSDo (func:le args:(le ...))
;         ILSCallC (func:lv args:(le ...))
;   ;      ILSPrim (op:lv args:(le ...))
;         ILSSizeof (type:lt)
;         ILSTagof (name:lv)
;         ILSAs (exp:le type:lt)
;         ILSSignedCast (exp:le type:lpt)
;         ILSUnsignedCast (exp:le type:lpt)
;         ILSValue :
;            (type:lt)
;            custom{(ensure-ls-value(e))}
;         ILSAnd (a:le, b:le)
;         ILSOr (a:le, b:le)
;         + intrin
;   
;      le?("optional LoStanza expression") :
;         INone ()
;         + le
;   
;      intrin("LoStanza intrinsic expression") :
;         ILSIntrinsic :
;            switch lsvar?{name(e), _} :
;               `heap-mem : (args:())
;               else : custom{(unrecognized-intrinsic(name(e)))}
;   
;      lval("LoStanza lvalue expression") :
;         ILSVar ()
;         ILSDeref (exp:le)
;         ILSSlot (exp:le index:le)
;         ILSField (exp:le name:lv)
;         + intrin
;   
;      lpt("LoStanza primitive type") :
;         ILSByteT ()
;         ILSIntT ()
;         ILSLongT ()
;         ILSFloatT ()
;         ILSDoubleT ()
;   
;      lt("LoStanza type") :
;         ILSUnknownT ()
;         ILSPtrT (type:lt)
;         ILSRefT (type:lt)
;         + lft
;         + lpt
;         
;      lt?("optional LoStanza type") :
;         INone ()
;         + lt
;   
;      lft("LoStanza function type") :
;         ILSFnT (a1:(lt ...) ar:lt? a2:lt)
;   
;      lv("symbol") :
;         ILSVar ()
;   
;      lv?("optional symbol") :
;         INone ()
;         + lv
;
;defn var? (e:IExp, s:Symbol) :
;   match(e) :
;      (e:IVar) : name(e) == s
;      (e) : false
;
;defn lsvar? (e:IExp, s:Symbol) :
;   match(e) :
;      (e:ILSVar) : name(e) == s
;      (e) : false
;

;============================================================
;================== Error Checkers ==========================
;============================================================

defn ensure-package (e:IExp) :
   defn first-exp (e:IExp) -> IExp|False :
      match(e) :
         (e:IBegin) : first-exp(exps(e))
         (e) : e
   defn first-exp (es:List<IExp>) -> IExp|False :
      if not empty?(es) :
         match(first-exp(head(es))) :
            (e:False) : first-exp(tail(es))
            (e) : e
   match(first-exp(e)) :
      (e:False|IPackage) : false
      (e:IExp) : lang/check/error!(info(e), "First expression in a program must be a package declaration.")

defn ensure-no-cap (e:IExp) :
   match(e) :
      (e:ICap) : lang/check/error!(info(e), "Capture variable ?~ cannot be used in this context." << [name(e)])
      (e) : do(ensure-no-cap, e)   

defn ensure-ordered-targs (es:List<IExp>) :
   defn loop* (es:List<IExp>) :
      if not empty?(es) :
         match(head(es)) :
            (e:ICap) :
               if not all?({_ typeof ICap}, es) :
                  lang/check/error!(info(e), "Capture variables must appear after all explicit type arguments.")
            (e) : loop*(tail(es))
   loop*(es)

defn ensure-capturing-position (targs:List<IExp>, a1:List<IExp>) :
   defn captures? (x:Symbol, e:IExp) :
      match(e) :
         (e:ICap) :
            match(name(e)) :
               (v:IVar) : name(v) == x
               (v) : false
         (e) : any?(captures?{x, _}, children(e))
   defn ensure-captured? (info:FileInfo, x:Symbol) :
      val captured? = any?(captures?{x, _}, a1)
      if not captured? :
         lang/check/error!(info, "Captured type argument ~ has no capturing position." << [x])
         
   val cargs = filter({_ typeof ICap}, targs) as Streamable<ICap>   
   for a in cargs do :
      val v = name(name(a) as IVar)
      ensure-captured?(info(a), v)

;defn ensure-matched-a1-args (info:FileInfo, a1:List<IExp>, args:List<IExp>) :
;   if length(a1) != length(args) :
;      lang/check/error!(info, "The number of argument types do not match the number of arguments.")
;
;defn ensure-no-this-param (e:IDefmethod) :
;   if any?(var?{_, `this}, args(e)) :
;      lang/check/error!(info(e), "Top level method cannot have a this argument.")
;
;defn ensure-this-param (e:IDefmethod) :
;   val i = index-when(var?{_, `this}, args(e))
;   if i == false :
;      lang/check/error!(info(e), "Instance level method requires a this argument.")
;   if length(a1(e)) == length(args(e)) :
;      val t = a1(e)[i as Int]
;      if t not-typeof INone :
;         lang/check/error!(info(e), "Cannot give the this argument an explicit type.")
;
;defn pure-expression? (e:IExp) :
;   e typeof IFn|IMulti|INew|IVar|ILiteral|ITuple
;
;defn ensure-impure (e:IExp) :
;   if pure-expression?(e) :
;      lang/check/error!(info(e), "Invalid context for pure expression ~. Expression with effect expected here." << [e])   
;         
;defn ensure-body (e:IExp) :
;   val es = match(e) :
;      (e:IBegin) : exps(e)
;      (e) : list(e)
;   if empty?(es) :
;      lang/check/error!(info(e), "Invalid syntax. Body has no expressions in it.")
;   else :
;      do(ensure-impure, but-last(es))
;      match(last(es)) :
;         (e:IDef|IDefVar|IDefn) : lang/check/error!(info(e), "Declaration cannot be last expression in body." << [e])
;         (e) : false
;
;defn ensure-branch-arity (e:IMatch) :
;   if all?({_ typeof IBranch}, branches(e)) :
;      val n = length(args(e))
;      for b in branches(e) as List<IBranch> do :
;         if length(args(b)) != n :
;            lang/check/error!(info(b), "The number of branch arguments does not match number of arguments given to match.")
;
;defn ensure-literal (e:ILiteral) :
;   defn lit? (v) :
;      match(v) :
;         (v:Int|Float|Symbol|String) : true
;         (v:List) : all?(lit?, v)
;         (v) : false
;   if not lit?(value(e)) :
;      lang/check/error!(info(e), "Value ~ is not a valid Stanza literal." << [value(e)])
;
;defn ensure-matched-type-fields (info:FileInfo, ts:List<IExp>, fs:List<IExp>) :
;   if length(ts) != length(fs) :
;      lang/check/error!(info, "The number of field types does not match the number of fields.")
;
;defn ensure-matched-rtype-rfield (info:FileInfo, t:IExp, f:IExp) :
;   match(t, f) :
;      (t:INone, f:INone) : false
;      (t:INone, f) : lang/check/error!(info, "No type given for rest field ~." << [f])
;      (t, f:INone) : lang/check/error!(info, "Type ~ given for rest field, but no rest field given." << [t])
;      (t, f) : false
;
;defn ensure-return (body:IExp) :
;   ;Find the last expression in the body
;   defn last-exp (e:IExp) -> IExp|False :
;      match(e) :
;         (e:ILSBegin) : last-exp(comms(e))
;         (e) : e
;   defn last-exp (es:List<IExp>) -> IExp|False :
;      if not empty?(es) :
;         match(last-exp(tail(es))) :
;            (e:False) : last-exp(head(es))
;            (e) : e
;      
;   match(body) :
;      (body:ILSBegin) :
;         match(last-exp(body)) :
;            (e:False) : lang/check/error!(info(body), "Return statement expected here for end of function body.")
;            (e:IExp) : ensure-return(e)
;      (body:ILSReturn|ILSGoto|ILSTCall) :
;         ;Found return
;         false
;      (body:ILSDef|ILSSet|ILSLabel|ILSDo|ILSCallC) :
;         ;Did not find return
;         lang/check/error!(info(body), "Return statement expected here for end of function body.")
;      (body:ILSLet) :
;         ensure-return(comm(body))
;      (body:ILSIf) :
;         ensure-return(conseq(body))
;         ensure-return(alt(body))
;      (body:ILSMatch) :
;         for b in branches(body) do :
;            ensure-return(b) when b typeof ILSBranch
;      (body) : false
;
;defn ensure-type-inferable (e:ILSDef) :
;   match(type(e), exp(e)) :
;      (t:INone, exp:INone) :
;         lang/check/error!(info(e), "A type must be provided for variable ~ because it has no initializing expression." << [name(e)])
;      (t, exp) :
;         false   
;
;defn ensure-ls-value (e:ILSValue) :
;   defn lit? (v) :
;      match(v) :
;         (v:Int|Float|String) : true
;         (v) : false
;   if not lit?(value(e)) :
;      lang/check/error!(info(e), "Value ~ is not a valid LoStanza literal." << [value(e)])
;
;defn unrecognized-intrinsic (e:IExp) :
;   match(e) :
;      (e:ILSVar) : lang/check/error!(info(e), "Unrecognized intrinsic ~." << [e])
;      (e) : lang/check/error!(info(e), "Name of intrinsic expected here, but found ~." << [e])
;
