defpackage stz/input :
   import core
   import verse
   import stz/il-ir

;============================================================
;================== DECLARATION =============================
;============================================================

#use-overlay(stz/reader-lang)

defreader SEXP-TABLE :
   e -> IExp :
      ;Package Forms
      ($package name:e imports:e ...) :
         IPackage(name, imports, info)
      ($import name:e prefixes:e ...) :
         IImport(name, prefixes, info)
      ($prefix-of (names:e ...) p:e) :
         IPrefix(names, p, info)
      ($prefix p:e) :
         IPrefix(false, p, info)      
      ($export e:e) :
         IExport(e, info)
         
      ;Stanza Forms
      ($deftype name:e (args:e ...) parent:e) :
         IDefType(name, args, parent, info)
      ($def name:e type:e value:e) :
         IDef(name, type, value, info)
      ($defvar name:e type:e value:e) :
         IDefVar(name, type, value, info)      
      ($defn name:e (targs:e ...) (a1:e ...) a2:e (args:e ...) body:e) :
         IDefn(false, name, targs, a1, a2, args, body, info)
      ($defn* name:e (targs:e ...) (a1:e ...) a2:e (args:e ...) body:e) :
         IDefn(true, name, targs, a1, a2, args, body, info)         
      ($defmulti name:e (targs:e ...) (a1:e ...) a2:e) :
         IDefmulti(name, targs, a1, a2, info)
      ($defmethod* name:e (targs:e ...) (a1:e ...) a2:e (args:e ...) body:e) :
         IDefmethod(true, name, false, targs, a1, a2, args, body, info)
      ($fn (a1:e ...) a2:e (args:e ...) body:e) :
         IFn(false, a1, a2, args, body, info)
      ($fn* (a1:e ...) a2:e (args:e ...) body:e) :
         IFn(true, a1, a2, args, body, info)
      ($multi fs:e ...) :
         IMulti(fs, info)
      ($begin es:e ...) :
         IBegin(es, info)
      ($match (es:e ...) bs:e ...) :
         IMatch(es, bs, info)
      ($branch (ts:e ...) (args:e ...) body:e) :
         IBranch(ts, args, body, info)
      ($new type:e methods:e ...) :
         INew(type, methods, info)
      ($as exp:e type:e) :
         ICast(exp, type, info)
      ($set name:e exp:e) :
         ISet(name, exp, info)
      ($do f:e args:e ...) :
         IDo(f, args, info)
      ($prim f:e args:e ...) :
         IPrim(f, args, info)
      ($call-ls f:e args:e ...) :
         ICallLS(f, args, info)
      ($tuple es:e ...) :
         ITuple(es, info)
      ($quote v:?) :
         ILiteral(unwrap-all(v), info)
      ($none) :
         INone(info)
         
      ;Type Forms   
      ($of name:e args:e ...) :
         IOf(name, args, info)
      ($and a:e b:e) :
         IAnd(a, b, info)
      ($or a:e b:e) :
         IOr(a, b, info)
      ($-> (a1:e ...) a2:e) :
         IArrow(a1, a2, info)
      ($cap x:e) :
         ICap(x, info)
      ($void) :
         IVoid(info)
      ($?) :
         IGradual(info)
      ($lostanza e:le) :
         e
         
      ;Atom Forms   
      x :
         IVar(x, info)
      v :
         ILiteral(v, info)

   le -> IExp :
      ;Expressions
      ($ref name:le args:le ...) :
         ILSRef(name, args, info)
      ($refarray name:le length:le args:le ...) :
         ILSRefArray(name, length, args, info)
      ($struct name:le args:le ...) :
         ILSStruct(name, args, info)
      ($ptr exp:le) :
         ILSPtr(exp, info)
      ($deref exp:le) :
         ILSDeref(exp, info)
      ($slot exp:le i:le) :
         ILSSlot(exp, i, info)
      ($field exp:le name:le) :
         ILSField(exp, name, info)
      ($do f:le args:le ...) :
         ILSDo(f, args, info)
      ($call-c f:le args:le ...) :
         ILSCallC(f, args, info)
      ($prim f:le args:le ...) :
         ILSPrim(f, args, info)
      ($sizeof type:le) :
         ILSSizeof(type, info)
      ($tagof name:le) :
         ILSTagof(name, info)
      ($as exp:le type:le) :
         ILSAs(exp, type, info)
      ($signed-cast exp:le type:le) :
         ILSSignedCast(exp, type, info)
      ($unsigned-cast exp:le type:le) :
         ILSUnsignedCast(exp, type, info)
      ($value value:? type:le) :
         ILSValue(value, type, info)
      ($and a:le b:le) :
         ILSAnd(a, b, info)
      ($or a:le b:le) :
         ILSOr(a, b, info)
      ($special name:le args:le ...) :
         ILSIntrinsic(name, args, info)
      ($none) :
         INone(info)

      ;Commands
      ($tcall e:le) :
         ILSTCall(e, info)
      ($set x:le y:le) :
         ILSSet(x, y, info)
      ($label name:le) :
         ILSLabel(name, info)
      ($goto name:le) :
         ILSGoto(name, info)
      ($return e:le) :
         ILSReturn(e, info)
      ($let c:le) :
         ILSLet(c, info)
      ($if p:le c:le a:le) :
         ILSIf(p, c, a, info)
      ($begin es:le ...) :
         ILSBegin(es, info)
      ($match e:le bs:le ...) :
         ILSMatch(e, bs, info)
      ($branch (ts:le ...) b:le) :
         ILSBranch(ts, b, info)
         
      ;Declarations   
      ($def name:le type:le exp:le) :
         ILSDef(name, type, exp, info)
      ($defn name:le (a1:le ...) a2:le (args:le ...) body:le) :
         ILSDefn(name, a1, a2, args, body, info)
      ($defstruct name:le (parents:le ...) (ts:le ...) tr:le (fs:le ...) fr:le) :
         ILSDefStruct(name, parents, ts, tr, fs, fr, info)
      ($extern name:le type:le) :
         ILSExtern(name, type, info)
      ($externfn name:le type:le) :
         ILSExternFn(name, type, info)

      ;Types
      ($byte) :
         ILSByteT(info)
      ($int) :
         ILSIntT(info)
      ($long) :
         ILSLongT(info)
      ($float) :
         ILSFloatT(info)
      ($double) :
         ILSDoubleT(info)
      ($?) :
         ILSUnknownT(info)
      ($ptr t:le) :
         ILSPtrT(t, info)
      ($ref t:le) :
         ILSRefT(t, info)
      ($-> (a1:le ...) ar:le a2:le) :
         ILSFnT(a1, ar, a2, info)
         
      ;Atom Forms
      x :
         ILSVar(x, info)
      v :
         ILSValue(value, INone(info), info)

;============================================================
;================== IMPLEMENTATION ==========================
;============================================================

defstruct FormTable :
   types: Tuple<KeyValue<Symbol, Tuple<Form>>>

definterface Form
defstruct TagForm <: Form :
   tag: Symbol
   fields: Tuple<Field>
   body: (Array, FileInfo) -> ?
defstruct SForm <: Form :
   body: (Symbol, FileInfo) -> ?
defstruct VForm <: Form :
   body: (?, FileInfo) -> ?

definterface Field
defstruct SField <: Field : (type: Symbol)
defstruct LField <: Field : (type: Symbol)
defstruct RField <: Field : (type: Symbol)   

defstruct ProdTable :
   tagforms: HashTable<Symbol, TagForm>
   sform: False|SForm
   vform: False|VForm

defn fill-info (form) :
   ;Find the first informative info
   defn first-info (a:FileInfo, b:FileInfo) :
      match(a) :
         (a:NoFileInfo) : b
         (a) : a
   defn first-info (x) :
      defn infos (x) :
         generate<FileInfo> :
            defn loop (x) :
               match(x) :
                  (x:Token) :
                     yield(info(x))
                     loop(item(x))
                  (x:List) : do(loop, x)
                  (x) : false
            loop(x)      
      reduce(first-info, FileInfo(), infos(x))

   ;Fill file information up tree
   defn fill-up (x, info:FileInfo) -> Token :
      match(x) :
         (x:Token) :
            fill-up(item(x), core/info(x))
         (x:List) :
            val x* = map(fill-up{_, FileInfo()}, x)
            val info* = first-info(info, first-info(x*))
            Token(x*, info*)
         (x) :
            Token(x, info)

   ;Fill file information down tree
   defn fill-down (x, info:FileInfo) -> Token :
      match(x) :
         (x:Token) :
            fill-down(item(x), core/info(x))
         (x:List) :
            val x* = map(fill-down{_, info}, x)
            Token(x*, info)
         (x) :
            Token(x, info)

   ;Driver
   fill-down(fill-up(form, FileInfo()), FileInfo())   

public defn read (form) :
   val tag-table = HashTable<Symbol,True>(symbol-hash)
   defn stanza-tag? (tag:Symbol) : key?(tag-table, tag)
   
   defn make-prod-table (forms: Tuple<Form>) :
      val tagforms = HashTable<Symbol,TagForm>(symbol-hash)
      var sform = false
      var vform = false
      for f in forms do :
         match(f) :
            (f:TagForm) :
               if not key?(tagforms, tag(f)) :
                  tagforms[tag(f)] = f
               tag-table[tag(f)] = true   
            (f:SForm) :
               if sform == false :
                  sform = f
            (f:VForm) :
               if vform == false :
                  vform = f
      ProdTable(tagforms, sform, vform)            
      
   val prod-tables = HashTable<Symbol, ProdTable>(symbol-hash)
   for entry in types(SEXP-TABLE) do :
      prod-tables[key(entry)] = make-prod-table(value(entry))

   val read-errors = Vector<ReadError>()
   defn error! (e:ReadError) :
      add(read-errors, e)
      throw(e)

   defn read-prod (form, prod:Symbol) :
      if prod == `? : unwrap-all(form)
      else : read-prod(form, prod-tables[prod])
      
   defn read-prod (form, table:ProdTable) :
      defn ensure-min-arity! (form:List, n:Int) :
         error!(MinArityError(form, n)) when (length(form) - 1) < n
      defn ensure-arity! (form:List, n:Int) :
         error!(ArityError(form, n)) when (length(form) - 1) != n
      defn read-fields (fs:Tuple<Field>, form:List) :
         defn list! (x, i:Int) :
            match(unwrap-token(x)) :
               (x:List) : x
               (x) : error!(NotListError(head(form), i, x))
         val n = length(fs)
         if any?({_ typeof RField}, fs) : ensure-min-arity!(form, n - 1)
         else : ensure-arity!(form, n)

         ;Read as much as possible
         var pass? = true
         defn read-prod? (form, prod:Symbol) :
            try :
               read-prod(form, prod)
            catch (e) :
               pass? = false
         defn read-prods? (form:List, prod:Symbol) :
            map(read-prod?{_, prod}, form)

         val values = Array<?>(n)
         defn* loop (i:Int, form:List) :
            if i < n :
               values[i] = match(fs[i]) :
                  (f:SField) : read-prod?(head(form), type(f))
                  (f:LField) : read-prods?(list!(head(form), i), type(f))                     
                  (f:RField) : read-prods?(form, type(f))
               loop(i + 1, tail(form)) when fs[i] not-typeof RField      
         loop(0, tail(form))
         throw(ReadError()) when not pass?
         values         

      defn r (form, info:FileInfo) :
         match(form) :
            (form:Token) :
               r(item(form), core/info(form))
            (form:List) :
               if empty?(form) :
                  error!(InvalidForm(form, info))
               else :
                  match(unwrap-token(head(form))) :
                     (tag:Symbol) :
                        match(get?(tagforms(table), tag, false)) :
                           (f:TagForm) :
                              val values = read-fields(fields(f), form)
                              body(f)(values, info)
                           (f:False) :
                              if stanza-tag?(tag) : error!(InvalidContext(form, info))
                              else : error!(InvalidForm(form, info))
                     (tag) :
                        error!(InvalidForm(form, info))                  
            (form:Symbol) :
               match(sform(table)) :
                  (f:SForm) : body(f)(form, info)
                  (f:False) : error!(InvalidContext(form, info))
            (form) :
               match(vform(table)) :
                  (f:VForm) : body(f)(form, info)
                  (f:False) : error!(InvalidContext(form, info))
                  
      r(form, FileInfo())

   val prod1 = key(types(SEXP-TABLE)[0])
   try :
      read-prod(fill-info(form), prod1)
   catch (e) :
      do(println, read-errors)
      throw(ReadError())

;============================================================
;================= Errors ===================================
;============================================================

definterface ReadError <: Exception
defn ReadError () :
   new ReadError :
      defmethod print (o:OutputStream, this) :
         print(o, "ReadError")

defn ReadError (msg, info) :
   new ReadError :
      defmethod print (o:OutputStream, this) :
         print(o, "~: ~" << [info, msg])

defn MinArityError (form:List, n:Int) :
   val info = info(head(form) as Token)
   ReadError{_, info} $
      "Stanza form ~ expects at least ~ arguments, but found only ~." << [
         head(form), n, length(form) - 1]

defn ArityError (form:List, n:Int) :
   val info = info(head(form) as Token)
   ReadError{_, info} $
      "Stanza form ~ expects ~ arguments, but found ~." << [
         head(form), n, length(form) - 1]

defn InvalidForm (form:List, info:FileInfo) :
   ReadError{_, info} $
      "Form ~ is not a valid Stanza core form." << [form]

defn NotListError (tag:Token, i:Int, x) :
   ReadError{_, info(tag)} $
      "Stanza form ~ expects a list in argument position ~, but received ~." << [tag, i, x]

defn InvalidContext (form, info:FileInfo) :
   ReadError{_, info} $
      "Inappropriate form ~ for in this context." << [form]

   
;============================================================      
;================= Syntactic Checking =======================
;============================================================



;defcheck (e:IExp) :
;   ;======== Stanza Language ========
;   pe("package level form") :
;      IPackage (name:v imports:(imp ...))
;      IBegin (exps:(pe ...))
;      + te
;
;   imp("import form") :
;      IImport (package:v prefix:(pr ...))
;
;   pr("prefix form") :
;      IPrefix :
;         if names(e) == false : (prefix:v)
;         else : (names:(v ...) prefix:v)
;
;   te("top level form") :
;      IExport (exp:te)
;      IDefType (class:v args:(v ...) parent:pt?)
;      IDefmulti :
;         (targs:(targ ...) a1:(ct? ...) a2:t?)
;         custom{ensure-ordered-targs(targs(e))}
;      IDefmethod :
;         (multi:v targs:(targ ...) a1:(ct? ...) a2:t? args:(b ...) body:se)
;         custom{ensure-no-this-param(e)}
;         custom{ensure-ordered-targs(targs(e))}
;         custom{ensure-last-exp(body(e))}
;      IBegin (exps:(te ...))
;      + ltc
;      + se
;
;   se("scope level form") :
;      IDef (name:b type:t? value:e)
;      IDefVar (name:v type:t? value:e?)
;      IDefn :
;         (name:v targs:(targ ...) a1:(ct? ...) a2:t? args:(b ...) body:se)
;         custom{ensure-ordered-targs(targs(e))}
;         custom{ensure-last-exp(body(e))}
;      IBegin (exps:(se ...))
;      + e
;
;   e("expression") :
;      IFn :
;         (a1:(t? ...) a2:t? args:(b ...) body:se)
;         custom{ensure-last-exp(body(e))}
;      IMulti (funcs:(f ...))
;      IBegin (exps:(e e ...))
;      IMatch (args:(b ...) branches:(br br ...))
;      INew (class:pt methods:(m ...))
;      IVar ()
;      ICast (exp:e type:t)
;      ISet (name:v value:e)
;      IDo (func:farg args:(e ...))
;      IPrim :
;         switch(function) :
;            add : (args:(e, e))
;            sub : (args:(e, e))
;            else : custom{unrecognized-prim(e)}
;      ICallLS (function:lfarg args:(e ...))
;      ILiteral :
;         (value:?)
;         custom{ensure-literal(e)}
;      ITuple (exps:(e ...))
;
;   farg("function expression") :
;      IOf (class:e args:(t ...))
;      + e
;
;   lfarg("lostanza function expression") :
;      IOf (class:v args:(t ...))
;      IVar ()
;
;   br("branch expression") :
;      IBranch (types:(t? ...) args:(b ...) body:e)
;
;   m("method expression") :
;      IDefmethod :
;         (multi:v targs:(targ ...) a1:(ct? ...) a2:t? args:(b ...) body:se)
;         custom{ensure-last-exp(body(e))}
;         custom{ensure-this-param(e)}
;         custom{ensure-ordered-targs(targs(e))}
;
;   b("binder expression") :
;      IVar ()
;      ITuple (exps:(b ...))
;
;   pt("parent type") :
;      IOf (class:v args:(t ...))
;      IAnd (a:pt b:pt)
;      IVar ()
;      
;   pt?("optional parent type") :
;      INone ()
;      + pt
;
;   ct("type") :
;      IOf (class:v args:(ct ...))
;      IAnd (a:ct b:ct)
;      IOr (a:ct b:ct)
;      IArrow (a1:(t ...) a2:ct)
;      ICap (name:v)
;      IGradual ()
;      IVoid ()
;      IVar ()
;      ITuple (exps:(ct ...))
;
;   ct?("optional type") :
;      INone ()
;      + ct
;
;   t("type") :
;      + ct
;      custom{ensure-no-cap(e)}
;   t?("optional type") :
;      INone ()
;      + t
;
;   v("symbol") :
;      IVar ()
;
;   targ("type argument") :
;      ICap (name:v)
;      IVar ()      
;      
;   ;======== LoStanza Language ========
;   ltc("LoStanza top level command") :   
;      ILSDef (name:lv type:lt e:le?)
;      ILSDefStruct (name:lv parents:(lv ...) types:(lt ...) rtype:lt? fields:(lv ...) rfield:lv?)
;      ILSExtern (name:lv type:lt)
;      ILSExternFn (name:lv type:lft)
;      ILSDefn :
;         (name:lv a1:(lt ...) a2:lt args:(lv ...) body:lc)
;         custom{ensure-return(e)}
;      ILSBegin (comms:(ltc ...))
;      + lc
;
;   lc("LoStanza command") :
;      ILSDef :
;         (name:lv type:lt? e:le?)
;         custom{ensure-type-inferable(e)}
;      ILSBegin (comms:(lc ...))
;      ILSTCall (exp:call)
;      ILSSet (exp:lval value:le)
;      ILSLabel (name:lv)
;      ILSGoto (name:lv)
;      ILSReturn (exp:le)
;      ILSLet (comm:lc)
;      ILSIf (pred:le conseq:lc alt:lc)
;      ILSMatch (exp:le branches:(lbr lbr ...))
;      ILSBranch (types:(lv lv ...) body:lc)
;      ILSDo (func:le args:(le ...))
;      ILSCallC (func:lv args:(le ...))   
;
;   call("LoStanza do expression") :
;      ILSDo (func:le args:(le ...))
;
;   le("LoStanza expression") :
;      ILSVar ()
;      ILSRef (name:lv args:(le ...))
;      ILSRefArray (name:lv length:le args:(le ...))
;      ILSStruct (name:lv args:(le ...))
;      ILSPtr (exp:lval)
;      ILSDeref (exp:le)
;      ILSSlot (exp:le index:le)
;      ILSField (exp:le name:lv)
;      ILSDo (func:le args:(le ...))
;      ILSCallC (func:lv args:(le ...))
;      ILSPrim (op:lv args:(le ...))
;      ILSSizeof (type:lt)
;      ILSTagof (name:lv)
;      ILSAs (exp:le type:lt)
;      ILSSignedCast (exp:le type:lpt)
;      ILSUnsignedCast (exp:le type:lpt)
;      ILSValue :
;         (value:? type:lt)
;         custom{ensure-ls-value(e)}
;      ILSAnd (a:le, b:le)
;      ILSOr (a:le, b:le)
;      + intrin
;
;   intrin("LoStanza intrinsic expression") :
;      ILSIntrinsic :
;         switch(name) :
;            something : ???
;            else : custom{unrecognized-intrinsic(e)}
;
;   lval("LoStanza lvalue expression") :
;      ILSVar ()
;      ILSDeref (exp:le)
;      ILSSlot (exp:le index:le)
;      ILSField (exp:le name:lv)
;      + intrin
;
;   lpt("LoStanza primitive type") :
;      ILSByteT ()
;      ILSIntT ()
;      ILSLongT ()
;      ILSFloatT ()
;      ILSDoubleT ()
;
;   lt("LoStanza type") :
;      ILSUnknownT ()
;      ILSPtrT (type:lt)
;      ILSRefT (type:lt)
;      ILSFnT (a1:(lt ...) ar:lt? a2:lt)
;      + lpt
;      
;   lt?("optional LoStanza type") :
;      INone ()
;      + lt
;
;   lft("LoStanza function type") :
;      ILSFnT (a1:(lt ...) ar:lt? a2:lt)
;
;   lv("symbol") :
;      ILSVar ()
;
;   lv?("optional symbol") :
;      INone ()
;      + lv