defpackage stz/infer :
   import core
   import verse
   import stz/utils
   import stz/tl-ir
   import stz/type-calculus
   import stz/algorithms
   import stz/primitives
   import stz/ids

;============================================================
;================= Constraint Language ======================
;============================================================
#use-overlay(stz/ast-lang, stz/printer-lang, stz/attempt-lang)

public defmulti n (c:Constraint) -> Int

public defast :
   deftype Constraint
   defnodes Constraint :
      FlowConstraint :
         n:Int with: (as-method => true)
         a:Type
         b:Type
      LSFlowConstraint :
         n:Int with: (as-method => true)
         a:LSType
         b:LSType
      SuperConstraint :
         n:Int with: (as-method => true)
         type:Type
      MixConstraint :
         n:Int with: (as-method => true)
         sel:Int
         xs:List<False|TArrow>         
      LSMixConstraint :
         n:Int with: (as-method => true)
         sel:Int
         xs:List<False|FnT>
      LSPickConstraint :
         n:Int with: (as-method => true)
         sel:Int
         xs:List<False|FnT>
      PartofConstraint :
         n:Int with: (as-method => true)
         xs:List<False|TArrow>
         y:Type         
      CallableConstraint :
         n: Int with: (as-method => true)
         xs:List<False|TArrow>
         args:List<List<Type>>
      LSCallableConstraint :
         n: Int with: (as-method => true)
         xs:List<False|FnT>
         args:List<List<LSType>>
      LSSelConstraint :
         n:Int with: (as-method => true)
         xs:List<False|FnT>
         y:LSType
      SelMultiConstraint :
         n:Int with: (as-method => true)
         x:TArrow
         ys:List<False|TArrow>
      SubConstraint :
         n:Int with: (as-method => true)
         x:Type
         env:List<KeyValue<Int, Type>>
      EqualConstraint :
         n:Int with: (as-method => true)
         type:Type
      LSEqualConstraint :
         n:Int with: (as-method => true)
         type:LSType
      DeptrConstraint :
         n:Int with: (as-method => true)
         type:LSType
      DerefConstraint :
         n:Int with: (as-method => true)
         type:LSType
      FieldConstraint :
         n:Int with: (as-method => true)
         type:LSType
         name:Symbol
      ArgConstraint :
         n:Int with: (as-method => true)
         type:LSType
         i:Int
         arity:Int
      RetConstraint :
         n:Int with: (as-method => true)
         type:LSType
      RefTypeConstraint :
         n:Int with: (as-method => true)
         type:LSType
      LSPrimConstraint :
         n:Int with: (as-method => true)
         op:LSPrimitive
         args:List<LSType>

   make-mapper(f: Type -> Type, c:Constraint)
   make-mapper(f: LSType -> LSType, c:Constraint)

   defmapper (f:Type -> Type) :
      (x:Type) : f(x)
      (x:TArrow) : f(x) as TArrow
      (xs:List<False|TArrow>) : for x in xs map : f(x as TArrow) as TArrow when x != false
      (x:List<List<Type>>) : for xs in x map : map(f, xs)
      (xs:List<KeyValue<Int,Type>>) : for x in xs map : key(x) => f(value(x))

   defmapper (f:LSType -> LSType) :
      (x:LSType) : f(x)
      (xs:List<LSType>) : map(f, xs)
      (xs:List<False|FnT>) : for x in xs map : f(x as FnT) as FnT when x != false
      (xs:List<List<LSType>>) : for x in xs map : map(f, x)

   ignore :
      Int
      Symbol
      LSPrimitive


defprinter (c:Constraint) :
   FlowConstraint :
      ($flow n a b)
   LSFlowConstraint :
      ($ls-flow n a b)
   SuperConstraint :
      ($super n type)
   MixConstraint :
      ($mix n sel (xs ...))
   LSMixConstraint :
      ($ls-mix n sel (xs ...))
   LSPickConstraint :
      ($ls-pick n sel (xs ...))
   PartofConstraint :
      ($partof n (xs ...) y)
   CallableConstraint :
      ($callable n (xs ...) (args ...))
   LSCallableConstraint :
      ($ls-callable n (xs ...) (args ...))
   LSSelConstraint :
      ($ls-sel n (xs ...) y)
   SelMultiConstraint :
      ($selmethod n x (ys ...))
   SubConstraint :
      ($sub n x env ...)
   EqualConstraint :
      ($equal n type)
   LSEqualConstraint :
      ($ls-equal n type)
   DeptrConstraint :
      ($deptr n type)
   DerefConstraint :
      ($deref n type)
   FieldConstraint :
      ($field n type name)
   ArgConstraint :
      ($arg n type i arity)
   RetConstraint :
      ($ret n type)
   RefTypeConstraint :
      ($ref-type n type)
   LSPrimConstraint :
      ($ls-prim n op args ...)

;============================================================
;====================== Solver ==============================
;============================================================

defstruct SolveError <: Exception

public defstruct SolveResults :
   types: HashTable<Int,Type>
   lstypes: HashTable<Int,LSType>
   sels: HashTable<Int,Selection>

defstruct SubException <: Exception :
   result: False|Unknown

public defn solve (constraints:Streamable<Constraint>) -> SolveResults :
   println("Solve:")
   do(println, constraints)

   ;======== State ========   
   ;Type: Type is successfully substituted
   ;False: Type depends upon an invalid type.
   ;Unknown: Type depends upon a variable that will never be known.
   val solved = HashTable<Int,False|Unknown|Type>({_})
   val lssolved = HashTable<Int,False|Unknown|LSType>({_})

   ;SSel: Selection is possibly calculated (may contain unknowns)
   ;Unknown: Selection depends upon variables that will never be known.
   val selsolved = HashTable<Int,Unknown|SSel>({_})

   ;Constraint queue.
   val cqueue = Queue<Constraint>()
   do(add{cqueue, _}, constraints)

   ;======== Solving Utility Functions ========
   ;Substitute variables in type.
   ;Throws a SubException when we cannot proceed
   defn sub-known? (t:Type) -> Type :
      println("sub-known?(~)" << [t])
      val r = indented $ fn () :
         defn save (n:Int, t:False|Unknown|Type) :
            solved[n] = t
            t
         match(t) :
            (t:TUVar) :
               if key?(solved, n(t)) :
                  val t* = match(solved[n(t)]) :
                     (t*:Type) : save(n(t), sub-known(t*))
                     (t*:False|Unknown) : t*
                  match(t*) :
                     (t*:False|Unknown) :
                        println("~ is ~" << [t, t*])
                        throw(SubException(t*))
                     (t*:Type) : t*
               else : t
            (t) : map(sub-known?, t)
      println("= ~" << [r])      
      r      

   ;Substitute variables in type.
   ;Throws a SubException when we cannot proceed
   defn sub-known? (t:LSType) -> LSType :
      println("sub-known?(~)" << [t])
      val r = indented $ fn () :
         defn save (n:Int, t:False|Unknown|LSType) :
            lssolved[n] = t
            t
         match(t) :
            (t:UVarT) :
               if key?(lssolved, n(t)) :
                  val t* = match(lssolved[n(t)]) :
                     (t*:LSType) : save(n(t), sub-known(t*))
                     (t*:False|Unknown) : t*
                  match(t*) :
                     (t*:False|Unknown) :
                        println("~ is ~" << [t, t*])
                        throw(SubException(t*))
                     (t*:LSType) : t*
               else : t
            (t:RefT) : RefT(sub-known?(type(t)))
            (t:StructT) : StructT(n(t), sub-known?(type(t)))
            (t) : map(sub-known?{_:LSType}, t)
      println("= ~" << [r])      
      r               

   ;Substitute variables in type.
   ;Returns false if reach an invalid type
   defn sub-known (t:Type) -> False|Unknown|Type :
      try : sub-known?(t)
      catch (e:SubException) : result(e)

   ;Substitute variables in type.
   ;Returns false if reach an invalid type
   defn sub-known (t:LSType) -> False|Unknown|LSType :
      try : sub-known?(t)
      catch (e:SubException) : result(e)

   ;Retrieve the current settings of the selection variable n
   ;List<True|Maybe|False> : Selection is fully known
   ;Unknown : Selection is not yet known.
   ;False : Selection will never be unknown.
   defn get-sel (n:Int) :      
      val r = match(get?(selsolved, n, unknown)) :
         (s:SSel) :
            if none?(uk?, sels(s)) : sels(s) as List<True|Maybe|False>
            else : unknown
         (s:False|Unknown) : s
      println("get-sel(~) = ~" << [n, r])   
      r   
   defn get-sel! (n:Int) :
      val s = selsolved[n] as SSel
      sels(s) as List<True|Maybe|False>

   ;Substitute variables in constraint
   ;Constraint: Constraint is successfully substituted.
   ;False: Constraint depends on variables that will never be known
   ;Unknown: Constraint is not yet known. (Only caused by unknown Selections).
   defn sub-known (c:Constraint) :
      defn sub? (s:List<True|Maybe|False>, xs:List<False|TArrow>) :
         for (si in s, x in xs) map :
            match(si, x) :
               (si:True|Maybe, x:TArrow) : sub-known?(x) as TArrow
               (si, x) : false

      defn sub? (s:List<True|Maybe|False>, xs:List<False|FnT>) :
         for (si in s, x in xs) map :
            match(si, x) :
               (si:True|Maybe, x:FnT) : sub-known?(x) as FnT
               (si, x) : false

      defn sub? (s:False) :
         false
         
      defn sub? (s:TArrow) :
         match(sub-known(s)) :
            (t:TArrow|False) : t
            (t:Unknown) : throw(SubException(unknown))

      defn sub? (s:FnT) :
         match(sub-known(s)) :
            (t:FnT|False) : t
            (t:Unknown) : throw(SubException(unknown))

      defn map-subknown? (xss:List<List<Type>>) :
         for xs in xss map :
            map(sub-known?, xs)

      defn map-subknown? (xss:List<List<LSType>>) :
         for xs in xss map :
            map(sub-known?, xs)
      
      try :
         match(c) :
            (c:MixConstraint) :
               match(get-sel(sel(c))) :
                  (s:List<True|Maybe|False>) : MixConstraint(n(c), sel(c), sub?(s, xs(c)))      
                  (s:False) : false
                  (s:Unknown) : unknown
            (c:LSMixConstraint) :
               match(get-sel(sel(c))) :
                  (s:List<True|Maybe|False>) : LSMixConstraint(n(c), sel(c), sub?(s, xs(c)))
                  (s:False) : false
                  (s:Unknown) : unknown
            (c:LSPickConstraint) :
               match(get-sel(sel(c))) :
                  (s:List<True|Maybe|False>) : LSPickConstraint(n(c), sel(c), sub?(s, xs(c)))
                  (s:False) : false
                  (s:Unknown) : unknown
            (c:PartofConstraint) :
               PartofConstraint(n(c), map(sub?, xs(c)), sub-known?(y(c)))               
            (c:CallableConstraint) :               
               CallableConstraint(n(c), map(sub?, xs(c)), map-subknown?(args(c)))
            (c:SelMultiConstraint) :
               SelMultiConstraint(n(c), sub-known?(x(c)) as TArrow, map(sub?, ys(c)))
            (c:LSCallableConstraint) :
               LSCallableConstraint(n(c), map(sub?, xs(c)), map-subknown?(args(c)))               
            (c:LSSelConstraint) :
               LSSelConstraint(n(c), map(sub?, xs(c)), sub-known?(y(c)))               
            (c) :
               map{sub-known?{_:Type}, _} $
               map(sub-known?{_:LSType}, c)
      catch (e:SubException) :
         false

   defn isolate (s:List) :
      if count({_ not-typeof False}, s) == 1 :
         map({_ not-typeof False}, s)
      else : s

   defn uk? (x) : x typeof Unknown

   ;Dereference a reference to a HiStanza type
   ;Fails if the answer is unknown.
   ;Returns false if not possible.
   defn deref (t:LSType) -> False|LSType :
      match(t) :
         (t:UVarT) : fail()
         (t:PtrT) : type(t)
         (t:RefT) :
            match(to-ls-type(type(t))) :
               (t:False|LSType) : t
               (t:Unknown) : fail()
         (t) : false

   ;Retrieve named field type of a LSType
   ;Fails if the answer is unknown.
   ;Returns false if not possible.
   defn field (t:False|LSType, fname:Symbol) -> False|LSType :
      match(t) :
         (t:UVarT) : fail()
         (t:RefT|PtrT) : field(deref(t), fname)
         (t:StructT) : field-type(t, fname)
         (t) : false

   defn rm-cycles (n*:Int, t:Type) -> Type :
      defn tor (a:Type, b:Type) :
         match(a, b) :
            (a:TBot, b) : b
            (a, b:TBot) : a
            (a, b) : TOr(a, b)
      match(t) :
         (t:TOr) : tor(rm-cycles(n*, a(t)), rm-cycles(n*, b(t)))
         (t:TUVar) : TBot() when n(t) == n* else t
         (t) : t

   defn occurs? (n*:Int, t:Type) :
      match(t) :
         (t:TUVar) : n(t) == n*
         (t) : any?(occurs?{n*, _}, children(t))

   defn occurs? (n*:Int, t:LSType) :
      match(t) :
         (t:UVarT) : n(t) == n*
         (t) : any?(occurs?{n*, _}, children(t))

   ;======== Phase 1: Removing super constraints ========
   remove-super-constraints() where :
      defn remove-super-constraints () :
         val vars = HashTable<Int,Type>({_})
         defn super (n:Int, b:Type) :
            vars[n] = match(get?(vars, n, false), b) :
               (a:False, b) : b
               (a:Type, b) : TOr(a, b)
         for i in 0 to length(cqueue) do :
            match(pop(cqueue)) :
               (c:SuperConstraint) : super(n(c), type(c))
               (c) : add(cqueue, c)
         for entry in vars do :
            val [n, t] = [key(entry), value(entry)]
            add(cqueue, EqualConstraint(n, t))

   ;======== Phase 2: Dataflow solver ========
   fixpoint $ fn (progress) :
      ;Note constraint is unsolvable
      defn unsolvable (c:Constraint) :
         println("unsolvable ~" << [c])
         match(c) :
            ;HiStanza constraints
            (c:FlowConstraint|MixConstraint|SubConstraint|EqualConstraint|RefTypeConstraint) :
               solved[n(c)] = unknown
               progress()
            ;LoStanza constraints
            (c:LSFlowConstraint|LSMixConstraint|LSEqualConstraint|DeptrConstraint|
               DerefConstraint|FieldConstraint|ArgConstraint|RetConstraint|LSPrimConstraint) :
               lssolved[n(c)] = unknown
               progress()
            ;Selection constraints
            (c:PartofConstraint|CallableConstraint|SelMultiConstraint|
               LSCallableConstraint|LSSelConstraint|LSPickConstraint) :
               selsolved[n(c)] = unknown
               progress()
      ;Note constraint was not solved on this iteration         
      defn unsolved (c:Constraint) :
         println("unsolved: ~" << [c])
         add(cqueue, c)
      ;Note solutions
      defn set-solved (n:Int, type:False|Type) :
         match(type) :
            (type:Type) :
               val t = rm-cycles(n, type)
               if occurs?(n, t) :
                  println("solved ~ is unknown" << [n])
                  solved[n] = unknown
               else :
                  solved[n] = simplify(t)
                  println("solved ~ = ~" << [n, solved[n]])
            (type:False) :
               solved[n] = false
               println("solved ~ is false" << [n])
         progress()
      defn set-ls-solved (n:Int, type:False|LSType) :
         match(type) :
            (type:LSType) :
               if occurs?(n, type) :
                  lssolved[n] = unknown
                  println("lssolved ~ is unknown" << [n])
               else :
                  lssolved[n] = simplify(type)
                  println("lssolved ~ = ~" << [n, lssolved[n]])
            (type:False) :
               lssolved[n] = false
               println("lssolved ~ = false" << [n])
         progress()
      defn set-solved-sel (n:Int, xs:List) :
         println("solved sel: ~ = ~" << [n, xs])
         defn update () :
            println("Saved sel: ~ = ~" << [n, xs])
            selsolved[n] = SSel(xs)
            progress()
         if key?(selsolved, n) :
            val s = selsolved[n] as SSel
            update() when sels(s) != xs
         else : update()
      ;Helper for updating selections   
      defn update-sel (c:Constraint, xs:List<False|TArrow>, f: TArrow -> True|False|Maybe|Unknown) :
         val sel = isolate $
            for x in xs map :
               f(x as TArrow) when x != false
         set-solved-sel(n(c), sel)
         unsolved(c) when any?(uk?, sel)
      defn update-sel (c:Constraint, xs:List<False|FnT>, f: FnT -> True|False|Maybe|Unknown) :
         val sel = isolate $
            for x in xs map :
               f(x as FnT) when x != false
         set-solved-sel(n(c), sel)
         unsolved(c) when any?(uk?, sel)

      for ci in 0 to length(cqueue) do :
         val next-c = pop(cqueue)
         println("Considering: ~" << [next-c])
         match(sub-known(next-c)) :
            (c:False) :
               unsolvable(next-c)
            (c:Unknown) :
               unsolved(next-c)
            (c:FlowConstraint) :
               match(flow(n(c), a(c), b(c))) :
                  (t:Type|False) : set-solved(n(c), t)
                  (t:Unknown) : unsolved(c)
            (c:LSFlowConstraint) :
               match(flow(n(c), a(c), b(c))) :
                  (t:Type|False) : set-solved(n(c), t)
                  (t:Unknown) : unsolved(c)
            (c:MixConstraint) :
               val s = get-sel!(sel(c))
               set-solved(n(c), mix(s, xs(c)))
            (c:LSMixConstraint) :
               val s = get-sel!(sel(c))
               set-ls-solved(n(c), mix(s, xs(c)))
            (c:LSPickConstraint) :
               val s = get-sel!(sel(c))
               if count({_ != false}, s) == 1 :
                  val x* = for (x in xs(c), si in s) find! : si != false
                  set-ls-solved(n(c), x* as FnT)
               else : set-ls-solved(n(c), false)
            (c:PartofConstraint) :
               update-sel(c, xs(c), partof?{_, y(c)})
            (c:CallableConstraint) :
               update-sel(c, xs(c), part-callable?{_, args(c)})
            (c:LSCallableConstraint) :
               update-sel(c, xs(c), part-callable?{_, args(c)})
            (c:LSSelConstraint) :
               update-sel(c, xs(c), subtype?{_, y(c)})
            (c:SelMultiConstraint) :
               update-sel(c, ys(c), submethod?{x(c), _})
            (c:SubConstraint) :
               if resolved?(x(c)) : set-solved(n(c), sub(x(c), env(c)))
               else : unsolved(c)
            (c:EqualConstraint) :
               set-solved(n(c), type(c))
            (c:LSEqualConstraint) :
               set-ls-solved(n(c), type(c))
            (c:DeptrConstraint) :
               match(type(c)) :
                  (t:UVarT) : unsolved(c)
                  (t:PtrT) : set-ls-solved(n(c), type(t))
                  (t) : set-ls-solved(n(c), false)
            (c:DerefConstraint) :
               attempt : set-ls-solved(n(c), deref(type(c)))
               else : unsolved(c)
            (c:FieldConstraint) :
               attempt : set-ls-solved(n(c), field(type(c), name(c)))
               else : unsolved(c)
            (c:ArgConstraint) :
               match(type(c)) :
                  (t:UVarT) :
                     unsolved(c)
                  (t:FnT) :
                     val len = length(a(t))
                     if r(t) == false :
                        if len == arity(c) : set-ls-solved(n(c), a(t)[i(c)])
                        else : set-ls-solved(n(c), false)
                     else :
                        if len <= arity(c) :
                           val t* = a(t)[i(c)] when i(c) < len else r(t) as LSType
                           set-ls-solved(n(c), t*)
                        else : set-ls-solved(n(c), false)
                  (t) :
                     set-ls-solved(n(c), false)
            (c:RetConstraint) :
               match(type(c)) :
                  (t:UVarT) : unsolved(c)
                  (t:FnT) : set-ls-solved(n(c), b(t))
                  (t) : set-ls-solved(n(c), false)
            (c:RefTypeConstraint) :
               match(type(c)) :
                  (t:UVarT) : unsolved(c)
                  (t:RefT) : set-solved(n(c), type(t))
                  (t) : set-solved(n(c), false)
            (c:LSPrimConstraint) :
               attempt :
                  defn #R (t:LSType) :
                     fail() when t typeof UVarT
                     t
                  defn binop (f: (LSType, LSType) -> False|LSType) :
                     if length(args(c)) == 2 :
                        f(#R(args(c)[0]), #R(args(c)[1]))
                     else : false
                  defn max-num () :
                     binop $ fn (x, y) :
                        match(x, y) :
                           (x:ByteT|IntT|LongT|FloatT|DoubleT, y:ByteT|IntT|LongT|FloatT|DoubleT) :
                              y when implicit-upcast?(x, y) else x
                           (x, y) : false
                  defn max-int () :
                     binop $ fn (x, y) :
                        match(x, y) :
                           (x:ByteT|IntT|LongT, y:ByteT|IntT|LongT) :
                              y when implicit-upcast?(x, y) else x
                           (x, y) : false
                  defn same-num () :
                     if length(args(c)) == 1 :
                        val t = #R(args(c)[0])
                        t when t typeof ByteT|IntT|LongT|FloatT|DoubleT
                  defn same-int () :
                     if length(args(c)) == 1 :
                        val t = #R(args(c)[0])
                        t when t typeof ByteT|IntT|LongT
                  defn fnum-to-int () :
                     if length(args(c)) == 1 :
                        match(#R(args(c)[0])) :
                           (t:FloatT) : IntT()
                           (t:DoubleT) : LongT()
                           (t) : false
                  defn int-to-fnum () :
                     if length(args(c)) == 1 :
                        match(#R(args(c)[0])) :
                           (t:IntT) : FloatT()
                           (t:LongT) : DoubleT()
                           (t) : false

                  val t* = match(op(c)) :
                     (p:GetterPrimitive) :
                        type(p)
                     (p:SetterPrimitive) :
                        LongT()
                     (p) :
                        switch {p == _} :
                           LS-ADD-OP :
                              binop $ fn (x, y) :
                                 match(x, y) :
                                    (x:PtrT, y) : x
                                    (x, y) : max-num()
                           LS-SUB-OP :
                              binop $ fn (x, y) :
                                 match(x, y) :
                                    (x:PtrT, y:PtrT) : LongT()
                                    (x:PtrT, y) : x
                                    (x, y) : max-num()
                           LS-MUL-OP : max-num()
                           LS-DIV-OP : max-num()
                           LS-MOD-OP : max-int()
                           LS-AND-OP : max-int()
                           LS-OR-OP : max-int()
                           LS-XOR-OP : max-int()
                           LS-SHL-OP : max-int()
                           LS-SHR-OP : max-int()
                           LS-ASHR-OP : max-int()
                           LS-EQ-OP : LongT()
                           LS-NE-OP : LongT()
                           LS-LT-OP : LongT()
                           LS-GT-OP : LongT()
                           LS-LE-OP : LongT()
                           LS-GE-OP : LongT()
                           LS-ULT-OP : LongT()
                           LS-UGT-OP : LongT()
                           LS-ULE-OP : LongT()
                           LS-UGE-OP : LongT()
                           LS-NOT-OP : same-int()
                           LS-NEG-OP : same-num()
                           LS-BITS-OP : fnum-to-int()
                           LS-FNUM-OP : int-to-fnum()
                  set-ls-solved(n(c), t*)
               else : unsolved(c)

   ;======== Return Solutions ========
   defn #V (t:False|Unknown) : fail()
   defn #V (t:Type) : t
   defn #V (t:LSType) : t
   defn #V (s:SSel) : s
   val solns = HashTable<Int,Type>({_})
   val ls-solns = HashTable<Int,LSType>({_})
   val sel-solns = HashTable<Int,SSel>({_})
   for entry in solved do :
      val [n, t] = [key(entry), value(entry)]
      attempt: solns[n] = #V(sub-known(#V(t)))
   for entry in lssolved do :
      val [n, t] = [key(entry), value(entry)]
      attempt: ls-solns[n] = #V(sub-known(#V(t)))
   for entry in selsolved do :
      val [n, s] = [key(entry), value(entry)]
      match(get-sel(n)) :
         (s:List<True|Maybe|False>) : sel-solns[n] = SSel(s)
         (s:False|Unknown) : false
   SolveResults(solns, ls-solns, sel-solns)