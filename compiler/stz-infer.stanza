defpackage stz/infer :
   import core
   import verse
   import stz/tl-ir
   import stz/type-calculus
   import stz/algorithms

;============================================================
;================= Constraint Language ======================
;============================================================
#use-overlay(stz/ast-lang, stz/printer-lang)

public defmulti n (c:Constraint) -> Int

public defast :
   deftype Constraint
   defnodes Constraint :
      FlowConstraint :
         n:Int with: (as-method => true)
         a:Type
         b:Type
      LSFlowConstraint :
         n:Int with: (as-method => true)
         a:LSType
         b:LSType
      SuperConstraint :
         n:Int with: (as-method => true)
         type:Type
      MixConstraint :
         n:Int with: (as-method => true)
         sel:Int
         xs:List<Type>
      LSMixConstraint :
         n:Int with: (as-method => true)
         sel:Int
         xs:List<LSType>
      PartofConstraint :
         n:Int with: (as-method => true)
         xs:List<Type>
         y:Type
      CallableConstraint :
         n: Int with: (as-method => true)
         xs:List<Type>
         args:List<List<Type>>
      LSPartofConstraint :
         n:Int with: (as-method => true)
         xs:List<LSType>
         args:List<LSType>
      LSSelConstraint :
         n:Int with: (as-method => true)
         xs:List<LSType>
         y:LSType
      SelMultiConstraint :
         n:Int with: (as-method => true)
         x:Type
         ys:List<Type>
      PickConstraint :
         n:Int with: (as-method => true)
         sel:Int
         ys:List<Type>
      LSPickConstraint :
         n:Int with: (as-method => true)
         sel:Int
         ys:List<LSType>
      SubConstraint :
         n:Int with: (as-method => true)
         x:Type
         env:List<KeyValue<Int, Type>>
      EqualConstraint :
         n:Int with: (as-method => true)
         type:Type
      LSEqualConstraint :
         n:Int with: (as-method => true)
         type:LSType
      DeptrConstraint :
         n:Int with: (as-method => true)
         type:LSType
      DerefConstraint :
         n:Int with: (as-method => true)
         type:LSType
      FieldConstraint :
         n:Int with: (as-method => true)
         type:LSType
         name:Symbol
      ArgConstraint :
         n:Int with: (as-method => true)
         type:LSType
         i:Int
         arity:Int
      RetConstraint :
         n:Int with: (as-method => true)
         type:LSType
      RefTypeConstraint :
         n:Int with: (as-method => true)
         type:LSType

   defmapper (f:Type -> Type) :
      (x:Type) : f(x)
      (x:List<Type>) : map(f, x)
      (x:List<List<Type>>) : for xs in x map : map(f, xs)
      (xs:List<KeyValue<Int,Type>>) : for x in xs map : key(x) => f(value(x))      
      ignore(Int)
      ignore(LSType)
      ignore(List<LSType>)
      ignore(Symbol)

   defmapper (f:LSType -> LSType) :
      (x:LSType) : f(x)
      (xs:List<LSType>) : map(f, xs)
      ignore(Type)
      ignore(List<Type>)
      ignore(List<List<Type>>)
      ignore(List<KeyValue<Int,Type>>)
      ignore(Int)
      ignore(Symbol)

   make-mapper(f: Type -> Type, c:Constraint)
   make-mapper(f: LSType -> LSType, c:Constraint)

defprinter (c:Constraint) :
   FlowConstraint :
      ($flow n a b)
   LSFlowConstraint :
      ($ls-flow n a b)
   SuperConstraint :
      ($super n type)
   MixConstraint :
      ($mix n sel (xs ...))
   LSMixConstraint :
      ($ls-mix n sel (xs ...))
   PartofConstraint :
      ($partof n (xs ...) y)
   LSPartofConstraint :
      ($ls-partof n (xs ...) args ...)
   CallableConstraint :
      ($callable n (xs ...) (args ...))
   LSSelConstraint :
      ($ls-sel n (xs ...) y)
   SelMultiConstraint :
      ($selmethod n x (ys ...))
   PickConstraint :
      ($pick n sel (ys ...))
   LSPickConstraint :
      ($ls-pick n sel (ys ...))
   SubConstraint :
      ($sub n x env ...)
   EqualConstraint :
      ($equal n type)
   LSEqualConstraint :
      ($ls-equal n type)
   DeptrConstraint :
      ($deptr n type)
   DerefConstraint :
      ($deref n type)
   FieldConstraint :
      ($field n type name)
   ArgConstraint :
      ($arg n type i arity)
   RetConstraint :
      ($ret n type)
   RefTypeConstraint :
      ($ref-type n type)

;============================================================
;====================== Solver ==============================
;============================================================

defstruct SolveError <: Exception

public defstruct SolveResults :
   types: HashTable<Int,Type>
   sels: HashTable<Int,Selection>

public defn solve (constraints:Streamable<Constraint>) -> SolveResults :
   println("Solve:")
   do(println, constraints)
   
   ;======== State ========
   val solved = HashTable<Int,Type>({_})
   val lssolved = HashTable<Int,LSType>({_})
   val selsolved = HashTable<Int, SSel>({_})
   val cqueue = Queue<Constraint>()
   do(add{cqueue, _}, constraints)

   ;======== Solving Utility Functions ========
   ;Substitute known types
   defn sub-known (t:Type) :
      defn save (n:Int, t:Type) :
         solved[n] = t
         t
      match(t) :
         (t:TUVar) :
            match(get?(solved, n(t), false)) :
               (r:Type) : save(n(t), sub-known(r))
               (r:False) : t
         (t) : map(sub-known, t)
         
   defn sub-known (t:LSType) :
      defn save (n:Int, t:LSType) :
         lssolved[n] = t
         t
      match(t) :
         (t:UVarT) :
            match(get?(lssolved, n(t), false)) :
               (r:LSType) : save(n(t), sub-known(r))
               (r:False) : t
         (t:RefT) : RefT(sub-known(type(t)))
         (t) : map(sub-known, t)

   defn sub-known (c:Constraint) :
      map{sub-known{_:Type}, _} $
      map(sub-known{_:LSType}, c)

   ;Substitute an env
   defn sub-env (t:Type, env:List<KeyValue<Int,Type>>) :
      match(t) :
         (t:TUVar) : throw(SolveError())
         (t:TVar) : lookup(env, n(t), t)
         (t) : map(sub-env{_, env}, t)

   ;Isolate
   defn isolate (s:List) :
      if count({_ not-typeof False}, s) == 1 : 
         map({_ not-typeof False}, s)
      else : s

   ;Compute selection of partof relation
   defn partof (xs:List<Type>, y:Type) :
      isolate $
      for x in xs map :
         match(x) :
            (x:TArrow) : partof?(x, y)
            (x:TNone) : false

   defn partof (xs:List<LSType>, args:List<LSType>) :
      isolate $
      for x in xs map :
         match(x) :
            (x:NoneT) : false
            (x:FnT|UVarT) : partof?(x, args)                      ;TODO: FIX THIS AS WELL

   ;Compute selection for callable relation
   defn callable (xs:List<Type>, args:List<List<Type>>) :
      isolate $
      for x in xs map :
         match(x) :
            (x:TArrow) : callable?(x, args)
            (x:TNone) : false

   ;Compute selection for subtype relation
   defn select (xs:List<LSType>, y:LSType) :
      isolate $
      for x in xs map :
         match(x) :
            (x:NoneT) : false
            (x) : subtype?(x, y)

   ;Compute method
   defn select-multi (x:Type, ys:List<Type>) :
      defn sm? (x:Type, y:Type) :
         match(x, y) :
            (x:TArrow, y:TArrow) : submethod?(x, y)
            (x, y) : unknown
      isolate(map(sm?{x, _}, ys))

   ;Determine if x is unknown
   defn uk? (x) : x typeof Unknown

   ;Mix selected
   defn mix-types (s:Int, xs:List<Type>) :
      throw(SolveError()) when not key?(selsolved, s)
      throw(SolveError()) when any?({_ typeof TUVar}, xs)
      val sel = sels(selsolved[s])
      throw(SolveError()) when any?(uk?, sel)
      mix(sel, xs)

   defn mix-types (s:Int, xs:List<LSType>) :
      throw(SolveError()) when not key?(selsolved, s)
      throw(SolveError()) when any?({_ typeof UVarT}, xs)
      val sel = sels(selsolved[s])
      throw(SolveError()) when any?(uk?, sel)
      mix(sel, xs)

   ;Pick selected
   defn pick-types (s:Int, ys:List<Type>) :
      throw(SolveError()) when not key?(selsolved, s)
      val sel = sels(selsolved[s])
      throw(SolveError()) when count({_ not-typeof False}, sel) != 1
      {_ as Type} $ for (y in ys, s in sel) find :
         s not-typeof False

   defn pick-types (s:Int, ys:List<LSType>) :
      throw(SolveError()) when not key?(selsolved, s)
      val sel = sels(selsolved[s])
      throw(SolveError()) when count({_ not-typeof False}, sel) != 1
      {_ as LSType} $ for (y in ys, s in sel) find :
         s not-typeof False

   ;Deptr a type
   defn deptr (t:LSType) :
      match(t) :
         (t:UVarT) : throw(SolveError())
         (t:PtrT) : type(t)
         (t) : NoneT()

   ;Deref a type
   defn deref (t:LSType) -> LSType :
      match(t) :
         (t:UVarT) :
            throw(SolveError())
         (t:PtrT) :
            type(t)
         (t:RefT) :
            match(type(t)) :
               (t:TVar) : throw(SolveError())
               (t:TArrow) : to-ls-fn(t)
               (t:TOf) : StructT(n(t), type(t)) when lstype?(n(t)) else NoneT()
               (t) : NoneT()
         (t) : NoneT()

   ;Retrieve a field
   defn field (t:LSType, fname:Symbol) :
      match(t) :
         (t:UVarT) : throw(SolveError())
         (t:RefT|PtrT) : field(deref(t), fname)
         (t:StructT) : field-type(t, fname)
         (t) : NoneT()

   ;Retrieve a specific argument
   defn get-arg (t:LSType, i:Int, arity:Int) :
      match(t) :
         (t:UVarT) :
            throw(SolveError())
         (t:FnT) :
            val n = length(a(t))
            match(r(t)) :
               (rt:NoneT) :
                  a(t)[i] when n == arity else NoneT()
               (rt) :
                  if n <= arity : a(t)[i] when i < n else rt
                  else : NoneT()   
         (t) :
            NoneT()

   ;Retrieve the return type
   defn get-ret (t:LSType) :
      match(t) :
         (t:UVarT) : throw(SolveError())
         (t:FnT) : b(t)
         (t) : NoneT()

   ;Retrieve the ref type
   defn ref-type (t:LSType) :
      match(t) :
         (t:UVarT) : throw(SolveError())
         (t:RefT) : type(t)
         (t) : TNone()

   ;Remove cycles in a type
   defn rm-cycles (n*:Int, t:Type) -> Type :
      val ts = Vector<Type>()
      var cycle? = false
      defn loop (t:Type) :
         match(t) :
            (t:TOr) : do(loop, t)
            (t:TBot) : false
            (t:TUVar) :
               if n(t) == n* : cycle? = true
               else : add(ts, t)
            (t) : add(ts, t)
      loop(t)
      if empty?(ts) :
         if cycle? : TUVar(n*)
         else : TBot()
      else : reduce(TOr, ts)

   ;Check if n* appears in t
   defn occurs? (n*:Int, t:Type) :
      match(t) :
         (t:TUVar) : n(t) == n*
         (t) : any?(occurs?{n*, _}, children(t))
         
   defn occurs? (n*:Int, t:LSType) :
      match(t) :
         (t:UVarT) : n(t) == n*
         (t) : any?(occurs?{n*, _}, children(t))

   ;======== Phase 1: Removing super constraints ========
   remove-super-constraints() where :
      defn remove-super-constraints () :
         val vars = HashTable<Int,Type>({_})
         defn super (n:Int, b:Type) :
            vars[n] = match(get?(vars, n, false)) :
               (a:False) : b
               (a:Type) : TOr(a, b)
         for i in 0 to length(cqueue) do :
            match(pop(cqueue)) :
               (c:SuperConstraint) : super(n(c), type(c))
               (c) : add(cqueue, c)
         for entry in vars do :
            val [n, t] = [key(entry), value(entry)]
            add(cqueue, EqualConstraint(n, t))

   ;======== Phase 2: Dataflow solver ========
   fixpoint $ fn (progress) :
      defn set-solved (n:Int, type:Type) :
         val t = rm-cycles(n, type)
         if not occurs?(n, t) :
            println("solved: ~ = ~" << [n, t])
            solved[n] = simplify(t)
            progress()
      defn set-solved (n:Int, type:LSType) :
         if not occurs?(n, type) :
            println("solved: ~ = ~" << [n, type])
            lssolved[n] = simplify(type)
            progress()
      defn set-solved-sel (n:Int, xs:List) :
         println("solved: ~ = ~" << [n, xs])
         val s = match(get?(selsolved, n, false)) :
            (s:SSel) : sels(s)
            (s:False) : s
         if s != xs :
            selsolved[n] = SSel(xs)
            progress()
      defn unsolved (c:Constraint) :
         println("unsolved: ~" << [c])
         add(cqueue, c)         
         
      for ci in 0 to length(cqueue) do :      
         val c = sub-known(pop(cqueue))
         println("Considering: ~" << [c])
         match(c) :         
            (c:FlowConstraint) :
               match(flow(n(c), a(c), b(c))) :
                  (t:Type) : set-solved(n(c), t)
                  (t:Unknown) : unsolved(c)
                  (t:False) : false
            (c:LSFlowConstraint) :
               match(flow(n(c), a(c), b(c))) :
                  (t:Type) : set-solved(n(c), t)
                  (t:Unknown) : unsolved(c)
                  (t:False) : false
            (c:MixConstraint) :
               try : set-solved(n(c), mix-types(sel(c), xs(c)))
               catch (e:SolveError) : unsolved(c)
            (c:LSMixConstraint) :
               try : set-solved(n(c), mix-types(sel(c), xs(c)))
               catch (e:SolveError) : unsolved(c)               
            (c:PartofConstraint) :
               val sel = partof(xs(c), y(c))
               set-solved-sel(n(c), sel)
               unsolved(c) when any?(uk?, sel)
            (c:LSPartofConstraint) :
               val sel = partof(xs(c), args(c))
               set-solved-sel(n(c), sel)
               unsolved(c) when any?(uk?, sel)
            (c:CallableConstraint) :
               val sel = callable(xs(c), args(c))
               set-solved-sel(n(c), sel)
               unsolved(c) when any?(uk?, sel)
            (c:LSSelConstraint) :
               val sel = select(xs(c), y(c))
               set-solved-sel(n(c), sel)
               unsolved(c) when any?(uk?, sel)
            (c:SelMultiConstraint) :
               val sel = select-multi(x(c), ys(c))
               set-solved-sel(n(c), sel)
               unsolved(c) when any?(uk?, sel)
            (c:PickConstraint) :
               try : set-solved(n(c), pick-types(sel(c), ys(c)))
               catch (e:SolveError) : unsolved(c)
            (c:LSPickConstraint) :
               try : set-solved(n(c), pick-types(sel(c), ys(c)))
               catch (e:SolveError) : unsolved(c)
            (c:SubConstraint) :
               try : set-solved(n(c), sub-env(x(c), env(c)))
               catch (e:SolveError) : unsolved(c)
            (c:EqualConstraint) :
               set-solved(n(c), type(c))
            (c:LSEqualConstraint) :
               set-solved(n(c), type(c))
            (c:DeptrConstraint) :
               try : set-solved(n(c), deptr(type(c)))
               catch (e:SolveError) : unsolved(c)
            (c:DerefConstraint) :
               try : set-solved(n(c), deref(type(c)))
               catch (e:SolveError) : unsolved(c)
            (c:FieldConstraint) :
               try : set-solved(n(c), field(type(c), name(c)))
               catch (e:SolveError) : unsolved(c)
            (c:ArgConstraint) :
               try : set-solved(n(c), get-arg(type(c), i(c), arity(c)))
               catch (e:SolveError) : unsolved(c)
            (c:RetConstraint) :
               try : set-solved(n(c), get-ret(type(c)))
               catch (e:SolveError) : unsolved(c)
            (c:RefTypeConstraint) :
               try : set-solved(n(c), ref-type(type(c)))
               catch (e:SolveError) : unsolved(c)

   ;======== Return Solutions ========
   for entry in solved do :
      val [n, t] = [key(entry), value(entry)]
      solved[n] = sub-known(t)
   SolveResults(solved, selsolved)