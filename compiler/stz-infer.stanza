defpackage stz/infer :
   import core
   import verse
   import stz/tl-ir
   import stz/type-calculus
   import stz/algorithms

;============================================================
;================= Constraint Language ======================
;============================================================
#use-overlay(stz/ast-lang, stz/printer-lang)

public defast :
   deftype Constraint
   defnodes Constraint :
      FlowConstraint : (n:Int, a:Type, b:Type)
      SuperConstraint : (n:Int, type:Type)
      MixConstraint : (n:Int, sel:Int, xs:List<Type>)
      SelConstraint : (n:Int, xs:List<Type>, y:Type)
      ThresholdConstraint : (n:Int, s:Int)
      SubConstraint : (n:Int, x:Type, env:List<KeyValue<Int, Type>>)
      EqualConstraint : (n:Int, type:Type)

   defmap (f:Type -> Type, c:Constraint) -> Constraint :
      (x:Int) : x
      (x:Type) : f(x)
      (x:List<Type>) : map(f, x)
      (xs:List<KeyValue<Int,Type>>) : for x in xs map : key(x) => f(value(x))

defprinter (c:Constraint) :
   FlowConstraint :
      ($flow n a b)
   SuperConstraint :
      ($super n type)
   MixConstraint :
      ($mix n sel (xs ...))
   SelConstraint :
      ($sel n xs y)
   ThresholdConstraint :
      ($threshold n s)
   SubConstraint :
      ($sub n x env ...)
   EqualConstraint :
      ($equal n type)

;============================================================
;====================== Solver ==============================
;============================================================

public definterface SolveResult
public defstruct SolvedSel <: SolveResult : (sel:List)
public defstruct Solved <: SolveResult : (type:Type)
public defstruct Unsolveable <: SolveResult
public defstruct Dependant <: SolveResult
defstruct SolveError <: Exception

defn solve (constraints:Streamable<Constraint>) -> HashTable<Int,SolveResult> :
   ;======== State ========
   val solved = HashTable<Int,Type>({_})
   val selsolved = HashTable<Int, List>({_})
   val unsolvable = Vector<Int>()
   val cqueue = Queue<Constraint>()
   do(add{cqueue, _}, constraints)

   ;======== Solving Utility Functions ========
   ;Substitute known types
   defn sub-known (t:Type) :
      defn save (n:Int, t:Type) :
         solved[n] = t
         t
      match(t) :
         (t:TUVar) :
            match(get?(solved, n(t), false)) :
               (r:Type) : save(n(t), sub-known(r))
               (r:False) : t
         (t) : map(sub-known, t)

   ;Substitute an env
   defn sub-env (t:Type, env:List<KeyValue<Int,Type>>) :
      match(t) :
         (t:TUVar) : throw(SolveError())
         (t:TVar) : lookup(env, n(t), t)
         (t) : map(sub-env{_, env}, t)

   ;Threshold a list
   defn threshold (s:Int) :
      throw(SolveError()) when not key?(selsolved, s)
      for x in selsolved[s] map :
         match(x) :
            (x:Maybe) : true
            (x:True|False|Unknown) : x

   ;Isolate
   defn isolate (s:List) :
      if count({_ not-typeof False}, s) == 1 : 
         map({_ not-typeof False}, s)
      else : s

   ;Compute selected
   defn select (xs:List<Type>, y:Type) :
      isolate(map(partof?{_, y}, xs))

   ;Determine if x is unknown
   defn uk? (x) : x typeof Unknown

   ;Mix selected
   defn mix-types (s:Int, xs:List<Type>) :
      throw(SolveError()) when not key?(selsolved, s)
      val sel = selsolved[s]
      throw(SolveError()) when any?(uk?, sel)
      mix(sel, xs)

   ;Remove cycles in a type
   defn rm-cycles (n*:Int, t:Type) -> Type :
      match(t) :
         (t:TUVar) : TBot() when n(t) == n* else t
         (t:TOr) : map(rm-cycles{n*, _}, t)
         (t) : t   

   ;Check if n* appears in t
   defn occurs? (n*:Int, t:Type) :
      match(t) :
         (t:TUVar) : n(t) == n*
         (t) : any?(occurs?{n*, _}, children(t))

   ;======== Phase 1: Removing super constraints ========
   remove-super-constraints() where :
      defn remove-super-constraints () :
         val vars = HashTable<Int,Type>({_})
         defn super (n:Int, b:Type) :
            vars[n] = match(get?(vars, n, false)) :
               (a:False) : b
               (a:Type) : TOr(a, b)
         for i in 0 to length(cqueue) do :
            match(pop(cqueue)) :
               (c:SuperConstraint) : super(n(c), type(c))
               (c) : add(cqueue, c)
         for entry in vars do :
            val [n, t] = [key(entry), value(entry)]
            add(cqueue, EqualConstraint(n, t))

   ;======== Phase 2: Dataflow solver ========
   fixpoint $ fn (progress) :
      defn set-unsolvable (n:Int) :
         add(unsolvable, n)
      defn set-solved (n:Int, t:Type) :
         solved[n] = t
         progress()
      defn set-solved-sel (n:Int, xs:List) :
         val s = get?(selsolved, n, false)
         if s != xs :
            selsolved[n] = xs
            progress()
      defn unsolved (c:Constraint) :
         add(cqueue, c)         
         
      for i in 0 to length(cqueue) do :
         match(map(sub-known, pop(cqueue))) :
            (c:FlowConstraint) :
               match(flow(n(c), a(c), b(c))) :
                  (t:Type) : set-solved(n(c), t)
                  (t:False) : set-unsolvable(n(c))
                  (t:Unknown) : unsolved(c)
            (c:MixConstraint) :
               try : set-solved(n(c), mix-types(sel(c), xs(c)))
               catch (e:SolveError) : unsolved(c)
            (c:SelConstraint) :
               val sel = select(xs(c), y(c))
               set-solved-sel(n(c), sel)
               unsolved(c) when any?(uk?, sel)
            (c:ThresholdConstraint) :
               try :
                  val sel = threshold(s(c))
                  set-solved-sel(n(c), sel)
                  unsolved(c) when any?(uk?, sel)
               catch (e:SolveError) : unsolved(c)
            (c:SubConstraint) :
               try : set-solved(n(c), sub-env(x(c), env(c)))
               catch (e:SolveError) : unsolved(c)
            (c:EqualConstraint) :
               val t = rm-cycles(n(c), type(c))
               if occurs?(n(c), t) : set-unsolvable(n(c))
               else : set-solved(n(c), t)

   ;======== Phase 3: Solution table ========
   val soln = HashTable<Int,SolveResult>({_})
   for n in unsolvable do : soln[n] = Unsolveable()
   for c in cqueue do : soln[n(c)] = Dependant()
   defn get-soln (t:Type) :
      label<SolveResult> return :
         defn fill (t:Type) :
            match(t) :
               (t:TUVar) :
                  match(get?(soln, n(t), false)) :
                     (r:Solved) : type(r)
                     (r:Unsolveable|Dependant) : return(Dependant())
               (t) :
                  map(fill, t)
         Solved(fill(sub-known(t)))
   for entry in solved do :
      soln[key(entry)] = get-soln(value(entry))
   for entry in selsolved do :
      soln[key(entry)] = SolvedSel(value(entry))
   soln