defpackage stz/infer :
   import core
   import verse
   import stz/utils
   import stz/tl-ir
   import stz/type-calculus
   import stz/algorithms
   import stz/primitives
   import stz/ids

;============================================================
;================= Constraint Language ======================
;============================================================
#use-overlay(stz/ast-lang, stz/printer-lang, stz/attempt-lang)

public defmulti n (c:Constraint) -> Int

public defast :
   deftype Constraint
   defnodes Constraint :
      FlowConstraint :
         n:Int with: (as-method => true)
         a:Type
         b:Type
      LSFlowConstraint :
         n:Int with: (as-method => true)
         a:LSType
         b:LSType
      SuperConstraint :
         n:Int with: (as-method => true)
         type:Type
      MixConstraint :
         n:Int with: (as-method => true)
         sel:Int
         xs:List<Type>
      LSMixConstraint :
         n:Int with: (as-method => true)
         sel:Int
         xs:List<LSType>
      PartofConstraint :
         n:Int with: (as-method => true)
         xs:List<Type>
         y:Type
      CallableConstraint :
         n: Int with: (as-method => true)
         xs:List<Type>
         args:List<List<Type>>
      LSPartofConstraint :
         n:Int with: (as-method => true)
         xs:List<LSType>
         args:List<LSType>
      LSCallableConstraint :
         n: Int with: (as-method => true)
         xs:List<LSType>
         args:List<List<LSType>>
      LSSelConstraint :
         n:Int with: (as-method => true)
         xs:List<LSType>
         y:LSType
      SelMultiConstraint :
         n:Int with: (as-method => true)
         x:TArrow
         ys:List<Type>
      PickConstraint :
         n:Int with: (as-method => true)
         sel:Int
         ys:List<Type>
      LSPickConstraint :
         n:Int with: (as-method => true)
         sel:Int
         ys:List<LSType>
      SubConstraint :
         n:Int with: (as-method => true)
         x:Type
         env:List<KeyValue<Int, Type>>
      EqualConstraint :
         n:Int with: (as-method => true)
         type:Type
      LSEqualConstraint :
         n:Int with: (as-method => true)
         type:LSType
      DeptrConstraint :
         n:Int with: (as-method => true)
         type:LSType
      DerefConstraint :
         n:Int with: (as-method => true)
         type:LSType
      FieldConstraint :
         n:Int with: (as-method => true)
         type:LSType
         name:Symbol
      ArgConstraint :
         n:Int with: (as-method => true)
         type:LSType
         i:Int
         arity:Int
      RetConstraint :
         n:Int with: (as-method => true)
         type:LSType
      RefTypeConstraint :
         n:Int with: (as-method => true)
         type:LSType
      LSPrimConstraint :
         n:Int with: (as-method => true)
         op:LSPrimitive
         args:List<LSType>

   make-mapper(f: Type -> Type, c:Constraint)
   make-mapper(f: LSType -> LSType, c:Constraint)

   defmapper (f:Type -> Type) :
      (x:Type) : f(x)
      (x:TArrow) : f(x) as TArrow
      (x:List<Type>) : map(f, x)
      (x:List<List<Type>>) : for xs in x map : map(f, xs)
      (xs:List<KeyValue<Int,Type>>) : for x in xs map : key(x) => f(value(x))      

   defmapper (f:LSType -> LSType) :
      (x:LSType) : f(x)
      (xs:List<LSType>) : map(f, xs)
      (xs:List<List<LSType>>) : for x in xs map : map(f, x)

   ignore :
      Int
      Symbol
      LSPrimitive


defprinter (c:Constraint) :
   FlowConstraint :
      ($flow n a b)
   LSFlowConstraint :
      ($ls-flow n a b)
   SuperConstraint :
      ($super n type)
   MixConstraint :
      ($mix n sel (xs ...))
   LSMixConstraint :
      ($ls-mix n sel (xs ...))
   PartofConstraint :
      ($partof n (xs ...) y)
   LSPartofConstraint :
      ($ls-partof n (xs ...) args ...)
   CallableConstraint :
      ($callable n (xs ...) (args ...))
   LSCallableConstraint :
      ($ls-callable n (xs ...) (args ...))
   LSSelConstraint :
      ($ls-sel n (xs ...) y)
   SelMultiConstraint :
      ($selmethod n x (ys ...))
   PickConstraint :
      ($pick n sel (ys ...))
   LSPickConstraint :
      ($ls-pick n sel (ys ...))
   SubConstraint :
      ($sub n x env ...)
   EqualConstraint :
      ($equal n type)
   LSEqualConstraint :
      ($ls-equal n type)
   DeptrConstraint :
      ($deptr n type)
   DerefConstraint :
      ($deref n type)
   FieldConstraint :
      ($field n type name)
   ArgConstraint :
      ($arg n type i arity)
   RetConstraint :
      ($ret n type)
   RefTypeConstraint :
      ($ref-type n type)
   LSPrimConstraint :
      ($ls-prim n op args ...)

;============================================================
;====================== Solver ==============================
;============================================================

defstruct SolveError <: Exception

public defstruct SolveResults :
   types: HashTable<Int,Type>
   lstypes: HashTable<Int,LSType>
   sels: HashTable<Int,Selection>

public defn solve (constraints:Streamable<Constraint>) -> SolveResults :
   println("Solve:")
   do(println, constraints)
   
   ;======== State ========
   val solved = HashTable<Int,Type>({_})
   val lssolved = HashTable<Int,LSType>({_})
   val selsolved = HashTable<Int, SSel>({_})
   val cqueue = Queue<Constraint>()
   do(add{cqueue, _}, constraints)

   ;======== Solving Utility Functions ========
   defn sub-known (t:Type) :
      defn save (n:Int, t:Type) :
         solved[n] = t
         t
      match(t) :
         (t:TUVar) :
            match(get?(solved, n(t), false)) :
               (r:Type) : save(n(t), sub-known(r))
               (r:False) : t
         (t) :
            map(sub-known, t)
         
   defn sub-known (t:LSType) :
      defn save (n:Int, t:LSType) :
         lssolved[n] = t
         t
      match(t) :
         (t:UVarT) :
            match(get?(lssolved, n(t), false)) :
               (r:LSType) : save(n(t), sub-known(r))
               (r:False) : t
         (t:RefT) : RefT(sub-known(type(t)))
         (t:StructT) : StructT(n(t), sub-known(type(t)))
         (t) : map(sub-known{_:LSType}, t)

   defn sub-known (c:Constraint) :
      map{sub-known{_:Type}, _} $
      map(sub-known{_:LSType}, c)

   defn isolate (s:List) :
      if count({_ not-typeof False}, s) == 1 : 
         map({_ not-typeof False}, s)
      else : s

   defn uk? (x) : x typeof Unknown

   defn deref (t:LSType) -> LSType :
      match(t) :
         (t:UVarT) : fail()
         (t:PtrT) : type(t)
         (t:RefT) : to-ls-type(type(t))
         (t) : NoneT()
         
   defn field (t:LSType, fname:Symbol) :
      match(t) :
         (t:UVarT) : fail()
         (t:RefT|PtrT) : field(deref(t), fname)
         (t:StructT) : field-type(t, fname)
         (t) : NoneT()

   defn rm-cycles (n*:Int, t:Type) -> Type :
      match(t) :
         (t:TOr) :
            match(rm-cycles(n*, a(t)), rm-cycles(n*, b(t))) :
               (a:TBot, b) : b
               (a, b:TBot) : a
               (a, b) : TOr(a, b)
         (t:TUVar) :
            if n(t) == n* : TBot()
            else : t
         (t) : t   

   defn occurs? (n*:Int, t:Type) :
      match(t) :
         (t:TUVar) : n(t) == n*
         (t) : any?(occurs?{n*, _}, children(t))
         
   defn occurs? (n*:Int, t:LSType) :
      match(t) :
         (t:UVarT) : n(t) == n*
         (t) : any?(occurs?{n*, _}, children(t))

   ;======== Phase 1: Removing super constraints ========
   remove-super-constraints() where :
      defn remove-super-constraints () :
         val vars = HashTable<Int,Type>({_})
         defn super (n:Int, b:Type) :
            vars[n] = match(get?(vars, n, false), b) :
               (a:False, b) : b
               (a:Type, b) : TOr(a, b)
         for i in 0 to length(cqueue) do :
            match(pop(cqueue)) :
               (c:SuperConstraint) : super(n(c), type(c))
               (c) : add(cqueue, c)
         for entry in vars do :
            val [n, t] = [key(entry), value(entry)]
            add(cqueue, EqualConstraint(n, t))

   ;======== Phase 2: Dataflow solver ========
   fixpoint $ fn (progress) :
      defn set-solved (n:Int, type:Type) :
         val t = rm-cycles(n, type)
         if not occurs?(n, t) :
            println("solved: ~ = ~" << [n, t])
            solved[n] = simplify(t)
            progress()
      defn set-ls-solved (n:Int, type:LSType) :
         if not occurs?(n, type) :
            println("solved ls: ~ = ~" << [n, type])
            lssolved[n] = simplify(type)
            progress()
      defn set-solved-sel (n:Int, xs:List) :
         println("solved sel: ~ = ~" << [n, xs])
         defn update () :
            selsolved[n] = SSel(xs)
            progress()
         match(get?(selsolved, n, false)) :
            (s:SSel) : update() when sels(s) != xs
            (s:False) : update()               
      defn unsolved (c:Constraint) :
         println("unsolved: ~" << [c])
         add(cqueue, c)         
      defn refine-sel (c:Constraint, xs:List<Type>, f: TArrow -> True|False|Maybe|Unknown) :
         val sel = isolate $
            for x in xs map :
               f(x as TArrow) when valid?(x)
         set-solved-sel(n(c), sel)
         unsolved(c) when any?(uk?, sel)
      defn refine-sel (c:Constraint, xs:List<LSType>, f: FnT -> True|False|Maybe|Unknown) :
         val sel = isolate $
            for x in xs map :
               f(x as FnT) when valid?(x)
         set-solved-sel(n(c), sel)
         unsolved(c) when any?(uk?, sel)
      defn sel! (n:Int) :
         fail() when not key?(selsolved, n)
         val sel = sels(selsolved[n])
         fail() when any?(uk?, sel)
         sel as List<True|Maybe|False>
      defn falses (xs:List) :
         map({false}, xs)
         
      for ci in 0 to length(cqueue) do :
         val c = sub-known(pop(cqueue))
         println("Considering: ~" << [c])
         match(c) :         
            (c:FlowConstraint) :
               if valid?(a(c)) and valid?(b(c)) :
                  match(flow(n(c), a(c), b(c))) :
                     (t:Type) : set-solved(n(c), t)
                     (t:Unknown) : unsolved(c)
               else : set-solved(n(c), TNone())      
            (c:LSFlowConstraint) :
               if valid?(a(c)) and valid?(b(c)) :
                  match(flow(n(c), a(c), b(c))) :
                     (t:Type) : set-solved(n(c), t)
                     (t:Unknown) : unsolved(c)
               else : set-solved(n(c), TNone())
            (c:MixConstraint) :
               attempt :
                  val sel = sel!(sel(c))
                  val valid = for (x in xs(c), s in sel) all? :
                     (s == false) or valid?(x)                     
                  set-solved{n(c), _} $
                     if valid : mix(sel, xs(c))
                     else : TNone()
               else : unsolved(c)
            (c:LSMixConstraint) :
               attempt :
                  val sel = sel!(sel(c))
                  val valid = for (x in xs(c), s in sel) all? :
                     (s == false) or valid?(x)
                  set-ls-solved{n(c), _} $
                     if valid : mix(sel, xs(c))
                     else : NoneT()
               else : unsolved(c)
            (c:PickConstraint) :
               attempt :
                  val y* =
                     if all?(valid?, ys(c)) :
                        for (y in ys(c), s in sel!(sel(c))) find! :
                           s not-typeof False
                     else : TNone()
                  set-solved(n(c), y*)
               else : unsolved(c)
            (c:LSPickConstraint) :
               attempt :
                  val y* =
                     if all?(valid?, ys(c)) :
                        for (y in ys(c), s in sel!(sel(c))) find! :
                           s not-typeof False
                     else : NoneT()
                  set-ls-solved(n(c), y*)
               else : unsolved(c)               
            (c:PartofConstraint) :
               if valid?(y(c)) :
                  refine-sel(c, xs(c), partof?{_, y(c)})
               else : set-solved-sel(n(c), falses(xs(c)))
            (c:CallableConstraint) :
               if all?(all?{valid?, _}, args(c)) :
                  refine-sel(c, xs(c), part-callable?{_, args(c)})
               else : set-solved-sel(n(c), falses(xs(c)))
            (c:LSCallableConstraint) :
               if all?(all?{valid?,_}, args(c)) :
                  refine-sel(c, xs(c), part-callable?{_, args(c)})
               else : set-solved-sel(n(c), falses(xs(c)))
            (c:LSSelConstraint) :
               if valid?(y(c)) :
                  refine-sel(c, xs(c), subtype?{_, y(c)})
               else : set-solved-sel(n(c), falses(xs(c)))   
            (c:SelMultiConstraint) :
               if valid?(x(c)) :
                  refine-sel(c, ys(c), submethod?{x(c), _})
               else : set-solved-sel(n(c), falses(ys(c)))
            (c:SubConstraint) :
               attempt :
                  if all?(valid?{value(_)}, env(c)) and valid?(x(c)) :
                     defn sub-env (t:Type) :
                        match(t) :
                           (t:TUVar) : fail()
                           (t:TVar) : lookup(env(c), n(t), t)
                           (t) : map(sub-env, t)
                     set-solved(n(c), sub-env(x(c)))
                  else :   
                     set-solved(n(c), TNone())
               else : unsolved(c)
            (c:EqualConstraint) :
               set-solved(n(c), type(c))
            (c:LSEqualConstraint) :
               set-ls-solved(n(c), type(c))
            (c:DeptrConstraint) :
               match(type(c)) :
                  (t:UVarT) : unsolved(c)
                  (t:PtrT) : set-ls-solved(n(c), type(t))
                  (t) : set-ls-solved(n(c), NoneT())
            (c:DerefConstraint) :
               attempt : set-ls-solved(n(c), deref(type(c)))
               else : unsolved(c)
            (c:FieldConstraint) :
               attempt : set-ls-solved(n(c), field(type(c), name(c)))
               else : unsolved(c)
            (c:ArgConstraint) :
               attempt :
                  val t = match(type(c)) :
                     (t:UVarT) : fail()
                     (t:FnT) :
                        val n = length(a(t))
                        match(r(t)) :
                           (rt:NoneT) :
                              a(t)[i(c)] when n == arity(c) else NoneT()
                           (rt) :
                              if n <= arity(c) : a(t)[i(c)] when i(c) < n else rt
                              else : NoneT()
                     (t) : NoneT()
                  set-ls-solved(n(c), t)   
               else : unsolved(c)   
            (c:RetConstraint) :
               match(type(c)) :
                  (t:UVarT) : unsolved(c)
                  (t:FnT) : set-ls-solved(n(c), b(t))
                  (t) : set-ls-solved(n(c), NoneT())
            (c:RefTypeConstraint) :
               match(type(c)) :
                  (t:UVarT) : unsolved(c)
                  (t:RefT) : set-solved(n(c), type(t))
                  (t) : set-solved(n(c), TNone())
            (c:LSPrimConstraint) :
               attempt :
                  defn #V (t:LSType) :
                     fail() when t typeof UVarT
                     t
                  defn binop (f: (LSType, LSType) -> LSType) :
                     if length(args(c)) == 2 :
                        f(#V(args(c)[0]), #V(args(c)[1]))
                     else : NoneT()
                  defn max-num () :
                     binop $ fn (x, y) :
                        match(x, y) :
                           (x:ByteT|IntT|LongT|FloatT|DoubleT, y:ByteT|IntT|LongT|FloatT|DoubleT) :
                              y when implicit-upcast?(x, y) else x
                           (x, y) : NoneT()
                  defn max-int () :
                     binop $ fn (x, y) :
                        match(x, y) :
                           (x:ByteT|IntT|LongT, y:ByteT|IntT|LongT) :
                              y when implicit-upcast?(x, y) else x
                           (x, y) : NoneT()

                  val t* = match(op(c)) :
                     (p:GetterPrimitive) :
                        type(p)
                     (p:SetterPrimitive) :
                        LongT()
                     (p) :
                        switch {p == _} :
                           LS-ADD-OP :
                              binop $ fn (x, y) :
                                 match(x, y) :
                                    (x:PtrT, y) : x
                                    (x, y) : max-num()
                           LS-SUB-OP :
                              binop $ fn (x, y) :
                                 match(x, y) :
                                    (x:PtrT, y:PtrT) : LongT()
                                    (x:PtrT, y) : x
                                    (x, y) : max-num()
                           LS-MUL-OP : max-num()
                           LS-DIV-OP : max-num()
                           LS-MOD-OP : max-int()
                           LS-AND-OP : max-int()
                           LS-OR-OP : max-int()
                           LS-XOR-OP : max-int()
                           LS-SHL-OP : max-int()
                           LS-SHR-OP : max-int()
                           LS-ASHR-OP : max-int()                     
                           LS-EQ-OP : LongT()
                           LS-NE-OP : LongT()
                           LS-LT-OP : LongT()
                           LS-GT-OP : LongT()
                           LS-LE-OP : LongT()
                           LS-GE-OP : LongT()
                           LS-ULT-OP : LongT()
                           LS-UGT-OP : LongT()
                           LS-ULE-OP : LongT()
                           LS-UGE-OP : LongT()         
                  set-ls-solved(n(c), t*)
               else : unsolved(c)

   ;======== Return Solutions ========
   for entry in solved do :
      val [n, t] = [key(entry), value(entry)]
      solved[n] = sub-known(t)
   for entry in lssolved do :
      val [n, t] = [key(entry), value(entry)]
      lssolved[n] = sub-known(t)
   SolveResults(solved, lssolved, selsolved)