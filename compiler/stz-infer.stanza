defpackage stz/infer :
   import core
   import verse
   import stz/tl-ir
   import stz/type-calculus
   import stz/algorithms

;============================================================
;================= Constraint Language ======================
;============================================================
#use-overlay(stz/ast-lang, stz/printer-lang)

public defmulti n (c:Constraint) -> Int

public defast :
   deftype Constraint
   defnodes Constraint :
      FlowConstraint :
         n:Int with: (as-method => true)
         a:Type
         b:Type
      SuperConstraint :
         n:Int with: (as-method => true)
         type:Type
      MixConstraint :
         n:Int with: (as-method => true)
         sel:Int
         xs:List<Type>
      SelConstraint :
         n:Int with: (as-method => true)
         xs:List<Type>
         y:Type
         min-y:Type
      SelMethodConstraint :
         n:Int with: (as-method => true)
         x:Type
         ys:List<Type>
      PickConstraint :
         n:Int with: (as-method => true)
         sel:Int
         ys:List<Type>
      ThresholdConstraint :
         n:Int with: (as-method => true)
         s:Int
      SubConstraint :
         n:Int with: (as-method => true)
         x:Type
         env:List<KeyValue<Int, Type>>
      EqualConstraint :
         n:Int with: (as-method => true)
         type:Type

   defmapper (f:Type -> Type) :
      (x:Type) : f(x)
      (x:List<Type>) : map(f, x)
      (xs:List<KeyValue<Int,Type>>) : for x in xs map : key(x) => f(value(x))      
      ignore(Int)

   make-mapper(f: Type -> Type, c:Constraint)

defprinter (c:Constraint) :
   FlowConstraint :
      ($flow n a b)
   SuperConstraint :
      ($super n type)
   MixConstraint :
      ($mix n sel (xs ...))
   SelConstraint :
      ($sel n (xs ...) y min-y)
   SelMethodConstraint :
      ($selmethod n x (ys ...))
   PickConstraint :
      ($pick n sel (ys ...))
   ThresholdConstraint :
      ($threshold n s)
   SubConstraint :
      ($sub n x env ...)
   EqualConstraint :
      ($equal n type)

;============================================================
;====================== Solver ==============================
;============================================================

defstruct SolveError <: Exception

public defstruct SolveResults :
   types: HashTable<Int,Type>
   sels: HashTable<Int,Selection>

public defn solve (constraints:Streamable<Constraint>) -> SolveResults :
   println("Solve:")
   do(println, constraints)
   
   ;======== State ========
   val solved = HashTable<Int,Type>({_})
   val selsolved = HashTable<Int, SSel>({_})
   val cqueue = Queue<Constraint>()
   do(add{cqueue, _}, constraints)

   ;======== Solving Utility Functions ========
   ;Substitute known types
   defn sub-known (t:Type) :
      defn save (n:Int, t:Type) :
         solved[n] = t
         t
      match(t) :
         (t:TUVar) :
            match(get?(solved, n(t), false)) :
               (r:Type) : save(n(t), sub-known(r))
               (r:False) : t
         (t) : map(sub-known, t)

   ;Substitute an env
   defn sub-env (t:Type, env:List<KeyValue<Int,Type>>) :
      match(t) :
         (t:TUVar) : throw(SolveError())
         (t:TVar) : lookup(env, n(t), t)
         (t) : map(sub-env{_, env}, t)

   ;Threshold a list
   defn threshold (s:Int) :
      throw(SolveError()) when not key?(selsolved, s)
      for x in sels(selsolved[s]) map :
         match(x) :
            (x:Maybe) : true
            (x:True|False|Unknown) : x

   ;Isolate
   defn isolate (s:List) :
      if count({_ not-typeof False}, s) == 1 : 
         map({_ not-typeof False}, s)
      else : s

   ;Compute selected
   defn select (xs:List<Type>, y:Type, min-y:Type) :
      isolate $
      for x in xs map :
         if partof?(x, min-y) != false :
            partof?(x, y)

   ;Compute method
   defn select-method (x:Type, ys:List<Type>) :
      defn sm? (x:Type, y:Type) :
         match(x, y) :
            (x:TArrow, y:TArrow) : submethod?(x, y)
            (x, y) : unknown
      isolate(map(sm?{x, _}, ys))

   ;Determine if x is unknown
   defn uk? (x) : x typeof Unknown

   ;Mix selected
   defn mix-types (s:Int, xs:List<Type>) :
      throw(SolveError()) when not key?(selsolved, s)
      throw(SolveError()) when not all?({_ typeof TArrow}, xs)
      val sel = sels(selsolved[s])
      throw(SolveError()) when any?(uk?, sel)
      mix(sel, xs as List<TArrow>)

   ;Pick selected
   defn pick-types (s:Int, ys:List<Type>) :
      throw(SolveError()) when not key?(selsolved, s)
      val sel = sels(selsolved[s])
      throw(SolveError()) when count({_ not-typeof False}, sel) != 1
      {_ as Type} $ for (y in ys, s in sel) find :
         s not-typeof False

   ;Remove cycles in a type
   defn rm-cycles (n*:Int, t:Type) -> Type :
      match(t) :
         (t:TUVar) : TBot() when n(t) == n* else t
         (t:TOr) : map(rm-cycles{n*, _}, t)
         (t) : t   

   ;Check if n* appears in t
   defn occurs? (n*:Int, t:Type) :
      match(t) :
         (t:TUVar) : n(t) == n*
         (t) : any?(occurs?{n*, _}, children(t))

   ;======== Phase 1: Removing super constraints ========
   remove-super-constraints() where :
      defn remove-super-constraints () :
         val vars = HashTable<Int,Type>({_})
         defn super (n:Int, b:Type) :
            vars[n] = match(get?(vars, n, false)) :
               (a:False) : b
               (a:Type) : TOr(a, b)
         for i in 0 to length(cqueue) do :
            match(pop(cqueue)) :
               (c:SuperConstraint) : super(n(c), type(c))
               (c) : add(cqueue, c)
         for entry in vars do :
            val [n, t] = [key(entry), value(entry)]
            add(cqueue, EqualConstraint(n, t))

   ;======== Phase 2: Dataflow solver ========
   fixpoint $ fn (progress) :
      defn set-solved (n:Int, type:Type) :
         val t = rm-cycles(n, type)
         if not occurs?(n, t) :
            println("solved: ~ = ~" << [n, t])
            solved[n] = simplify(t)
            progress()
      defn set-solved-sel (n:Int, xs:List) :
         println("solved: ~ = ~" << [n, xs])
         val s = match(get?(selsolved, n, false)) :
            (s:SSel) : sels(s)
            (s:False) : s
         if s != xs :
            selsolved[n] = SSel(xs)
            progress()
      defn unsolved (c:Constraint) :
         println("unsolved: ~" << [c])
         add(cqueue, c)         
         
      for i in 0 to length(cqueue) do :      
         val c = map(sub-known, pop(cqueue))
         println("Considering: ~" << [c])
         match(c) :         
            (c:FlowConstraint) :
               match(flow(n(c), a(c), b(c))) :
                  (t:Type) : set-solved(n(c), t)
                  (t:Unknown) : unsolved(c)
                  (t:False) : false
            (c:MixConstraint) :
               try : set-solved(n(c), mix-types(sel(c), xs(c)))
               catch (e:SolveError) : unsolved(c)
            (c:SelConstraint) :
               val sel = select(xs(c), y(c), min-y(c))
               set-solved-sel(n(c), sel)
               unsolved(c) when any?(uk?, sel)
            (c:SelMethodConstraint) :
               val sel = select-method(x(c), ys(c))
               set-solved-sel(n(c), sel)
               unsolved(c) when any?(uk?, sel)
            (c:PickConstraint) :
               try : set-solved(n(c), pick-types(sel(c), ys(c)))
               catch (e:SolveError) : unsolved(c)
            (c:ThresholdConstraint) :
               try :
                  val sel = threshold(s(c))
                  set-solved-sel(n(c), sel)
                  unsolved(c) when any?(uk?, sel)
               catch (e:SolveError) : unsolved(c)
            (c:SubConstraint) :
               try : set-solved(n(c), sub-env(x(c), env(c)))
               catch (e:SolveError) : unsolved(c)
            (c:EqualConstraint) :
               set-solved(n(c), type(c))

   ;======== Return Solutions ========
   for entry in solved do :
      val [n, t] = [key(entry), value(entry)]
      solved[n] = sub-known(t)
   SolveResults(solved, selsolved)