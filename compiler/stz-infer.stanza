defpackage stz/infer :
   import core
   import verse
   import stz/tl-ir
   import stz/type-calculus

;============================================================
;================= Constraint Language ======================
;============================================================
#use-overlay(stz/ast-lang, stz/printer-lang)

public defast :
   deftype Constraint
   defnodes Constraint :
      FlowConstraint : (n:Int, a:Type, b:Type)
      SuperConstraint : (n:Int, type:Type)
      MixConstraint : (n:Int, sel:Int, xs:List<Type>)
      SelConstraint : (n:Int, xs:List<Type>, y:Type)
      ThresholdConstraint : (n:Int, s:Int)
      SubConstraint : (n:Int, x:Type, env:List<KeyValue<Int, Type>>)
      EqualConstraint : (n:Int, type:Type)

   defmap (f:Type -> Type, c:Constraint) -> Constraint :
      (x:Int) : x
      (x:Type) : f(x)
      (x:List<Type>) : map(f, x)
      (xs:List<KeyValue<Int,Type>>) : for x in xs map : key(x) => f(value(x))

defprinter (c:Constraint) :
   FlowConstraint :
      ($flow n a b)
   SuperConstraint :
      ($super n type)
   MixConstraint :
      ($mix n sel (xs ...))
   SelConstraint :
      ($sel n xs y)
   ThresholdConstraint :
      ($threshold n s)
   SubConstraint :
      ($sub n x env ...)
   EqualConstraint :
      ($equal n type)

;;============================================================
;;====================== Solver ==============================
;;============================================================
;
;public definterface SolveResult
;public defstruct SolvedSel <: SolveResult : (sel:List)
;public defstruct Solved <: SolveResult : (type:Type)
;public defstruct Unsolveable <: SolveResult
;public defstruct Dependant <: SolveResult
;defstruct SolveError <: Exception
;
;defn solve (constraints:Streamable<Constraint>) -> HashTable<Int,SolveResult> :
;   ;Tables
;   val solved = HashTable<Int,Type>({_})
;   val selsolved = HashTable<Int, List>({_})
;   val unsolvable = Vector<Int>()
;   val cqueue = Queue<Constraint>()
;   do(add{cqueue, _}, constraints)
;
;   ;Substitute known types
;   defn sub-known (t:Type) :
;      defn save (n:Int, t:Type) : (solved[n] = t, t)
;      match(t) :
;         (t:TUVar) :
;            match(get?(solved, n(t), false)) :
;               (r:Type) : save(n(t), sub-known(r))
;               (r:False) : t
;         (t) : map(sub-known, t)
;
;   ;Substitute an env
;   defn sub-env (t:Type, env:List<KeyValue<Int,Type>>) :
;      match(t) :
;         (t:TUVar) : throw(SolveError())
;         (t:TVar) : lookup(env, n(t), t)
;         (t) : map(sub-env{_, env}, t)
;
;   ;Threshold a list
;   defn threshold (s:Int) :
;      match(get?(selsolved, s, false)) :
;         (s:List) :
;            for x in s map :
;               match(x) :
;                  (x:Maybe) : true
;                  (x:True|False|Unknown) : x
;         (s:False) : throw(SolveError())
;
;   ;Isolate
;   defn isolate (s:List) :
;      if count({_ not-typeof False}, s) == 1 : 
;         map({_ not-typeof False}, s)
;      else : s
;
;   ;Compute selected
;   defn select (xs:List<Type>, y:Type) :
;      isolate(for x in xs map : partof?(x, y))
;
;   ;Mix selected
;   defn mix-types (s:Int, xs:List<Type>) :
;      val sel = match(get?(selsolved, s, false)) :
;         (s:List) :
;            if any?({_ typeof Unknown}, s) : throw(SolveError())
;            else : s
;         (s:False) : throw(SolveError())
;      mix(sel, xs)
;
;   ;Remove cycles in a type
;   defn rm-cycles (tn:Int, t:Type) -> Type :
;      match(t) :
;         (t:TUVar) : TBot() when n(t) == tn else t
;         (t:TOr) : map(rm-cycles{tn, _}, t)
;         (t) : t   
;
;   ;Check if 
;   defn occurs? (tn:Int, t:Type) :
;      match(t) :
;         (t:TUVar) : n(t) == tn
;         (t) : any?(occurs?, children(t))
;
;   ;Remove super constraints
;   remove-super-constraints() where :
;      defn remove-super-constraints () :
;         val vars = HashTable<Int,Type>({_})
;         defn super (n:Int, b:Type) :
;            vars[n] = match(get?(vars, n, false)) :
;               (a:False) : b
;               (a:Type) : TOr(a, b)
;         for i in 0 to length(cqueue) do :
;            match(pop(cqueue)) :
;               (c:SuperConstraint) : super(n(c), type(c))
;               (c) : add(cqueue, c)
;         for entry in vars do :
;            val [n, t] = [key(entry), value(entry)]
;            add(cqueue, EqualConstraint(n, t))
;
;   ;Process constraints
;   fixpoint $ fn (progress) :
;      defn set-unsolvable (n:Int) :
;         add(unsolvable, n)
;      defn set-solved (n:Int, t:Type) :
;         solved[n] = t
;         progress()
;      defn unsolved (c:Constraint) :
;         add(cqueue, c)
;         
;      for i in 0 to length(cqueue) do :
;         match(map(sub-known, pop(cqueue))) :
;            (c:FlowConstraint) :
;               match(flow(n(c), x(c), y(c))) :
;                  (t:Type) : set-solved(n(c), t)
;                  (t:False) : set-unsolvable(n(c))
;                  (t:Unknown) : unsolved(c)
;            (c:MixConstraint) :
;               try : set-solved(n(c), mix-types(sel(c), xs(c)))
;               catch (e:SolveError) : unsolved(c)
;            (c:SelConstraint) :
;               val sel = select(xs(c), y(c))
;               set-solved-sel(n(c), sel)
;               unsolved(c) when any?({_ typeof Unknown}, sel)
;            (c:ThresholdConstraint) :
;               try :
;                  val sel = threshold(s(c))
;                  set-solved-sel(n(c), sel)
;                  unsolved(c) when any?({_ typeof Unknown}, sel)
;               catch (e:SolveError) : unsolved(c)
;            (c:SubConstraint) :
;               try : set-solved(n(c), sub-env(x(c), env(c)))
;               catch (e:SolveError) : unsolved(c)
;            (c:EqualConstraint) :
;               val t = rm-cycles(n(c), type(c))
;               if occurs?(n(c), t) : set-unsolvable(n(c))
;               else : set-solved(n(c), t)
;
;   ;Create solution table
;   val soln = HashTable<Int,SolveResult>({_})
;   for n in unsolvable do : soln[n] = Unsolveable()
;   for c in cqueue do : soln[n(c)] = Dependant()
;   defn get-soln (t:Type) :
;      label<SolveResult> return :
;         defn fill (t:Type) :
;            match(t) :
;               (t:TUVar) :
;                  match(get?(soln, n(t), false)) :
;                     (r:Solved) : type(r)
;                     (r:Unsolveable|Dependant) : return(Dependant())
;               (t) :
;                  map(fill, t)
;         fill(sub-known(t))
;   for entry in solved do :
;      soln[key(entry)] = get-soln(value(entry))
;   for entry in selsolved do :
;      soln[key(entry)] = SolvedSel(value(entry))
;   soln   