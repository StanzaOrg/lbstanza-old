defpackage stz/earley-lang :
  import core
  import collections
  import stz/earley-eval-result
  import stz/earley-grammar

;============================================================
;=================== Pattern Definition =====================
;============================================================

public deftype Pattern
public defstruct SeqPat <: Pattern :
  patterns: Tuple<Pattern>
public defstruct ListPat <: Pattern :
  pattern: Pattern
public defstruct Repeat <: Pattern :
  pattern: Pattern
public defstruct Production <: Pattern :
  name: Symbol
public defstruct Prim <: Pattern :
  type: GPrimType
public defstruct Form <: Pattern
public defstruct Rest <: Pattern
public defstruct Binder <: Pattern :
  name: Symbol
  pattern: Pattern
public defstruct Keyword <: Pattern :
  value: Symbol
public defstruct ChoicePat <: Pattern :
  patterns: Tuple<Pattern>

;------------------------------------------------------------
;----------------------- Printer ----------------------------
;------------------------------------------------------------

defmethod print (o:OutputStream, p:Pattern) :
  match(p) :
    (p:SeqPat) :
      print(o, "%s" % [patterns(p)])
    (p:ListPat) :
      print(o, "(%_)" % [pattern(p)])
    (p:Repeat) :
      print(o, "%_ ..." % [pattern(p)])
    (p:Production) :
      print(o, "#%_" % [name(p)])
    (p:Prim) :
      print(o, "#%_" % [type(p)])
    (p:Form) :
      print(o, "_")
    (p:Rest) :
      print(o, "_ ...")
    (p:Binder) :
      print(o, "?%_ : %_" % [name(p), pattern(p)])
    (p:Keyword) :
      print(o, value(p))
    (p:ChoicePat) :
      print(o, "(%*)" % [join(patterns(p), " | ")])

;============================================================
;====================== Rule Definition =====================
;============================================================

public deftype SyntaxExp

public defstruct DefProductionExp <: SyntaxExp :
  name: Symbol

public defstruct DefRuleExp <: SyntaxExp :
  production: Symbol
  pattern: Pattern
  guard: Maybe<(? -> True|False)>
  action: ParsedBinders -> ?
  priority: Int
  associativity: Associativity
  lazy?: True|False

;============================================================
;=================== Package Definition =====================
;============================================================

public defstruct SyntaxPackage :
  name: Symbol
  exps: Tuple<SyntaxExp>

;============================================================
;================= Parse Pattern ============================
;============================================================

;Parse the given form as a Pattern.
;Throws PatternParseError if the form does not represent a valid pattern.
public defn parse-pattern (input-form:List) -> Pattern :
  ;Remove all token information.
  val form = unwrap-all(input-form)

  ;Parse the given list as a list of patterns, and returns the
  ;list remaining after the parse ends.
  ;The choice | operator is not handled by this function
  ;and the parse ends when it encounters this.
  defn parse-pats (f:List) -> [List<Pattern>, List] :
    ;End of list or choice operator
    if empty?(f) or tagged-list?(f, `|) :
      [List(), f]
    ;Invalid pattern
    else if tagged-list?(f, `@...) or
            tagged-list?(f, `...) :
      throw(InvalidRepetitionOperator(head(f)))
    ;Binder
    else if tagged-list?(head(f), `@cap) :
      val name = ensure-cap-form(head(f))
      val [ps, rest] =
        if tagged-list?(tail(f), `:) : parse-pats(tailn(f,2))
        else : parse-pats(cons(`_, tail(f)))
      ensure-binder-pattern(name, ps)
      [cons(Binder(name, head(ps)), tail(ps)), rest]
    ;Escape
    else if tagged-list?(f, `~) :
      ensure-escape-value(tail(f))
      val item = form[1] as Symbol
      val [p, rest] = parse-pats(tailn(f,2))
      [cons(Keyword(item),p), rest]
    ;Repeat Splice
    else if tagged-list?(tail(f), `@...) :
      val p1 = ensure-splice-list(parse-single-pat(head(f)))
      val [p2, rest] = parse-pats(tailn(f,2))
      [cons(Repeat(p1), p2), rest]
    ;Repeat
    else if tagged-list?(tail(f), `...) :
      val p1 = parse-single-pat(head(f))
      val [p2, rest] = parse-pats(tailn(f,2))
      [cons(Repeat(p1), p2), rest]
    ;Otherwise
    else :
      val p1 = parse-single-pat(head(f))
      val [p2, rest] = parse-pats(tail(f))
      [cons(p1,p2), rest]

  ;Parse a single s-expression as a pattern.
  ;This s-expression is assumed to lie within a
  ;list pattern.
  defn parse-single-pat (form) -> Pattern :
    match(form) :
      (form:List) :
        val pats = parse-choice-pats(form)
        if length(pats) == 1 : ListPat(head(pats))
        else : ChoicePat(to-tuple(pats))
      (form:Symbol) :
        if form == `_ : Form()
        else if prefix?(form, "#") : Production(subsymbol(form,1))
        else : Keyword(form)
      (form) :
        fatal("Not yet handled.")

  ;Parse the given list as a list of choice patterns.
  ;Returned list is guaranteed to not be empty.
  defn parse-choice-pats (f:List) -> List<Pattern> :
    val [pats, rest] = parse-pats(f)
    val pat = make-seq(pats)
    if empty?(rest) :
      List(pat)
    else :
      fatal("Expected choice operator.") when not tagged-list?(rest, `|)
      cons(pat, parse-choice-pats(tail(rest)))

  ;Create a SeqPat object from the list of patterns
  ;unless the list has exactly length 1.
  defn make-seq (ps:List<Pattern>) -> Pattern :
    if length(ps) == 1 : head(ps)
    else : SeqPat(to-tuple(ps))

  ;Apply post-processing transformations to pattern.
  defn postprocess (pat:Pattern) :
    println("Analyzed Binders:")
    within indented() :
      do(println,analyze-binders(pat))
    lift-rests(simplify-repeat(pat))

  ;Launch!
  val pats = parse-choice-pats(form)
  postprocess $
    if length(pats) == 1 : head(pats)
    else : ChoicePat(to-tuple(pats))

;------------------------------------------------------------
;--------------------- Error Conditions ---------------------
;------------------------------------------------------------

;Throw InvalidBindingForm if given form does not have structure (@cap name).
;Returns 'name' otherwise.
defn ensure-cap-form (form:List) -> Symbol :
  if length(form) != 2 or form[1] is-not Symbol :
    throw(InvalidBindingForm(form))
  form[1]

;Throw MissingEscapedTerminal if form is empty.
defn ensure-escape-value (form:List) :
  throw(MissingEscapedTerminal()) when empty?(form)

;Throw InvalidSpliceRepeat if pattern 'p' is not a ListPat.
;Returns the wrapped pattern within the list if it is.
defn ensure-splice-list (p:Pattern) -> Pattern :
  match(p:ListPat) : pattern(p)
  else : throw(InvalidSpliceRepeat(p))

;Throw MissingBinderPattern if list of patterns 'ps' is empty.
defn ensure-binder-pattern (name:Symbol, ps:List<Pattern>) :
  throw(MissingBinderPattern(name)) when empty?(ps)

;------------------------------------------------------------
;-------------------- Small Utilities -----------------------
;------------------------------------------------------------

;Returns a new symbol with the first n characters of 'x' removed.
defn subsymbol (x:Symbol, n:Int) -> Symbol :
  to-symbol(to-string(x)[n to false])

;Returns true if the given form has structure (tag ...).
defn tagged-list? (form, tag:Symbol) -> True|False :
  match(form:List) :
    not empty?(form) and head(form) == tag

;============================================================
;================ Pattern Post-Processing ===================
;============================================================

;Return a new pattern with the following replacement performed.
;Repeat(?x:P) => ?x:Repeat(P)
defn simplify-repeat (p:Pattern) -> Pattern :
  match(map(simplify-repeat,p)) :
    (p:Repeat) :
      match(pattern(p)) :
        (b:Binder) : Binder(name(b), Repeat(pattern(b)))
        (pat) : p
    (p) : p

;Return a new pattern with the following replacement performed.
;(a b c _ ...) => (a b c R)
defn lift-rests (p:Pattern) -> Pattern :
  defn lift (p:Pattern, last-in-list?:True|False) -> Pattern :
    match(p) :
      (p:SeqPat) :
        val n = length(patterns(p))
        val patterns* = to-tuple $
          for (p in patterns(p), i in 0 to false) seq :
            lift(p, last-in-list? and i == n - 1)
        SeqPat(patterns*)
      (p:ListPat) :
        ListPat(lift(pattern(p), true))
      (p0:Repeat) :
        val p = map(lift{_, false}, p0) as Repeat
        match(pattern(p)) :
          (pat:Form) : Rest()
          (pat) : p
      (p) :
        map(lift{_, last-in-list?}, p)
  lift(p, true)

defn map (f:Pattern -> Pattern, p:Pattern) -> Pattern :
  match(p) :
    (p:SeqPat) : SeqPat(map(f,patterns(p)))
    (p:ListPat) : ListPat(f(pattern(p)))
    (p:Repeat) : Repeat(f(pattern(p)))
    (p:Production) : p
    (p:Prim) : p
    (p:Form) : p
    (p:Rest) : p
    (p:Binder) : Binder(name(p), f(pattern(p)))
    (p:Keyword) : p
    (p:ChoicePat) : ChoicePat(map(f,patterns(p)))

defn do (f:Pattern -> ?, p:Pattern) -> False :
  defn g (p:Pattern) : p
  map(g,p)
  false

;============================================================
;==================== Parse Errors ==========================
;============================================================

deftype PatternParseError <: Exception

defstruct InvalidRepetitionOperator <: PatternParseError :
  operator: Symbol

defmethod print (o:OutputStream, e:InvalidRepetitionOperator) :
  val msg = "Invalid position for repetition operator '%~'. \
             Repetition operator should follow a pattern."
  print(o, msg % [operator(e)])

defstruct InvalidBindingForm <: PatternParseError :
  form: List

defmethod print (o:OutputStream, e:InvalidBindingForm) :
  val msg = "Invalid syntax for binder form: %~. Binder should \
             have form (@cap binder-name)."
  print(o, msg % [form(e)])

defstruct MissingEscapedTerminal <: PatternParseError

defmethod print (o:OutputStream, e:MissingEscapedTerminal) :
  print(o, "Expected an escaped terminal here, but reached end of list.")

defstruct InvalidSpliceRepeat <: PatternParseError :
  pattern: Pattern

defmethod print (o:OutputStream, e:InvalidSpliceRepeat) :
  val msg = "The splice repeat operator @... requires a list pattern, \
             but found %_."
  print(o, msg % [pattern(e)])

defstruct MissingBinderPattern <: PatternParseError :
  name: Symbol

defmethod print (o:OutputStream, e:MissingBinderPattern) :
  val msg = "No binding pattern provided for pattern binder %~."
  print(o, msg % [name(e)])

;============================================================
;===================== Binder Analysis ======================
;============================================================

defstruct AnalyzedBinder :
  name:Symbol
  pos:BinderPos

deftype BinderPos
defmulti index (p:BinderPos) -> Int
defstruct LeafPos <: BinderPos :
  index: Int with: (as-method => true)
  pattern: Pattern
defstruct RepeatPos <: BinderPos :
  index: Int with: (as-method => true)
  pos: BinderPos
defstruct ChoicePos <: BinderPos :
  index: Int with: (as-method => true)
  choices: Tuple<BinderPos|False>

defmethod print (o:OutputStream, b:AnalyzedBinder) :
  print(o, "AnalyzedBinder(%_,%_)" % [name(b), indented-list([pos(b)])])

defmethod print (o:OutputStream, p:BinderPos) :
  match(p) :
    (p:LeafPos) :
      print(o, "LeafPos(%_, %_)" % [index(p), pattern(p)])
    (p:RepeatPos) :
      print(o, "RepeatPos(%_,%_)" % [index(p), indented-list([pos(p)])])
    (p:ChoicePos) :
      val entries = for (c in choices(p), i in 0 to false) seq? :
        match(c:BinderPos) : One(i => c)
        else : None()
      print(o, "ChoicePos(%_,%_)" % [index(p), indented-list(entries)])

defn indented-list (xs:Seqable) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, xs)

defn analyze-binders (input-pattern:Pattern) -> Tuple<AnalyzedBinder> :
  defn scan (return:(Symbol, BinderPos) -> ?, p:Pattern) :
    val index = to-seq(0 to false)
    let loop (p:Pattern = p) :
      match(p) :
        (p:SeqPat) :
          do(loop, patterns(p))
        (p:ListPat) :
          next(index) ;ListStart
          loop(pattern(p))
          next(index) ;ListEnd
        (p:Repeat) :
          val i = next(index)
          within (name, pos) = scan(pattern(p)) :
            return(name, RepeatPos(i, pos))
        (p:Binder) :
          return(name(p), LeafPos(next(index), pattern(p)))
        (p:ChoicePat) :
          val i = next(index)
          val pos-table = HashTable-init<Symbol,Vector<KeyValue<Int,BinderPos>>>(
                            Vector<KeyValue<Int,BinderPos>>{})
          for (c in patterns(p), i in 0 to false) do :
            within (name, pos) = scan(c) :
              add(pos-table[name], i => pos)
          for entry in pos-table do :
            val name = key(entry)
            val choices = to-tuple(length(patterns(p)), value(entry))
            return(name, ChoicePos(i, choices))
        (p:Production|Prim|Form|Keyword|Rest) :
          next(index)
  val binders = Vector<AnalyzedBinder>()
  within (name, pos) = scan(input-pattern) :
    add(binders, AnalyzedBinder(name,pos))
  to-tuple(binders)

;------------------------------------------------------------
;--------------- Utility: Dense Array -----------------------
;------------------------------------------------------------
defn to-tuple<?T> (len:Int, xs:Seqable<KeyValue<Int,?T>>) -> Tuple<T|False> :
  val array = Array<T|False>(len, false)
  for x in xs do :
    array[key(x)] = value(x)
  to-tuple(array)

;============================================================
;====================== ParsedBinders =======================
;============================================================

deftype BinderExtractor
defmulti extract (e:BinderExtractor, result:ParsedResult, name:Symbol) -> ?

defn BinderExtractor (binders:Tuple<AnalyzedBinder>) -> BinderExtractor :
  defn compile (p:BinderPos) -> (ParsedResult -> ?) :
    match(p) :
      (p:LeafPos) :
        val extract = binding-value-extractor(pattern(p))
        fn (result) :
          extract(result[index(p)])
      (p:RepeatPos) :
        val extract = compile(pos(p))
        fn (result) :
          val results = result[index(p)] as List<ParsedResult>
          map(extract, results)
      (p:ChoicePos) :
        val extractors = for c in choices(p) map :
          match(c:BinderPos) : compile(c)
          else : fn (result) : false
        fn (result) :
          val choice = result[index(p)] as ChoiceResult
          val extract = extractors[index(choice)]
          extract(/result(choice))
  val extractors = 
    for b in binders map :
      name(b) => compile(pos(b))
  new BinderExtractor :
    defmethod extract (this, result:ParsedResult, name:Symbol) :
      val extract = lookup?(extractors, name)
      match(extract:ParsedResult -> ?) : extract(result)
      else : fatal("There is no binder '%~' for this rule.")

public deftype ParsedBinders
public defmulti get (bs:ParsedBinders, name:Symbol) -> ?

defn ParsedBinders (e:BinderExtractor, result:ParsedResult) :
  new ParsedBinders :
    defmethod get (this, name:Symbol) :
      extract(e, result, name)

;============================================================
;===================== Choice Results =======================
;============================================================

defstruct ChoiceResult :
  index: Int
  result: ParsedResult

;============================================================
;===================== List Results =========================
;============================================================

deftype ListResult
defmulti value (r:ListResult, rest:List) -> List

defn list-result-extractor (p:Pattern) -> (ParsedResult -> ListResult) :
  val index = to-seq(0 to false)
  defn extractor (p:Pattern) -> (ParsedResult -> ListResult) :
    match(p) :
      (p:SeqPat) :
        val n = length(patterns(p))
        val extractors = map(extractor, patterns(p))
        fn (result) :
          new ListResult :
            defmethod value (this, rest:List) :
              let loop (i:Int = n - 1, rest:List = rest) :
                if i >= 0 :
                  val r = extractors[i](result)
                  loop(i - 1, value(r, rest))
                else :
                  rest
      (p:ListPat) :
        next(index) ;ListStart token
        val extract = extractor(pattern(p))
        next(index) ;ListEnd token
        fn (result) :
          new ListResult :
            defmethod value (this, rest:List) :
              val form = value(extract(result), List())
              cons(form, rest)              
      (p:Repeat) :
        val i = next(index)
        fn (result) :
          result[i] as ListResult
      (p:ChoicePat) :
        val i = next(index)
        fn (result) :
          result[i] as ListResult
      (p:Keyword|Form|Prim|Production) :
        val i = next(index)
        fn (result) :
          new ListResult :
            defmethod value (this, rest:List) :
              cons(result[i], rest)
      (p:Rest) :
        val i = next(index)
        fn (result) :
          new ListResult :
            defmethod value (this, rest:List) :
              result[i]
  extractor(p)

defn binding-value-extractor (p:Pattern) -> (? -> ?) :
  match(p) :
    (p:Keyword|Form|Prim|Production|Rest) :
      fn (x) : x
    (p:ChoicePat|Repeat|ListPat|SeqPat) :
      fn (x:ListResult) : value(x,List())
        
;============================================================
;==================== Making GRules =========================
;============================================================

public defstruct StartRule :
  pattern: Pattern
  action: ParsedBinders -> ?

public defn make-rules (p:SyntaxPackage, starting-rules:Tuple<StartRule>) :
  val m = RuleMaker()
  for e in filter-by<DefProductionExp>(exps(p)) do :
    add(m, make-def(m,e))
  for e in filter-by<DefRuleExp>(exps(p)) do :
    add(m, make-rule(m,e))
  val start-prod = fresh-prod-id(m)
  add(m, GDefProduction(start-prod, `Start))
  add(m, GDefProduction(0, `Top))
  for r in starting-rules do :
    add(m, make-starting-rule(m, start-prod, pattern(r), action(r)))
  add(m, make-top-rule(m, GProduction(start-prod), {_}))
  grules(m)

public defn make-rules (p:SyntaxPackage, start-pattern:Pattern) :
  val m = RuleMaker()
  for e in filter-by<DefProductionExp>(exps(p)) do :
    add(m, make-def(m,e))
  for e in filter-by<DefRuleExp>(exps(p)) do :
    add(m, make-rule(m,e))
  add(m, GDefProduction(0, `Top))
  val start-token = make-binder(m, 0, start-pattern)
  add(m, make-top-rule(m, start-token, binding-value-extractor(start-pattern)))
  grules(m)

;============================================================
;===================== Rule Maker ===========================
;============================================================

deftype RuleMaker

;Return a new identifier to use for productions.
defmulti fresh-prod-id (m:RuleMaker) -> Int

;Return a new identifier to use for rules.
defmulti fresh-rule-id (m:RuleMaker) -> Int

;Retrieve the GProduction corresponding to production 'p'.
defmulti production-id (m:RuleMaker, production:Symbol) -> Int

;Create a new production with the same name as the given 'prod-id'.
defmulti clone-production (m:RuleMaker, prod-id:Int) -> Int

;Add newly created rule
defmulti add (m:RuleMaker, rule:GRule) -> False

;Define a production
defmulti add (m:RuleMaker, def:GDefProduction) -> False

;Return rules
defmulti grules (m:RuleMaker) -> GRules

;------------------------------------------------------------
;--------------- Rule Maker Implementation ------------------
;------------------------------------------------------------

defn RuleMaker () :
  val prod-counter = to-seq(1 to false)
  val rule-counter = to-seq(0 to false)
  val rules = Vector<GRule>()
  val production-ids = HashTable<Symbol,Int>()
  val production-table = IntTable<GDefProduction>()

  new RuleMaker :
    defmethod fresh-prod-id (this) :
      next(prod-counter)
    defmethod fresh-rule-id (this) :
      next(rule-counter)
    defmethod production-id (this, production:Symbol) :
      production-ids[production]
    defmethod clone-production (this, id:Int) :
      val id* = fresh-prod-id(this)
      val def = production-table[id]
      production-table[id*] = GDefProduction(id*, symbol-join([name(def) "*"]))
      id*
    defmethod add (this, rule:GRule) :
      add(rules, rule)
    defmethod add (this, def:GDefProduction) :
      production-table[id(def)] = def
      production-ids[name(def)] = id(def)
    defmethod grules (this) :
      GRules(
        to-tuple(values(production-table)),
        to-tuple(rules))

;============================================================
;=========== Utilities for Conversion to GRule ==============
;============================================================

;Create the definition for the given production.
defn make-def (m:RuleMaker, exp:DefProductionExp) -> GDefProduction :
  val prod-id = fresh-prod-id(m)
  GDefProduction(prod-id, name(exp))

;Create a callback that computes a result from a ParsedResult, given
;a callback that computes a result from a ParsedBinders.
defn make-action (action:ParsedBinders -> ?, pattern:Pattern) -> (ParsedResult -> ?) :
  val extractor = BinderExtractor(analyze-binders(pattern))
  fn (result) :
    action(ParsedBinders(extractor, result))

;Create an appropriate rule for the given rule expression.
defn make-rule (m:RuleMaker, exp:DefRuleExp) -> GRule :
  val rule-id = fresh-rule-id(m)
  val prod-id = production-id(m, production(exp))
  val tokens = make-tokens(m, prod-id, pattern(exp), false)
  if empty?(guard(exp)) :
    val action = make-action(action(exp), pattern(exp))
    val params = TokenRuleParams(priority(exp), associativity(exp), action, lazy?(exp))
    GTokenRule(rule-id, prod-id, tokens, params)
  else :  
    val terminal = tokens[0] as GTerminal
    val matcher = value!(guard(exp))
    val action = make-action(action(exp), pattern(exp))
    GMatcherRule(rule-id, prod-id, terminal, matcher, action, priority(exp))

;Convert the given pattern into tuple of GToken for creating GRule.
defn make-tokens (m:RuleMaker, prod-id:Int, p:Pattern, binder-pattern?:True|False) -> Tuple<GToken> :
  val tokens = Vector<GToken>()
  let loop (p:Pattern = p) :
    match(p) :
      (p:SeqPat) :
        do(loop, patterns(p))
      (p:ListPat) :
        add(tokens, GListStart())
        loop(pattern(p))
        add(tokens, GListEnd())
      (p:Repeat) :
        add(tokens, make-repeat(m, prod-id, pattern(p), binder-pattern?))
      (p:ChoicePat) :
        add(tokens, make-choice(m, prod-id, patterns(p), binder-pattern?))
      (p:Production) :
        val id = production-id(m, name(p))
        add(tokens, GProduction(id))
      (p:Prim) :
        add(tokens, GPrimToken(type(p)))
      (p:Form) :
        add(tokens, GAny())
      (p:Rest) :
        add(tokens, GListRest())
      (p:Keyword) :
        add(tokens, GKeyword(value(p)))
      (p:Binder) :
        make-binder(m, prod-id, pattern(p))
  to-tuple(tokens)

defn make-binder (m:RuleMaker, parent-prod-id:Int, p:Pattern) -> GToken :
  match(p) :
    (p:Keyword|Form|Prim|Production|Rest|Repeat|ChoicePat) :
      val ts = make-tokens(m, parent-prod-id, p, true)
      fatal("Expected single token.") when length(ts) != 1
      ts[0]
    (p:SeqPat|ListPat) :
      val prod-id = clone-production(m, parent-prod-id)
      val tokens = make-tokens(m, prod-id, p, true)
      val rule-id = fresh-rule-id(m)
      val make-result = list-result-extractor(p)
      val params = TokenRuleParams(100, NonAssociative, make-result, false)
      val rule = GTokenRule(rule-id, prod-id, tokens, params)
      add(m, rule)
      GProduction(prod-id)

;Create a new production for the given pattern, whose action
;simply returns the ParseResult.
defn make-internal-production (m:RuleMaker, parent-prod-id:Int, p:Pattern, binder-pattern?:True|False) -> GProduction :
  val prod-id = clone-production(m, parent-prod-id)
  val rule-id = fresh-rule-id(m)
  val tokens = make-tokens(m, prod-id, p, binder-pattern?)
  val make-result =
    if binder-pattern? :
      list-result-extractor(p)
    else :
      fn (result:ParsedResult) :
        result
  val params = TokenRuleParams(100, NonAssociative, make-result, false)
  val rule = GTokenRule(rule-id, prod-id, tokens, params)
  add(m, rule)
  GProduction(prod-id)

;Create a production for representing the choice between patterns 'ps'.
defn make-choice (m:RuleMaker, parent-prod-id:Int, patterns:Tuple<Pattern>, binder-pattern?:True|False) -> GProduction :
  val prod-id = clone-production(m, parent-prod-id)
  for (pattern in patterns, index in 0 to false) do :
    val rule = GTokenRule(rule-id, prod-id, tokens, params) where :
      val rule-id = fresh-rule-id(m)
      val tokens = make-tokens(m, prod-id, pattern, binder-pattern?)
      val make-result =
        if binder-pattern? :
          list-result-extractor(pattern)
        else :
          fn (result:ParsedResult) :
            ChoiceResult(index, result)
      val params = TokenRuleParams(100, NonAssociative, make-result, false)
    add(m, rule)
  GProduction(prod-id)

;Create a production for representing the repetition of the pattern 'p'.
;The associated action returns List<ParseResult>.
defn make-repeat (m:RuleMaker, parent-prod-id:Int, p:Pattern, binder-pattern?:True|False) -> GProduction :
  val prod-id = clone-production(m, parent-prod-id)
  val rule1 = GTokenRule(rule-id, prod-id, tokens, params) where :
    val tokens = [
      make-internal-production(m, prod-id, p, binder-pattern?),
      GProduction(prod-id)]
    val rule-id = fresh-rule-id(m)
    val make-result =
      if binder-pattern? :
        fn (result:ParsedResult) :
          val x = result[0] as ListResult
          val xs = result[1] as ListResult
          new ListResult :
            defmethod value (this, rest:List) :
              value(x, value(xs, rest))
      else :
        fn (result:ParsedResult) :
          cons(result[0] as ParsedResult, result[1] as List<ParsedResult>)
    val params = TokenRuleParams(100, NonAssociative, make-result, false)
  val rule2 = GTokenRule(rule-id, prod-id, [], params) where :
    val rule-id = fresh-rule-id(m)
    val make-result =
      if binder-pattern? :
        fn (result:ParsedResult) :
          new ListResult :
            defmethod value (this, rest:List) :
              rest
      else :
        fn (result:ParsedResult) :
          List()
    val params = TokenRuleParams(100, NonAssociative, make-result, false)
  add(m, rule1)
  add(m, rule2)
  GProduction(prod-id)

;Create a starting rule for the parser.
defn make-starting-rule (m:RuleMaker, prod:Int, p:Pattern, binder-action:ParsedBinders -> ?) -> GTokenRule :
  GTokenRule(rule-id, prod, tokens, params) where :
    val rule-id = fresh-rule-id(m)
    val tokens = make-tokens(m, prod, p, false)
    val action = make-action(binder-action, p)
    val params = TokenRuleParams(100, NonAssociative, action, false)

;Create the top launcher rule for the grammar.
defn make-top-rule (m:RuleMaker, start-token:GToken, extract:? -> ?) -> GTokenRule :
  GTokenRule(rule-id, 0, tokens, params) where :
    val rule-id = fresh-rule-id(m)
    val tokens = [GListStart(), start-token, GListEnd()]
    val params = TokenRuleParams(100, NonAssociative, fn (result) : extract(result[1]), false)