defpackage stz/earley-lang :
  import core
  import collections
  import stz/earley-eval-result
  import stz/earley-grammar

;============================================================
;=================== Pattern Definition =====================
;============================================================

public deftype Pattern
public defstruct SeqPat <: Pattern :
  patterns: Tuple<Pattern>
public defstruct ListPat <: Pattern :
  pattern: Pattern
public defstruct Repeat <: Pattern :
  pattern: Pattern
public defstruct Production <: Pattern :
  name: Symbol
public defstruct Prim <: Pattern :
  type: GPrimType
public defstruct Form <: Pattern
public defstruct Rest <: Pattern
public defstruct Binder <: Pattern :
  name: Symbol
  pattern: Pattern
public defstruct Keyword <: Pattern :
  value: Symbol

;============================================================
;====================== Rule Definition =====================
;============================================================

public deftype SyntaxExp

public defstruct DefProductionExp <: SyntaxExp :
  name: Symbol

public defstruct DefRuleExp <: SyntaxExp :
  production: Symbol
  pattern: Pattern
  guard: Maybe<(? -> True|False)>
  action: ParsedResult -> ?
  priority: Int
  associativity: Associativity
  lazy?: True|False

;============================================================
;=================== Package Definition =====================
;============================================================

public defstruct SyntaxPackage :
  name: Symbol
  exps: Tuple<SyntaxExp>

;============================================================
;==================== Making GRules =========================
;============================================================

public defn make-rules (p:SyntaxPackage, starting-pattern:Pattern) :
  val m = RuleMaker()
  for e in filter-by<DefProductionExp>(exps(p)) do :
    add(m, make-def(m,e))
  for e in filter-by<DefRuleExp>(exps(p)) do :
    add(m, make-rule(m,e))
  add(m, GDefProduction(0, `Start))
  add(m, make-starting-rule(m, starting-pattern))
  grules(m)

;============================================================
;===================== Rule Maker ===========================
;============================================================

deftype RuleMaker

;Return a new identifier to use for productions.
defmulti fresh-prod-id (m:RuleMaker) -> Int

;Return a new identifier to use for rules.
defmulti fresh-rule-id (m:RuleMaker) -> Int

;Retrieve the GProduction corresponding to production 'p'.
defmulti production-id (m:RuleMaker, production:Symbol) -> Int

;Create a new production with the same name as the given 'prod-id'.
defmulti clone-production (m:RuleMaker, prod-id:Int) -> Int

;Add newly created rule
defmulti add (m:RuleMaker, rule:GRule) -> False

;Define a production
defmulti add (m:RuleMaker, def:GDefProduction) -> False

;Return rules
defmulti grules (m:RuleMaker) -> GRules

;------------------------------------------------------------
;--------------- Rule Maker Implementation ------------------
;------------------------------------------------------------

defn RuleMaker () :
  val prod-counter = to-seq(1 to false)
  val rule-counter = to-seq(0 to false)
  val rules = Vector<GRule>()
  val production-ids = HashTable<Symbol,Int>()
  val production-table = IntTable<GDefProduction>()
  
  new RuleMaker :
    defmethod fresh-prod-id (this) :
      next(prod-counter)
    defmethod fresh-rule-id (this) :
      next(rule-counter)
    defmethod production-id (this, production:Symbol) :
      production-ids[production]
    defmethod clone-production (this, id:Int) :
      val id* = fresh-prod-id(this)
      val def = production-table[id]
      production-table[id*] = GDefProduction(id*, symbol-join([name(def) "*"]))
      id*
    defmethod add (this, rule:GRule) :
      add(rules, rule)
    defmethod add (this, def:GDefProduction) :
      production-table[id(def)] = def
      production-ids[name(def)] = id(def)
    defmethod grules (this) :
      GRules(
        to-tuple(values(production-table)),
        to-tuple(rules))

;============================================================
;=========== Utilities for Conversion to GRule ==============
;============================================================

;Create the definition for the given production.
defn make-def (m:RuleMaker, exp:DefProductionExp) -> GDefProduction :
  val prod-id = fresh-prod-id(m)
  GDefProduction(prod-id, name(exp))

;Create an appropriate rule for the given rule expression.
defn make-rule (m:RuleMaker, exp:DefRuleExp) -> GRule :
  val rule-id = fresh-rule-id(m)
  val prod-id = production-id(m, production(exp))
  val tokens = make-tokens(m, prod-id, pattern(exp))
  if empty?(guard(exp)) :
    val params = TokenRuleParams(priority(exp), associativity(exp), default-action, lazy?(exp))
    GTokenRule(rule-id, prod-id, tokens, params)
  else :
    val terminal = tokens[0] as GTerminal
    val matcher = value!(guard(exp))
    GMatcherRule(rule-id, prod-id, terminal, matcher, default-action, priority(exp))

;Convert the given pattern into tuple of GToken for creating GRule.
defn make-tokens (m:RuleMaker, prod-id:Int, p:Pattern) -> Tuple<GToken> :
  val tokens = Vector<GToken>()
  let loop (p:Pattern = p) :
    match(p) :
      (p:SeqPat) :
        do(loop, patterns(p))
      (p:ListPat) :
        add(tokens, GListStart())
        loop(pattern(p))
        add(tokens, GListEnd())
      (p:Repeat) :
        add(tokens, make-repeat(m, prod-id, pattern(p)))
      (p:Production) :
        val id = production-id(m, name(p))
        add(tokens, GProduction(id))
      (p:Prim) :
        add(tokens, GPrimToken(type(p)))
      (p:Form) :
        add(tokens, GAny())
      (p:Rest) :
        add(tokens, GListRest())
      (p:Keyword) :
        add(tokens, GKeyword(value(p)))
      (p:Binder) :
        fatal("Binder should be removed by this stage.")
  to-tuple(tokens)

;Create a production for representing the repetition of the pattern 'p'.
defn make-repeat (m:RuleMaker, parent-prod-id:Int, p:Pattern) -> GProduction :
  val prod-id = clone-production(m, parent-prod-id)
  val rule1 = GTokenRule(rule-id, prod-id, to-tuple(tokens), params) where :
    val tokens = Vector<GToken>()
    add-all(tokens, make-tokens(m, prod-id, p))
    add(tokens, GProduction(prod-id))
    val rule-id = fresh-rule-id(m)
    val params = TokenRuleParams(100, NonAssociative, default-action, false)
  val rule2 = GTokenRule(rule-id, prod-id, [], params) where :
    val rule-id = fresh-rule-id(m)
    val params = TokenRuleParams(100, NonAssociative, default-action, false)
  add(m, rule1)
  add(m, rule2)
  GProduction(prod-id)  

;Create the starting rule for the paser.
defn make-starting-rule (m:RuleMaker, p:Pattern) -> GTokenRule :
  val tokens = Vector<GToken>()
  add(tokens, GListStart())
  add-all(tokens, make-tokens(m, 0, p))
  add(tokens, GListEnd())
  GTokenRule(rule-id, 0, to-tuple(tokens), params) where :
    val rule-id = fresh-rule-id(m)
    val params = TokenRuleParams(100, NonAssociative, default-action, false)