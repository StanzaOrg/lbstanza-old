defpackage stz/earley-lang :
  import core
  import collections
  import stz/earley-eval-result
  import stz/earley-grammar

;============================================================
;=================== Pattern Definition =====================
;============================================================

public deftype Pattern
public defstruct SeqPat <: Pattern :
  patterns: Tuple<Pattern>
public defstruct ListPat <: Pattern :
  pattern: Pattern
public defstruct Repeat <: Pattern :
  pattern: Pattern
public defstruct Production <: Pattern :
  name: Symbol
public defstruct Prim <: Pattern :
  type: GPrimType
public defstruct Form <: Pattern
public defstruct Rest <: Pattern
public defstruct Binder <: Pattern :
  name: Symbol
  pattern: Pattern
public defstruct Keyword <: Pattern :
  value: Symbol
public defstruct ChoicePat <: Pattern :
  patterns: Tuple<Pattern>

;------------------------------------------------------------
;----------------------- Printer ----------------------------
;------------------------------------------------------------

defmethod print (o:OutputStream, p:Pattern) :
  match(p) :
    (p:SeqPat) :
      print(o, "%s" % [patterns(p)])
    (p:ListPat) :
      print(o, "(%_)" % [pattern(p)])
    (p:Repeat) :
      print(o, "%_ ..." % [pattern(p)])
    (p:Production) :
      print(o, "#%_" % [name(p)])
    (p:Prim) :
      print(o, "#%_" % [type(p)])
    (p:Form) :
      print(o, "_")
    (p:Rest) :
      print(o, "_ ...")
    (p:Binder) :
      print(o, "?%_ : %_" % [name(p), pattern(p)])
    (p:Keyword) :
      print(o, value(p))
    (p:ChoicePat) :
      print(o, "(%*)" % [join(patterns(p), " | ")])

;============================================================
;====================== Rule Definition =====================
;============================================================

public deftype SyntaxExp

public defstruct DefProductionExp <: SyntaxExp :
  name: Symbol

public defstruct DefRuleExp <: SyntaxExp :
  production: Symbol
  pattern: Pattern
  guard: Maybe<(? -> True|False)>
  action: ParsedResult -> ?
  priority: Int
  associativity: Associativity
  lazy?: True|False

;============================================================
;=================== Package Definition =====================
;============================================================

public defstruct SyntaxPackage :
  name: Symbol
  exps: Tuple<SyntaxExp>

;============================================================
;================= Parse Pattern ============================
;============================================================

;Parse the given form as a Pattern.
;Throws PatternParseError if the form does not represent a valid pattern.
public defn parse-pattern (input-form:List) -> Pattern :
  ;Remove all token information.
  val form = unwrap-all(input-form)

  ;Parse the given list as a list of patterns, and returns the
  ;list remaining after the parse ends.
  ;The choice | operator is not handled by this function
  ;and the parse ends when it encounters this.
  defn parse-pats (f:List) -> [List<Pattern>, List] :
    ;End of list or choice operator
    if empty?(f) or tagged-list?(f, `|) :
      [List(), f]
    ;Invalid pattern
    else if tagged-list?(f, `@...) or
            tagged-list?(f, `...) :
      throw(InvalidRepetitionOperator(head(f)))
    ;Binder
    else if tagged-list?(head(f), `@cap) :
      val name = ensure-cap-form(head(f))
      val [ps, rest] =
        if tagged-list?(tail(f), `:) : parse-pats(tailn(f,2))
        else : parse-pats(cons(`_, tail(f)))
      ensure-binder-pattern(name, ps)
      [cons(Binder(name, head(ps)), tail(ps)), rest]
    ;Escape
    else if tagged-list?(f, `~) :
      ensure-escape-value(tail(f))
      val item = form[1] as Symbol
      val [p, rest] = parse-pats(tailn(f,2))
      [cons(Keyword(item),p), rest]
    ;Repeat Splice
    else if tagged-list?(tail(f), `@...) :
      val p1 = ensure-splice-list(parse-single-pat(head(f)))
      val [p2, rest] = parse-pats(tailn(f,2))
      [cons(Repeat(p1), p2), rest]
    ;Repeat
    else if tagged-list?(tail(f), `...) :
      val p1 = parse-single-pat(head(f))
      val [p2, rest] = parse-pats(tailn(f,2))
      [cons(Repeat(p1), p2), rest]
    ;Otherwise
    else :
      val p1 = parse-single-pat(head(f))
      val [p2, rest] = parse-pats(tail(f))
      [cons(p1,p2), rest]

  ;Parse a single s-expression as a pattern.
  ;This s-expression is assumed to lie within a
  ;list pattern.
  defn parse-single-pat (form) -> Pattern :
    match(form) :
      (form:List) :
        val pats = parse-choice-pats(form)
        if length(pats) == 1 : ListPat(head(pats))
        else : ChoicePat(to-tuple(pats))
      (form:Symbol) :
        if form == `_ : Form()
        else if prefix?(form, "#") : Production(subsymbol(form,1))
        else : Keyword(form)
      (form) :
        fatal("Not yet handled.")

  ;Parse the given list as a list of choice patterns.
  ;Returned list is guaranteed to not be empty.
  defn parse-choice-pats (f:List) -> List<Pattern> :
    val [pats, rest] = parse-pats(f)
    val pat = make-seq(pats)
    if empty?(rest) :
      List(pat)
    else :
      fatal("Expected choice operator.") when not tagged-list?(rest, `|)
      cons(pat, parse-choice-pats(tail(rest)))

  ;Create a SeqPat object from the list of patterns
  ;unless the list has exactly length 1.
  defn make-seq (ps:List<Pattern>) -> Pattern :
    if length(ps) == 1 : head(ps)
    else : SeqPat(to-tuple(ps))

  ;Apply post-processing transformations to pattern.
  defn postprocess (pat:Pattern) :
    println("Analyzed Binders:")
    within indented() :
      do(println,analyze-binders(pat))
    lift-rests(simplify-repeat(pat))

  ;Launch!
  val pats = parse-choice-pats(form)
  postprocess $
    if length(pats) == 1 : head(pats)
    else : ChoicePat(to-tuple(pats))

;------------------------------------------------------------
;--------------------- Error Conditions ---------------------
;------------------------------------------------------------

;Throw InvalidBindingForm if given form does not have structure (@cap name).
;Returns 'name' otherwise.
defn ensure-cap-form (form:List) -> Symbol :
  if length(form) != 2 or form[1] is-not Symbol :
    throw(InvalidBindingForm(form))
  form[1]

;Throw MissingEscapedTerminal if form is empty.
defn ensure-escape-value (form:List) :
  throw(MissingEscapedTerminal()) when empty?(form)

;Throw InvalidSpliceRepeat if pattern 'p' is not a ListPat.
;Returns the wrapped pattern within the list if it is.
defn ensure-splice-list (p:Pattern) -> Pattern :
  match(p:ListPat) : pattern(p)
  else : throw(InvalidSpliceRepeat(p))

;Throw MissingBinderPattern if list of patterns 'ps' is empty.
defn ensure-binder-pattern (name:Symbol, ps:List<Pattern>) :
  throw(MissingBinderPattern(name)) when empty?(ps)

;------------------------------------------------------------
;-------------------- Small Utilities -----------------------
;------------------------------------------------------------

;Returns a new symbol with the first n characters of 'x' removed.
defn subsymbol (x:Symbol, n:Int) -> Symbol :
  to-symbol(to-string(x)[n to false])

;Returns true if the given form has structure (tag ...).
defn tagged-list? (form, tag:Symbol) -> True|False :
  match(form:List) :
    not empty?(form) and head(form) == tag

;============================================================
;================ Pattern Post-Processing ===================
;============================================================

;Return a new pattern with the following replacement performed.
;Repeat(?x:P) => ?x:Repeat(P)
defn simplify-repeat (p:Pattern) -> Pattern :
  match(map(simplify-repeat,p)) :
    (p:Repeat) :
      match(pattern(p)) :
        (b:Binder) : Binder(name(b), Repeat(pattern(b)))
        (pat) : p
    (p) : p

;Return a new pattern with the following replacement performed.
;(a b c _ ...) => (a b c R)
defn lift-rests (p:Pattern) -> Pattern :
  defn lift (p:Pattern, last-in-list?:True|False) -> Pattern :
    match(p) :
      (p:SeqPat) :
        val n = length(patterns(p))
        val patterns* = to-tuple $
          for (p in patterns(p), i in 0 to false) seq :
            lift(p, last-in-list? and i == n - 1)
        SeqPat(patterns*)
      (p:ListPat) :
        ListPat(lift(pattern(p), true))
      (p0:Repeat) :
        val p = map(lift{_, false}, p0) as Repeat
        match(pattern(p)) :
          (pat:Form) : Rest()
          (pat) : p
      (p) :
        map(lift{_, last-in-list?}, p)
  lift(p, true)

defn map (f:Pattern -> Pattern, p:Pattern) -> Pattern :
  match(p) :
    (p:SeqPat) : SeqPat(map(f,patterns(p)))
    (p:ListPat) : ListPat(f(pattern(p)))
    (p:Repeat) : Repeat(f(pattern(p)))
    (p:Production) : p
    (p:Prim) : p
    (p:Form) : p
    (p:Rest) : p
    (p:Binder) : Binder(name(p), f(pattern(p)))
    (p:Keyword) : p
    (p:ChoicePat) : ChoicePat(map(f,patterns(p)))

;============================================================
;==================== Parse Errors ==========================
;============================================================

deftype PatternParseError <: Exception

defstruct InvalidRepetitionOperator <: PatternParseError :
  operator: Symbol

defmethod print (o:OutputStream, e:InvalidRepetitionOperator) :
  val msg = "Invalid position for repetition operator '%~'. \
             Repetition operator should follow a pattern."
  print(o, msg % [operator(e)])

defstruct InvalidBindingForm <: PatternParseError :
  form: List

defmethod print (o:OutputStream, e:InvalidBindingForm) :
  val msg = "Invalid syntax for binder form: %~. Binder should \
             have form (@cap binder-name)."
  print(o, msg % [form(e)])

defstruct MissingEscapedTerminal <: PatternParseError

defmethod print (o:OutputStream, e:MissingEscapedTerminal) :
  print(o, "Expected an escaped terminal here, but reached end of list.")

defstruct InvalidSpliceRepeat <: PatternParseError :
  pattern: Pattern

defmethod print (o:OutputStream, e:InvalidSpliceRepeat) :
  val msg = "The splice repeat operator @... requires a list pattern, \
             but found %_."
  print(o, msg % [pattern(e)])

defstruct MissingBinderPattern <: PatternParseError :
  name: Symbol

defmethod print (o:OutputStream, e:MissingBinderPattern) :
  val msg = "No binding pattern provided for pattern binder %~."
  print(o, msg % [name(e)])

;============================================================
;===================== Binder Analysis ======================
;============================================================

defstruct AnalyzedBinder :
  name:Symbol
  pos:BinderPos

deftype BinderPos
defmulti index (p:BinderPos) -> Int
defstruct LeafPos <: BinderPos :
  index: Int with: (as-method => true)
defstruct RepeatPos <: BinderPos :
  index: Int with: (as-method => true)
  pos: BinderPos
defstruct ChoicePos <: BinderPos :
  index: Int with: (as-method => true)
  choices: Tuple<BinderPos|False>

defmethod print (o:OutputStream, b:AnalyzedBinder) :
  print(o, "AnalyzedBinder(%_,%_)" % [name(b), indented-list([pos(b)])])

defmethod print (o:OutputStream, p:BinderPos) :
  match(p) :
    (p:LeafPos) :
      print(o, "LeafPos(%_)" % [index(p)])
    (p:RepeatPos) :
      print(o, "RepeatPos(%_,%_)" % [index(p), indented-list([pos(p)])])
    (p:ChoicePos) :
      val entries = for (c in choices(p), i in 0 to false) seq? :
        match(c:BinderPos) : One(i => c)
        else : None()
      print(o, "ChoicePos(%_,%_)" % [index(p), indented-list(entries)])

defn indented-list (xs:Seqable) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, xs)

defn analyze-binders (input-pattern:Pattern) -> Tuple<AnalyzedBinder> :
  defn scan (return:(Symbol, BinderPos) -> ?, p:Pattern) :
    val index = to-seq(0 to false)
    let loop (p:Pattern = p) :
      match(p) :
        (p:SeqPat) :
          do(loop, patterns(p))
        (p:ListPat) :
          next(index) ;ListStart
          loop(pattern(p))
          next(index) ;ListEnd
        (p:Repeat) :
          val i = next(index)
          within (name, pos) = scan(pattern(p)) :
            return(name, RepeatPos(i, pos))
        (p:Binder) :
          return(name(p), LeafPos(next(index)))
        (p:ChoicePat) :
          val i = next(index)
          val pos-table = HashTable-init<Symbol,Vector<KeyValue<Int,BinderPos>>>(
                            Vector<KeyValue<Int,BinderPos>>{})
          for (c in patterns(p), i in 0 to false) do :
            within (name, pos) = scan(c) :
              add(pos-table[name], i => pos)
          for entry in pos-table do :
            val name = key(entry)
            val choices = to-tuple(length(patterns(p)), value(entry))
            return(name, ChoicePos(i, choices))
        (p:Production|Prim|Form|Keyword|Rest) :
          next(index)
  val binders = Vector<AnalyzedBinder>()
  within (name, pos) = scan(input-pattern) :
    add(binders, AnalyzedBinder(name,pos))
  to-tuple(binders)

;------------------------------------------------------------
;--------------- Utility: Dense Array -----------------------
;------------------------------------------------------------
defn to-tuple<?T> (len:Int, xs:Seqable<KeyValue<Int,?T>>) -> Tuple<T|False> :
  val array = Array<T|False>(len, false)
  for x in xs do :
    array[key(x)] = value(x)
  to-tuple(array)

;============================================================
;==================== Making GRules =========================
;============================================================

public defn make-rules (p:SyntaxPackage, starting-pattern:Pattern) :
  val m = RuleMaker()
  for e in filter-by<DefProductionExp>(exps(p)) do :
    add(m, make-def(m,e))
  for e in filter-by<DefRuleExp>(exps(p)) do :
    add(m, make-rule(m,e))
  add(m, GDefProduction(0, `Start))
  add(m, make-starting-rule(m, starting-pattern))
  grules(m)

;============================================================
;===================== Rule Maker ===========================
;============================================================

deftype RuleMaker

;Return a new identifier to use for productions.
defmulti fresh-prod-id (m:RuleMaker) -> Int

;Return a new identifier to use for rules.
defmulti fresh-rule-id (m:RuleMaker) -> Int

;Retrieve the GProduction corresponding to production 'p'.
defmulti production-id (m:RuleMaker, production:Symbol) -> Int

;Create a new production with the same name as the given 'prod-id'.
defmulti clone-production (m:RuleMaker, prod-id:Int) -> Int

;Add newly created rule
defmulti add (m:RuleMaker, rule:GRule) -> False

;Define a production
defmulti add (m:RuleMaker, def:GDefProduction) -> False

;Return rules
defmulti grules (m:RuleMaker) -> GRules

;------------------------------------------------------------
;--------------- Rule Maker Implementation ------------------
;------------------------------------------------------------

defn RuleMaker () :
  val prod-counter = to-seq(1 to false)
  val rule-counter = to-seq(0 to false)
  val rules = Vector<GRule>()
  val production-ids = HashTable<Symbol,Int>()
  val production-table = IntTable<GDefProduction>()

  new RuleMaker :
    defmethod fresh-prod-id (this) :
      next(prod-counter)
    defmethod fresh-rule-id (this) :
      next(rule-counter)
    defmethod production-id (this, production:Symbol) :
      production-ids[production]
    defmethod clone-production (this, id:Int) :
      val id* = fresh-prod-id(this)
      val def = production-table[id]
      production-table[id*] = GDefProduction(id*, symbol-join([name(def) "*"]))
      id*
    defmethod add (this, rule:GRule) :
      add(rules, rule)
    defmethod add (this, def:GDefProduction) :
      production-table[id(def)] = def
      production-ids[name(def)] = id(def)
    defmethod grules (this) :
      GRules(
        to-tuple(values(production-table)),
        to-tuple(rules))

;============================================================
;=========== Utilities for Conversion to GRule ==============
;============================================================

;Create the definition for the given production.
defn make-def (m:RuleMaker, exp:DefProductionExp) -> GDefProduction :
  val prod-id = fresh-prod-id(m)
  GDefProduction(prod-id, name(exp))

;Create an appropriate rule for the given rule expression.
defn make-rule (m:RuleMaker, exp:DefRuleExp) -> GRule :
  val rule-id = fresh-rule-id(m)
  val prod-id = production-id(m, production(exp))
  val tokens = make-tokens(m, prod-id, pattern(exp))
  if empty?(guard(exp)) :
    val params = TokenRuleParams(priority(exp), associativity(exp), default-action, lazy?(exp))
    GTokenRule(rule-id, prod-id, tokens, params)
  else :
    val terminal = tokens[0] as GTerminal
    val matcher = value!(guard(exp))
    GMatcherRule(rule-id, prod-id, terminal, matcher, default-action, priority(exp))

;Convert the given pattern into tuple of GToken for creating GRule.
defn make-tokens (m:RuleMaker, prod-id:Int, p:Pattern) -> Tuple<GToken> :
  val tokens = Vector<GToken>()
  let loop (p:Pattern = p) :
    match(p) :
      (p:SeqPat) :
        do(loop, patterns(p))
      (p:ListPat) :
        add(tokens, GListStart())
        loop(pattern(p))
        add(tokens, GListEnd())
      (p:Repeat) :
        add(tokens, make-repeat(m, prod-id, pattern(p)))
      (p:ChoicePat) :
        add(tokens, make-choice(m, prod-id, patterns(p)))
      (p:Production) :
        val id = production-id(m, name(p))
        add(tokens, GProduction(id))
      (p:Prim) :
        add(tokens, GPrimToken(type(p)))
      (p:Form) :
        add(tokens, GAny())
      (p:Rest) :
        add(tokens, GListRest())
      (p:Keyword) :
        add(tokens, GKeyword(value(p)))
      (p:Binder) :
        fatal("Binder should be removed by this stage.")
  to-tuple(tokens)

;Create a production for representing the choice between patterns 'ps'.
defn make-choice (m:RuleMaker, parent-prod-id:Int, patterns:Tuple<Pattern>) -> GProduction :
  val prod-id = clone-production(m, parent-prod-id)
  for pattern in patterns do :
    val rule = GTokenRule(rule-id, prod-id, tokens, params) where :
      val rule-id = fresh-rule-id(m)
      val tokens = make-tokens(m, prod-id, pattern)
      val params = TokenRuleParams(100, NonAssociative, default-action, false)
    add(m, rule)
  GProduction(prod-id)

;Create a production for representing the repetition of the pattern 'p'.
defn make-repeat (m:RuleMaker, parent-prod-id:Int, p:Pattern) -> GProduction :
  val prod-id = clone-production(m, parent-prod-id)
  val rule1 = GTokenRule(rule-id, prod-id, to-tuple(tokens), params) where :
    val tokens = Vector<GToken>()
    add-all(tokens, make-tokens(m, prod-id, p))
    add(tokens, GProduction(prod-id))
    val rule-id = fresh-rule-id(m)
    val params = TokenRuleParams(100, NonAssociative, default-action, false)
  val rule2 = GTokenRule(rule-id, prod-id, [], params) where :
    val rule-id = fresh-rule-id(m)
    val params = TokenRuleParams(100, NonAssociative, default-action, false)
  add(m, rule1)
  add(m, rule2)
  GProduction(prod-id)

;Create the starting rule for the paser.
defn make-starting-rule (m:RuleMaker, p:Pattern) -> GTokenRule :
  val tokens = Vector<GToken>()
  add(tokens, GListStart())
  add-all(tokens, make-tokens(m, 0, p))
  add(tokens, GListEnd())
  GTokenRule(rule-id, 0, to-tuple(tokens), params) where :
    val rule-id = fresh-rule-id(m)
    val params = TokenRuleParams(100, NonAssociative, default-action, false)
