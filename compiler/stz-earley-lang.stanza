defpackage stz/earley-lang :
  import core
  import collections
  import stz/earley-eval-result
  import stz/earley-grammar
  import stz/earley-syntax-package
  import stz/earley-syntax-package-rules

;============================================================
;=================== Pattern Definition =====================
;============================================================

public deftype Pattern
public defstruct SeqPat <: Pattern :
  patterns: Tuple<Pattern>
public defstruct ListPat <: Pattern :
  pattern: Pattern
public defstruct Repeat <: Pattern :
  pattern: Pattern
public defstruct Production <: Pattern :
  name: Symbol
  id: Int|False with: (default => false, updater => sub-id)
public defstruct Prim <: Pattern :
  type: GPrimType
public defstruct Form <: Pattern
public defstruct Rest <: Pattern
public defstruct Binder <: Pattern :
  name: Symbol
  pattern: Pattern
public defstruct Keyword <: Pattern :
  value: Symbol
public defstruct ChoicePat <: Pattern :
  patterns: Tuple<Pattern>

;------------------------------------------------------------
;----------------------- Printer ----------------------------
;------------------------------------------------------------

defmethod print (o:OutputStream, p:Pattern) :
  match(p) :
    (p:SeqPat) :
      print(o, "%s" % [patterns(p)])
    (p:ListPat) :
      print(o, "(%_)" % [pattern(p)])
    (p:Repeat) :
      print(o, "%_ ..." % [pattern(p)])
    (p:Production) :
      print(o, "#%_" % [name(p)])
    (p:Prim) :
      print(o, "#%_" % [type(p)])
    (p:Form) :
      print(o, "_")
    (p:Rest) :
      print(o, "_ ...")
    (p:Binder) :
      print(o, "?%_ : %_" % [name(p), pattern(p)])
    (p:Keyword) :
      print(o, value(p))
    (p:ChoicePat) :
      print(o, "(%*)" % [join(patterns(p), " | ")])

;============================================================
;====================== Rule Definition =====================
;============================================================

public deftype SyntaxExp
public defmulti info (e:SyntaxExp) -> FileInfo|False

public defstruct DefProductionExp <: SyntaxExp :
  info: FileInfo|False with: (as-method => true)
  name: Symbol
  id: Int|False with: (default => false, updater => sub-id)
  public?: True|False

public defstruct DefKeywordsExp <: SyntaxExp :
  info: FileInfo|False with: (as-method => true)
  name: Symbol
  id: Int|False with: (default => false, updater => sub-id)
  public?: True|False

public defstruct DefProductionsExp <: SyntaxExp :
  info: FileInfo|False with: (as-method => true)
  clones: Tuple<DefCloneExp> with: (updater => sub-clones)
  
public defstruct DefCloneExp <: SyntaxExp :
  info: FileInfo|False with: (as-method => true)
  name: Symbol
  id: Int|False with: (default => false, updater => sub-id)
  prod: Symbol
  prod-id: Int|False with: (default => false, updater => sub-prod-id)
  public?: True|False

public defstruct DefKeywordRuleExp <: SyntaxExp :
  info: FileInfo|False with: (as-method => true)
  production: Symbol
  id: Int|False with: (default => false, updater => sub-id)
  pattern: Pattern with: (updater => sub-pattern)

public defstruct DefNotRuleExp <: SyntaxExp :
  info: FileInfo|False with: (as-method => true)
  production: Symbol
  id: Int|False with: (default => false, updater => sub-id)
  pattern: Pattern with: (updater => sub-pattern)

public defstruct ImportExp <: SyntaxExp :
  info: FileInfo|False with: (as-method => true)
  name: Symbol
  id: Int|False with: (default => false, updater => sub-id)
  package: Symbol

public defstruct DefRuleExp <: SyntaxExp :
  info: FileInfo|False with: (as-method => true)
  production: Symbol
  id: Int|False with: (default => false, updater => sub-id)
  pattern: Pattern with: (updater => sub-pattern)
  guard: Maybe<(? -> True|False)> with: (updater => sub-guard)
  action: ParsedBinders -> ?
  priority: Int
  associativity: Associativity
  lazy?: True|False

public defstruct StartRule :
  pattern: Pattern
  action: ParsedBinders -> ?

;============================================================
;====================== Actions =============================
;============================================================

public deftype ParsedBinders
public defmulti get (bs:ParsedBinders, name:Symbol) -> ?

;============================================================
;=================== Package Definition =====================
;============================================================

public defstruct SyntaxPackage :
  name: Symbol
  exps: Tuple<SyntaxExp> with: (updater => sub-exps)

val SYNTAX-PACKAGES = Vector<SyntaxPackage>()
public defn register-syntax-package (p:SyntaxPackage) :
  add(SYNTAX-PACKAGES, p)
public defn get-syntax-package (package-name:Symbol) -> SyntaxPackage|False :
  find({name(_) == package-name}, SYNTAX-PACKAGES)

var CURRENT-OVERLAYS:List<Symbol> = List()
defn resolve-overlays (os:List<Symbol>) :
  if empty?(os) : os
  else if head(os) == `current-overlays : append(CURRENT-OVERLAYS, tail(os))
  else : os

public defn syntax-match (base:Symbol,
                          overlays:List<Symbol>,
                          pattern-forms:Tuple<List>,
                          actions:Tuple<(ParsedBinders -> ?)>) -> ? :
  val all-packages = for name in unique(cons(base, resolve-overlays(overlays))) map :
    get-syntax-package(name) as SyntaxPackage
  val package-tables = new SyntaxPackageTables :
    defmethod get (this, name:Symbol) : get-syntax-package(name)
  match(analyze(head(all-packages), to-tuple(tail(all-packages)), package-tables)) :
    (p:AnalyzedSyntaxPackage) :
      val patterns = for form in pattern-forms map :
        match(resolve(p, parse-pattern(form), false)) :
          (p:Pattern) : p
          (e:PatternResolutionErrors) : throw(e)
      val start-rules = to-tuple $ seq(StartRule, patterns, actions)
      val grules = make-rules(p, start-rules)
      println(grules)
    (e:Exception) :
      throw(e)
  

;============================================================
;================= Parse Pattern ============================
;============================================================

;Parse the given form as a Pattern.
;Throws PatternParseError if the form does not represent a valid pattern.
public defn parse-pattern (input-form:List) -> Pattern :
  ;Remove all token information.
  val form = unwrap-all(input-form)

  ;Parse the given list as a list of patterns, and returns the
  ;list remaining after the parse ends.
  ;The choice | operator is not handled by this function
  ;and the parse ends when it encounters this.
  defn parse-pats (f:List) -> [List<Pattern>, List] :
    ;End of list or choice operator
    if empty?(f) or tagged-list?(f, `|) :
      [List(), f]
    ;Invalid pattern
    else if tagged-list?(f, `@...) or
            tagged-list?(f, `...) :
      throw(InvalidRepetitionOperator(head(f)))
    ;Binder
    else if tagged-list?(head(f), `@cap) :
      val name = ensure-cap-form(head(f))
      val [ps, rest] =
        if tagged-list?(tail(f), `:) : parse-pats(tailn(f,2))
        else : parse-pats(cons(`_, tail(f)))
      ensure-binder-pattern(name, ps)
      [cons(Binder(name, head(ps)), tail(ps)), rest]
    ;Escape
    else if tagged-list?(f, `~) :
      ensure-escape-value(tail(f))
      val item = form[1] as Symbol
      val [p, rest] = parse-pats(tailn(f,2))
      [cons(Keyword(item),p), rest]
    ;Repeat Splice
    else if tagged-list?(tail(f), `@...) :
      val p1 = ensure-splice-list(parse-single-pat(head(f)))
      val [p2, rest] = parse-pats(tailn(f,2))
      [cons(Repeat(p1), p2), rest]
    ;Repeat
    else if tagged-list?(tail(f), `...) :
      val p1 = parse-single-pat(head(f))
      val [p2, rest] = parse-pats(tailn(f,2))
      [cons(Repeat(p1), p2), rest]
    ;Otherwise
    else :
      val p1 = parse-single-pat(head(f))
      val [p2, rest] = parse-pats(tail(f))
      [cons(p1,p2), rest]

  ;Parse a single s-expression as a pattern.
  ;This s-expression is assumed to lie within a
  ;list pattern.
  defn parse-single-pat (form) -> Pattern :
    match(form) :
      (form:List) :
        val pats = parse-choice-pats(form)
        if length(pats) == 1 : ListPat(head(pats))
        else : ChoicePat(to-tuple(pats))
      (form:Symbol) :
        if form == `_ : Form()
        else if prefix?(form, "#") : Production(subsymbol(form,1))
        else : Keyword(form)
      (form) :
        fatal("Not yet handled.")

  ;Parse the given list as a list of choice patterns.
  ;Returned list is guaranteed to not be empty.
  defn parse-choice-pats (f:List) -> List<Pattern> :
    val [pats, rest] = parse-pats(f)
    val pat = make-seq(pats)
    if empty?(rest) :
      List(pat)
    else :
      fatal("Expected choice operator.") when not tagged-list?(rest, `|)
      cons(pat, parse-choice-pats(tail(rest)))

  ;Create a SeqPat object from the list of patterns
  ;unless the list has exactly length 1.
  defn make-seq (ps:List<Pattern>) -> Pattern :
    if length(ps) == 1 : head(ps)
    else : SeqPat(to-tuple(ps))

  ;Apply post-processing transformations to pattern.
  defn postprocess (pat:Pattern) :
    lift-rests(simplify-repeat(pat))

  ;Launch!
  val pats = parse-choice-pats(form)
  postprocess $
    if length(pats) == 1 : head(pats)
    else : ChoicePat(to-tuple(pats))

;------------------------------------------------------------
;--------------------- Error Conditions ---------------------
;------------------------------------------------------------

;Throw InvalidBindingForm if given form does not have structure (@cap name).
;Returns 'name' otherwise.
defn ensure-cap-form (form:List) -> Symbol :
  if length(form) != 2 or form[1] is-not Symbol :
    throw(InvalidBindingForm(form))
  form[1]

;Throw MissingEscapedTerminal if form is empty.
defn ensure-escape-value (form:List) :
  throw(MissingEscapedTerminal()) when empty?(form)

;Throw InvalidSpliceRepeat if pattern 'p' is not a ListPat.
;Returns the wrapped pattern within the list if it is.
defn ensure-splice-list (p:Pattern) -> Pattern :
  match(p:ListPat) : pattern(p)
  else : throw(InvalidSpliceRepeat(p))

;Throw MissingBinderPattern if list of patterns 'ps' is empty.
defn ensure-binder-pattern (name:Symbol, ps:List<Pattern>) :
  throw(MissingBinderPattern(name)) when empty?(ps)

;------------------------------------------------------------
;-------------------- Small Utilities -----------------------
;------------------------------------------------------------

;Returns a new symbol with the first n characters of 'x' removed.
defn subsymbol (x:Symbol, n:Int) -> Symbol :
  to-symbol(to-string(x)[n to false])

;Returns true if the given form has structure (tag ...).
defn tagged-list? (form, tag:Symbol) -> True|False :
  match(form:List) :
    not empty?(form) and head(form) == tag

;============================================================
;================ Pattern Post-Processing ===================
;============================================================

;Return a new pattern with the following replacement performed.
;Repeat(?x:P) => ?x:Repeat(P)
defn simplify-repeat (p:Pattern) -> Pattern :
  match(map(simplify-repeat,p)) :
    (p:Repeat) :
      match(pattern(p)) :
        (b:Binder) : Binder(name(b), Repeat(pattern(b)))
        (pat) : p
    (p) : p

;Return a new pattern with the following replacement performed.
;(a b c _ ...) => (a b c R)
defn lift-rests (p:Pattern) -> Pattern :
  defn lift (p:Pattern, last-in-list?:True|False) -> Pattern :
    match(p) :
      (p:SeqPat) :
        val n = length(patterns(p))
        val patterns* = to-tuple $
          for (p in patterns(p), i in 0 to false) seq :
            lift(p, last-in-list? and i == n - 1)
        SeqPat(patterns*)
      (p:ListPat) :
        ListPat(lift(pattern(p), true))
      (p0:Repeat) :
        val p = map(lift{_, false}, p0) as Repeat
        match(pattern(p)) :
          (pat:Form) : Rest()
          (pat) : p
      (p) :
        map(lift{_, last-in-list?}, p)
  lift(p, true)

public defn map (f:Pattern -> Pattern, p:Pattern) -> Pattern :
  match(p) :
    (p:SeqPat) : SeqPat(map(f,patterns(p)))
    (p:ListPat) : ListPat(f(pattern(p)))
    (p:Repeat) : Repeat(f(pattern(p)))
    (p:Production) : p
    (p:Prim) : p
    (p:Form) : p
    (p:Rest) : p
    (p:Binder) : Binder(name(p), f(pattern(p)))
    (p:Keyword) : p
    (p:ChoicePat) : ChoicePat(map(f,patterns(p)))

public defn do (f:Pattern -> ?, p:Pattern) -> False :
  defn g (p:Pattern) : p
  map(g,p)
  false

;============================================================
;==================== Parse Errors ==========================
;============================================================

deftype PatternParseError <: Exception

defstruct InvalidRepetitionOperator <: PatternParseError :
  operator: Symbol

defmethod print (o:OutputStream, e:InvalidRepetitionOperator) :
  val msg = "Invalid position for repetition operator '%~'. \
             Repetition operator should follow a pattern."
  print(o, msg % [operator(e)])

defstruct InvalidBindingForm <: PatternParseError :
  form: List

defmethod print (o:OutputStream, e:InvalidBindingForm) :
  val msg = "Invalid syntax for binder form: %~. Binder should \
             have form (@cap binder-name)."
  print(o, msg % [form(e)])

defstruct MissingEscapedTerminal <: PatternParseError

defmethod print (o:OutputStream, e:MissingEscapedTerminal) :
  print(o, "Expected an escaped terminal here, but reached end of list.")

defstruct InvalidSpliceRepeat <: PatternParseError :
  pattern: Pattern

defmethod print (o:OutputStream, e:InvalidSpliceRepeat) :
  val msg = "The splice repeat operator @... requires a list pattern, \
             but found %_."
  print(o, msg % [pattern(e)])

defstruct MissingBinderPattern <: PatternParseError :
  name: Symbol

defmethod print (o:OutputStream, e:MissingBinderPattern) :
  val msg = "No binding pattern provided for pattern binder %~."
  print(o, msg % [name(e)])