defpackage stz/reg-alloc-flow-order :
  import core
  import collections
  import stz/reg-alloc-block

;============================================================
;===================== Flow Order ===========================
;============================================================

;Compute flow order of blocks and return all stages.
public defn flow-order (blocks:Vector<Block>) -> Vector<FlowStage> :
  println("Flow Order")
  do(println, blocks)
  ;Accumulate all detected paths.
  ;Branching paths appear before main paths.
  val paths = Vector<Path>()

  ;Track which blocks have been visited, and which path they
  ;are visited on.
  val path-indices = Array<Int|False>(length(blocks), false)

  ;Generate path indices.
  val path-index-counter = to-seq(0 to false)

  ;Create a new path and add it to the accumulator.
  defn add-new-path (b:Int) -> False :
    add(paths, visit(blocks[b], next(path-index-counter)))

  ;Visit the given block as part of the given path.
  defn visit (b:Block, path-index:Int) -> Path :
    ;Case: Never visited this block before.
    if path-indices[index(b)] is False :
    
      ;Mark the block as visited.
      path-indices[index(b)] = path-index
      
      ;If there are no more successors, then path has ended.
      if empty?(succs(b)) :
        EndingPath(List(index(b)))
        
      ;Otherwise, visit the successors.
      else :

        ;Select a good successor to follow. Prefer backward edges
        ;if possible.
        val good-succ = let :
          val s = find({_ < index(b)}, succs(b))
          if s is False : succs(b)[0]
          else : s as Int

        ;Visit the good successor as part of the same path.
        val result = add(index(b), visit(blocks[good-succ], path-index))
      
        ;Visit branches as part of different paths.
        for s in succs(b) do :
          add-new-path(s) when s != good-succ            

        ;Return the result
        result

    ;Case: Visited this block before as part of the same path.
    else if path-indices[index(b)] == path-index :
      LoopingPath(List(), index(b))
      
    ;Case: Visited this block before as part of a different path.
    else :
      JoiningPath(List(), index(b))

  ;Launch!
  add-new-path(0)
  flow-stages(paths)

;------------------------------------------------------------
;------------------- Creation of Stages ---------------------
;------------------------------------------------------------

;Compute the flow stages given the detected paths.
defn flow-stages (paths:Vector<Path>) -> Vector<FlowStage> :

  ;Accumulate stages into a vector.
  val stages = Vector<FlowStage>()

  ;Helpers for creating stages.
  defn make-stage (type:StageType, b:Int) : add(stages, FlowStage(type, b))
  defn make-stages (type:StageType, bs:List<Int>) : do(make-stage{type, _}, bs)

  ;Process paths in reverse order because branching paths
  ;appear first.
  for path in in-reverse(paths) do :
    match(path) :
      (path:EndingPath) :
        make-stages(ForwardStage, blocks(path))
      (path:LoopingPath) :
        val [start, loop] = separate(path)
        make-stages(ForwardStage, start)
        make-stage(HeaderStage, end(path))
        make-stages(BackwardStage, reverse(loop))
        make-stages(ForwardStage, loop)
      (path:JoiningPath) :
        make-stages(BackwardStage, reverse(blocks(path)))
        make-stages(ForwardStage, blocks(path))
        
  ;Return the created stages.
  stages

;------------------------------------------------------------
;---------------- Representation of Paths -------------------
;------------------------------------------------------------

;Represents one linear path through the block graph.
deftype Path

;A path that ends with no successors.
defstruct EndingPath <: Path :
  blocks:List<Int>
with:
  printer => true

;A path that ends with a loop.
;- end: A block that appears within 'blocks'.
defstruct LoopingPath <: Path :
  blocks:List<Int>
  end:Int
with:
  printer => true

;A path that ends with a join to another path.
;- end: A block that doesn't appear within 'blocks'.
defstruct JoiningPath <: Path :
  blocks:List<Int>
  end:Int
with:
  printer => true

;Separate a looping path into its start and its loop.
;The loop begins at the 'end' node.
defn separate (path:LoopingPath) -> [List<Int>, List<Int>] :
  let loop (parents:List<Int> = List()
            nodes:List<Int> = blocks(path)) :
    if head(nodes) == end(path) :
      [reverse(parents), nodes]
    else :
      val new-parents = cons(head(nodes), parents)
      loop(new-parents, tail(nodes))

;Add a new block to a path.
defn add (b:Int, path:Path) -> Path :
  match(path) :
    (path:EndingPath) :
      EndingPath(cons(b,blocks(path)))
    (path:LoopingPath) :
      LoopingPath(cons(b,blocks(path)), end(path))
    (path:JoiningPath) :
      JoiningPath(cons(b,blocks(path)), end(path))

;------------------------------------------------------------
;------------------- Order Type -----------------------------
;------------------------------------------------------------

;Represents one stage of the flow order.
public defstruct FlowStage :
  type:StageType
  block:Int
with:
  printer => true

;Represents the type of the flow stage.
public defenum StageType :
  ForwardStage
  BackwardStage
  HeaderStage