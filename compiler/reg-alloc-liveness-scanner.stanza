defpackage stz/reg-alloc-liveness-scanner :
  import core
  import collections
  import stz/reg-alloc-engine
  import stz/reg-alloc-ir

;Algorithm for computing variable liveness and usage information
;when instructions are processed in reverse order.
public deftype LivenessScanner

;Initialize the algorithm by scanning the output ports.
public defmulti scan-output-ports (s:LivenessScanner, ports:Seqable<Port>) -> False

;Scan the given program statement at the given index.
public defmulti scan-stmt (s:LivenessScanner, index:Int, stmt:ProgramStmt) -> False

;Retrieve the currently live variables.
;A variable is live if it is going to be used by one of the scanned
;statements.
public defmulti live-vars (s:LivenessScanner) -> Seqable<KeyValue<Int,Int>>

;Retrieve the next usage of a variable.
;Returns false if the variable is not live.
public defmulti next-usage (s:LivenessScanner, v:Int) -> Int|False

;Retrieve all the defined variables in this block.
public defmulti defs (s:LivenessScanner) -> Seqable<Int>

;Create the liveness scanner.
public defn LivenessScanner () -> LivenessScanner :
  val defs = IntSet()
  val uses = IntTable<Int>()

  new LivenessScanner :
    defmethod scan-output-ports (this, ports:Seqable<Port>) :
      for p in ports do :
        uses[id(p)] = usage-position(p)    
    
    defmethod scan-stmt (this, index:Int, stmt:ProgramStmt) :
      match(stmt:OperationStmt) :
        ;Mark the results as defined.
        ;If they were expecting to be used, that is now satisfied.
        for v in results(stmt) do :
          add(defs, v)
          remove(uses, v)
        
        ;Mark the arguments as now expecting to be used.
        for v in args(stmt) do :
          uses[v] = index

    defmethod live-vars (this) :
      uses

    defmethod next-usage (this, v:Int) :
      get?(uses, v)
          
    defmethod defs (this) :
      defs