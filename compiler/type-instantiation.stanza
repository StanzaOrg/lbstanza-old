defpackage stz/type-instantiation :
  import core
  import collections
  import stz/types
  import stz/type-instfns
  import stz/type-utils
  import stz/type-fargs
  import stz/type-fnarities

;<doc>=======================================================
;========================== Doc =============================
;============================================================

HiStanza:

  Given a bunch of functions (TFunction):
  
  1) Which ones can be called with a set of arguments (Tuple<FArg>)?
    a. Provide an accurate version.
    b. And a forced version.
  
  2) Which ones can be used for an expected type (Type)?

LoStanza:

  Given a bunch of functions (TLSFunction):

  1) Which ones can be called with a set of arguments (Tuple<LSFArg>)?
    a. Provide an accurate version.
    b. And a forced version.

  2) Which ones can be referenced by the addr(...) expression?

;============================================================
;=======================================================<doc>

;============================================================
;=================== Instantiator Callbacks =================
;============================================================

;Implement the necessary operations for creating new equations
;and equation variables for the instantiation process.
public deftype Instantiator

;Create new capture variables.
public defmulti fresh-capvars (inst:Instantiator, n:Int) -> Tuple<TUVar>

;Return the identifier of the special Tuple type.
public defmulti tuple-id (inst:Instantiator) -> Int

;Create a new capture equation.
public defmulti capture-right (inst:Instantiator, capvars:Tuple<TUVar>, xs:Tuple<Type>, ys:Tuple<Type>) -> False
public defmulti capture-left (inst:Instantiator, capvars:Tuple<TUVar>, x:Type, y:Type) -> False
public defmulti capture-right (inst:Instantiator, capvars:Tuple<TUVar>, xs:Tuple<LSType>, ys:Tuple<LSType>) -> False

;Perform a delayed substitution operation on the given type.
public defmulti substitute (inst:Instantiator, t:Type|LSType, env:Tuple<KeyValue<Int,Type>>) -> Type|LSType

;============================================================
;======================= Drivers ============================
;============================================================

;Compute the instantiations of the given functions with the given
;arguments.
public defn instantiations (instantiator:Instantiator,
                            functions:Tuple<KeyValue<Int,TFunction>>,
                            targs:Tuple<Type>,
                            args:Tuple<FArg>) -> Tuple<InstFn> :
  ;Compute all appropriate instantiation patterns.
  val instfns = Vector<InstFn>()
  for entry in functions do :
    val pat = instantiate(value(entry), length(targs), args)
    match(pat:ArgPattern) :
      add(instfns, make-instfn(instantiator, key(entry), value(entry), pat, targs, args))
  to-tuple(instfns)

;Compute the instantiations of the given functions with the given
;arguments.
public defn instantiations (instantiator:Instantiator,
                            functions:Tuple<KeyValue<Int,TLSFunction>>,
                            targs:Tuple<Type>,
                            args:Tuple<FArg>) -> Tuple<LSInstFn> :
  ;Compute all appropriate instantiation patterns.
  val instfns = Vector<LSInstFn>()
  for entry in functions do :
    val pat = instantiate(value(entry), length(targs), args)
    match(pat:ArgPattern) :
      add(instfns, make-lsinstfn(instantiator, key(entry), value(entry), pat, targs, args))
  to-tuple(instfns)

;;Forcefully compute a single instantiation.
;public defn force-instantiation (instantiator:Instantiator,
;                                 functions:Tuple<KeyValue<Int,TFunction>>,
;                                 targs:Tuple<Type>,
;                                 args:Tuple<FArg>) -> InstFn|False :
;  if length(functions) == 1:
;    val entry = functions[0]
;    val pat = force-instantiate(value(entry), length(targs), args)
;    match(pat:ArgPattern) :
;      make-instfn(instantiator, key(entry), value(entry), pat, targs, args)


;;Forcefully compute a single instantiation.
;public defn force-instantiation (instantiator:Instantiator,
;                                 functions:Tuple<KeyValue<Int,TLSFunction>>,
;                                 targs:Tuple<Type>,
;                                 args:Tuple<FArg>) -> LSInstFn|False :
;  if length(functions) == 1:
;    val entry = functions[0]
;    val pat = force-instantiate(value(entry), length(targs), args)
;    match(pat:ArgPattern) :
;      make-lsinstfn(instantiator, key(entry), value(entry), pat, targs, args)

;Compute the instantiations of the given functions with the given
;expected type. Returns Blocked if 'expected' is not sufficiently
;resolved to instantiate the functions.
public defn instantiations (instantiator:Instantiator,
                            functions:Tuple<KeyValue<Int,TFunction>>,
                            expected:Type) -> Tuple<InstFn>|Blocked :

  ;Compute the unknown variables and arity specifiers.
  val block-vars = IntSet()
  val arity-specs = Vector<Int|AritySpecifier>()
  find-arities(expected, arity-specs, block-vars)

  ;Try instantiating all the functions using those arity specifiers.
  ;Return Blocked immediately if one of them could not be computed.
  label<Blocked|Tuple<InstFn>> return :

    ;Compute all instantiation patterns.
    val instpats = Vector<[KeyValue<Int,TFunction>,Tuple<ArgPattern>]>()
    for entry in functions do :
      val pats = instantiate(value(entry), arity-specs)
      if empty?(pats) :
        return(Blocked(to-list(block-vars)))
      else :
        add(instpats, [entry, value!(pats)])

    ;Create the instantiated functions.
    to-tuple $ for [entry, pats] in instpats seq-cat :
      for pat in pats seq :
        make-instfn(instantiator, key(entry), value(entry), pat, expected)

;Scan through the given type for desired arities.
defn find-arities (t:Type|LSType,
                   specs:Vector<Int|AritySpecifier>,
                   blocks:IntSet) -> False :
  let loop (t:Type|LSType = t) :
    match(t) :
      (t:TUVar) :
        add(blocks, n(t))
        add(specs, UnknownArity)
      (t:UVarT) :
        add(blocks, n(t))
        add(specs, UnknownArity)
      (t:TAnd|TOr) : do(loop{_ as Type}, t)
      (t:TGradual|TTop) : add(specs, AllArities)
      (t:TArrow) : add(specs, length(a1(t)))
      (t:RefT) : loop(type(t))
      (t) : false

;Compute the instantiations of the given LoStanza functions
;appropriate for use with the 'addr(...)' expression. No optional
;arguments, type arguments, or keyword arguments, or variable-arity
;arguments allowed.
public defn addr-instantiations (instantiator:Instantiator,
                                 functions:Tuple<KeyValue<Int,TLSFunction>>) -> Tuple<LSInstFn> :
  val appropriate-functions = filter(use-in-addr-context?{value(_)}, functions)
  to-tuple $ for entry in appropriate-functions seq :
    val fid = key(entry)
    val f = value(entry)
    val arities = arities(f)
    val pat = ArgPattern(min-arity(arities), to-tuple(positional(arities)))
    val fnt = pattern-type(f, pat, tuple-id(instantiator))
    LSInstFn(fid, pat, [], fnt)

;Compute the instantiations of the given multis. Used to help
;select the multi that a defmethod is attached to.
public defn multi-instantiations (instantiator:Instantiator,
                                  functions:Tuple<KeyValue<Int,TFunction>>,
                                  targs:Tuple<TVar>,
                                  args:Tuple<FArg>) -> Tuple<InstFn> :
  ;Compute all appropriate instantiation patterns.
  val instfns = Vector<InstFn>()
  for entry in functions do :
    val pat = instantiate-multi(value(entry), length(targs), args)
    match(pat:ArgPattern) :
      add(instfns, make-instfn(instantiator, key(entry), value(entry), pat, targs, args))
  to-tuple(instfns)

;============================================================
;============== Appropriate in Addr Context =================
;============================================================

;Return true if the given function can be referenced from
;an addr(...) context.
defn use-in-addr-context? (f:TLSFunction) -> True|False :
  val arities = arities(f)
  targ-arity(arities) == 0 and
  num-optional(arities) == 0 and
  empty?(keywords(arities)) and
  vararg(arities) is False

;============================================================
;=========== Pattern Instantiation in Call Context ==========
;============================================================

;Instantiate a function to be called with the given arguments.
defn instantiate (func:TFunction|TLSFunction, tarity:Int, args:Tuple<FArg>) -> ArgPattern|False :
  ;Compute the arities of the function.
  val arities = arities(func)

  ;Compute number of positional arguments, and keyword arguments provided.
  val num-pos-args = count({_ is PositionalArg}, args)
  val keywords = to-tuple $ seq(name, filter-by<KeywordArg>(args))

  ;If we satisfy the arity requirements, then go ahead with the pattern.
  if satisfies-arity?(arities, tarity, num-pos-args, keywords) :
    arg-pattern(arities, a1(func), args)

;============================================================
;======== Forced Pattern Instantiation In Call Context ======
;============================================================

;;Force a pattern to be instantiated.
;defn force-instantiate (func:TFunction|TLSFunction, tarity:Int, args:Tuple<FArg>) -> ArgPattern|False :
;  if length(targs(func)) == tarity :
;    ArgPattern $ for arg in args map :
;      InstArg(false, BadArg)

;============================================================
;========= Pattern Instantiation in Exp Context =============
;============================================================

;Instantiate a function with the given arities.
;Returns None() if there is insufficient information to compute instantiations.
;Otherwise returns the complete set of instantiations.
defn instantiate (func:TFunction|TLSFunction, arity-specs:Collection<Int|AritySpecifier>) -> Maybe<Tuple<ArgPattern>> :
  ;Compute function arities.
  val arities = arities(func)

  ;Instantiate all the reasonable arities.
  val inst-arities = instantiate-arities(arities, arity-specs)

  ;Return none if there is insufficient information.
  if empty?(inst-arities)  :
    None()

  ;Otherwise, return the instantiated arities.
  else :
    One $ for num-args in value!(inst-arities) map :
      arg-pattern(arities, a1(func), num-args)

;============================================================
;========== Pattern Instantiation in Multi Context ==========
;============================================================

;Instantiate a function to be called with the given arguments.
defn instantiate-multi (func:TFunction|TLSFunction, tarity:Int, args:Tuple<FArg>) -> ArgPattern|False :
  ;Compute the arities of both the multi and the method.
  val multi-arities = arities(func)
  val method-arities = arities(tarity, args)

  ;If signatures match, then instantiate the arguments.
  val pos-args = to-seq(positional(method-arities))
  if matching-signature?(multi-arities, method-arities) :
    val pat-args = for arg in a1(func) map :
      match(arg) :
        (arg:PositionalArg) :
          next(pos-args)          
        (arg:KeywordArg) :
          keywords(method-arities)[name(arg)]          
        (arg:VarArg) :
          ;Translate VarArg into a normal positional arg, so
          ;that types are not tuple-wrapped upon instantiation.
          val method-arg = vararg(method-arities) as VarArg<Int>
          PositionalArg<Int>(false, type(method-arg))
    ArgPattern(length(args), pat-args)

;============================================================
;============== Making an InstFn From Pattern ===============
;============================================================

;Create the InstFn given the instantiation pattern in
;a call context.
defn make-instfn (instantiator:Instantiator,
                  fid:Int, t:TFunction, pat:ArgPattern,
                  type-args:Tuple<Type>, fargs:Tuple<FArg<Type>>) -> InstFn :
  within (capvars, arrow) = make-instfn(instantiator, fid, t, pat, type-args) :
    capture-right(instantiator, capvars, map(type,fargs), a1(arrow))

;Create the InstFn given the instantiation pattern in
;an expression context.
defn make-instfn (instantiator:Instantiator,
                  fid:Int, t:TFunction, pat:ArgPattern,
                  expected:Type) -> InstFn :
  within (capvars, arrow) = make-instfn(instantiator, fid, t, pat, []) :
    capture-left(instantiator, capvars, arrow, expected)

;Make an InstFn out of the given parameters.
;Relies upon capture, meant to generate the equation for the given
;capture variables and instantiated arrow type.
defn make-instfn (capture:(Tuple<TUVar>, TArrow) -> False
                  instantiator:Instantiator,
                  fid:Int, t:TFunction, pat:ArgPattern,
                  type-args:Tuple<Type>) -> InstFn :

  ;If it's a non-polymorphic function, then no capture and substitution
  ;is necessary.
  if empty?(targs(t)) and empty?(cargs(t)) :

    ;Get the instantiated arrow type.
    val arrow = pattern-type(t, pat, tuple-id(instantiator))

    ;Create the InstFn
    InstFn(fid, pat, [], arrow)

  else :

    ;Create the capture vars.
    val capvars = fresh-capvars(instantiator, length(cargs(t)))

    ;Substitute the given types to get the actual argument types.
    val cap-env = to-tuple $ cat(seq(KeyValue, targs(t), type-args),
                                 seq({_ => n(_)}, cargs(t), capvars))
    val sub-env = to-tuple $ cat(seq(KeyValue, targs(t), type-args),
                                 seq(KeyValue, cargs(t), capvars))

    ;Get the instantiated arrow type.
    val arrow = pattern-type(t, pat, tuple-id(instantiator))
    val new-a2 = substitute(instantiator, a2(arrow), sub-env) as Type
    val cap-arrow = TArrow(sub-caps(a1(arrow), cap-env), new-a2)
    val sub-arrow = TArrow(sub(map(uncap,a1(arrow)), sub-env), new-a2)

    ;Capture the variables if there are any.
    capture(capvars, cap-arrow) when not empty?(capvars)      

    ;Create the InstFn.
    InstFn(fid, pat, capvars, sub-arrow)  

;============================================================
;=========== Making an LSInstFn From Pattern ================
;============================================================

;Create the LSInstFn given the instantiation pattern in a call context.
defn make-lsinstfn (instantiator:Instantiator,
                    fid:Int, t:TLSFunction, pat:ArgPattern,
                    type-args:Tuple<Type>, fargs:Tuple<FArg<LSType>>) -> LSInstFn :
  within (capvars, fnt) = make-lsinstfn(instantiator, fid, t, pat, type-args) :
    capture-right(instantiator, capvars, map(type,fargs), a(fnt))

;Make an InstFn out of the given parameters.
;Relies upon capture, meant to generate the equation for the given
;capture variables and instantiated arrow type.
defn make-lsinstfn (capture:(Tuple<TUVar>, FnT) -> False,
                    instantiator:Instantiator,
                    fid:Int, t:TLSFunction, pat:ArgPattern,
                    type-args:Tuple<Type>) -> LSInstFn :

  ;If it's a non-polymorphic function, then no capture and substitution
  ;is necessary.
  if empty?(targs(t)) and empty?(cargs(t)) :

    ;Get the instantiated FnT type.
    val fnt = pattern-type(t, pat, tuple-id(instantiator))

    ;Create the LSInstFn
    LSInstFn(fid, pat, [], fnt)

  else :

    ;Create the capture vars.
    val capvars = fresh-capvars(instantiator, length(cargs(t)))

    ;Substitute the given types to get the actual argument types.
    val cap-env = to-tuple $ cat(seq(KeyValue, targs(t), type-args),
                                 seq({_ => n(_)}, cargs(t), capvars))
    val sub-env = to-tuple $ cat(seq(KeyValue, targs(t), type-args),
                                 seq(KeyValue, cargs(t), capvars))

    ;Get the instantiated FnT type.
    val fnt = pattern-type(t, pat, tuple-id(instantiator))
    val cap-fnt = FnT(sub-caps(a(fnt),cap-env), false, sub(b(fnt), sub-env))
    val new-a = sub(map(uncap,a(fnt)),sub-env)
    val new-b = substitute(instantiator, b(fnt), sub-env) as LSType
    val sub-fnt = FnT(new-a, false, new-b)

    ;Capture the variables if there are any.
    capture(capvars, cap-fnt) when not empty?(capvars)

    ;Create the InstFn.
    LSInstFn(fid, pat, capvars, sub-fnt)  

;============================================================
;===================== Pattern Utilities ====================
;============================================================

;Compute the arities of a function.
defn arities (func:TFunction|TLSFunction) -> FnArities :
  arities(length(targs(func)), a1(func))

;Return the instantiated arrow for the given instantiation.
defn pattern-type (t:TFunction, pat:ArgPattern, tuple-n:Int) -> TArrow :
  defn wrap-tuple (t:Type) : TOf(tuple-n, [t])
  val new-a1 = arg-types(wrap-tuple, pat, a1(t))
  TArrow(new-a1, a2(t))
  
;Return the instantiated FnT for the given instantiation.
defn pattern-type (t:TLSFunction, pat:ArgPattern, tuple-n:Int) -> FnT :
  defn wrap-tuple (t:LSType) -> RefT :
    fatal("Vararg type is not declared as Ref<T>") when t is-not RefT
    val reft = type(t as RefT)
    RefT(TOf(tuple-n, [reft]))
  val new-a1 = arg-types(wrap-tuple, pat, a1(t))
  FnT(new-a1, false, a2(t))

