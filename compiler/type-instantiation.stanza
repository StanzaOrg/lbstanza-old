defpackage stz/type-instantiation :
  import core
  import collections
  import stz/types
  import stz/type-instfns
  import stz/type-utils

;<doc>=======================================================
;========================== Doc =============================
;============================================================

HiStanza:

  Given a bunch of functions (TFunction):
  
  1) Which ones can be called with a set of arguments (Tuple<FArg>)?
    a. Provide an accurate version.
    b. And a forced version.
  
  2) Which ones can be used for an expected type (Type)?

LoStanza:

  Given a bunch of functions (TLSFunction):

  1) Which ones can be called with a set of arguments (Tuple<LSFArg>)?
    a. Provide an accurate version.
    b. And a forced version.

  2) Which ones can be referenced by the addr(...) expression?

;============================================================
;=======================================================<doc>

;============================================================
;=================== Instantiator Callbacks =================
;============================================================

;Implement the necessary operations for creating new equations
;and equation variables for the instantiation process.
public deftype Instantiator

;Create new capture variables.
public defmulti fresh-capvars (inst:Instantiator, n:Int) -> Tuple<TUVar>

;Return the identifier of the special Tuple type.
public defmulti tuple-id (inst:Instantiator) -> Int

;Create a new capture equation.
public defmulti capture-right (inst:Instantiator, capvars:Tuple<TUVar>, xs:Tuple<Type>, ys:Tuple<Type>) -> False
public defmulti capture-left (inst:Instantiator, capvars:Tuple<TUVar>, x:Type, y:Type) -> False
public defmulti capture-right (inst:Instantiator, capvars:Tuple<TUVar>, xs:Tuple<LSType>, ys:Tuple<LSType>) -> False

;Perform a delayed substitution operation on the given type.
public defmulti substitute (inst:Instantiator, t:Type, env:Tuple<KeyValue<Int,Type>>) -> Type

;============================================================
;======================= Drivers ============================
;============================================================

;Compute the instantiations of the given functions with the given
;arguments.
public defn instantiations (instantiator:Instantiator,
                            functions:Tuple<KeyValue<Int,TFunction>>,
                            targs:Tuple<Type>,
                            args:Tuple<FArg>) -> Tuple<InstFn> :
  ;Compute all appropriate instantiation patterns.
  val instfns = Vector<InstFn>()
  for entry in functions do :
    val pat = instantiate(value(entry), length(targs), args)
    match(pat:InstPattern) :
      add(instfns, make-instfn(instantiator, key(entry), value(entry), pat, targs, args))
  to-tuple(instfns)

;Compute the instantiations of the given functions with the given
;arguments.
public defn instantiations (instantiator:Instantiator,
                            functions:Tuple<KeyValue<Int,TLSFunction>>,
                            targs:Tuple<Type>,
                            args:Tuple<LSFArg>) -> Tuple<LSInstFn> :
  ;Compute all appropriate instantiation patterns.
  val instfns = Vector<LSInstFn>()
  for entry in functions do :
    val pat = instantiate(value(entry), length(targs), args)
    match(pat:InstPattern) :
      add(instfns, make-lsinstfn(instantiator, key(entry), value(entry), pat, targs, args))
  to-tuple(instfns)

;Forcefully compute a single instantiation.
public defn force-instantiation (instantiator:Instantiator,
                                 functions:Tuple<KeyValue<Int,TFunction>>,
                                 targs:Tuple<Type>,
                                 args:Tuple<FArg>) -> InstFn|False :
  if length(functions) == 1:
    val entry = functions[0]
    val pat = force-instantiate(value(entry), length(targs), args)
    match(pat:InstPattern) :
      make-instfn(instantiator, key(entry), value(entry), pat, targs, args)


;Forcefully compute a single instantiation.
public defn force-instantiation (instantiator:Instantiator,
                                 functions:Tuple<KeyValue<Int,TLSFunction>>,
                                 targs:Tuple<Type>,
                                 args:Tuple<LSFArg>) -> LSInstFn|False :
  if length(functions) == 1:
    val entry = functions[0]
    val pat = force-instantiate(value(entry), length(targs), args)
    match(pat:InstPattern) :
      make-lsinstfn(instantiator, key(entry), value(entry), pat, targs, args)

;Compute the instantiations of the given functions with the given
;expected type. Returns Blocked if 'expected' is not sufficiently
;resolved to instantiate the functions.
public defn instantiations (instantiator:Instantiator,
                            functions:Tuple<KeyValue<Int,TFunction>>,
                            expected:Type) -> Tuple<InstFn>|Blocked :

  ;Compute the unknown variables and arity specifiers.
  val block-vars = IntSet()
  val arity-specs = Vector<Int|AritySpecifier>()
  find-arities(expected, arity-specs, block-vars)

  ;Try instantiating all the functions using those arity specifiers.
  ;Return Blocked immediately if one of them could not be computed.
  label<Blocked|Tuple<InstFn>> return :

    ;Compute all instantiation patterns.
    val instpats = Vector<[KeyValue<Int,TFunction>,Tuple<InstPattern>]>()
    for entry in functions do :
      val pats = instantiate(value(entry), arity-specs)
      if empty?(pats) :
        return(Blocked(to-list(block-vars)))
      else :
        add(instpats, [entry, value!(pats)])

    ;Create the instantiated functions.
    to-tuple $ for [entry, pats] in instpats seq-cat :
      for pat in pats seq :
        make-instfn(instantiator, key(entry), value(entry), pat, expected)

;;Compute the instantiations of the given functions with the given
;;expected type. Returns Blocked if 'expected' is not sufficiently
;;resolved to instantiate the functions.
;public defn instantiations (instantiator:Instantiator,
;                            functions:Tuple<KeyValue<Int,TLSFunction>>,
;                            expected:LSType) -> Tuple<LSInstFn>|Blocked :
;
;  ;Compute the unknown variables and arity specifiers.
;  val block-vars = IntSet()
;  val arity-specs = Vector<Int|AritySpecifier>()
;  find-arities(expected, arity-specs, block-vars)
;
;  ;Try instantiating all the functions using those arity specifiers.
;  ;Return Blocked immediately if one of them could not be computed.
;  label<Blocked|Tuple<LSInstFn>> return :
;
;    ;Compute all instantiation patterns.
;    val instpats = Vector<[KeyValue<Int,TLSFunction>,Tuple<InstPattern>]>()
;    for entry in functions do :
;      val pats = instantiate(value(entry), arity-specs)
;      if empty?(pats) :
;        return(Blocked(to-list(block-vars)))
;      else :
;        add(instpats, [entry, value!(pats)])
;
;    ;Create the instantiated functions.
;    to-tuple $ for [entry, pats] in instpats seq-cat :
;      for pat in pats seq :
;        make-lsinstfn(instantiator, key(entry), value(entry), pat, expected)

;Scan through the given type for desired arities.
defn find-arities (t:Type|LSType,
                   specs:Vector<Int|AritySpecifier>,
                   blocks:IntSet) -> False :
  let loop (t:Type|LSType = t) :
    match(t) :
      (t:TUVar) :
        add(blocks, n(t))
        add(specs, UnknownArity)
      (t:UVarT) :
        add(blocks, n(t))
        add(specs, UnknownArity)
      (t:TAnd|TOr) : do(loop{_ as Type}, t)
      (t:TGradual|TTop) : add(specs, AllArities)
      (t:TArrow) : add(specs, length(a1(t)))
      (t:RefT) : loop(type(t))
      (t) : false

;Compute the instantiations of the given LoStanza functions
;appropriate for use with the 'addr(...)' expression. No optional
;arguments, type arguments, or keyword arguments, or variable-arity
;arguments allowed.
public defn addr-instantiations (instantiator:Instantiator,
                                 functions:Tuple<KeyValue<Int,TLSFunction>>) -> Tuple<LSInstFn> :
  val appropriate-functions = filter(use-in-addr-context?{value(_)}, functions)
  to-tuple $ for entry in appropriate-functions seq :
    val fid = key(entry)
    val f = value(entry)
    val num-args = length(a1(f))
    val pat = InstPattern $ to-tuple $
      for i in 0 to num-args seq :
        InstArg(i, ToPositionalArg)
    val fnt = pattern-type(f, pat, tuple-id(instantiator))
    LSInstFn(fid, pat, [], fnt)

;============================================================
;============== Appropriate in Addr Context =================
;============================================================

;Return true if the given function can be referenced from
;an addr(...) context.
defn use-in-addr-context? (f:TLSFunction) -> True|False :
  val arities = arities(f)
  targ-arity(arities) == 0 and
  num-optional(arities) == 0 and
  empty?(keywords(arities)) and
  vararg(arities) is False

;============================================================
;=========== Pattern Instantiation in Call Context ==========
;============================================================

;Instantiate a function to be called with the given arguments.
defn instantiate (func:TFunction|TLSFunction, tarity:Int, args:Tuple<FArg|LSFArg>) -> InstPattern|False :
  ;Compute the arities of the function.
  val arities = arities(func)

  ;Compute number of positional arguments, and keyword arguments provided.
  val num-pos-args = count({_ is PositionalArg|LSPositionalArg}, args)
  val keywords = to-tuple $ seq(name, filter-by<KeywordArg|LSKeywordArg>(args))

  ;If we satisfy the arity requirements, then go ahead with the pattern.
  if satisfies-arity?(arities, tarity, num-pos-args, keywords) :

    ;Compute the positional arguments.
    val pos-args = to-seq(positional-args(arities, num-pos-args))

    ;Lookup the corresponding arguments.
    InstPattern $ for arg in args map :
      match(arg) :
        (arg:PositionalArg|LSPositionalArg) :
          next(pos-args)
        (arg:KeywordArg|LSKeywordArg) :
          if name(arg) == vararg-name?(arities) :
            val v = vararg(arities) as VarargIndex
            InstArg(index(v), ToKeywordVarArg)
          else :
            val entry = /keywords(arities)[name(arg)]
            InstArg(index(entry), ToKeywordArg)

;============================================================
;============== Forced Pattern Instantiation ================
;============================================================

;Force a pattern to be instantiated.
defn force-instantiate (func:TFunction|TLSFunction, tarity:Int, args:Tuple<FArg|LSFArg>) -> InstPattern|False :
  if length(targs(func)) == tarity :
    InstPattern $ for arg in args map :
      InstArg(false, BadArg)

;============================================================
;========= Pattern Instantiation in Exp Context =============
;============================================================

;Represent the known arities that we need.
defenum AritySpecifier :
  AllArities
  UnknownArity

;Instantiate a function with the given arities.
;Returns None() if there is insufficient information to compute instantiations.
;Otherwise returns the complete set of instantiations.
defn instantiate (func:TFunction|TLSFunction, arity-specs:Collection<Int|AritySpecifier>) -> Maybe<Tuple<InstPattern>> :
  ;Compute function arities.
  val arities = arities(func)

  ;Instantiate all the reasonable arities.
  val inst-arities = instantiate-arities(arities, arity-specs)

  ;Return none if there is insufficient information.
  if empty?(inst-arities)  :
    None()

  ;Otherwise, return the instantiated arities.
  else :
    One $ for num-args in value!(inst-arities) map :
      InstPattern(to-tuple(positional-args(arities, num-args)))

;============================================================
;============== Making an InstFn From Pattern ===============
;============================================================

;Create the InstFn given the instantiation pattern in
;a call context.
defn make-instfn (instantiator:Instantiator,
                  fid:Int, t:TFunction, pat:InstPattern,
                  type-args:Tuple<Type>, fargs:Tuple<FArg>) -> InstFn :
  within (capvars, arrow) = make-instfn(instantiator, fid, t, pat, type-args) :
    capture-right(instantiator, capvars, map(type,fargs), a1(arrow))

;Create the InstFn given the instantiation pattern in
;an expression context.
defn make-instfn (instantiator:Instantiator,
                  fid:Int, t:TFunction, pat:InstPattern,
                  expected:Type) -> InstFn :
  within (capvars, arrow) = make-instfn(instantiator, fid, t, pat, []) :
    capture-left(instantiator, capvars, arrow, expected)

;Make an InstFn out of the given parameters.
;Relies upon capture, meant to generate the equation for the given
;capture variables and instantiated arrow type.
defn make-instfn (capture:(Tuple<TUVar>, TArrow) -> False
                  instantiator:Instantiator,
                  fid:Int, t:TFunction, pat:InstPattern,
                  type-args:Tuple<Type>) -> InstFn :

  ;If it's a non-polymorphic function, then no capture and substitution
  ;is necessary.
  if empty?(targs(t)) and empty?(cargs(t)) :

    ;Get the instantiated arrow type.
    val arrow = pattern-type(t, pat, tuple-id(instantiator))

    ;Create the InstFn
    InstFn(fid, pat, [], arrow)

  else :

    ;Create the capture vars.
    val capvars = fresh-capvars(instantiator, length(cargs(t)))

    ;Substitute the given types to get the actual argument types.
    val cap-env = to-tuple $ cat(seq(KeyValue, targs(t), type-args),
                                 seq({_ => n(_)}, cargs(t), capvars))
    val sub-env = to-tuple $ cat(seq(KeyValue, targs(t), type-args),
                                 seq(KeyValue, cargs(t), capvars))

    ;Get the instantiated arrow type.
    val arrow = pattern-type(t, pat, tuple-id(instantiator))
    val new-a2 = substitute(instantiator, a2(arrow), sub-env)
    val cap-arrow = TArrow(sub-caps(a1(arrow), cap-env), new-a2)
    val sub-arrow = TArrow(sub(map(uncap,a1(arrow)), sub-env), new-a2)

    ;Capture the variables if there are any.
    capture(capvars, cap-arrow) when not empty?(capvars)      

    ;Create the InstFn.
    InstFn(fid, pat, capvars, sub-arrow)  

;============================================================
;=========== Making an LSInstFn From Pattern ================
;============================================================

;Create the LSInstFn given the instantiation pattern in a call context.
defn make-lsinstfn (instantiator:Instantiator,
                    fid:Int, t:TLSFunction, pat:InstPattern,
                    type-args:Tuple<Type>, fargs:Tuple<LSFArg>) -> LSInstFn :
  within (capvars, fnt) = make-lsinstfn(instantiator, fid, t, pat, type-args) :
    capture-right(instantiator, capvars, map(type,fargs), a(fnt))

;;Create the LSInstFn given the instantiation pattern in a call context.
;defn make-lsinstfn (instantiator:Instantiator,
;                    fid:Int, t:TLSFunction, pat:InstPattern,
;                    expected:LSType) -> LSInstFn :
;  within (capvars, fnt) = make-lsinstfn(instantiator, fid, t, pat, []) :
;    capture(instantiator, capvars, fnt, expected)

;Make an InstFn out of the given parameters.
;Relies upon capture, meant to generate the equation for the given
;capture variables and instantiated arrow type.
defn make-lsinstfn (capture:(Tuple<TUVar>, FnT) -> False,
                    instantiator:Instantiator,
                    fid:Int, t:TLSFunction, pat:InstPattern,
                    type-args:Tuple<Type>) -> LSInstFn :

  ;If it's a non-polymorphic function, then no capture and substitution
  ;is necessary.
  if empty?(targs(t)) and empty?(cargs(t)) :

    ;Get the instantiated FnT type.
    val fnt = pattern-type(t, pat, tuple-id(instantiator))

    ;Create the LSInstFn
    LSInstFn(fid, pat, [], fnt)

  else :

    ;Create the capture vars.
    val capvars = fresh-capvars(instantiator, length(cargs(t)))

    ;Substitute the given types to get the actual argument types.
    val cap-env = to-tuple $ cat(seq(KeyValue, targs(t), type-args),
                                 seq({_ => n(_)}, cargs(t), capvars))
    val sub-env = to-tuple $ cat(seq(KeyValue, targs(t), type-args),
                                 seq(KeyValue, cargs(t), capvars))

    ;Get the instantiated FnT type.
    val fnt = pattern-type(t, pat, tuple-id(instantiator))
    val cap-fnt = FnT(sub-caps(a(fnt),cap-env), false, sub(b(fnt), sub-env))
    val sub-fnt = FnT(sub(map(uncap,a(fnt)),sub-env), false, sub(b(fnt), sub-env))

    ;Capture the variables if there are any.
    capture(capvars, cap-fnt) when not empty?(capvars)      

    ;Create the InstFn.
    LSInstFn(fid, pat, capvars, sub-fnt)  

;============================================================
;=============== Compute Type of a Pattern ==================
;============================================================

;Return the instantiated arrow for the given instantiation.
defn pattern-type (t:TFunction, pat:InstPattern, tuple-n:Int) -> TArrow :
  ;Retrieve the argument types.
  val a1 = for arg in args(pat) map :
    switch(mode(arg)) :
      BadArg :
        TTop()
      ToKeywordVarArg :
        val farg = a1(t)[arg-index(arg) as Int]
        TOf(tuple-n, [type(farg)])
      else :
        val farg = a1(t)[arg-index(arg) as Int]
        type(farg)
  ;Form the resulting TArrow.
  TArrow(a1, a2(t))

;Return the instantiated FnT for the given instantiation.
defn pattern-type (t:TLSFunction, pat:InstPattern, tuple-n:Int) -> FnT :
  ;Retrieve the argument types.
  val a1 = for arg in args(pat) map :
    switch(mode(arg)) :
      BadArg :
        UnknownT()
      ToKeywordVarArg :
        val farg = a1(t)[arg-index(arg) as Int]
        val reft = type(farg) as RefT
        val tuplet = TOf(tuple-n, [type(reft)])
        RefT(tuplet)
      else :
        val farg = a1(t)[arg-index(arg) as Int]
        type(farg)
  ;Form the resulting FnT.
  FnT(a1, false, a2(t))

;============================================================
;===================== Compute Arities ======================
;============================================================

;------------------------------------------------------------
;---------------------- Arity Summary -----------------------
;------------------------------------------------------------

;Represent the arities of a function.
;- keywords: An entry, name => optional?, indicates that the
;  function accepts a keyword 'name', and 'optional?' indicates
;  whether the keyword is required or optional.
defstruct FnArities :
  targ-arity:Int
  min-arity:Int
  max-arity:Int
  num-optional:Int
  num-required-keywords:Int
  positional:Vector<PosIndex>
  keywords:HashTable<Symbol,KeywordIndex>
  vararg:VarargIndex|False

;Track the indices of the positional arguments.
defstruct PosIndex :
  index:Int
  optional?:True|False

;Track the indices of the keyword arguments.
defstruct KeywordIndex :
  index:Int
  optional?:True|False

;Track the index of the vararg.
defstruct VarargIndex :
  index:Int
  name:Symbol

;Return true if FnArities represents a fixed arity function.
defn fixed-arity? (a:FnArities) -> True|False :
  num-optional(a) == 0 and vararg(a) is False

;Return the name of the variable arity argument.
defn vararg-name? (a:FnArities) -> Symbol|False :
  match(vararg(a)) :
    (v:VarargIndex) : name(v)
    (f:False) : false

;------------------------------------------------------------
;---------------------- Summarize Arities -------------------
;------------------------------------------------------------

;Compute the arities of a function.
defn arities (func:TFunction|TLSFunction) -> FnArities :
  val num-required = to-seq(0 to false)
  val num-optional = to-seq(0 to false)
  val positional = Vector<PosIndex>()
  val keywords = HashTable<Symbol,KeywordIndex>()
  var vararg:VarargIndex|False = false
  val num-required-keywords = to-seq(0 to false)

  for (arg in a1(func), index in 0 to false) do :
    match(arg) :
      (arg:PositionalArg|LSPositionalArg) :
        if optional?(arg) : next(num-optional)
        else : next(num-required)
        add(positional, PosIndex(index, optional?(arg)))
      (arg:KeywordArg|LSKeywordArg) :
        keywords[name(arg)] = KeywordIndex(index, optional?(arg))
        if not optional?(arg) : next(num-required-keywords)
      (arg:VarArg|LSVarArg) :
        vararg = VarargIndex(index, name(arg))
        
  FnArities(length(targs(func)),
            peek(num-required),
            peek(num-required) + peek(num-optional),
            peek(num-optional),
            peek(num-required-keywords),
            positional,
            keywords,            
            vararg)

;------------------------------------------------------------
;---------------------- Arity Satisfied? --------------------
;------------------------------------------------------------

;Returns true if the given call signature satisfies the
;function arities.
defn satisfies-arity? (arities:FnArities,
                       num-targs:Int,
                       num-args:Int,
                       keywords:Tuple<Symbol>) -> True|False :

  ;Returns true if the right positional arguments
  ;were passed in.
  defn pos-arity-satisfied? () :
    if targ-arity(arities) == num-targs :
      ;Determine whether the function's variable-arity
      ;feature is used.
      val variable? = vararg(arities) is-not False and
                      not contains?(keywords, vararg-name?(arities))
      if variable? :
        num-args >= min-arity(arities)
      else :
        num-args >= min-arity(arities) and
        num-args <= max-arity(arities)

  ;Returns true if the right keyword arguments
  ;were passed in.
  defn keywords-satisfied? () :
    if num-required-keywords(arities) == 0 and empty?(keywords) :
      true
    else :
      val num-required-provided = to-seq(0 to false)
      val good-keywords? = for name in keywords all? :
        if key?(/keywords(arities), name) :
          val optional? = optional?(/keywords(arities)[name])
          next(num-required-provided) when not optional?
          true
        else if vararg-name?(arities) == name :
          true
      val enough-keywords? = peek(num-required-provided) == num-required-keywords(arities)
      good-keywords? and enough-keywords?

  ;Launch!
  pos-arity-satisfied?() and
  keywords-satisfied?()

;------------------------------------------------------------
;----------------- Instantiated Arities ---------------------
;------------------------------------------------------------

;Compute set of all arities applicable out of the desired specifiers.
;Returns None() to indicate that there is insufficient information to compute.
defn instantiate-arities (arities:FnArities, specs:Collection<Int|AritySpecifier>) -> Maybe<Tuple<Int>> :
  ;If type arguments or keyword arguments required, then no instantiation
  ;is possible.
  if targ-arity(arities) > 0 or num-required-keywords(arities) > 0 :
    One([])
  ;Otherwise:
  else :
    ;Case: Fixed arity functions can only be instantiated in one way.
    if fixed-arity?(arities) :
      One([min-arity(arities)])
    ;Case: Finite arity functions can always be instantiated if
    ;AllArities is one of the specifiers.
    else if vararg(arities) is False and contains?(specs, AllArities) :
      One(to-tuple(min-arity(arities) through max-arity(arities)))
    ;Case: Otherwise, functions can be instantiated only if
    ;the specifiers are known.
    else if not contains?(specs, UnknownArity) :
      ;Compute set of desired arities.
      val arity-set = HashSet<Int>()
      for spec in specs do :
        match(spec) :
          (spec:Int) : add(arity-set, spec)
          (spec:AllArities) : add-all(arity-set, min-arity(arities) through max-arity(arities))
      ;Keep the good arities out of the given set.
      One $ to-tuple $ for n in arity-set filter :
        satisfies-arity?(arities, 0, n, [])
    ;Case: Insufficient information to instantiate.
    else :
      None()

;------------------------------------------------------------
;------------------ Compute Positional Args -----------------
;------------------------------------------------------------

;For the given number of arguments, return the positional arguments
;that were used. 
defn positional-args (arities:FnArities, num-args:Int) -> Vector<InstArg> :
  val instargs = Vector<InstArg>()
  val num-used-optional = min(num-optional(arities), num-args - min-arity(arities))
  val num-used-varargs = max(0, num-args - max-arity(arities))
  val num-optional = to-seq(0 to false)
  for arg in positional(arities) do :
    val used? = if optional?(arg) : next(num-optional) < num-used-optional
                else : true
    if used? :
      add(instargs, InstArg(index(arg), ToPositionalArg))
  for i in 0 to num-used-varargs do :
    val v = vararg(arities) as VarargIndex
    add(instargs, InstArg(index(v), ToVarArg))
  instargs