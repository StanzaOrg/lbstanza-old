defpackage stz/type-instantiation :
  import core
  import collections
  import stz/types
  import stz/type-instfns
  import stz/type-utils

;============================================================
;=================== Instantiator Callbacks =================
;============================================================

;Implement the necessary operations for creating new equations
;and equation variables for the instantiation process.
public deftype Instantiator

;Create new capture variables.
public defmulti fresh-capvars (inst:Instantiator, n:Int) -> Tuple<TUVar>

;Return the identifier of the special Tuple type.
public defmulti tuple-id (inst:Instantiator) -> Int

;Create a new capture equation.
public defmulti capture (inst:Instantiator, capvars:Tuple<TUVar>,
                         x:Type, y:Type) -> False

;Perform a substitution operation on the given type.
public defmulti substitute (inst:Instantiator, t:Type, env:Tuple<KeyValue<Int,Type>>) -> Type

;============================================================
;======================= Drivers ============================
;============================================================

;Compute the instantiations of the given functions with the given
;arguments.
public defn instantiations (instantiator:Instantiator,
                            functions:Tuple<KeyValue<Int,TFunction>>,
                            targs:Tuple<Type>,
                            args:Tuple<FArg>) -> Tuple<InstFn> :
  ;Compute all appropriate instantiation patterns.
  val instfns = Vector<InstFn>()
  for entry in functions do :
    val pat = instantiate(value(entry), length(targs), args)
    match(pat:InstPattern) :
      add(instfns, make-instfn(instantiator, key(entry), value(entry), pat, targs, args))
  to-tuple(instfns)

;Compute the instantiations of the given functions with the given
;arguments.
;<comment>
public defn instantiations (instantiator:Instantiator,
                            functions:Tuple<KeyValue<Int,TLSFunction>>,
                            targs:Tuple<Type>,
                            args:Tuple<FArg>) -> Tuple<LSInstFn> :
  ;Compute all appropriate instantiation patterns.
  val instfns = Vector<LSInstFn>()
  for entry in functions do :
    val pat = instantiate(value(entry), length(targs), args)
    match(pat:InstPattern) :
      add(instfns, make-instfn(instantiator, key(entry), value(entry), pat, targs, args))
  to-tuple(instfns)
;<comment>

;Forcefully compute a single instantiation.
public defn force-instantiation (instantiator:Instantiator,
                                 functions:Tuple<KeyValue<Int,TFunction>>,
                                 targs:Tuple<Type>,
                                 args:Tuple<FArg>) -> InstFn|False :
  if length(functions) == 1:
    val entry = functions[0]
    val pat = force-instantiate(value(entry), length(targs), args)
    match(pat:InstPattern) :
      make-instfn(instantiator, key(entry), value(entry), pat, targs, args)

;Compute the instantiations of the given functions with the given
;expected type. Returns Blocked if 'expected' is not sufficiently
;resolved to instantiate the functions.
public defn instantiations (instantiator:Instantiator,
                            functions:Tuple<KeyValue<Int,TFunction>>,
                            expected:Type) -> Tuple<InstFn>|Blocked :

  ;Compute the unknown variables and arity specifiers.
  val block-vars = IntSet()
  val arity-specs = Vector<Int|AritySpecifier>()
  let loop (t:Type = expected) :
    match(t) :
      (t:TUVar) :
        add(block-vars, n(t))
        add(arity-specs, UnknownArity)
      (t:TAnd|TOr) : do(loop{_ as Type}, t)
      (t:TGradual|TTop) : add(arity-specs, AllArities)
      (t:TArrow) : add(arity-specs, length(a1(t)))
      (t) : false

  ;Try instantiating all the functions using those arity specifiers.
  ;Return Blocked immediately if one of them could not be computed.
  label<Blocked|Tuple<InstFn>> return :

    ;Compute all instantiation patterns.
    val instpats = Vector<[KeyValue<Int,TFunction>,Tuple<InstPattern>]>()
    for entry in functions do :
      val pats = instantiate(value(entry), arity-specs)
      if empty?(pats) :
        return(Blocked(to-list(block-vars)))
      else :
        add(instpats, [entry, value!(pats)])

    ;Create the instantiated functions.
    to-tuple $ for [entry, pats] in instpats seq-cat :
      for pat in pats seq :
        make-instfn(instantiator, key(entry), value(entry), pat, expected)

;============================================================
;=========== Pattern Instantiation in Call Context ==========
;============================================================

;Instantiate a function to be called with the given arguments.
public defn instantiate (func:TFunction, tarity:Int, args:Tuple<FArg>) -> InstPattern|False :
  ;Compute the arities of the function.
  val arities = arities(func)

  ;Compute number of positional arguments, and keyword arguments provided.
  val num-pos-args = count({_ is PositionalArg}, args)
  val keywords = to-tuple $ seq(name, filter-by<KeywordArg>(args))

  ;If we satisfy the arity requirements, then go ahead with the pattern.
  if satisfies-arity?(arities, tarity, num-pos-args, keywords) :

    ;Compute the positional arguments.
    val pos-args = to-seq(positional-args(arities, num-pos-args))

    ;Lookup the corresponding arguments.
    InstPattern $ for arg in args map :
      match(arg) :
        (arg:PositionalArg) :
          next(pos-args)
        (arg:KeywordArg) :
          if name(arg) == vararg-name?(arities) :
            val v = vararg(arities) as VarargIndex
            InstArg(index(v), ToKeywordVarArg)
          else :
            val entry = /keywords(arities)[name(arg)]
            InstArg(index(entry), ToKeywordArg)

;============================================================
;============== Forced Pattern Instantiation ================
;============================================================

;Force a pattern to be instantiated.
public defn force-instantiate (func:TFunction, tarity:Int, args:Tuple<FArg>) -> InstPattern|False :
  if length(targs(func)) == tarity :
    InstPattern $ for arg in args map :
      InstArg(false, BadArg)

;============================================================
;========= Pattern Instantiation in Exp Context =============
;============================================================

;Represent the known arities that we need.
public defenum AritySpecifier :
  AllArities
  UnknownArity

;Instantiate a function with the given arities.
;Returns None() if there is insufficient information to compute instantiations.
;Otherwise returns the complete set of instantiations.
public defn instantiate (func:TFunction, arity-specs:Collection<Int|AritySpecifier>) -> Maybe<Tuple<InstPattern>> :
  ;Compute function arities.
  val arities = arities(func)

  ;Instantiate all the reasonable arities.
  val inst-arities = instantiate-arities(arities, arity-specs)

  ;Return none if there is insufficient information.
  if empty?(inst-arities)  :
    None()

  ;Otherwise, return the instantiated arities.
  else :
    One $ for num-args in value!(inst-arities) map :
      InstPattern(to-tuple(positional-args(arities, num-args)))

;============================================================
;===== LoStanza Pattern Instantiation in Call Context =======
;============================================================
;<comment>
;Instantiate a function to be called with the given arguments.
public defn instantiate (func:TLSFunction, tarity:Int, args:Tuple<LSFArg>) -> InstPattern|False :
  ;Compute the arities of the function.
  val arities = arities(func)

  ;Classify given arguments into positional and keywords arguments.
  val given-pos-args = Vector<LSPositionalArg>()
  val given-keyword-args = HashTable<Symbol,LSKeywordArg>()
  for a in args do :
    match(a) :
      (a:LSPositionalArg) : add(given-pos-args, a)
      (a:LSKeywordArg) : given-keyword-args[name(a)] = a

  ;Classify expected arguments into positional and keyword arguments.
  val expected-pos-args = Vector<PositionalArg>()
  val expected-keyword-args = HashTable<Symbol,KeywordArg>()
  var expected-vararg:VarArg|False = false
  for a in a1(func) do :
    match(a) :
      (a:PositionalArg) : add(expected-pos-args, a)
      (a:KeywordArg) : expected-keyword-args[name(a)] = a
      (a:VarArg) : expected-vararg = a

  ;Compute whether the function arity is correct.
  defn correct-arity? () -> True|False :
    ;Determine whether max-arity applies.
    val max-arity-applies? = match(expected-vararg) :
      (vararg:VarArg) : key?(given-keyword-args, name(vararg))
      (f:False) : true
    ;Ensure arity within range.
    val n = length(given-pos-args)
    if max-arity-applies? :
      n >= min-arity(arities) and n <= max-arity(arities)
    else :
      n >= min-arity(arities)

  ;Return true if 'name' is the name of the expected vararg.
  defn vararg-name? (name:Symbol) -> True|False :
    match(expected-vararg:VarArg) :
      name == /name(expected-vararg)

  ;Compute whether the correct keyword arguments are given.
  defn correct-keywords? () -> True|False :
    val required-is-given? =
      for a in values(expected-keyword-args) all? :
        optional?(a) or key?(given-keyword-args, name(a))
    val given-is-expected? =
      for a in values(given-keyword-args) all? :
        key?(expected-keyword-args,name(a)) or vararg-name?(name(a))
    required-is-given? and given-is-expected?

  ;Compute the instantiated arguments.
  defn compute-inst-args () -> Tuple<InstArg> :
    ;Compute the vector of InstArg corresponding to the positional arguments.
    val num-given = length(given-pos-args)
    val num-used-optional = min(num-optional(arities), num-given - min-arity(arities))
    val num-used-varargs = max(0, num-given - max-arity(arities))
    val num-optional = to-seq(0 to false)
    val vararg-index = index-when({_ is VarArg}, a1(func))
    val pos-args = Vector<InstArg>()
    for (a in a1(func), i in 0 to false) do :
      match(a:PositionalArg) :
        val used-arg? =
          if optional?(a) : next(num-optional) < num-used-optional
          else : true
        add(pos-args, InstArg(i, ToPositionalArg)) when used-arg?
    for i in 0 to num-used-varargs do :
      add(pos-args, InstArg(vararg-index as Int, ToVarArg))

    ;Compute the InstArgs corresponding to the given keyword arguments.
    val keyword-args = HashTable<Symbol,InstArg>()
    for (a in a1(func), i in 0 to false) do :
      match(a:KeywordArg) :
        if key?(given-keyword-args, name(a)) :
          keyword-args[name(a)] = InstArg(i, ToKeywordArg)

    ;Add the vararg keyword argument if used.
    match(expected-vararg:VarArg) :
      if key?(given-keyword-args, name(expected-vararg)) :
        keyword-args[name(expected-vararg)] = InstArg(vararg-index as Int, ToKeywordVarArg)

    ;Finally iterate through the actual given arguments and read
    ;off their corresponding function arguments.
    val pos-arg-index = to-seq(0 to false)
    for arg in args map :
      match(arg) :
        (arg:PositionalArg) : pos-args[next(pos-arg-index)]
        (arg:KeywordArg) : keyword-args[name(arg)]

  ;Launch the overall algorithm.
  if correct-arity?() and correct-keywords?() :
    InstPattern(compute-inst-args())
;<comment>

;============================================================
;============== Making an InstFn From Pattern ===============
;============================================================

;Create the InstFn given the instantiation pattern in
;a call context.
defn make-instfn (instantiator:Instantiator,
                  fid:Int, t:TFunction, pat:InstPattern,
                  type-args:Tuple<Type>, fargs:Tuple<FArg>) -> InstFn :

  ;If it's a non-polymorphic function, then no capture and substitution
  ;is necessary.
  if empty?(targs(t)) and empty?(cargs(t)) :

    ;Get the instantiated arrow type.
    val arrow = pattern-type(t, pat, tuple-id(instantiator))

    ;Create the InstFn.
    InstFn(fid, pat, [], arrow)

  else :

    ;Create the capture vars.
    val capvars = fresh-capvars(instantiator, length(cargs(t)))

    ;Substitute the given types to get the actual argument types.
    val env = to-tuple $ cat(seq(KeyValue, targs(t), type-args),
                             seq({_ => n(_)}, cargs(t), capvars))

    ;Get the instantiated arrow type.
    val arrow = pattern-type(t, pat, tuple-id(instantiator))

    ;Substitute env to compute new a1.
    val cap-a1 = sub-caps(a1(arrow), env)

    ;Perform any necessary capturing.
    if not empty?(capvars) :
      capture(instantiator, capvars,
              TTuple(map(type,fargs)), TTuple(cap-a1))

    ;Perform substitution for the return type. If the
    ;return type is a TUVar, then use a delayed substitution.
    val subenv = to-tuple $ cat(seq(KeyValue, targs(t), type-args),
                                seq(KeyValue, cargs(t), capvars))
    val new-a1 = sub(map(uncap,a1(arrow)), subenv)
    val new-a2 = substitute(instantiator, a2(arrow), subenv)

    ;Create the InstFn.
    InstFn(fid,
           pat,
           capvars,
           TArrow(new-a1, new-a2))

;Create the InstFn given the instantiation pattern in
;an expression context.
defn make-instfn (instantiator:Instantiator,
                  fid:Int, t:TFunction, pat:InstPattern,
                  expected:Type) -> InstFn :

  ;If it's a non-polymorphic function, then no capture and substitution
  ;is necessary.
  if empty?(cargs(t)) :

    ;Get the instantiated arrow type.
    val arrow = pattern-type(t, pat, tuple-id(instantiator))

    ;Create the InstFn
    InstFn(fid, pat, [], arrow)

  else :

    ;Create the capture vars.
    val capvars = fresh-capvars(instantiator, length(cargs(t)))

    ;Substitute the given types to get the actual argument types.
    val env = to-tuple $ seq({_ => n(_)}, cargs(t), capvars)

    ;Get the instantiated arrow type.
    val arrow = pattern-type(t, pat, tuple-id(instantiator))

    ;Substitute env to compute new a1.
    val cap-arrow = sub-caps(arrow, env)

    ;Perform any necessary capturing.
    capture(instantiator, capvars, cap-arrow, expected)

    ;Perform substitution for the return type. If the
    ;return type is a TUVar, then use a delayed substitution.
    val subenv = to-tuple $ seq(KeyValue, cargs(t), capvars)
    val new-a1 = sub(map(uncap,a1(arrow)), subenv)
    val new-a2 = substitute(instantiator, a2(arrow), subenv)

    ;Create the InstFn.
    InstFn(fid,
           pat,
           capvars,
           TArrow(new-a1, new-a2))

;============================================================
;=============== Compute Type of a Pattern ==================
;============================================================

;Return the instantiated arrow for the given instantiation.
defn pattern-type (t:TFunction, pat:InstPattern, tuple-n:Int) -> TArrow :
  ;Retrieve the argument types.
  val a1 = for arg in args(pat) map :
    switch(mode(arg)) :
      BadArg :
        TTop()
      ToKeywordVarArg :
        val farg = a1(t)[arg-index(arg) as Int]
        TOf(tuple-n, [type(farg)])
      else :
        val farg = a1(t)[arg-index(arg) as Int]
        type(farg)
  ;Form the resulting TArrow.
  TArrow(a1, a2(t))

;============================================================
;===================== Compute Arities ======================
;============================================================

;------------------------------------------------------------
;---------------------- Arity Summary -----------------------
;------------------------------------------------------------

;Represent the arities of a function.
;- keywords: An entry, name => optional?, indicates that the
;  function accepts a keyword 'name', and 'optional?' indicates
;  whether the keyword is required or optional.
defstruct FnArities :
  targ-arity:Int
  min-arity:Int
  max-arity:Int
  num-optional:Int
  num-required-keywords:Int
  positional:Vector<PosIndex>
  keywords:HashTable<Symbol,KeywordIndex>
  vararg:VarargIndex|False

;Track the indices of the positional arguments.
defstruct PosIndex :
  index:Int
  optional?:True|False

;Track the indices of the keyword arguments.
defstruct KeywordIndex :
  index:Int
  optional?:True|False

;Track the index of the vararg.
defstruct VarargIndex :
  index:Int
  name:Symbol

;Return true if FnArities represents a fixed arity function.
defn fixed-arity? (a:FnArities) -> True|False :
  num-optional(a) == 0 and vararg(a) is False

;Return the name of the variable arity argument.
defn vararg-name? (a:FnArities) -> Symbol|False :
  match(vararg(a)) :
    (v:VarargIndex) : name(v)
    (f:False) : false

;------------------------------------------------------------
;---------------------- Summarize Arities -------------------
;------------------------------------------------------------

;Compute the arities of a function.
defn arities (func:TFunction|TLSFunction) -> FnArities :
  val num-required = to-seq(0 to false)
  val num-optional = to-seq(0 to false)
  val positional = Vector<PosIndex>()
  val keywords = HashTable<Symbol,KeywordIndex>()
  var vararg:VarargIndex|False = false
  val num-required-keywords = to-seq(0 to false)

  for (arg in a1(func), index in 0 to false) do :
    match(arg) :
      (arg:PositionalArg|LSPositionalArg) :
        if optional?(arg) : next(num-optional)
        else : next(num-required)
        add(positional, PosIndex(index, optional?(arg)))
      (arg:KeywordArg|LSKeywordArg) :
        keywords[name(arg)] = KeywordIndex(index, optional?(arg))
        if not optional?(arg) : next(num-required-keywords)
      (arg:VarArg|LSVarArg) :
        vararg = VarargIndex(index, name(arg))
        
  FnArities(length(targs(func)),
            peek(num-required),
            peek(num-required) + peek(num-optional),
            peek(num-optional),
            peek(num-required-keywords),
            positional,
            keywords,            
            vararg)

;------------------------------------------------------------
;---------------------- Arity Satisfied? --------------------
;------------------------------------------------------------

;Returns true if the given call signature satisfies the
;function arities.
defn satisfies-arity? (arities:FnArities,
                       num-targs:Int,
                       num-args:Int,
                       keywords:Tuple<Symbol>) -> True|False :

  ;Returns true if the right positional arguments
  ;were passed in.
  defn pos-arity-satisfied? () :
    if targ-arity(arities) == num-targs :
      ;Determine whether the function's variable-arity
      ;feature is used.
      val variable? = vararg(arities) is-not False and
                      not contains?(keywords, vararg-name?(arities))
      if variable? :
        num-args >= min-arity(arities)
      else :
        num-args >= min-arity(arities) and
        num-args <= max-arity(arities)

  ;Returns true if the right keyword arguments
  ;were passed in.
  defn keywords-satisfied? () :
    if num-required-keywords(arities) == 0 and empty?(keywords) :
      true
    else :
      val num-required-provided = to-seq(0 to false)
      val good-keywords? = for name in keywords all? :
        if key?(/keywords(arities), name) :
          val optional? = optional?(/keywords(arities)[name])
          next(num-required-provided) when not optional?
          true
        else if vararg-name?(arities) == name :
          true
      val enough-keywords? = peek(num-required-provided) == num-required-keywords(arities)
      good-keywords? and enough-keywords?

  ;Launch!
  pos-arity-satisfied?() and
  keywords-satisfied?()

;------------------------------------------------------------
;----------------- Instantiated Arities ---------------------
;------------------------------------------------------------

;Compute set of all arities applicable out of the desired specifiers.
;Returns None() to indicate that there is insufficient information to compute.
defn instantiate-arities (arities:FnArities, specs:Collection<Int|AritySpecifier>) -> Maybe<Tuple<Int>> :
  ;If type arguments or keyword arguments required, then no instantiation
  ;is possible.
  if targ-arity(arities) > 0 or num-required-keywords(arities) > 0 :
    One([])
  ;Otherwise:
  else :
    ;Case: Fixed arity functions can only be instantiated in one way.
    if fixed-arity?(arities) :
      One([min-arity(arities)])
    ;Case: Finite arity functions can always be instantiated if
    ;AllArities is one of the specifiers.
    else if vararg(arities) is False and contains?(specs, AllArities) :
      One(to-tuple(min-arity(arities) through max-arity(arities)))
    ;Case: Otherwise, functions can be instantiated only if
    ;the specifiers are known.
    else if not contains?(specs, UnknownArity) :
      ;Compute set of desired arities.
      val arity-set = HashSet<Int>()
      for spec in specs do :
        match(spec) :
          (spec:Int) : add(arity-set, spec)
          (spec:AllArities) : add-all(arity-set, min-arity(arities) through max-arity(arities))
      ;Keep the good arities out of the given set.
      One $ to-tuple $ for n in arity-set filter :
        satisfies-arity?(arities, 0, n, [])
    ;Case: Insufficient information to instantiate.
    else :
      None()

;------------------------------------------------------------
;------------------ Compute Positional Args -----------------
;------------------------------------------------------------

;For the given number of arguments, return the positional arguments
;that were used. 
defn positional-args (arities:FnArities, num-args:Int) -> Vector<InstArg> :
  val instargs = Vector<InstArg>()
  val num-used-optional = min(num-optional(arities), num-args - min-arity(arities))
  val num-used-varargs = max(0, num-args - max-arity(arities))
  val num-optional = to-seq(0 to false)
  for arg in positional(arities) do :
    val used? = if optional?(arg) : next(num-optional) < num-used-optional
                else : true
    if used? :
      add(instargs, InstArg(index(arg), ToPositionalArg))
  for i in 0 to num-used-varargs do :
    val v = vararg(arities) as VarargIndex
    add(instargs, InstArg(index(v), ToVarArg))
  instargs