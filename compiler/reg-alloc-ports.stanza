defpackage stz/reg-alloc-ports :
  import core
  import collections
  import stz/printing-utils
  import stz/reg-alloc-ir

;- usage-position: The first position at which this
;  variable is used. 0 indicates the first instruction
;  of the current block.
;- pref-reg: Based upon the code downstream, the preferred
;  register that the port value should be stored in.
public defstruct Port :
  id:Int
  usage-position:Int
  prefs:PortPref|False with:
    default => false
    updater => sub-prefs
  pref-reg: Reg|FReg|False with:
    default => false
    updater => sub-pref-reg
  status: PortStatus|False with:
    default => false
    updater => sub-status

;Indicates the actual save/load/reg status of the port
;based on calculations from code upstream.
public defstruct PortStatus :
  saved?:True|False
  loaded:Location|False with: (updater => sub-loaded)

;Indicates the save and load preferences of a port.
public defstruct PortPref <: Hashable&Equalable :
  save-pref: SavePref
  load-pref: LoadPref
with:
  hashable => true
  equalable => true

public defenum SavePref :
  ;The variable is preferred to be saved. The
  ;variable is live across a clear-registers operation.
  PreferSave

  ;The variable is preferred to be not saved.
  ;The variable is killed so there's no point
  ;in saving it.
  PreferNoSave

  ;The variable is preferred to be saved, if the
  ;block successors prefer for it to be saved.
  ;(Used only during port preference algorithm.)
  PreferSaveIfSuccessor

public deftype LoadPref <: Hashable & Equalable

  ;The variable is preferred to be not loaded.
  ;The variable crosses a clear-registers operation,
  ;before it is ever used.
public defstruct PreferNoLoad <: LoadPref
with: (hashable => true, equalable => true)

  ;The variable is preferred to be loaded, if the
  ;block successors prefer for it to be loaded.
  ;(Used only during port preference algorithm.)
public defstruct PreferLoadIfSuccessor <: LoadPref
with: (hashable => true, equalable => true)

;The variable is preferred to be loaded in a register.
;The variable is used as an argument to an operation.
public defstruct PreferLoad <: LoadPref :
  reg: AnyReg|AnyFReg
with:
  hashable => true
  equalable => true

defmethod print (o:OutputStream, p:LoadPref) :
  print{o, _} $ match(p) :
    (p:PreferNoLoad) : "PreferNoLoad"
    (p:PreferLoadIfSuccessor) : "PreferLoadIfSuccessor"
    (p:PreferLoad) : "PreferLoad(%_)" % [reg(p)]

defmethod print (o:OutputStream, p:Port) :
  val items = [
    simple-field("usage-position", usage-position(p))
    falseable-field(prefs(p))
    falseable-field("pref-reg", pref-reg(p))
    falseable-field("status", status(p))]
  print(o, "port %_ (%_)" % [id(p), comma-field-list(items)])

defmethod print (o:OutputStream, p:PortPref) :
  print(o, "PortPref(%_, %_)" % [save-pref(p), load-pref(p)])

defmethod print (o:OutputStream, s:PortStatus) :
  val items = [
    bool-flag-field("saved?", saved?(s))
    falseable-field("loaded", loaded(s))]
  print(o, "PortStatus(%_)" % [comma-field-list(items)])