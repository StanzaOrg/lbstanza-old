defpackage stz/stitcher :
  import core
  import collections
  import stz/asm-ir
  import stz/asm-ir-utils
  import stz/codegen
  import stz/code-emitter
  import stz/dl-ir
  import stz/vm-ir
  import stz/utils
  import stz/padder
  import stz/const-pool
  import stz/dyn-tree
  import stz/typeset
  import stz/backend
  import stz/backend-regs
  import stz/algorithms
  import stz/bindings
  import stz/conversion-utils
  import stz/dispatch-dag with:
    prefix(Branch) => Dag
  import stz/set-utils
  import stz/binary-tree
  import stz/c-trampoline
  import core/stack-trace
  import stz/packed-class-table
  import stz/c-extern-trampoline

;<DOC>=======================================================
;===================== Documentation ========================
;============================================================

Input:
  Functions compiled into ASM IR.  
Output:
  Pure ASM IR

Constructs that are removed:
  LocalMem
  TagImm
  StackMap
  LinkId
  Match
  Dispatch
  MethodDispatch
  TypeofOp

Labels are unique-ified so that we can compile multiple packages into
the same assembly file.

Removal strategies for each construct:
  TagImm:
    Becomes integer immediates.
    Requires each class to have an integer tag assigned to it.
    If it is a marker, then becomes (tag << 3) + marker-ref-bits.
    If it is not a marker, then becomes tag.
  StackMap:
    Becomes an integer immediate.
    Requires every unique stackmap to have an integer id assigned to it.
    Output the id.
  LinkId:
    The linkids can refer to one of the following:
      CodeId:
        Becomes a Mem immediate referencing the starting label of the function.
        Requires all functions to have a unique label assigned to it.
      ExternId:
        Becomes an ExMem immediate referencing the external label of the variable.
      ExternDefnId:
        Becomes an ExMem immediate referencing the external label of the function.
      DataId:
        Becomes a Mem immediate referencing the label of the data packet.
      GlobalId:
        Becomes a Mem immediate referencing the global constant pool table, with
        the appropriate offset. 
      ConstId:
        Becomes a Mem immediate referencing the global constant pool table, with
        the appropriate offset.
        Requires constants to be interned and assigned indices. 
  Match, Dispatch:
    Requires the class hierarchy to be indexed.
    Convert the branches into a trie and then emit the instructions
    for performing the branching.
  MethodDispatch:
    Requires the class hierarchy to be indexed.
    Requires the method branches for each multi to be collected.
    Convert the branches into a trie and then emit the instructions
    for performing the branching.
  TypeofOp :
    Requires the class hierarchy to be indexed.
    No trie is needed, just the list of concrete tags.

Implementation of Global Table:
  Input:
    Sequence of VMGlobals:
      defstruct VMGlobal :
        id: Int
        size: Int
        roots: Tuple<Int>
  Output:
    For each global:
      Compute an offset.
    Compute the reference mask.
    Compute the number of words in the mask.

Implementation of Constant Table:
  Input:
    Sequence of VMConst:
      defstruct VMConst :
        id: Int
        value: VMValue
  Output:
    The index of each interned VMConst.
    The Consts corresponding to each index, ready to be
    encoded as a table.

Implementation of Class Table:
  Goal:
    The objective of the class table is to help compile the
    match/dispatch statements. The key feature needed is the ability
    to convert a TypeSet into an ISet to perform the trie conversion.
  Therefore:
    Given a single typeid, within a package. Convert it to an ISet.
  Therefore:
    Given a single typeid, we need to resolve it to a global typeid.
  Therefore:
    Each global typeid needs a node in the class dynamic tree.
  Implementation:
    Sweep through every vmclass definition in each package, and if it
    is a concrete class, then assign its ClassProp property with its
    assigned tag.
    At the same time, for each vmclass definition, add a definition in
    the class dynamic tree using its global id (not its tag).
  Output:
    For each TypeSet, its ISet mapping to its global tags, because we
    need to distinguish marker objects from non-marker objects.

Implementation of Match/Dispatch instructions:
  Input:
    Match :
      xs: List<Imm>
      branches: List<Branch>
      no-branch: Int
    Branch :
      tags: List<TypeSet>
      n: Int
  Output:
    Emitted code for performing the dispatch.
  Assumptions:
    We can assume that the arguments have been placed in the appropriate
    registers and argument slots for the platform.
  Implementation:
    Requires conversion of a typeset to an ISet.
    This can be done using the DynTree implementation, once we
    have finished assigning class tags to all concrete classes.

;============================================================
;=======================================================<DOC>

;============================================================
;=================== StitcherEmitter ========================
;============================================================

public deftype Stitcher
public defmulti emit-tables (s:Stitcher, emitter:CodeEmitter) -> False
public defmulti emitter (s:Stitcher, package:Symbol, emitter:CodeEmitter) -> StitchEmitter
public defmulti stubs (s:Stitcher) -> AsmStubs
defmulti core-fn (s:Stitcher, id:FnId) -> Imm

public deftype StitchEmitter <: CodeEmitter

;============================================================
;=============== Create the Stitcher Tables =================
;============================================================

deftype PackageIds
defmulti global-id (ids:PackageIds, lid:Int) -> Int|False
defmulti set-global-id (ids:PackageIds, lid:Int, gid:Int) -> False

defn global-id! (ids:PackageIds, lid:Int) :
  match(global-id(ids,lid)) :
    (id:Int) : id
    (id:False) : fatal("No global id registered for local id: %_" % [lid])

public defn Stitcher (packages:Collection<VMPackage>, bindings:Bindings|False, stubs:AsmStubs) :
  ;Records
  val global-recs = Vector<Rec>()
  val global-props = Vector<GProps|False>()
  val id-indices = HashTable<RecId,Int>()
  val package-ids = HashTable<Symbol,PackageIds>()

  ;Add a new global record
  defn add-global-record (r:Rec) -> Int :
    val global-id = length(global-props)
    add(global-recs, r)
    add(global-props, false)
    id-indices[id(r)] = global-id
    global-id

  ;Ensure that the following local id in the package
  ;has a reserved global id. Returns its global-id.
  defn ensure-global-id (pkgids:PackageIds, lid:Int) -> Int :
    match(global-id(pkgids, lid)) :
      (gid:Int) :
        gid
      (_:False) :
        val gid = length(global-props)
        add(global-props, false)
        set-global-id(pkgids, lid, gid)
        gid

  ;Set the property of a given local id
  defn set-global-prop (pkgids:PackageIds, lid:Int, p:GProps) :
    val gid = ensure-global-id(pkgids, lid)
    global-props[gid] = p

  ;Initialize record tables
  defn initialize-record-tables () :
    ;Accumulate initializers to run after we populate
    ;exported records.
    val initializers = Vector<(() -> ?)>()
    defn initialize (f:() -> ?) :
      add(initializers, f)      

    ;Initialize package ids
    for packageio in seq(packageio, packages) do :
      val local-ids = IntTable<Int>()
      for e in exports(packageio) do :
        local-ids[n(e)] = add-global-record(rec(e))
      within initialize() :
        for i in imports(packageio) do :
          local-ids[n(i)] = id-indices[id(rec(i))]
      package-ids[package(packageio)] = new PackageIds :
        defmethod global-id (this, lid:Int) :
          get?(local-ids, lid)
        defmethod set-global-id (this, lid:Int, gid:Int) :
          local-ids[lid] = gid
        defmethod print (o:OutputStream, this) :
          val o2 = IndentedStream(o)
          print(o, "PackageIds:")
          lnprint(o2, "original-local-id => assigned-global-id")
          do(lnprint{o2, _}, local-ids)
        
    ;Run initializers
    for init in initializers do :
      init()

  ;Simple properties
  defn initialize-simple-props () :    
    for p in packages do :
      val pkgids = package-ids[package(p)]
      for f in funcs(p) do :
        set-global-prop(pkgids, id(f), CodeProps(unique-id(stubs)))
      for e in extern-defns(p) do :
        set-global-prop(pkgids, fid(e), ExternDefnProps(unique-id(stubs), lbl(e)))
      for e in externs(p) do :
        set-global-prop(pkgids, id(e), ExternProps(name(e)))
      for d in datas(p) do :
        set-global-prop(pkgids, id(d), DataProps(unique-id(stubs)))

  ;Global table
  val global-entries = Vector<GlobalTableEntry>()  
  defn initialize-global-table () :
    ;Retrieve the alignment in bytes for the global
    defn global-alignment (g:VMGlobal) -> Int :
      if size(g) >= 8 : 8
      else : size(g)

    ;Track the offset since the beginning of the table.
    val offset-counter = Counter(0)

    ;For each package
    for p in packages do :
      ;Retrieve the ids in the package
      val pkgids = package-ids[package(p)]

      ;Construct the debug info table
      val debug-info = to-inttable<VMDebugInfo> $
        for e in entries(debug-table(p)) seq :
          id(e) => e

      ;Add padding to the global in the package
      val [padded-globals, _] = pad(global-alignment, size, globals(p), 8)

      ;Add entries for each global.
      for g in padded-globals do :
        match(g) :
          ;If it's a padding.
          (g:Padding) :
            ;Increment the offset.
            next(offset-counter, size(g))
          ;Otherwise, if it is a global.            
          (g:VMGlobal) :
            ;Retrieve the offset of the global (and increment the offset counter).
            val offset = next(offset-counter, size(g))

            ;Store the offset in the property table.            
            set-global-prop(pkgids, id(g), GlobalProps(offset))
            
            ;Add the starting marker for the global
            val [name, info] = match(get?(debug-info, id(g))) :
              (dbg:VMDebugInfo) : [name(dbg), info(dbg)]
              (f:False) : [false, false]
            add(global-entries, StartOfGlobal(offset, name, info))

            ;Store the roots in the table.
            for r in roots(g) do :
              fatal("Unaligned global reference") when offset % 8 != 0
              add(global-entries, GlobalRoot(offset + r * 8))
              
      ;End of table
      add(global-entries, EndOfGlobals(value(offset-counter)))

  ;Constant pool
  val const-pool = ConstantPool()
  defn initialize-const-table () :    
    for p in packages do :
      val pkgids = package-ids[package(p)]
      defn resolve-code-ids (v:VMValue) -> VMValue :
        defn to-global (x:CodeId) : CodeId(global-id!(pkgids, id(x)))
        match(v) :
          (v:List) : map(resolve-code-ids, v)
          (v:VMTypeObject) : VMTypeObject(to-global(id(v)))
          (v:VMClosure) : VMClosure(to-global(id(v)))
          (v) : v              
      for c in consts(p) do :
        val v* = resolve-code-ids(value(c))
        val c* = intern(const-pool, v*)
        set-global-prop(pkgids, id(c), ConstProps(id(id(c*))))

  ;Class properties
  val class-tree = DynTree()
  val class-table = Vector<VMClass>()
  var num-concrete-classes:Int 
  
  defn initialize-class-props () :
    ;Compute mapping from global-ids to core tags.
    ;Each entry, gid => tag, means that the type with id 'gid'
    ;should be represented using tag 'tag'.
    val core-tag-table = IntTable<Int>()
    for entry in [CORE-FALSE-ID => FALSE-TYPE
                  CORE-TRUE-ID => TRUE-TYPE
                  CORE-BYTE-ID => BYTE-TYPE
                  CORE-CHAR-ID => CHAR-TYPE
                  CORE-INT-ID => INT-TYPE
                  CORE-FLOAT-ID => FLOAT-TYPE
                  CORE-STACK-ID => STACK-TYPE
                  CORE-FN-ID => FN-TYPE
                  CORE-TYPE-ID => TYPE-TYPE
                  CORE-LIVENESS-TRACKER-ID => LIVENESS-TRACKER-TYPE] do :
      val gid = id-indices[key(entry)]
      core-tag-table[gid] = value(entry)

    ;Resolve all parent and child links to their global ids.
    defn resolve (pkgids:PackageIds, c:VMClass) :
      defn gid (n:Int) : global-id!(pkgids, n)
      defn gids (ns:Tuple<Int>) : map(gid, ns)
      match(c) :
        (c:VMArrayClass) : sub-id(sub-parents(c, gids(parents(c))), gid(id(c)))
        (c:VMLeafClass) : sub-id(sub-parents(c, gids(parents(c))), gid(id(c)))
        (c:VMAbstractClass) : VMAbstractClass(gid(id(c)), gids(parents(c)), gids(children(c)))

    ;Categorize class definitions
    val builtin-classes = Array<VMArrayClass|VMLeafClass>(NUM-BUILTIN-CONCRETE-TYPES)
    val concrete-classes = Vector<VMArrayClass|VMLeafClass>()
    val abstract-classes = Vector<VMAbstractClass>()
    for p in packages do :
      val pkgids = package-ids[package(p)]
      for c in classes(p) do :
        val cid = ensure-global-id(pkgids, id(c))
        match(resolve(pkgids, c)) :
          (c:VMArrayClass|VMLeafClass) :
            match(get?(core-tag-table,cid)) :
              (tag:Int) : builtin-classes[tag] = c
              (_:False) : add(concrete-classes, c)             
          (c:VMAbstractClass) :
            add(abstract-classes, c)
    num-concrete-classes = length(builtin-classes) + length(concrete-classes)
    add-all(class-table, cat-all([builtin-classes, concrete-classes, abstract-classes]))

    ;Build class tree
    add(class-tree, node-states) where :
      val node-states = for c in class-table seq :
        match(c) :
          (c:VMArrayClass|VMLeafClass) : NodeState(id(c), parents(c), [], true)
          (c:VMAbstractClass) : NodeState(id(c), parents(c), children(c), false)

    ;Determine whether a class is represented as a marker
    val unique-id = id-indices[CORE-UNIQUE-ID]
    defn marker? (c:VMClass) :
      match(c:VMLeafClass) :
        val no-fields = size(c) == 0
        val unique = parent?(class-tree, id(c), unique-id)
        no-fields and not unique

    ;Add all classes to props table and assign tags for
    ;each of them.
    for (c in class-table, tag in 0 to false) do :
      global-props[id(c)] = ClassProps(tag, marker?(c))

  ;Method Table
  val method-table = IntListTable<Branch>()
  defn initialize-method-table () :
    for p in packages do :
      val pkgids = package-ids[package(p)]
      for m in methods(p) do :
        val multi* = global-id!(pkgids, multi(m))
        val fid* = global-id!(pkgids, fid(m))
        val lbl = lbl(global-props[fid*] as CodeProps)
        val types* = map(resolve{pkgids, _}, types(m))
        val branch* = Branch(to-list(types*), M(lbl))
        add(method-table, multi*, branch*)

  ;Resolve a package-local TypeSet to use global ids
  defn resolve (pkgids:PackageIds, t:TypeSet) -> TypeSet :
    let loop (t:TypeSet = t) :
      match(t) :
        (t:TopType) : t
        (t:AndType) : AndType?(seq(loop,types(t)))
        (t:OrType) : OrType?(seq(loop,types(t)))
        (t:SingleType) : SingleType(global-id!(pkgids,type(t)))

  ;Create stackmap table
  defn stackmap-hash (x:StackMap) :
    hash $ [size(x), indices(x)]
  val stackmap-table = HashTable<StackMap,Int>(stackmap-hash, equal?)
  val stackmaps = Vector<StackMap>()
  defn stackmap-index (m:StackMap) :
    if not key?(stackmap-table,m) :
      val i = length(stackmaps)
      add(stackmaps, m)
      stackmap-table[m] = i
    stackmap-table[m]

  ;Accumulate info table
  val trace-table = Vector<KeyValue<Int,StackTraceEntry>>()
  defn add-trace-entry (n:Int, entry:StackTraceEntry) :
    add(trace-table, n => entry)

  ;Create a function-local emitter
  defn emitter (package:Symbol, code-emitter:CodeEmitter) :
    val pkgids = package-ids[package]
    val label-table = IntTable-init<Int>(unique-id{stubs})

    ;Link an immediate, remove all non-handled items.
    defn link (x:Imm) :
      match(x) :
        (x:LocalMem) :
          Mem(label-table[n(x)],0)
        (x:TagImm) : 
          tag-imm(global-id!(pkgids, n(x)), marker?(x))
        (x:StackMap) :
          IntImm(stackmap-index(x))
        (x:LinkId) :
          val gid = global-id!(pkgids, id(x))
          match(global-props[gid]) :
            (p:CodeProps) :
              Mem(lbl(p), 0)
            (p:ExternProps) :
              ExMem(exlbl(p), 0)
            (p:ExternDefnProps) :
              Mem(lbl(p), 0)
            (p:DataProps) :
              Mem(lbl(p), 0)
            (p:ConstProps) :
              Mem(const-table(stubs), index(p) * 8)
            (p:GlobalProps) :
              Mem(globals(stubs), offset(p))
        (x) :
          x

    ;Return the numerical tag for the given global id
    defn tag-imm (gid:Int, marker?:True|False) :
      val props = global-props[gid] as ClassProps
      if marker? : INT(tag(props) << 3 + 2)
      else : INT(tag(props))

    ;Resolve a typeset from package ids to global ids
    defn resolve-branch (b:Branch) :
      val tags* = map(resolve{pkgids, _}, tags(b))
      Branch(tags*, dst(b))

    ;Convert branches into branch table
    defn to-dag (ts:Seqable<Seqable<TypeSet>>, topological?:True|False) :
      val bs = to-branches(ts, all-children{class-tree, _})
      val btable = BranchTable(bs, non-leaves(class-tree))
      compute-dispatch-dag(btable, topological?)

    ;Emit code for producing dag (args is a helper)
    defn emit-dag (dag:Dag, targets:Tuple<Imm>, default-target:Imm, amb-target:Imm|False, args:Tuple<Imm>) :
      ;Is the given type a marker?
      ;Is it both empty, and not a subtype of Unique?
      defn marker? (x:Int) :
        /marker?(global-props[x] as ClassProps)

      ;Calculate labels for all entries
      val labels = map(M{unique-id(stubs)}, entries(dag))
      defn to-label (v:Int|Soln) -> Imm :
        match(v) :
          (v:Int) : labels[v]
          (v:NoSoln) : default-target
          (v:AmbSoln) : amb-target as Imm
          (v:UniqueSoln) : targets[index(v)]

      ;Emit a single dag entry
      defn emit-dag-entry (dag-e:DagEntry) :
        if empty?(entries(dag-e)) :
          E $ Goto(to-label(default(dag-e)))
        else :
          ;Categorize branches
          val prim-targets = Vector<KeyValue<Int,Imm>>()
          val marker-targets = Vector<KeyValue<Int,Imm>>()
          val ref-targets = Vector<KeyValue<Int,Imm>>()
          val default-target = to-label(default(dag-e))
          for entry in entries(dag-e) do :
            val tgt = to-label(value(entry))
            for x in values(key(entry))  do :
              if x == id-indices[CORE-BYTE-ID] : add(prim-targets, x => tgt)
              else if x == id-indices[CORE-CHAR-ID] : add(prim-targets, x => tgt)
              else if x == id-indices[CORE-INT-ID] : add(prim-targets, x => tgt)
              else if x == id-indices[CORE-FLOAT-ID] : add(prim-targets, x => tgt)
              else if marker?(x) : add(marker-targets, x => tgt)
              else : add(ref-targets, x => tgt)              

          ;Registers
          val OBJ = R0
          val BITS = R1
          val TAG = R1

          ;Load object
          val object = match(args[depth(dag-e)]) :
            (a:Reg) :
              a
            (a:Mem) :
              E $ LoadL(OBJ, a)
              OBJ

          ;Test bits
          val marker-branches = unique-id(stubs)
          val ref-branches = unique-id(stubs)
          val prim-targets? = not empty?(prim-targets)
          val marker-targets? = not empty?(marker-targets)
          val ref-targets? = not empty?(ref-targets)

          ;Checking for primitives or references requires knowing the tag bits.
          ;So create the tag bits if we have either case.
          if prim-targets? or ref-targets? :
            E $ AndL(BITS, object, INT(7))

          ;Jump to the appropriate primitive target if the object
          ;is one of the given primitives.
          for entry in prim-targets do :
            val x = key(entry)
            val target = value(entry)
            val tagbits =
              if x == id-indices[CORE-BYTE-ID] : INT(3)
              else if x == id-indices[CORE-CHAR-ID] : INT(4)
              else if x == id-indices[CORE-INT-ID] : INT(0)
              else if x == id-indices[CORE-FLOAT-ID] : INT(5)
              else : fatal("Not a primitive type")
            E $ BreakL(target, EqOp(), BITS, tagbits)

          ;Skip the reference branches if the object is not a reference.
          val label-after-refs = M(marker-branches) when marker-targets?
                            else default-target
          if ref-targets? : E $ BreakL(label-after-refs, NeOp(), BITS, INT(1))
          else if not marker-targets? : E $ Goto(label-after-refs)

          ;Jump to the appropriate reference branches if the object
          ;is one of the given references
          if ref-targets? :
            defn ref-tree () :
              BinaryNode $ for e in ref-targets seq :
                val header = tag-imm(key(e), false)
                (value(header) as Int) => value(e)
            E $ Label(ref-branches)
            E $ LoadL(TAG, object, -1)
            let loop (tree:BinaryNode<Imm> = ref-tree()) :
              match(tree) :
                (tree:InnerNode<Imm>) :
                  val left-tree = unique-id(stubs)
                  E $ BreakL(M(left-tree), UleOp(), TAG, IntImm(value(tree)))
                  loop(right(tree))
                  E $ Label(left-tree)
                  loop(left(tree))
                (tree:LeafNode<Imm>) :
                  for e in entries(tree) do :
                    val x = key(e)
                    val target = value(e)
                    E $ BreakL(target, EqOp(), TAG, IntImm(x))
                  E $ Goto(default-target)

          ;Jump to the appropriate marker branches if the object is one
          ;of the given marker branches.
          if marker-targets? :
            defn marker-tree () :
              BinaryNode $ for e in marker-targets seq :
                val header = tag-imm(key(e), true)
                (value(header) as Int) => value(e)
            E $ Label(marker-branches)
            let loop (tree:BinaryNode<Imm> = marker-tree()) :
              match(tree) :
                (tree:InnerNode<Imm>) :
                  val left-tree = unique-id(stubs)
                  E $ BreakL(M(left-tree), UleOp(), object, IntImm(value(tree)))
                  loop(right(tree))
                  E $ Label(left-tree)
                  loop(left(tree))
                (tree:LeafNode<Imm>) :
                  for e in entries(tree) do :
                    val x = key(e)
                    val target = value(e)
                    E $ BreakL(target, EqOp(), object, IntImm(x))
                  E $ Goto(default-target)

      ;Emit all entries
      for (e in entries(dag), l in labels) do :
        E $ Label(n(l))
        emit-dag-entry(e)

    ;Emit code for producing typeof
    defn emit-typeof (x:Loc, y:Imm, arg:Arg) :
      match(arg) :
        ;Return true always
        (arg:Top) :
          E $ SetL(x, INT(1))
        ;Return false
        (arg:Nums) :
          ;Is the given type a marker?
          defn marker? (x:Int) :
            /marker?(global-props[x] as ClassProps)

          ;Categorize branches
          val prims = Vector<Int>()
          val markers = Vector<Int>()
          val refs = Vector<Int>()
          for x in values(arg) do :
            if x == id-indices[CORE-BYTE-ID] : add(prims, x)
            else if x == id-indices[CORE-CHAR-ID] : add(prims, x)
            else if x == id-indices[CORE-INT-ID] : add(prims, x)
            else if x == id-indices[CORE-FLOAT-ID] : add(prims, x)
            else if marker?(x) : add(markers, x)
            else : add(refs, x)              

          ;Registers
          val OBJ = R0
          val BITS = R1
          val TAG = R1

          ;Labels
          val pass-lbl = unique-id(stubs)
          val end-lbl = unique-id(stubs)

          ;Load object
          E $ SetL(OBJ, y)

          ;Default is 0
          E $ SetL(x, INT(0))

          ;Test bits
          val marker-branches = unique-id(stubs)
          val ref-branches = unique-id(stubs)
          ;See above for case-based optimization
          val prim-targets? = not empty?(prims)
          val marker-targets? = not empty?(markers)
          val ref-targets? = not empty?(refs)

          if prim-targets? or ref-targets? :
            E $ AndL(BITS, OBJ, INT(7))
            
          for x in prims do :
            val tagbits =
              if x == id-indices[CORE-BYTE-ID] : INT(3)
              else if x == id-indices[CORE-CHAR-ID] : INT(4)
              else if x == id-indices[CORE-INT-ID] : INT(0)
              else if x == id-indices[CORE-FLOAT-ID] : INT(5)
              else : fatal("Not a primitive type")
            E $ BreakL(M(pass-lbl), EqOp(), BITS, tagbits)

          ;Skip the reference branches if the object is not a reference.
          val label-after-refs = M(marker-branches) when marker-targets?
                            else M(end-lbl)
          if ref-targets? : E $ BreakL(label-after-refs, NeOp(), BITS, INT(1))
          else if not marker-targets? : E $ Goto(label-after-refs)

          ;Ref branches
          if ref-targets?:
            E $ Label(ref-branches)
            E $ LoadL(TAG, OBJ, -1)
            for x in refs do :
              E $ BreakL(M(pass-lbl), EqOp(), TAG, tag-imm(x, false))
            E $ Goto(M(end-lbl))

          ;Marker branches
          if marker-targets?: 
            E $ Label(marker-branches)
            for x in markers do :
              E $ BreakL(M(pass-lbl), EqOp(), OBJ, tag-imm(x,true))
            E $ Goto(M(end-lbl))

          ;Pass and failure labels
          E $ Label(pass-lbl)
          E $ SetL(x, INT(1))
          E $ Label(end-lbl)

    ;Retrieve the arguments to a dag for a match/dispatch statement
    defn dag-args (dag:Dag, xs:List<Imm>) :
      val reg-args = xs as List<Reg>
      val mem-args = seq(Mem{registers(stubs), _}, 0 to false by 8)
      val all-args = cat(reg-args, mem-args)
      to-tuple(take-n(depth(dag), all-args))

    defn dag-method-args (dag:Dag, num-header-args:Int) :
      val nregs = length(call-regs(backend(stubs)))
      val reg-args = for i in num-header-args to nregs seq :
        R(call-regs(backend(stubs))[i])
      val mem-args = seq(Mem{registers(stubs), _}, 0 to false by 8)
      val all-args = cat(reg-args, mem-args)
      to-tuple(take-n(depth(dag), all-args))      

    ;Return new code emitter
    defn E (i:Ins) : emit(code-emitter, i)
    
    new StitchEmitter :
      defmethod emit (this, i:Ins) :
        match(map(link,i)) :
          (i:LinkLabel) :
            val gid = global-id!(pkgids, id(i))
            match(global-props[gid]) :
              (p:CodeProps) :
                E $ Label(lbl(p))
              (p:ExternDefnProps) :
                val exlbl = exlbl(p)
                E $ Label(lbl(p))
                match(exlbl:Symbol) :
                  E $ ExLabel(exlbl)
          (i:Label) :
            val n* = label-table[n(i)]
            E $ Label(n*)
            match(trace-entry(i)) :
              (entry:StackTraceEntry) : add-trace-entry(n*, entry)
              (entry:False) : false
          (i:Match) :
            val branches* = map(resolve-branch, branches(i))
            val dag = to-dag(seq(tags,branches*), false)
            emit-dag(dag, to-tuple(seq(dst,branches*)), no-branch(i), false, dag-args(dag,xs(i)))
          (i:Dispatch) :
            val branches* = map(resolve-branch, branches(i))
            val dag = to-dag(seq(tags,branches*), true)
            emit-dag(dag, to-tuple(seq(dst,branches*)), no-branch(i), amb-branch(i), dag-args(dag,xs(i)))
          (i:MethodDispatch) :
            val multi-id = global-id!(pkgids, multi(i))
            val branches = method-table[multi-id]
            val dag = to-dag(seq(tags,branches), true)
            emit-dag(dag, to-tuple(seq(dst,branches)), no-branch(i), amb-branch(i), dag-method-args(dag,num-header-args(i)))
          (i:UnaOp) :
            match(op(i)) :
              (op:TypeofOp) :
                val tag* = resolve(pkgids, tag(op))
                val arg = to-arg(tag*, all-children{class-tree, _})
                emit-typeof(x(i), y(i), arg)
              (op) : E(i)
          (i) : E(i)    
      defmethod unique-label (this) :
        unique-label(code-emitter)

  ;Initialization function
  defn emit-initialization-function (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)
    val frame-size = 16
    val stackmap = stackmap-index(StackMap(frame-size, []))
    E $ Comment("Program Initialization Function")
    E $ Label(init-function(stubs))
    E $ StoreL(RSP, INT(stackmap), 8)    
    for p in packages do :
      val pkgids = package-ids[package(p)]
      val init = init(p)
      match(init:Int) :
        E $ AddL(RSP, RSP, INT(frame-size + 8))
        val gid = global-id!(pkgids, init)
        val code-id = lbl(global-props[gid] as CodeProps)
        E $ Call(M(code-id))
        E $ SubL(RSP, RSP, INT(frame-size + 8))
    E $ SetL(R0, INT(0))
    E $ Return()

  ;Emit global table
  defn emit-global-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)

    ;Human-readable description of global
    defn comment-string (r:StartOfGlobal) -> String :
      val name = match(name(r)) :
        (name:False) : "Unnamed global"
        (name:String) : name
      val info-str = match(info(r)) :
        (info:FileInfo) : " at %_" % [info]
        (info:False) : ""
      val location-str = " (L%_ + %_)" % [globals(stubs), offset(r)]
      string-join([name, info-str, location-str])        
    
    ;Memory for globals
    E $ Comment("Globals Table")
    E $ DefData()
    E $ Label(globals(stubs))

    ;Emit entries for each global
    defn DefSpace? (sz:Int) :
      E(DefSpace(sz)) when sz > 0
    var current-size:Int = 0
    for r in global-entries do :
      match(r) :
        (r:StartOfGlobal) :
          DefSpace?(offset(r) - current-size)
          E $ Comment(comment-string(r))
          current-size = offset(r)
        (r:GlobalRoot) :
          DefSpace?(offset(r) - current-size)
          E $ DefLong(to-long(-1 << 3 + 2))
          current-size = offset(r) + 8
        (r:EndOfGlobals) :
          DefSpace?(size(r) - current-size)
          
    ;End of memory for globals
    E $ DefText()
    E $ Comment("End of Globals Table")

    ;Memory for global roots
    val roots = to-tuple $ filter-by<GlobalRoot>(global-entries)
    E $ Comment("Global Root Table")
    E $ DefData()
    E $ Label(global-root-table(stubs))
    E $ Comment(to-string("%_ roots in total" % [length(roots)]))
    E $ DefInt(length(roots))
    E $ Comment("Indices of roots")
    for r in roots do :
      E $ DefInt(offset(r) / 8)
    E $ DefText()
    E $ Comment("End of Global Root Table")

  ;Emit constant table
  defn emit-const-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)
    val consts = consts(const-pool)

    E $ Comment("Constant Table")
    E $ DefData()
    E $ Label(const-table(stubs))
    for v in consts do :
      E $ DefLong(to-long(-1 << 3 + 2))
    E $ DefText()
    E $ Comment("End of Constant Table")

    ;Create the constant writer.
    ;Align it with an initial alignment of 4 bytes because
    ;the first 4 bytes are used to store the number of constants.
    val writer = AlignedConstWriter{_, 4} $
      new ConstWriter :
        defmethod write (this, b:Byte) :
          E $ DefByte(b)
        defmethod write (this, i:Int) :
          E $ DefInt(i)
        defmethod write (this, l:Long) :
          E $ DefLong(l)
        defmethod write (this, cid:CodeId) :
          val props = global-props[id(cid)] as CodeProps
          E $ DefLabel(lbl(props))
    
    E $ Comment("Serialized Constants")
    E $ DefData()
    E $ Label(const-mem(stubs))
    E $ DefInt(length(consts))
    for v in consts do :
      write-const(writer, v)
    E $ DefText()
    E $ Comment("End of Serialized Constants")

  ;Emit data table
  defn emit-data-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)
    E $ Comment("Data Tables")
    for p in packages do :
      val pkgids = package-ids[package(p)]
      for d in datas(p) do :
        val props = global-props[global-id!(pkgids, id(d))] as DataProps
        E $ DefData()
        E $ Label(lbl(props))
        E $ DefBytes(data(d))
        E $ DefText()
    E $ Comment("End of Data Tables")

  ;Emit class table
  defn emit-class-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)

    ;Emit packed class table
    E $ Comment("Class Table")
    E $ DefData()
    E $ Label(/class-table(stubs))
    pack(class-records, packer) where :
      val class-records = to-tuple $
        for (c in class-table, i in 0 to num-concrete-classes) seq :
          match(c) :
            (c:VMLeafClass) :
              LeafClassRecord(i, name(c), size(c), roots(c))
            (c:VMArrayClass) :
              ArrayClassRecord(i, name(c), base-size(c), item-size(c), base-roots(c), item-roots(c))
      val packer = new StaticPacker :
        defmethod make-label (this) : unique-id(stubs)
        defmethod emit-comment (this, str:String) : E $ Comment(str)
        defmethod emit-label (this, id:Int) : E $ Label(id)
        defmethod emit-pointer-to-label (this, id:Int) : E $ DefLabel(id)
        defmethod emit (this, x:Int) : E $ DefInt(x)
        defmethod emit (this, x:String) : E $ DefString(x)
    E $ DefText()
    E $ Comment("End of Class Table")

  ;Emit stackmap table
  defn emit-stackmap-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)
    val map-lbls = to-tuple $
      repeatedly(unique-id{stubs}, length(stackmaps))
    E $ Comment("Stackmap Table")  
    E $ DefData()
    E $ Label(/stackmap-table(stubs))
    for lbl in map-lbls do :
      E $ DefLabel(lbl)
    for (m in stackmaps, lbl in map-lbls) do :
      E $ Label(lbl)
      E $ DefInt(size(m))
      E $ DefInt(length(indices(m)))
      for i in indices(m) do :
        E $ DefInt(i)
    E $ DefText()
    E $ Comment("End of Stackmap Table")  

  ;Emit info table
  defn emit-info-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)
    val string-lbls = HashTable-init<String,Int>(unique-id{stubs})
    E $ Comment("File Information Table")  
    E $ DefData()
    E $ Label(stack-trace-table(stubs))
    E $ DefLong(to-long(length(trace-table)))
    for entry in trace-table do :
      val [lbl, trace-entry] = [key(entry), value(entry)]
      E $ DefLabel(lbl)
      E $ DefLabel(string-lbls[to-string(package(trace-entry))])
      match(signature(trace-entry)) :
        (s:String) : E $ DefLabel(string-lbls[s])
        (f:False) : E $ DefLong(0L)
      match(info(trace-entry)) :
        (info:FileInfo) :
          E $ DefLabel(string-lbls[filename(info)])
          E $ DefInt(line(info))
          E $ DefInt(column(info))
        (f:False) :
          E $ DefLong(0L)        
          E $ DefInt(0)
          E $ DefInt(0)
    E $ DefText()
    E $ Comment("End of File Information Table")  

    E $ Comment("String Table for Filenames")  
    E $ DefData()
    for entry in string-lbls do :
      val [s, n] = [key(entry), value(entry)]
      E $ Label(n)
      E $ DefString(s)
    E $ DefText()
    E $ Comment("End of String Table for Filenames")  

  defn emit-export-table (code-emitter: CodeEmitter) -> False:
    defn E (i:Ins) : emit(code-emitter, i)

    ; First collect all of the `extern defn` symbols
    val defns = filter-by<Symbol>(
      for package in packages seq-cat :
        seq(lbl, extern-defns(package)))

    ; If we have any, mark that we're now in a .drectve section, and then for
    ; each symbol, put out a string directing the assembler to export it
    if not empty?(defns):
      E $ DefDirectives()
      for def in defns do :
        E $ DefExportLabel(def)

  ;Initialize record tables
  initialize-record-tables()
  initialize-simple-props()
  initialize-global-table()
  initialize-const-table()
  initialize-class-props()
  initialize-method-table()

  ;Return new Stitcher
  new Stitcher :
    defmethod emitter (this, package:Symbol, code-emitter:CodeEmitter) :
      emitter(package, code-emitter)
    defmethod emit-tables (this, code-emitter:CodeEmitter) :
      emit-initialization-function(code-emitter)
      emit-global-table(code-emitter)
      emit-const-table(code-emitter)
      emit-data-table(code-emitter)
      emit-class-table(code-emitter)
      emit-stackmap-table(code-emitter)
      emit-info-table(code-emitter)
      emit-extern-table(code-emitter, packages, bindings, stubs)
      ; On Windows, create an EXPORTS table for `extern defn` symbols
      ; so they can be dynamically imported by other executables
      if generate-export-directives-table?(backend(stubs)) :
        emit-export-table(code-emitter)
    defmethod stubs (this) :
      stubs
    defmethod core-fn (this, id:FnId) :
      val gid = id-indices[id]
      val lbl = lbl(global-props[gid] as CodeProps)
      M(lbl)
  
deftype GProps
defstruct CodeProps <: GProps :
  lbl:Int
defstruct ExternProps <: GProps :
  exlbl:Symbol
defstruct ExternDefnProps <: GProps :
  lbl:Int
  exlbl:Symbol|False
defstruct GlobalProps <: GProps :
  offset: Int
defstruct DataProps <: GProps :
  lbl:Int
defstruct ConstProps <: GProps :
  index:Int
defstruct ClassProps <: GProps :
  tag: Int
  marker?: True|False

;============================================================
;==================== Extern Table ==========================
;============================================================

;Emit the extern table.
defn emit-extern-table (emitter:CodeEmitter,
                        packages:Collection<VMPackage>,
                        bindings:Bindings|False,
                        stubs:AsmStubs) -> False :
  ;Helper: Emit an instruction.
  defn E (i:Ins) : emit(emitter, i)

  ;Track all the strings required for the extern labels.
  val string-lbls = HashTable-init<String,Int>(unique-label{emitter})

  ;Compute the list of all extern labels.
  val extern-list = all-extern-labels(packages, bindings)

  ;Externs
  ;Emit placeholder data
  E $ Comment("Extern Table")  
  E $ DefData()
  E $ Label(extern-table(stubs))
  E $ Comment(to-string("%_ Externs in total" % [length(extern-list)])  )
  E $ DefLong(to-long(length(extern-list)))
  E $ Comment("List of Externs")  
  for e in extern-list do :
    E $ DefLabel(string-lbls[to-string(e)])
    E $ DefLong(0L)
  E $ DefText()
  E $ Comment("End of Extern Table")  

  ;Extern Defns
  E $ Comment("Extern Defn Table")
  E $ DefData()
  E $ Label(extern-defn-table(stubs))
  match(bindings:Bindings) :
    val num-externs = length(extern-defns(bindings))
    E $ Comment(to-string("%_ Extern Defns in total" % [num-externs]))
    E $ DefLong(to-long(num-externs))
    for (def in extern-defns(bindings), i in 0 to false) do :
      E $ DefLabel(string-lbls[to-string(lbl(def))])
      E $ DefLong(0L)
  else :
    E $ Comment("No Extern Defns")
    E $ DefLong(0L)    
  E $ DefText()
  E $ Comment("End of Extern Defn Table")

  ;Extern Defn Stubs
  match(bindings:Bindings) :
    E $ Comment("Extern Defn Stubs")
    val free-regs = free-regs([CallCArgRegs, CallCPreservedRegs], backend(stubs))
    val TMP = free-regs[0]
    for (def in extern-defns(bindings), i in 0 to false) do :
      E $ ExLabel(lbl(def))
      val offset = 8 + i * 16 + 8
      E $ LoadL(TMP, M(extern-defn-table(stubs)), offset)
      E $ Goto(TMP)
    
  ;Emit string labels
  E $ Comment("String Table for Externs")
  E $ DefData()
  for entry in string-lbls do :
    val [s, n] = [key(entry), value(entry)]
    E $ Label(n)
    E $ DefString(s)
  E $ DefText()
  E $ Comment("End of String Table for Externs")
  
  ;Emit initializing routine
  E $ Comment("Initialization Function for Extern Table")
  E $ Label(init-extern-table(stubs))
  for (e in extern-list, i in 0 to false) do :
    E $ SetL(R1, ExMem(e, 0))
    E $ StoreL(M(extern-table(stubs)), R1, 8 + 16 * i + 8)
  E $ Goto(R0)

;Retrieve all the externs in the program.
;Includes the all the binding externs, and program externs.
defn all-extern-labels (packages:Collection<VMPackage>,
                        bindings:Bindings|False) -> Tuple<Symbol> :
  val all-externs = HashSet<Symbol>()
  for p in packages do :
    add-all(all-externs, seq(name, externs(p)))  
  match(bindings:Bindings) :
    add-all(all-externs, seq(lbl, externs(bindings)))
    add-all(all-externs, seq(lbl, extern-defns(bindings)))
  to-tuple(all-externs)

;============================================================
;===================== Runtime Stubs ========================
;============================================================

public defn emit-stubs (s:Stitcher, emitter:CodeEmitter) :
  emit(emitter, DefText())
  compile-extend-stack-stub(s, emitter)
  compile-collect-garbage-stub(s, emitter)
  compile-c-trampoline-stub(backend(stubs(s)), emitter)
  compile-c-extern-trampoline-stub(backend(stubs(s)), emitter)
  compile-c-extern-dynamic-code-template(backend(stubs(s)), emitter)

;<doc>=======================================================
;==================== Stack Extension =======================
;============================================================

Extend Stack Stub:
  Input:
    R0 is return address.
    R1 is required stack size: (must satisfy: RSP + R1 <= stack-limit)
    RSP still points to caller's stack frame.
  Responsibilities:
    Save the current registers.
    Save the current stack parameters.
      (Save RSP)
      (Save return address)
    Switch to using the system stack.
      (Swap current stack with system stack)
      (Swap registers with system registers)
    Load the system stack parameters
      (Load RSP)
      (Load stack-limit)
    Call extend-stack:
      (argument 0 (unused) = ---)
      (argument 1 (arity) = 1)
      (argument 2 (size) = size)
      (call)
    Switch back to using the program stack.
      (Null the system stack pointer)
      (Swap current stack with system stack)
      (Swap registers with system registers)
    Load the stack parameters
      (Load RSP)
      (Load stack-limit)
    Restore current registers.
    Continue from stack.pc.

  Pseudocode:
    save R2 ... Rn
    
    current-stack.pc = return address (R0)
    current-stack.sp = RSP
      (use TMP:R2 for current-stack)
      TMP = [current-stack]
      TMP.pc = R0
      TMP.sp = RSP
      
    swap [current-stack] with [system-stack]
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [current-stack]
      TMP2 = [system-stack]
      [current-stack] = TMP2
      [system-stack] = TMP

    swap [registers] with [system_registers]
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [registers]
      TMP2 = [system-registers]
      [registers] = TMP
      [system-registers] = TMP2

    RSP = current-stack.frames
    stack-limit = current-stack.frames + current-stack.size
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [current-stack]
      RSP = TMP.frames
      TMP2 = TMP.size
      TMP2 += RSP
      [stack-limit] = TMP2

    (use size:R1)
    R3 = 1
    R4 = size
    
    RSP += 8
    call extend-stack
    (RSP -= 8) (Elided: Not used again)
    
    current-stack.stack-pointer = null
      (use TMP:R2)
      TMP = [current-stack]
      TMP.stack-pointer = null

    swap [current-stack] with [system-stack]
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [current-stack]
      TMP2 = [system-stack]
      [current-stack] = TMP2
      [system-stack] = TMP

    swap [registers] with [system_registers]
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [registers]
      TMP2 = [system-registers]
      [registers] = TMP
      [system-registers] = TMP2

    RSP = current-stack.sp
    stack-limit = current-stack.frames + current-stack.size
      (use TMP:R1)
      (use TMP2:R3)
      TMP = [current-stack]
      TMP2 = TMP.frames
      TMP = TMP.size
      TMP += TMP2
      [stack-limit] = TMP
      TMP = [current-stack]
      RSP = TMP.sp

    restore R2 ... Rn
    
    goto current-stack.pc
      (use TMP:R1)
      TMP = [current-stack]
      TMP = TMP.pc
      goto TMP

;============================================================
;=======================================================<doc>

defn compile-extend-stack-stub (stitcher:Stitcher, emitter:CodeEmitter) :
  val stubs = stubs(stitcher)
  val backend = backend(stubs)
  defn E (i:Ins) : emit(emitter, i)
  
  defn swap (r1:Reg, m1:Mem, r2:Reg, m2:Mem) :
    E $ LoadL(r1, m1)
    E $ LoadL(r2, m2)
    E $ StoreL(m1, r2)
    E $ StoreL(m2, r1)

  ;Compute stack offsets
  val stack-offset-counter = Counter(-1 + 8)
  val size-offset = next(stack-offset-counter, 8)
  val frames-offset = next(stack-offset-counter, 8)
  val sp-offset = next(stack-offset-counter, 8)
  val pc-offset = next(stack-offset-counter, 8)

  E $ Label(extend-stack(stubs))

  ;save R2 ... Rn
  for (r in call-regs(backend), loc in saved-regs(stubs)) do :
    E $ StoreL(M(loc), R(r))
  for (r in call-fregs(backend), loc in saved-fregs(stubs)) do :
    E $ StoreD(M(loc), F(r))

  ;current-stack.pc = return address (R0)
  ;current-stack.sp = RSP
  let :
    val TMP = R2
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ StoreL(TMP, R0, pc-offset)
    E $ StoreL(TMP, RSP, sp-offset)

  ;swap [current-stack] with [system-stack]
  ;swap [registers] with [system_registers]
  swap(R2, M(current-stack(stubs)), R3, M(system-stack(stubs)))  
  swap(R2, M(registers(stubs)), R3, M(system-registers(stubs)))

  ;RSP = current-stack.frames
  ;stack-limit = current-stack.frames + current-stack.size
  let :
    val TMP = R2
    val TMP2 = R3
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(RSP, TMP, frames-offset)
    E $ LoadL(TMP2, TMP, size-offset)
    E $ AddL(TMP2, TMP2, RSP)
    E $ StoreL(M(stack-limit(stubs)), TMP2)

  ;Call extend stack
  E $ SetL(R3, INT(1))
  E $ SetL(R4, R1)
  E $ AddL(RSP, RSP, INT(8))
  E $ Call(core-fn(stitcher, CORE-EXTEND-STACK-ID))

  ;current-stack.stack-pointer = null
  let :
    val TMP = R2
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ StoreL(TMP, INT(0), sp-offset)

  ;swap [current-stack] with [system-stack]
  ;swap [registers] with [system_registers]
  swap(R2, M(current-stack(stubs)), R3, M(system-stack(stubs)))  
  swap(R2, M(registers(stubs)), R3, M(system-registers(stubs)))  

  ;RSP = current-stack.sp
  ;stack-limit = current-stack.frames + current-stack.size
  let :
    val TMP = R1
    val TMP2 = R3
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(TMP2, TMP, frames-offset)
    E $ LoadL(TMP, TMP, size-offset)
    E $ AddL(TMP, TMP, TMP2)
    E $ StoreL(M(stack-limit(stubs)), TMP)
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(RSP, TMP, sp-offset)

  ;restore R2 ... Rn
  for (r in call-regs(backend), loc in saved-regs(stubs)) do :
    E $ LoadL(R(r), M(loc))
  for (r in call-fregs(backend), loc in saved-fregs(stubs)) do :
    E $ LoadD(F(r), M(loc))

  ;goto current-stack.pc
  let :
    val TMP = R1
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(TMP, TMP, pc-offset)
    E $ Goto(TMP)

;<doc>=======================================================
;==================== Garbage Collection ====================
;============================================================

Garbage Collection Stub:
  Input:
    R0 is return address.
    R2 is required heap size: (must satisfy: heap-top + R1 <= heap-limit)
    RSP still points to caller's stack frame.
  Responsibilities:
    Save the current registers.
    Save the current stack parameters.
      (Save RSP)
      (Save return address)
    Switch to using the system stack.
      (Swap current stack with system stack)
      (Swap registers with system registers)
    Load the system stack parameters
      (Load RSP)
      (Load stack-limit)
    Call collect-garbage:
      (argument 0 (unused) = ---)
      (argument 1 (arity) = 1)
      (argument 2 (size) = size)
      (call)
    Switch back to using the program stack.
      (Null the system stack pointer)
      (Swap current stack with system stack)
      (Swap registers with system registers)
    Load the stack parameters
      (Load RSP)
      (Load stack-limit)
    Restore current registers.
    Continue from stack.pc.

  Pseudocode:
    save R2 ... Rn
    
    current-stack.pc = return address (R0)
    current-stack.sp = RSP
      (use TMP:R1 for current-stack)
      TMP = [current-stack]
      TMP.pc = R0
      TMP.sp = RSP
      
    swap [current-stack] with [system-stack]
      (use TMP:R1)
      (use TMP2:R3)
      TMP = [current-stack]
      TMP2 = [system-stack]
      [current-stack] = TMP2
      [system-stack] = TMP

    swap [registers] with [system_registers]
      (use TMP:R1)
      (use TMP2:R3)
      TMP = [registers]
      TMP2 = [system-registers]
      [registers] = TMP
      [system-registers] = TMP2

    RSP = current-stack.frames
    stack-limit = current-stack.frames + current-stack.size
      (use TMP:R1)
      (use TMP2:R3)
      TMP = [current-stack]
      RSP = TMP.frames
      TMP2 = TMP.size
      TMP2 += RSP
      [stack-limit] = TMP2

    (use size:R2)
    R3 = 1
    R4 = size
    
    RSP += 8
    call collect-garbage
    (RSP -= 8) (Elided: Not used again)
    
    current-stack.stack-pointer = null
      (use TMP:R1)
      TMP = [current-stack]
      TMP.stack-pointer = null

    swap [current-stack] with [system-stack]
      (use TMP:R1)
      (use TMP2:R3)
      TMP = [current-stack]
      TMP2 = [system-stack]
      [current-stack] = TMP2
      [system-stack] = TMP

    swap [registers] with [system_registers]
      (use TMP:R1)
      (use TMP2:R3)
      TMP = [registers]
      TMP2 = [system-registers]
      [registers] = TMP
      [system-registers] = TMP2

    RSP = current-stack.sp
    stack-limit = current-stack.frames + current-stack.size
      (use TMP:R1)
      (use TMP2:R3)
      TMP = [current-stack]
      TMP2 = TMP.frames
      TMP = TMP.size
      TMP += TMP2
      [stack-limit] = TMP
      TMP = [current-stack]
      RSP = TMP.sp
      
    restore R2 ... Rn
    
    goto current-stack.pc
      (use TMP:R1)
      TMP = [current-stack]
      TMP = TMP.pc
      goto TMP

;============================================================
;=======================================================<doc>

defn compile-collect-garbage-stub (stitcher:Stitcher, emitter:CodeEmitter) :
  val stubs = stubs(stitcher)
  val backend = backend(stubs)
  defn E (i:Ins) : emit(emitter, i)
  
  defn swap (r1:Reg, m1:Mem, r2:Reg, m2:Mem) :
    E $ LoadL(r1, m1)
    E $ LoadL(r2, m2)
    E $ StoreL(m1, r2)
    E $ StoreL(m2, r1)

  ;Compute stack offsets
  val stack-offset-counter = Counter(-1 + 8)
  val size-offset = next(stack-offset-counter, 8)
  val frames-offset = next(stack-offset-counter, 8)
  val sp-offset = next(stack-offset-counter, 8)
  val pc-offset = next(stack-offset-counter, 8)

  E $ Label(collect-garbage(stubs))

  ;save R2 ... Rn
  for (r in call-regs(backend), loc in saved-regs(stubs)) do :
    E $ StoreL(M(loc), R(r))
  for (r in call-fregs(backend), loc in saved-fregs(stubs)) do :
    E $ StoreD(M(loc), F(r))

  ;current-stack.pc = return address (R0)
  ;current-stack.sp = RSP
  let :
    val TMP = R1
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ StoreL(TMP, R0, pc-offset)
    E $ StoreL(TMP, RSP, sp-offset)

  ;swap [current-stack] with [system-stack]
  ;swap [registers] with [system_registers]
  swap(R1, M(current-stack(stubs)), R3, M(system-stack(stubs)))  
  swap(R1, M(registers(stubs)), R3, M(system-registers(stubs)))

  ;RSP = current-stack.frames
  ;stack-limit = current-stack.frames + current-stack.size
  let :
    val TMP = R1
    val TMP2 = R3
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(RSP, TMP, frames-offset)
    E $ LoadL(TMP2, TMP, size-offset)
    E $ AddL(TMP2, TMP2, RSP)
    E $ StoreL(M(stack-limit(stubs)), TMP2)

  ;Call collect-garbage
  E $ SetL(R3, INT(1))
  E $ SetL(R4, R2)
  E $ AddL(RSP, RSP, INT(8))
  E $ Call(core-fn(stitcher, CORE-COLLECT-GARBAGE-ID))

  ;current-stack.stack-pointer = null
  let :
    val TMP = R1
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ StoreL(TMP, INT(0), sp-offset)

  ;swap [current-stack] with [system-stack]
  ;swap [registers] with [system_registers]
  swap(R1, M(current-stack(stubs)), R3, M(system-stack(stubs)))  
  swap(R1, M(registers(stubs)), R3, M(system-registers(stubs)))  

  ;RSP = current-stack.sp
  ;stack-limit = current-stack.frames + current-stack.size
  let :
    val TMP = R1
    val TMP2 = R3
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(TMP2, TMP, frames-offset)
    E $ LoadL(TMP, TMP, size-offset)
    E $ AddL(TMP, TMP, TMP2)
    E $ StoreL(M(stack-limit(stubs)), TMP)
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(RSP, TMP, sp-offset)

  ;restore R2 ... Rn
  for (r in call-regs(backend), loc in saved-regs(stubs)) do :
    E $ LoadL(R(r), M(loc))
  for (r in call-fregs(backend), loc in saved-fregs(stubs)) do :
    E $ LoadD(F(r), M(loc))

  ;goto current-stack.pc
  let :
    val TMP = R1
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(TMP, TMP, pc-offset)
    E $ Goto(TMP)

;============================================================
;=================== Utility Structs ========================
;============================================================

;------------------------------------------------------------
;----------------------- Globals ----------------------------
;------------------------------------------------------------

;Represents a global in the global table entry.
deftype GlobalTableEntry
  
;Start of a global
defstruct StartOfGlobal <: GlobalTableEntry :
  offset:Int
  name:String|False
  info:FileInfo|False
  
;A global root
defstruct GlobalRoot <: GlobalTableEntry :
  offset:Int

;End of global
defstruct EndOfGlobals <: GlobalTableEntry :
  size:Int