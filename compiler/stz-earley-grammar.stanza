defpackage stz/earley-grammar :
  import core
  import collections
  import stz/earley-eval-result
  import stz/earley-sexp-stream
  
;============================================================
;====================== Definitions =========================
;============================================================

public deftype GRule
public defmulti name (r:GRule) -> Symbol
public defmulti sub-name (r:GRule, name:Symbol) -> GRule

public defstruct GNegationRule <: GRule :
  name: Symbol with: (as-method => true, updater => sub-name)
  token: GToken

public defstruct GMatcherRule <: GRule :
  name: Symbol with: (as-method => true, updater => sub-name)
  tokens: Tuple<GToken>
  matcher: ? -> True|False
  priority: Int with: (default => 100)
  action: ParsedResult -> ? with: (default => default-action)
  lazy-action?: True|False with: (default => false)

public defstruct GTokenRule <: GRule :
  name: Symbol with: (as-method => true, updater => sub-name)
  tokens: Tuple<GToken>
  priority: Int with: (default => 100)
  associativity: Associativity with: (default => LeftAssociative)
  action: ParsedResult -> ? with: (default => default-action)
  lazy-action?: True|False with: (default => false)

public defn GMatcherRule (name:Symbol, tokens:Tuple<GToken>, matcher:? -> True|False,
                          action:ParsedResult -> ?, lazy-action?:True|False) :
  GMatcherRule(name, tokens, matcher, 100, action, lazy-action?)

public defn GMatcherRule (name:Symbol, tokens:Tuple<GToken>, matcher:? -> True|False,
                          action:ParsedResult -> ?) :
  GMatcherRule(name, tokens, matcher, action, false)

public defn GTokenRule (name:Symbol,
                        tokens:Tuple<GToken>,
                        action:ParsedResult -> ?,
                        lazy-action?:True|False) :
  GTokenRule(name, tokens, 100, RightAssociative, action, lazy-action?)

public defn GTokenRule (name:Symbol,
                        tokens:Tuple<GToken>,
                        action:ParsedResult -> ?) :
  GTokenRule(name, tokens, action, false)

public defenum Associativity :
  LeftAssociative
  RightAssociative

;+[Earley Matcher Tokens]
public deftype GToken <: Equalable & Hashable & Comparable<GToken>
public defstruct GProduction <: GToken :
  name: Symbol
public deftype GTerminal <: GToken
public defstruct GKeyword <: GTerminal :
  item: Symbol
public defstruct GCharToken <: GTerminal
public defstruct GByteToken <: GTerminal
public defstruct GIntToken <: GTerminal
public defstruct GLongToken <: GTerminal
public defstruct GFloatToken <: GTerminal
public defstruct GDoubleToken <: GTerminal
public defstruct GStringToken <: GTerminal
public defstruct GSymbolToken <: GTerminal
public defstruct GTrueToken <: GTerminal
public defstruct GFalseToken <: GTerminal
  
public defstruct GListStart <: GTerminal :
  reluctant?: True|False with: (default => false)
public defstruct GListEnd <: GTerminal
public defstruct GAny <: GTerminal :
  type: AnyType with: (default => Standard)
public defstruct GListRest <: GTerminal

public defenum AnyType :
  Atomic
  Reluctant
  Standard
;/[Earley Matcher Tokens]

;============================================================
;===================== Default Action =======================
;============================================================

defn default-action (r:ParsedResult) : false

;============================================================
;======================== Equalable =========================
;============================================================

defmethod equal? (a:GToken, b:GToken) :
  match(a, b) :
    (a:GKeyword, b:GKeyword) : item(a) == item(b)
    (a:GCharToken, b:GCharToken) : true
    (a:GByteToken, b:GByteToken) : true
    (a:GIntToken, b:GIntToken) : true
    (a:GLongToken, b:GLongToken) : true
    (a:GFloatToken, b:GFloatToken) : true
    (a:GDoubleToken, b:GDoubleToken) : true
    (a:GStringToken, b:GStringToken) : true
    (a:GSymbolToken, b:GSymbolToken) : true
    (a:GTrueToken, b:GTrueToken) : true
    (a:GFalseToken, b:GFalseToken) : true
    (a:GProduction, b:GProduction) : name(a) == name(b)
    (a:GListStart, b:GListStart) : true
    (a:GListEnd, b:GListEnd) : true
    (a:GAny, b:GAny) : type(a) == type(b)
    (a:GListRest, b:GListRest) : true
    (a, b) : false

defmethod hash (t:GToken) :
  match(t) :
    (t:GKeyword) : 1 + hash(item(t))
    (t:GProduction) : 2 + hash(name(t))
    (t:GListStart) : 3
    (t:GListEnd) : 4
    (t:GAny) : 5 + hash(to-int(type(t)))
    (t:GListRest) : 6
    (t:GCharToken) : 7
    (t:GByteToken) : 8
    (t:GIntToken) : 9
    (t:GLongToken) : 10
    (t:GFloatToken) : 11
    (t:GDoubleToken) : 12
    (t:GStringToken) : 13
    (t:GSymbolToken) : 14
    (t:GTrueToken) : 15
    (t:GFalseToken) : 16

defmethod compare (a:GToken, b:GToken) :
  defn rank (t:GToken) :
    match(t) :
      (t:GKeyword) : 0
      (t:GProduction) : 1
      (t:GListStart) : 2
      (t:GListEnd) : 3
      (t:GAny) : 4
      (t:GListRest) : 5
      (t:GCharToken) : 6
      (t:GByteToken) : 7
      (t:GIntToken) : 8
      (t:GLongToken) : 9
      (t:GFloatToken) : 10
      (t:GDoubleToken) : 11
      (t:GStringToken) : 12
      (t:GSymbolToken) : 13
      (t:GTrueToken) : 14
      (t:GFalseToken) : 15
  defn compare-token (a:GToken, b:GToken) :
    match(a, b) :
      (a:GProduction, b:GProduction) : compare(name(a), name(b))
      (a:GKeyword, b:GKeyword) : compare(item(a), item(b))
      (a:GAny, b:GAny) : compare(to-int(type(a)), to-int(type(b)))
      (a, b) : 0
  val c = compare(rank(a), rank(b))
  if c == 0 : compare-token(a,b)
  else : c

;============================================================
;======================= Printers ===========================
;============================================================

defmethod print (o:OutputStream, t:GToken) :
  print{o, _} $ match(t) :
    (t:GProduction) : name(t)
    (t:GKeyword) : item(t)
    (t:GCharToken) : "Char"
    (t:GByteToken) : "Byte"
    (t:GIntToken) : "Int"
    (t:GLongToken) : "Long"
    (t:GFloatToken) : "Float"
    (t:GDoubleToken) : "Double"
    (t:GStringToken) : "String"
    (t:GSymbolToken) : "Symbol"
    (t:GTrueToken) : "True"
    (t:GFalseToken) : "False"
    (t:GListStart) : "("
    (t:GListEnd) : ")"
    (t:GAny) : "_"
    (t:GListRest) : "_ ..."

defmethod print (o:OutputStream, r:GRule) :
  print{o, _} $ match(r) :
    (r:GTokenRule) : "%_ = %s" % [name(r), tokens(r)]
    (r:GMatcherRule) : "%_ = custom matcher" % [name(r)]
    (r:GNegationRule) : "%_ != %_" % [name(r), token(r)]

;============================================================
;======================== Utilities =========================
;============================================================

public defn tokens! (rule:GRule) :
  tokens(rule as GMatcherRule|GTokenRule)

public defn associativity (rule:GMatcherRule) :
  RightAssociative

;============================================================
;======================== Grammar ===========================
;============================================================

public deftype Grammar
public defmulti get (g:Grammar, i:Int) -> GRule
public defmulti nullable? (g:Grammar, production:Symbol) -> True|False
public defmulti rules (g:Grammar, production:Symbol) -> Seqable<Int>
public defmulti rules-with-prefix (g:Grammar, production:Symbol, prefix:SExpToken) -> Seqable<Int>
public defmulti rules-with-suffix (g:Grammar, production:Symbol, suffix:SExpToken) -> Seqable<Int>