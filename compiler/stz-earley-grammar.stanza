defpackage stz/earley-grammar :
  import core
  import collections
  import stz/earley-eval-result
  import stz/earley-sexp-stream
  
;============================================================
;====================== Definitions =========================
;============================================================

public deftype GRule
public defmulti name (r:GRule) -> Symbol
public defmulti sub-name (r:GRule, name:Symbol) -> GRule

public defstruct GNegationRule <: GRule :
  name: Symbol with: (as-method => true, updater => sub-name)
  token: GToken

public defstruct GMatcherRule <: GRule :
  name: Symbol with: (as-method => true, updater => sub-name)
  token: GTerminal
  matcher: ? -> True|False
  action: ParsedResult -> ? with: (default => default-action)
  
public defstruct GTokenRule <: GRule :
  name: Symbol with: (as-method => true, updater => sub-name)
  tokens: Tuple<GToken>
  priority: Int with: (default => 100)
  associativity: Associativity with: (default => LeftAssociative)
  action: ParsedResult -> ? with: (default => default-action)
  lazy-action?: True|False with: (default => false)

public defn GTokenRule (name:Symbol,
                        tokens:Tuple<GToken>,
                        action:ParsedResult -> ?,
                        lazy-action?:True|False) :
  GTokenRule(name, tokens, 100, LeftAssociative, action, lazy-action?)

public defn GTokenRule (name:Symbol,
                        tokens:Tuple<GToken>,
                        action:ParsedResult -> ?) :
  GTokenRule(name, tokens, action, false)

public defenum Associativity :
  LeftAssociative
  RightAssociative

;+[Earley Matcher Tokens]
public deftype GToken <: Equalable & Hashable & Comparable<GToken>
public defstruct GProduction <: GToken :
  name: Symbol
public deftype GTerminal <: GToken
public defstruct GKeyword <: GTerminal :
  item: Symbol
public defstruct GPrimToken <: GTerminal :
  type: GPrimType
public defstruct GMatcherToken <: GTerminal :
  terminal: GTerminal
  matcher-id: Int
  
public defstruct GListStart <: GTerminal :
  reluctant?: True|False with: (default => false)
public defstruct GListEnd <: GTerminal
public defstruct GAny <: GTerminal :
  type: AnyType with: (default => Standard)
public defstruct GListRest <: GTerminal

public defenum GPrimType :
  GCharType
  GByteType
  GIntType
  GLongType
  GFloatType
  GDoubleType
  GStringType
  GSymbolType
  GTrueType
  GFalseType

public defenum AnyType :
  Atomic
  Reluctant
  Standard
;/[Earley Matcher Tokens]

;============================================================
;===================== Default Action =======================
;============================================================

defn default-action (r:ParsedResult) : false

;============================================================
;======================== Equalable =========================
;============================================================

defmethod equal? (a:GToken, b:GToken) :
  match(a, b) :
    (a:GKeyword, b:GKeyword) : item(a) == item(b)
    (a:GPrimToken, b:GPrimToken) : type(a) == type(b)
    (a:GProduction, b:GProduction) : name(a) == name(b)
    (a:GListStart, b:GListStart) : true
    (a:GListEnd, b:GListEnd) : true
    (a:GAny, b:GAny) : type(a) == type(b)
    (a:GListRest, b:GListRest) : true
    (a:GMatcherToken, b:GMatcherToken) :
      terminal(a) == terminal(b) and matcher-id(a) == matcher-id(b)
    (a, b) : false

defmethod hash (t:GToken) :
  match(t) :
    (t:GKeyword) : 1 + hash(item(t))
    (t:GProduction) : 2 + hash(name(t))
    (t:GListStart) : 3
    (t:GListEnd) : 4
    (t:GAny) : 5 + hash(to-int(type(t)))
    (t:GListRest) : 6
    (t:GPrimToken) : 7 * hash(type(t))
    (t:GMatcherToken) : hash $ [terminal(t), matcher-id(t)]

defmethod compare (a:GToken, b:GToken) :
  defn rank (t:GToken) :
    match(t) :
      (t:GKeyword) : 0
      (t:GProduction) : 1
      (t:GListStart) : 2
      (t:GListEnd) : 3
      (t:GAny) : 4
      (t:GListRest) : 5
      (t:GPrimToken) : 6
      (t:GMatcherToken) : 7
  defn compare-token (a:GToken, b:GToken) :
    match(a, b) :
      (a:GProduction, b:GProduction) : compare(name(a), name(b))
      (a:GKeyword, b:GKeyword) : compare(item(a), item(b))
      (a:GAny, b:GAny) : compare(to-int(type(a)), to-int(type(b)))
      (a:GPrimToken, b:GPrimToken) : compare(to-int(type(a)), to-int(type(b)))
      (a:GMatcherToken, b:GMatcherToken) :
        val c = compare(terminal(a), terminal(b))
        if c == 0 : compare(matcher-id(a), matcher-id(b))
        else : c
      (a, b) : 0
  val c = compare(rank(a), rank(b))
  if c == 0 : compare-token(a,b)
  else : c

;============================================================
;======================= Printers ===========================
;============================================================

public defn name (t:GPrimType) :
  match(t) :
    (t:GCharType) : "Char"
    (t:GByteType) : "Byte"
    (t:GIntType) : "Int"
    (t:GLongType) : "Long"
    (t:GFloatType) : "Float"
    (t:GDoubleType) : "Double"
    (t:GStringType) : "String"
    (t:GSymbolType) : "Symbol"
    (t:GTrueType) : "True"
    (t:GFalseType) : "False"

defmethod print (o:OutputStream, t:GToken) :
  print{o, _} $ match(t) :
    (t:GProduction) : name(t)
    (t:GKeyword) : item(t)
    (t:GPrimToken) : name(type(t))
    (t:GListStart) : "("
    (t:GListEnd) : ")"
    (t:GAny) : "_"
    (t:GListRest) : "_ ..."
    (t:GMatcherToken) : "M%_[%_]" % [matcher-id(t), terminal(t)]

defmethod print (o:OutputStream, r:GRule) :
  print{o, _} $ match(r) :
    (r:GTokenRule) : "%_ = %s" % [name(r), tokens(r)]
    (r:GMatcherRule) : "%_ = custom matcher" % [name(r)]
    (r:GNegationRule) : "%_ != %_" % [name(r), token(r)]

;============================================================
;======================== Utilities =========================
;============================================================

public defn tokens! (rule:GRule) :
  tokens(rule as GTokenRule)

;============================================================
;======================== Grammar ===========================
;============================================================

public deftype Grammar <: Collection<GRule>
public defmulti get (g:Grammar, i:Int) -> GRule
public defmulti nullable? (g:Grammar, production:Symbol) -> True|False
public defmulti rules (g:Grammar, production:Symbol) -> Seqable<Int>
public defmulti rules-with-prefix (g:Grammar, production:Symbol, prefix:SExpToken) -> Seqable<Int>
public defmulti rules-with-suffix (g:Grammar, production:Symbol, suffix:SExpToken) -> Seqable<Int>
public defmulti match? (g:Grammar, matcher-id:Int, input) -> True|False