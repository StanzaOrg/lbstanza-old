defpackage stz/earley-grammar :
  import core
  import collections
  import stz/earley-eval-result
  import stz/earley-sexp-stream
  
;============================================================
;====================== Definitions =========================
;============================================================

public defstruct GRules :
  productions: Tuple<GDefProduction>
  rules: Tuple<GRule>
  num-productions: Int with: (init => compute-num-productions(productions))

defn compute-num-productions (ps:Tuple<GDefProduction>) -> Int :
  maximum(0, for p in ps seq : id(p) + 1)

public defstruct GDefProduction :
  id: Int
  name: Symbol

public deftype GRule
public defmulti id (r:GRule) -> Int
public defmulti sub-id (r:GRule, id:Int) -> GRule
public defmulti prod (r:GRule) -> Int
public defmulti sub-prod (r:GRule, prod:Int) -> GRule
public defmulti order (r:GRule) -> Int|False
public defmulti sub-order (r:GRule, o:Int|False) -> GRule

public defstruct GNegationRule <: GRule :
  id: Int with: (as-method => true, updater => sub-id)
  prod: Int with: (as-method => true, updater => sub-prod)
  token: GToken
  order: Int|False with: (default => false, updater => sub-order, as-method => true)

public defstruct GMatcherRule <: GRule :
  id: Int with: (as-method => true, updater => sub-id)
  prod: Int with: (as-method => true, updater => sub-prod)
  token: GTerminal
  matcher: ? -> True|False
  action: ParsedResult -> ? with: (default => default-action)
  order: Int|False with: (default => false, updater => sub-order, as-method => true)
  
public defstruct GTokenRule <: GRule :
  id: Int with: (as-method => true, updater => sub-id)
  prod: Int with: (as-method => true, updater => sub-prod)
  tokens: Tuple<GToken> with: (updater => sub-tokens)
  params: RuleParams with: (updater => sub-params)
  order: Int|False with: (default => false, updater => sub-order, as-method => true)

public deftype RuleParams

public defstruct TokenRuleParams <: RuleParams :
  priority: Int with: (default => 100)
  associativity: Associativity with: (default => NonAssociative)
  action: ParsedResult -> ? with: (default => default-action)
  lazy-action?: True|False with: (default => false)
  operator-type: OperatorType|False with: (default => false, updater => sub-operator-type)
with:
  printer => true
  
public defstruct InheritParams <: RuleParams

public deftype OperatorType

public defstruct Prefix <: OperatorType :
  id: Int
with:
  printer => true
public defstruct Postfix <: OperatorType :
  id: Int
with:
  printer => true
public defstruct Binary <: OperatorType :
  left: Int
  right: Int
with:
  printer => true

public defn TokenRuleParams (priority:Int,
                             associativity:Associativity,
                             operator-type:OperatorType|False) :
  TokenRuleParams(priority, associativity, default-action, false, operator-type)

public defn TokenRuleParams (priority:Int,
                             associativity:Associativity,
                             operator-type:OperatorType|False,
                             action:ParsedResult -> ?) :
  TokenRuleParams(priority, associativity, action, false, operator-type)

public defn TokenRuleParams (operator-type:OperatorType|False,
                             action:ParsedResult -> ?) :
  TokenRuleParams(100, NonAssociative, action, false, operator-type)

public defn TokenRuleParams (action:ParsedResult -> ?,
                             lazy-action?:True|False) :
  TokenRuleParams(100, NonAssociative, action, lazy-action?)

public defn TokenRuleParams (action:ParsedResult -> ?) :
  TokenRuleParams(100, NonAssociative, action, false)

public defenum Associativity <: Comparable<Associativity> :
  LeftAssociative
  RightAssociative
  NonAssociative

;+[Earley Matcher Tokens]
public deftype GToken <: Equalable & Hashable & Comparable<GToken>
public defstruct GProduction <: GToken :
  id: Int
public deftype GTerminal <: GToken
public defstruct GKeyword <: GTerminal :
  item: Symbol
public defstruct GPrimToken <: GTerminal :
  type: GPrimType
public defstruct GMatcherToken <: GTerminal :
  terminal: GTerminal
  matcher-id: Int
  
public defstruct GListStart <: GTerminal :
  reluctant?: True|False with: (default => false)
public defstruct GListEnd <: GTerminal
public defstruct GAny <: GTerminal :
  type: AnyType with: (default => Standard)
public defstruct GListRest <: GTerminal

public defenum GPrimType :
  GCharType
  GByteType
  GIntType
  GLongType
  GFloatType
  GDoubleType
  GStringType
  GSymbolType
  GTrueType
  GFalseType

public defenum AnyType :
  Atomic
  Reluctant
  Standard
;/[Earley Matcher Tokens]

;============================================================
;===================== Default Action =======================
;============================================================

defn default-action (r:ParsedResult) : false

;============================================================
;======================== Equalable =========================
;============================================================

defmethod equal? (a:GToken, b:GToken) :
  match(a, b) :
    (a:GKeyword, b:GKeyword) : item(a) == item(b)
    (a:GPrimToken, b:GPrimToken) : type(a) == type(b)
    (a:GProduction, b:GProduction) : id(a) == id(b)
    (a:GListStart, b:GListStart) : true
    (a:GListEnd, b:GListEnd) : true
    (a:GAny, b:GAny) : type(a) == type(b)
    (a:GListRest, b:GListRest) : true
    (a:GMatcherToken, b:GMatcherToken) :
      terminal(a) == terminal(b) and matcher-id(a) == matcher-id(b)
    (a, b) : false

defmethod hash (t:GToken) :
  match(t) :
    (t:GKeyword) : 1 + hash(item(t))
    (t:GProduction) : 2 + id(t)
    (t:GListStart) : 3
    (t:GListEnd) : 4
    (t:GAny) : 5 + hash(to-int(type(t)))
    (t:GListRest) : 6
    (t:GPrimToken) : 7 * hash(type(t))
    (t:GMatcherToken) : hash $ [terminal(t), matcher-id(t)]

defmethod compare (a:GToken, b:GToken) :
  defn rank (t:GToken) :
    match(t) :
      (t:GKeyword) : 0
      (t:GProduction) : 1
      (t:GListStart) : 2
      (t:GListEnd) : 3
      (t:GAny) : 4
      (t:GListRest) : 5
      (t:GPrimToken) : 6
      (t:GMatcherToken) : 7
  defn compare-token (a:GToken, b:GToken) :
    match(a, b) :
      (a:GProduction, b:GProduction) : compare(id(a), id(b))
      (a:GKeyword, b:GKeyword) : compare(item(a), item(b))
      (a:GAny, b:GAny) : compare(to-int(type(a)), to-int(type(b)))
      (a:GPrimToken, b:GPrimToken) : compare(to-int(type(a)), to-int(type(b)))
      (a:GMatcherToken, b:GMatcherToken) :
        val c = compare(terminal(a), terminal(b))
        if c == 0 : compare(matcher-id(a), matcher-id(b))
        else : c
      (a, b) : 0
  val c = compare(rank(a), rank(b))
  if c == 0 : compare-token(a,b)
  else : c

defmethod compare (a:Associativity, b:Associativity) :
  compare(to-int(a), to-int(b))

;============================================================
;======================= Printers ===========================
;============================================================

public defn name (t:GPrimType) :
  match(t) :
    (t:GCharType) : "Char"
    (t:GByteType) : "Byte"
    (t:GIntType) : "Int"
    (t:GLongType) : "Long"
    (t:GFloatType) : "Float"
    (t:GDoubleType) : "Double"
    (t:GStringType) : "String"
    (t:GSymbolType) : "Symbol"
    (t:GTrueType) : "True"
    (t:GFalseType) : "False"

defmethod print (o:OutputStream, t:GToken) :
  print{o, _} $ match(t) :
    (t:GProduction) : "#%_" % [id(t)]
    (t:GKeyword) : item(t)
    (t:GPrimToken) : name(type(t))
    (t:GListStart) : "("
    (t:GListEnd) : ")"
    (t:GAny) : "_"
    (t:GListRest) : "_ ..."
    (t:GMatcherToken) : "M%_[%_]" % [matcher-id(t), terminal(t)]

defmethod print (o:OutputStream, r:GRule) :
  print{o, _} $ match(r) :
    (r:GTokenRule) : "#%_ = %s (%_)" % [prod(r), tokens(r), params(r)]
    (r:GMatcherRule) : "#%_ = custom matcher" % [prod(r)]
    (r:GNegationRule) : "#%_ != %_" % [prod(r), token(r)]

defmethod print (o:OutputStream, p:GDefProduction) :
  print(o, "defproduction %_ (id = %_)" % [name(p), id(p)])

defmethod print (o:OutputStream, rs:GRules) :
  val o2 = IndentedStream(o)
  val o3 = IndentedStream(o2)
  print(o, "GRules:")
  lnprint(o2, "productions:")
  do(lnprint{o3, _}, productions(rs))
  lnprint(o2, "rules:")
  do(lnprint{o3, _}, rules(rs))

public defn format (grammar:Grammar, t:GToken) :
  match(t) :
    (t:GProduction) : name(production(grammar,id(t)))
    (t) : t

public defn format (grammar:Grammar, r:GRule) :
  defn rule-name (id:Int)  : name(production(grammar,id))
  match(r) :
   (r:GTokenRule) : "%_ = %s" % [rule-name(prod(r)), seq(format{grammar,_},tokens(r))]
   (r:GMatcherRule) : "%_ = custom matcher" % [rule-name(prod(r))]
   (r:GNegationRule) : "%_ != %_" % [rule-name(prod(r)), format(grammar,token(r))]

;============================================================
;======================== Grammar ===========================
;============================================================

public deftype Grammar <: Collection<GTokenRule>
public defmulti production (g:Grammar, id:Int) -> GDefProduction
public defmulti get (g:Grammar, i:Int) -> GTokenRule
public defmulti nullable? (g:Grammar, production:Int) -> True|False
public defmulti rules (g:Grammar, production:Int) -> Seqable<Int>
public defmulti rules-with-prefix (g:Grammar, production:Int, prefix:SExpToken) -> Seqable<Int>
public defmulti match? (g:Grammar, matcher-id:Int, input) -> True|False
public defmulti num-productions (g:Grammar) -> Int

;============================================================
;================= Matching Predicates ======================
;============================================================

;Returns true if the given terminal matches against the given input.
public defn matches-input? (grammar:Grammar, t:GTerminal, input:SExpToken) -> True|False :
  match(input) :
    ;Wildcard matching
    (input:SExpWildcard) :
      t is-not GListStart|GListEnd
    ;Form matching
    (input:SExpForm) :
      match(t) :
        (t:GKeyword) : unwrap-token(form(input)) == item(t)
        (t:GPrimToken) :
          switch(type(t)) :
            GCharType : unwrap-token(form(input)) is Char
            GByteType : unwrap-token(form(input)) is Byte
            GIntType : unwrap-token(form(input)) is Int
            GLongType : unwrap-token(form(input)) is Long
            GFloatType : unwrap-token(form(input)) is Float
            GDoubleType : unwrap-token(form(input)) is Double
            GStringType : unwrap-token(form(input)) is String
            GSymbolType : unwrap-token(form(input)) is Symbol
            GTrueType : unwrap-token(form(input)) is True
            GFalseType : unwrap-token(form(input)) is False
        (t:GListStart) : unwrap-token(form(input)) is List        
        (t:GAny) : true
        (t:GListRest) : true
        (t:GMatcherToken) : matches-input?(grammar, terminal(t), input) and
                            match?(grammar, matcher-id(t), form(input))
        (t) : false
    ;List end matching
    (input:SExpListEnd) :
      t is GListEnd