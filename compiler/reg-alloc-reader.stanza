defpackage stz/reg-alloc-reader :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-errors

defsyntax reg-alloc-ir :

  ;Syntax for overall program.
  public defproduction prog: Program
  defrule prog = (program :
                    num-vars: ?num-vars:#int!
                    ?stmts:#pstmt! ...) :
    Program(num-vars,
            to-tuple(stmts))

  ;Syntax for operation models.
  public defproduction model: OperationModel
  defrule model = (model ?results:#model-results ?id:#opid!(?args:#varid! ...) ?temp:#model-temp :
                     ?stmts:#mstmt! ...) :
    for (v in cat-all([results, args, temp]), i in 0 to false) do :
      if v != i :
        val msg = "Model variables are not densely indexed. Variable V%_ \
                   is in the position reserved for V%_."
        throw(RegAllocSyntaxError(closest-info(), msg % [v, i]))
    OperationModel(id,
                   results,
                   to-tuple(args),
                   temp,
                   to-tuple(stmts))

  defproduction model-results: Tuple<Int>
  defrule model-results = ((?results:#varid ...) =) : to-tuple(results)
  defrule model-results = () : []

  defproduction model-temp: Tuple<Int>
  defrule model-temp = ((temp ?temp:#varid! ...)) : to-tuple(temp)
  defrule model-temp = () : []

  ;Syntax for program statements
  defproduction pstmt: ProgramStmt

  defrule pstmt = (label ?id:#labelid!) :
    LabelStmt(id)

  defrule pstmt = ((?results:#varid ...) = ?op-id:#opid!(?args:#varid! ...)) :
    OperationStmt(op-id, false, to-tuple(args), to-tuple(results))

  defrule pstmt = (?op-id:#opid(?args:#varid! ...)) :
    OperationStmt(op-id, false, to-tuple(args), [])

  defrule pstmt = (branch (?targets:#labelid! ...)) :
    BranchStmt(to-tuple(targets))

  defrule pstmt = (goto ?target:#labelid!) :
    GotoStmt(target)

  ;Syntax for model statements.
  defproduction mstmt: ModelStmt

  defrule mstmt = (require ?loc:#loc! for ?arg:#varid! ?pref:#pref) :
    Require(arg, loc, pref)

  defrule mstmt = (release ?arg:#varid!) :
    Release(arg)

  defrule mstmt = (clear-registers) :
    ClearRegisters()

  defrule mstmt = (return) :
    Return()

  ;Syntax for locations
  defproduction register: Register
  defrule register = (?id:#fregid) : FReg(id)
  defrule register = (?id:#regid) : Reg(id)
  defrule register = (Fx) : AnyFReg()
  defrule register = (Rx) : AnyReg()

  defproduction loc: Location
  defrule loc = (?reg:#register or stack) : OrStack(reg)
  defrule loc = (?reg:#register)

  ;Syntax for preferences
  defproduction pref: Preference
  defrule pref = (prefer-same-as ?arg:#varid) : PreferSame(arg)
  defrule pref = (prefer ?id:#regid) : PreferRegister(Reg(id))
  defrule pref = (prefer ?id:#fregid) : PreferRegister(FReg(id))
  defrule pref = () : NoPreference()

  ;Primitives
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  ;Special identifiers
  defproduction labelid: Int
  defrule labelid = (?x) when integer-id?(x, "L") :
    extract-integer-id!(x)
  
  defproduction varid: Int
  defrule varid = (?x) when integer-id?(x, "V") :
    extract-integer-id!(x)

  defproduction opid: Int
  defrule opid = (?x) when integer-id?(x, "op") :
    extract-integer-id!(x)

  defproduction regid: Int
  defrule regid = (?x) when integer-id?(x, "R") :
    extract-integer-id!(x)

  defproduction fregid: Int
  defrule fregid = (?x) when integer-id?(x, "F") :
    extract-integer-id!(x)

  ;Error productions
  public defproduction model!: OperationModel
  defrule model! = (?x:#model)
  fail-if model! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for operation model.")

  defproduction loc!: Location
  defrule loc! = (?x:#loc)
  fail-if loc! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for location.")

  defproduction mstmt!: ModelStmt
  defrule mstmt! = (?x:#mstmt)
  fail-if mstmt! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for model statement.")

  defproduction pstmt!: ProgramStmt
  defrule pstmt! = (?x:#pstmt)
  fail-if pstmt! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for program statement.")

  defproduction varid!: Int
  defrule varid! = (?x:#varid)
  fail-if varid! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for variable.")

  defproduction labelid!: Int
  defrule labelid! = (?x:#labelid)
  fail-if labelid! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for label.")

  defproduction opid!: Int
  defrule opid! = (?x:#opid)
  fail-if opid! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for operation.")

  defproduction int!: Int
  defrule int! = (?x:#int)
  fail-if int! = () :
    RegAllocSyntaxError(closest-info(), "Expected an integer here.")

;============================================================
;=================== ID Helpers =============================
;============================================================

;Returns true if x is a prefixed integer id.
defn integer-id? (x, str:String) -> True|False :
  match(unwrap-token(x)) :
    (sym:Symbol) :
      if prefix?(name(sym), str) :
        val rest = name(sym)[length(str) to false]
        to-int(rest) is Int
    (x) :
      false

;Extracts the integer portion of the integer id.
defn extract-integer-id! (x) -> Int :
  val sym = unwrap-token(x) as Symbol
  val i = index-when!(digit?, name(sym))
  to-int!(name(sym)[i to false])