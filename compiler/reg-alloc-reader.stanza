defpackage stz/reg-alloc-reader :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/reg-alloc-ports
  import stz/reg-alloc-errors

defsyntax reg-alloc-ir :

  ;Syntax for overall program.
  public defproduction prog: Program
  defrule prog = (program :
                    vars: (?vars:#vardef! ...)
                    ?stmts:#pstmt! ...) :
    ;Ensure dense indexing of variables.
    for (v in vars, i in 0 to false) do :
      if id(v) != i :
        val msg = "Program variables are not densely indexed. Variable V%_ \
                   is in the position reserved for V%_."
        throw(RegAllocSyntaxError(closest-info(), msg % [id(v), i]))
        
    Program(to-tuple(vars),
            to-tuple(stmts))

  ;Variable definition
  public defproduction vardef!: VarDef
  defrule vardef! = (?v:#varid! : ?t:#register-type!) : VarDef(v,t)

  ;Syntax for operation models.
  public defproduction model: OperationModel
  defrule model = (model ?results:#model-results ?op-id:#opid!(?args:#model-var! ...) ?temp:#model-temp :
                     ?stmts:#mstmt! ...) :
    ;Ensure dense indexing of model variables.
    for (v in cat-all([results, args, temp]), i in 0 to false) do :
      if id(v) != i :
        val msg = "Model variables are not densely indexed. Variable V%_ \
                   is in the position reserved for V%_."
        throw(RegAllocSyntaxError(closest-info(), msg % [id(v), i]))
        
    OperationModel(op-id,
                   results,
                   to-tuple(args),
                   temp,
                   to-tuple(stmts))

  defproduction model-results: Tuple<ModelVar>
  defrule model-results = ((?results:#model-var ...) =) : to-tuple(results)
  defrule model-results = () : []

  defproduction model-temp: Tuple<ModelVar>
  defrule model-temp = ((temp ?temp:#model-var! ...)) : to-tuple(temp)
  defrule model-temp = () : []

  defproduction model-var: ModelVar
  defrule model-var = (?id:#varid : ?loc:#loc! ?pref:#pref) :
    ModelVar(id, loc, pref)

  ;Syntax for program statements
  defproduction pstmt: ProgramStmt

  defrule pstmt = (label ?id:#labelid!) :
    LabelStmt(id)

  defrule pstmt = ((?results:#varid ...) = (?args:#varid ...)) :
    SetStmt(to-tuple(results), to-tuple(args))

  defrule pstmt = ((?results:#varid ...) = ?op-id:#opid!(?args:#varid! ...)) :
    OperationStmt(op-id, false, to-tuple(args), to-tuple(results))

  defrule pstmt = (?op-id:#opid(?args:#varid! ...)) :
    OperationStmt(op-id, false, to-tuple(args), [])

  defrule pstmt = (branch (?targets:#labelid! ...)) :
    BranchStmt(to-tuple(targets))

  defrule pstmt = (goto ?target:#labelid!) :
    GotoStmt(target)

  ;Syntax for model statements.
  defproduction mstmt: ModelStmt

  defrule mstmt = (assign ?id:#varid!) :
    Assign(id)

  defrule mstmt = (release ?id:#varid!) :
    Release(id)

  defrule mstmt = (clear-registers) :
    ClearRegisters()

  defrule mstmt = (return) :
    Return()

  ;Syntax for locations
  public defproduction loc: Location
  defrule loc = (?t:#register-type)
  defrule loc = (?r:#register)
  
  public defproduction register-type: RegisterType
  defrule register-type = (Rx) : AnyReg()
  defrule register-type = (Fx) : AnyFReg()
  
  public defproduction register: Register
  defrule register = (?r:#reg)
  defrule register = (?r:#freg)

  public defproduction reg: Reg
  defrule reg = (?id:#regid) : Reg(id)

  public defproduction freg: FReg
  defrule freg = (?id:#fregid) : FReg(id)

  ;Syntax for preferences
  defproduction pref: Preference
  defrule pref = ((prefer-same ?id:#varid)) : PreferSame(id)
  defrule pref = ((prefer ?reg:#register)) : PreferRegister(reg)
  defrule pref = () : NoPreference()

  ;Syntax for ports
  defproduction port: Port
  defrule port = (port ?id:#varid! (usage-position: ?usage-position:#int! ?prefs:#prefs? ?status:#status?)) :
    Port(id, usage-position, prefs, status)

  ;Syntax for port preferences
  defproduction prefs?: PortPref|False
  defrule prefs? = (PortPref(?savepref:#savepref, ?loadpref:#loadpref, ?regpref:#reg-pref)) :
    PortPref(savepref, loadpref, regpref)
  defrule prefs? = () : false

  ;Syntax for port status
  defproduction status?: PortStatus|False
  defrule status? = (PortStatus(?saved:#saved?, ?loaded:#loaded?)) :
    PortStatus(saved, loaded)
  defrule status? = () : false

  defproduction saved?: True|False
  defrule saved? = (saved) : true
  defrule saved? = () : false

  defproduction loaded?: Location|False
  defrule loaded? = (loaded: ?l:#loc)
  defrule loaded? = () : false

  ;Preferred register for port.
  defproduction reg-pref: Register|False
  defrule reg-pref = (reg-pref: ?reg:#register)
  defrule reg-pref = () : false

  ;Syntax for port preferred register
  defproduction pref-reg?: Reg|FReg|False
  defrule pref-reg? = (pref-reg: ?r:#regid) : Reg(r)
  defrule pref-reg? = (pref-reg: ?r:#fregid) : FReg(r)
  defrule pref-reg? = () : false

  ;Syntax for save preferences
  defproduction savepref: SavePref
  defrule savepref = (PreferSave) : PreferSave
  defrule savepref = (NoPreferSave) : NoPreferSave
  defrule savepref = (PreferSaveIfSuccessor) : PreferSaveIfSuccessor
  
  ;Syntax for load preferences
  defproduction loadpref: LoadPref
  defrule loadpref = (PreferUnload) : PreferUnload
  defrule loadpref = (NoPreferUnload) : NoPreferUnload
  defrule loadpref = (PreferUnloadIfSuccessor) : PreferUnloadIfSuccessor

  ;Primitives
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

  ;Special identifiers
  defproduction labelid: Int
  defrule labelid = (?x) when integer-id?(x, "L") :
    extract-integer-id!(x)
  
  public defproduction varid: Int
  defrule varid = (?x) when integer-id?(x, "V") :
    extract-integer-id!(x)

  defproduction opid: Int
  defrule opid = (?x) when integer-id?(x, "op") :
    extract-integer-id!(x)

  defproduction regid: Int
  defrule regid = (?x) when integer-id?(x, "R") :
    extract-integer-id!(x)

  defproduction fregid: Int
  defrule fregid = (?x) when integer-id?(x, "F") :
    extract-integer-id!(x)

  ;Error productions
  public defproduction model!: OperationModel
  defrule model! = (?x:#model)
  fail-if model! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for operation model.")

  defproduction loc!: Location
  defrule loc! = (?x:#loc)
  fail-if loc! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for location.")

  defproduction mstmt!: ModelStmt
  defrule mstmt! = (?x:#mstmt)
  fail-if mstmt! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for model statement.")

  public defproduction pstmt!: ProgramStmt
  defrule pstmt! = (?x:#pstmt)
  fail-if pstmt! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for program statement.")

  public defproduction port!: Port
  defrule port! = (?x:#port)
  fail-if port! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for port.")

  defproduction varid!: Int
  defrule varid! = (?x:#varid)
  fail-if varid! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for variable.")

  defproduction labelid!: Int
  defrule labelid! = (?x:#labelid)
  fail-if labelid! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for label.")

  defproduction opid!: Int
  defrule opid! = (?x:#opid)
  fail-if opid! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for operation.")

  public defproduction int!: Int
  defrule int! = (?x:#int)
  fail-if int! = () :
    RegAllocSyntaxError(closest-info(), "Expected an integer here.")

  public defproduction symbol!: Symbol
  defrule symbol! = (?x:#symbol)
  fail-if symbol! = () :
    RegAllocSyntaxError(closest-info(), "Expected a symbol here.")

  defproduction register-type!: RegisterType
  defrule register-type! = (?x:#register-type)
  fail-if register-type! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for register type.")

  defproduction model-var!: ModelVar
  defrule model-var! = (?x:#model-var)
  fail-if model-var! = () :
    RegAllocSyntaxError(closest-info(), "Invalid syntax for model variable.")

;============================================================
;=================== ID Helpers =============================
;============================================================

;Returns true if x is a prefixed integer id.
defn integer-id? (x, str:String) -> True|False :
  match(unwrap-token(x)) :
    (sym:Symbol) :
      if prefix?(name(sym), str) :
        val rest = name(sym)[length(str) to false]
        to-int(rest) is Int
    (x) :
      false

;Extracts the integer portion of the integer id.
defn extract-integer-id! (x) -> Int :
  val sym = unwrap-token(x) as Symbol
  val i = index-when!(digit?, name(sym))
  to-int!(name(sym)[i to false])