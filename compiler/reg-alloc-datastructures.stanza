defpackage stz/reg-alloc-datastructures :
  import core
  import collections
  import stz/reg-alloc-ir
  import stz/printing-utils

;============================================================
;================= Datastructure Provider ===================
;============================================================

;A provider of fast datastructures.
public deftype ResourceProvider

;Create a new register set.
public defmulti RegisterSet (p:ResourceProvider) -> RegisterSet

;Create a new register table.
public defmulti RegisterTable<T> (p:ResourceProvider) -> RegisterTable<T>

;Create a new variable set.
public defmulti VarSet (p:ResourceProvider) -> VarSet

;Create a new variable table.
public defmulti VarTable<T> (p:ResourceProvider) -> VarTable<T>

;============================================================
;===================== Create a Provider ====================
;============================================================

public defn ResourceProvider (num-regs:Int,
                              num-fregs:Int,
                              num-vars:Int) -> ResourceProvider :
  new ResourceProvider :
    defmethod RegisterSet (this) :
      RegisterSet(BitSet(num-regs), BitSet(num-fregs))
    defmethod RegisterTable<T> (this) :
      RegisterTable<T>(Array<T>(num-regs),
                       Array<T>(num-fregs),
                       BitSet(num-regs),
                       BitSet(num-fregs))
    defmethod VarSet (this) :
      VarSet(BitSet(num-vars))
    defmethod VarTable<T> (this) : 
      VarTable<T>(Array<T>(num-vars),
                  BitSet(num-vars))

;============================================================
;====================== Register Set ========================
;============================================================

public defstruct RegisterSet <: Collection<Reg|FReg> :
  regs:BitSet
  fregs:BitSet

;Add a new register to the set.
public defn add (s:RegisterSet, r:Reg|FReg) -> True|False :
  match(r) :
    (r:Reg) : add(regs(s), index(r))
    (r:FReg) : add(fregs(s), index(r))

;Return whether a register is in the set.
public defn get (s:RegisterSet, r:Reg|FReg) -> True|False :
  match(r) :
    (r:Reg) : regs(s)[index(r)]
    (r:FReg) : fregs(s)[index(r)]

;Remove a register from the set.
public defn remove (s:RegisterSet, r:Reg|FReg) -> True|False :
  match(r) :
    (r:Reg) : remove(regs(s), index(r))
    (r:FReg) : remove(fregs(s), index(r))

;Add a bunch of registers to the set.
public defn add-all (s:RegisterSet, rs:Seqable<Reg|FReg>) -> False :
  do(add{s, _}, rs)

;Initialize the set with the given registers.
public defn set-contents (s:RegisterSet, rs:Seqable<Reg|FReg>) -> False :
  clear(s)
  add-all(s, rs)

;Clear the set.
public defn clear (s:RegisterSet) -> False :
  clear(regs(s))
  clear(fregs(s))

;Retrieve all the registers in the set.
defmethod to-seq (s:RegisterSet) :
  cat(
    seq(Reg, regs(s))
    seq(FReg, fregs(s)))

defmethod print (o:OutputStream, s:RegisterSet) :
  print(o, "RegisterSet{%,}" % [s])
    
;============================================================
;===================== Register Table =======================
;============================================================

public defstruct RegisterTable<T> <: Collection<KeyValue<Reg|FReg,T>> :
  regs:Array<T>
  fregs:Array<T>
  regset:BitSet
  fregset:BitSet

;Set an entry in the table.
public defn set<?T> (t:RegisterTable<?T>, r:Reg|FReg, x:T) -> False :
  match(r) :
    (r:Reg) :
      regs(t)[index(r)] = x
      add(regset(t), index(r))
      false
    (r:FReg) :
      fregs(t)[index(r)] = x
      add(fregset(t), index(r))
      false

;Retrieve an entry in table.
public defn get?<?T> (t:RegisterTable<?T>, r:Reg|FReg) -> T|False :
  if key?(t,r) :
    match(r) :
      (r:Reg) : regs(t)[index(r)]
      (r:FReg) : fregs(t)[index(r)]

;Return true if r is a key in the table.
public defn key? (t:RegisterTable, r:Reg|FReg) -> True|False :
  match(r) :
    (r:Reg) : regset(t)[index(r)]
    (r:FReg) : fregset(t)[index(r)]

;Force retrieve an entry in table.
public defn get<?T> (t:RegisterTable<?T>, r:Reg|FReg) -> T :
  if not key?(t,r) : fatal("Register %_ not in table." % [r])
  match(r) :
    (r:Reg) : regs(t)[index(r)]
    (r:FReg) : fregs(t)[index(r)]

;Remove an entry in the table.
public defn remove (t:RegisterTable, r:Reg|FReg) -> False :
  match(r) :
    (r:Reg) : remove(regset(t), index(r))
    (r:FReg) : remove(fregset(t), index(r))
  false

;Clear the table.
public defn clear (t:RegisterTable) -> False :
  clear(regset(t))
  clear(fregset(t))

;Retrieve all entries in the table.
defmethod to-seq<?T> (t:RegisterTable<?T>) :
  cat(
    for i in regset(t) seq :
      Reg(i) => regs(t)[i]
    for i in fregset(t) seq :
      FReg(i) => fregs(t)[i])

defmethod print (o:OutputStream, t:RegisterTable) :
  print(o, "RegisterTable(%_)" % [indented-field-list(t)])

;============================================================
;======================== Var Set ===========================
;============================================================

public defstruct VarSet <: Collection<Int> :
  bitset:BitSet

;Add a new register to the set.
public defn add (s:VarSet, v:Int) -> True|False :
  add(bitset(s), v)

;Return whether a register is in the set.
public defn get (s:VarSet, v:Int) -> True|False :
  bitset(s)[v]

;Remove a register from the set.
public defn remove (s:VarSet, v:Int) -> True|False :
  remove(bitset(s), v)

;Add a bunch of registers to the set.
public defn add-all (s:VarSet, vs:Seqable<Int>) -> False :
  do(add{s, _}, vs)

;Initialize the set with the given registers.
public defn set-contents (s:VarSet, vs:Seqable<Int>) -> False :
  clear(s)
  add-all(s, vs)

;Clear the set.
public defn clear (s:VarSet) -> False :
  clear(bitset(s))

;Retrieve all the registers in the set.
defmethod to-seq (s:VarSet) :
  to-seq(bitset(s))

defmethod print (o:OutputStream, s:VarSet) :
  val vs = for v in s seq : "V%_" % [v]
  print(o, "VarSet{%,}" % [vs])

;============================================================
;======================== Var Table =========================
;============================================================

public defstruct VarTable<T> <: Collection<KeyValue<Int,T>> :
  array:Array<T>
  varset:BitSet

;Set an entry in the table.
public defn set<?T> (t:VarTable<?T>, v:Int, x:T) -> False :
  array(t)[v] = x
  add(varset(t), v)
  false

;Retrieve an entry in table.
public defn get?<?T> (t:VarTable<?T>, v:Int) -> T|False :
  if key?(t,v) :
    array(t)[v]

;Return true if v is a key in the table.
public defn key? (t:VarTable, v:Int) -> True|False :
  varset(t)[v]

;Force retrieve an entry in table.
public defn get<?T> (t:VarTable<?T>, v:Int) -> T :
  if not key?(t,v) : fatal("Variable V%_ not in table." % [v])
  array(t)[v]

;Remove an entry in the table.
public defn remove (t:VarTable, v:Int) -> False :
  remove(varset(t), v)
  false

;Clear the table.
public defn clear (t:VarTable) -> False :
  clear(varset(t))

;Retrieve all entries in the table.
defmethod to-seq<?T> (t:VarTable<?T>) :
  for v in varset(t) seq :
    v => array(t)[v]

defmethod print (o:OutputStream, t:VarTable) :
  val entries = for entry in t seq :
    val v = "V%_" % [key(entry)]
    v => value(entry)
  print(o, "VarTable(%_)" % [indented-field-list(entries)])

;============================================================
;========================= BitSet ===========================
;============================================================
  
;Represents a dense set of integers.
public lostanza deftype BitSet <: Collection<Int> :
  num-words:long
  length:long
  var words:long ...

;Create a bitset capable of storing integers between 0 and n.
public lostanza defn BitSet (n:ref<Int>) -> ref<BitSet> :
  val num-words = (n.value + 63) / 64
  val bitset = new BitSet{num-words, n.value}
  clear(bitset)
  return bitset

;Retrieve the maximum length of the bitset.
public lostanza defn length (s:ref<BitSet>) -> ref<Int> :
  return new Int{s.length as int}

;Clear all set bits.
public lostanza defn clear (s:ref<BitSet>) -> ref<False> :
  for (var i:long = 0, i < s.num-words, i = i + 1) :
    s.words[i] = 0L
  return false

;Retrieve bit 'i' in the bitset.
public lostanza defn get (s:ref<BitSet>, i:ref<Int>) -> ref<True|False> :
  ensure-valid-index!(s,i)
  val result = call-prim test-bit(i.value as long, addr!(s.words))
  if result : return true
  else : return false

;Add an integer to the bitset.
;Returns true if added successfully.
public lostanza defn add (s:ref<BitSet>, i:ref<Int>) -> ref<True|False> :
  ensure-valid-index!(s,i)
  val result = call-prim test-and-set-bit(i.value as long, addr!(s.words))
  if result : return false
  else : return true

;Remove an integer from the bitset.
;Returns true if removed successfully.
public lostanza defn remove (s:ref<BitSet>, i:ref<Int>) -> ref<True|False> :
  ensure-valid-index!(s,i)
  val result = call-prim test-and-clear-bit(i.value as long, addr!(s.words))
  if result : return true
  else : return false

;Sanity check: Ensure that the given index is within bounds of the bitset.
defn ensure-valid-index! (s:BitSet, i:Int) -> False :
  #if-not-defined(OPTIMIZE) :
    if i < 0 or i >= length(s) :
      fatal("Index (%_) out of bounds of bitset." % [i])
  false

;Retrieve all the integers in the set.
defmethod to-seq (s:BitSet) :
  BitSetSeq(s)

;Simple slow implementation that prints out all numbers in the bitset.
defmethod print (o:OutputStream, s:BitSet) :
  print(o, "BitSet{%,}" % [s])

;Fast sequence for iterating through a BitSet.
;- bitset: The bitset that the sequence iterates over.
;- num-words: The total number of words in the bitset.
;- word-index: The current index of the word the sequence is iterating over.
;- word: The bits at the current word.
lostanza deftype BitSetSeq <: Seq<Int> :
  bitset:ref<BitSet>  
  num-words:long
  var word-index:long
  var word:long

;Create a new BitSetSeq from a BitSet.
lostanza defn BitSetSeq (bitset:ref<BitSet>) -> ref<BitSetSeq> :
  val s = new BitSetSeq{bitset, bitset.num-words, -1L, 0L}
  ensure-word-loaded(s)
  return s

;Ensure that the sequence has the next word loaded.
;This operation is guaranteed to run at the end of all user operations.
;So the postconditions guaranteed by this function can be assumed
;to always be true.
lostanza defn* ensure-word-loaded (s:ref<BitSetSeq>) -> ref<False> :
  labels :
    loop :
      ;Case: Word is non-zero, so already loaded.
      if s.word :
        return false
      ;Case: There are more words to load.
      else if s.word-index < s.num-words :
        s.word-index = s.word-index + 1
        s.word = s.bitset.words[s.word-index]
        goto loop
      ;Case: Past the end, sequence is empty.
      else :
        return false

;Return true if the sequence is empty.
lostanza defmethod empty? (s:ref<BitSetSeq>) -> ref<True|False> :
  if s.word-index < s.num-words : return false
  else : return true

;Peek at the next integer in the sequence.
lostanza defmethod peek (s:ref<BitSetSeq>) -> ref<Int> :
  ensure-non-empty!(s)
  val i = num-leading-zeros(s.word)
  val num = s.word-index << 6 + i
  return new Int{num as int}

;Helper: Fatal error if the given sequence is empty.
defn ensure-non-empty! (s:BitSetSeq) :
  fatal("BitSet sequence is empty.") when empty?(s)

;Retrieve the next integer in the sequence.
lostanza defmethod next (s:ref<BitSetSeq>) -> ref<Int> :
  ;Retrieve the next integer to return.
  val result = peek(s)

  ;Turn off leading bit to advance to the next entry.
  val mask = 1L << num-leading-zeros(s.word)
  s.word = s.word & (~ mask)
  ensure-word-loaded(s)
  
  ;Return the result
  return result

;Return the number of leading zero bits in the given long.
;Result is guaranteed to be in the range 0 through 64.
lostanza defn num-leading-zeros (word:long) -> int :
  val x = call-prim lowest-zero-bit-count(word)
  return x as int