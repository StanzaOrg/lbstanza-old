defpackage stz/reg-alloc-datastructures :
  import core
  import collections
  import stz/reg-alloc-ir

;============================================================
;================= Datastructure Provider ===================
;============================================================

;A provider of fast datastructures.
public deftype ResourceProvider

;Create a new register set.
public defmulti RegisterSet (p:ResourceProvider) -> RegisterSet

;Create a new register table.
public defmulti RegisterTable<T> (p:ResourceProvider) -> RegisterTable<T>

;Create a new variable set.
public defmulti VarSet (p:ResourceProvider) -> VarSet

;Create a new variable table.
public defmulti VarTable<T> (p:ResourceProvider) -> VarTable<T>

;============================================================
;===================== Create a Provider ====================
;============================================================

public defn ResourceProvider (num-regs:Int,
                              num-fregs:Int,
                              num-vars:Int) -> ResourceProvider :
  new ResourceProvider :
    defmethod RegisterSet (this) :
      RegisterSet(BitSet(num-regs), BitSet(num-fregs))
    defmethod RegisterTable<T> (this) :
      RegisterTable<T>(Array<T>(num-regs),
                       Array<T>(num-fregs),
                       BitSet(num-regs),
                       BitSet(num-fregs))
    defmethod VarSet (this) :
      VarSet(BitSet(num-vars))
    defmethod VarTable<T> (this) : 
      VarTable<T>(Array<T>(num-vars),
                  BitSet(num-vars))

;============================================================
;====================== Register Set ========================
;============================================================

public defstruct RegisterSet :
  regs:BitSet
  fregs:BitSet

;Add a new register to the set.
public defn add (s:RegisterSet, r:Reg|FReg) -> True|False :
  match(r) :
    (r:Reg) : add(regs(s), index(r))
    (r:FReg) : add(fregs(s), index(r))

;Return whether a register is in the set.
public defn get (s:RegisterSet, r:Reg|FReg) -> True|False :
  match(r) :
    (r:Reg) : regs(s)[index(r)]
    (r:FReg) : fregs(s)[index(r)]

;Remove a register from the set.
public defn remove (s:RegisterSet, r:Reg|FReg) -> True|False :
  match(r) :
    (r:Reg) : remove(regs(s), index(r))
    (r:FReg) : remove(fregs(s), index(r))

;Add a bunch of registers to the set.
public defn add-all (s:RegisterSet, rs:Seqable<Reg|FReg>) -> False :
  do(add{s, _}, rs)

;Initialize the set with the given registers.
public defn set-contents (s:RegisterSet, rs:Seqable<Reg|FReg>) -> False :
  clear(s)
  add-all(s, rs)

;Clear the set.
public defn clear (s:RegisterSet) -> False :
  clear(regs(s))
  clear(fregs(s))
    
;============================================================
;===================== Register Table =======================
;============================================================

public defstruct RegisterTable<T> :
  regs:Array<T>
  fregs:Array<T>
  regset:BitSet
  fregset:BitSet

;Set an entry in the table.
public defn set<?T> (t:RegisterTable<?T>, r:Reg|FReg, x:T) -> False :
  match(r) :
    (r:Reg) :
      regs(t)[index(r)] = x
      add(regset(t), index(r))
      false
    (r:FReg) :
      fregs(t)[index(r)] = x
      add(fregset(t), index(r))
      false

;Retrieve an entry in table.
public defn get?<?T> (t:RegisterTable<?T>, r:Reg|FReg) -> T|False :
  if key?(t,r) :
    match(r) :
      (r:Reg) : regs(t)[index(r)]
      (r:FReg) : fregs(t)[index(r)]

;Return true if r is a key in the table.
public defn key? (t:RegisterTable, r:Reg|FReg) -> True|False :
  match(r) :
    (r:Reg) : regset(t)[index(r)]
    (r:FReg) : fregset(t)[index(r)]

;Force retrieve an entry in table.
public defn get<?T> (t:RegisterTable<?T>, r:Reg|FReg) -> T :
  if not key?(t,r) : fatal("Register %_ not in table." % [r])
  match(r) :
    (r:Reg) : regs(t)[index(r)]
    (r:FReg) : fregs(t)[index(r)]

;Remove an entry in the table.
public defn remove (t:RegisterTable, r:Reg|FReg) -> False :
  match(r) :
    (r:Reg) : remove(regset(t), index(r))
    (r:FReg) : remove(fregset(t), index(r))
  false

;Clear the table.
public defn clear (t:RegisterTable) -> False :
  clear(regset(t))
  clear(fregset(t))

;============================================================
;======================== Var Set ===========================
;============================================================

public defstruct VarSet :
  bitset:BitSet

;============================================================
;======================== Var Table =========================
;============================================================

public defstruct VarTable<T> :
  array:Array<T>
  varset:BitSet

;============================================================
;========================= BitSet ===========================
;============================================================
  
;Represents a dense set of integers.
public lostanza deftype BitSet :
  num-words:long
  length:long
  var words:long ...

;Create a bitset capable of storing integers between 0 and n.
public lostanza defn BitSet (n:ref<Int>) -> ref<BitSet> :
  val num-words = (n.value + 63) / 64
  val bitset = new BitSet{num-words, n.value}
  clear(bitset)
  return bitset

;Retrieve the maximum length of the bitset.
public lostanza defn length (s:ref<BitSet>) -> ref<Int> :
  return new Int{s.length as int}

;Clear all set bits.
public lostanza defn clear (s:ref<BitSet>) -> ref<False> :
  for (var i:long = 0, i < s.num-words, i = i + 1) :
    s.words[i] = 0L
  return false

;Retrieve bit 'i' in the bitset.
public lostanza defn get (s:ref<BitSet>, i:ref<Int>) -> ref<True|False> :
  ensure-valid-index!(s,i)
  val result = call-prim test-bit(i.value as long, addr!(s.words))
  if result : return true
  else : return false

;Add an integer to the bitset.
;Returns true if added successfully.
public lostanza defn add (s:ref<BitSet>, i:ref<Int>) -> ref<True|False> :
  ensure-valid-index!(s,i)
  val result = call-prim test-and-set-bit(i.value as long, addr!(s.words))
  if result : return false
  else : return true

;Remove an integer from the bitset.
;Returns true if removed successfully.
public lostanza defn remove (s:ref<BitSet>, i:ref<Int>) -> ref<True|False> :
  ensure-valid-index!(s,i)
  val result = call-prim test-and-clear-bit(i.value as long, addr!(s.words))
  if result : return true
  else : return false

;Sanity check: Ensure that the given index is within bounds of the bitset.
defn ensure-valid-index! (s:BitSet, i:Int) -> False :
  #if-not-defined(OPTIMIZE) :
    if i < 0 or i >= length(s) :
      fatal("Index (%_) out of bounds of bitset." % [i])
  false

;Simple slow implementation that prints out all numbers in the bitset.
defmethod print (o:OutputStream, s:BitSet) :
  val nums = for i in 0 to length(s) filter : s[i]
  print(o, "BitSet{%,}" % [nums])