defpackage stz/reg-alloc-datastructures :
  import core
  import collections
  import stz/reg-alloc-ir

;============================================================
;================= Datastructure Provider ===================
;============================================================

;A provider of fast datastructures.
public deftype ResourceProvider

;Create a new register set.
public defmulti RegisterSet (p:ResourceProvider) -> RegisterSet

;Create a new register table.
public defmulti RegisterTable (p:ResourceProvider) -> RegisterTable

;============================================================
;====================== Register Set ========================
;============================================================

public defstruct RegisterSet :
  regs:Array<Int>
  fregs:Array<Int>
  marker:Int with: (setter => set-marker)
    
;============================================================
;===================== Register Table =======================
;============================================================

public defstruct RegisterTable<T> :
  regs:Array<T>
  fregs:Array<T>
  regset:RegisterSet

;============================================================
;======================== Var Table =========================
;============================================================

;public defstruct VarTable<T> :

;============================================================
;========================= BitSet ===========================
;============================================================
  
public lostanza deftype BitSet :
  num-words:long
  length:long
  var words:long ...

public lostanza defn BitSet (n:ref<Int>) -> ref<BitSet> :
  val num-words = (n.value + 63) / 64
  val bitset = new BitSet{num-words, n.value}
  clear(bitset)
  return bitset

public lostanza defn length (s:ref<BitSet>) -> ref<Int> :
  return new Int{s.length as int}

public lostanza defn clear (s:ref<BitSet>) -> ref<False> :
  for (var i:long = 0, i < s.num-words, i = i + 1) :
    s.words[i] = 0L
  return false

public lostanza defn get (s:ref<BitSet>, i:ref<Int>) -> ref<True|False> :
  ensure-valid-index!(s,i)
  val result = call-prim test-bit(i.value as long, addr!(s.words))
  if result : return true
  else : return false

public lostanza defn add (s:ref<BitSet>, i:ref<Int>) -> ref<True|False> :
  ensure-valid-index!(s,i)
  val result = call-prim test-and-set-bit(i.value as long, addr!(s.words))
  if result : return false
  else : return true

public lostanza defn remove (s:ref<BitSet>, i:ref<Int>) -> ref<True|False> :
  ensure-valid-index!(s,i)
  val result = call-prim test-and-clear-bit(i.value as long, addr!(s.words))
  if result : return true
  else : return false

defn ensure-valid-index! (s:BitSet, i:Int) -> False :
  #if-not-defined(OPTIMIZE) :
    if i < 0 or i >= length(s) :
      fatal("Index (%_) out of bounds of bitset." % [i])
  false

defmethod print (o:OutputStream, s:BitSet) :
  val nums = for i in 0 to length(s) filter : s[i]
  print(o, "BitSet{%,}" % [nums])