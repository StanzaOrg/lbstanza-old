defpackage stz/reg-alloc-shuffle :
  import core
  import collections
  import stz/reg-alloc-ir

;============================================================
;==================== Fast Predicate ========================
;============================================================

;Categorizes the situation according to whether the shuffling engine
;is required to perform the following parallel move.

;Definition of naive algorithm on example:
;  (R2, R6, R3) => (Rx, R2, R3)
;Step 1. For all specific target registers, perform their
;moves first, in any arbitrary order. (Release the source
;registers as part of this move.)
;Step 2. For all general target registers, perform these
;moves, moving to some arbitrary free register.

public defn needs-shuffle? (inputs:Tuple<Reg|FReg>,
                            outputs:Tuple<Location>) -> NeedsShuffle :
  ;Sanity check.
  if length(inputs) != length(outputs) :
    fatal("Mismatched lengths between inputs and outputs.")

  ;First collect all the target registers.
  ;These are the registers that will be one of the destinations
  ;of a MOVE statement.
  val target-registers = to-tuple $
    for (input in inputs, output in outputs) seq? :
      match(output:Reg|FReg) :
        if input == output : None()
        else : One(output)
      else : None()
        
  ;Case: If there are no target registers, then we're done.
  if empty?(target-registers) :
    AlreadyInPosition
  ;Case: If there exists overlap between the target registers
  ;and the input registers, then we need to make sure that we
  ;don't accidentally overwrite an input during a MOVE. In this
  ;case, the naive algorithm won't work.
  else if any?(contains?{inputs, _}, target-registers) :
    UseShuffle
  ;Case: Naive moves work fine.
  else :
    UseNaiveMoves

;Represents the result of testing the shuffle engine.
public defenum NeedsShuffle :
  AlreadyInPosition
  UseNaiveMoves
  UseShuffle

;============================================================
;====================== Shuffling Engine ====================
;============================================================

;Represents an abstract type for performing shuffles.
public deftype ShuffleEngine

;Use the engine to perform a parallel move.
;- vars: The ids of the variables being shuffled.
;- inputs: The registers that the inputs are currently in.
;- saved: For each input, whether they are already saved.
;- outputs: The desired output locations for the variables.
;- free-reg: An optional free register to use during shuffling.
;- free-freg: An optional free floating-point register to use during shuffling.
;- emit: The function to use to emit the instructions for shuffling.
public defmulti shuffle (engine:ShuffleEngine,
                         vars:Tuple<Int>,
                         inputs:Tuple<Reg|FReg>,
                         saved:Tuple<True|False>,
                         outputs:Tuple<Location>,
                         free-reg:Reg|False,
                         free-freg:FReg|False,
                         emit:ProgramStmt -> ?) -> False 

;Create a shuffle engine that can perform shuffles.
public defn ShuffleEngine (num-regs:Int, num-fregs:Int) -> ShuffleEngine :
  new ShuffleEngine
  
