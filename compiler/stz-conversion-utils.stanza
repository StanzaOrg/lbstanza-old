defpackage stz/conversion-utils :
  import core
  import collections
  import stz/utils
  import stz/set-utils
  import stz/dispatch-dag
  import stz/el-ir
  import stz/typeset
  import stz/dyn-tree

public defn etype-to-arg (ct:DynTree, t:EType, include-abstract?:True|False) -> Arg :
  defn to-set (t:EType) :
    match(t) :
      (t:EAnd) : IntersectSet([to-set(a(t)), to-set(b(t))])
      (t:EOr) : UnionSet([to-set(a(t)), to-set(b(t))])
      (t:ETVar|ETop) : AllSet()
      (t:EOf) :
        AtomSet $
          if include-abstract? : all-children(ct, n(t))
          else : all-leaves(ct, n(t))
  set-to-arg(to-set(t))

public defn to-arg (t:TypeSet, set-representation:Int -> Tuple<Int>) -> Arg :
  defn to-set (t:TypeSet) :
    match(t) :
      (t:AndType) : IntersectSet(map(to-set, types(t)))
      (t:OrType) : UnionSet(map(to-set, types(t)))
      (t:TopType) : AllSet()
      (t:SingleType) : AtomSet(set-representation(type(t)))
  set-to-arg(to-set(t))

public defn to-branches (bs:Seqable<Seqable<TypeSet>>, set-representation:Int -> Tuple<Int>) -> Tuple<Branch> :
  to-tuple $ for b in bs seq :
    Branch(to-tuple(seq(to-arg{_, set-representation}, b)))

public defn set-to-arg (s:NumSet) -> Arg :
  match(remove-alls(s)) :
    (s:AllSet) :
      Top()
    (s) :
      defn loop (s:NumSet) :
        match(s) :
          (s:AtomSet) :
            values(s)
          (s:IntersectSet) :
            intersect(seq(loop, sets(s)))
          (s:UnionSet) :
            union(seq(loop, sets(s)))
      Nums(to-tuple $ loop(s))
