;See License.txt for details about licensing.

defpackage stz/bb :
   import core
   import collections
   import stz/algorithms
   import stz/ids
   import stz/utils
   import stz/imms with :
      prefix(Op) => Tgt
   import stz/tgt-ir with :
      prefix(
      ;Instructions
         Ins ArgsIns Return CArgsIns CReturn SetIns ConvertIns
         InterpretIns BinOp UnaOp Load Store Addr Call CallStack
         TCall TCallStack CallC Label Goto Branch SpecialBranch SpecialOp
      ;Top Level Instructions   
         DefIns DefFn DefVar) => Tgt
   import stz/bb-ir
   import stz/asm-ir with :
      prefix(Ins XchgIns SetIns ConvertIns ReinterpretIns UnaOp BinOp DualOp
             Load Store Call Return Goto Branch Label ExLabel DefData DefText
             DefByte DefInt DefLong DefFloat DefDouble DefString DefSpace DefLabel) => Asm
   import stz/padder
   import stz/backend
   import stz/params

;============================================================
;==================== Main Driver ===========================
;============================================================

public defn compile (def:TgtDefFn,
                     backend:Backend,
                     output:Vector<AsmIns>,
                     infos:Vector<KeyValue<Int,FileInfo>>) -> False :

   var d = normalize(def)
   d = spill-call-args(d, backend)   
   val [tt, bb-ir] = to-bb-ir(d, backend)

   ;Track changes
   var u:Unit = bb-ir
   u = remove-critical-edges(u)
   index-prog(u)
   add-annotations()
   allocate-classes(backend)
   register-assignment(backend)
   #if-not-defined(OPTIMIZE) :
      verify-register-assignment(backend)
   val smap = calculate-stack-map()
   enforce-clears(smap)
   val ins = collapse-blocks(smap)
   assemble(n(d), backend, ins, smap, output, infos)

;============================================================
;====================== Utilities ===========================
;============================================================

deftype Cache<T>
defmulti fresh<?T> (c:Cache<?T>, update: (() -> T) & (T -> T)) -> T
defn Cache<T> () :
   var value:T
   var initialized? = false
   new Cache<T> :
      defmethod fresh (this, update:(() -> T) & (T -> T)) :
         if initialized? : value = update(value)
         else : value = update()
         value

defn IntTable<T> (c:Cache<IntTable<T>>) :
   fresh{c, _} $ multifn :
      () : IntTable<T>()
      (t) : (clear(t), t)

defn Vector<T> (c:Cache<Vector<T>>) :
   fresh{c, _} $ multifn :
      () : Vector<T>()
      (v) : (clear(v), v)

defn Array<T> (c:Cache<Array<T>>, n:Int, x0:T) :
   fresh{c, _} $ multifn :
      () :
         Array<T>(n, x0)
      (a) :
         if length(a) < n : (set-all(a, 0 to n, x0), a)
         else : Array<T>(max(2 * length(a), n), x0)

defn Array<T> (c:Cache<Array<T>>, n:Int) :
   fresh{c, _} $ multifn :
      () :
         Array<T>(n)
      (a) :
         if length(a) < n : a
         else : Array<T>(max(2 * length(a), n))

defn VarArray<T> (c:Cache<Array<T>>, x0:T) :
   Array<T>(c, nvars(), x0)

defn BlockArray<T> (c:Cache<Array<T>>, x0:T) :
   Array<T>(c, nblocks(), x0)

defn BitArray (c:Cache<BitArray>, n:Int, x0:True|False) :
   fresh{c, _} $ multifn :
      () :
         BitArray(n, x0)
      (a) :
         if length(a) < n : (clear(a, n, x0), a)
         else : BitArray(max(2 * length(a), n), x0)

defn VarBitArray (c:Cache<BitArray>, x0:True|False) :
   BitArray(c, nvars(), x0)

defn BlockBitArray (c:Cache<BitArray>, x0:True|False) :
   BitArray(c, nblocks(), x0)

;============================================================
;================= Spill Call Arguments =====================
;============================================================

defn spill-call-args (def:TgtDefFn, backend:Backend) :
   ;     Type Layer
   ;     ----------
   val int-values = HashTable<Int,True|False>()
   for d in defs(def) do :
      int-values[n(d)] = type(d) is IntegerType

   defn int? (x:Imm) :
      match(x) :
         (x:Var) : int-values[n(x)]
         (x) : true

   ;     Output State
   ;     ------------
   val output = Vector<TgtIns>()
   val defvars = Vector<TgtDefVar>()
   do(add{defvars, _}, defs(def))
   defn emit (i:TgtIns) :
      add(output, i)
   defn make-var (t:Type) :
      val n = fresh-id()
      add(defvars, TgtDefVar(n, t))
      Var(n)

   var cached-c-rsp : False|Var = false
   defn saved-c-rsp () :
      if cached-c-rsp is False :
         cached-c-rsp = make-var(LongType())
      cached-c-rsp as Var

   ;     Split Locations
   ;     ---------------
   ;Split a group of values into which go into memory, and which go
   ;into registers.
   defn split-mem-locs<?T> (xs:List<?T&Imm>, nregs:Int, nfregs:Int) :
      val regs = to-seq(0 to nregs)
      val fregs = to-seq(0 to nfregs)
      val reg-xs = Vector<T&Imm>()
      val mem-xs = Vector<T&Imm>()
      for x in xs do :
         if int?(x) :
            if empty?(regs) :
               add(mem-xs, x)
            else :
               next(regs)
               add(reg-xs, x)

         else :
            if empty?(fregs) :
               add(mem-xs, x)
            else :
               next(fregs)
               add(reg-xs, x)

      [to-list(reg-xs), to-list(mem-xs)]
   defn split-call-locs<?T> (xs:List<?T&Imm>) :
      split-mem-locs(xs, length(call-regs(backend)), length(call-fregs(backend)))
   defn split-callc-locs<?T> (xs:List<?T&Imm>, varargs:List<?T&Imm>) :
      match(backend) :
         (backend:W64Backend) :
            ;Pull out memory arguments
            val reg-list = Vector<T&Imm>()
            val varargs-list = Vector<T&Imm>()
            val mem-list = Vector<T>()
            val regs = to-seq(0 to 4)
            defn place-on (xs:List<T>, list:Vector<T>) :
               for x in xs do :
                  if empty?(regs) :
                     add(mem-list, x)
                  else :
                     next(regs)
                     add(list, x)
            place-on(xs, reg-list)
            place-on(varargs, varargs-list)
            ;Return separated lists
            [to-list(reg-list), to-list(varargs-list), to-list(mem-list)]
         (backend) :
            val reg-list = Vector<T&Imm>()
            val varargs-list = Vector<T&Imm>()
            val mem-list = Vector<T>()
            val regs = to-seq(callc-regs(backend))
            val fregs = to-seq(callc-fregs(backend))
            defn place-on (xs:List<T&Imm>, list:Vector<T&Imm>) :
               for x in xs do :
                  add{_, x} $
                     if int?(x) :
                        if empty?(regs) : mem-list
                        else : (next(regs), list)
                     else :
                        if empty?(fregs) : mem-list
                        else : (next(fregs), list)
            place-on(xs, reg-list)
            place-on(varargs, varargs-list)
            ;Return separated lists
            [to-list(reg-list), to-list(varargs-list), to-list(mem-list)]

   ;     Main Algorithm
   ;     --------------
   ;Convert calls
   for e in body(def) do :
      match(e) :
         (e:TgtArgsIns) :
            val [xs, mxs] = split-call-locs(xs(e))
            emit(TgtArgsIns(xs))
            for (x in mxs, o in 0 to false by 8) do :
               emit(TgtLoad(x, Mem(ARG-LBL), o))
         (e:TgtReturn) :
            val [xs, mxs] = split-call-locs(xs(e))
            for (x in mxs, o in 0 to false by 8) do :
               emit(TgtStore(x, Mem(ARG-LBL), o))
            emit(TgtReturn(xs))
         (e:TgtCArgsIns) :
            val sp = make-var(LongType())
            val [xs, vs, mxs] = split-callc-locs(xs(e), List())
            emit(TgtCArgsIns(cons(sp, xs)))
            for (x in mxs, i in 0 to false) do :
               emit(TgtLoad(x, sp, 8 * (i + 1)))
            emit(TgtLoad(saved-c-rsp(), Mem(C-RSP-LBL), 0))
            emit(TgtStore(Mem(C-RSP-LBL), sp, 0))
         (e:TgtCReturn) :
            val sp = make-var(LongType())
            emit(TgtLoad(sp, Mem(C-RSP-LBL), 0))
            emit(TgtStore(Mem(C-RSP-LBL), saved-c-rsp(), 0))
            emit(TgtCReturn(cons(sp, xs(e))))
         (e:TgtCall) :
            val [ys, mys] = split-call-locs(ys(e))
            val [xs, mxs] = split-call-locs(xs(e))
            for (y in mys, o in 0 to false by 8) do :
               emit(TgtStore(Mem(ARG-LBL), y, o))
            emit(TgtCall(arity(e), xs, f(e), ys, new-stack?(e), info(e)))
            for (x in mxs, o in 0 to false by 8) do :
               emit(TgtLoad(x, Mem(ARG-LBL), o))
         (e:TgtCallStack) :
            val [ys, mys] = split-call-locs(ys(e))
            val [xs, mxs] = split-call-locs(xs(e))
            for (y in mys, o in 0 to false by 8) do :
               emit(TgtStore(Mem(ARG-LBL), y, o))
            emit(TgtCallStack(xs, f(e), ys, info(e)))
            for (x in mxs, o in 0 to false by 8) do :
               emit(TgtLoad(x, Mem(ARG-LBL), o))
         (e:TgtTCall) :
            val [ys, mys] = split-call-locs(ys(e))
            for (y in mys, o in 0 to false by 8) do :
               emit(TgtStore(Mem(ARG-LBL), y, o))
            emit(TgtTCall(arity(e), f(e), ys, new-stack?(e)))
         (e:TgtTCallStack) :
            val [ys, mys] = split-call-locs(ys(e))
            for (y in mys, o in 0 to false by 8) do :
               emit(TgtStore(Mem(ARG-LBL), y, o))
            emit(TgtTCallStack(f(e), ys))
         (e:TgtCallC) :
            val [ys, vs, mys] = split-callc-locs(ys(e), varargs(e))
            val ssp = make-var(LongType()) ;Stanza stack pointer
            emit(TgtLoad(ssp, Mem(STACK-PTR-LBL), 0))
            match(backend) :
               (backend:W64Backend) :
                  if empty?(mys) :
                     ;TODO: n parameter not right
                     emit(TgtCallC(0, xs(e), f(e), ys, vs))
                  else :
                     val n = length(mys) ;alignment issues?
                     val csp = make-var(LongType()) ;C stack pointer
                     emit(TgtLoad(csp, Mem(C-RSP-LBL), 0))
                     for (y in mys, i in 0 to false) do :
                        emit(TgtStore(csp, y, 8 * (i - 8 - n))) ;8 for saved C context
                     emit(TgtCallC(length(mys), xs(e), f(e), ys, vs))
               (backend) :
                  if empty?(mys) :
                     emit(TgtCallC(0, xs(e), f(e), ys, vs))
                  else :
                     val n = length(mys) | 1
                     val csp = make-var(LongType()) ;C stack pointer
                     emit(TgtLoad(csp, Mem(C-RSP-LBL), 0))
                     for (y in mys, i in 0 to false) do :
                        emit(TgtStore(csp, y, 8 * (i - 6 - n))) ;6 for saved C context
                     emit(TgtCallC(length(mys), xs(e), f(e), ys, vs))
            emit(TgtStore(Mem(STACK-PTR-LBL), ssp, 0))
         (e) :
            emit(e)

   ;Return result
   TgtDefFn(n(def), defvars, output)


;============================================================
;================== Normalization ===========================
;============================================================

defn normalize (d:TgtDefFn) -> TgtDefFn :

   ;                   State
   ;                   =====
   ;(clones[x] = ys) => ys are all clones of x
   val clones = HashTable<Int,List<Int>>()
   val body* = Vector<TgtIns>()
   val defs* = Vector<TgtDefVar>()

   ;                   Helpers
   ;                   =======

   defn operands (i:TgtIns) -> List<Imm> :
      match(i) :
         (i:TgtConvertIns) : List(y(i))
         (i:TgtInterpretIns) : List(y(i))
         (i:TgtBinOp) : List(y(i), z(i))
         (i:TgtUnaOp) : List(y(i))
         (i:TgtLoad) : List(y(i))

   defn update-x (i:TgtIns, x:Var) :
      match(i) :
         (i:TgtConvertIns) : TgtConvertIns(x, y(i))
         (i:TgtInterpretIns) : TgtInterpretIns(x, y(i))
         (i:TgtBinOp) : TgtBinOp(x, op(i), y(i), z(i))
         (i:TgtUnaOp) : TgtUnaOp(x, op(i), y(i))
         (i:TgtLoad) : TgtLoad(x, y(i), offset(i))

   defn matches? (x:Var, y:Imm) :
      match(y) :
         (y:Var) : n(x) == n(y)
         (y) : false

   defn matches? (x:Var, ys:List<Imm>) :
      for y in ys any? :
         matches?(x, y)

   defn clone (x:Var) :
      val n* = fresh-id()
      clones[n(x)] = cons(n*, get?(clones, n(x), List()))
      Var(n*)

   ;                   Driver
   ;                   ======

   ;Normalize instructions
   for i in body(d) do :
      match(i) :
         (i:TgtSetIns) :
            if not matches?(x(i), y(i)) :
               add(body*, i)
         (i:TgtLoad|TgtBinOp|TgtUnaOp|TgtInterpretIns|TgtConvertIns) :
            if matches?(x(i), operands(i)) :
               val x* = clone(x(i))
               add(body*, update-x(i, x*))
               add(body*, TgtSetIns(x(i), x*))
            else :
               add(body*, i)
         (i) :
            add(body*, i)

   ;Copy defs with clones
   for def in defs(d) do :
      add(defs*, def)
      if key?(clones, n(def)) :
         for y in clones[n(def)] do :
            add(defs*, TgtDefVar(y, type(def)))

   ;Return normalized DefFn
   TgtDefFn(n(d), defs*, body*)



;============================================================
;============== Translation to BB IR=========================
;============================================================

deftype Binary :
   AddOp <: Binary
   SubOp <: Binary
   MulOp <: Binary
   DivOp <: Binary
   ModOp <: Binary
   AndOp <: Binary
   OrOp <: Binary
   XorOp <: Binary
   ShlOp <: Binary
   ShrOp <: Binary
   AshrOp <: Binary
   EqOp <: Binary
   NeOp <: Binary
   LtOp <: Binary
   GtOp <: Binary
   LeOp <: Binary
   GeOp <: Binary
   UleOp <: Binary
   UltOp <: Binary
   UgtOp <: Binary
   UgeOp <: Binary

deftype Unary :
   NotOp <: Unary
   NegOp <: Unary

deftype Commutative :
   AddOp <: Commutative
   AndOp <: Commutative
   OrOp <: Commutative
   XorOp <: Commutative

deftype Comparison :
   EqOp <: Comparison
   NeOp <: Comparison
   LtOp <: Comparison
   GtOp <: Comparison
   LeOp <: Comparison
   GeOp <: Comparison
   UleOp <: Comparison
   UltOp <: Comparison
   UgtOp <: Comparison
   UgeOp <: Comparison

defn to-bb-ir (d:TgtDefFn, backend:Backend) -> [HashTable<Int,Type>, Unit] :
   ;State
   val defvars = Vector<TgtDefVar>()
   val block-list = Vector<Block>()
   val type-table = HashTable<Int,Type>()

   ;Helpers
   defn imm-type (i:Imm) :
      match(i) :
         (i:ByteImm) : ByteType()
         (i:IntImm) : IntType()
         (i:LongImm) : LongType()
         (i:RegSP) : LongType()
         (i:Var) : type-table[n(i)]
         (i:Mem) : LongType()
         (i:ExMem) : LongType()

   defn fresh-block (n:Int) :
      Block(n, Vector<Ins>(), List())

   var active-block = fresh-block(fresh-id())

   defn emit (i:Ins) :
      add(ins(active-block), i)

   defn close-block (ns:List<Int>) :
      val ab = active-block
      add(block-list, Block(n(ab), ins(ab), ns))

   defn force-var (x:Imm) :
      match(x) :
         (x:Var) :
            x
         (x) :
            val v = fresh(imm-type(x))
            emit(Set(v, x))
            v

   defn force-operand (x:Imm) :
      val max = 1 << 16
      val min = -1 << 16
      defn large? (v:Int) : (v < min) or (v > max)
      defn large? (v:Long) : (v < to-long(min)) or (v > to-long(max))
      match(x) :
         (x:Var) : x
         (x:IntImm|LongImm) : force-var(x) when large?(value(x)) else x
         (x:Mem|ExMem) : force-var(x)
         (x) : x

   defn fresh (t:Type) :
      val n = fresh-id()
      add(defvars, TgtDefVar(n, t))
      type-table[n] = t
      Var(n)

   ;Add unit defs
   for def in defs(d) do :
      add(defvars, def)
      type-table[n(def)] = type(def)

   ;Translate instructions
   for i in body(d) do :
      match(i) :
         (i:TgtArgsIns) :
            emit(Args(xs(i), StanzaContext()))
         (i:TgtCArgsIns) :
            val ctxt = match(backend) :
               (backend:W64Backend) :
                  val regs = seq(Reg, callc-regs(backend))
                  val fregs = seq(FReg, callc-fregs(backend))
                  val xs* = for x in tail(xs(i)) map :
                     match(imm-type(x)) :
                        (t:IntegerType) : (next(fregs), next(regs))
                        (t:RealType) : (next(regs), next(fregs))
                  CContext(cons(Reg(6), xs*))
               (backend) :
                  val regs = seq(Reg, callc-regs(backend))
                  val fregs = seq(FReg, callc-fregs(backend))
                  val xs* = for x in tail(xs(i)) map :
                     match(imm-type(x)) :
                        (t:IntegerType) : next(regs)
                        (t:RealType) : next(fregs)
                  CContext(cons(Reg(6), xs*))
            emit(Args(xs(i), ctxt))
         (i:TgtSetIns) :
            emit(Set(x(i), y(i)))
         (i:TgtBinOp) :
            val t = imm-type(x(i))
            val top = op(i)
            val x* = x(i)
            val y* = force-operand(y(i))
            val z* = force-operand(z(i))

            defn cast-to-int (f: (Type, Var, Var, Var) -> False) :
               val ix = fresh(IntType())
               val iy = fresh(IntType())
               val iz = fresh(IntType())
               emit(Op(ConvOp(), List(iy), List(force-var(y*))))
               emit(Op(ConvOp(), List(iz), List(force-var(z*))))
               f(IntType(), ix, iy, iz)
               emit(Op(ConvOp(), List(x*), List(ix)))

            match(top) :
               (top:DivOp) :
                  match(t) :
                     (t:RealType) :
                        emit(Op(top, List(x*), List(y*, z*)))
                        emit(Op(NoOp(), List(), List(z*)))
                     (t:ByteType) :
                        cast-to-int $ fn (t, x*, y*, z*) :
                           emit(Op(DivModOp(), List(x*, fresh(t)), List(y*, z*)))
                           emit(Op(NoOp(), List(), List(z*)))
                     (t) :
                        val y* = force-var(y*)
                        val z* = force-var(z*)
                        emit(Op(DivModOp(), List(x*, fresh(t)), List(y*, z*)))
                        emit(Op(NoOp(), List(), List(z*)))
               (top:ModOp) :
                  match(t) :
                     (t:ByteType) :
                        cast-to-int $ fn (t, x*, y*, z*) :
                           emit(Op(DivModOp(), List(fresh(t), x*), List(y*, z*)))
                           emit(Op(NoOp(), List(), List(z*)))
                     (t) :
                        val y* = force-var(y*)
                        val z* = force-var(z*)
                        emit(Op(DivModOp(), List(fresh(t), x*), List(y*, z*)))
                        emit(Op(NoOp(), List(), List(z*)))
               (top:MulOp) :
                  match(t) :
                     (t:ByteType) :
                        cast-to-int $ fn (t, x*, y*, z*) :
                           emit(Op(top, List(x*), List(y*, z*)))
                     (t) : emit(Op(top, List(x*), List(y*, z*)))
               (top:TgtOp&Commutative) :
                  emit(Op(top, List(x*), List(y*, z*)))
               (top:TgtOp&Comparison) :
                  match(y*, z*) :
                     (y*:Val, z*:Val) : emit(Op(top, List(x*), List(force-var(y*), z*)))
                     (y*, z*) : emit(Op(top, List(x*), List(y*, z*)))
               (top) :
                  emit(Op(top, List(x*), List(y*, z*)))
                  emit(Op(NoOp(), List(), List(z*)))
         (i:TgtUnaOp) :
            val t = imm-type(x(i))
            val top = op(i)
            val x* = x(i)
            val y* = force-var(y(i))

            defn cast-to-int (f: (Type, Var, Var) -> False) :
               val ix = fresh(IntType())
               val iy = fresh(IntType())
               emit(Op(ConvOp(), List(iy), List(force-var(y*))))
               f(IntType(), ix, iy)
               emit(Op(ConvOp(), List(x*), List(ix)))

            match(t) :
               (t:ByteType) :
                  cast-to-int $ fn (t, x*, y*) :
                     emit(Op(top, List(x*), List(y*)))
               (t) : emit(Op(top, List(x*), List(y*)))
         (i:TgtConvertIns) :
            val xt = imm-type(x(i))
            val yt = imm-type(y(i))
            val x* = x(i)
            val y* = force-var(y(i))
            match(xt, yt) :
               (xt:IntegerType, yt:IntegerType) :
                  emit(Op(ConvOp(), List(x*), List(y*)))
               (xt:RealType, yt:RealType) :
                  emit(Op(ConvOp(), List(x*), List(y*)))
               (xt:ByteType, yt:RealType) :
                  val ix = fresh(IntType())
                  emit(Op(ConvOp(), List(ix), List(y*)))
                  emit(Op(ConvOp(), List(x*), List(ix)))
               (xt:IntegerType, yt:RealType) :
                  emit(Op(ConvOp(), List(x*), List(y*)))
               (xt:RealType, yt:ByteType) :
                  val iy = fresh(IntType())
                  emit(Op(ConvOp(), List(iy), List(y*)))
                  emit(Op(ConvOp(), List(x*), List(iy)))
               (xt:RealType, yt:IntegerType) :
                  emit(Op(ConvOp(), List(x*), List(y*)))
         (i:TgtInterpretIns) :
            val xt = imm-type(x(i))
            val yt = imm-type(y(i))
            val x* = x(i)
            val y* = force-var(y(i))
            emit(Op(InterpretOp(), List(x*), List(y*)))
         (i:TgtLoad) :
            val x* = x(i)
            val y* = y(i)
            emit(Op(LoadOp(offset(i)), List(x*), List(y*)))
         (i:TgtStore) :
            val x* = x(i)
            val y* = force-operand(y(i))
            emit(Op(StoreOp(offset(i)), List(), List(x*, y*)))
         (i:TgtAddr) :
            val x* = x(i)
            emit(Op(AddrOp(n(i)), List(x*), List()))
         (i:TgtCall) :
            val xs = xs(i)
            val f = f(i)
            val ys = ys(i)
            val type = StanzaCall(arity(i), false, new-stack?(i), info(i))
            emit(Call(xs, f, ys, type))
         (i:TgtCallStack) :
            val xs = xs(i)
            val f = f(i)
            val ys = ys(i)
            val type = StackCall(false, info(i))
            emit(Call(xs, f, ys, type))
         (i:TgtCallC) :
            match(backend) :
               (backend:W64Backend) :
                  defn integer-shadow (y:Imm) :
                     val float-t = imm-type(y)
                     val int-t = IntegerType(size(float-t))
                     val y* = fresh(int-t)
                     emit(Op(InterpretOp(), List(y*), List(force-var(y))))
                     y*
                  val xs* = List $
                     if empty?(xs(i)) :
                        Reg(0)
                     else :
                        match(imm-type(head(xs(i)))) :
                           (t:IntegerType) : Reg(0)
                           (t:RealType) : FReg(0)
                  val f* = Reg(1)
                  val ys* = Vector<Imm>() ;Holds final arguments
                  val ys-locs = Vector<Loc>() ;Holds calling registers for final arguments
                  val regs = seq(Reg, callc-regs(backend))
                  val fregs = seq(FReg, callc-fregs(backend))
                  for y in ys(i) do :
                     match(imm-type(y)) :
                        (t:IntegerType) :
                           add(ys*, y) ;Add argument
                           add(ys-locs, next(regs)) ;Argument goes in integer register
                           next(fregs) ;Eat float register
                        (t:RealType) :
                           add(ys*, y) ;Add argument
                           add(ys-locs, next(fregs)) ;Argument goes in float register
                           next(regs) ;Eat integer register
                  for y in varargs(i) do :
                     match(imm-type(y)) :
                        (t:IntegerType) :
                           add(ys*, y) ;Add argument
                           add(ys-locs, next(regs)) ;Argument goes in integer register
                           next(fregs) ;Eat float register
                        (t:RealType) :
                           add(ys*, y) ;Add argument
                           add(ys-locs, next(fregs)) ;Argument goes in float register
                           add(ys*, integer-shadow(y)) ; Add integer shadow for argument
                           add(ys-locs, next(regs)) ;Shadowed argument goes in int register
                  val frame-size =
                     if n(i) > 0 :
                        8 * (8 + (n(i) + 4) | 1)
                     else :
                        8 * (8 + length(xs(i)) | 1)
                  val ctxt = CCall(frame-size, xs*, f*, to-list(ys-locs))
                  emit(Call(xs(i), f(i), to-list(ys*), ctxt))
               (backend) :
                  val xs* = List $
                     if empty?(xs(i)) :
                        Reg(0)
                     else :
                        match(imm-type(head(xs(i)))) :
                           (t:IntegerType) : Reg(0)
                           (t:RealType) : FReg(0)
                  val f* = Reg(1)
                  val regs = seq(Reg, callc-regs(backend))
                  val fregs = seq(FReg, callc-fregs(backend))
                  val ys* = for y in append(ys(i), varargs(i)) map :
                     match(imm-type(y)) :
                        (t:IntegerType) : next(regs) ;TODO: Upcast vararg arguments
                        (t:RealType) : next(fregs)
                  val frame-size = 8 * (6 + n(i) | 1)
                  val ctxt = CCall(frame-size, xs*, f*, ys*)
                  emit(Call(xs(i), f(i), append(ys(i), varargs(i)), ctxt))
         (i:TgtTCall) :
            val f = f(i)
            val ys = ys(i)
            val type = StanzaCall(arity(i), true, new-stack?(i), false)
            emit(Call(List(), f, ys, type))
            close-block(List())
            active-block = fresh-block(fresh-id())
         (i:TgtTCallStack) :
            val f = f(i)
            val ys = ys(i)
            val type = StackCall(true, false)
            emit(Call(List(), f, ys, type))
            close-block(List())
            active-block = fresh-block(fresh-id())
         (i:TgtReturn) :
            val xs = xs(i)
            emit(Return(xs, StanzaContext()))
            close-block(List())
            active-block = fresh-block(fresh-id())
         (i:TgtCReturn) :
            ;First return is stack pointer
            val xs* = List $
               if empty?(tail(xs(i))) :
                  Reg(0)
               else :
                  match(imm-type(xs(i)[1])) :
                     (t:IntegerType) : Reg(0)
                     (t:RealType) : FReg(0)
            emit(Return(xs(i), CContext(xs*)))
            close-block(List())
            active-block = fresh-block(fresh-id())
         (i:TgtLabel) :
            close-block(List(n(i)))
            active-block = fresh-block(n(i))
         (i:TgtGoto) :
            close-block(List(n(i)))
            active-block = fresh-block(fresh-id())
         (i:TgtBranch) :
            val x* = x(i)
            val y* = y(i)
            val xs* = match(x*, y*) :
               (x*:Val, y*:Val) : List(force-var(x*), y*)
               (x*, y*) : List(x*, y*)
            emit(Branch(op(i), xs*))
            val alt = fresh-id()
            close-block(List(n(i), alt))
            active-block = fresh-block(alt)
         (i:TgtSpecialBranch) :
            emit(Branch(op(i), List()))
            val alt = fresh-id()
            close-block(List(n(i), alt))
            active-block = fresh-block(alt)
         (i:TgtSpecialOp) :
            emit(Op(op(i), List(), List()))

   ;Return
   close-block(List())
   [type-table, Unit(defvars, block-list)]

;============================================================
;=============== Critical Edge Removal ======================
;============================================================

val FORWARD-CACHE = Cache<IntTable<Int>>()
val NUM-PRED-CACHE = Cache<IntTable<Int>>()
val SAFE-BLOCK-CACHE = Cache<Vector<Block>>()
val BLOCKS-LIST-CACHE = Cache<Vector<Block>>()

defn remove-critical-edges (u:Unit) :
   ;     Forward past empty blocks
   ;     -------------------------
   val forwards = IntTable<Int>(FORWARD-CACHE)

   defn forwarded? (b:Block) : key?(forwards, n(b))

   defn resolve (n:Int) :
      match(get?(forwards, n, false)) :
         (f:False) :
            n
         (f:Int) :
            val n* = resolve(f)
            forwards[n] = n*
            n*

   for b in blocks(u) do :
      if empty?(ins(b)) :
         if length(next(b)) == 1 :
            forwards[n(b)] = head(next(b))

   defn next* (b:Block) :
      map(resolve, next(b))

   ;     Count predecessors for blocks
   ;     -----------------------------
   val num-preds-table = IntTable<Int>(NUM-PRED-CACHE)
   defn num-preds (n:Int) : get?(num-preds-table, n, 0)

   for b in blocks(u) do :
      if not forwarded?(b) :
         for n in next*(b) do :
            num-preds-table[n] = 1 + num-preds(n)

   ;     Insert safe blocks
   ;     ------------------
   val safe-blocks = Vector<Block>(SAFE-BLOCK-CACHE)
   val blocks-list = Vector<Block>(BLOCKS-LIST-CACHE)

   defn safe-block (next:Int) :
      val n = fresh-id()
      add(safe-blocks, Block(n, Vector<Ins>(), List(next)))
      n

   for b in blocks(u) do :
      add{blocks-list, Block(n(b), ins(b), _)} $
         ;If multiple successors
         if length(next(b)) > 1 :
            for n in next*(b) map :
               if num-preds(n) > 1 : safe-block(n)
               else : n
         ;Otherwise
         else : next*(b)
   add-all(blocks-list, safe-blocks)

   ;     Return result
   ;     -------------
   Unit(defs(u), blocks-list)

;============================================================
;================== Working Set =============================
;============================================================

val BLOCKS = Vector<Block>()
val VAR-TYPES = Vector<Type>()
val IN-PORTS = Vector<List<Port>>()
val OUT-PORTS = Vector<List<Port>>()
val PREDECESSORS = Vector<List<Int>>()

defn nblocks () : length(BLOCKS)
defn nvars () : length(VAR-TYPES)

;============================================================
;==================== Index =================================
;============================================================

val BLOCK-DEFS-CACHE = Cache<BitArray>()
val VAR-USES-CACHE = Cache<Array<List<KeyValue<Int,Int>>>>()
val VAR-INDICES-CACHE = Cache<IntTable<Int>>()
val BLOCK-INDICES-CACHE = Cache<IntTable<Int>>()
val BLOCK-TABLE-CACHE = Cache<IntTable<False|Block>>()
val IN-DISTS-CACHE = Cache<Array<Int>>()
val OUT-DISTS-CACHE = Cache<Array<Int>>()
val IN-DIRTY-CACHE = Cache<Vector<Int>>()
val OUT-DIRTY-CACHE = Cache<Vector<Int>>()

defn index-prog (u:Unit) :
   ;Populate Block Table
   val block-table = IntTable<False|Block>(BLOCK-TABLE-CACHE)
   for b in blocks(u) do : block-table[n(b)] = b
   ;Populate Variables
   clear(VAR-TYPES)
   val var-indices = IntTable<Int>(VAR-INDICES-CACHE)
   for def in defs(u) do :
      val [n, t] = [n(def), type(def)]
      add(VAR-TYPES, t)
      var-indices[n] = length(VAR-TYPES) - 1
   ;Populate Blocks in Reverse Post Order
   clear(BLOCKS)
   defn order (n:Int) :
      match(block-table[n]) :
         (b:Block) :
            block-table[n] = false
            do(order, next(b))
            add(BLOCKS, b)
         (b:False) :
            false
   order(n(blocks(u)[0]))
   reverse!(BLOCKS)
   ;Assign Block indices
   val block-indices = IntTable<Int>(BLOCK-INDICES-CACHE)
   for (b in BLOCKS, i in 0 to false) do :
      block-indices[n(b)] = i

   ;Rename Instruction
   defn rename (i:Ins) :
      for imm in i map :
         match(imm) :
            (imm:Var) : Var(var-indices[n(imm)])
            (imm) : imm

   ;Compute renamed instruction, predecessors, variable usages, variable definitions
   ;for each block
   val var-uses = VarArray<List<KeyValue<Int,Int>>>(VAR-USES-CACHE, List())
   val block-defs = BitArray(BLOCK-DEFS-CACHE, nblocks() * nvars(), false)
   clear(PREDECESSORS, nblocks(), List())

   for blk in BLOCKS map! :
      ;Rename block indices
      val next* = map({block-indices[_]}, next(blk))
      val n* = block-indices[n(blk)]
      ;Mark definitions and usages
      defn mark-defined (v:Var) :
         block-defs[n* * nvars() + n(v)] = true
      defn defined? (v:Var) :
         block-defs[n* * nvars() + n(v)]
      defn mark-used (v:Var, d:Int) :
         if not defined?(v) :
            var-uses[n(v)] = cons(n* => d, var-uses[n(v)])
      ;Rename instructions
      val idx-counter = to-seq(0 to false)
      val ins* = for i in ins(blk) map<Ins> :     ;TODO: Use a vector pool
         val idx = next(idx-counter)
         val i* = rename(i)
         do-used(mark-used{_, idx}, i*)
         do-defined(mark-defined, i*)
         i*
      ;Record predecessors
      for n in next* do :
         PREDECESSORS[n] = cons(n*, PREDECESSORS[n])
      ;Return updated block
      Block(n(blk), ins*, next*)

   ;Propagate liveness
   clear(IN-PORTS, nblocks(), List())
   clear(OUT-PORTS, nblocks(), List())
   val in-dists = BlockArray<Int>(IN-DISTS-CACHE, INT-MAX)
   val out-dists = BlockArray<Int>(OUT-DISTS-CACHE, INT-MAX)
   val in-dirty = Vector<Int>(IN-DIRTY-CACHE)
   val out-dirty = Vector<Int>(OUT-DIRTY-CACHE)

   ;For each variable
   for v in 0 to nvars() do :
      if not empty?(var-uses[v]) :
         ;Mark all usages of the variable
         for entry in var-uses[v] do :
            val [b, d] = [key(entry), value(entry)]
            mark-live-in(block-defs, in-dists, out-dists, in-dirty, out-dirty, b, v, d)
         ;Record all live in ports
         for b in in-dirty do :
            IN-PORTS[b] = cons(Port(v, false, Any(), false, in-dists[b]), IN-PORTS[b])
            in-dists[b] = INT-MAX
         clear(in-dirty)
         ;Record all live out ports
         for b in out-dirty do :
            OUT-PORTS[b] = cons(Port(v, false, Any(), false, out-dists[b]), OUT-PORTS[b])
            out-dists[b] = INT-MAX
         clear(out-dirty)

lostanza defn mark-live-out (defs:ref<BitArray>, in-dists:ref<Array<Int>>, out-dists:ref<Array<Int>>,
                             in-dirty:ref<Vector<Int>>, out-dirty:ref<Vector<Int>>,
                             b:ref<Int>, v:ref<Int>, d:ref<Int>) -> ref<False> :
   val old-value = get(out-dists, b).value
   if d.value < old-value :
      if old-value == INT-MAX.value :
         add(out-dirty, b)
      set(out-dists, b, d)

      val idx = b.value * nvars().value + v.value
      if get(defs, new Int{idx}) == false :
         val d* = new Int{d.value + length(ins(get(BLOCKS, b))).value}
         mark-live-in(defs, in-dists, out-dists, in-dirty, out-dirty, b, v, d*)
   return false

lostanza defn mark-live-in (defs:ref<BitArray>, in-dists:ref<Array<Int>>, out-dists:ref<Array<Int>>,
                            in-dirty:ref<Vector<Int>>, out-dirty:ref<Vector<Int>>,
                            b:ref<Int>, v:ref<Int>, d:ref<Int>) -> ref<False> :
   val old-value = get(in-dists, b).value
   if d.value < old-value :
      if old-value == INT-MAX.value :
         add(in-dirty, b)
      set(in-dists, b, d)
      labels :
         begin :
            goto loop(get(PREDECESSORS, b))
         loop (preds:ref<List<Int>>) :
            if empty?(preds) == false :
               mark-live-out(defs, in-dists, out-dists, in-dirty, out-dirty, head(preds), v, d)
               goto loop(tail(preds))
   return false

defn print-indexed-prog () :
   println("VARS = %_" % [VAR-TYPES])
   for b in 0 to nblocks() do :
      println("Block %_" % [b])
      println("Predecessors: %_" % [PREDECESSORS[b]])
      println("Ins: %_" % [IN-PORTS[b]])
      println(BLOCKS[b])
      println("Outs: %_" % [OUT-PORTS[b]])
      println("")

;============================================================
;=================== Annotations ============================
;============================================================

val INS-BUFFER-CACHE = Cache<Vector<Ins>>()
val USAGES-CACHE = Cache<Array<False|Int>>()
val REQUIRES-SAVE-CACHE = Cache<BitArray>()
val PREFERS-LOAD-CACHE = Cache<Array<True|False|Any>>()
val LIVE-DIRTY-CACHE = Cache<Vector<Int>>()

;TODO: Follow block chain backwards for earlier saves.
defn add-annotations (bi:Int) :
   ;Retrieve block
   val blk = BLOCKS[bi]

   ;Clear instruction buffer
   val ins-list = Vector<Ins>(INS-BUFFER-CACHE)
   defn emit (e:Ins) : add(ins-list, e)

   ;Live variable management
   val usages = VarArray<False|Int>(USAGES-CACHE, false)
   val live-dirty = Vector<Int>(LIVE-DIRTY-CACHE)

   defn live? (n:Int) :
      usages[n] is Int

   defn mark-live (n:Int, i:Int) :
      add(live-dirty, n) when not live?(n)
      usages[n] = i

   defn mark-dead (n:Int) :
      usages[n] = false

   defn do-live (f: Int -> ?) :
      for x in live-dirty remove-when :
         if live?(x) : (f(x), false)
         else : true

   ;Note usages of output ports
   val num-ins = length(ins(blk))
   for p in OUT-PORTS[bi] do :
      mark-live(n(p), dist(p) + num-ins)

   ;Sweep through instructions backwards
   val prefers-load = VarArray<True|False|Any>(PREFERS-LOAD-CACHE, Any())
   val requires-save = VarBitArray(REQUIRES-SAVE-CACHE, false)
   for (e in in-reverse(ins(blk)), i in (num-ins - 1) through 0 by -1) do :
      defn touched (x:Var) :
         ;Unload live variables that do not need loading
         if live?(n(x)) and prefers-load[n(x)] is False :
            emit(Unload(x))
         ;Note usages for defined nad used variables
         val d = usages[n(x)]
         if d is Int :
            emit(NextUsed(n(x), d as Int))

      defn defined (x:Var) :
         ;Save defined variables that need saving
         if requires-save[n(x)] :
            emit(Save(x))
         ;Otherwise kill variables that are never used
         else if not live?(n(x)) :
            emit(Kill(n(x)))

         ;Variable is no longer live
         mark-dead(n(x))
         requires-save[n(x)] = false
         prefers-load[n(x)] = false

      defn emitted (e:Ins) :
         ;Compute killed
         var killed = List()
         for x in e do-used :
            if usages[n(x)] is False :
               killed = cons(n(x), killed)
         emit(update-killed(e, killed))

         ;Cross Call Boundary
         if e is Call :
            do-live $ fn (x) :
               requires-save[x] = true
               prefers-load[x] = false

      defn used (x:Var) :
         mark-live(n(x), i)
         prefers-load[n(x)] = true

      reverse-sweep(e, touched, defined, emitted, used)

   ;Update block instructions
   clear(ins(blk))
   add-all(ins(blk), in-reverse(ins-list))

   ;Update block input ports
   IN-PORTS[bi] = for x in IN-PORTS[bi] map :
      val sv-x = requires-save[n(x)]
      val ld-x = prefers-load[n(x)]
      Port(n(x), sv-x, ld-x, false, dist(x))

defn add-annotations () :
   do(add-annotations, 0 to nblocks())

;============================================================
;================== Class Allocation ========================
;============================================================

val LOADED-CACHE = Cache<BitArray>()
val SAVED-CACHE = Cache<BitArray>()
val DIRTY-LOADED-CACHE = Cache<Vector<Int>>()
val DELAY-INS-CACHE = Cache<Vector<Ins>>()

defn allocate-classes (bi:Int, backend:Backend) :
   ;Retrieve block
   val blk = BLOCKS[bi]

   ;Track number of registers used
   var num-free-reg = num-regs(backend)
   var num-free-freg = num-fregs(backend)
   defn inc-reg (n:Int) :
      match(VAR-TYPES[n]) :
         (t:IntegerType) : num-free-reg = num-free-reg + 1
         (t:RealType) : num-free-freg = num-free-freg + 1
   defn dec-reg (n:Int) :
      match(VAR-TYPES[n]) :
         (t:IntegerType) : num-free-reg = num-free-reg - 1
         (t:RealType) : num-free-freg = num-free-freg - 1

   ;Track loads
   val loaded = VarBitArray(LOADED-CACHE, false)
   val dirty-loaded = Vector<Int>(DIRTY-LOADED-CACHE)
   defn mark-loaded (n:Int) -> True|False :
      if not loaded[n] :
         add(dirty-loaded, n)
         loaded[n] = true
         dec-reg(n)
         true
   defn mark-unloaded (n:Int) -> True|False :
      if loaded[n] :
         loaded[n] = false
         inc-reg(n)
         true
   defn do-loaded (f: Int -> ?) :
      for x in dirty-loaded remove-when :
         if loaded[x] : (f(x), false)
         else : true
   defn mark-all-unloaded () :
      do-loaded(mark-unloaded)

   ;Track Saved
   val saved = VarBitArray(SAVED-CACHE, false)

   ;Track Pending Usages
   val usages = VarArray<Int|False>(USAGES-CACHE, false)

   ;Actions by Variables
   defn define (x:Var) :
      val n = n(x)
      mark-loaded(n)
      saved[n] = false
   defn save (x:Int, buffer:Vector<Ins>) :
      if not saved[x] :
         add(buffer, Save(Var(x)))
      saved[x] = true
   defn load (x:Int, buffer:Vector<Ins>) :
      if mark-loaded(x) :
         add(buffer, Load(Var(x)))
   defn unload (x:Int, buffer:Vector<Ins>) :
      if mark-unloaded(x) :
         add(buffer, Unload(Var(x)))

   ;Spill
   defn next-spill-reg (type?: Type -> True|False) :
      var reg = false
      var dist = 0
      do-loaded $ fn (x) :
         if type?(VAR-TYPES[x]) :
            val dist* = usages[x] as Int
            if dist* > dist :
               reg = x
               dist = dist*
      reg as Int
   defn spill-reg (buffer:Vector<Ins>) :
      val reg = next-spill-reg({_ is IntegerType})
      save(reg, buffer)
      unload(reg, buffer)
   defn spill-freg (buffer:Vector<Ins>) :
      val reg = next-spill-reg({_ is RealType})
      save(reg, buffer)
      unload(reg, buffer)
   defn reserve-reg (n:Int, buffer:Vector<Ins>) :
      match(VAR-TYPES[n]) :
         (t:IntegerType) : spill-reg(buffer) when num-free-reg < 1
         (t:RealType) : spill-freg(buffer) when num-free-freg < 1
   defn spill-overcommitted (buffer:Vector<Ins>) :
      while num-free-reg < 0 : spill-reg(buffer)
      while num-free-freg < 0 : spill-freg(buffer)

   ;Fill a Port with save/load information
   defn fill (p:Port) :
      Port(n(p), saved[n(p)], loaded[n(p)], reg(p), dist(p))

   ;Fill entry ports
   for p in IN-PORTS[bi] do :
      val n = n(p)
      mark-loaded(n) when loaded?(p) is True|Any
      saved[n] = saved?(p)
      usages[n] = dist(p)
   spill-overcommitted(Vector<Ins>(DELAY-INS-CACHE))
   IN-PORTS[bi] = map(fill, IN-PORTS[bi])

   ;Sweep through instructions
   val ins-list = Vector<Ins>(INS-BUFFER-CACHE)
   for e in ins(blk) do :
      match(e) :
         (e:NextUsed) :
            usages[n(e)] = pos(e)
         (e:Unload) :
            unload(n(x(e)), ins-list)
         (e:Save) :
            save(n(x(e)), ins-list)
         (e:Kill) :
            mark-unloaded(n(e))
            add(ins-list,e)
         (e) :
            val delay-ins = Vector<Ins>(DELAY-INS-CACHE)
            ;Load arguments
            for x in e do-used :
               reserve-reg(n(x), ins-list)
               load(n(x), delay-ins)
            ;Emit instruction
            add(delay-ins, e)
            ;Unload registers
            if e is Call : mark-all-unloaded()
            else : do(mark-unloaded, killed(e))
            ;Define new variables
            for x in e do-defined :
               reserve-reg(n(x), ins-list)
               define(x)
            ;Add delayed instructions to buffer
            add-all(ins-list, delay-ins)

   ;Update instructions in block
   clear(ins(blk))
   add-all(ins(blk), ins-list)

   ;Update output ports
   OUT-PORTS[bi] = map(fill, OUT-PORTS[bi])

defn allocate-classes (backend:Backend) :
   do(allocate-classes{_, backend}, 0 to nblocks())

;============================================================
;=============== Register Assignment ========================
;============================================================

;             Free Register
;             =============

defstruct FreeReg <: Loc :
   prefer: List<Int>

defn FreeReg () : FreeReg(List())

defn PrefReg (xs:List<Imm>) :
   val regs = for x in xs seq? :
      match(x) :
         (x:Var) :
            match(reg(x)) :
               (l:Reg|FReg) : One(n(l))
               (l) : None()
         (x) : None()
   FreeReg(to-list(regs))

defn PrefReg (x:Imm) :
   match(x) :
      (x:Var) :
         match(reg(x)) :
            (r:Reg|FReg) : FreeReg(List(n(r)))
            (r) : FreeReg()
      (x) : FreeReg()

defmethod print (o:OutputStream, f:FreeReg) :
   print(o, "FreeReg(%,)" % [prefer(f)])

;              Algorithm
;              =========

val VAR-LOC-CACHE = Cache<Array<False|Reg|FReg>>()
val REG-SLOTS-CACHE = Cache<Array<False|Int>>()
val FREG-SLOTS-CACHE = Cache<Array<False|Int>>()
val PORT-TABLE-CACHE = Cache<Array<Port>>()

defn register-assignment (bi:Int, backend:Backend) :
   ;Retrieve block
   val blk = BLOCKS[bi]

   ;Emit to instruction buffer
   val ins-list = Vector<Ins>(INS-BUFFER-CACHE)
   defn emit (e:Ins) :
      add(ins-list, e)

   ;Register management
   val var-locs = VarArray<False|Reg|FReg>(VAR-LOC-CACHE, false)
   val reg-slots = Array<False|Int>(REG-SLOTS-CACHE, num-regs(backend), false)
   val freg-slots = Array<False|Int>(FREG-SLOTS-CACHE, num-fregs(backend), false)

   ;Fill an immediate or port with
   defn fill (x:Port) :
      val reg = var-locs[n(x)]
      val sv = saved?(x)
      val ld = reg is Reg|FReg
      Port(n(x), sv, ld, reg, dist(x))
   defn fill<?T> (x:?T&Imm) -> T :
      {_ as T&Imm} $ match(x) :
         (x:Var) : Var(n(x), var-locs[n(x)])
         (x) : x

   ;Free a register
   defn free (x:Int) :
      match(var-locs[x]) :
         (reg:Reg) :
            reg-slots[n(reg)] = false
            var-locs[x] = false
         (reg:FReg) :
            freg-slots[n(reg)] = false
            var-locs[x] = false
         (reg) : false

   ;Free all registers
   defn free-all () :
      defn free-regs (regs:Array<Int|False>, nregs:Int) :
         for i in 0 to nregs do :
            match(regs[i]) :
               (x:Int) :
                  regs[i] = false
                  var-locs[x] = false
               (x:False) : false
      free-regs(reg-slots, num-regs(backend))
      free-regs(freg-slots, num-fregs(backend))

   ;Find the next free register
   ;TODO: Use a free list
   defn free-reg (pref:List<Int>) :
      val reg = for i in pref first :
         One(Reg(i)) when reg-slots[i] is False else None()
      if empty?(reg) : Reg(index-of!(reg-slots, false))
      else : value!(reg)
   defn free-freg (pref:List<Int>) :
      val reg = for i in pref first :
         One(FReg(i)) when freg-slots[i] is False else None()
      if empty?(reg) : FReg(index-of!(freg-slots, false))
      else : value!(reg)

   ;Assign a location
   defn assign (x:Int, r:Loc) :
      match(r) :
         (r:FreeReg) :
            val reg = match(VAR-TYPES[x]) :
               (t:IntegerType) : free-reg(prefer(r))
               (t:RealType) : free-freg(prefer(r))
            assign(x, reg)
         (r:Reg) :
            var-locs[x] = r
            reg-slots[n(r)] = x
         (r:FReg) :
            var-locs[x] = r
            freg-slots[n(r)] = x

   ;Convenience assigners
   defn assign (x:Var|Port, l:Loc) :
      assign(n(x), l)
   defn assign (xs:List<Var|Port>, l:Loc) :
      do(assign{_, l}, xs)

   ;Assign several locations
   defn assign (xs:List<Var|Port>, ls:List<Loc>) :
      ;First assign stacks and regs
      for (x in xs, l in ls) do :
         assign(n(x), l) when l is-not FreeReg
      ;Next assign free registers
      for (x in xs, l in ls) do :
         assign(n(x), l) when l is FreeReg

   ;Helper: Move whatever was in src to dst. If dst is occupied then
   ;move it somewhere safe.
   defn swap-reg (src:Int, dst:Int) :
      val x = reg-slots[src] as Int
      match(reg-slots[dst]) :
         (y:Int) :
            match(index-of(reg-slots, false)) :
               (s:Int) :
                  emit(Set(Var(y, Reg(s)), Var(y, Reg(dst))))
                  emit(Set(Var(x, Reg(dst)), Var(x, Reg(src))))
                  free(x)
                  free(y)
                  assign(x, Reg(dst))
                  assign(y, Reg(s))
               (s:False) :
                  emit(Xchg(Var(x, Reg(src)), Var(y, Reg(dst)), false))
                  free(x)
                  free(y)
                  assign(x, Reg(dst))
                  assign(y, Reg(src))
         (y:False) :
            emit(Set(Var(x, Reg(dst)), Var(x, Reg(src))))
            free(x)
            assign(x, Reg(dst))

   ;Ensure registers regs will be free after ks are released
   defn ensure-free-regs (regs:List<Int>, ks:List<Int>) :
      ;Will be free after release
      defn free? (r:Int) :
         (reg-slots[r] is False) or
         contains?(ks, reg-slots[r])
      ;Safe position to swap with
      defn swap? (r:Int) :
         free?(r) and not contains?(regs, r)
      val swaps = filter(swap?, 0 to length(reg-slots))
      ;Swap out registers to ensure free
      for r in regs do :
         swap-reg(r, next(swaps)) when not free?(r)

   ;Ensure that the value x is in register r
   defn ensure-reg (x:Int, r:Int) :
      val src = n(var-locs[x] as Reg)
      swap-reg(src, r) when src != r

   ;Assign input ports
   val in-ports = IN-PORTS[bi]
   if not empty?(in-ports) :
      ;Retrieve output ports of predecessor block
      val pred = find!({_ < bi}, PREDECESSORS[bi])
      val port-table = Array<Port>(PORT-TABLE-CACHE, nvars())
      for p in OUT-PORTS[pred] do : port-table[n(p)] = p
      ;Calculate port locations
      val port-assigns = to-list $ for p in in-ports seq? :
         match(loaded?(p), reg(port-table[n(p)])) :
            (l1:True, r:Reg|FReg) : One(p => r)
            (l1:True, r:False) : One(p => FreeReg())
            (l1:False, r) : None()
      ;Assign ports
      assign(map(key, port-assigns), map(value, port-assigns))
      IN-PORTS[bi] = map(fill, in-ports)

   ;Sweep through instructions and assign locations
   for e in ins(blk) do :
      match(e) :
         (e:Set) :
            val y* = fill(y(e))
            do(free, killed(e))
            assign(x(e), PrefReg(y*))
            emit(Set(fill(x(e)), y*))
         (e:Op) :
            defn xs-prefers-arg () :
               val ys* = map(fill,ys(e))
               do(free, killed(e))
               assign(xs(e), PrefReg(ys*))
               emit(Op(op(e), map(fill,xs(e)), ys*))
            defn xs-prefers-arg0 () :
               val ys* = map(fill,ys(e))
               do(free, killed(e))
               assign(xs(e), PrefReg(head(ys*)))
               emit(Op(op(e), map(fill,xs(e)), ys*))
            defn xs-prefers-none () :
               val ys* = map(fill,ys(e))
               do(free, killed(e))
               assign(xs(e), FreeReg())
               emit(Op(op(e), map(fill,xs(e)), ys*))
            defn xs-requires-r0-r3 () :
               ensure-free-regs(List(0,3), killed(e))
               val ys* = map(fill,ys(e))
               do(free, killed(e))
               assign(xs(e), List(Reg(0), Reg(3)))
               emit(Op(op(e), map(fill,xs(e)), ys*))
            defn z-in-r2 () :
               match(ys(e)[1]) :
                  (z:Var) : ensure-reg(n(z), 2)
                  (z) : false
               xs-prefers-arg0()
            match(op(e)) :
               (opc:SubOp|DivOp) : xs-prefers-arg0()
               (opc:LoadOp|AddrOp|AddOp|MulOp|AndOp|OrOp|XorOp|
                    NotOp|NegOp|ConvOp|InterpretOp) :
                  xs-prefers-arg()
               (opc:ShlOp|ShrOp|AshrOp) : z-in-r2()
               (opc:DivModOp) : xs-requires-r0-r3()
               (opc:StoreOp|SwitchStackOp|SaveCContextOp) : xs-prefers-none()
               (opc:TgtOp&Comparison) : xs-prefers-none()
               (opc:NoOp) : false
         (e:Branch) :
            emit(Branch(op(e), map(fill, xs(e))))
            do(free, killed(e))
         (e:Return) :
            emit(Return(map(fill,xs(e)), ctxt(e)))
            do(free, killed(e))
         (e:Args) :
            do(free, killed(e))
            assign(xs(e), FreeReg())
            emit(Args(map(fill,xs(e)), ctxt(e)))
         (e:Call) :
            val f* = fill(f(e))
            val ys* = map(fill,ys(e))
            free-all()
            assign(xs(e), FreeReg())
            emit(Call(map(fill,xs(e)), f*, ys*, type(e)))
         (e:Save) :
            emit(Save(fill(x(e))))
         (e:Load) :
            assign(x(e), FreeReg())
            emit(Load(fill(x(e))))
         (e:Kill) :
            free(n(e))
         (e:Unload) :
            free(n(x(e)))
         (e) :
            fatal("%_ not supported." % [e])

   ;Update block instructions
   clear(ins(blk))
   add-all(ins(blk), ins-list)

   ;Fill output ports
   OUT-PORTS[bi] = map(fill, OUT-PORTS[bi])

defn register-assignment (backend:Backend) :
   do(register-assignment{_, backend}, 0 to nblocks())

;============================================================
;=========== Register Assignment Verification ===============
;============================================================

defn verify-register-assignment (bi:Int, backend:Backend) :
   ;Retrieve block
   val blk = BLOCKS[bi]

   ;Clear state
   val reg-slots = Array<False|Int>(REG-SLOTS-CACHE, num-regs(backend), false)
   val freg-slots = Array<False|Int>(FREG-SLOTS-CACHE, num-fregs(backend), false)
   val saved = VarBitArray(SAVED-CACHE, false)

   ;Helper: Setting and Retrieving register contents
   defn get-reg (r:Reg|FReg) :
      match(r) :
         (r:Reg) : reg-slots[n(r)]
         (r:FReg) : freg-slots[n(r)]

   defn set-reg (r:Reg|FReg, v:Int|False) :
      match(r) :
         (r:Reg) : reg-slots[n(r)] = v
         (r:FReg) : freg-slots[n(r)] = v

   ;State updaters
   defn define (x:Port) :
      match(saved?(x), loaded?(x), reg(x)) :
         (sv:True, ld:True, r:FReg|Reg) :
            set-reg(r, n(x))
            saved[n(x)] = true
         (sv:False, ld:True, r:FReg|Reg) :
            set-reg(r, n(x))
            saved[n(x)] = false
         (sv:True, ld:False, r:False) :
            saved[n(x)] = true
         (sv, ld, r) :
            fatal("Unreachable combination: (%_, %_, %_)" % [sv, ld, r])

   defn define (x:Var) :
      set-reg(reg!(x), n(x))
      saved[n(x)] = false

   defn mov (x:Var, y:Imm) :
      set-reg(reg!(x), n(x))
      match(y) :
         (y:Var) :
            ;Needed to verify swap operations
            if n(x) != n(y) :
               saved[n(x)] = false
         (y) : saved[n(x)] = false


   defn load (x:Var) :
      set-reg(reg!(x), n(x))

   defn save (x:Var) :
      saved[n(x)] = true

   defn clear-registers () :
      for i in 0 to num-regs(backend) do :
         reg-slots[i] = false
      for i in 0 to num-fregs(backend) do :
         freg-slots[i] = false

   defn xchg (x:Var, y:Var) :
      match(reg(x), reg(y)) :
         (lx:Reg, ly:Reg) : false
         (lx:FReg, ly:FReg) : false
      val lx = reg!(x)
      val ly = reg!(y)
      val vx = get-reg(lx)
      val vy = get-reg(ly)
      set-reg(lx, vy)
      set-reg(ly, vx)

   ;Checkers
   defn reg! (x:Var) :
      match(reg(x)) :
         (l:FReg|Reg) : l
         (l) : fatal("Block %_: Variable %_ is not in a register." % [n(blk), x])

   defn saved! (x:Int) :
      if saved[x] is-not True :
         fatal("Block %_: %~ has not been saved." % [n(blk), x])
   defn saved! (x:Var) : saved!(n(x))

   defn not-saved! (x:Int) :
      if saved[x] is-not False :
         fatal("Block %_: %~ should not be saved." % [n(blk), x])

   defn holds! (r:FReg|Reg, x:Int) :
      val y = get-reg(r)
      if y != x :
         fatal("Block %_: Register %_ should hold %_ but holds %_." % [n(blk), r, x, y])

   defn check! (p:Port) :
      match(saved?(p), loaded?(p), reg(p)) :
         (sv:True, ld:True, r:FReg|Reg) :
            holds!(r, n(p))
            saved!(n(p))
         (sv:False, ld:True, r:FReg|Reg) :
            holds!(r, n(p))
            not-saved!(n(p))
         (sv:True, ld:False, r:False) :
            saved!(n(p))

   defn check! (x:Imm) :
      match(x) :
         (x:Var) :
            match(reg(x)) :
               (r:FReg|Reg) : holds!(r, n(x))
               (r:False) : saved!(n(x))
         (x) : false

   ;     Layer 2
   ;     -------
   ;Input ports
   do(define, IN-PORTS[bi])

   ;Check each instruction
   for e in ins(blk) do :
      match(e) :
         (e:Set) :
            check!(y(e))
            mov(x(e), y(e))
         (e:Xchg) :
            check!(x(e))
            check!(y(e))
            xchg(x(e), y(e))
         (e:Op) :
            do(check!, ys(e))
            do(define, xs(e))
         (e:Branch) :
            do(check!, xs(e))
         (e:Return) :
            do(check!, xs(e))
         (e:Save) :
            check!(x(e))
            save(x(e))
         (e:Load) :
            saved!(x(e))
            load(x(e))
         (e:Args) :
            do(define, xs(e))
         (e:Call) :
            check!(f(e))
            do(check!, ys(e))
            clear-registers()
            do(define, xs(e))

   ;Output ports
   do(check!, OUT-PORTS[bi])

defn verify-register-assignment (backend:Backend) :
   do(verify-register-assignment{_, backend}, 0 to nblocks())

;============================================================
;============== Stack Interval Calculation ==================
;============================================================

;                 Interval Structure
;                 ==================
deftype Interval
defstruct StartInterval <: Interval :
   n: Int
defstruct EndInterval <: Interval :
   n: Int

defmethod print (o:OutputStream, i:Interval) :
   print{o, _} $ match(i) :
      (i:StartInterval) : "Start(%_)" % [n(i)]
      (i:EndInterval) : "End(%_)" % [n(i)]

;                     Algorithm
;                     =========

val VAR-START-CACHE = Cache<Array<Int>>()
val VAR-END-CACHE = Cache<Array<Int>>()
val IN-PORT-POS-CACHE = Cache<Array<Int>>()
val OUT-PORT-POS-CACHE = Cache<Array<Int>>()
val INTERVALS-CACHE = Cache<Array<List<Interval>>>()

defn stack-intervals () :
   ;Compute port positions
   val in-port-pos = Array<Int>(IN-PORT-POS-CACHE, nblocks())
   val out-port-pos = Array<Int>(OUT-PORT-POS-CACHE, nblocks())
   var pos = 0
   for b in 0 to nblocks() do :
      in-port-pos[b] = pos
      pos = pos + length(ins(BLOCKS[b]))
      out-port-pos[b] = pos

   ;For each block
   val pos-counter = to-seq(0 to false)
   val var-start = VarArray<Int>(VAR-START-CACHE, INT-MAX)
   val var-end = VarArray<Int>(VAR-END-CACHE, INT-MIN)
   for bi in 0 to nblocks() do :
      ;Retrieve block
      val blk = BLOCKS[bi]

      ;Note usages
      defn note-usage (x:Int, i:Int) :
         var-start[x] = min(i,var-start[x])
         var-end[x] = max(i,var-end[x])

      defn note-in-port-usage (x:Int) :
         note-usage(x, in-port-pos[bi])
         for pred in PREDECESSORS[bi] do :
            note-usage(x, out-port-pos[pred])

      defn note-out-port-usage (x:Int) :
         note-usage(x, out-port-pos[bi])
         for succ in next(blk) do :
            note-usage(x, in-port-pos[succ])

      ;Note input port usages
      ;TODO: Saved is never Any so just get rid of that.
      for p in IN-PORTS[bi] do :
         note-in-port-usage(n(p)) when saved?(p)
      ;Note instruction usages
      for e in ins(blk) do :
         val pos = next(pos-counter)
         match(e) :
            (e:Save) : note-usage(n(x(e)), pos)
            (e:Load) : note-usage(n(x(e)), pos)
            (e) : false
      ;Note output port usages
      for p in OUT-PORTS[bi] do :
         note-out-port-usage(n(p)) when saved?(p)

   ;Order intervals by position
   val num-pos = next(pos-counter) + 1
   val intervals = Array<List<Interval>>(INTERVALS-CACHE, num-pos, List())
   defn add-interval (p:Int, int:Interval) :
      intervals[p] = cons(int, intervals[p])

   ;Put intervals in order of position
   defn stack-allocated? (v:Int) :
      var-start[v] <= var-end[v]
   for v in 0 to nvars() do :
      add-interval(var-end[v], EndInterval(v)) when stack-allocated?(v)
   for v in 0 to nvars() do :
      add-interval(var-start[v], StartInterval(v)) when stack-allocated?(v)

   ;Return intervals
   intervals

;============================================================
;==================== Stack Map =============================
;============================================================

;                Stack Map Structure
;                ===================

deftype StackMap
defmulti ref-offsets (s:StackMap) -> Seq<Int>
defmulti mask (s:StackMap) -> [Int, List<Long>]
defmulti offset (s:StackMap, x:Int) -> Int
defmulti type (s:StackMap, n:Int) -> Type
defmulti location (s:StackMap, n:Int) -> Int
defmulti num-locations (s:StackMap) -> Int
defmulti size (s:StackMap) -> Int

;                   Algorithm
;                   =========

val OCCUPIED-LOCS-CACHE = Cache<Vector<True|False>>()
val LOC-TYPES-CACHE = Cache<Vector<Type>>()
val VAR-STACK-LOCS-CACHE = Cache<Array<Int>>()
val ITEM-BUFFER-CACHE = Cache<Vector<Item>>()
val LOC-OFFSETS-CACHE = Cache<Array<Int>>()

defn calculate-stack-map () :
   ;Get next free location
   ;(occupied-locs[i] = true) => location i is occupied
   ;(loc-types[i] = t) => type of location i is t
   val occupied-locs = Vector<True|False>(OCCUPIED-LOCS-CACHE)
   val loc-types = Vector<Type>(LOC-TYPES-CACHE)
   defn next-free-loc (t:Type) :
      val t* = IntegerType(t)
      val n = length(occupied-locs)
      val i = for i in 0 to n find :
         (not occupied-locs[i]) and
         loc-types[i] == t*
      match(i) :
         (i:Int) : i
         (i:False) :
            add(occupied-locs, false)
            add(loc-types, t*)
            n

   ;Assign stack locations to variables
   ;(var-locs[x] = i) => variable x is at location i
   val var-locs = Array<Int>(VAR-STACK-LOCS-CACHE, nvars())
   for ints in stack-intervals() do :
      for int in ints do :
         match(int) :
            (int:StartInterval) :
               val loc = next-free-loc(VAR-TYPES[n(int)])
               var-locs[n(int)] = loc
               occupied-locs[loc] = true
            (int:EndInterval) :
               val loc = var-locs[n(int)]
               occupied-locs[loc] = false

   ;Order and Pad stack locations
   val [items, aln] = let :
      val buffer = Vector<Item>(ITEM-BUFFER-CACHE)
      for (t in loc-types, i in 0 to false) do :
         add(buffer, Item(size(t), i))
      qsort!(alignment, buffer)
      pad(buffer, 8)

   ;Compute location offsets
   ;(loc-offsets[i] = o) => offset of location i is o
   val loc-offsets = Array<Int>(LOC-OFFSETS-CACHE, length(loc-types))
   var stack-size = 16 ;[Return, StackMap]
   for it in items do :
      match(it) :
         (it:Item) :
            val i = data(it) as Int
            loc-offsets[i] = stack-size
            stack-size = stack-size + alignment(it)
         (it:Padding) :
            stack-size = stack-size + size(it)
   if stack-size % 8 != 0 :
      fatal("Stack has not been padded to multiple of 8.")

   ;Return table
   new StackMap :
      defmethod ref-offsets (this) :
         for item in items seq? :
            if item is Item :
               val loc = data(item as Item) as Int
               if loc-types[loc] is RefType : One(loc-offsets[loc])
               else : None()
            else : None()
      defmethod mask (this) :
         val stack-types = to-list $ for item in items seq :
            match(item) :
               (item:Item) : loc-types[data(item) as Int]
               (item:Padding) : IntegerType(size(item))
         val refs = ref-mask(stack-types)
         val bits = to-bitmask(refs)
         val n = length(refs)
         [n, bits]
      defmethod location (this, n:Int) :
         var-locs[n]
      defmethod num-locations (this) :
         length(loc-types)
      defmethod type (this, n:Int) :
         loc-types[location(this, n)]
      defmethod offset (this, x:Int) :
         loc-offsets[location(this, x)]
      defmethod size (this) :
         stack-size

;============================================================
;================= Enforce Clearing =========================
;============================================================

val LOC-LIVE-CACHE = Cache<BitArray>()

;TODO: This algorithm is too eager about clearing variables.
;Do not clear variables if the slot is going to be overwritten by another variable.
defn enforce-clears (bi:Int, smap:StackMap) :
   ;Retrieve block
   val blk = BLOCKS[bi]

   ;Live Stack Locations
   val loc-live = BitArray(LOC-LIVE-CACHE, num-locations(smap), false)
   defn mark-live (n:Int) : loc-live[location(smap, n)] = true
   defn mark-dead (n:Int) : loc-live[location(smap, n)] = false
   defn var-live? (x:Var) : loc-live[location(smap, n(x))]

   ;Utilities
   defn ref-var? (x:Var) : VAR-TYPES[n(x)] is RefType

   ;Initialize location liveness according to ports
   for port in OUT-PORTS[bi] do :
      mark-live(n(port)) when saved?(port)

   ;Sweep through instructions in reverse
   val ins-list = Vector<Ins>(INS-BUFFER-CACHE)
   for e in in-reverse(ins(blk)) do :
      if e is Load :
         val e = e as Load
         if ref-var?(x(e)) and not var-live?(x(e)) :
            add(ins-list, Clear(x(e)))
      add(ins-list, e)
      match(e) :
         (e:Load) : mark-live(n(x(e)))
         (e:Save) : mark-dead(n(x(e)))
         (e) : false

   ;Update block instructions
   clear(ins(blk))
   add-all(ins(blk), in-reverse(ins-list))

defn enforce-clears (smap:StackMap) :
   do(enforce-clears{_, smap}, 0 to nblocks())


;============================================================
;================= Block Collapsing =========================
;============================================================

val LOAD-INS-CACHE = Cache<Vector<Ins>>()
val SAVE-INS-CACHE = Cache<Vector<Ins>>()
val CLEAR-INS-CACHE = Cache<Vector<Ins>>()

defn collapse-blocks (smap:StackMap) :
   ;Manage instruction buffer
   val ins-list = Vector<Ins>(INS-BUFFER-CACHE)
   defn emit (e:Ins) : add(ins-list, e)
   defn emit-all (es:Seqable<Ins>) : add-all(ins-list, es)

   ;Parallel Port Glue Engine
   ;Perform xs = ys in parallel, with handling of loads, stores, and clears
   defn glue-ports (xs:List<Port>, ys:List<Port>) :
      ;Create instruction buffers
      val load-ins = Vector<Ins>(LOAD-INS-CACHE)
      val save-ins = Vector<Ins>(SAVE-INS-CACHE)
      val clear-ins = Vector<Ins>(CLEAR-INS-CACHE)
      var shuffle-xs = List()
      var shuffle-ys = List()
      var fshuffle-xs = List()
      var fshuffle-ys = List()

      ;Utilities
      defn ref-var? (n:Int) : VAR-TYPES[n] is RefType

      ;Populate port table
      val port-table = Array<Port>(PORT-TABLE-CACHE, nvars())
      for y in ys do :
         port-table[n(y)] = y

      ;Populate instruction buffers
      for x in xs do :
         val y = port-table[n(x)]
         val vx = Var(n(x), reg(x))
         val vy = Var(n(y), reg(y))
         ;1. Emit any saves or clears required
         match(saved?(x), saved?(y)) :
            (sx:True, sy:False) : add(save-ins, Save(vy))
            (sx:False, sy:True) : add(clear-ins, Clear(vx)) when ref-var?(n(x))
            (sx, sy) : false
         ;2. Emit any loads required
         match(loaded?(x), loaded?(y)) :
            (lx:True, ly:False) : add(load-ins, Load(vx))
            (lx, ly) : false
         ;3. Emit any shuffles required
         match(reg(x), reg(y)) :
            (lx:Reg, ly:Reg) :
               shuffle-xs = cons(n(lx), shuffle-xs)
               shuffle-ys = cons(n(ly), shuffle-ys)
            (lx:FReg, ly:FReg) :
               fshuffle-xs = cons(n(lx), fshuffle-xs)
               fshuffle-ys = cons(n(ly), fshuffle-ys)
            (lx, ly) : false

      ;Output buffers to main instruction buffer
      emit-all(save-ins)
      emit(ShuffleReg(shuffle-xs, shuffle-ys)) when not empty?(shuffle-xs)
      emit(ShuffleFReg(fshuffle-xs, fshuffle-ys)) when not empty?(fshuffle-xs)
      emit-all(load-ins)
      emit-all(clear-ins)

   ;Collapse all Blocks
   ;Retrieve a blocks label
   defn lbl (b:Int) : n(BLOCKS[b])
   for (blk in BLOCKS, bi in 0 to false) do :
      ;Determine whether block i is coming up next
      defn upcoming? (i:Int) : i == (bi + 1)
      ;Emit block label
      emit(Label(n(blk)))
      ;Emit entry glue logic
      if length(PREDECESSORS[bi]) == 1 :
         val pred = head(PREDECESSORS[bi])
         if length(next(BLOCKS[pred])) > 1 :
            glue-ports(IN-PORTS[bi], OUT-PORTS[pred])
      ;Emit instructions
      for e in ins(blk) do :
         match(e) :
            ;Branches need to be laid out
            (e:Branch) :
               val conseq = next(blk)[0]
               val alt = next(blk)[1]
               match(upcoming?(conseq), upcoming?(alt)) :
                  (fc:True, fa:False) :
                     emit(Break(lbl(alt), flip(op(e)), xs(e)))
                  (fc:False, fa:True) :
                     emit(Break(lbl(conseq), op(e), xs(e)))
                  (fc:False, fa:False) :
                     emit(Break(lbl(conseq), op(e), xs(e)))
                     emit(Goto(lbl(alt)))
            (e) : emit(e)
      ;Emit exit glue logic
      if length(next(blk)) == 1 :
         val n = head(next(blk))
         glue-ports(IN-PORTS[n], OUT-PORTS[bi])
         emit(Goto(lbl(n))) when not upcoming?(n)
   ;Return instruction buffer
   ins-list

;============================================================
;================= Shuffling Engine =========================
;============================================================

;            Shuffling Instructions
;            ======================

deftype ShuffleIns
defstruct ShfMove <: ShuffleIns : (dst:Int, src:Int)
defstruct ShfSave <: ShuffleIns : (n:Int)
defstruct ShfLoad <: ShuffleIns : (n:Int)

defmethod print (o:OutputStream, i:ShuffleIns) :
   print{o, _} $ match(i) :
      (i:ShfMove) : "%~ = %~" % [dst(i), src(i)]
      (i:ShfSave) : "save %~" % [n(i)]
      (i:ShfLoad) : "load %~" % [n(i)]

;                Algorithm
;                =========

val PREDS-CACHE = Cache<Array<False|Int>>()
val SATISFIED-CACHE = Cache<BitArray>()
val LOADS-CACHE = Cache<BitArray>()
val PENDING-CACHE = Cache<BitArray>()

defn shuffle (xs:List<Int>, ys:List<Int>, nreg:Int, f: ShuffleIns -> ?) :
   ;Create tables
   ;(preds[dst] = src) => contents of register src need to be moved into register dst
   ;(satisfied[r] = true) => register r holds what it should
   ;(loads[r] = true) => contents of register r need to be loaded from swap
   val preds = Array<False|Int>(PREDS-CACHE, nreg, false)
   val satisfied = BitArray(SATISFIED-CACHE, nreg, false)
   val loads = BitArray(LOADS-CACHE, nreg, false)

   ;Initialize Predecessors
   for (dst in xs, src in ys) do :
      if dst == src : satisfied[dst] = true
      else : preds[dst] = src

   ;Compute pending moves
   ;(pending[r] = true) => contents of register r still need to be moved
   defn pending () :
      val ret = BitArray(PENDING-CACHE, nreg, false)
      for i in 0 to nreg do :
         match(preds[i]) :
            (p:Int) : ret[p] = true
            (p:False) : false
      ret

   ;Find a simple destination.
   ;A register with a predecessor but no successor
   defn simple-dst (pending:BitArray) :
      for i in 0 to nreg find :
         preds[i] is-not False and
         (not pending[i])

   ;Find a remaining destination.
   defn remaining-dst () :
      for i in 0 to nreg find :
         preds[i] is-not False

   ;Find a swap register
   defn swap-reg (pending:BitArray) :
      for i in 0 to nreg find :
         (not pending[i]) and (not satisfied[i])

   ;Iterate until predecessors fulfilled.
   defn* loop () :
      ;Move src to dst and update pred table
      defn move (dst:Int, src:Int) :
         f(ShfMove(dst, src))
         for i in 0 to nreg do :
            if preds[i] == src :
               preds[i] = dst

      ;Save register and update pred table
      defn save (r:Int) :
         f(ShfSave(r))
         for i in 0 to nreg do :
            if preds[i] == r :
               preds[i] = false
               loads[i] = true

      ;Fills the appropriate value into register r (if there is one)
      defn* fill (r:Int) :
         match(preds[r]) :
            (p:Int) :
               move(r, p)
               preds[r] = false
               satisfied[r] = true
               fill(p)
            (p:False) :
               false

      val pending = pending()
      match(simple-dst(pending)) :
         (r:Int) : (fill(r), loop())
         (r:False) :
            match(remaining-dst(), swap-reg(pending)) :
               (r:Int, s:Int) : (move(s, r), loop())
               (r:Int, s:False) : (save(r), loop())
               (r, s) : false
   loop()

   ;Load saved registers
   for i in 0 to nreg do :
      f(ShfLoad(i)) when loads[i]

;============================================================
;================= Assemble =================================
;============================================================

;     Compilation
;     -----------
defn assemble (func-id:Int,
               backend:Backend,
               ins:Vector<Ins>,
               stackmap:StackMap,
               output:Vector<AsmIns>,
               infos:Vector<KeyValue<Int,FileInfo>>) -> False :

   ;     Utilities for Immediates
   ;     ------------------------
   defn imm-type? (i:Imm) :
      match(i) :
         (i:Var) :
            match(VAR-TYPES[n(i)]) :
               (t:RefType) : LongType()
               (t) : t
         (i:RegSP) : LongType()
         (i:ByteImm) : ByteType()
         (i:IntImm) : IntType()
         (i:LongImm) : LongType()
         (i:Mem) : LongType()
         (i:ExMem) : LongType()
         (i) : false

   defn imm-type (i:Imm) :
      match(imm-type?(i)) :
         (t:Type) : t
         (t:False) : fatal("%_ has no type." % [i])

   ;Retrieve location if there is one
   defn loc? (x:Imm) :
      match(x) :
         (x:Var) :
            match(reg(x)) :
               (r:Reg|FReg) : r
               (r:False) : x
         (x) : x

   defn loc! (x:Imm) :
      match(x) :
         (x:Var) : reg(x) as Reg|FReg
         (x:RegSP|Reg|FReg) : x
         (x) : fatal("%_ has no location." % [x])

   defn imm! (x:Imm) :
      match(x) :
         (x:Var) : reg(x) as Reg|FReg
         (x) : x

   ;     Output Instruction Buffer
   ;     -------------------------
   val #rsp = RegSP()
   val #r0 = Reg(0)
   val #r1 = Reg(1)
   val #r4 = Reg(4)
   val #r5 = Reg(5)
   val #r6 = Reg(6)
   val #r11 = Reg(11)
   val #r12 = Reg(12)
   val #r13 = Reg(13)
   val #r14 = Reg(14)

   defn emit (i:AsmIns) :
      add(output, i)

   defn #load-var (x:Loc, y:Var) :
      #load(imm-type(y), x, #rsp, offset(stackmap, n(y)))

   defn #store-var (x:Var, y:Imm) :
      #store(imm-type(x), #rsp, y, offset(stackmap, n(x)))

   defn #mov (t:Type, x:Imm, y:Imm) :
      match(loc?(x), loc?(y)) :
         ;Sets
         (x:RegSP|Reg|FReg, y:RegSP|Reg|FReg|Val) : emit(AsmSetIns(t, x, y))
         (x:RegSP|Reg|FReg, y:Var) : #load-var(x, y)
         (x:Var, y:RegSP|Reg|FReg|Val) : #store-var(x, y)
         (x, y) : fatal("Illegal mov: (%_) %_ = %_" % [t, x, y])
   defn #mov (x:Imm, y:Imm) :
      val t = match(imm-type?(x)) :
                 (t:Type) : t
                 (t:False) : imm-type(y)
      #mov(t, x, y)
   defn #movl (x:Imm, y:Imm) : #mov(LongType(), x, y)
   defn #movd (x:Imm, y:Imm) : #mov(DoubleType(), x, y)

   defn #binop (t:Type, x:Loc, op:TgtOp, y:Imm, z:Imm) :
      emit(AsmBinOp(t, loc!(x), op, imm!(y), imm!(z)))
   defn #add (t:Type, x:Loc, y:Imm, z:Imm) : #binop(t, x, AddOp(), y, z)
   defn #sub (t:Type, x:Loc, y:Imm, z:Imm) : #binop(t, x, SubOp(), y, z)
   defn #addl (x:Loc, y:Imm, z:Imm) : #binop(LongType(), x, AddOp(), y, z)
   defn #subl (x:Loc, y:Imm, z:Imm) : #binop(LongType(), x, SubOp(), y, z)

   defn #unaop (t:Type, x:Loc, op:TgtOp, y:Imm) :
      emit(AsmUnaOp(t, loc!(x), op, imm!(y)))

   defn #dualop (t:Type, x1:Loc, x2:Loc, op:TgtOp, y:Imm, z:Imm) :
      emit(AsmDualOp(t, loc!(x1), loc!(x2), op, imm!(y), imm!(z)))

   defn #load (t:Type, x:Loc, a:Imm, o:Int) :
      emit(AsmLoad(t, loc!(x), imm!(a), o))
   defn #loadl (x:Loc, a:Imm, o:Int) : #load(LongType(), x, a, o)
   defn #loadl (x:Loc, a:Imm) : #load(LongType(), x, a, 0)
   defn #loadd (x:Loc, a:Imm) : #load(DoubleType(), x, a, 0)

   defn #store (t:Type, a:Imm, v:Imm, o:Int) :
      emit(AsmStore(t, imm!(a), imm!(v), o))
   defn #storel (a:Imm, v:Imm, o:Int) : #store(LongType(), a, v, o)
   defn #storel (a:Imm, v:Imm) : #store(LongType(), a, v, 0)
   defn #stored (a:Imm, v:Imm) : #store(DoubleType(), a, v, 0)

   defn #conv (tx:Type, x:Loc, ty:Type, y:Imm) :
      emit(AsmConvertIns(tx, loc!(x), ty, imm!(y)))

   defn #interpret (tx:Type, x:Loc, ty:Type, y:Imm) :
      emit(AsmReinterpretIns(tx, loc!(x), ty, imm!(y)))

   defn #label (n:Int) :
      emit(AsmLabel(n))

   defn #goto (a:Imm) :
      emit(AsmGoto(imm!(a)))

   defn #break (t:Type, n:Int, op:TgtOp, x:Imm, y:Imm) :
      emit(AsmBranch(t, Mem(n), op, imm!(x), imm!(y)))
   defn #breakl (n:Int, op:TgtOp, x:Imm, y:Imm) : #break(LongType(), n, op, x, y)

   defn #ret () :
      emit(AsmReturn())

   defn #call (f:Imm) :
      emit(AsmCall(imm!(f)))

   defn #xchg (x:Imm, y:Imm) :
      emit(AsmXchgIns(loc!(x), loc!(y)))

   defn #data () : emit(AsmDefData())

   defn #text () : emit(AsmDefText())

   defn #deflong (v:Long) : emit(AsmDefLong(v))

   ;     Calling Convention
   ;     ------------------
   defn call-locations (xs:List<Imm>) :
      val regs = to-seq(call-regs(backend))
      val fregs = to-seq(call-fregs(backend))
      for x in xs map :
         match(imm-type(x)) :
            (t:IntegerType) : Reg(next(regs))
            (t:RealType) : FReg(next(fregs))
   defn call-locations (f:Imm, xs:List<Imm>) :
      cons(Reg(1), call-locations(xs))

   ;     Shuffle Engine
   ;     --------------
   defn shuffle-reg (xs:List<Int>, ys:List<Int>) :
      shuffle{xs, ys, num-regs(backend), _} $ fn (i) :
         match(i) :
            (i:ShfMove) : #movl(Reg(dst(i)), Reg(src(i)))
            (i:ShfSave) : #storel(Mem(SWAP-LBL), Reg(n(i)))
            (i:ShfLoad) : #loadl(Reg(n(i)), Mem(SWAP-LBL))

   defn shuffle-freg (xs:List<Int>, ys:List<Int>) :
      shuffle{xs, ys, num-fregs(backend), _} $ fn (i) :
         match(i) :
            (i:ShfMove) : #movd(FReg(dst(i)), FReg(src(i)))
            (i:ShfSave) : #stored(Mem(SWAP-LBL), FReg(n(i)))
            (i:ShfLoad) : #loadd(FReg(n(i)), Mem(SWAP-LBL))

   defn shuffle-vals (xs:List<Imm>, ys:List<Imm>) :
      var rxs:List<Int> = List()
      var rys:List<Int> = List()
      var fxs:List<Int> = List()
      var fys:List<Int> = List()
      var oxs:List<Imm> = List()
      var oys:List<Imm> = List()

      for (x in xs, y in ys) do :
         match(loc?(x), loc?(y)) :
            (x:Reg, y:Reg) :
               rxs = cons(n(x), rxs)
               rys = cons(n(y), rys)
            (x:FReg, y:FReg) :
               fxs = cons(n(x), fxs)
               fys = cons(n(y), fys)
            (x, y) :
               oxs = cons(x, oxs)
               oys = cons(y, oys)

      shuffle-reg(rxs, rys) when not empty?(rxs)
      shuffle-freg(fxs, fys) when not empty?(rys)
      do(#mov, oxs, oys)

   ;     Generate Header
   ;     ---------------
   val stack-map-id = fresh-id()
   let :
      val [n, bits] = mask(stackmap)
      #data()
      #label(stack-map-id)
      #deflong(to-long(n))
      do(#deflong, bits)
      #text()
      #label(func-id)

   ;     Convert Instructions
   ;     --------------------
   for e in ins do :
      match(e) :
         (e:Set) :
            #mov(x(e), y(e))
         (e:Return) :
            match(ctxt(e)) :
               (c:StanzaContext) :
                  shuffle-vals(call-locations(xs(e)), xs(e))
                  #ret()
               (c:CContext) :
                  ;First argument is the stack pointer
                  val [sp, rets] = [head(xs(e)), tail(xs(e))]
                  ;Restore c stack pointer
                  #mov(#rsp, sp)
                  ;Shuffle return arguments to correct location
                  shuffle-vals(xs(c), rets)
                  ;Restore C context
                  #loadl(#r1, #rsp, -8)
                  #loadl(#r6, #rsp, -16)
                  #loadl(#r11, #rsp, -24)
                  #loadl(#r12, #rsp, -32)
                  #loadl(#r13, #rsp, -40)
                  #loadl(#r14, #rsp, -48)
                  ;Return to C
                  #ret()
         (e:Op) :
            match(op(e)) :
               (op:LoadOp) :
                  val [x, y, o] = [xs(e)[0], ys(e)[0], offset(op)]
                  #load(imm-type(x), x, y, o)
               (op:StoreOp) :
                  val [x, y, o] = [ys(e)[0], ys(e)[1], offset(op)]
                  #store(imm-type(y), x, y, o)
               (op:AddrOp) :
                  val x = xs(e)[0]
                  #mov(x, Mem(n(op)))
               (op:DivModOp) :
                  val [x1, x2, y, z] = [xs(e)[0], xs(e)[1], ys(e)[0], ys(e)[1]]
                  #dualop(imm-type(x1), x1, x2, DivModOp(), y, z)
               (op:ConvOp) :
                  val [x, y] = [head(xs(e)), head(ys(e))]
                  #conv(imm-type(x), x, imm-type(y), y)
               (op:InterpretOp) :
                  val [x, y] = [head(xs(e)), head(ys(e))]
                  #interpret(imm-type(x), x, imm-type(y), y)
               (op:SwitchStackOp) :
                  ;1. Decrement number of free stacks
                  #loadl(#r0, Mem(NUM-FREE-STACKS-LBL))
                  #subl(#r0, #r0, IntImm(1))
                  #storel(Mem(NUM-FREE-STACKS-LBL), #r0)

                  ;2. Retrieve the next free stack
                  ;R0 = next free stack
                  ;temporary R1 = stack pool
                  #loadl(#r1, Mem(FREE-STACKS-LBL))
                  #loadl(#r0, #r1)
                  #addl(#r1, #r1, IntImm(8))
                  #storel(Mem(FREE-STACKS-LBL), #r1)

                  ;3. Cap the current stack. Set current stack as parent of new stack.
                  ;#r1 = current stack
                  ;preserve #r0 = free stack
                  #loadl(#r1, Mem(STACK-LBL))
                  #storel(#r1, #rsp, STACK-SP-OFFSET - REF-TAG-BITS)
                  #storel(#r0, #r1, STACK-PARENT-OFFSET - REF-TAG-BITS)

                  ;4. update the current stack and limits
                  ;preserve #r0 = free stack
                  ;temporary #r1 = stack limit
                  ;Update stack register
                  #addl(#rsp, #r0, IntImm(STACK-ITEMS-OFFSET - REF-TAG-BITS))
                  ;Update stack limit, and current stack
                  #addl(#r1, #r0, IntImm(STACK-SIZE - REF-TAG-BITS))
                  #storel(Mem(STACK-LIM-LBL), #r1)
                  #storel(Mem(STACK-LBL), #r0)
                  ;Intercept return code
                  #movl(#r1, Mem(RETRACT-STACK-LBL))
                  #storel(#rsp, #r1)
               (op:SaveCContextOp) :
                  match(backend) :
                     (backend:W64Backend) :
                        ;Store C preserved registers
                        #storel(#rsp, #r1, -8)
                        #storel(#rsp, #r4, -16)
                        #storel(#rsp, #r5, -24)
                        #storel(#rsp, #r6, -32)
                        #storel(#rsp, #r11, -40)
                        #storel(#rsp, #r12, -48)
                        #storel(#rsp, #r13, -56)
                        #storel(#rsp, #r14, -64)
                        ;Move #rsp to R6 for CArgs
                        #movl(#r6, #rsp)
                        ;Restore Stanza context
                        #loadl(#rsp, Mem(STACK-PTR-LBL))
                     (backend) :
                        ;Store C preserved registers
                        #storel(#rsp, #r1, -8)
                        #storel(#rsp, #r6, -16)
                        #storel(#rsp, #r11, -24)
                        #storel(#rsp, #r12, -32)
                        #storel(#rsp, #r13, -40)
                        #storel(#rsp, #r14, -48)
                        ;Move #rsp to R6 for CArgs
                        #movl(#r6, #rsp)
                        ;Restore Stanza context
                        #loadl(#rsp, Mem(STACK-PTR-LBL))
               (op:TgtOp&Binary) :
                  val [x, y, z] = [xs(e)[0], ys(e)[0], ys(e)[1]]
                  #binop(imm-type(y), x, op, y, z)
               (op:TgtOp&Unary) :
                  val [x, y] = [xs(e)[0], ys(e)[0]]
                  #unaop(imm-type(x), x, op, y)
               (op) :
                  fatal("Unsupported Op: %_" % [e])
         (e:Args) :
            ;Write stack map
            #movl(#r0, Mem(stack-map-id))
            #storel(#rsp, #r0, 8)
            ;Null out stack
            for off in ref-offsets(stackmap) do :
               #storel(#rsp, IntImm(VOID-TAG), off)
            ;Save argument values
            val ys* = match(ctxt(e)) :
               (c:StanzaContext) : call-locations(xs(e))
               (c:CContext) : xs(c)
            shuffle-vals(xs(e), ys*)
         (e:Call) :
            match(type(e)) :
               (t:StanzaCall) :
                  ;Call in new stack?
                  if new-stack?(t) :
                     #storel(Mem(STACK-LIM-LBL), IntImm(0))
                  ;Move arguments into position and call
                  val f* = match(f(e)) :
                     (f*:Mem|ExMem) :
                        shuffle-vals(call-locations(ys(e)), ys(e))
                        f*
                     (f*) :
                        val ts* = call-locations(f*,ys(e))
                        shuffle-vals(ts*, cons(f*,ys(e)))
                        head(ts*)
                  ;Check whether tail call
                  if tail?(t) :
                     ;Set arity
                     #movl(#r0, IntImm(arity(t)))
                     ;Tail call
                     #goto(f*)
                  else :
                     ;Set arity
                     #movl(#r0, IntImm(arity(t)))
                     ;Call
                     #addl(#rsp, #rsp, IntImm(size(stackmap) + 8))
                     #call(f*)
                     ;Record call site
                     if info(t) is FileInfo :
                        val lbl = fresh-id()
                        add(infos, lbl => info(t) as FileInfo)
                        #label(lbl)
                     ;Resume
                     #subl(#rsp, #rsp, IntImm(size(stackmap) + 8))
                     ;Move return values out from Args
                     shuffle-vals(xs(e), call-locations(xs(e)))

               (t:StackCall) :
                  ;Move arguments into position
                  val ts* = call-locations(f(e), ys(e))
                  shuffle-vals(ts*, cons(f(e),ys(e)))
                  ;Determine whether tail call
                  if tail?(t) :
                     ;Cap the current stack
                     ;#r0 = current stack
                     #loadl(#r0, Mem(STACK-LBL))
                     #storel(#r0, #rsp, STACK-SP-OFFSET - REF-TAG-BITS)
                     ;Update the current stack and limits
                     ;#r1 = target stack
                     ;temporary #r0 = stack limit
                     ;Update stack limit, and current stack
                     #addl(#r0, #r1, IntImm(STACK-SIZE - REF-TAG-BITS))
                     #storel(Mem(STACK-LIM-LBL), #r0)
                     #storel(Mem(STACK-LBL), #r1)
                     ;Recover stack register
                     #loadl(#rsp, #r1, STACK-SP-OFFSET - REF-TAG-BITS)
                     #ret()
                  else :
                     ;Cap the current stack
                     ;#r0 = current stack
                     val ret-lbl = fresh-id()
                     #addl(#rsp, #rsp, IntImm(size(stackmap)))
                     #loadl(#r0, Mem(STACK-LBL))
                     #storel(#r0, #rsp, STACK-SP-OFFSET - REF-TAG-BITS)
                     ;Write return address
                     #movl(#r0, Mem(ret-lbl))
                     #storel(#rsp, #r0)
                     ;Update the current stack and limits
                     ;#r1 = target stack
                     ;temporary #r0 = stack limit
                     ;Update stack limit, and current stack
                     #addl(#r0, #r1, IntImm(STACK-SIZE - REF-TAG-BITS))
                     #storel(Mem(STACK-LIM-LBL), #r0)
                     #storel(Mem(STACK-LBL), #r1)
                     ;Recover stack register
                     #loadl(#rsp, #r1, STACK-SP-OFFSET - REF-TAG-BITS)
                     #ret()
                     ;Record call site
                     #label(ret-lbl)
                     if info(t) is FileInfo :
                        add(infos, ret-lbl => info(t) as FileInfo)
                     ;Resume
                     #subl(#rsp, #rsp, IntImm(size(stackmap) + 8))
                     ;Move return values out from Args
                     shuffle-vals(xs(e), call-locations(xs(e)))
               (t:CCall) :
                  ;Move function and arguments into position
                  val f* = match(f(e)) :
                     (f*:Mem|ExMem) :
                        shuffle-vals(ys(t), ys(e))
                        f*
                     (f*) :
                        val ts* = cons(f(t) as Loc, ys(t))
                        shuffle-vals(ts*, cons(f*,ys(e)))
                        f(t) as Loc
                  ;Calculate number of floating point registers
                  val num-fregs = count({imm-type(_) is RealType}, ys(e))
                  ;Call
                  #movl(#r0, IntImm(num-fregs))
                  #storel(Mem(STACK-PTR-LBL), #rsp)
                  #loadl(#rsp, Mem(C-RSP-LBL))
                  #subl(#rsp, #rsp, IntImm(frame-size(t)))
                  #call(f*)
                  #loadl(#rsp, Mem(STACK-PTR-LBL))
                  ;Move return values out from Args
                  shuffle-vals(xs(e), xs(t))
         (e:Save) :
            #store-var(x(e), x(e))
         (e:Clear) :
            #store-var(x(e), IntImm(VOID-TAG))
         (e:Load) :
            #load-var(x(e), x(e))
         (e:Xchg) :
            #xchg(x(e), y(e))
         (e:ShuffleReg) :
            shuffle-reg(xs(e), ys(e))
         (e:ShuffleFReg) :
            shuffle-freg(xs(e), ys(e))
         (e:Label) :
            #label(n(e))
         (e:Goto) :
            #goto(Mem(n(e)))
         (e:Break) :
            match(op(e)) :
               (o:CmpStackLimitOp) :
                  ;Reserve space for current stack + return address of next call
                  #addl(#r0, #rsp, IntImm(size(stackmap) + 8))
                  #loadl(#r1, Mem(STACK-LIM-LBL))
                  #breakl(n(e), op(o), #r0, #r1)
               (o:CmpArityOp) :
                  #breakl(n(e), op(o), #r0, IntImm(arity(o)))
               (o) :
                  val [x, y] = [xs(e)[0], xs(e)[1]]
                  #break(imm-type(x), n(e), o, x, y)

;============================================================
;====================== Working IR ==========================
;============================================================

defn do-defined (f: Var -> False, e:Ins) :
   match(e) :
      (e:Set) : f(x(e))
      (e:Args) : do(f, xs(e))
      (e:Call) : do(f, xs(e))
      (e:Return) : false
      (e:Op) : do(f, xs(e))
      (e:Branch) : false
      (e:Save) : false
      (e:Load) : f(x(e))

defn do-used (g: Var -> False, e:Ins) :
   defn gi (i:Imm) : g(i as Var) when i is Var
   match(e) :
      (e:Set) : gi(y(e))
      (e:Args) : false
      (e:Call) : (gi(f(e)), do(gi, ys(e)))
      (e:Return) : do(gi, xs(e))
      (e:Op) : do(gi, ys(e))
      (e:Branch) : do(gi, xs(e))
      (e:Save) : gi(x(e))
      (e:Load) : false

defn reverse-sweep (e:Ins, touched: Var -> ?, defined:Var -> ?, emit:Ins -> ?, used:Var -> ?) :
   defn touch-imm (x:Imm) : touched(x as Var) when x is Var
   defn use-imm (x:Imm) : used(x as Var) when x is Var
   match(e) :
      (e:Set) :
         touched(x(e))
         touch-imm(y(e))
         defined(x(e))
         emit(e)
         use-imm(y(e))
      (e:Args) :
         do(touched, xs(e))
         do(defined, xs(e))
         emit(e)
      (e:Call) :
         do(touched, xs(e))
         touch-imm(f(e))
         do(touch-imm, ys(e))
         do(defined, xs(e))
         emit(e)
         use-imm(f(e))
         do(use-imm, ys(e))
      (e:Return) :
         do(touch-imm, xs(e))
         emit(e)
         do(use-imm, xs(e))
      (e:Op) :
         do(touched, xs(e))
         do(touch-imm, ys(e))
         do(defined, xs(e))
         emit(e)
         do(use-imm, ys(e))
      (e:Branch) :
         do(touch-imm, xs(e))
         emit(e)
         do(use-imm, xs(e))

;============================================================
;=================== Working IR =============================
;============================================================

;             Working Instructions
;             ====================

deftype WorkingIns <: Ins
defstruct Save <: WorkingIns :
   x: Var
defstruct Load <: WorkingIns :
   x: Var
defstruct Clear <: WorkingIns :
   x: Var
defstruct Unload <: WorkingIns :
   x: Var
defstruct NextUsed <: WorkingIns :
   n: Int
   pos: Int
defstruct Kill <: WorkingIns :
   n: Int
defstruct Xchg <: WorkingIns :
   x: Var
   y: Var
   swap: Reg|False
defstruct ShuffleReg <: WorkingIns :
   xs: List<Int>
   ys: List<Int>
defstruct ShuffleFReg <: WorkingIns :
   xs: List<Int>
   ys: List<Int>
defstruct Label <: WorkingIns :
   n: Int
defstruct Goto <: WorkingIns :
   n: Int
defstruct Break <: WorkingIns :
   n: Int
   op: TgtOp
   xs: List<Imm>

defmethod print (o:OutputStream, i:WorkingIns) :
   print{o, _} $ match(i) :
      (i:NextUsed) : "next used %_ at %_" % [n(i), pos(i)]
      (i:Kill) : "kill %_" % [n(i)]
      (i:Save) : "save %_" % [x(i)]
      (i:Load) : "load %_" % [x(i)]
      (i:Clear) : "clear %_" % [x(i)]
      (i:Unload) : "unload %_" % [x(i)]
      (i:Xchg) : "xchg %_ %_ through %_" % [x(i), y(i), swap(i)]
      (i:ShuffleReg) : "shuffle reg (%,) = (%,)" % [xs(i), ys(i)]
      (i:ShuffleFReg) : "shuffle freg (%,) = (%,)" % [xs(i), ys(i)]
      (i:Label) : "label<%_>" % [n(i)]
      (i:Goto) : "goto label<%_>" % [n(i)]
      (i:Break) : "break label<%_> when %_(%,)" % [n(i), op(i), xs(i)]

;                Ports
;                =====

defstruct Port :
   n: Int
   saved?: True|False
   loaded?: True|False|Any
   reg: False|Reg|FReg
   dist: Int

defmethod print (o:OutputStream, p:Port) :
   print(o, "%~ (s:%~, l:%~, at:%~, dist:%~)" % [n(p), saved?(p), loaded?(p), reg(p), dist(p)])

;               Any Value
;               =========

defstruct Any <: Equalable
defmethod equal? (a:Any, b:Any) : true
defmethod print (o:OutputStream, x:Any) : print(o, "any")
