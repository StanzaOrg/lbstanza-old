defpackage stz/bb :
   import core
   import verse
   import stz/algorithms
   import stz/utils
   import stz/tgt with :
      prefix => tgt-
   import stz/tgt-ir with :
      prefix => tgt-
   import stz/bb-ir
   import stz/asm-ir with :
      prefix => asm-
   import stz/padder

;                            Main Driver
;                            ===========

public defn compile (d:tgt-DefFn, output:Vector<asm-Ins>) -> False :
   var u:Unit = to-bb-ir(d)
   println("Basic block IR:\n~" << [u])
   u = remove-critical-edges(u)
   u = analyze-liveness(u)
   u = map(emit-early-saves, u)
   println("Get type table")
   val tt = type-table(u)
   println("Allocate classes for:\n~" << [u])
   u = map(allocate-classes{tt, _}, u)
   println("Propagate assumptions for:\n~" << [u])
   u = map(propagate-assumptions, u)
   println(u)
;   println("Register assignment for:\n~" << [u])
;   u = register-assignment(tt, u)
;   println("Finished:\n~" << [u])
;   println("Verify Register Assignment")
;   do(verify-register-assignment, blocks(u) as Vector<WBlock>)
;   println("Calculate stack table")
;   val stack-map = calculate-stack-map(tt, u)
;   println("Collapse Blocks")
;   val ins = collapse-blocks(u)
;   println("Collapsed Instructions:\n~@" << [join(ins, "\n")])
;   compile(tt, ins, stack-map, output)


;                          Various Utilities
;                          =================

defn make-table<?K,?V,?T> (xs:Streamable<?T>,
                           k: T -> ?K,
                           v: T -> ?V,
                           hash: K -> Int) :
   val table = HashTable<K,V>(hash)
   for x in xs do : table[k(x)] = v(x)
   table

defn map (f: WBlock -> Block, u:Unit) :
   Unit(defs(u),
        map(f, blocks(u) as Vector<WBlock>))

defn in-reverse<?T> (xs:Vector<?T>) :
   for i in (length(xs) - 1) through 0 by -1 stream :
      xs[i]

defn reverse!<?T> (xs:Vector<?T>) :
   val n = length(xs)
   for i in 0 to n / 2 do :
      val j = n - 1 - i
      val xi = xs[i]
      val xj = xs[j]
      xs[i] = xj
      xs[j] = xi

defn reverse-post-order (bs:Vector<Block>) -> Vector<Block> :
   ;Block Table
   val block = HashTable<Int,Block>({_})
   for b in bs do : block[n(b)] = b

   ;Mark Table
   val mark-table = HashTable<Int,True>({_})
   defn marked? (b:Block) : key?(mark-table, n(b))
   defn mark (b:Block) : mark-table[n(b)] = true

   ;Add blocks to ys
   val ys = Vector<Block>()
   defn* loop (b:Block) :
      if not marked?(b) :
         mark(b)
         do(loop{block[_]}, next(b))
         add(ys, b)
   loop(bs[0])

   ;Return reversed
   reverse!(ys)
   ys

defn find!<?T> (f: T -> True|False, xs:Streamable<?T>) -> T :
   find(f, xs) as T


;                           Translation to IR
;                           =================

defn to-bb-ir (d:tgt-DefFn) -> Unit :
   println("TODO: Not everything is a ComOp")
   println("TODO: Defs need to be properly populated.")
   println("TODO: Some operators need to have immediates pulled out to values.")

   ;     State
   ;     -----
   val defs = Vector<tgt-DefVar>()
   val blocks = Vector<Block>()
   val type-table = HashTable<Int,tgt-TgtType>({_})

   ;     Update State
   ;     ------------
   defn close-block (b:Block, ns:List<Int>) :
      add(blocks, Block(n(b), ins(b), ns))
   defn fresh-block (n:Int) :
      Block(n, Vector<Ins>(), List())

   ;     Populate Defs and Type Table
   ;     ----------------------------
   defn add-def (d:tgt-DefVar) :
      add(defs, d)
      type-table[tgt-n(d)] = tgt-type(d)
   defn imm-type (i:tgt-Imm) :
      match(i) :
         (i:tgt-ByteImm) : tgt-BYTE-TYPE
         (i:tgt-IntImm) : tgt-INT-TYPE
         (i:tgt-LongImm) : tgt-LONG-TYPE
         (i:tgt-Var) : type-table[tgt-n(i)]
   defn fresh-local (t:tgt-TgtType) :
      val n = fresh-id()
      add(defs, tgt-DefVar(n, t))
      type-table[n] = t
      Var(n)
   do(add-def, tgt-args(d))
   do(add-def, tgt-locals(d))

   ;     Find all blocks
   ;     ---------------
   defn* scan-block (b:Block, str-i:Stream<tgt-Ins>) :
      defn emit (i:Ins) :
         add(ins(b), i)

      defn to-imm (x:tgt-Imm) :
         match(x) :
            (x:tgt-Var) : Var(tgt-n(x))
            (x) : Val(x)

      defn to-var (x:tgt-Imm) :
         match(x) :
            (x:tgt-Var) :
               to-imm(x) as Var
            (x) :
               val v = fresh-local(imm-type(x))
               emit(Set(v, Val(x)))
               v

      if more?(str-i) :
         match(next(str-i)) :
            (i:tgt-SetIns) :
               val x = to-var(tgt-x(i))
               val y = to-imm(tgt-y(i))
               emit(Set(x, y))
               scan-block(b, str-i)
            (i:tgt-BinOp) :
               ;     Classification
               ;     --------------
               defn com-op? (o:tgt-TgtOp) :
                  contains?([tgt-ADD-OP, tgt-MUL-OP, tgt-AND-OP, tgt-OR-OP, tgt-XOR-OP], o)
               defn ncom-op? (o:tgt-TgtOp) :
                  o == tgt-SUB-OP
               defn div-op? (o:tgt-TgtOp) :
                  contains?([tgt-DIV-OP, tgt-MOD-OP], o)
               defn cmp-op? (o:tgt-TgtOp) :
                  contains?([tgt-EQ-OP, tgt-NE-OP, tgt-LT-OP, tgt-GT-OP, tgt-LE-OP,
                             tgt-GE-OP, tgt-ULE-OP, tgt-ULT-OP, tgt-UGT-OP, tgt-UGE-OP], o)
               defn shf-op? (o:tgt-TgtOp) :
                  contains?([tgt-SHL-OP, tgt-SHR-OP, tgt-ASHR-OP], o)
               defn int-type? (t:tgt-TgtType) :
                  contains?([tgt-BYTE-TYPE, tgt-INT-TYPE, tgt-LONG-TYPE, tgt-REF-TYPE], t)
               defn float-type? (t:tgt-TgtType) :
                  contains?([tgt-FLOAT-TYPE, tgt-DOUBLE-TYPE], t)


               ;     Convenience Translators
               ;     -----------------------
               val t = imm-type(tgt-x(i))
               val top = tgt-op(i)
               defn x-var () : list(to-var(tgt-x(i)))
               defn y-imms () : list(to-imm(tgt-y(i)), to-imm(tgt-z(i)))
               defn y-vars () : list(to-var(tgt-y(i)), to-var(tgt-z(i)))

               ;     Dispatch on Operator Type
               ;     -------------------------
               if int-type?(t) :
                  switch _{top} :
                     com-op? :
                        emit(Op(ComOp(top), x-var(), y-imms()))
                     ncom-op? :
                        val y = to-imm(tgt-y(i))
                        val z = to-imm(tgt-z(i))
                        emit(Op(NComOp(top), x-var(), list(y, z)))
                        emit(Op(NOp(), List(), list(z))) when y != z
                     div-op? :
                        if t == tgt-BYTE-TYPE :
                           val y = to-var(tgt-y(i))
                           val z = to-var(tgt-z(i))
                           emit(Op(DivOp(top), x-var(), list(y, z)))
                           emit(Op(NOp(), List(), list(z))) when y != z
                        else if top == tgt-DIV-OP :
                           val tmp = fresh-local(t)
                           val x = to-var(tgt-x(i))
                           val y = to-var(tgt-y(i))
                           val z = to-var(tgt-z(i))
                           emit(Op(DivModOp(), list(x, tmp), list(y, z)))
                           emit(Op(NOp(), List(), list(z))) when y != z
                        else if top == tgt-MOD-OP :
                           val tmp = fresh-local(t)
                           val x = to-var(tgt-x(i))
                           val y = to-var(tgt-y(i))
                           val z = to-var(tgt-z(i))
                           emit(Op(DivModOp(), list(tmp, x), list(y, z)))
                           emit(Op(NOp(), List(), list(z))) when y != z
                        else :
                           error("Unreachable")
                     cmp-op? :
                        val ys* = match(tgt-y(i), tgt-z(i)) :
                           (y:tgt-Var, z) : y-imms()
                           (y, z:tgt-Var) : y-imms()
                           (y, z) : list(to-var(y), to-imm(z))
                        emit(Op(CmpOp(top), x-var(), ys*))
                     shf-op? :
                        val y = to-imm(tgt-y(i))
                        val z = to-imm(tgt-z(i))
                        emit(Op(ShfOp(top), x-var(), list(y, z)))
                        emit(Op(NOp(), List(), list(z))) when y != z
               else if float-type?(t) :
                  switch _{top} :
                     com-op? : emit(Op(ComOp(top), x-var(), y-imms()))
                     cmp-op? : emit(Op(CmpOp(top), x-var(), y-imms()))
                     ncom-op? :
                        val y = to-imm(tgt-y(i))
                        val z = to-imm(tgt-z(i))
                        emit(Op(NComOp(top), x-var(), list(y, z)))
                        emit(Op(NOp(), List(), list(z))) when y != z
                     div-op? :
                        val y = to-imm(tgt-y(i))
                        val z = to-imm(tgt-z(i))
                        emit(Op(NComOp(top), x-var(), list(y, z)))
                        emit(Op(NOp(), List(), list(z))) when y != z
               else :
                  error("Unreachable")
               scan-block(b, str-i)
            (i:tgt-ConvertIns) :
               val x* = to-var(tgt-x(i))
               val y* = to-var(tgt-y(i))
               emit(Op(ConvOp(tgt-signed?(i)), list(x*), list(y*)))
               scan-block(b, str-i)
            (i:tgt-Load) :
               val x* = to-var(tgt-x(i))
               val y* = to-imm(tgt-y(i))
               emit(Op(LoadOp(tgt-offset(i)), list(x*), list(y*)))
               scan-block(b, str-i)
            (i:tgt-Store) :
               val x* = to-imm(tgt-x(i))
               val y* = to-imm(tgt-y(i))
               emit(Op(StoreOp(tgt-offset(i)), List(), list(x*, y*)))
               scan-block(b, str-i)
            (i:tgt-Addr) :
               val x* = to-var(tgt-x(i))
               val y* = to-imm(tgt-y(i))
               emit(Op(AddrOp(y*, tgt-offset(i)), list(x*), List()))
               scan-block(b, str-i)
            (i:tgt-Call) :
               val xs = map(to-var, tgt-xs(i))
               val f = to-imm(tgt-f(i))
               val ys = map(to-imm, tgt-ys(i))
               emit(Call(tgt-arity(i), xs, f, ys, false))
               scan-block(b, str-i)
            (i:tgt-TCall) :
               val f = to-imm(tgt-f(i))
               val ys = map(to-imm, tgt-ys(i))
               emit(Call(tgt-arity(i), List(), f, ys, true))
               close-block(b, List())
               scan-block(fresh-block(fresh-id()), str-i)
            (i:tgt-Return) :
               val xs = map(to-imm, tgt-xs(i))
               emit(Return(xs))
               close-block(b, List())
               scan-block(fresh-block(fresh-id()), str-i)
            (i:tgt-Label) :
               close-block(b, list(tgt-n(i)))
               scan-block(fresh-block(tgt-n(i)), str-i)
            (i:tgt-Goto) :
               val n = fresh-id()
               close-block(b, list(tgt-n(i)))
               scan-block(fresh-block(n), str-i)
            (i:tgt-Branch) :
               val alt = fresh-id()
               val xs = match(tgt-x(i), tgt-y(i)) :
                  (x:tgt-Var, y) : list(to-imm(x), to-imm(y))
                  (x, y:tgt-Var) : list(to-imm(x), to-imm(y))
                  (x, y) : list(to-var(x), to-imm(y))
               emit(Branch(CmpOp(tgt-op(i)), xs))
               close-block(b, list(tgt-n(i), alt))
               scan-block(fresh-block(alt), str-i)

   ;     Entry Block
   ;     -----------
   val entry = fresh-block(fresh-id())
   add(ins(entry), Args(vs)) where :
      val vs = for def in tgt-args(d) map :
         Var(tgt-n(def))
   scan-block(entry, to-stream(tgt-body(d)))

   ;     Return result
   ;     -------------
   Unit(defs, blocks)



;                       Critical Edge Removal
;                       =====================

defn remove-critical-edges (u:Unit) :

   ;     Forward past empty blocks
   ;     -------------------------
   val forwards = HashTable<Int,Int>({_})

   defn resolve (n:Int) :
      match(get?(forwards, n, false)) :
         (f:False) :
            n
         (f:Int) :
            val n* = resolve(f)
            forwards[n] = n*
            n*

   defn next* (b:Block) :
      map(resolve, next(b))

   for b in blocks(u) do :
      if empty?(ins(b)) :
         if length(next(b)) == 1 :
            forwards[n(b)] = head(next(b))


   ;     Count predecessors for blocks
   ;     -----------------------------
   val num-preds = HashTable<Int,Int>({_})
   defn inc-pred (b:Int) :
      num-preds[b] = 1 + get?(num-preds, b, 0)

   for b in blocks(u) do :
      if not empty?(ins(b)) :
         do(inc-pred, next*(b))


   ;     Insert safe blocks
   ;     ------------------
   val safe-blocks = Vector<Block>()
   val blocks* = Vector<Block>()

   defn safe-block (next:Int) :
      val n = fresh-id()
      add(safe-blocks, Block(n, Vector<Ins>(), list(next)))
      n

   defn multi-in? (b:Int) :
      get?(num-preds, b, 0) > 1

   defn multi-out? (b:Block) :
      length(next(b)) > 1


   for b in blocks(u) map :
      add{blocks*, Block(n(b), ins(b), _)} $
         if multi-out?(b) :
            for n in next*(b) map :
               if multi-in?(n) : safe-block(n)
               else : n
         else :
            next*(b)
   do(add{blocks*, _}, safe-blocks)

   ;     Return result
   ;     -------------
   Unit(defs(u), blocks*)



;                       Working IR
;                       ==========

;     Working Instructions
;     --------------------
definterface Working
defstruct WArgs <: Ins&Working :
   xs: List<Port>
defstruct WCall <: Ins&Working :
   arity: Int
   xs: List<Port>
   f: Imm
   ys: List<Imm>
   tail?: True|False
defstruct Save <: Ins&Working :
   x: Var
defstruct Load <: Ins&Working :
   x: Var
defstruct Unload <: Ins&Working :
   x: Var
defstruct Xchg <: Ins&Working :
   x: Var
   y: Var
   swap: Reg|FReg|False
defstruct Glue <: Ins&Working :
   xs: List<Var>
   ys: List<Var>
defstruct Label <: Ins&Working :
   n: Int
defstruct Goto <: Ins&Working :
   n: Int
defstruct Break <: Ins&Working :
   n: Int
   op: BBOp
   xs: List<Imm>
   flip?: True|False

defn cms (xs) : join(xs, ", ")
defmethod print (o:OutputStream, i:Ins&Working) :
   print{o, _} $ match(i) :
      (i:WArgs) : "(~@) = Args" << [cms(xs(i))]
      (i:WCall) : "(~@) = ~(~@)" << [cms(xs(i)), f(i), cms(ys(i))]
      (i:Save) : "save ~" << [x(i)]
      (i:Load) : "load ~" << [x(i)]
      (i:Unload) : "unload ~" << [x(i)]
      (i:Xchg) : "xchg ~ ~ through ~" << [x(i), y(i), swap(i)]
      (i:Glue) : "shuffle (~@) = (~@)" << [cms(xs(i)), cms(ys(i))]
      (i:Label) : "label<~>" << [n(i)]
      (i:Goto) : "goto label<~>" << [n(i)]
      (i:Break) : "break label<~> when ~(~@) (flip:~)" << [n(i), op(i), cms(xs(i)), flip?(i)]

;     Any Value
;     ---------
defstruct Any
defmethod print (o:OutputStream, x:Any) :
   print(o, "any")

;     Port Definition
;     ---------------
definterface Port
defmulti n (p:Port) -> Int

defstruct LivePort <: Port :
   n: Int with: (as-method => true)
   saved?: True|False|Any
   loaded?: True|False|Any
   loc: Loc
defstruct DeadPort <: Port :
   n: Int with: (as-method => true)

defmethod print (o:OutputStream, p:Port) :
   print{o, _} $ match(p) :
      (p:LivePort) : "~ (s:~, l:~, at:~)" << [n(p), saved?(p), loaded?(p), loc(p)]
      (p:DeadPort) : "~ (dead)" << [n(p)]

;     Working Block
;     -------------
defstruct WBlock <: Block :
   n: Int with : (as-method => true)
   ins: Vector<Ins> with : (as-method => true)
   next: List<Int> with : (as-method => true)
   in: List<LivePort>
   out: List<LivePort>
   dist: List<Int>

defmethod print (o:OutputStream, b:WBlock) :
   val io = IndentedStream(o, 3)
   print(o, "block B~ :" << [n(b)])
   print(io, "\nin: ~@" << [cms(in(b))])
   for e in ins(b) do :
      print(io, "\n~" << [e])
   print(io, "\nnext ~@" << [cms(next(b))])
   print(io, "\nout: ~@" << [cms(out(b))])
   print(io, "\ndist: ~@" << [cms(dist(b))])


;     Useful Doers
;     ------------
defn do-defined (f: Var|Port -> False, e:Ins) :
   match(e) :
      (e:Set) : f(x(e))
      (e:WArgs) : do(f, xs(e))
      (e:WCall) : do(f, xs(e))
      (e:Return) : false
      (e:Op) : do(f, xs(e))
      (e:Branch) : false
      (e:Save) : false
      (e:Load) : f(x(e))

defn do-used (g: Imm|Port -> False, e:Ins) :
   match(e) :
      (e:Set) : g(y(e))
      (e:WArgs) : false
      (e:WCall) : (g(f(e)), do(g, ys(e)))
      (e:Return) : do(g, xs(e))
      (e:Op) : do(g, ys(e))
      (e:Branch) : do(g, xs(e))
      (e:Save) : g(x(e))
      (e:Load) : false

;                         Type Table
;                         ==========

defn type-table (u:Unit) :
   make-table(defs(u), tgt-n, tgt-type, {_})

;                       Block Liveness
;                       ==============

defn analyze-liveness (u:Unit) :
   ;     Propagation Tables
   ;     ------------------
   defn bhash ([b,x]:[Int,Int]) : 7 * b + x
   val defs-tab = HashTable<[Int,Int],True>(bhash)
   val ins-tab = HashTable<[Int,Int],False|Int>(bhash)

   ;     Find immediate defs and live-ins
   ;     --------------------------------
   defn find-defs-uses (b:Block) :
      ;Update def/ins tables
      defn key (x:Var) : [n(b), n(x)]
      defn def (x:Var) :
         defs-tab[key(x)] = true
         ins-tab[key(x)] = false
      defn use (x:Imm, i:Int) :
         match(x) :
            (x:Var) : ins-tab[key(x)] = i
            (x) : false
      defn def (xs:List<Var>) : do(def, xs)
      defn use (xs:List<Imm>, i:Int) : do(use{_, i}, xs)

      ;Sweep through instructions
      val n = length(ins(b))
      for (e in in-reverse(ins(b)), i in (n - 1) through 0 by -1) do :
         match(e) :
            (e:Set) : (def(x(e)), use(y(e), i))
            (e:Op) : (def(xs(e)), use(ys(e), i))
            (e:Call) : (def(xs(e)), use(f(e), i), use(ys(e), i))
            (e:Args) : def(xs(e))
            (e:Return) : use(xs(e), i)
            (e:Branch) : use(xs(e), i)

   do(find-defs-uses, blocks(u))

   ;     Find block predecessors and block lengths
   ;     -----------------------------------------
   val preds = HashTable<Int,List<Int>>({_})
   val lengths = HashTable<Int,Int>({_})
   for b in blocks(u) do :
      preds[n(b)] = List()
      lengths[n(b)] = length(ins(b))
   for b in blocks(u) do :
      for nx in next(b) do :
         preds[nx] = List(n(b), preds[nx])

   ;     Propagation of live-ins and live-outs
   ;     -------------------------------------
   ;Iterate through a table of live vars
   defn do-for-live (f: [Int,Int,Int] -> False,
                     es: HashTable<[Int,Int],False|Int>) :
      for entry in es do :
         if value(entry) != false :
            val [b,x] = key(entry)
            f([b, x, value(entry) as Int])

   ;Propagate block liveness results
   val outs-tab = HashTable<[Int,Int],Int>(bhash)
   fixpoint $ fn (progress) :
      defn add-live (live:HashTable<[Int,Int],False|Int>,
                     b:Int, x:Int, d:Int) :
         match(get?(live, [b,x], false)) :
            (d2:Int) :
               if d < d2 :
                  live[[b,x]] = d
                  progress()
            (d2:False) :
               live[[b,x]] = d
               progress()

      for [b,x,d] in ins-tab do-for-live :
         for p in preds[b] do : add-live(outs-tab, p, x, d)
      for [b,x,d] in outs-tab do-for-live :
         if not key?(defs-tab, [b,x]) :
            add-live(ins-tab, b, x, d + lengths[b])

   ;     Create results table
   ;     --------------------
   defn to-port (x:Int) : LivePort(x, Any(), Any(), NoLoc())
   val in-lists = HashTable<Int,List<Int>>({_})
   val out-lists = HashTable<Int,List<Int>>({_})
   val dist-lists = HashTable<Int,List<Int>>({_})
   for [b,x,d] in ins-tab do-for-live :
      in-lists[b] = List(x, get?(in-lists, b, List()))
   for [b,x,d] in outs-tab do-for-live :
      out-lists[b] = List(x, get?(out-lists, b, List()))
      dist-lists[b] = List(d, get?(dist-lists, b, List()))

   let :
      val blocks* = for b in blocks(u) map :
         WBlock(n(b),
                ins(b),
                next(b),
                map(to-port, get?(in-lists, n(b), List()))
                map(to-port, get?(out-lists, n(b), List()))
                get?(dist-lists, n(b), List()))

      Unit(defs(u), blocks*)


;                             Position Marker
;                             ===============

defstruct Pos :
   index: Int
   mid?: True|False

defn hash (p:Pos) :
   match(mid?(p)) :
      (m:True) : index(p) * 2 + 1
      (m:False) : index(p) * 2

defn less? (a:Pos, b:Pos) :
   hash(a) < hash(b)

defn less-eq? (a:Pos, b:Pos) :
   hash(a) <= hash(b)

defmethod print (o:OutputStream, p:Pos) :
   print(o, "~~" << [
      index(p),
      ".5" when mid?(p) else ""])



;                             List Table
;                             ==========

defclass ListTable<K,V>
defmulti get<?K,?V> (t:ListTable<?K,?V>, k:K) -> Streamable<V>
defmulti get<?K,?V> (t:ListTable<?K,?V>, k:K, i:Int) -> V
defmulti add<?K,?V> (t:ListTable<?K,?V>, k:K, v:V) -> False
defmulti length<?K> (t:ListTable<?K, ?>, k:K) -> Int

defn ListTable<K,V> (hash: K -> Int) :
   defn pos-hash ([k,i]:[K,Int]) : 7 * hash(k) + i
   val item-table = HashTable<[K,Int], V>(pos-hash)
   val len-table = HashTable<K,Int>(hash)

   new ListTable<K,V> :
      defmethod get (this, k:K, i:Int) :
         if (i < 0) or (i >= len-table[k]) :
            error("Index ~ out of bounds." % [i])
         item-table[[k,i]]

      defmethod get (this, k:K) :
         match(get?(len-table, k, false)) :
            (n:Int) :
               new Streamable<V> :
                  defmethod to-stream (this) :
                     for i in 0 to n stream :
                        item-table[[k,i]]
            (n:False) :
               List()

      defmethod add (this, k:K, v:V) :
         val n = length(this, k)
         item-table[[k,n]] = v
         len-table[k] = n + 1

      defmethod length (this, k:K) :
         get?(len-table, k, 0)


;                             Usage Table
;                             ===========

;     Interface
;     ---------
defclass UsageTable
defmulti order-by-usage (t:UsageTable, xs:Streamable<Int>, p:Pos) -> Stream<Int>

;     Type of Usage
;     -------------
definterface Usage
defmulti pos (u:Usage) -> Pos
defstruct UsedUsage <: Usage : (pos:Pos with: (as-method => true))
defstruct KillUsage <: Usage : (pos:Pos with: (as-method => true))

;     Analysis
;     --------
defn usage-table (b:WBlock) :
   ;     Computing List of Usages
   ;     ------------------------
   val usages = ListTable<Int, Usage>({_})

   defn add-usage (x:Int|Imm|Port, u:Usage) :
      match(x) :
         (x:Int) : add(usages, x, u)
         (x:Var) : add-usage(n(x), u)
         (x:LivePort) : add-usage(n(x), u)
         (x) : false

   for (e in ins(b), i in 0 to false) do :
      if e not-typeof Save :
         for x in e do-used :
            add-usage(x, UsedUsage(Pos(i, false)))
      for x in e do-defined :
         add-usage(x, KillUsage(Pos(i, true)))

   val n = length(ins(b))
   for (x in out(b), d in dist(b)) do :
      add-usage(x, UsedUsage(Pos(d + n, false)))


   ;     Order by Distance
   ;     -----------------
   defn use-pos (x:Int, p:Pos) :
      val use = find({p <= pos(_)}, usages[x])
      match(use) :
         (use:UsedUsage) :
            index(pos(use))
         (use:KillUsage|False) :
            error("Variable ~ is not used after ~." % [x, p])

   val ordering-buffer = Vector<Int>()
   new UsageTable :
      defmethod order-by-usage (this, xs:Streamable<Int>, p:Pos) :
         clear(ordering-buffer)
         for x in xs do : add(ordering-buffer, x)
         sort-by-key!(ordering-buffer, use-pos{_, p})
         in-reverse(ordering-buffer)


;                      Release Table
;                      =============

;     Interface
;     ---------
defclass ReleaseTable
defmulti get (t:ReleaseTable, a:Pos, b:Pos) -> Streamable<Int>

;     Analysis
;     --------
defn release-table (b:WBlock) :
   ;     Computing Releases and Positions
   ;     --------------------------------
   val load-table = HashTable<Int,True|False>({_})
   val release-list = Vector<KeyValue<Pos,Int>>()

   defn clear-loaded () :
      clear(load-table)

   defn mark-loaded (x:Int|Imm|Port, v:True|False) :
      match(x) :
         (x:Int) : load-table[x] = v
         (x:Var) : load-table[n(x)] = v
         (x:LivePort) : (load-table[n(x)] = v) when loaded?(x) != false
         (x) : false

   defn release-if-not-loaded (p:Pos, x:Int|Imm|Port) :
      match(x) :
         (x:Int) :
            if not get?(load-table, x, false) :
               add(release-list, p => x)
         (x:Var) : release-if-not-loaded(p, n(x))
         (x:LivePort) : release-if-not-loaded(p, n(x))
         (x) : false

   ;Initialize live-out as live
   for x in out(b) do :
      mark-loaded(x, true)

   ;Analyze expression list
   val n = length(ins(b))
   for (e in in-reverse(ins(b)), i in (n - 1) through 0 by -1) do :
      for x in e do-defined :
         release-if-not-loaded(Pos(i + 1, false), x)
         mark-loaded(x, false)
      if e typeof WCall :
         clear-loaded()
      for x in e do-used :
         release-if-not-loaded(Pos(i, true), x)
         mark-loaded(x, true)
   reverse!(release-list)

   ;     Compute releases to a given position
   ;     ------------------------------------
   var cached-pos = Pos(0, false)
   var cached-i = 0
   defn pos-index (p:Pos) :
      defn* loop (i:Int) :
         if i < length(release-list) :
            val r = release-list[i]
            if p < key(r) : i
            else : loop(i + 1)
         else : i
      ;Optimization
      cached-i =
         if cached-pos <= p : loop(cached-i)
         else : loop(0)
      cached-pos = p
      cached-i

   new ReleaseTable :
      defmethod get (this, a:Pos, b:Pos) :
         val ai = pos-index(a)
         val bi = pos-index(b)
         new Streamable<Int> :
            defmethod to-stream (this) :
               for i in ai to bi stream :
                  value(release-list[i])

      defmethod print (o:OutputStream, this) :
         val io = IndentedStream(o, 3)
         print(o, "Release Table:")
         for e in release-list do :
            print(io, "\n~" << [e])



;                       Save Emission
;                       =============

defn emit-early-saves (b:WBlock) :
   ;     Algorithm State
   ;     ---------------
   ;requires-save = true implies a variable needs to be saved. (default = false)
   ;prefers-load = false implies no benefit if a variable is loaded. (default = true)
   ;is-live = true implies a variable is still going to be used. (default = false)

   val requires-save = HashTable<Int,True|False>({_})
   val prefers-load = HashTable<Int,True|False>({_})
   val is-live = HashTable<Int,True|False>({_})

   defn currently-live () :
      stream(key, filter(value, is-live))

   ;     Output State
   ;     ------------
   val accum = Vector<Ins>()

   defn emit (i:Ins) :
      add(accum, i)

   ;     Analysis Helpers
   ;     ----------------
   ;Updates state for a defined variable
   defn defd (x:Var) :
      is-live[n(x)] = false
      requires-save[n(x)] = false
      prefers-load[n(x)] = false

   ;Updates state for a used variable
   defn used (x:Imm) :
      match(x) :
         (x:Var) :
            is-live[n(x)] = true
            prefers-load[n(x)] = true
         (x) : false

   ;Updates state for a variable that was live through a call
   defn lived-through-call (x:Int) :
      requires-save[x] = true
      prefers-load[x] = false

   ;Convenience
   defn defd (xs:List<Var>) : do(defd, xs)
   defn used (xs:List<Imm>) : do(used, xs)
   defn lived-through-call (xs:Stream<Int>) : do(lived-through-call, xs)

   ;Retrieve the variable as a port according to the current algorithm state.
   defn get-port (x:Int) :
      val sv = get?(requires-save, x, false)
      val ld = get?(prefers-load, x, true)
      val lv = get?(is-live, x, false)
      match(lv, sv, ld) :
         (lv:False, sv, ld) : DeadPort(x)
         (lv:True, sv:False, ld:False) : LivePort(x, Any(), false, NoLoc())
         (lv:True, sv:False, ld:True) : LivePort(x, Any(), Any(), NoLoc())
         (lv:True, sv:True, ld:False) : LivePort(x, true, false, NoLoc())
         (lv:True, sv:True, ld:True) : LivePort(x, true, Any(), NoLoc())

   defn get-port (x:Var) : get-port(n(x))
   defn get-port (xs:List<Var>) : map(get-port, xs)

   ;Insert a Save for the variable if it needs to be saved.
   defn save-if-required (x:Var) :
      if get?(requires-save, n(x), false) :
         emit(Save(x))

   defn save-if-required (xs:List<Var>) :
      do(save-if-required, xs)

   ;     Analysis
   ;     --------
   ;Exit variables
   for p in out(b) do :
      is-live[n(p)] = true

   ;Sweep through instructions
   ;For each instruction:
   ;1. Save any required values
   ;2. Emit the updated instruction
   ;3. Update the algorithm state
   for e in in-reverse(ins(b)) do :
      match(e) :
         (e:Set) :
            save-if-required(x(e))
            emit(e)
            defd(x(e))
            used(y(e))
         (e:Args) :
            emit(WArgs(get-port(xs(e))))
            defd(xs(e))
         (e:Call) :
            emit(WCall(arity(e), get-port(xs(e)), f(e), ys(e), tail?(e)))
            defd(xs(e))
            lived-through-call(currently-live())
            used(f(e))
            used(ys(e))
         (e:Return) :
            emit(e)
            used(xs(e))
         (e:Op) :
            save-if-required(xs(e))
            emit(e)
            defd(xs(e))
            used(ys(e))
         (e:Branch) :
            emit(e)
            used(xs(e))

   ;Entry variables
   val in* = for x in in(b) map :
      get-port(n(x)) as LivePort

   ;     Return results
   ;     --------------
   reverse!(accum)
   WBlock(n(b),
          accum,
          next(b),
          in*,
          out(b),
          dist(b))


;                       Class Allocation
;                       ================

;     Allocate classes
;     ----------------
defn allocate-classes (tt:HashTable<Int,tgt-TgtType>, b:WBlock) -> WBlock :
   ;     Layer 1
   ;     -------
   ;Algorithm state
   val saved = HashTable<Int, True|False|Any>({_})
   val loaded = HashTable<Int, True|False|Any>({_})
   var num-free-reg = 8
   var num-free-freg = 8
   val output = Vector<Ins>()

   ;Utilities
   defn inc-reg (n:Int, t:tgt-TgtType) :
      if tgt-int?(t) : num-free-reg = num-free-reg + n
      else if tgt-float?(t) : num-free-freg = num-free-freg + n
      else : error("Unreachable")

   ;Raw Fundamental Language
   defn emit (i:Ins) :
      add(output, i)

   defn kill (x:Int) :
      match(loaded[x]) :
         (l:True|Any) : inc-reg(1, tt[x])
         (l:False) : false
      loaded[x] = false

   defn save (x:Int) :
      match(saved[x]) :
         (s:True) : false
         (s:False|Any) : emit(Save(Var(x)))
      saved[x] = true

   defn load (x:Int) :
      match(loaded[x]) :
         (l:True) : false
         (l:False) :
            emit(Load(Var(x)))
            inc-reg(-1, tt[x])
         (l:Any) :
            emit(Load(Var(x)))
      loaded[x] = true

   defn unload (x:Int) :
      match(loaded[x]) :
         (l:True|Any) :
            emit(Unload(Var(x)))
            inc-reg(1, tt[x])
         (l:False) : false
      loaded[x] = false

   defn define (x:Var) :
      val n = n(x)
      loaded[n] = true
      saved[n] = false
      inc-reg(-1, tt[n])

   defn define (x:Port) :
      match(x) :
         (x:LivePort) :
            loaded[n(x)] = loaded?(x) as False|Any
            saved[n(x)] = saved?(x) as True|Any
            inc-reg(-1, tt[n(x)]) when loaded?(x) typeof Any
         (x:DeadPort) :
            false

   defn currently-loaded () :
      stream{key, _} $
      for e in loaded filter :
         value(e) typeof True|Any

   ;Convenience
   defn save (x:Var) : save(n(x))
   defn load (x:Imm) : load(n(x as Var)) when x typeof Var
   defn load (xs:Streamable<Imm>) : do(load, xs)
   defn kill (xs:Streamable<Int>) : do(kill, xs)
   defn define (xs:Streamable<Var>) : do(define, xs)
   defn define (xs:Streamable<Port>) : do(define, xs)


   ;     Layer 2
   ;     -------
   defn num-spills-required (used:List<Imm>,
                             released:Streamable<Int>,
                             defined:List<Var>) :
      ;Track whether a variable is projected to be loaded
      val proj-loaded = HashTable<Int,True|False>({_})
      defn proj-loaded? (x:Int) :
         if key?(proj-loaded, x) : proj-loaded[x]
         else : loaded[x] != false

      ;Track the net use count
      var net-reg-use = 0
      var net-freg-use = 0
      var peak-reg-use = 0
      var peak-freg-use = 0

      defn inc-reg-use (n:Int, t:tgt-TgtType) :
         if tgt-int?(t) :
            net-reg-use = net-reg-use + n
            peak-reg-use = max(peak-reg-use, net-reg-use)
         else if tgt-float?(t) :
            net-freg-use = net-freg-use + n
            peak-freg-use = max(peak-freg-use, net-freg-use)
         else : error("Unreachable")

      ;Increment register use for used
      for u in used do :
         if u typeof Var :
            val u = u as Var
            if not proj-loaded?(n(u)) :
               proj-loaded[n(u)] = true
               inc-reg-use(1, tt[n(u)])

      ;Decrement register use for released
      for r in released do :
         if proj-loaded?(r) :
            proj-loaded[r] = false
            inc-reg-use(-1, tt[r])

      ;Increment register use for defined
      for d in defined do :
         inc-reg-use(1, tt[n(d)])

      ;Return number of spills needed of each type
      val num-spills = max(0, peak-reg-use - num-free-reg)
      val num-fspills = max(0, peak-freg-use - num-free-freg)
      [num-spills, num-fspills]

   val ut = usage-table(b)
   defn spill (p:Pos, nr:Int, nf:Int) :
      if (nr > 1) or (nf > 1) :
         ;Get the currently loaded variables ordered by
         ;distance to usage (farthest first).
         val vs = order-by-usage(ut, currently-loaded(), p)

         ;Track the number of each type to spill
         var num-r = nr
         var num-f = nf
         var total = nr + nf

         ;Spill until we've spilled the total number
         while total > 0 :
            val v = next(vs)
            if tgt-int?(tt[v]) and num-r > 0 :
               save(v)
               unload(v)
               num-r = num-r - 1
               total = total - 1
            else if tgt-float?(tt[v]) and num-f > 0 :
               save(v)
               unload(v)
               num-f = num-f - 1
               total = total - 1

   defn spill-overcommitted (p:Pos) :
      val nr = max(0, neg(num-free-reg))
      val nf = max(0, neg(num-free-freg))
      spill(p, nr, nf)

   ;     Layer 3
   ;     -------
   ;Define incoming ports
   define(in(b))
   spill-overcommitted(Pos(0, false))

   ;Iterate through block instructions
   val rt = release-table(b)
   for (e in ins(b), i in 0 to false) do :
      match(e) :
         (e:Set) :
            val rs = rt[Pos(i,false), Pos(i,true)]
            val [nr,nf] = num-spills-required(List(), rs, list(x(e)))
            spill(Pos(i,false), nr, nf)
            kill(rs)
            define(x(e))
            emit(e)
         (e:Op) :
            val rs = rt[Pos(i,false), Pos(i,true)]
            val [nr,nf] = num-spills-required(ys(e), rs, xs(e))
            spill(Pos(i,false), nr, nf)
            load(ys(e))
            kill(rs)
            define(xs(e))
            emit(e)
         (e:Branch) :
            val rs = rt[Pos(i,false), Pos(i,true)]
            val [nr,nf] = num-spills-required(xs(e), rs, List())
            spill(Pos(i,false), nr, nf)
            load(xs(e))
            kill(rs)
            emit(e)
         (e:Return) :
            kill(rt[Pos(i,false), Pos(i,true)])
            emit(e)
         (e:Save) :
            kill(rt[Pos(i,false), Pos(i,true)])
            save(x(e))
         (e:WArgs) :
            kill(rt[Pos(i,false), Pos(i,true)])
            emit(e)
            define(xs(e))
            spill-overcommitted(Pos(i + 1, false))
         (e:WCall) :
            kill(rt[Pos(i,false), Pos(i,true)])
            emit(e)
            define(xs(e))
            spill-overcommitted(Pos(i + 1, false))
      kill(rt[Pos(i,true), Pos(i + 1,false)])

   ;Read state of outgoing ports
   val out* = for x in out(b) map :
      LivePort(n(x), saved[n(x)], loaded[n(x)], loc(x))

   ;Return result
   WBlock(n(b), output, next(b),
          in(b), out*, dist(b))



;                    Assumption Propagation
;                    ======================

definterface Assumption
defstruct Accept <: Assumption
defstruct Assume <: Assumption : (value: True|False|Any)

defn propagate-assumptions (b:WBlock) :
   val save-assumptions = HashTable<Int, Assumption>({_})
   val load-assumptions = HashTable<Int, Assumption>({_})
   val output = Vector<Ins>()

   defn emit (i:Ins) :
      add(output, i)

   defn define-port (x:Port) :
      match(x) :
         (x:LivePort) :
            load-assumptions[n(x)] = match(loaded?(x)) :
               (l:Any) : Accept()
               (l:True|False) : Assume(l)
            save-assumptions[n(x)] = match(saved?(x)) :
               (s:Any) : Accept()
               (s:True|False) : Assume(s)            
         (x:DeadPort) :
            false

   defn assumed-port (x:Port) :
      defn get-value (x:Assumption) :
         match(x) :
            (x:Assume) : value(x)
            (x:Accept) : Any()
      match(x) :
         (x:LivePort) :
            LivePort(n(x),
                     get-value(save-assumptions[n(x)]),
                     get-value(load-assumptions[n(x)]),
                     loc(x))
         (x:DeadPort) :
            x

   ;Define all incoming ports
   do(define-port, in(b))

   ;Process assumptions on each instruction
   val instructions = to-stream(ins(b))
   defn* loop (process-assumptions: () -> False) :
      if more?(instructions) :
         val e = next(instructions)

         defn fill-ports (f: List<Port> -> Ins, xs:List<Port>) :
            val i = length(output)
            emit(e) ;Placeholder
            process-assumptions()
            clear(save-assumptions)
            clear(load-assumptions)
            do(define-port, xs)
            loop $ fn* () :
               output[i] = f(map(assumed-port, xs))

         match(e) :
            (e:Save) :            
               val x = n(x(e))
               match(get?(save-assumptions, x, false)) :
                  (a:Accept) : save-assumptions[x] = Assume(true)
                  (a:Assume|False) : emit(Save(Var(x)))
               loop(process-assumptions)
            (e:Load) :
               val x = n(x(e))
               match(get?(load-assumptions, x, false)) :
                  (a:Accept) : load-assumptions[x] = Assume(true)
                  (a:Assume|False) : emit(Load(Var(x)))
               loop(process-assumptions)
            (e:Unload) :
               val x = n(x(e))
               match(get?(load-assumptions, x, false)) :
                  (a:Accept) : load-assumptions[x] = Assume(false)
                  (a:Assume|False) : false
               loop(process-assumptions)
            (e:WArgs) :
               for xs* in xs(e) fill-ports :
                  WArgs(xs*)
            (e:WCall) :
               for xs* in xs(e) fill-ports :
                  WCall(arity(e), xs*, f(e), ys(e), tail?(e))
            (e) :
               for vx in e do-defined :
                  val x = n(vx)
                  if get?(load-assumptions, x, false) typeof Accept :
                     load-assumptions[x] = Assume(Any())
                  if get?(save-assumptions, x, false) typeof Accept :
                     save-assumptions[x] = Assume(Any())
               emit(e)
               loop(process-assumptions)
      else :
         process-assumptions()

   ;Read out the assumptions on input ports
   var in*
   loop $ fn* () :
      in* = for x in in(b) map :
         assumed-port(x) as LivePort

   ;Return result
   WBlock(n(b), output, next(b),
          in*, out(b), dist(b))


;                      Register Assignment
;                      ===================

;     Assignment Mini-Language
;     ------------------------
defstruct FreeReg <: Loc :
   type: tgt-TgtType
   prefer: List<Int>
   prefer-not: List<Int>

defn FreeReg (t:tgt-TgtType, p:List<Int>) : FreeReg(t, p, List())
defn FreeReg (t:tgt-TgtType) : FreeReg(t, List(), List())

defmethod print (o:OutputStream, f:FreeReg) :
   print(o, "FreeReg(~, ~@ not ~@)" << [type(f), cms(prefer(f)), cms(prefer-not(f))])

;     Algorithm
;     ---------
defn register-assignment (tt:HashTable<Int,tgt-TgtType>, b:WBlock, ports-in:List<LivePort>) :
   ;     Algorithm State
   ;     ---------------
   val locs = HashTable<Int,Loc>({_})
   val reg-slots = Array<False|Int>(8, false)
   val freg-slots = Array<False|Int>(8, false)
   val rt = release-table(b)

   ;     Utilities
   ;     ---------
   ;Convert list of liveports to a table of locations
   defn ports-to-table (ports:List<LivePort>) :
      make-table(ports, n, loc, {_})

   ;Retrieve all the liveports in the given list
   defn liveports (ports:List<Port>) :
      val ports* = to-list $
         for p in ports filter :
            p typeof LivePort
      ports* as List<LivePort>

   ;Retrieve all Vars in given immediates
   defn vars-in (xs:Streamable<Imm>) :
      {_ as Stream<Var>} $
         for x in xs filter :
            x typeof Var

   ;Retrieve all Registers in given immediates
   defn regs-in (xs:List<Imm>) -> List<Int> :
      val locs = stream(loc, vars-in(xs))
      val regs = filter({_ typeof Reg|FReg}, locs)
      to-list(stream(n, regs as Stream<Reg|FReg>))

   ;Classify types
   defn int? (t:tgt-TgtType) :
      contains?([tgt-BYTE-TYPE, tgt-INT-TYPE, tgt-LONG-TYPE, tgt-REF-TYPE], t)
   defn float? (t:tgt-TgtType) :
      contains?([tgt-FLOAT-TYPE, tgt-DOUBLE-TYPE], t)

   ;Get the type of a given variable or port
   defn var-type (v:Var|Port) : tt[n(v)]

   ;Get register slot array for the given type
   defn slots (t:tgt-TgtType) :
      if int?(t) : reg-slots
      else if float?(t) : freg-slots
      else : error("Unreachable")

   ;Create the appropriate register
   defn XReg (t:tgt-TgtType, i:Int) :
      if int?(t) : Reg(i)
      else if float?(t) : FReg(i)
      else : error("Unreachable")

   ;     Output State
   ;     ------------
   val accum = Vector<Ins>()
   defn emit (i:Ins) :
      add(accum, i)

   ;     State Updaters
   ;     --------------
   defn assign (x:Int, l:Loc) :
      defn next-free-reg (t:tgt-TgtType, pref:List<Int>, npref:List<Int>) :
         label<Reg|FReg> return :
            ;First determine which slot array is applicable
            val slots = slots(t)
            ;First try preferred registers
            for r in pref do :
               if not contains?(npref, r) :
                  return(XReg(t,r)) when slots[r] == false
            ;Otherwise search for free register
            val i = index-of(slots, false) as Int
            XReg(t,i)

      match(l) :
         (l:FreeReg) :
            val r = next-free-reg(type(l), prefer(l), prefer-not(l))
            assign(x, r)
         (l:Stack) :
            locs[x] = l
         (l:Reg) :
            locs[x] = l
            reg-slots[n(l)] = x
         (l:FReg) :
            locs[x] = l
            freg-slots[n(l)] = x

   defn assign (xs:List<Int>, ls:List<Loc>) :
      ;First assign stacks and regs
      for (x in xs, l in ls) do :
         assign(x, l) when l typeof Stack|Reg|FReg
      ;Next assign free registers
      for (x in xs, l in ls) do :
         assign(x, l) when l typeof FreeReg

   ;Convenience
   defn assign (x:Var, l:Loc) :
      assign(n(x), l)
   defn assign (xs:List<Var>, ls:List<Loc>) :
      assign(map(n, xs), ls)
   defn assign (xs:List<LivePort>, ls:List<Loc>) :
      assign(map(n, xs), ls)

   ;Update state by freeing the given variable
   defn free (x:Int) :
      match(locs[x]) :
         (loc:Reg) :
            reg-slots[n(loc)] = false
            locs[x] = Stack(x)
         (loc:FReg) :
            freg-slots[n(loc)] = false
            locs[x] = Stack(x)
         (loc) : false

   defn free (xs:Streamable<Int>) :
      do(free, xs)

   ;     State Reader
   ;     ------------
   ;Fill the given immediate with its location
   defn fill<?T> (x:?T&Imm) :
      {_ as T&Imm} $ match(x) :
         (x:Var) : Var(n(x), locs[n(x)])
         (x:Val) : x
   defn fill<?T> (xs:List<?T&Imm>) -> List<T> :
      map(fill, xs)

   ;Fill the given port with its location
   defn fill<?T> (x:?T&Port) :
      {_ as T&Port} $ match(x) :
         (x:LivePort) :
            val sv = match(saved?(x)) :
               (sv:True) : sv
               (sv:False|Any) : false
            val loc = locs[n(x)]
            val ld = loc typeof Reg|FReg
            LivePort(n(x), sv, ld, loc)
         (x:DeadPort) : x
   defn fill<?T> (xs:List<?T&Port>) -> List<T> :
      map(fill, xs)

   ;     Swap Helpers
   ;     ------------
   ;Find a register that is either free, or one of the given registers
   ;and is not vetoed.
   defn swap-reg (t:tgt-TgtType, free:List<Int>, veto:List<Int>) :
      label<Int> return :
         ;Get the appropriate slots array
         val slots = slots(t)
         ;Try to find a free register
         val i = for i in 0 to length(reg-slots) find :
            (not contains?(veto, i)) and
            slots[i] == false
         return(i as Int) when i typeof Int
         ;Find one of the given registers
         for i in 0 to length(slots) find! :
            (not contains?(veto, i)) and
            contains?(free, slots[i])

   ;Swap the two register contents
   defn swap (t:tgt-TgtType, src:Int, dst:Int) :
      val slots = slots(t)
      if slots[dst] == false :
         val x = slots[src] as Int
         emit(Set(Var(x, XReg(t,dst)), Var(x, XReg(t,src))))
         free(x)
         assign(x, XReg(t,dst))
      else :
         val x = slots[src] as Int
         val y = slots[dst] as Int
         val swap = for i in 0 to length(slots) search :
            if (i != src) and (i != dst) and (slots[i] == false) :
               XReg(t,i)
         emit(Xchg(Var(x, XReg(t,src)), Var(y, XReg(t,dst)), swap))
         free(x)
         free(y)
         assign(x, XReg(t,dst))
         assign(y, XReg(t,src))

   ;Ensure that the following registers are free after release
   defn ensure-free (t:tgt-TgtType, reg:List<Int>, rs:List<Int>) :
      val slots = slots(t)
      defn* loop (reg:List<Int>, veto:List<Int>) :
         if not empty?(reg) :
            val r = head(reg)
            if (slots[r] != false) and not contains?(rs, slots[r]) :
               swap(t, r, swap-reg(t, rs, veto))
            loop(tail(reg), List(r, veto))
      loop(reg, List())

   ;Ensure that the following value is in a certain register
   defn ensure-reg (t:tgt-TgtType, x:Int, r:Int) :
      val src = n(locs[x] as Reg|FReg)
      swap(t, src, r) when src != r

   ;     Algorithm
   ;     ---------
   ;Helper: Desired assigned port locations
   defn port-locations (xs:List<Port>) :
      for x in xs map :
         match(x) :
            (x:LivePort) :
               match(loaded?(x)) :
                  (l:True|Any) : FreeReg()
                  (l:False) : Stack(n(x))
            (x:DeadPort) :
               NoLoc()            

   ;Assign initial registers   
   val in* = let :
      val pt = make-table(ports-in, n, loc, {_})
      val locs = for x in in(b) map :
         match(loaded?(x), pt[n(x)]) :
            (ld:True, loc:Reg|FReg) : loc
            (ld:True, loc:Stack) : FreeReg()
            (ld:False, loc) : Stack(n(x))
            (ld:Any, loc) : loc
      assign(in(b), locs)
      fill(in(b))

   ;Assign concrete locations
   for (e in ins(b), i in 0 to false) do :
      ;Helper:
      defn assign-result-loc (x: Var, y:Imm
                              loc: Imm -> Loc,
                              Ins: (Var, Imm) -> Ins) :
         val y* = fill(y)
         free(rt[Pos(i,false), Pos(i,true)])
         assign(x, loc(y*))
         emit(Ins(fill(x(e)), y*))         
      defn assign-result-loc (x: Var, y:List<Imm>
                              loc: List<Imm> -> Loc,
                              Ins: (Var, List<Imm>) -> Ins) :
         val y* = fill(y)
         free(rt[Pos(i,false), Pos(i,true)])
         assign(x, loc(y*))
         emit(Ins(fill(x(e)), y*))         
      defn assign-result-loc (x: List<Var>, y:List<Imm>
                              loc: List<Imm> -> List<Loc>,
                              Ins: (List<Var>, List<Imm>) -> Ins) :
         val y* = fill(y)
         free(rt[Pos(i,false), Pos(i,true)])
         assign(x, loc(y*))
         emit(Ins(fill(x(e)), y*))

      match(e) :
         (e:Set) :
            assign-result-loc(x(e), y(e),
               FreeReg{regs-in(_)}, Set)
         (e:Op) :
            match(op(e)) :
               (opc:CmpOp|LoadOp|StoreOp|AddrOp|ConvOp) :
                  assign-result-loc(xs(e), ys(e),
                     map{FreeReg(), _},
                     Op{op(opc), _, _})
               (opc:ComOp) :
                  assign-result-loc(head(xs(e)), ys(e),
                     FreeReg{regs-in(_)},
                     Op{op(opc), list(_), _})
               (opc:NComOp) :
                  assign-result-loc(head(xs(e)), ys(e),
                     FreeReg{regs-in(head(_))},
                     Op{op(opc), list(_), _})
               (opc:DivOp) :
                  ensure-free-reg(list(0))
                  assign-result-loc(head(xs(e)), ys(e),
                     Reg{0},
                     Op{op(opc), list(_), _})
               (opc:ShfOp) :
                  val z = ys(e)[1]
                  ensure-reg(z, 2) when z typeof Var
                  assign-result-loc(head(xs(e)), ys(e),
                     FreeReg{regs-in(head(_))},
                     Op{op(opc), list(_), _})
         (e:Branch) :
            emit(Branch(op(e), fill(xs(e))))
            free(rt[Pos(i,false), Pos(i,true)])
         (e:Return) :
            emit(Return(fill(xs(e))))
            free(rt[Pos(i,false), Pos(i,true)])
         (e:Save) :
            emit(Save(fill(x(e))))
            free(rt[Pos(i,false), Pos(i,true)])
         (e:Load) :
            free(rt[Pos(i,false), Pos(i,true)])
            assign(x(e), FreeReg())
            emit(Load(fill(x(e))))
         (e:WArgs) :
            free(rt[Pos(i,false), Pos(i,true)])
            assign(xs(e), port-locations(xs(e)))
            emit(WArgs(fill(xs(e))))
         (e:WCall) :
            val f* = fill(f(e))
            val ys* = fill(ys(e))
            free(rt[Pos(i,false), Pos(i,true)])
            assign(xs(e), port-locations(xs(e)))
            emit(WCall(arity(e), fill(xs(e)), f*, ys*, tail?(e)))

      ;Free any unused defines
      free(rt[Pos(i,true), Pos(i,false)])

   ;Output locations
   val out* = fill(out(b))

   ;Return result
   WBlock(n(b), accum, next(b),
          in*, out*, dist(b))
          



;;                      Register Assignment
;;                      ===================
;
;;     Assignment Mini-Language
;;     ------------------------
;defstruct FreeReg <: Loc :
;   type: tgt-TgtType
;   prefer: List<Int>
;   prefer-not: List<Int>
;
;defn FreeReg (t:tgt-TgtType, p:List<Int>) : FreeReg(t, p, List())
;defn FreeReg (t:tgt-TgtType) : FreeReg(t, List(), List())
;
;defmethod print (o:OutputStream, f:FreeReg) :
;   print(o, "FreeReg(~, ~@ not ~@)" << [type(f), cms(prefer(f)), cms(prefer-not(f))])
;
;;     Algorithm
;;     ---------
;defn register-assignment (tt:HashTable<Int,tgt-TgtType>, b:WBlock, ports-in:List<LivePort>) :
;   ;     Algorithm State
;   ;     ---------------
;   val locs = HashTable<Int,Loc>({_})
;   val reg-slots = Array<False|Int>(8, false)
;   val freg-slots = Array<False|Int>(8, false)
;   val rt = release-table(b)
;
;   ;     Utilities
;   ;     ---------
;   ;Convert list of liveports to a table of locations
;   defn ports-to-table (ports:List<LivePort>) :
;      make-table(ports, n, loc, {_})
;
;   ;Retrieve all the liveports in the given list
;   defn liveports (ports:List<Port>) :
;      val ports* = to-list $
;         for p in ports filter :
;            p typeof LivePort
;      ports* as List<LivePort>
;
;   ;Retrieve all Vars in given immediates
;   defn vars-in (xs:Streamable<Imm>) :
;      {_ as Stream<Var>} $
;         for x in xs filter :
;            x typeof Var
;
;   ;Retrieve all Registers in given immediates
;   defn regs-in (xs:List<Imm>) -> List<Int> :
;      val locs = stream(loc, vars-in(xs))
;      val regs = filter({_ typeof Reg|FReg}, locs)
;      to-list(stream(n, regs as Stream<Reg|FReg>))
;
;   ;Classify types
;   defn int? (t:tgt-TgtType) :
;      contains?([tgt-BYTE-TYPE, tgt-INT-TYPE, tgt-LONG-TYPE, tgt-REF-TYPE], t)
;   defn float? (t:tgt-TgtType) :
;      contains?([tgt-FLOAT-TYPE, tgt-DOUBLE-TYPE], t)
;
;   ;Get the type of a given variable or port
;   defn var-type (v:Var|Port) : tt[n(v)]
;
;   ;Get register slot array for the given type
;   defn slots (t:tgt-TgtType) :
;      if int?(t) : reg-slots
;      else if float?(t) : freg-slots
;      else : error("Unreachable")
;
;   ;Create the appropriate register
;   defn XReg (t:tgt-TgtType, i:Int) :
;      if int?(t) : Reg(i)
;      else if float?(t) : FReg(i)
;      else : error("Unreachable")
;
;   ;     Output State
;   ;     ------------
;   val accum = Vector<Ins>()
;   defn emit (i:Ins) :
;      add(accum, i)
;
;   ;     State Updaters
;   ;     --------------
;   defn assign (x:Int, l:Loc) :
;      defn next-free-reg (t:tgt-TgtType, pref:List<Int>, npref:List<Int>) :
;         label<Reg|FReg> return :
;            ;First determine which slot array is applicable
;            val slots = slots(t)
;            ;First try preferred registers
;            for r in pref do :
;               if not contains?(npref, r) :
;                  return(XReg(t,r)) when slots[r] == false
;            ;Otherwise search for free register
;            val i = index-of(slots, false) as Int
;            XReg(t,i)
;
;      match(l) :
;         (l:FreeReg) :
;            val r = next-free-reg(type(l), prefer(l), prefer-not(l))
;            assign(x, r)
;         (l:Stack) :
;            locs[x] = l
;         (l:Reg) :
;            locs[x] = l
;            reg-slots[n(l)] = x
;         (l:FReg) :
;            locs[x] = l
;            freg-slots[n(l)] = x
;
;   defn assign (xs:List<Int>, ls:List<Loc>) :
;      ;First assign stacks and regs
;      for (x in xs, l in ls) do :
;         assign(x, l) when l typeof Stack|Reg|FReg
;      ;Next assign free registers
;      for (x in xs, l in ls) do :
;         assign(x, l) when l typeof FreeReg
;
;   ;Convenience
;   defn assign (x:Var, l:Loc) :
;      assign(n(x), l)
;   defn assign (xs:List<Var>, ls:List<Loc>) :
;      assign(map(n, xs), ls)
;   defn assign (xs:List<LivePort>, ls:List<Loc>) :
;      assign(map(n, xs), ls)
;
;   ;Update state by freeing the given variable
;   defn free (x:Int) :
;      match(locs[x]) :
;         (loc:Reg) :
;            reg-slots[n(loc)] = false
;            locs[x] = Stack(x)
;         (loc:FReg) :
;            freg-slots[n(loc)] = false
;            locs[x] = Stack(x)
;         (loc) : false
;
;   defn free (xs:Streamable<Int>) :
;      do(free, xs)
;
;   ;     State Reader
;   ;     ------------
;   ;Fill the given immediate with its location
;   defn fill<?T> (x:?T&Imm) :
;      {_ as T&Imm} $ match(x) :
;         (x:Var) : Var(n(x), locs[n(x)])
;         (x:Val) : x
;   defn fill<?T> (xs:List<?T&Imm>) -> List<T> :
;      map(fill, xs)
;
;   ;Fill the given port with its location
;   defn fill<?T> (x:?T&Port) :
;      {_ as T&Port} $ match(x) :
;         (x:LivePort) :
;            val sv = match(saved?(x)) :
;               (sv:True) : sv
;               (sv:False|Any) : false
;            val loc = locs[n(x)]
;            val ld = loc typeof Reg|FReg
;            LivePort(n(x), sv, ld, loc)
;         (x:DeadPort) : x
;   defn fill<?T> (xs:List<?T&Port>) -> List<T> :
;      map(fill, xs)
;
;   ;     Swap Helpers
;   ;     ------------
;   ;Find a register that is either free, or one of the given registers
;   ;and is not vetoed.
;   defn swap-reg (t:tgt-TgtType, free:List<Int>, veto:List<Int>) :
;      label<Int> return :
;         ;Get the appropriate slots array
;         val slots = slots(t)
;         ;Try to find a free register
;         val i = for i in 0 to length(reg-slots) find :
;            (not contains?(veto, i)) and
;            slots[i] == false
;         return(i as Int) when i typeof Int
;         ;Find one of the given registers
;         for i in 0 to length(slots) find! :
;            (not contains?(veto, i)) and
;            contains?(free, slots[i])
;
;   ;Swap the two register contents
;   defn swap (t:tgt-TgtType, src:Int, dst:Int) :
;      val slots = slots(t)
;      if slots[dst] == false :
;         val x = slots[src] as Int
;         emit(Set(Var(x, XReg(t,dst)), Var(x, XReg(t,src))))
;         free(x)
;         assign(x, XReg(t,dst))
;      else :
;         val x = slots[src] as Int
;         val y = slots[dst] as Int
;         val swap = for i in 0 to length(slots) search :
;            if (i != src) and (i != dst) and (slots[i] == false) :
;               XReg(t,i)
;         emit(Xchg(Var(x, XReg(t,src)), Var(y, XReg(t,dst)), swap))
;         free(x)
;         free(y)
;         assign(x, XReg(t,dst))
;         assign(y, XReg(t,src))
;
;   ;Ensure that the following registers are free after release
;   defn ensure-free (t:tgt-TgtType, reg:List<Int>, rs:List<Int>) :
;      val slots = slots(t)
;      defn* loop (reg:List<Int>, veto:List<Int>) :
;         if not empty?(reg) :
;            val r = head(reg)
;            if (slots[r] != false) and not contains?(rs, slots[r]) :
;               swap(t, r, swap-reg(t, rs, veto))
;            loop(tail(reg), List(r, veto))
;      loop(reg, List())
;
;   ;Ensure that the following value is in a certain register
;   defn ensure-reg (t:tgt-TgtType, x:Int, r:Int) :
;      val src = n(locs[x] as Reg|FReg)
;      swap(t, src, r) when src != r
;
;   ;     Analysis
;   ;     --------
;
;   ;Assign initial registers
;   val in* = let :
;      val pt = ports-to-table(ports-in)
;      val locs = for x in in(b) map :
;         match(loaded?(x), pt[n(x)]) :
;            (ld:True, loc:Reg|FReg) : loc
;            (ld:True, loc:Stack) : FreeReg(tt[n(x)])
;            (ld:False, loc) : Stack(n(x))
;            (ld:Any, loc) : loc
;      assign(in(b), locs)
;      fill(in(b))
;
;   ;Assign concrete locations
;   for (e in ins(b), i in 0 to false) do :
;      free(releases-up-to(rt, Pos(i, false)))
;      match(e) :
;         (e:Set) :
;            val y* = fill(y(e))
;            free(releases-up-to(rt, Pos(i, true)))
;            assign(x(e), FreeReg(var-type(x(e)), regs-in(list(y*))))
;            emit(Set(fill(x(e)), y*))
;         (e:Op) :
;            ;Implement different rules depending on operation type
;            val ys* = match(op(e)) :
;               (op:ComOp) :
;                  val x = head(xs(e))
;                  val ys* = fill(ys(e))
;                  free(releases-up-to(rt, Pos(i, true)))
;                  assign(x, FreeReg(var-type(x), regs-in(ys*)))
;                  ys*
;               (op:CmpOp|LoadOp|StoreOp|AddrOp|ConvOp) :
;                  val ys* = fill(ys(e))
;                  free(releases-up-to(rt, Pos(i, true)))
;                  val fr = FreeReg(var-type(xs(e)[0]))
;                  assign(xs(e), map({fr}, xs(e)))
;                  ys*
;               (op:NComOp) :
;                  val x = head(xs(e))
;                  val ys* = fill(ys(e))
;                  free(releases-up-to(rt, Pos(i, true)))
;                  assign(x, FreeReg(var-type(x),
;                                    regs-in(list(ys*[0]))))
;                  ys*
;               (op:DivOp) :
;                  val rs = to-list(releases-up-to(rt, Pos(i, true)))
;                  ensure-free(tgt-BYTE-TYPE, list(0), rs)
;                  val x = head(xs(e))
;                  val ys* = fill(ys(e))
;                  free(rs)
;                  assign(x, Reg(0))
;                  ys*
;               (op:ShfOp) :
;                  val [x, y, z] = [xs(e)[0], ys(e)[0], ys(e)[1]]
;                  val t = var-type(x)
;                  if z typeof Var :
;                     ensure-reg(t, n(z as Var), 2)
;                  val [y*, z*] = [fill(y), fill(z)]
;                  free(releases-up-to(rt, Pos(i, true)))
;                  assign(x, FreeReg(t, regs-in(list(y*))))
;                  list(y*, z*)
;               (op:DivModOp) :
;                  val rs = to-list(releases-up-to(rt, Pos(i, true)))
;                  ensure-free(tgt-LONG-TYPE, list(0,3), rs)
;                  val ys* = fill(ys(e))
;                  free(rs)
;                  assign(xs(e), list(Reg(0), Reg(3)))
;                  ys*
;            emit(Op(op(e), fill(xs(e)), ys*))
;         (e:Branch) :
;            emit(Branch(op(e), fill(xs(e))))
;         (e:Return) :
;            emit(Return(fill(xs(e))))
;         (e:Save) :
;            emit(Save(fill(x(e))))
;         (e:Load) :
;            assign(list(x(e)), list(FreeReg(var-type(x(e)))))
;            emit(Load(fill(x(e))))
;         (e:WArgs) :
;            val lxs = liveports(xs(e))
;            val locs = for x in lxs map :
;               match(loaded?(x)) :
;                  (l:True|Any) : FreeReg(tt[n(x)])
;                  (l:False) : Stack(n(x))
;            assign(lxs, locs)
;            emit(WArgs(fill(xs(e))))
;         (e:WCall) :
;            val f* = fill(f(e))
;            val ys* = fill(ys(e))
;            free(releases-up-to(rt, Pos(i, true)))
;            val lxs = liveports(xs(e))
;            val locs = for x in lxs map :
;               match(loaded?(x)) :
;                  (l:True|Any) : FreeReg(var-type(x))
;                  (l:False) : Stack(n(x))
;            assign(lxs, locs)
;            emit(WCall(arity(e), fill(xs(e)), f*, ys*, tail?(e)))
;
;   ;Output locations
;   val out* = fill(out(b))
;
;   ;     Return result
;   ;     -------------
;   WBlock(n(b), accum, next(b),
;          in*, out*, dist(b))


;defn register-assignment (tt:HashTable<Int,tgt-TgtType>, p:Unit) :
;   ;     Algorithm State
;   ;     ---------------
;   val block-table = HashTable<Int,False|WBlock>({_})
;   val blocks* = Vector<Block>()
;
;   ;     Algorithm
;   ;     ------------------
;   ;Initially fill table
;   for b in blocks(p) do :
;      block-table[n(b)] = b as WBlock
;
;   ;Assign registers to the given block
;   defn assign-regs (b:WBlock, ports-in:List<LivePort>) :
;      val b* = register-assignment(tt, b, ports-in)
;      add(blocks*, b*)
;      block-table[n(b*)] = false
;      b*
;
;   ;Assign registers to successors
;   defn* assign-successors (b:WBlock) :
;      for n in next(b) do :
;         match(block-table[n]) :
;            (s:WBlock) : assign-successors(assign-regs(s, out(b)))
;            (s:False) : false
;
;   ;Driver
;   val b0 = blocks(p)[0] as WBlock
;   val b0* = assign-regs(b0, List())
;   assign-successors(b0*)
;   Unit(defs(p), blocks*)
;
;
;
;
;;                   Register Assignment Verification
;;                   ================================
;
;defn verify-register-assignment (b:WBlock) :
;   ;     Algorithm State
;   ;     ---------------
;   val regs = Array<False|Int>(8, false)
;   val fregs = Array<False|Int>(8, false)
;   val saved = HashTable<Int,True|False>({_})
;
;   ;     State Updaters
;   ;     --------------
;   defn get-reg (r:Reg|FReg) :
;      match(r) :
;         (r:Reg) : regs[n(r)]
;         (r:FReg) : fregs[n(r)]
;
;   defn set-reg (r:Reg|FReg, v:Int|False) :
;      match(r) :
;         (r:Reg) : regs[n(r)] = v
;         (r:FReg) : fregs[n(r)] = v
;
;   defn define (x:Port) :
;      match(x) :
;         (x:LivePort) :
;            match(saved?(x), loaded?(x), loc(x)) :
;               (sv:True, ld:True, loc:FReg|Reg) :
;                  set-reg(loc, n(x))
;                  saved[n(x)] = true
;               (sv:False, ld:True, loc:FReg|Reg) :
;                  set-reg(loc, n(x))
;                  saved[n(x)] = false
;               (sv:True, ld:False, loc:Stack) :
;                  saved[n(x)] = true
;         (x:DeadPort) :
;            false
;
;   defn define (x:Var) :
;      val r = loc(x) as FReg|Reg
;      set-reg(r, n(x))
;      saved[n(x)] = false
;
;   defn mov (x:Var, y:Imm) :
;      val r = loc(x) as FReg|Reg
;      set-reg(r, n(x))
;      match(y) :
;         (y:Val) :
;            saved[n(x)] = false
;         (y:Var) :
;            if n(x) != n(y) :
;               saved[n(x)] = false
;
;   defn load (x:Var) :
;      val r = loc(x) as FReg|Reg
;      set-reg(r, n(x))
;
;   defn save (x:Var) :
;      saved[n(x)] = true
;
;   defn clear-registers () :
;      for i in 0 to length(regs) do :
;         regs[i] = false
;      for i in 0 to length(fregs) do :
;         fregs[i] = false
;
;   defn swap-register-contents (x:Reg|FReg, y:Reg|FReg) :
;      val vx = get-reg(x)
;      val vy = get-reg(y)
;      set-reg(x, vy)
;      set-reg(y, vx)
;
;   ;     State Checkers
;   ;     --------------
;   defn reg! (x:Imm) :
;      match(x) :
;         (x:Var) : loc(x) as Reg|FReg
;         (x:Val) : false
;   defn saved! (x:Int) : saved[x] as True
;   defn saved! (x:Var) : saved!(n(x))
;   defn not-saved! (x:Int) : saved[x] as False
;   defn holds! (r:FReg|Reg, x:Int) : (get-reg(r) == x) as True
;   defn holds! (r:FReg|Reg, x:Var) : holds!(r, n(x))
;
;   defn check! (p:Port) :
;      match(p) :
;         (p:LivePort) :
;            match(saved?(p), loaded?(p), loc(p)) :
;               (sv:True, ld:True, lc:FReg|Reg) :
;                  holds!(lc, n(p))
;                  saved!(n(p))
;               (sv:False, ld:True, lc:FReg|Reg) :
;                  holds!(lc, n(p))
;                  not-saved!(n(p))
;               (sv:True, ld:False, lc:Stack) :
;                  saved!(n(p))
;         (p:DeadPort) :
;            false
;
;   defn check! (x:Imm) :
;      match(x) :
;         (x:Var) :
;            match(loc(x)) :
;               (l:FReg|Reg) : holds!(l, n(x))
;               (l:Stack) : saved!(n(x))
;         (x:Val) : false
;
;   ;     Algorithm
;   ;     ---------
;
;   ;Input ports
;   do(define, in(b))
;
;   ;Check each instruction
;   for e in ins(b) do :
;      match(e) :
;         (e:Set) :
;            check!(y(e))
;            reg!(x(e))
;            mov(x(e), y(e))
;         (e:Xchg) :
;            check!(x(e))
;            check!(y(e))
;            val rx = loc(x(e)) as FReg|Reg
;            val ry = loc(y(e)) as FReg|Reg
;            swap-register-contents(rx, ry)
;         (e:Op) :
;            for y in ys(e) do : (check!(y), reg!(y))
;            for x in xs(e) do : (reg!(x), define(x))
;         (e:Branch) :
;            for x in xs(e) do : (check!(x), reg!(x))
;         (e:Return) :
;            do(check!, xs(e))
;         (e:Save) :
;            check!(x(e))
;            save(x(e))
;         (e:Load) :
;            saved!(x(e))
;            load(x(e))
;         (e:WArgs) :
;            do(define, xs(e))
;         (e:WCall) :
;            do(check!, ys(e))
;            check!(f(e))
;            clear-registers()
;            do(define, xs(e))
;
;   ;Output ports
;   do(check!, out(b))
;
;
;
;;                    Stack Map Calculation
;;                    =====================
;
;;     Interval Structure
;;     ------------------
;definterface Interval
;defstruct StartInterval <: Interval :
;   n: Int
;defstruct EndInterval <: Interval :
;   n: Int
;
;defmethod print (o:OutputStream, i:Interval) :
;   print{o, _} $ match(i) :
;      (i:StartInterval) : "Start(~)" << [n(i)]
;      (i:EndInterval) : "End(~)" << [n(i)]
;
;
;;     Calculating Stack Intervals
;;     ---------------------------
;defn stack-intervals (p:Unit) :
;   ;     Algorithm State
;   ;     ---------------
;   val var-start = HashTable<Int,Int>({_})
;   val var-end = HashTable<Int,Int>({_})
;
;   defn note-usage (x:Int, i:Int) :
;      if key?(var-start, x) :
;         var-start[x] = min(i, var-start[x])
;         var-end[x] = max(i, var-end[x])
;      else :
;         var-start[x] = i
;         var-end[x] = i
;
;   ;     Usages in Various Items
;   ;     -----------------------
;   defn note-usage (x:Imm|Port, i:Int) :
;      match(x) :
;         (x:LivePort) :
;            if saved?(x) == true :
;               note-usage(n(x), i)
;         (x:Var) :
;            match(loc(x)) :
;               (l:Stack) : note-usage(n(x), i)
;               (l) : false
;         (x) : false
;
;   defn note-usage (xs:List<Imm|Port>, i:Int) :
;      for x in xs do :
;         note-usage(x, i)
;
;   defn note-usage (e:Ins, i:Int) :
;      match(e) :
;         (e:Set) : note-usage(y(e), i)
;         (e:Xchg) : false
;         (e:Op) : false
;         (e:Branch) : false
;         (e:Return) : note-usage(xs(e), i)
;         (e:Save) : note-usage(n(x(e)), i)
;         (e:Load) : note-usage(n(x(e)), i)
;         (e:WArgs) : note-usage(xs(e), i)
;         (e:WCall) :
;            note-usage(ys(e), i)
;            note-usage(f(e), i)
;            note-usage(xs(e), i)
;
;   ;     Note variable start and end stack usages
;   ;     ----------------------------------------
;   val ins-counter = to-stream(0 to false)
;   for b in reverse-post-order(blocks(p)) as Vector<WBlock> do :
;      note-usage(in(b), next(ins-counter))
;      for e in ins(b) do :
;         note-usage(e, next(ins-counter))
;      note-usage(out(b), next(ins-counter))
;   val num-pos = next(ins-counter)
;
;
;   ;     Sort start and end intervals by position
;   ;     ----------------------------------------
;   val intervals = Array<List<Interval>>(num-pos, List())
;   defn add-interval (i:Int, int:Interval) :
;      intervals[i] = List(int, intervals[i])
;   for e in var-end do :
;      add-interval(value(e), EndInterval(key(e)))
;   for e in var-start do :
;      add-interval(value(e), StartInterval(key(e)))
;   concat-all(intervals)
;
;
;;     Calculating Stack Map
;;     ---------------------
;
;;Interface
;defclass StackMap
;defmulti offset (s:StackMap, x:Stack) -> Int
;defmulti size (s:StackMap) -> Int
;
;;Location Calculation
;defn calculate-stack-map (tt:HashTable<Int,tgt-TgtType>, u:Unit) :
;   ;     Assigning Stack Locations
;   ;     -------------------------
;   val occupied = Vector<False|True>()
;   val types = Vector<tgt-TgtType>()
;   val var-locs = HashTable<Int,Int>({_})
;
;   ;Get the next free location
;   defn next-free-loc (t:tgt-TgtType) :
;      defn exemplar (t:tgt-TgtType) :
;         switch {t == _} :
;            tgt-FLOAT-TYPE : tgt-INT-TYPE
;            tgt-DOUBLE-TYPE : tgt-LONG-TYPE
;            else : t
;      label<Int> return :
;         ;Get exemplar type
;         val t* = exemplar(t)
;         ;Find unoccupied location
;         val n = length(occupied)
;         for i in 0 to n do :
;            if (occupied[i] == false) and types[i] == t* :
;               return(i)
;         ;Or create a new location
;         add(occupied, false)
;         add(types, t*)
;         n
;
;   ;Assign stack locations to variables
;   for i in stack-intervals(u) do :
;      match(i) :
;         (i:StartInterval) :
;            val l = next-free-loc(tt[n(i)])
;            var-locs[n(i)] = l
;            occupied[l] = true
;         (i:EndInterval) :
;            val l = var-locs[n(i)]
;            occupied[l] = false
;
;   ;     Compute Stack Offsets
;   ;     ---------------------
;   ;Pad stack items
;   val items* = let :
;      val items = Vector<Item>()
;      for (t in types, i in 0 to false) do :
;         defn type-size (t:tgt-TgtType) :
;            switch {t == _} :
;               tgt-BYTE-TYPE : 1
;               tgt-INT-TYPE : 4
;               tgt-LONG-TYPE : 8
;               tgt-REF-TYPE : 8
;         add(items, Item(type-size(t), i))
;      sort-by-key!(items, alignment)
;      pad(items, 8)
;
;   ;Compute cumulative offsets
;   var accum = 16
;   val offsets = Array<Int>(length(occupied))
;   for it in items* do :
;      match(it) :
;         (it:Item) :
;            val i = data(it) as Int
;            offsets[i] = accum
;            accum = accum + alignment(it)
;         (it:Padding) :
;            accum = accum + size(it)
;
;   ;     Return table
;   ;     ------------
;   new StackMap :
;      defmethod offset (this, x:Stack) :
;         val i = var-locs[n(x)]
;         offsets[i]
;      defmethod size (this) :
;         accum
;
;
;;                      Block Collapsing
;;                      ================
;
;defn collapse-blocks (u:Unit) :
;   ;     Glue Port Discovery
;   ;     -------------------
;   val glue-entry = HashTable<Int, List<LivePort>>({_})
;   val glue-exit = HashTable<Int, List<LivePort>>({_})
;   val wblocks = blocks(u) as Vector<WBlock>
;   val block-table = make-table(wblocks, n, {_}, {_})
;
;   defn in-ports (n:Int) :
;      in(block-table[n])
;
;   val port-table = HashTable<Int,LivePort>({_})
;   defn reorder (xs:List<LivePort>, ys:List<LivePort>) :
;      clear(port-table)
;      for x in xs do : port-table[n(x)] = x
;      for y in ys map : port-table[n(y)]
;
;   for b in wblocks do :
;      if length(next(b)) == 1 :
;         val nb = head(next(b))
;         glue-exit[n(b)] = reorder(in-ports(nb), out(b))
;      else if length(next(b)) > 1 :
;         for n in next(b) do :
;            glue-entry[n] = reorder(out(b), in-ports(n))
;
;   ;     Instruction Emission
;   ;     --------------------
;   val output = Vector<Ins>()
;   defn emit (i:Ins) :
;      add(output, i)
;
;   defn glue-ports (xs:List<LivePort>, ys:List<LivePort>) :
;      ;Variables needed to glue
;      val xs* = Vector<Var>()
;      val ys* = Vector<Var>()
;
;      for (x in xs, y in ys) do :
;         ;Ensure ports properly reordered
;         (n(x) == n(y)) as True
;         ;Emit any saves required
;         match(loc(x), loc(y), saved?(x)) :
;            (xl:Reg|FReg, yl:Reg|FReg, sv:True) :
;               emit(Save(Var(n(y), yl)))
;            (x, y, sv) : false
;         ;Push onto variables needing glue
;         match(loc(x), loc(y)) :
;            (xl:Stack, yl:Stack) :
;               false
;            (xl, yl) :
;               add(xs*, Var(n(x), xl))
;               add(ys*, Var(n(y), yl))
;
;      emit(Glue(to-list(xs*), to-list(ys*)))
;
;   for (b in wblocks, i in 0 to false) do :
;      ;Check whether block n is upcoming
;      defn upcoming? (b:Int) :
;         if i < length(wblocks) - 1 :
;            val upcoming = n(wblocks[i + 1])
;            upcoming == b
;
;      ;Emit block label
;      emit(Label(n(b)))
;
;      ;Emit entry glue
;      if key?(glue-entry, n(b)) :
;         glue-ports(in(b), glue-entry[n(b)])
;
;      ;Emit instructions
;      defn save-reg-port (x:Port) :
;         match(x) :
;            (x:LivePort) :
;               match(loc(x), saved?(x)) :
;                  (xl:Reg|FReg, sv:True) :
;                     emit(Save(Var(n(x), xl)))
;                  (xl, sv) : false
;            (x:DeadPort) : false
;
;      for e in ins(b) do :
;         match(e) :
;            (e:WArgs) :
;               emit(e)
;               do(save-reg-port, xs(e))
;            (e:WCall) :
;               emit(e)
;               do(save-reg-port, xs(e))
;            (e:Branch) :
;               val conseq = next(b)[0]
;               val alt = next(b)[1]
;               match(upcoming?(conseq), upcoming?(alt)) :
;                  (fc:True, fa:False) :
;                     emit(Break(alt, op(e), xs(e), true))
;                  (fc:False, fa:True) :
;                     emit(Break(conseq, op(e), xs(e), false))
;                  (fc:False, fa:False) :
;                     emit(Break(conseq, op(e), xs(e), false))
;                     emit(Goto(alt))
;            (e) :
;               emit(e)
;
;      ;Emit exit glue
;      if key?(glue-exit, n(b)) :
;         glue-ports(glue-exit[n(b)], out(b))
;
;      ;Emit goto if necessary
;      if length(next(b)) == 1 :
;         val n = head(next(b))
;         emit(Goto(n)) when not upcoming?(n)
;
;   output
;
;
;;                    Compilation to ASM
;;                    ==================
;
;;     Argument Value Language
;;     -----------------------
;definterface AVal
;defmulti type (a:AVal) -> asm-AsmType
;defstruct ArgAV <: AVal :
;   n: Int
;   type: asm-AsmType with: (as-method => true)
;defstruct StackAV <: AVal :
;   offset: Int
;   type: asm-AsmType with: (as-method => true)
;defstruct RegAV <: AVal :
;   n: Int
;   type: asm-AsmType with: (as-method => true)
;defstruct FRegAV <: AVal :
;   n: Int
;   type: asm-AsmType with: (as-method => true)
;defstruct RSPAV <: AVal
;defstruct ImmAV <: AVal :
;   value: Int
;   type: asm-AsmType with: (as-method => true)
;defstruct NoneAV <: AVal :
;   type: asm-AsmType with: (as-method => true)
;defstruct MemAV <: AVal :
;   n: Int
;defstruct Swap <: AVal
;defstruct FSwap <: AVal
;
;defmethod type (x:RSPAV) : asm-LONG-TYPE
;defmethod type (x:MemAV) : asm-LONG-TYPE
;defmethod type (x:Swap) : asm-LONG-TYPE
;defmethod type (x:FSwap) : asm-DOUBLE-TYPE
;
;defn imm! (v:AVal) :
;   match(v) :
;      (v:RSPAV) : asm-RegSP()
;      (v:RegAV) : asm-Reg(n(v))
;      (v:FRegAV) : asm-FReg(n(v))
;      (v:ImmAV) : asm-IntImm(value(v))
;      (v:MemAV) : asm-Mem(n(v))
;
;defn loc! (v:AVal) :
;   imm!(v) as asm-Loc
;
;defmethod print (o:OutputStream, v:AVal) :
;   print{o, _} $ match(v) :
;      (v:ArgAV) : "arg(~,~)" << [n(v), type(v)]
;      (v:StackAV) : "stk(~,~)" << [offset(v), type(v)]
;      (v:RegAV) : "reg(~,~)" << [n(v), type(v)]
;      (v:FRegAV) : "freg(~,~)" << [n(v), type(v)]
;      (v:RSPAV) : "rsp"
;      (v:ImmAV) : "imm(~, ~)" << [value(v), type(v)]
;      (v:NoneAV) : "none(~)" << [type(v)]
;      (v:MemAV) : "mem(~)" << [n(v)]
;      (v:Swap) : "swap"
;      (v:FSwap) : "fswap"
;
;;     Compilation
;;     -----------
;defn compile (tt:HashTable<Int,tgt-TgtType>,
;              ins:Vector<Ins>,
;              stackmap:StackMap,
;              output:Vector<asm-Ins>) -> False :
;
;   ;     Output State
;   ;     ------------
;   defn emit (i:asm-Ins) :
;      add(output, i)
;
;   ;     Types Classification
;   ;     --------------------
;   defn int? (t:asm-AsmType) :
;      contains?([asm-BYTE-TYPE, asm-INT-TYPE, asm-LONG-TYPE], t)
;   defn float? (t:asm-AsmType) :
;      contains?([asm-FLOAT-TYPE, asm-DOUBLE-TYPE], t)
;   defn int? (x:AVal) : int?(type(x))
;   defn float? (x:AVal) : float?(type(x))
;
;   ;     Calling Convention
;   ;     ------------------
;   defn call-locations (xs:List<AVal>) :
;      ;Positions
;      val regs = to-stream(2 to 8)
;      val fregs = to-stream(0 to 8)
;      val args = to-stream(0 to false)
;
;      ;Get locations
;      to-list $ for x in xs stream :
;         if int?(x) :
;            if more?(regs) : RegAV(next(regs), type(x))
;            else : ArgAV(next(args), type(x))
;         else if float?(x) :
;            if more?(fregs) : FRegAV(next(fregs), type(x))
;            else : ArgAV(next(args), type(x))
;         else : error("Unreachable")
;
;   defn call-locations (f:AVal, xs:List<AVal>) :
;      List(RegAV(1, asm-LONG-TYPE), call-locations(xs))
;
;
;   ;     Value Engine
;   ;     ------------
;   defn aval (x:Imm|Port) :
;      defn asm-type (t:tgt-TgtType) :
;         switch {t == _} :
;            tgt-BYTE-TYPE : asm-BYTE-TYPE
;            tgt-INT-TYPE : asm-INT-TYPE
;            tgt-LONG-TYPE : asm-LONG-TYPE
;            tgt-REF-TYPE : asm-LONG-TYPE
;            tgt-FLOAT-TYPE : asm-FLOAT-TYPE
;            tgt-DOUBLE-TYPE : asm-DOUBLE-TYPE
;
;      match(x) :
;         (x:Var|LivePort) :
;            val t = asm-type(tt[n(x)])
;            match(loc(x)) :
;               (l:Reg) : RegAV(n(l), t)
;               (l:FReg) : FRegAV(n(l), t)
;               (l:Stack) : StackAV(offset(stackmap, l), t)
;         (x:DeadPort) :
;            val t = asm-type(tt[n(x)])
;            NoneAV(t)
;         (x:Val) :
;            match(value(x)) :
;               (x:tgt-ByteImm) : ImmAV(tgt-value(x), asm-BYTE-TYPE)
;               (x:tgt-IntImm) : ImmAV(tgt-value(x), asm-INT-TYPE)
;               (x:tgt-LongImm) : ImmAV(tgt-value(x), asm-LONG-TYPE)
;               (x:tgt-Mem) : MemAV(tgt-n(x))
;
;   defn stack-aval (x:Var) :
;      aval(Var(n(x), Stack(n(x))))
;
;   defn to-asm-op (op:tgt-TgtOp) :
;      switch {op == _} :
;         tgt-ADD-OP : asm-ADD-OP
;         tgt-SUB-OP : asm-SUB-OP
;         tgt-MUL-OP : asm-MUL-OP
;         tgt-DIV-OP : asm-DIV-OP
;         tgt-MOD-OP : asm-MOD-OP
;         tgt-AND-OP : asm-AND-OP
;         tgt-OR-OP : asm-OR-OP
;         tgt-XOR-OP : asm-XOR-OP
;         tgt-SHL-OP : asm-SHL-OP
;         tgt-SHR-OP : asm-SHR-OP
;         tgt-ASHR-OP : asm-ASHR-OP
;         tgt-EQ-OP : asm-EQ-OP
;         tgt-NE-OP : asm-NE-OP
;         tgt-LT-OP : asm-LT-OP
;         tgt-GT-OP : asm-GT-OP
;         tgt-LE-OP : asm-LE-OP
;         tgt-GE-OP : asm-GE-OP
;         tgt-ULE-OP : asm-ULE-OP
;         tgt-ULT-OP : asm-ULT-OP
;         tgt-UGT-OP : asm-UGT-OP
;         tgt-UGE-OP : asm-UGE-OP
;
;   defn av-mov (x:AVal, y:AVal) :
;      defn mem-base (x:AVal) :
;         match(x) :
;            (x:ArgAV) : asm-Mem(tgt-ARG-LBL)
;            (x:StackAV) : asm-RegSP()
;            (x:Swap) : asm-Mem(tgt-SWAP-LBL)
;            (x:FSwap) : asm-Mem(tgt-FSWAP-LBL)
;      defn mem-offset (x:AVal) :
;         match(x) :
;            (x:ArgAV) : 8 * n(x)
;            (x:StackAV) : offset(x)
;            (x:Swap) : 0
;            (x:FSwap) : 0
;      match(x, y) :
;         (x:RSPAV|RegAV|FRegAV, y:RSPAV|RegAV|FRegAV|ImmAV) :
;            emit(asm-SetIns(type(x), loc!(x), imm!(y)))
;         (x:RSPAV|RegAV|FRegAV, y:ArgAV|StackAV|Swap|FSwap) :
;            emit(asm-Load(type(x), loc!(x), mem-base(y), mem-offset(y)))
;         (x:ArgAV|StackAV|Swap|FSwap, y:RSPAV|RegAV|FRegAV|ImmAV) :
;            emit(asm-Store(type(y), mem-base(x), imm!(y), mem-offset(x)))
;
;   defn av-binop (x:AVal, op:tgt-TgtOp, y:AVal, z:AVal) :
;      emit(asm-BinOp(type(x), loc!(x), to-asm-op(op), imm!(y), imm!(z)))
;
;   defn av-add (x:AVal, y:AVal, z:AVal) :
;      av-binop(x, tgt-ADD-OP, y, z)
;
;   defn av-sub (x:AVal, y:AVal, z:AVal) :
;      av-binop(x, tgt-SUB-OP, y, z)
;
;   defn av-divmod (x1:AVal, x2:AVal, y:AVal, z:AVal) :
;      emit(asm-DualOp(type(x1), loc!(x1), loc!(x2), asm-DIVMOD-OP, imm!(y), imm!(z)))
;
;   defn av-load (v:AVal, a:AVal, o:Int) :
;      emit(asm-Load(type(v), loc!(v), imm!(a), o))
;
;   defn av-store (a:AVal, v:AVal, o:Int) :
;      emit(asm-Store(type(v), imm!(a), imm!(v), o))
;
;   defn av-conv (x:AVal, y:AVal, sign?:True|False) :
;     emit(asm-ConvertIns(type(x), loc!(x), type(y), imm!(y), sign?))
;
;   defn av-label (n:Int) :
;     emit(asm-Label(n))
;
;   defn av-goto (v:AVal) :
;      emit(asm-Goto(imm!(v)))
;
;   defn av-break (n:Int, op:tgt-TgtOp, x:AVal, y:AVal) :
;      emit(asm-Branch(type(x), asm-Mem(n), to-asm-op(op), imm!(x), imm!(y)))
;
;   defn av-long (v:Int) :
;      ImmAV(v, asm-LONG-TYPE)
;
;   defn av-arity () :
;      RegAV(0, asm-LONG-TYPE)
;
;   defn av-return () :
;      emit(asm-Return())
;
;   defn av-call (f:AVal) :
;      emit(asm-Call(imm!(f)))
;
;   defn av-xchg (x:AVal, y:AVal) :
;      emit(asm-XchgIns(loc!(x), loc!(y)))
;
;
;   ;     Parallel Move Engine
;   ;     --------------------
;   defn av-mov (xs:List<AVal>, ys:List<AVal>) :
;      ;Algorithm State
;      val swaps = Vector<[AVal, AVal]>()
;      val shuffles = Vector<[RegAV, RegAV]>()
;      val fshuffles = Vector<[FRegAV, FRegAV]>()
;      val loads = Vector<[AVal, AVal]>()
;      val occupied-regs = Array<True|False>(8, false)
;      val occupied-fregs = Array<True|False>(8, false)
;
;      ;Utilities
;      defn fst<?T> ([x, y]:[?T, ?]) : x
;      defn snd<?T> ([x, y]:[?, ?T]) : y
;
;      ;Step 1: Free registers through saves and discover which registers are free
;      defn save-step () :
;         for (x in xs, y in ys) do :
;            match(x, y) :
;               (x:ArgAV|StackAV|Swap|FSwap, y:RegAV|FRegAV|RSPAV|ImmAV) :
;                  av-mov(x, y)
;               (x:ArgAV|StackAV|Swap|FSwap, y:ArgAV|StackAV|Swap|FSwap) :
;                  add(swaps, [x, y])
;               (x:RegAV, y:RegAV) :
;                  occupied-regs[n(y)] = true
;                  add(shuffles, [x, y])
;               (x:FRegAV, y:FRegAV) :
;                  occupied-fregs[n(y)] = true
;                  add(fshuffles, [x, y])
;               (x:RegAV|FRegAV|RSPAV, y:ArgAV|StackAV|Swap|FSwap|ImmAV) :
;                  add(loads, [x, y])
;               (x:NoneAV, y) :
;                  false
;               (x, y) :
;                  error("Unsupported combination: ~ and ~" % [x, y])
;
;      ;Step 2: Swap Memory Locations through a Register
;      defn swap-step (s:Int) :
;         defn int-type (x:AVal) :
;            val t = type(x)
;            switch {t == _} :
;               asm-DOUBLE-TYPE : asm-LONG-TYPE
;               asm-FLOAT-TYPE : asm-INT-TYPE
;               else : t
;         defn with-type (x:AVal, t:asm-AsmType) :
;            match(x) :
;               (x:ArgAV) : ArgAV(n(x), t)
;               (x:StackAV) : StackAV(offset(x), t)
;
;         for [x, y] in swaps do :
;            val t = int-type(x)
;            av-mov(RegAV(s,t), with-type(y,t))
;            av-mov(with-type(x,t), RegAV(s,t))
;
;      ;Step 3: Doing the shuffles
;      defn shuffle-step (s:Int, sf:Int) :
;         defn shuffle (t:asm-AsmType, xs:List<Int>, ys:List<Int>, s:Int) :
;            ;Create predecessor and successor table
;            val pred = Array<False|Int>(8,false)
;            val succs = Array<List<Int>>(8, List())
;
;            ;Fill tables
;            for (x in xs, y in ys) do :
;               pred[x] = y
;               succs[y] = List(x, succs[y])
;
;            ;Glue
;            defn shuf (x:Int, y:Int) :
;               if int?(t) : av-mov(RegAV(x,t), RegAV(y,t))
;               else if float?(t) : av-mov(FRegAV(x,t), FRegAV(y,t))
;               else : error("Unreachable")
;
;            ;Resolve a cycle
;            defn* cycle (xs:List<Int>) :
;               val x0 = head(xs)
;               shuf(s, x0)
;               for x in xs do :
;                  val p = if pred[x] == x0 : s
;                          else : pred[x] as Int
;                  shuf(x, p)
;
;            ;Issue in proper order
;            val graph = stream(KeyValue, 0 to false, succs)
;            for c in strong-components(graph) do :
;               match(c) :
;                  (c:List<Int>) : cycle(c) when not empty?(tail(c))
;                  (c:Int) : shuf(c, pred[c] as Int) when pred[c] != false
;
;         shuffle(asm-LONG-TYPE,
;                 to-list(stream(n{fst(_)}, shuffles))
;                 to-list(stream(n{snd(_)}, shuffles)),
;                 s)
;         shuffle(asm-DOUBLE-TYPE,
;                 to-list(stream(n{fst(_)}, fshuffles))
;                 to-list(stream(n{snd(_)}, fshuffles)),
;                 sf)
;
;      ;Step 4: Doing the register loads
;      defn load-step () :
;         for [x, y] in loads do :
;            av-mov(x, y)
;
;      ;Step 5: Explicit Save and Restore of Swap Register
;      defn save-and-restore-swap (s:Int|False, s2:Int|False) :
;         ;Save
;         if s == false : av-mov(Swap(), RegAV(0, asm-LONG-TYPE))
;         if s2 == false : av-mov(FSwap(), FRegAV(0, asm-DOUBLE-TYPE))
;         ;Swap out sources
;         defn reg0? (x:AVal) :
;            match(x) :
;               (x:RegAV) : n(x) == 0
;               (x) : false
;         defn freg0? (x:AVal) :
;            match(x) :
;               (x:FRegAV) : n(x) == 0
;               (x) : false
;         defn xys () :
;            concat-all([swaps, shuffles, fshuffles, loads])
;         val xs* = to-list $
;            for e in xys() stream :
;               val x = fst(e)
;               if (s == false) and reg0?(x) : Swap()
;               else if (s2 == false) and freg0?(x) : FSwap()
;               else : x
;         val ys* = to-list(stream(snd, xys()))
;         av-mov(xs*, ys*)
;         ;Restore
;         if s == false : av-mov(RegAV(0, asm-LONG-TYPE), Swap())
;         if s2 == false : av-mov(FRegAV(0, asm-DOUBLE-TYPE), FSwap())
;
;      ;Driver
;      save-step()
;      match(index-of(occupied-regs, false), index-of(occupied-fregs, false)) :
;         (s:Int, sf:Int) :
;            swap-step(s)
;            shuffle-step(s, sf)
;            load-step()
;         (s, sf) :
;            save-and-restore-swap(s, sf)
;
;
;   ;     Convert Instructions
;   ;     --------------------
;   for e in ins do :
;      println("Converting ~" << [e])
;      match(e) :
;         (e:Set) :
;            av-mov(aval(x(e)), aval(y(e)))
;         (e:Return) :
;            val xs* = map(aval, xs(e))
;            val ts* = call-locations(xs*)
;            av-mov(ts*, xs*)
;            av-return()
;         (e:Op) :
;            match(op(e)) :
;               (opc:ComOp|NComOp|DivOp|ShfOp|CmpOp) :
;                  val [x, y, z] = [xs(e)[0], ys(e)[0], ys(e)[1]]
;                  av-binop(aval(x), op(opc), aval(y), aval(z))
;               (opc:DivModOp) :
;                  val [x1, x2, y, z] = [xs(e)[0], xs(e)[1], ys(e)[0], ys(e)[1]]
;                  av-divmod(aval(x1), aval(x2), aval(y), aval(z))
;               (opc:LoadOp) :
;                  val [x, y, o] = [xs(e)[0], ys(e)[0], offset(opc)]
;                  av-load(aval(x), aval(y), o)
;               (opc:StoreOp) :
;                  val [x, y, o] = [ys(e)[0], ys(e)[1], offset(opc)]
;                  av-store(aval(x), aval(y), o)
;               (opc:ConvOp) :
;                  val [x, y, s] = [xs(e)[0], ys(e)[0], signed?(opc)]
;                  av-conv(aval(x), aval(y), s)
;               (opc:AddrOp) :
;                  error("TODO: Not yet implemented.")
;               (opc:NOp) :
;                  false
;         (e:WArgs) :
;            val xs* = map(aval, xs(e))
;            val ts* = call-locations(xs*)
;            av-mov(xs*, ts*)
;         (e:WCall) :
;            ;Convert to AVals
;            val f* = aval(f(e))
;            val ys* = map(aval, ys(e))
;
;            ;Move arguments into position and call
;            match(f*) :
;               (f*:MemAV) :
;                  val ts* = call-locations(ys*)
;                  av-mov(ts*, ys*)
;               (f*) :
;                  val ts* = call-locations(f*, ys*)
;                  av-mov(ts*, List(f*,ys*))
;
;            ;Call
;            av-mov(av-arity(), av-long(arity(e)))
;            av-add(RSPAV(), RSPAV(), av-long(size(stackmap) + 8))
;            av-call(f*)
;            av-sub(RSPAV(), RSPAV(), av-long(size(stackmap) + 8))
;
;            ;Move return values out from Args
;            val xs* = map(aval, xs(e))
;            val ts* = call-locations(xs*)
;            av-mov(xs*, ts*)
;         (e:Save) :
;            val x* = aval(x(e))
;            val sx* = stack-aval(x(e))
;            av-mov(sx*, x*)
;         (e:Load) :
;            val x* = aval(x(e))
;            val sx* = stack-aval(x(e))
;            av-mov(x*, sx*)
;         (e:Xchg) :
;            av-xchg(aval(x(e)), aval(y(e)))
;            println("TODO: Handle floating point exchanges too.")
;         (e:Glue) :
;            val xs* = map(aval,xs(e))
;            val ys* = map(aval,ys(e))
;            av-mov(xs*, ys*)
;         (e:Label) :
;            av-label(n(e))
;         (e:Goto) :
;            av-goto(MemAV(n(e)))
;         (e:Break) :
;            defn flip (op:tgt-TgtOp) :
;               switch {op == _} :
;                  tgt-EQ-OP : tgt-NE-OP
;                  tgt-NE-OP : tgt-EQ-OP
;                  tgt-LT-OP : tgt-GE-OP
;                  tgt-GT-OP : tgt-LE-OP
;                  tgt-LE-OP : tgt-GT-OP
;                  tgt-GE-OP : tgt-LT-OP
;                  tgt-ULE-OP : tgt-UGT-OP
;                  tgt-ULT-OP : tgt-UGE-OP
;                  tgt-UGT-OP : tgt-ULE-OP
;                  tgt-UGE-OP : tgt-ULT-OP
;
;            match(op(e)) :
;               (opc:CmpOp) :
;                  val [x, y] = [xs(e)[0], xs(e)[1]]
;                  if flip?(e) : av-break(n(e), flip(op(opc)), aval(x), aval(y))
;                  else : av-break(n(e), op(opc), aval(x), aval(y))