defpackage stz/bb :
   import core
   import collections
   import stz/algorithms
   import stz/ids
   import stz/utils
   import stz/tgt-ir with :
      prefix => tgt-
   import stz/bb-ir
   import stz/asm-ir with :
      prefix => asm-
   import stz/padder
   import stz/backend
   import stz/params

;============================================================
;==================== Main Driver ===========================
;============================================================

val normalize-timer = MillisecondTimer("Normalize")
val spill-timer = MillisecondTimer("Spill")
val to-bb-timer = MillisecondTimer("To Bb")
val critical-edges-timer = MillisecondTimer("Critical Edges")
val liveness-timer = MillisecondTimer("Liveness")
val early-saves-timer = MillisecondTimer("Early Saves")
val class-allocation-timer = MillisecondTimer("Class Allocation")
val propagate-assumptions-timer = MillisecondTimer("Propagate Assumptions")
val register-assignment-timer = MillisecondTimer("Register Assignment")
val stackmap-timer = MillisecondTimer("Stackmap")
val enforced-clearing-timer = MillisecondTimer("Enforced Clearing")
val collapse-blocks-timer = MillisecondTimer("Collapse Blocks")
val assemble-timer = MillisecondTimer("Assemble")

val index-timer = MillisecondTimer("Index")
val new-early-saves-timer = MillisecondTimer("New Early Saves")
val kill-use-timer = MillisecondTimer("Kill Use Timer")

public defn print-timing () :
   val total = time(normalize-timer) + time(spill-timer) + time(to-bb-timer) +
               time(critical-edges-timer) + time(liveness-timer) + time(early-saves-timer) +
               time(class-allocation-timer) + time(propagate-assumptions-timer) +
               time(register-assignment-timer) + time(stackmap-timer) + time(enforced-clearing-timer) +
               time(collapse-blocks-timer) + time(assemble-timer)
   println("Total = %_" % [total])
   defn print-percentage (t:Timer, total:Long) :
      println("%_ (%_%%)" % [t, time(t) * 100L / total])
   print-percentage(spill-timer, total)
   print-percentage(to-bb-timer, total)
   print-percentage(critical-edges-timer, total)
   print-percentage(liveness-timer, total)
   print-percentage(early-saves-timer, total)
   print-percentage(class-allocation-timer, total)
   print-percentage(propagate-assumptions-timer, total)
   print-percentage(register-assignment-timer, total)
   print-percentage(stackmap-timer, total)
   print-percentage(enforced-clearing-timer, total)
   print-percentage(collapse-blocks-timer, total)
   print-percentage(assemble-timer, total)

   println("Class Allocation")
   print-percentage(spill-calc-timer, time(class-allocation-timer))
   print-percentage(spill-reg-timer, time(class-allocation-timer))
   print-percentage(usage-table-timer, time(class-allocation-timer))
   print-percentage(release-table-timer, time(class-allocation-timer))
   print-percentage(allocate-sweep-timer, time(class-allocation-timer))

   println("New Pipeline")
   print-percentage(index-timer, total)
   print-percentage(new-early-saves-timer, total)
   print-percentage(kill-use-timer, total)

   

public defn compile (def:tgt-DefFn,
                     backend:Backend,
                     output:Vector<asm-Ins>,
                     infos:Vector<KeyValue<Int,FileInfo>>) -> False :
   defn vheadline (name:String) :
      if flag-defined?(`VERBOSE) :
         header(name)
      false
   defn vprintln (x) :
      if flag-defined?(`VERBOSE) :
         println(x)
      false

   start(normalize-timer)
   vheadline("Normalize")
   var d = normalize(def)
   ;println(d)
   stop(normalize-timer)

   start(spill-timer)
   vheadline("Spill call arguments")
   d = spill-call-args(d, backend)
   ;println(d)
   stop(spill-timer)

   start(to-bb-timer)
   vheadline("Compile to Basic Block IR")
   val [tt, bb-ir] = to-bb-ir(d)
   ;println(bb-ir)
   stop(to-bb-timer)

   start(critical-edges-timer)
   var u:Unit = bb-ir
   u = remove-critical-edges(u)
   stop(critical-edges-timer)

   ;New Pipeline
   start(index-timer)
   index-prog(u)
   stop(index-timer)
   ;print-indexed-prog()

   start(kill-use-timer)
   kill-use-annotations()
   stop(kill-use-timer)
   print-indexed-prog()

   ;start(new-early-saves-timer)
   ;new-emit-early-saves()
   ;stop(new-early-saves-timer)
   ;print-indexed-prog()

   ;Old Pipeline
   start(liveness-timer)
   u = analyze-liveness(u)
   stop(liveness-timer)

   start(early-saves-timer)
   vheadline("Early Saves")
   u = map(emit-early-saves, u)
   ;println(u)
   stop(early-saves-timer)

   start(class-allocation-timer)
   vheadline("Allocate Classes")
   u = map(allocate-classes{tt, _, backend}, u)
   ;println(u)
   stop(class-allocation-timer)

   start(propagate-assumptions-timer)
   vheadline("Propagate Assumptions")
   u = map(propagate-assumptions, u)
   ;println(u)
   stop(propagate-assumptions-timer)

   start(register-assignment-timer)
   vheadline("Register Assignment")
   u = register-assignment(tt, backend, u)
   ;println(u)
   stop(register-assignment-timer)

   #if-not-defined(OPTIMIZE) :
      vheadline("Verify Reigster Assignment")
      do(verify-register-assignment{_, backend}, blocks(u) as Vector<WBlock>)

   start(stackmap-timer)
   vheadline("Calculating stack map")
   val stack-map = calculate-stack-map(tt, u)
   stop(stackmap-timer)

   start(enforced-clearing-timer)
   vheadline("Enforced Clearing")
   u = enforced-clearing(u, stack-map)
   vprintln(u)
   stop(enforced-clearing-timer)

   start(collapse-blocks-timer)
   vheadline("Block Collapsing")
   val ins = collapse-blocks(u, stack-map)
   stop(collapse-blocks-timer)
   if flag-defined?(`VERBOSE) :
      do(println, ins)

   start(assemble-timer)
   compile(tgt-n(d), tt, backend, ins, stack-map, output, infos)
   stop(assemble-timer)


;============================================================
;====================== Utilities ===========================
;============================================================

defn make-table<?K,?V,?T> (xs:Seqable<?T>,
                           k: T -> ?K,
                           v: T -> ?V,
                           hash: K -> Int) :
   val table = HashTable<K,V>(hash)
   for x in xs do : table[k(x)] = v(x)
   table

defn map (f: WBlock -> Block, u:Unit) :
   Unit(defs(u),
        map<Block>(f, blocks(u) as Vector<WBlock>))

defn post-order (bs:Vector<Block>, cull?:True|False) -> Vector<Block> :
   ;Block Table
   val block = HashTable<Int,Block>()
   for b in bs do : block[n(b)] = b

   ;Mark Table
   val mark-table = HashTable<Int,True>()
   defn marked? (b:Block) : key?(mark-table, n(b))
   defn mark (b:Block) : mark-table[n(b)] = true

   ;Add blocks to ys
   val ys = Vector<Block>()
   defn* loop (b:Block) :
      if not marked?(b) :
         mark(b)
         do(loop{block[_]}, next(b))
         add(ys, b)
   loop(bs[0])

   ;Add non-reachable blocks
   if not cull? :
      for b in bs do :
         add(ys, b) when not marked?(b)

   ;Return
   ys

defn post-order (bs:Vector<Block>) -> Vector<Block> :
   post-order(bs, true)

defn reverse-post-order (bs:Vector<Block>) -> Vector<Block> :
   val bs* = post-order(bs)
   reverse!(bs*)
   bs*

;============================================================
;================= Spill Call Arguments =====================
;============================================================

defn spill-call-args (def:tgt-DefFn, backend:Backend) :
   ;     Type Layer
   ;     ----------
   val int-values = HashTable<Int,True|False>()
   for d in tgt-defs(def) do :
      int-values[tgt-n(d)] = tgt-int?(tgt-type(d))

   defn int? (x:tgt-Imm) :
      match(x) :
         (x:tgt-Var) : int-values[tgt-n(x)]
         (x) : true

   ;     Output State
   ;     ------------
   val output = Vector<tgt-Ins>()
   val defvars = Vector<tgt-DefVar>()
   do(add{defvars, _}, tgt-defs(def))
   defn emit (i:tgt-Ins) :
      add(output, i)
   defn make-var (t:tgt-TgtType) :
      val n = fresh-id()
      add(defvars, tgt-DefVar(n, t))
      tgt-Var(n)

   var cached-c-rsp : False|tgt-Var = false
   defn saved-c-rsp () :
      if cached-c-rsp is False :
         cached-c-rsp = make-var(tgt-LONG-TYPE)
      cached-c-rsp as tgt-Var

   ;     Split Locations
   ;     ---------------
   ;Split a group of values into which go into memory, and which go
   ;into registers.
   defn split-mem-locs<?T> (xs:List<?T&tgt-Imm>, nregs:Int, nfregs:Int) :
      defn cms (xs) : join(xs, ", ")
      val regs = to-seq(0 to nregs)
      val fregs = to-seq(0 to nfregs)
      val reg-xs = Vector<T&tgt-Imm>()
      val mem-xs = Vector<T&tgt-Imm>()
      for x in xs do :
         if int?(x) :
            if empty?(regs) :
               add(mem-xs, x)
            else :
               next(regs)
               add(reg-xs, x)

         else :
            if empty?(fregs) :
               add(mem-xs, x)
            else :
               next(fregs)
               add(reg-xs, x)

      [to-list(reg-xs), to-list(mem-xs)]
   defn split-call-locs<?T> (xs:List<?T&tgt-Imm>) :
      split-mem-locs(xs, length(call-regs(backend)), length(call-fregs(backend)))
   defn split-callc-locs<?T> (xs:List<?T&tgt-Imm>) :
      split-mem-locs(xs, length(callc-regs(backend)), length(callc-fregs(backend)))

   ;     Main Algorithm
   ;     --------------
   ;Convert calls
   for e in tgt-body(def) do :
      match(e) :
         (e:tgt-ArgsIns) :
            val [xs, mxs] = split-call-locs(tgt-xs(e))
            emit(tgt-ArgsIns(xs))
            for (x in mxs, o in 0 to false by 8) do :
               emit(tgt-Load(x, tgt-Mem(ARG-LBL,0), o))
         (e:tgt-Return) :
            val [xs, mxs] = split-call-locs(tgt-xs(e))
            for (x in mxs, o in 0 to false by 8) do :
               emit(tgt-Store(x, tgt-Mem(ARG-LBL,0), o))
            emit(tgt-Return(xs))
         (e:tgt-CArgsIns) :
            val sp = make-var(tgt-LONG-TYPE)
            val [xs, mxs] = split-callc-locs(tgt-xs(e))
            emit(tgt-CArgsIns(cons(sp, xs)))
            for (x in mxs, i in 0 to false) do :
               emit(tgt-Load(x, sp, 8 * (i + 1)))
            emit(tgt-Load(saved-c-rsp(), tgt-Mem(C-RSP-LBL,0), 0))
            emit(tgt-Store(tgt-Mem(C-RSP-LBL,0), sp, 0))
         (e:tgt-CReturn) :
            val sp = make-var(tgt-LONG-TYPE)
            emit(tgt-Load(sp, tgt-Mem(C-RSP-LBL,0), 0))
            emit(tgt-Store(tgt-Mem(C-RSP-LBL,0), saved-c-rsp(), 0))
            emit(tgt-CReturn(cons(sp, tgt-xs(e))))
         (e:tgt-Call) :
            val [ys, mys] = split-call-locs(tgt-ys(e))
            val [xs, mxs] = split-call-locs(tgt-xs(e))
            for (y in mys, o in 0 to false by 8) do :
               emit(tgt-Store(tgt-Mem(ARG-LBL,0), y, o))
            emit(tgt-Call(tgt-arity(e), xs, tgt-f(e), ys, tgt-new-stack?(e), tgt-info(e)))
            for (x in mxs, o in 0 to false by 8) do :
               emit(tgt-Load(x, tgt-Mem(ARG-LBL,0), o))
         (e:tgt-CallStack) :
            val [ys, mys] = split-call-locs(tgt-ys(e))
            val [xs, mxs] = split-call-locs(tgt-xs(e))
            for (y in mys, o in 0 to false by 8) do :
               emit(tgt-Store(tgt-Mem(ARG-LBL,0), y, o))
            emit(tgt-CallStack(xs, tgt-f(e), ys, tgt-info(e)))
            for (x in mxs, o in 0 to false by 8) do :
               emit(tgt-Load(x, tgt-Mem(ARG-LBL,0), o))
         (e:tgt-TCall) :
            val [ys, mys] = split-call-locs(tgt-ys(e))
            for (y in mys, o in 0 to false by 8) do :
               emit(tgt-Store(tgt-Mem(ARG-LBL,0), y, o))
            emit(tgt-TCall(tgt-arity(e), tgt-f(e), ys, tgt-new-stack?(e)))
         (e:tgt-TCallStack) :
            val [ys, mys] = split-call-locs(tgt-ys(e))
            for (y in mys, o in 0 to false by 8) do :
               emit(tgt-Store(tgt-Mem(ARG-LBL,0), y, o))
            emit(tgt-TCallStack(tgt-f(e), ys))
         (e:tgt-CallC) :
            val [ys, mys] = split-callc-locs(tgt-ys(e))
            val spl = make-var(tgt-LONG-TYPE)
            emit(tgt-Load(spl, tgt-Mem(STACK-PTR-LBL,0), 0))
            if empty?(mys) :
               emit(tgt-CallC(1, tgt-xs(e), tgt-f(e), ys))
            else :
               val n = length(mys) | 1
               val sp = make-var(tgt-LONG-TYPE)
               emit(tgt-Load(sp, tgt-Mem(C-RSP-LBL,0), 0))
               for (y in mys, i in 0 to false) do :
                  emit(tgt-Store(sp, y, 8 * (i - 6 - n)))
               emit(tgt-CallC(n, tgt-xs(e), tgt-f(e), ys))
            emit(tgt-Store(tgt-Mem(STACK-PTR-LBL,0), spl, 0))
         (e) :
            emit(e)

   ;Return result
   tgt-DefFn(tgt-n(def), defvars, output)


;============================================================
;================== Normalization ===========================
;============================================================

defn normalize (d:tgt-DefFn) -> tgt-DefFn :

   ;                   State
   ;                   =====
   ;(clones[x] = ys) => ys are all clones of x
   val clones = HashTable<Int,List<Int>>()
   val body* = Vector<tgt-Ins>()
   val defs* = Vector<tgt-DefVar>()

   ;                   Helpers
   ;                   =======

   defn operands (i:tgt-Ins) -> List<tgt-Imm> :
      match(i) :
         (i:tgt-ConvertIns) : List(tgt-y(i))
         (i:tgt-InterpretIns) : List(tgt-y(i))
         (i:tgt-BinOp) : List(tgt-y(i), tgt-z(i))
         (i:tgt-UnaOp) : List(tgt-y(i))
         (i:tgt-Load) : List(tgt-y(i))
         (i) : fatal("Not needed.")

   defn update-x (i:tgt-Ins, x:tgt-Var) :
      match(i) :
         (i:tgt-ConvertIns) : tgt-ConvertIns(x, tgt-y(i))
         (i:tgt-InterpretIns) : tgt-InterpretIns(x, tgt-y(i))
         (i:tgt-BinOp) : tgt-BinOp(x, tgt-op(i), tgt-y(i), tgt-z(i))
         (i:tgt-UnaOp) : tgt-UnaOp(x, tgt-op(i), tgt-y(i))
         (i:tgt-Load) : tgt-Load(x, tgt-y(i), tgt-offset(i))
         (i) : fatal("Not needed.")

   defn matches? (x:tgt-Var, y:tgt-Imm) :
      match(y) :
         (y:tgt-Var) : tgt-n(x) == tgt-n(y)
         (y) : false

   defn matches? (x:tgt-Var, ys:List<tgt-Imm>) :
      for y in ys any? :
         matches?(x, y)

   defn clone (x:tgt-Var) :
      val n* = fresh-id()
      clones[tgt-n(x)] = cons(n*, get?(clones, tgt-n(x), List()))
      tgt-Var(n*)

   ;                   Driver
   ;                   ======

   ;Normalize instructions
   for i in tgt-body(d) do :
      match(i) :
         (i:tgt-SetIns) :
            if not matches?(tgt-x(i), tgt-y(i)) :
               add(body*, i)
         (i:tgt-Load|tgt-BinOp|tgt-UnaOp|tgt-InterpretIns|tgt-ConvertIns) :
            if matches?(tgt-x(i), operands(i)) :
               val x* = clone(tgt-x(i))
               add(body*, update-x(i, x*))
               add(body*, tgt-SetIns(tgt-x(i), x*))
            else :
               add(body*, i)
         (i) :
            add(body*, i)

   ;Copy defs with clones
   for def in tgt-defs(d) do :
      add(defs*, def)
      if key?(clones, tgt-n(def)) :
         for y in clones[tgt-n(def)] do :
            add(defs*, tgt-DefVar(y, tgt-type(def)))

   ;Return normalized DefFn
   tgt-DefFn(tgt-n(d), defs*, body*)



;============================================================
;============== Translation to BB IR=========================
;============================================================

defn to-bb-ir (d:tgt-DefFn) -> [HashTable<Int,tgt-TgtType>, Unit] :
   ;State
   val defs = Vector<tgt-DefVar>()
   val block-list = Vector<Block>()
   val type-table = HashTable<Int,tgt-TgtType>()

   ;Helpers
   defn imm-type (i:tgt-Imm) :
      match(i) :
         (i:tgt-ByteImm) : tgt-BYTE-TYPE
         (i:tgt-IntImm) : tgt-INT-TYPE
         (i:tgt-LongImm) : tgt-LONG-TYPE
         (i:tgt-RSP) : tgt-LONG-TYPE
         (i:tgt-Var) : type-table[tgt-n(i)]
         (i:tgt-Mem) : tgt-LONG-TYPE
         (i:tgt-ExMem) : tgt-LONG-TYPE

   defn fresh-block (n:Int) :
      Block(n, Vector<Ins>(), List())

   var active-block = fresh-block(fresh-id())

   defn emit (i:Ins) :
      add(ins(active-block), i)

   defn to-var (x:tgt-Var) :
      Var(tgt-n(x))

   defn to-imm (x:tgt-Imm) :
      val max = 1 << 16
      val min = -1 << 16
      defn large? (v:Int) : (v < min) or (v > max)
      defn large? (v:Long) : (v < to-long(min)) or (v > to-long(max))

      match(x) :
         (x:tgt-Var) : to-var(x)
         (x:tgt-IntImm|tgt-LongImm) :
            if large?(tgt-value(x)) : force-var(Val(x))
            else : Val(x)
         (x) : Val(x)

   defn close-block (ns:List<Int>) :
      val ab = active-block
      add(block-list, Block(n(ab), ins(ab), ns))

   defn force-var (x:Imm) :
      match(x) :
         (x:Var) :
            x
         (x:Val) :
            val v = fresh(imm-type(value(x)))
            emit(Set(v, x))
            v

   defn force-operand (x:Imm) :
      match(x) :
         (x:Var) : x
         (x:Val) :
            match(value(x)) :
               (v:tgt-Mem|tgt-ExMem) : force-var(x)
               (v) : x

   defn fresh (t:tgt-TgtType) :
      val n = fresh-id()
      add(defs, tgt-DefVar(n, t))
      type-table[n] = t
      Var(n)

   ;Add unit defs
   for def in tgt-defs(d) do :
      add(defs, def)
      type-table[tgt-n(def)] = tgt-type(def)

   ;Translate instructions
   for i in tgt-body(d) do :
      match(i) :
         (i:tgt-ArgsIns) :
            val xs* = map(to-var, tgt-xs(i))
            emit(Args(xs*, StanzaContext()))
         (i:tgt-CArgsIns) :
            val xs* = map(to-var, tgt-xs(i))
            emit(Args(xs*, CContext()))
         (i:tgt-SetIns) :
            val x* = to-var(tgt-x(i))
            val y* = to-imm(tgt-y(i))
            emit(Set(x*, y*))
         (i:tgt-BinOp) :
            val t = imm-type(tgt-x(i))
            val top = tgt-op(i)
            val x* = to-var(tgt-x(i))
            val y* = force-operand(to-imm(tgt-y(i)))
            val z* = force-operand(to-imm(tgt-z(i)))

            defn cast-to-int (f: (tgt-TgtType, Var, Var, Var) -> False) :
               val ix = fresh(tgt-INT-TYPE)
               val iy = fresh(tgt-INT-TYPE)
               val iz = fresh(tgt-INT-TYPE)
               emit(Op(tgt-CONV-OP, List(iy), List(force-var(y*))))
               emit(Op(tgt-CONV-OP, List(iz), List(force-var(z*))))
               f(tgt-INT-TYPE, ix, iy, iz)
               emit(Op(tgt-CONV-OP, List(x*), List(ix)))
            defn com-op () :
               emit(Op(top, List(x*), List(y*, z*)))
            defn cmp-op () :
               match(y*, z*) :
                  (y*:Val, z*:Val) : emit(Op(top, List(x*), List(force-var(y*), z*)))
                  (y*, z*) :emit(Op(top, List(x*), List(y*, z*)))
            defn ncom-op () :
               emit(Op(top, List(x*), List(y*, z*)))
               emit(Op(tgt-NO-OP, List(), List(z*)))
            defn mul-op () :
               if t == tgt-BYTE-TYPE :
                  cast-to-int $ fn (t, x*, y*, z*) :
                     emit(Op(top, List(x*), List(y*, z*)))
               else : emit(Op(top, List(x*), List(y*, z*)))
            defn div-op () :
               if tgt-float?(t) :
                  emit(Op(top, List(x*), List(y*, z*)))
                  emit(Op(tgt-NO-OP, List(), List(z*)))
               else if t == tgt-BYTE-TYPE :
                  cast-to-int $ fn (t, x*, y*, z*) :
                     emit(Op(tgt-DIVMOD-OP, List(x*, fresh(t)), List(y*, z*)))
                     emit(Op(tgt-NO-OP, List(), List(z*)))
               else :
                  val y* = force-var(y*)
                  val z* = force-var(z*)
                  emit(Op(tgt-DIVMOD-OP, List(x*, fresh(t)), List(y*, z*)))
                  emit(Op(tgt-NO-OP, List(), List(z*)))
            defn mod-op () :
               if t == tgt-BYTE-TYPE :
                  cast-to-int $ fn (t, x*, y*, z*) :
                     emit(Op(tgt-DIVMOD-OP, List(fresh(t), x*), List(y*, z*)))
                     emit(Op(tgt-NO-OP, List(), List(z*)))
               else :
                  val y* = force-var(y*)
                  val z* = force-var(z*)
                  emit(Op(tgt-DIVMOD-OP, List(fresh(t), x*), List(y*, z*)))
                  emit(Op(tgt-NO-OP, List(), List(z*)))

            switch {top == _} :
               tgt-ADD-OP : com-op()
               tgt-SUB-OP : ncom-op()
               tgt-MUL-OP : mul-op()
               tgt-DIV-OP : div-op()
               tgt-MOD-OP : mod-op()
               tgt-AND-OP : com-op()
               tgt-OR-OP : com-op()
               tgt-XOR-OP : com-op()
               tgt-SHL-OP : ncom-op()
               tgt-SHR-OP : ncom-op()
               tgt-ASHR-OP : ncom-op()
               tgt-EQ-OP : cmp-op()
               tgt-NE-OP : cmp-op()
               tgt-LT-OP : cmp-op()
               tgt-GT-OP : cmp-op()
               tgt-LE-OP : cmp-op()
               tgt-GE-OP : cmp-op()
               tgt-ULE-OP : cmp-op()
               tgt-ULT-OP : cmp-op()
               tgt-UGT-OP : cmp-op()
               tgt-UGE-OP : cmp-op()
         (i:tgt-UnaOp) :
            val t = imm-type(tgt-x(i))
            val top = tgt-op(i)
            val x* = to-var(tgt-x(i))
            val y* = force-var(to-imm(tgt-y(i)))

            defn cast-to-int (f: (tgt-TgtType, Var, Var) -> False) :
               val ix = fresh(tgt-INT-TYPE)
               val iy = fresh(tgt-INT-TYPE)
               emit(Op(tgt-CONV-OP, List(iy), List(force-var(y*))))
               f(tgt-INT-TYPE, ix, iy)
               emit(Op(tgt-CONV-OP, List(x*), List(ix)))

            if t == tgt-BYTE-TYPE :
               cast-to-int $ fn (t, x*, y*) :
                  emit(Op(top, List(x*), List(y*)))
            else : emit(Op(top, List(x*), List(y*)))
         (i:tgt-ConvertIns) :
            val xt = imm-type(tgt-x(i))
            val yt = imm-type(tgt-y(i))
            val x* = to-var(tgt-x(i))
            val y* = force-var(to-imm(tgt-y(i)))
            if tgt-int?(xt) and tgt-int?(yt) :
               emit(Op(tgt-CONV-OP, List(x*), List(y*)))
            else if tgt-float?(xt) and tgt-float?(yt) :
               emit(Op(tgt-CONV-OP, List(x*), List(y*)))
            else if tgt-int?(xt) and tgt-float?(yt) :
               if xt == tgt-BYTE-TYPE :
                  val ix = fresh(tgt-INT-TYPE)
                  emit(Op(tgt-CONV-OP, List(ix), List(y*)))
                  emit(Op(tgt-CONV-OP, List(x*), List(ix)))
               else :
                  emit(Op(tgt-CONV-OP, List(x*), List(y*)))
            else if tgt-float?(xt) and tgt-int?(yt) :
               if yt == tgt-BYTE-TYPE :
                  val iy = fresh(tgt-INT-TYPE)
                  emit(Op(tgt-CONV-OP, List(iy), List(y*)))
                  emit(Op(tgt-CONV-OP, List(x*), List(iy)))
               else :
                  emit(Op(tgt-CONV-OP, List(x*), List(y*)))
         (i:tgt-InterpretIns) :
            val xt = imm-type(tgt-x(i))
            val yt = imm-type(tgt-y(i))
            val x* = to-var(tgt-x(i))
            val y* = force-var(to-imm(tgt-y(i)))
            emit(Op(tgt-INTERPRET-OP, List(x*), List(y*)))
         (i:tgt-Load) :
            val x* = to-var(tgt-x(i))
            val y* = to-imm(tgt-y(i))
            emit(Op(tgt-LoadOp(tgt-offset(i)), List(x*), List(y*)))
         (i:tgt-Store) :
            val x* = to-imm(tgt-x(i))
            val y* = force-operand(to-imm(tgt-y(i)))
            emit(Op(tgt-StoreOp(tgt-offset(i)), List(), List(x*, y*)))
         (i:tgt-Addr) :
            val x* = to-var(tgt-x(i))
            emit(Op(tgt-AddrOp(tgt-n(i)), List(x*), List()))
         (i:tgt-Call) :
            val xs = map(to-var, tgt-xs(i))
            val f = to-imm(tgt-f(i))
            val ys = map(to-imm, tgt-ys(i))
            val type = StanzaCall(tgt-arity(i), false, tgt-new-stack?(i), tgt-info(i))
            emit(Call(xs, f, ys, type))
         (i:tgt-CallStack) :
            val xs = map(to-var, tgt-xs(i))
            val f = to-imm(tgt-f(i))
            val ys = map(to-imm, tgt-ys(i))
            val type = StackCall(false, tgt-info(i))
            emit(Call(xs, f, ys, type))
         (i:tgt-CallC) :
            val xs = map(to-var, tgt-xs(i))
            val f = to-imm(tgt-f(i))
            val ys = map(to-imm, tgt-ys(i))
            emit(Call(xs, f, ys, CCall(tgt-n(i))))
         (i:tgt-TCall) :
            val f = to-imm(tgt-f(i))
            val ys = map(to-imm, tgt-ys(i))
            val type = StanzaCall(tgt-arity(i), true, tgt-new-stack?(i), false)
            emit(Call(List(), f, ys, type))
            close-block(List())
            active-block = fresh-block(fresh-id())
         (i:tgt-TCallStack) :
            val f = to-imm(tgt-f(i))
            val ys = map(to-imm, tgt-ys(i))
            val type = StackCall(true, false)
            emit(Call(List(), f, ys, type))
            close-block(List())
            active-block = fresh-block(fresh-id())
         (i:tgt-Return) :
            val xs = map(to-imm, tgt-xs(i))
            emit(Return(xs, StanzaContext()))
            close-block(List())
            active-block = fresh-block(fresh-id())
         (i:tgt-CReturn) :
            val xs = map(to-imm, tgt-xs(i))
            emit(Return(xs, CContext()))
            close-block(List())
            active-block = fresh-block(fresh-id())
         (i:tgt-Label) :
            close-block(List(tgt-n(i)))
            active-block = fresh-block(tgt-n(i))
         (i:tgt-Goto) :
            close-block(List(tgt-n(i)))
            active-block = fresh-block(fresh-id())
         (i:tgt-Branch) :
            val x* = to-imm(tgt-x(i))
            val y* = to-imm(tgt-y(i))
            val xs* = match(x*, y*) :
               (x*:Val, y*:Val) : List(force-var(x*), y*)
               (x*, y*) : List(x*, y*)
            emit(Branch(tgt-op(i), xs*))
            val alt = fresh-id()
            close-block(List(tgt-n(i), alt))
            active-block = fresh-block(alt)
         (i:tgt-SpecialBranch) :
            emit(Branch(tgt-op(i), List()))
            val alt = fresh-id()
            close-block(List(tgt-n(i), alt))
            active-block = fresh-block(alt)
         (i:tgt-SpecialOp) :
            emit(Op(tgt-op(i), List(), List()))

   ;Return
   close-block(List())
   [type-table, Unit(defs, block-list)]

;============================================================
;=============== Critical Edge Removal ======================
;============================================================

defn remove-critical-edges (u:Unit) :
   ;     Forward past empty blocks
   ;     -------------------------
   val forwards = HashTable<Int,Int>()

   defn resolve (n:Int) :
      match(get?(forwards, n, false)) :
         (f:False) :
            n
         (f:Int) :
            val n* = resolve(f)
            forwards[n] = n*
            n*

   for b in blocks(u) do :
      if empty?(ins(b)) :
         if length(next(b)) == 1 :
            forwards[n(b)] = head(next(b))

   defn next* (b:Block) :
      map(resolve, next(b))

   ;     Count predecessors for blocks
   ;     -----------------------------
   val num-preds = HashTable<Int,Int>()

   for b in blocks(u) do :
      num-preds[n(b)] = get?(num-preds, n(b), 0)
      if not empty?(ins(b)) :
         for n in next*(b) do :
            num-preds[n] = 1 + get?(num-preds, n, 0)

   ;     Insert safe blocks
   ;     ------------------
   val safe-blocks = Vector<Block>()
   val blocks-list = Vector<Block>()

   defn safe-block (next:Int) :
      val n = fresh-id()
      add(safe-blocks, Block(n, Vector<Ins>(), List(next)))
      n

   for b in blocks(u) do :
      add{blocks-list, Block(n(b), ins(b), _)} $
         if length(next(b)) > 1 :
            for n in next*(b) map :
               if num-preds[n] > 1 : safe-block(n)
               else : n
         else :
            next*(b)
   do(add{blocks-list, _}, safe-blocks)

   ;     Return result
   ;     -------------
   Unit(defs(u), blocks-list)


;============================================================
;==================== Index =================================
;============================================================

val VAR-INDICES = IntTable<Int>()
val BLOCK-INDICES = IntTable<Int>()
val VAR-TYPES = Vector<tgt-TgtType>()
val BLOCKS = Vector<Block>()
val PREDECESSORS = Vector<List<Int>>()
var BLOCK-DEFS = BitArray(1024 * 1024)
val BLOCK-INS = Vector<List<Port>>()
val BLOCK-OUTS = Vector<List<Port>>()

val VAR-USES = Vector<List<KeyValue<Int,Int>>>()
val LIVE-IN-BUFFER = Vector<Int>()
val LIVE-OUT-BUFFER = Vector<Int>()
val BLOCK-IN-BUFFER = Vector<Int>()
val BLOCK-OUT-BUFFER = Vector<Int>()

defn clear-block-defs (n:Int) :
   if length(BLOCK-DEFS) < n :
      val n* = max(length(BLOCK-DEFS) * 2, n)
      BLOCK-DEFS = BitArray(n*)
   else :
      clear(BLOCK-DEFS, n)

defn index-prog (u:Unit) :
   ;Clear Vars and Blocks
   clear(VAR-INDICES)
   clear(BLOCK-INDICES)
   clear(VAR-TYPES)
   clear(BLOCKS)

   ;Populate Variables
   for def in defs(u) do :
      val [n, t] = [tgt-n(def), tgt-type(def)]
      val n* = length(VAR-TYPES)
      VAR-INDICES[n] = n*
      add(VAR-TYPES, t)
   ;Populate Blocks
   for blk in blocks(u) do :
      val n* = length(BLOCKS)
      BLOCK-INDICES[n(blk)] = n*
      add(BLOCKS, blk)

   ;Clear block defs
   val nblocks = length(BLOCKS)
   val nvars = length(VAR-TYPES)
   clear-block-defs(nblocks * nvars)
   ;Clear block uses
   clear(VAR-USES)
   set-length(VAR-USES, nvars, List())
   ;Clear predecessors
   clear(PREDECESSORS)
   set-length(PREDECESSORS, nblocks, List())

   ;Rename Instruction
   defn rename (i:Ins) :
      for imm in i map :
         match(imm) :
            (imm:Var) : Var(VAR-INDICES[n(imm)])
            (imm) : imm

   ;Rename Blocks
   for blk in BLOCKS map! :
      ;Rename block indices
      val next* = map({BLOCK-INDICES[_]}, next(blk))
      val n* = BLOCK-INDICES[n(blk)]

      ;Mark definitions and usages
      defn mark-defined (v:Var) : BLOCK-DEFS[n* * n(v)] = true
      defn defined? (v:Var) : BLOCK-DEFS[n* * n(v)]
      defn mark-used (v:Imm, d:Int) :
         if v is Var :
            val v = v as Var
            if not defined?(v) :
               VAR-USES[n(v)] = cons(n* => d, VAR-USES[n(v)])

      val idx-counter = to-seq(0 to false)
      val ins* = for i in ins(blk) map<Ins> :
         val idx = next(idx-counter)
         val i* = rename(i)
         do-used(mark-used{_, idx}, i*)
         do-defined(mark-defined, i*)
         i*
      for n in next* do :
         PREDECESSORS[n] = cons(n*, PREDECESSORS[n])
      Block(n(blk), ins*, next*)

   ;Propagate liveness
   clear(BLOCK-INS)
   clear(BLOCK-OUTS)
   set-length(BLOCK-INS, nblocks, List())
   set-length(BLOCK-OUTS, nblocks, List())
   if length(LIVE-IN-BUFFER) < nblocks :
      lengthen(LIVE-IN-BUFFER, nblocks, INT-MAX)
      lengthen(LIVE-OUT-BUFFER, nblocks, INT-MAX)

   defn save-lives (v:Int) :
      for b in BLOCK-IN-BUFFER do :
         BLOCK-INS[b] = cons(DPort(v, Any(), Any(), NoLoc(), LIVE-IN-BUFFER[b]), BLOCK-INS[b])
         LIVE-IN-BUFFER[b] = INT-MAX
      clear(BLOCK-IN-BUFFER)

      for b in BLOCK-OUT-BUFFER do :
         BLOCK-OUTS[b] = cons(DPort(v, Any(), Any(), NoLoc(), LIVE-OUT-BUFFER[b]), BLOCK-OUTS[b])
         LIVE-OUT-BUFFER[b] = INT-MAX
      clear(BLOCK-OUT-BUFFER)

   for v in 0 to nvars do :
      if not empty?(VAR-USES[v]) :
         for entry in VAR-USES[v] do :
            val [b, d] = [key(entry), value(entry)]
            mark-live-in(b, v, d)
         save-lives(v)

lostanza defn mark-live-out (b:ref<Int>, v:ref<Int>, d:ref<Int>) -> ref<False> :
   val old-value = get(LIVE-OUT-BUFFER, b).value
   if d.value < old-value :
      if old-value == INT-MAX.value :
         add(BLOCK-OUT-BUFFER, b)
      set(LIVE-OUT-BUFFER, b, d)
      if get(BLOCK-DEFS, new Int{b.value * v.value}) == false :
         val d* = new Int{d.value + length(ins(get(BLOCKS, b))).value}
         mark-live-in(b, v, d*)
   return false

lostanza defn mark-live-in (b:ref<Int>, v:ref<Int>, d:ref<Int>) -> ref<False> :
   if get(LIVE-IN-BUFFER, b) == INT-MAX :
      add(BLOCK-IN-BUFFER, b)
   set(LIVE-IN-BUFFER, b, d)
   labels :
      begin :
         goto loop(get(PREDECESSORS, b))
      loop (preds:ref<List<Int>>) :
         match(preds) :
            (preds:ref<FullList<Int>>) :
               mark-live-out(head(preds), v, d)
               goto loop(tail(preds))
            (preds:ref<NilList>) :
               return false

defn print-indexed-prog () :
   println("VARS = %_" % [VAR-TYPES])
   for b in 0 to length(BLOCKS) do :
      println("Block %_" % [b])
      println("Predecessors: %_" % [PREDECESSORS[b]])
      println("Ins: %_" % [BLOCK-INS[b]])
      println(BLOCKS[b])
      println("Outs: %_" % [BLOCK-OUTS[b]])
      println("")


;============================================================
;=================== Save Emission ==========================
;============================================================

var NEW-REQUIRES-SAVE = BitArray(1024)
var NEW-PREFERS-LOAD = BitArray(1024, true)
var NEW-IS-LIVE = BitArray(1024)
val DIRTY-LIVE-LIST = Vector<Int>()
val INS-BUFFER = Vector<Ins>()

defn new-emit-early-saves (bi:Int) :
   ;Retrieve block
   val b = BLOCKS[bi]
   
   ;Clear algorithm state
   val nvars = length(VAR-TYPES)
   NEW-REQUIRES-SAVE = fresh-bit-array(NEW-REQUIRES-SAVE, nvars, false)
   NEW-PREFERS-LOAD = fresh-bit-array(NEW-PREFERS-LOAD, nvars, true)
   NEW-IS-LIVE = fresh-bit-array(NEW-IS-LIVE, nvars, false)
   clear(DIRTY-LIVE-LIST)
   clear(INS-BUFFER)

   ;Emit instructions to buffer
   defn emit (i:Ins) :
      add(INS-BUFFER, i)

   ;Mark variable as live
   defn mark-live (n:Int) :
      if not NEW-IS-LIVE[n] :
         add(DIRTY-LIVE-LIST, n)
         NEW-IS-LIVE[n] = true

   ;Mark out-going ports as live
   do(mark-live{n(_)}, BLOCK-OUTS[bi])

   ;Sweep through the instructions backwards
   for e in in-reverse(ins(b)) do :
      ;Save defined variables that need saving
      for x in e do-defined :
         if NEW-REQUIRES-SAVE[n(x)] :
            emit(Save(x as Var))

      ;Emit the instruction
      emit(e)

      ;Defined variables are no longer live
      ;If they are no longer live then no longer need saving
      ;And they no longer need loading
      for x in e do-defined :
         NEW-IS-LIVE[n(x)] = false
         NEW-REQUIRES-SAVE[n(x)] = false
         NEW-PREFERS-LOAD[n(x)] = false

      ;Any live variable that crosses a boundary
      ;needs to be saved. And does not prefer to be loaded.
      if e is Call :
         for x in DIRTY-LIVE-LIST remove-when :
            if NEW-IS-LIVE[x] :
               NEW-REQUIRES-SAVE[x] = true
               NEW-PREFERS-LOAD[x] = false
               false
            else : true

      ;Used variables prefer to be loaded and are live
      for x in e do-used :
         if x is Var :
            val n = n(x as Var)
            NEW-IS-LIVE[n] = true
            NEW-PREFERS-LOAD[n] = true

   ;Update block instructions
   clear(ins(b))
   add-all(ins(b), in-reverse(INS-BUFFER))

   ;Update block input ports
   BLOCK-INS[bi] = for x in BLOCK-INS[bi] map :
      val sv-x = true when NEW-REQUIRES-SAVE[n(x)] else Any()
      val ld-x = Any() when NEW-PREFERS-LOAD[n(x)] else false
      DPort(n(x), sv-x, ld-x, NoLoc(), dist(x))

defn new-emit-early-saves () :
   do(new-emit-early-saves, 0 to length(BLOCKS))


;============================================================
;================ Kill Use Annotations ======================
;============================================================

var USE-POS-BUFFER = Array<False|Int>(1024, false)
defn fresh-array<?T> (a:Array<?T>, n:Int, x:T) :
   if length(a) < n :
      Array<T>(n, x)
   else :
      set-all(a, 0 to n, x)
      a

defn fresh-bit-array (a:BitArray, n:Int, init:True|False) :
   if n < length(a) :
      clear(a, n, init)
      a
   else :
      val n* = max(2 * length(a), n)
      BitArray(n*, init)

defn give-killed (e:Ins, ks:List<Int>) :
   match(e) :
      (e:Set) : Set(x(e), y(e), ks)
      (e:Args) : Args(xs(e), ctxt(e), ks)
      (e:Return) : Return(xs(e), ctxt(e), ks)
      (e:Call) : Call(xs(e), f(e), ys(e), type(e), ks)
      (e:Op) : Op(op(e), xs(e), ys(e), ks)
      (e:Branch) : Branch(op(e), xs(e), ks)

defn kill-use-annotations (bi:Int) :
   ;Retrieve block
   val blk = BLOCKS[bi]

   ;Clear state
   val nvars = length(VAR-TYPES)
   USE-POS-BUFFER = fresh-array(USE-POS-BUFFER, nvars, false)
   NEW-REQUIRES-SAVE = fresh-bit-array(NEW-REQUIRES-SAVE, nvars, false)
   NEW-PREFERS-LOAD = fresh-bit-array(NEW-PREFERS-LOAD, nvars, true)
   NEW-IS-LIVE = fresh-bit-array(NEW-IS-LIVE, nvars, false)
   clear(DIRTY-LIVE-LIST)

   ;Clear instruction buffer
   clear(INS-BUFFER)
   defn emit (e:Ins) :
      println("emit %_" % [e])
      add(INS-BUFFER, e)

   ;Mark variable as live
   defn mark-live (n:Int) :
      if not NEW-IS-LIVE[n] :
         add(DIRTY-LIVE-LIST, n)
         NEW-IS-LIVE[n] = true

   ;Note usages of output ports
   val num-ins = length(ins(blk))
   for p in BLOCK-OUTS[bi] do :
      USE-POS-BUFFER[n(p)] = dist(p) + num-ins
      mark-live(n(p))

   ;Sweep through instructions backwards
   for (e in in-reverse(ins(blk)), i in (num-ins - 1) through 0 by -1) do :
      println("Sweeping through %_: %_" % [i, e])
      ;Unload live variables that do not need loading
      println("Unload live variables")
      defn unload (x:Imm) :
         match(x) :
            (x:Var) : 
               if NEW-IS-LIVE[n(x)] and not NEW-PREFERS-LOAD[n(x)] :
                  emit(Unload(x))
            (x) : false
      do-defined(unload, e)
      do-used(unload, e)

      ;Save defined variables that need saving
      println("Save defined variables")
      for x in e do-defined :
         if NEW-REQUIRES-SAVE[n(x)] :
            emit(Save(x))

      ;Kill variables that are defined but not used
      println("Kill unused defined variables")
      defn kill-unused (x:Var) :
         val d = USE-POS-BUFFER[n(x)]
         if d is False :
            emit(Kill(n(x)))
      do-defined(kill-unused, e)

      ;Note usages for defined and used variables
      println("Note usages")
      defn note-usage (x:Imm) :
         match(x) :
            (x:Var) :
               val d = USE-POS-BUFFER[n(x)]
               if d is Int :
                  emit(NextUsed(n(x), d as Int))
            (x) : false
      do-defined(note-usage, e)
      do-used(note-usage, e)

      ;Update the position buffer
      println("Update position buffer")
      defn mark-pos (x:Imm, d:Int|False) :
         match(x) :
            (x:Var) :
               println("Variable %_ used at position %_" % [n(x), d])
               USE-POS-BUFFER[n(x)] = d
            (x) : false
      do-defined(mark-pos, e, false)

      ;Compute killed
      println("Compute killed")
      var killed = List()
      for x in e do-used :
         match(x) :
            (x:Var) :
               if USE-POS-BUFFER[n(x)] is False :
                  killed = cons(n(x), killed)
            (x) : false
      ;Emit the instruction
      emit(give-killed(e, killed))

      ;Defined variables are no longer live
      ;If they are no longer live then no longer need saving
      ;And they no longer need loading
      for x in e do-defined :
         println("%_ is no longer live, requires saving, or loading" % [n(x)])
         NEW-IS-LIVE[n(x)] = false
         NEW-REQUIRES-SAVE[n(x)] = false
         NEW-PREFERS-LOAD[n(x)] = false

      ;Any live variable that crosses a boundary
      ;needs to be saved. And does not prefer to be loaded.
      if e is Call :
         for x in DIRTY-LIVE-LIST remove-when :
            if NEW-IS-LIVE[x] :
               println("%_ live across call boundary." % [x])
               NEW-REQUIRES-SAVE[x] = true
               NEW-PREFERS-LOAD[x] = false
               false
            else : true

      ;Used variables prefer to be loaded and are live
      for x in e do-used :
         if x is Var :
            val n = n(x as Var)
            mark-live(n)
            NEW-PREFERS-LOAD[n] = true
            println("Variable %_ is used and is now live and prefers loading." % [n])
      
      ;Update the position buffer
      do-used(mark-pos, e, i)
      
   ;Update block instructions
   clear(ins(blk))
   add-all(ins(blk), in-reverse(INS-BUFFER))

   ;Update block input ports
   BLOCK-INS[bi] = for x in BLOCK-INS[bi] map :
      val sv-x = true when NEW-REQUIRES-SAVE[n(x)] else Any()
      val ld-x = Any() when NEW-PREFERS-LOAD[n(x)] else false
      DPort(n(x), sv-x, ld-x, NoLoc(), dist(x))

defn kill-use-annotations () :
   do(kill-use-annotations, 0 to length(BLOCKS))


;============================================================
;====================== Working IR ==========================
;============================================================

;     Working Instructions
;     --------------------
deftype Working
defstruct Save <: Ins&Working :
   x: Var
defstruct Load <: Ins&Working :
   x: Var
defstruct Clear <: Ins&Working :
   x: Var
defstruct Unload <: Ins&Working :
   x: Var
defstruct NextUsed <: Ins&Working :
   n: Int
   pos: Int
defstruct Kill <: Ins&Working :
   n: Int
defstruct Xchg <: Ins&Working :
   x: Var
   y: Var
   swap: Reg|False
defstruct Glue <: Ins&Working :
   xs: List<Var>
   ys: List<Var>
defstruct Label <: Ins&Working :
   n: Int
defstruct Goto <: Ins&Working :
   n: Int
defstruct Break <: Ins&Working :
   n: Int
   op: tgt-TgtOp
   xs: List<Imm>
   flip?: True|False

defn cms (xs) : join(xs, ", ")
defmethod print (o:OutputStream, i:Ins&Working) :
   print{o, _} $ match(i) :
      (i:NextUsed) : "next used %_ at %_" % [n(i), pos(i)]
      (i:Kill) : "kill %_" % [n(i)]
      (i:Save) : "save %~" % [x(i)]
      (i:Load) : "load %~" % [x(i)]
      (i:Clear) : "clear %~" % [x(i)]
      (i:Unload) : "unload %~" % [x(i)]
      (i:Xchg) : "xchg %~ %~ through %~" % [x(i), y(i), swap(i)]
      (i:Glue) : "shuffle (%*) = (%*)" % [cms(xs(i)), cms(ys(i))]
      (i:Label) : "label<%~>" % [n(i)]
      (i:Goto) : "goto label<%~>" % [n(i)]
      (i:Break) : "break label<%~> when %~(%*) (flip:%~)" % [n(i), op(i), cms(xs(i)), flip?(i)]

;     Any Value
;     ---------
defstruct Any <: Equalable
defmethod equal? (a:Any, b:Any) :
   true
defmethod print (o:OutputStream, x:Any) :
   print(o, "any")

;     Port Definition
;     ---------------
deftype Port
defmulti n (p:Port) -> Int
defmulti saved? (p:Port) -> True|False|Any
defmulti loaded? (p:Port) -> True|False|Any
defmulti loc (p:Port) -> Loc
defmulti dist (p:Port) -> Int

defstruct EPort <: Port :
   n: Int with: (as-method => true)
   saved?: True|False|Any with: (as-method => true)
   loaded?: True|False|Any with: (as-method => true)
   loc: Loc with: (as-method => true)
with :
   constructor => Port

defmethod print (o:OutputStream, p:Port) :
   print(o, "%~ (s:%~, l:%~, at:%~)" % [n(p), saved?(p), loaded?(p), loc(p)])

defn DPort (n:Int, saved?:True|False|Any, loaded?:True|False|Any, loc:Loc, dist:Int) :
   new Port :
      defmethod n (this) : n
      defmethod saved? (this) : saved?
      defmethod loaded? (this) : loaded?
      defmethod loc (this) : loc
      defmethod dist (this) : dist
      defmethod print (o:OutputStream, this) :
         print(o, "%~ (s:%~, l:%~, at:%~, dist:%~)" % [n, saved?, loaded?, loc, dist])

;     Working Block
;     -------------
defstruct WBlock <: Block :
   n: Int with : (as-method => true)
   ins: Vector<Ins> with : (as-method => true)
   next: List<Int> with : (as-method => true)
   in: List<Port>
   out: List<Port>
   dist: List<Int>

defmethod print (o:OutputStream, b:WBlock) :
   val io = IndentedStream(o, 3)
   print(o, "block B%~ :" % [n(b)])
   print(io, "\nin: %*" % [cms(in(b))])
   for e in ins(b) do :
      print(io, "\n%~" % [e])
   print(io, "\nnext %*" % [cms(next(b))])
   print(io, "\nout: %*" % [cms(out(b))])
   print(io, "\ndist: %*" % [cms(dist(b))])

;     Useful Doers
;     ------------
defn* do-list<?T,?S> (f: (T, S) -> ?, xs:List<?T>, a:?S) -> False :
   match(xs) :
      (xs:FullList) :
         f(head(xs), a)
         do-list(f, tail(xs), a)
      (xs:NilList) : false
      
defn do-defined (f: Var -> False, e:Ins) :
   match(e) :
      (e:Set) : f(x(e))
      (e:Args) : do(f, xs(e))
      (e:Call) : do(f, xs(e))
      (e:Return) : false
      (e:Op) : do(f, xs(e))
      (e:Branch) : false
      (e:Save) : false
      (e:Load) : f(x(e))

defn do-defined<?T> (f: (Var, T) -> False, e:Ins, a:?T) :
   match(e) :
      (e:Set) : f(x(e), a)
      (e:Args) : do-list(f, xs(e), a)
      (e:Call) : do-list(f, xs(e), a)
      (e:Return) : false
      (e:Op) : do-list(f, xs(e), a)
      (e:Branch) : false
      (e:Save) : false
      (e:Load) : f(x(e), a)

defn do-used (g: Imm -> False, e:Ins) :
   match(e) :
      (e:Set) : g(y(e))
      (e:Args) : false
      (e:Call) : (g(f(e)), do(g, ys(e)))
      (e:Return) : do(g, xs(e))
      (e:Op) : do(g, ys(e))
      (e:Branch) : do(g, xs(e))
      (e:Save) : g(x(e))
      (e:Load) : false

defn do-used<?T> (g: (Imm, T) -> False, e:Ins, a:?T) :
   match(e) :
      (e:Set) : g(y(e), a)
      (e:Args) : false
      (e:Call) : (g(f(e), a), do-list(g, ys(e), a))
      (e:Return) : do-list(g, xs(e), a)
      (e:Op) : do-list(g, ys(e), a)
      (e:Branch) : do-list(g, xs(e), a)
      (e:Save) : g(x(e), a)
      (e:Load) : false

;============================================================
;==================== Block Liveness ========================
;============================================================

deftype LiveTable
defmulti record-length (t:LiveTable, b:Int, len:Int) -> False
defmulti add-def (t:LiveTable, b:Int, v:Int) -> False
defmulti add-use (t:LiveTable, b:Int, v:Int, d:Int) -> False
defmulti add-out (t:LiveTable, b:Int, v:Int, d:Int) -> True|False
defmulti do-ins (t:LiveTable, b:Int, f: (Int, Int) -> ?) -> False
defmulti do-outs (t:LiveTable, b:Int, f: (Int, Int) -> ?) -> False
defmulti add-predecessor (t:LiveTable, b:Int, p:Int) -> False
defmulti predecessors (t:LiveTable, b:Int) -> List<Int>
defmulti clear (t:LiveTable) -> False
defmulti in-vars (t:LiveTable, b:Int) -> Vector<Int>
defmulti in-dists (t:LiveTable, b:Int) -> Vector<Int>
defmulti out-vars (t:LiveTable, b:Int) -> Vector<Int>
defmulti out-dists (t:LiveTable, b:Int) -> Vector<Int>

defn #LiveTable () :
   val empty-vec = Vector<Int>(0)
   val ins-dists = IntTable<Vector<Int>>()
   val ins-vars = IntTable<Vector<Int>>()
   val outs-dists = IntTable<Vector<Int>>()
   val outs-vars = IntTable<Vector<Int>>()
   val ins-idx = DualIntTable<Int>()
   val outs-idx = DualIntTable<Int>()
   val defs-tab = DualIntTable<True>()
   val lengths = IntTable<Int>()
   val predecessors = IntTable<List<Int>>()
   val vec-pool = Vector<Vector<Int>>()
   var vecs-used = 0

   defn next-vec () :
      vecs-used = vecs-used + 1
      if vecs-used < length(vec-pool) :
         val v = vec-pool[vecs-used - 1]
         clear(v)
         v
      else :
         val v = Vector<Int>()
         add(vec-pool, v)
         v

   defn add-out (b:Int, v:Int, d:Int) -> True|False :
      match(get?(outs-idx, b, v, false)) :
         (i:Int) :
            val dists = outs-dists[b]
            if d < dists[i] :
               dists[i] = d
               true
         (i:False) :
            if not key?(outs-dists, b) :
               outs-dists[b] = next-vec()
               outs-vars[b] = next-vec()
            val dists = outs-dists[b]
            add(outs-vars[b], v)
            add(dists, d)
            outs-idx[b, v] = length(dists) - 1
            true

   defn add-in (b:Int, v:Int, d:Int) -> False :
      match(get?(ins-idx, b, v, false)) :
         (i:Int) :
            val dists = ins-dists[b]
            if d < dists[i] :
               dists[i] = d
         (i:False) :
            if not key?(ins-dists, b) :
               ins-dists[b] = next-vec()
               ins-vars[b] = next-vec()
            val dists = ins-dists[b]
            add(ins-vars[b], v)
            add(dists, d)
            ins-idx[b, v] = length(dists) - 1

   defn def? (b:Int, v:Int) :
      key?(defs-tab, b, v)

   new LiveTable :
      defmethod clear (this) :
         clear(ins-dists)
         clear(ins-vars)
         clear(outs-dists)
         clear(outs-vars)
         clear(ins-idx)
         clear(outs-idx)
         clear(defs-tab)
         clear(lengths)
         clear(predecessors)
         vecs-used = 0

      defmethod record-length (this, b:Int, len:Int) :
         lengths[b] = len

      defmethod add-def (this, b:Int, v:Int) :
         defs-tab[b, v] = true

      defmethod add-use (this, b:Int, v:Int, d:Int) :
         if not def?(b, v) :
            add-in(b, v, d)

      defmethod add-out (this, b:Int, v:Int, d:Int) :
         if add-out(b, v, d) :
            if not def?(b, v) :
               add-in(b, v, d + lengths[b])
            true

      defmethod do-ins (this, b:Int, f: (Int, Int) -> ?) -> False :
         if key?(ins-vars, b) :
            do(f, ins-vars[b], ins-dists[b])

      defmethod do-outs (this, b:Int, f: (Int, Int) -> ?) -> False :
         if key?(outs-vars, b) :
            do(f, outs-vars[b], outs-dists[b])

      defmethod in-vars (this, b:Int) :
         ins-vars[b] when key?(ins-vars, b) else empty-vec

      defmethod in-dists (this, b:Int) :
         ins-dists[b] when key?(ins-dists, b) else empty-vec

      defmethod out-vars (this, b:Int) :
         outs-vars[b] when key?(outs-vars, b) else empty-vec

      defmethod out-dists (this, b:Int) :
         outs-dists[b] when key?(outs-dists, b) else empty-vec

      defmethod add-predecessor (this, b:Int, p:Int) :
         predecessors[b] = cons(p, get?(predecessors, b, List()))

      defmethod predecessors (this, b:Int) :
         get?(predecessors, b, List())


val LIVE-TABLE = #LiveTable()
defn LiveTable () :
   clear(LIVE-TABLE)
   LIVE-TABLE

val liveness-gather-timer = MillisecondTimer("Liveness Gather")
val liveness-propagation-timer = MillisecondTimer("Liveness Propagation")
val liveness-collect-timer = MillisecondTimer("Liveness Collection")

defn analyze-liveness (u:Unit) :
   ;     Gathering Summaries
   ;     -------------------
   val table = LiveTable()

   ;Gather
   start(liveness-gather-timer)
   for b in blocks(u) do :
      for (e in ins(b), i in 0 to false) do :
         for v in e do-used :
            if v is Var :
               add-use(table, n(b), n(v as Var), i)
         for v in e do-defined :
            add-def(table, n(b), n(v))
      record-length(table, n(b), length(ins(b)))
      for s in next(b) do :
         add-predecessor(table, s, n(b))
   stop(liveness-gather-timer)

   ;Propagation
   start(liveness-propagation-timer)
   val ordered-blocks = post-order(blocks(u), false)
   fixpoint $ fn (progress) :
      for blk in ordered-blocks do :
         ;Original:
         ;   for p in predecessors(table, n(blk)) do :
         ;      do-ins{table, n(blk), _} $ fn (v, d) :
         ;         if add-out(table, p, v, d) :
         ;            progress()
         ;Optimized:
         defn* do-preds (ps:List<Int>) :
            if not empty?(ps) :
               val p = head(ps)
               add-outs(p, 0, in-vars(table, n(blk)), in-dists(table, n(blk)))
               do-preds(tail(ps))
         defn* add-outs (b:Int, i:Int, vars:Vector<Int>, dists:Vector<Int>) :
            if i < length(vars) :
               if add-out(table, b, vars[i], dists[i]) :
                  progress()
               add-outs(b, i + 1, vars, dists)
         do-preds(predecessors(table, n(blk)))
   stop(liveness-propagation-timer)

   ;Collect Results
   start(liveness-collect-timer)
   defn to-port (x:Int) :
      Port(x, Any(), Any(), NoLoc())
   val blocks* = for b in blocks(u) map<Block> :
      var in-ports = List()
      var out-ports = List()
      var dists = List()

      ;Original:
      ;   do-ins{table, n(b), _} $ fn (v, d) :
      ;      in-ports = cons(to-port(v), in-ports)
      ;   do-outs{table, n(b), _} $ fn (v, d) :
      ;      out-ports = cons(to-port(v), out-ports)
      ;      dists = cons(d, dists)
      ;Optimized:
      defn* add-ins (i:Int, vars:Vector<Int>) :
         if i < length(vars) :
            in-ports = cons(to-port(vars[i]), in-ports)
            add-ins(i + 1, vars)
      defn* add-outs (i:Int, vars:Vector<Int>, ds:Vector<Int>) :
         if i < length(vars) :
            out-ports = cons(to-port(vars[i]), out-ports)
            dists = cons(ds[i], dists)
            add-outs(i + 1, vars, ds)
      add-ins(0, in-vars(table, n(b)))
      add-outs(0, out-vars(table, n(b)), out-dists(table, n(b)))

      WBlock(n(b), ins(b), next(b), in-ports, out-ports, dists)
   stop(liveness-collect-timer)

   Unit(defs(u), blocks*)


;                             Position Marker
;                             ===============

defstruct Pos :
   index: Int
   mid?: True|False


defn hash (p:Pos) :
   match(mid?(p)) :
      (m:True) : index(p) * 2 + 1
      (m:False) : index(p) * 2

defn less? (a:Pos, b:Pos) :
   hash(a) < hash(b)

defn less-eq? (a:Pos, b:Pos) :
   hash(a) <= hash(b)

defmethod print (o:OutputStream, p:Pos) :
   print(o, "%_%_" % [
      index(p),
      ".5" when mid?(p) else ""])



;                             List Table
;                             ==========

deftype ListTable<V>
defmulti get<?V> (t:ListTable<?V>, k:Int) -> Collection<V>
defmulti get<?V> (t:ListTable<?V>, k:Int, i:Int) -> V
defmulti add<?V> (t:ListTable<?V>, k:Int, v:V) -> False
defmulti length (t:ListTable, k:Int) -> Int
defmulti clear (t:ListTable) -> False

defn ListTable<V> () :
   val item-table = DualIntTable<V>()
   val len-table = IntTable<Int>()

   new ListTable<V> :
      defmethod get (this, k:Int, i:Int) :
         if (i < 0) or (i >= len-table[k]) :
            fatal("Index %_ out of bounds." % [i])
         item-table[k, i]

      defmethod get (this, k:Int) :
         match(get?(len-table, k, false)) :
            (n:Int) :
               new Collection<V> :
                  defmethod to-seq (this) :
                     for i in 0 to n seq :
                        item-table[k, i]
            (n:False) :
               List()

      defmethod add (this, k:Int, v:V) :
         val n = length(this, k)
         item-table[k,n] = v
         len-table[k] = n + 1

      defmethod length (this, k:Int) :
         get?(len-table, k, 0)

      defmethod clear (this) :
         clear(item-table)
         clear(len-table)


;                             Usage Table
;                             ===========

;     Interface
;     ---------
deftype UsageTable
defmulti order-by-usage (t:UsageTable, xs:Seqable<Int>, p:Pos) -> Seq<Int>

;     Type of Usage
;     -------------
deftype Usage
defmulti pos (u:Usage) -> Pos
defstruct UsedUsage <: Usage : (pos:Pos with: (as-method => true))
defstruct KillUsage <: Usage : (pos:Pos with: (as-method => true))

;     Analysis
;     --------
val USAGES = ListTable<Usage>()
val ORDERING-BUFFER = Vector<Int>()

defn usage-table (b:WBlock) :
   ;     Computing List of Usages
   ;     ------------------------
   clear(USAGES)

   defn add-usage (x:Int|Imm|Port, u:Usage) :
      match(x) :
         (x:Int) : add(USAGES, x, u)
         (x:Var) : add-usage(n(x), u)
         (x:Port) : add-usage(n(x), u)
         (x) : false

   for (e in ins(b), i in 0 to false) do :
      if e is-not Save :
         for x in e do-used :
            add-usage(x, UsedUsage(Pos(i, false)))
      for x in e do-defined :
         add-usage(x, KillUsage(Pos(i, true)))

   val n = length(ins(b))
   for (x in out(b), d in dist(b)) do :
      add-usage(x, UsedUsage(Pos(d + n, false)))


   ;     Order by Distance
   ;     -----------------
   defn use-pos (x:Int, p:Pos) :
      val use = find({p <= pos(_)}, USAGES[x])
      match(use) :
         (use:UsedUsage) :
            index(pos(use))
         (use:KillUsage|False) :
            fatal("Variable %_ is not used after %_." % [x, p])

   new UsageTable :
      defmethod order-by-usage (this, xs:Seqable<Int>, p:Pos) :
         clear(ORDERING-BUFFER)
         for x in xs do : add(ORDERING-BUFFER, x)
         qsort!(use-pos{_, p}, ORDERING-BUFFER)
         in-reverse(ORDERING-BUFFER)


;============================================================
;=================== Release Table ==========================
;============================================================

;     Interface
;     ---------
deftype ReleaseTable
defmulti get (t:ReleaseTable, a:Pos, b:Pos) -> Collection<Int>

;     Analysis
;     --------

val LOAD-TABLE = IntTable<True|False>()
val RELEASE-LIST = Vector<KeyValue<Pos,Int>>()

defn release-table (b:WBlock) :
   ;     Computing Releases and Positions
   ;     --------------------------------
   clear(LOAD-TABLE)
   clear(RELEASE-LIST)

   defn clear-loaded () :
      clear(LOAD-TABLE)

   defn mark-loaded (x:Int|Imm, v:True|False) :
      match(x) :
         (x:Int) : LOAD-TABLE[x] = v
         (x:Var) : LOAD-TABLE[n(x)] = v
         (x) : false

   defn release-if-not-loaded (p:Pos, x:Int|Imm) :
      match(x) :
         (x:Int) :
            if not get?(LOAD-TABLE, x, false) :
               add(RELEASE-LIST, p => x)
         (x:Var) : release-if-not-loaded(p, n(x))
         (x) : false

   ;Initialize live-out as live
   for x in out(b) do :
      mark-loaded(n(x), true) when loaded?(x) is-not False

   ;Analyze expression list
   val n = length(ins(b))
   for (e in in-reverse(ins(b)), i in (n - 1) through 0 by -1) do :
      for x in e do-defined :
         release-if-not-loaded(Pos(i + 1, false), x)
         mark-loaded(x, false)
      clear-loaded() when e is Call
      for x in e do-used :
         release-if-not-loaded(Pos(i, true), x)
         mark-loaded(x, true)
   reverse!(RELEASE-LIST)

   ;     Compute releases to a given position
   ;     ------------------------------------
   var cached-pos = Pos(0, false)
   var cached-i = 0
   defn pos-index (p:Pos) :
      defn* loop (i:Int) :
         if i < length(RELEASE-LIST) :
            val r = RELEASE-LIST[i]
            if p < key(r) : i
            else : loop(i + 1)
         else : i
      ;Optimization
      cached-i =
         if cached-pos <= p : loop(cached-i)
         else : loop(0)
      cached-pos = p
      cached-i

   new ReleaseTable :
      defmethod get (this, a:Pos, b:Pos) :
         val ai = pos-index(a)
         val bi = pos-index(b)
         new Collection<Int> :
            defmethod to-seq (this) :
               for i in ai to bi seq :
                  value(RELEASE-LIST[i])

      defmethod print (o:OutputStream, this) :
         val io = IndentedStream(o, 3)
         print(o, "Release Table:")
         for i in 0 to length(ins(b)) do :
            print("\nInstruction: %_" % [ins(b)[i]])
            print("\n   Before Def: %*" % [cms(this[Pos(i,false), Pos(i,true)])])
            print("\n   After Def: %*" % [cms(this[Pos(i,true), Pos(i + 1, false)])])


;============================================================
;=================== Save Emission ==========================
;============================================================

val REQUIRES-SAVE = IntTable<True|False>()
val PREFERS-LOAD = IntTable<True|False>()
val IS-LIVE = IntTable<True|False>()

defn emit-early-saves (b:WBlock) :
   ;Algorithm state
   clear(REQUIRES-SAVE)
   clear(PREFERS-LOAD)
   clear(IS-LIVE)
   val output = Vector<Ins>()

   defn emit (i:Ins) :
      add(output, i)

   ;Overall algorithm
   for p in out(b) do :
      IS-LIVE[n(p)] = true

   for e in in-reverse(ins(b)) do :
      for x in e do-defined :
         if get?(REQUIRES-SAVE, n(x), false) :
            emit(Save(x as Var))
 
      emit(e)

      for x in e do-defined :
         IS-LIVE[n(x)] = false
         REQUIRES-SAVE[n(x)] = false
         PREFERS-LOAD[n(x)] = false

      if e is Call :
         val live = seq(key, filter(value, IS-LIVE))
         for x in live do :
            REQUIRES-SAVE[x] = true
            PREFERS-LOAD[x] = false

      for x in e do-used :
         if x is Var :
            val n = n(x as Var)
            IS-LIVE[n] = true
            PREFERS-LOAD[n] = true

   ;Entry ports
   val in* = for x in in(b) map :
      val sv = get?(REQUIRES-SAVE, n(x), false)
      val ld = get?(PREFERS-LOAD, n(x), true)
      val sv-x = true when sv else Any()
      val ld-x = Any() when ld else false
      Port(n(x), sv-x, ld-x, NoLoc())

   ;Result
   reverse!(output)
   WBlock(n(b),
          output,
          next(b),
          in*,
          out(b),
          dist(b))

;============================================================
;================== Class Allocation ========================
;============================================================

;     Allocate classes
;     ----------------

val SAVED = IntTable<True|False|Any>()
val LOADED = IntTable<True|False|Any>()
val PROJ-LOADED = IntTable<True|False>()

val spill-calc-timer = MillisecondTimer("Calc Spill")
val spill-reg-timer = MillisecondTimer("Spill Registers")
val usage-table-timer = MillisecondTimer("Usage Table")
val release-table-timer = MillisecondTimer("Release Table")
val allocate-sweep-timer = MillisecondTimer("Allocate Sweep")

defn allocate-classes (tt:HashTable<Int,tgt-TgtType>, b:WBlock, backend:Backend) -> WBlock :
   ;     Layer 1
   ;     -------
   ;Algorithm state
   clear(SAVED)
   clear(LOADED)
   var num-free-reg = num-regs(backend)
   var num-free-freg = num-fregs(backend)

   val output = Vector<Ins>()

   defn print-regs () :
      println("%_ Regs Available. %_ FRegs Available." % [num-free-reg, num-free-freg])

   ;Utilities
   defn inc-reg (n:Int, t:tgt-TgtType) :
      if tgt-int?(t) : num-free-reg = num-free-reg + n
      else if tgt-float?(t) : num-free-freg = num-free-freg + n
      else : fatal("Unreachable")

   ;Raw Fundamental Language
   defn emit (i:Ins) :
      add(output, i)

   defn kill (x:Int) :
      ;Increment number of registers available, if it was taking up a register
      if LOADED[x] is True|Any :
         inc-reg(1, tt[x])
      LOADED[x] = false

;      println("Killed %_" % [x])
;      print-regs()

   defn save (x:Int) :
      match(SAVED[x]) :
         (s:True) : false
         (s:False|Any) : emit(Save(Var(x)))
      SAVED[x] = true

;      println("Save %_" % [x])
;      print-regs()

   defn load (x:Int) :
      match(LOADED[x]) :
         (l:True) : false
         (l:False) :
            emit(Load(Var(x)))
            inc-reg(-1, tt[x])
         (l:Any) :
            emit(Load(Var(x)))
      LOADED[x] = true

;      println("Load %_" % [x])
;      print-regs()

   defn unload (x:Int) :
      match(LOADED[x]) :
         (l:True|Any) :
            emit(Unload(Var(x)))
            inc-reg(1, tt[x])
         (l:False) : false
      LOADED[x] = false

;      println("Unload %_" % [x])
;      print-regs()

   defn define (x:Var) :
      val n = n(x)
      LOADED[n] = true
      SAVED[n] = false
      inc-reg(-1, tt[n])

;      println("Define %_" % [x])
;      print-regs()

   defn define (x:Port) :
      LOADED[n(x)] = loaded?(x) as False|Any
      SAVED[n(x)] = saved?(x) as True|Any
      inc-reg(-1, tt[n(x)]) when loaded?(x) is Any

;      println("Define %_" % [x])
;      print-regs()

   defn currently-loaded () :
      seq{key, _} $
      for e in LOADED filter :
         value(e) is True|Any

   ;Convenience
   defn save (x:Var) : save(n(x))
   defn load (x:Imm) : load(n(x as Var)) when x is Var
   defn load (xs:Seqable<Imm>) : do(load, xs)
   defn kill (xs:Seqable<Int>) : do(kill, xs)
   defn define (xs:Seqable<Var>) : do(define, xs)
   defn define (xs:Seqable<Port>) : do(define, xs)


   ;                Layer 2
   ;                =======
   defn num-spills-required (used:Seqable<Imm>,
                             released:Seqable<Int>,
                             defined:List<Var>) :
      start(spill-calc-timer)                       
      ;Track whether a variable is projected to be loaded
      clear(PROJ-LOADED)
      defn proj-loaded? (x:Int) :
         if key?(PROJ-LOADED, x) : PROJ-LOADED[x]
         else : LOADED[x] is-not False

      ;Track the net use count
      var net-reg-use:Int = 0
      var net-freg-use:Int = 0
      var peak-reg-use:Int = 0
      var peak-freg-use:Int = 0

      defn inc-reg-use (n:Int, t:tgt-TgtType) :
         if tgt-int?(t) :
            net-reg-use = net-reg-use + n
            peak-reg-use = max(peak-reg-use, net-reg-use)
         else if tgt-float?(t) :
            net-freg-use = net-freg-use + n
            peak-freg-use = max(peak-freg-use, net-freg-use)
         else : fatal("Unreachable")

      ;Increment register use for used
      for u in used do :
         if u is Var :
            val u = u as Var
            if not proj-loaded?(n(u)) :
               PROJ-LOADED[n(u)] = true
               inc-reg-use(1, tt[n(u)])

      ;Decrement register use for released
      for r in released do :
         if proj-loaded?(r) :
            PROJ-LOADED[r] = false
            inc-reg-use(-1, tt[r])

      ;Increment register use for defined
      for d in defined do :
         inc-reg-use(1, tt[n(d)])

      ;Return number of spills needed of each type
      val num-spills = max(0, peak-reg-use - num-free-reg)
      val num-fspills = max(0, peak-freg-use - num-free-freg)
      stop(spill-calc-timer)
      [num-spills, num-fspills]

   start(usage-table-timer)
   val ut = usage-table(b)
   stop(usage-table-timer)
   
   defn spill (p:Pos, nr:Int, nf:Int) :
      start(spill-reg-timer)
      if (nr > 0) or (nf > 0) :
         ;Get the currently loaded variables ordered by
         ;distance to usage (farthest first).
         val vs = order-by-usage(ut, currently-loaded(), p)

         ;Track the number of each type to spill
         var num-r = nr
         var num-f = nf
         var total = nr + nf

         ;Spill until we've spilled the total number
         while total > 0 :
            val v = next(vs)
            if tgt-int?(tt[v]) and num-r > 0 :
               save(v)
               unload(v)
               num-r = num-r - 1
               total = total - 1
            else if tgt-float?(tt[v]) and num-f > 0 :
               save(v)
               unload(v)
               num-f = num-f - 1
               total = total - 1
      stop(spill-reg-timer)         

   defn spill-overcommitted (p:Pos) :
      val nr = max(0, (- num-free-reg))
      val nf = max(0, (- num-free-freg))
      spill(p, nr, nf)

   ;     Layer 3
   ;     -------
   ;Define incoming ports
   define(in(b))
   spill-overcommitted(Pos(0, false))

   ;Iterate through block instructions
   start(release-table-timer)
   val rt = release-table(b)
   stop(release-table-timer)

   start(allocate-sweep-timer)
   for (e in ins(b), i in 0 to false) do :
      match(e) :
         (e:Set) :
            val rs = rt[Pos(i,false), Pos(i,true)]
            val [nr,nf] = num-spills-required(List(y(e)), rs, List(x(e)))
            spill(Pos(i,false), nr, nf)
            load(y(e))
            kill(rs)
            define(x(e))
            emit(e)
         (e:Op) :
            val rs = rt[Pos(i,false), Pos(i,true)]
            val [nr,nf] = num-spills-required(ys(e), rs, xs(e))
            spill(Pos(i,false), nr, nf)
            load(ys(e))
            kill(rs)
            define(xs(e))
            emit(e)
         (e:Branch) :
            val rs = rt[Pos(i,false), Pos(i,true)]
            val [nr,nf] = num-spills-required(xs(e), rs, List())
            spill(Pos(i,false), nr, nf)
            load(xs(e))
            kill(rs)
            emit(e)
         (e:Return) :
            val rs = rt[Pos(i,false), Pos(i,true)]
            val [nr,nf] = num-spills-required(xs(e), rs, List())
            spill(Pos(i,false), nr, nf)
            load(xs(e))
            kill(rs)
            emit(e)
         (e:Save) :
            kill(rt[Pos(i,false), Pos(i,true)])
            save(x(e))
         (e:Args) :
            kill(rt[Pos(i,false), Pos(i,true)])
            emit(e)
            define(xs(e))
         (e:Call) :
            val rs = rt[Pos(i,false), Pos(i,true)]
            val [nr,nf] = num-spills-required(cons(f(e), ys(e)), rs, List())
            spill(Pos(i,false), nr, nf)
            load(f(e))
            load(ys(e))
            kill(rs)
            emit(e)
            define(xs(e))
      kill(rt[Pos(i,true), Pos(i + 1,false)])
   stop(allocate-sweep-timer)   

   ;Read state of outgoing ports
   val out* = for x in out(b) map :
      Port(n(x), SAVED[n(x)], LOADED[n(x)], loc(x))

   ;Return result
   WBlock(n(b), output, next(b),
          in(b), out*, dist(b))



;                    Assumption Propagation
;                    ======================

deftype Assumption
defstruct Accept <: Assumption
defstruct Assume <: Assumption : (value: True|False|Any)

val SAVE-ASSUMPTIONS = IntTable<Assumption>()
val LOAD-ASSUMPTIONS = IntTable<Assumption>()
defn propagate-assumptions (b:WBlock) :
   clear(SAVE-ASSUMPTIONS)
   clear(LOAD-ASSUMPTIONS)
   val output = Vector<Ins>()

   defn emit (i:Ins) :
      add(output, i)

   ;Incoming assumptions on ports
   for x in in(b) do :
      LOAD-ASSUMPTIONS[n(x)] = match(loaded?(x)) :
         (l:False) : Assume(l)
         (l:Any) : Accept()
      SAVE-ASSUMPTIONS[n(x)] = match(saved?(x)) :
         (s:True) : Assume(s)
         (s:Any) : Accept()

   ;Process assumptions on each instruction
   val instructions = to-seq(ins(b))
   while not empty?(instructions) :
      match(next(instructions)) :
         (e:Save) :
            val x = n(x(e))
            match(get?(SAVE-ASSUMPTIONS, x, false)) :
               (a:Accept) : SAVE-ASSUMPTIONS[x] = Assume(true)
               (a:Assume|False) : emit(Save(Var(x)))
         (e:Load) :
            val x = n(x(e))
            match(get?(LOAD-ASSUMPTIONS, x, false)) :
               (a:Accept) : LOAD-ASSUMPTIONS[x] = Assume(true)
               (a:Assume|False) : emit(Load(Var(x)))
         (e:Unload) :
            val x = n(x(e))
            match(get?(LOAD-ASSUMPTIONS, x, false)) :
               (a:Accept) : LOAD-ASSUMPTIONS[x] = Assume(false)
               (a:Assume|False) : false
         (e:Args|Call) :
            emit(e)
            for e in instructions do :
               emit(e) when e is-not Unload
         (e) :
            emit(e)
            for x in e do-defined :
               if get?(LOAD-ASSUMPTIONS, n(x), false) is Accept :
                  LOAD-ASSUMPTIONS[n(x)] = Assume(Any())
               if get?(SAVE-ASSUMPTIONS, n(x), false) is Accept :
                  SAVE-ASSUMPTIONS[n(x)] = Assume(Any())

   ;Propagated assumptions on ports
   val in* = for x in in(b) map :
      defn get-value (x:Assumption) :
         match(x) :
            (x:Assume) : value(x)
            (x:Accept) : Any()
      Port(n(x),
           get-value(SAVE-ASSUMPTIONS[n(x)]),
           get-value(LOAD-ASSUMPTIONS[n(x)]),
           loc(x))

   ;Return result
   WBlock(n(b), output, next(b),
          in*, out(b), dist(b))


;                      Register Assignment
;                      ===================

;     Assignment Mini-Language
;     ------------------------
defstruct FreeReg <: Loc :
   prefer: List<Int>

defn FreeReg () : FreeReg(List())

defmethod print (o:OutputStream, f:FreeReg) :
   print(o, "FreeReg(%*)" % [cms(prefer(f))])

;     Algorithm
;     ---------
val VAR-LOCS = IntTable<Loc>()
val REG-SLOTS = Vector<False|Int>()
val FREG-SLOTS = Vector<False|Int>()

defn register-assignment (tt:HashTable<Int,tgt-TgtType>,
                          backend:Backend,
                          b:WBlock,
                          ports-in:List<Port>) :
   ;     Layer 1
   ;     -------
   clear(VAR-LOCS)
   clear(REG-SLOTS)
   clear(FREG-SLOTS)
   for i in 0 to num-regs(backend) do :
      add(REG-SLOTS, false)
      add(FREG-SLOTS, false)

   val output = Vector<Ins>()

   ;Emitting updated instruction
   defn emit (i:Ins) :
      add(output, i)

   ;Fill variable with location
   defn fill<?T> (x:?T&(Imm|Port)) :
      val r = match(x) :
         (x:Var) :
            Var(n(x), VAR-LOCS[n(x)])
         (x:Port) :
            val loc = VAR-LOCS[n(x)]
            val sv = (saved?(x) is True) or (loc is Stack)
            val ld = loc is Reg|FReg
            Port(n(x), sv, ld, loc)
         (x) : x
      r as T&(Imm|Port)
   defn fill<?T> (xs:List<?T&(Imm|Port)>) -> List<T> :
      map(fill, xs)

   ;Free register for use
   defn free (x:Int) :
      match(VAR-LOCS[x]) :
         (loc:Reg) :
            REG-SLOTS[n(loc)] = false
            VAR-LOCS[x] = Stack(x)
         (loc:FReg) :
            FREG-SLOTS[n(loc)] = false
            VAR-LOCS[x] = Stack(x)
         (loc) : false
   defn free (xs:Seqable<Int>) :
      do(free, xs)

   ;Assign a value to a location
   defn assign (x:Int, l:Loc) :
      defn next-free-reg (int?:True|False, pref:List<Int>) :
         label<Reg|FReg> return :
            ;Differentiate between integer and floating point
            val slots = REG-SLOTS when int? else FREG-SLOTS
            defn XReg (i:Int) : Reg(i) when int? else FReg(i)
            ;Search through preferences first
            for r in pref do :
               return(XReg(r)) when slots[r] is False
            ;Otherwise return next free register
            XReg(index-of(slots, false) as Int)

      match(l) :
         (l:FreeReg) :
            val int? = tgt-int?(tt[x])
            assign(x, next-free-reg(int?, prefer(l)))
         (l:Stack) :
            VAR-LOCS[x] = l
         (l:Reg) :
            VAR-LOCS[x] = l
            REG-SLOTS[n(l)] = x
         (l:FReg) :
            VAR-LOCS[x] = l
            FREG-SLOTS[n(l)] = x

   defn assign (x:Port, l:Loc) : assign(n(x), l)
   defn assign (x:Var, l:Loc) : assign(n(x), l)

   defn assign (xs:List<Var|Port>, ls:List<Loc>) :
      ;First assign stacks and regs
      for (x in xs, l in ls) do :
         assign(x, l) when l is Stack|Reg|FReg
      ;Next assign free registers
      for (x in xs, l in ls) do :
         assign(x, l) when l is FreeReg


   ;     Layer 2
   ;     -------
   ;Helper: Swap contents from src to dst
   defn swap-reg (src:Int, dst:Int) :
      ;If the destination is free, then issue Set
      if REG-SLOTS[dst] is False :
         val x = REG-SLOTS[src] as Int
         emit(Set(Var(x, Reg(dst)), Var(x, Reg(src))))
         free(x)
         assign(x, Reg(dst))
      ;If the destination is not free, then issue Xchg
      else :
         defn free? (i:Int) :
            (i != src) and (i != dst) and
            (REG-SLOTS[i] is False)
         val x = REG-SLOTS[src] as Int
         val y = REG-SLOTS[dst] as Int
         val s = index-when(free?, 0 to length(REG-SLOTS))
         emit(Xchg(Var(x, Reg(src)), Var(y, Reg(dst)),
                   Reg(s as Int) when s is-not False))
         free(x)
         free(y)
         assign(x, Reg(dst))
         assign(y, Reg(src))

   ;Ensure that the given registers are free after release
   defn ensure-free-reg (reg:List<Int>, rs:Seqable<Int>) :
      defn* loop (reg:List<Int>, veto:List<Int>) :
         ;Will register r be free?
         defn free? (r:Int) :
            (REG-SLOTS[r] is False) or
            contains?(rs, REG-SLOTS[r])

         ;Find a free register that is not vetoed.
         defn free-reg () :
            label<Int> return :
               for i in 0 to length(REG-SLOTS) do :
                  if (not contains?(veto, i)) and
                     REG-SLOTS[i] is False :
                     return(i)
               for i in 0 to length(REG-SLOTS) find! :
                  (not contains?(veto, i)) and
                  contains?(rs, REG-SLOTS[i])

         if not empty?(reg) :
            val r = head(reg)
            if not free?(r) :
               swap-reg(r, free-reg())
            loop(tail(reg), cons(r, veto))
      loop(reg, List())

   ;Ensure that the following value is in a certain register
   defn ensure-reg (x:Int, r:Int) :
      val src = n(VAR-LOCS[x] as Reg)
      swap-reg(src, r) when src != r


   ;     Layer 3
   ;     -------
   ;Assign initial registers
   val in* = let :
      val pt = make-table(ports-in, n, loc, {_})
      val locs = for x in in(b) map :
         if not key?(pt, n(x)) :
            fatal("%~ not found in block %~" % [n(x), n(b)])
         match(loaded?(x), pt[n(x)]) :
            (ld:True, loc:Reg|FReg) : loc
            (ld:True, loc:Stack) : FreeReg()
            (ld:False, loc) : Stack(n(x))
            (ld:Any, loc) : loc
      assign(in(b), locs)
      fill(in(b))

   ;Assign concrete locations
   val rt = release-table(b)
   for (e in ins(b), i in 0 to false) do :
      ;Helper: Registers in given immediates
      defn reg? (x:Imm) :
         (x is Var) and
         loc(x as Var) is Reg|FReg
      defn reg! (x:Imm) :
         n(loc(x as Var) as Reg|FReg)

      defn regs-in (xs:List<Imm>) -> List<Int> :
         to-list(seq(reg!, filter(reg?, xs)))
      defn regs-in (x:Imm) -> List<Int> :
         if reg?(x) : List(reg!(x))
         else : List()

      match(e) :
         (e:Set) :
            val y* = fill(y(e))
            free(rt[Pos(i,false), Pos(i,true)])
            assign(x(e), FreeReg(regs-in(y*)))
            emit(Set(fill(x(e)), y*))
         (e:Op) :
            defn no-xs () :
               val ys* = fill(ys(e))
               free(rt[Pos(i,false), Pos(i,true)])
               emit(Op(op(e), List(), ys*))
            defn x-prefers-any () :
               val ys* = fill(ys(e))
               free(rt[Pos(i,false), Pos(i,true)])
               assign(head(xs(e)), FreeReg(regs-in(ys*)))
               emit(Op(op(e), fill(xs(e)), ys*))
            defn x-prefers-arg0 () :
               val ys* = fill(ys(e))
               free(rt[Pos(i,false), Pos(i,true)])
               assign(head(xs(e)), FreeReg(regs-in(head(ys*))))
               emit(Op(op(e), fill(xs(e)), ys*))
            defn x-no-preference () :
               val ys* = fill(ys(e))
               free(rt[Pos(i,false), Pos(i,true)])
               assign(head(xs(e)), FreeReg())
               emit(Op(op(e), fill(xs(e)), ys*))
            defn ignore () :
               free(rt[Pos(i,false), Pos(i,true)])
            defn x-reqs-r0-r3 () :
               ensure-free-reg(List(0,3), rt[Pos(i,false), Pos(i,true)])
               val ys* = fill(ys(e))
               free(rt[Pos(i,false), Pos(i,true)])
               assign(xs(e), List(Reg(0), Reg(3)))
               emit(Op(op(e), fill(xs(e)), ys*))
            defn z-in-r2 () :
               val z = ys(e)[1]
               ensure-reg(n(z as Var), 2) when z is Var
               x-prefers-arg0()

            match(op(e)) :
               (opc:tgt-LoadOp) : x-prefers-any()
               (opc:tgt-StoreOp) : no-xs()
               (opc:tgt-AddrOp) : x-prefers-any()
               (opc) :
                  switch {opc == _} :
                     tgt-ADD-OP : x-prefers-any()
                     tgt-SUB-OP : x-prefers-arg0()
                     tgt-MUL-OP : x-prefers-any()
                     tgt-DIV-OP : x-prefers-arg0()
                     tgt-AND-OP : x-prefers-any()
                     tgt-OR-OP : x-prefers-any()
                     tgt-XOR-OP : x-prefers-any()
                     tgt-NOT-OP : x-prefers-any()
                     tgt-NEG-OP : x-prefers-any()
                     tgt-SHL-OP : z-in-r2()
                     tgt-SHR-OP : z-in-r2()
                     tgt-ASHR-OP : z-in-r2()
                     tgt-EQ-OP : x-no-preference()
                     tgt-NE-OP : x-no-preference()
                     tgt-LT-OP : x-no-preference()
                     tgt-GT-OP : x-no-preference()
                     tgt-LE-OP : x-no-preference()
                     tgt-GE-OP : x-no-preference()
                     tgt-ULE-OP : x-no-preference()
                     tgt-ULT-OP : x-no-preference()
                     tgt-UGT-OP : x-no-preference()
                     tgt-UGE-OP : x-no-preference()
                     tgt-DIVMOD-OP : x-reqs-r0-r3()
                     tgt-CONV-OP : x-prefers-any()
                     tgt-INTERPRET-OP : x-prefers-any()
                     tgt-SWITCH-STACK-OP : no-xs()
                     tgt-ENTER-FROM-C : no-xs()
                     tgt-NO-OP : ignore()
         (e:Branch) :
            emit(Branch(op(e), fill(xs(e))))
            free(rt[Pos(i,false), Pos(i,true)])
         (e:Return) :
            emit(Return(fill(xs(e)), ctxt(e)))
            free(rt[Pos(i,false), Pos(i,true)])
         (e:Save) :
            emit(Save(fill(x(e))))
            free(rt[Pos(i,false), Pos(i,true)])
         (e:Load) :
            free(rt[Pos(i,false), Pos(i,true)])
            assign(x(e), FreeReg())
            emit(Load(fill(x(e))))
         (e:Args) :
            free(rt[Pos(i,false), Pos(i,true)])
            assign(xs(e), map(FreeReg{}, xs(e)))
            emit(Args(fill(xs(e)), ctxt(e)))
         (e:Call) :
            val f* = fill(f(e))
            val ys* = fill(ys(e))
            free(rt[Pos(i,false), Pos(i,true)])
            assign(xs(e), map(FreeReg{}, xs(e)))
            emit(Call(fill(xs(e)), f*, ys*, type(e)))

      ;Free any unused defines
      free(rt[Pos(i,true), Pos(i + 1,false)])

   ;Output locations
   val out* = fill(out(b))

   ;Return result
   WBlock(n(b), output, next(b),
          in*, out*, dist(b))


;Block stitching
defn register-assignment (tt:HashTable<Int,tgt-TgtType>, backend:Backend, p:Unit) :
   val block-table = make-table(blocks(p), n, {_ as False|WBlock}, {_})
   val blocks* = Vector<Block>()

   ;Assign registers to the given block
   defn assign-regs (b:WBlock, ports-in:List<Port>) :
      val b* = register-assignment(tt, backend, b, ports-in)
      add(blocks*, b*)
      block-table[n(b*)] = false
      b*

   ;Assign registers to successors
   defn* assign-successors (b:WBlock) :
      for n in next(b) do :
         match(block-table[n]) :
            (s:WBlock) : assign-successors(assign-regs(s, out(b)))
            (s:False) : false

   ;Driver
   val b0 = blocks(p)[0] as WBlock
   val b0* = assign-regs(b0, List())
   assign-successors(b0*)
   Unit(defs(p), blocks*)


;                   Register Assignment Verification
;                   ================================

defn verify-register-assignment (b:WBlock, backend:Backend) :
   ;     Layer 1
   ;     -------
   val regs = Array<False|Int>(num-regs(backend), false)
   val fregs = Array<False|Int>(num-fregs(backend), false)
   val saved = HashTable<Int,True|False>()

   ;Helper: Setting and Retrieving register contents
   defn get-reg (r:Reg|FReg) :
      match(r) :
         (r:Reg) : regs[n(r)]
         (r:FReg) : fregs[n(r)]

   defn set-reg (r:Reg|FReg, v:Int|False) :
      match(r) :
         (r:Reg) : regs[n(r)] = v
         (r:FReg) : fregs[n(r)] = v

   ;State updaters
   defn define (x:Port) :
      match(saved?(x), loaded?(x), loc(x)) :
         (sv:True, ld:True, loc:FReg|Reg) :
            set-reg(loc, n(x))
            saved[n(x)] = true
         (sv:False, ld:True, loc:FReg|Reg) :
            set-reg(loc, n(x))
            saved[n(x)] = false
         (sv:True, ld:False, loc:Stack) :
            saved[n(x)] = true
         (sv, ld, loc) :
            fatal("Unreachable combination: (%_, %_, %_)" % [sv, ld, loc])

   defn define (x:Var) :
      val r = loc(x) as FReg|Reg
      set-reg(r, n(x))
      saved[n(x)] = false

   defn mov (x:Var, y:Imm) :
      val r = loc(x) as FReg|Reg
      set-reg(r, n(x))
      match(y) :
         (y:Val) :
            saved[n(x)] = false
         (y:Var) :
            if n(x) != n(y) :
               saved[n(x)] = false

   defn load (x:Var) :
      val r = loc(x) as FReg|Reg
      set-reg(r, n(x))

   defn save (x:Var) :
      saved[n(x)] = true

   defn clear-registers () :
      for i in 0 to length(regs) do :
         regs[i] = false
      for i in 0 to length(fregs) do :
         fregs[i] = false

   defn xchg (x:Var, y:Var, s:Reg|FReg|False) :
      match(loc(x), loc(y), s) :
         (lx:Reg, ly:Reg, s:Reg|False) : false
         (lx:FReg, ly:FReg, s:FReg|False) : false
      val lx = loc(x) as Reg|FReg
      val ly = loc(y) as Reg|FReg
      val vx = get-reg(lx)
      val vy = get-reg(ly)
      set-reg(lx, vy)
      set-reg(ly, vx)
      set-reg(s as Reg|FReg, false) when s is-not False

   ;Checkers
   defn saved! (x:Int) :
      if saved[x] is-not True :
         fatal("%~ has not been saved." % [x])
   defn saved! (x:Var) : saved!(n(x))

   defn not-saved! (x:Int) :
      if saved[x] is-not False :
         fatal("%~ cannot be saved." % [x])

   defn holds! (r:FReg|Reg, x:Int) :
      val y = get-reg(r)
      if y != x :
         fatal("Block %_: Register %_ should hold %_ but holds %_." % [n(b), r, x, y])

   defn check! (p:Port) :
      match(saved?(p), loaded?(p), loc(p)) :
         (sv:True, ld:True, lc:FReg|Reg) :
            holds!(lc, n(p))
            saved!(n(p))
         (sv:False, ld:True, lc:FReg|Reg) :
            holds!(lc, n(p))
            not-saved!(n(p))
         (sv:True, ld:False, lc:Stack) :
            saved!(n(p))

   defn check! (x:Imm) :
      match(x) :
         (x:Var) :
            match(loc(x)) :
               (l:FReg|Reg) : holds!(l, n(x))
               (l:Stack) : saved!(n(x))
         (x:Val) : false

   ;     Layer 2
   ;     -------
   ;Input ports
   do(define, in(b))

   ;Check each instruction
   for e in ins(b) do :
      match(e) :
         (e:Set) :
            check!(y(e))
            mov(x(e), y(e))
         (e:Xchg) :
            check!(x(e))
            check!(y(e))
            xchg(x(e), y(e), swap(e))
         (e:Op) :
            do(check!, ys(e))
            do(define, xs(e))
         (e:Branch) :
            do(check!, xs(e))
         (e:Return) :
            do(check!, xs(e))
         (e:Save) :
            check!(x(e))
            save(x(e))
         (e:Load) :
            saved!(x(e))
            load(x(e))
         (e:Args) :
            do(define, xs(e))
         (e:Call) :
            check!(f(e))
            do(check!, ys(e))
            clear-registers()
            do(define, xs(e))

   ;Output ports
   do(check!, out(b))




;                    Stack Map Calculation
;                    =====================

;     Interval Structure
;     ------------------
deftype Interval
defstruct StartInterval <: Interval :
   n: Int
defstruct EndInterval <: Interval :
   n: Int

defmethod print (o:OutputStream, i:Interval) :
   print{o, _} $ match(i) :
      (i:StartInterval) : "Start(%_)" % [n(i)]
      (i:EndInterval) : "End(%_)" % [n(i)]


;     Calculating Stack Intervals
;     ---------------------------

defn stack-intervals (p:Unit) :
   ;     Interval State
   ;     --------------
   val var-start = HashTable<Int,Int>()
   val var-end = HashTable<Int,Int>()

   ;     Block Statistics
   ;     ----------------
   val block-table = HashTable<Int,WBlock>()
   val block-in = HashTable<Int,Int>()
   val block-out = HashTable<Int,Int>()

   ;     Note Usage of Variable
   ;     ----------------------
   defn note-usage (x:Int, i:Int) :
      if key?(var-start, x) :
         var-start[x] = min(i, var-start[x])
         var-end[x] = max(i, var-end[x])
      else :
         var-start[x] = i
         var-end[x] = i

   defn note-usage (x:Imm|Port, i:Int) :
      match(x) :
         (x:Port) :
            if saved?(x) is True :
               note-usage(n(x), i)
         (x:Var) :
            match(loc(x)) :
               (l:Stack) : note-usage(n(x), i)
               (l) : false
         (x) : false

   defn note-usage (e:Ins, i:Int) :
      match(e) :
         (e:Set) : note-usage(y(e), i)
         (e:Xchg) : false
         (e:Op) : false
         (e:Branch) : false
         (e:Return) : false
         (e:Save) : note-usage(n(x(e)), i)
         (e:Load) : note-usage(n(x(e)), i)
         (e:Args) : false
         (e:Call) : false

   ;     Note variable start and end stack usages
   ;     ----------------------------------------
   ;Note usages in instructions
   val ordered-blocks = reverse-post-order(blocks(p)) as Vector<WBlock>
   val ins-counter = to-seq(0 to false)
   for b in ordered-blocks as Vector<WBlock> do :
      block-table[n(b)] = b
      block-in[n(b)] = next(ins-counter)
      for e in ins(b) do :
         note-usage(e, next(ins-counter))
      block-out[n(b)] = next(ins-counter)
   val num-pos = next(ins-counter)

   ;Note usages in ports
   for b in ordered-blocks do :
      val port-indices = cons(
         block-out[n(b)]
         map({block-in[_]}, next(b)))
      defn note-usages (ps:Seqable<Port>) :
         for p in ps do :
            for i in port-indices do :
               note-usage(p, i)
      note-usages(out(b))
      for n in next(b) do :
         note-usages(in(block-table[n]))

   ;     Sort start and end intervals by position
   ;     ----------------------------------------
   val intervals = Array<List<Interval>>(num-pos, List())
   defn add-interval (i:Int, int:Interval) :
      intervals[i] = cons(int, intervals[i])
   for e in var-end do :
      add-interval(value(e), EndInterval(key(e)))
   for e in var-start do :
      add-interval(value(e), StartInterval(key(e)))
   cat-all(intervals)


;     Calculating Stack Map
;     ---------------------

;Interface
deftype StackMap
defmulti ref-offsets (s:StackMap) -> Seq<Int>
defmulti mask (s:StackMap) -> [Int, List<Long>]
defmulti offset (s:StackMap, x:Stack) -> Int
defmulti type (s:StackMap, n:Int) -> tgt-TgtType
defmulti location (s:StackMap, n:Int) -> Int
defmulti size (s:StackMap) -> Int

;Location Calculation
defn calculate-stack-map (tt:HashTable<Int,tgt-TgtType>, u:Unit) :
   ;     Assigning Stack Locations
   ;     -------------------------
   val occupied = Vector<False|True>()      ;(occupied[i] = true) => location i is occupied.
   val types = Vector<tgt-TgtType>()        ;type of location i = types[i]
   val var-locs = HashTable<Int,Int>({_})   ;(var-locs[x] = i) => variable x is at location i

   ;Get the next free location
   defn next-free-loc (t:tgt-TgtType) :
      defn to-int-type (t:tgt-TgtType) :
         if tgt-float?(t) : tgt-IntType(tgt-size(t))
         else : t
      label<Int> return :
         ;Get exemplar type
         val t* = to-int-type(t)
         ;Find unoccupied location
         val n = length(occupied)
         for i in 0 to n do :
            if (occupied[i] is False) and types[i] == t* :
               return(i)
         ;Or create a new location
         add(occupied, false)
         add(types, t*)
         n

   ;Assign stack locations to variables
   for i in stack-intervals(u) do :
      match(i) :
         (i:StartInterval) :
            val l = next-free-loc(tt[n(i)])
            var-locs[n(i)] = l
            occupied[l] = true
         (i:EndInterval) :
            val l = var-locs[n(i)]
            occupied[l] = false

   ;     Compute Stack Offsets
   ;     ---------------------
   ;Pad stack items
   ;item.data holds the location id
   val [items*, aln] = let :
      val items = Vector<Item>()
      for (t in types, i in 0 to false) do :
         add(items, Item(tgt-size(t), i))
      qsort!(alignment, items)
      pad(items, 8)

   ;Compute cumulative offsets
   var accum = 16 ;[Ret, Map]
   val offsets = Array<Int>(length(occupied)) ;(offsets[i] = off) => offset of location i is off
   for it in items* do :
      match(it) :
         (it:Item) :
            val i = data(it) as Int
            offsets[i] = accum
            accum = accum + alignment(it)
         (it:Padding) :
            accum = accum + size(it)
   if accum % 8 != 0 :
      fatal("Stack has not been padded to multiple of 8.")

   ;     Return table
   ;     ------------
   new StackMap :
      defmethod ref-offsets (this) :
         generate<Int> :
            for item in items* do :
               if item is Item :
                  val loc = data(item as Item) as Int
                  val t = types[loc]
                  yield(offsets[loc]) when t == tgt-REF-TYPE
      defmethod mask (this) :
         val stack-types = to-list $ for item in items* seq :
            match(item) :
               (item:Item) : types[data(item) as Int]
               (item:Padding) : tgt-IntType(size(item))
         val refs = tgt-ref-mask(stack-types)
         val bits = tgt-to-bitmask(refs)
         val n = length(refs)
         [n, bits]
      defmethod location (this, n:Int) :
         var-locs[n]
      defmethod type (this, n:Int) :
         types[location(this, n)]
      defmethod offset (this, x:Stack) :
         offsets[location(this, n(x))]
      defmethod size (this) :
         accum

;============================================================
;================= Enforce Clearing =========================
;============================================================

defn enforced-clearing (b:WBlock, smap:StackMap) :
   ;Live Stack Locations
   val loc-live? = HashTable<Int,True|False>(false)

   defn mark-live (n:Int) : loc-live?[location(smap, n)] = true
   defn mark-dead (n:Int) : loc-live?[location(smap, n)] = false

   ;Utilities
   defn ref-var? (x:Var) : type(smap, n(x)) == tgt-REF-TYPE
   defn var-live? (x:Var) : loc-live?[location(smap, n(x))]

   ;Initialize location liveness according to ports
   val saved-ports = filter({saved?(_) is True}, out(b))
   do(mark-live{n(_)}, saved-ports)

   ;Sweep through instructions in reverse
   val exps* = Vector<Ins>()
   for e in in-reverse(ins(b)) do :
      if e is Load :
         val e = e as Load
         if ref-var?(x(e)) and not var-live?(x(e)) :
            add(exps*, Clear(x(e)))
      add(exps*, e)
      match(e) :
         (e:Load) : mark-live(n(x(e)))
         (e:Save) : mark-dead(n(x(e)))
         (e:Set) : mark-dead(n(x(e))) when loc(x(e)) is Stack
         (e) : false

   ;Reverse the instructions
   reverse!(exps*)
   WBlock(n(b), exps*, next(b), in(b), out(b), dist(b))

defn enforced-clearing (u:Unit, smap:StackMap) :
   Unit(defs(u), map<WBlock>(enforced-clearing{_ as WBlock, smap}, blocks(u)))

;============================================================
;================= Block Collapsing =========================
;============================================================

defn collapse-blocks (u:Unit, smap:StackMap) :
   ;     Glue Port Discovery
   ;     -------------------
   val glue-entry = HashTable<Int, List<Port>>()
   val glue-exit = HashTable<Int, List<Port>>()
   val wblocks = blocks(u) as Vector<WBlock>
   val block-table = make-table(wblocks, n, {_}, {_})

   defn in-ports (n:Int) :
      in(block-table[n])

   val port-table = HashTable<Int,Port>()
   defn reorder (xs:List<Port>, ys:List<Port>) :
      clear(port-table)
      for x in xs do : port-table[n(x)] = x
      for y in ys map : port-table[n(y)]

   for b in wblocks do :
      if length(next(b)) == 1 :
         val nb = head(next(b))
         glue-exit[n(b)] = reorder(in-ports(nb), out(b))
      else if length(next(b)) > 1 :
         for n in next(b) do :
            glue-entry[n] = reorder(out(b), in-ports(n))

   ;     Instruction Emission
   ;     --------------------
   val output = Vector<Ins>()
   defn emit (i:Ins) :
      add(output, i)

   ;parallel xs = ys
   defn glue-ports (xs:List<Port>, ys:List<Port>) :
      ;Ensure ports properly reordered
      for (x in xs, y in ys) do :
         fatal("Ports improperly ordered") when n(x) != n(y)

      ;1. Emit any saves required
      for (x in xs, y in ys) do :
         match(saved?(x), saved?(y)) :
            (sx:True, sy:False) : emit(Save(Var(n(y), loc(y))))
            (sx, sy) : false

      ;2. Emit shuffles
      val xs* = Vector<Var>()
      val ys* = Vector<Var>()
      for (x in xs, y in ys) do :
         match(loc(x), loc(y)) :
            (lx:Reg|FReg, ly:Reg|FReg) :
               add(xs*, Var(n(x), lx))
               add(ys*, Var(n(y), ly))
            (lx, ly) : false
      emit(Glue(to-list(xs*), to-list(ys*)))

      ;3. Emit any loads required
      for (x in xs, y in ys) do :
         match(loaded?(x), loaded?(y)) :
            (lx:True, ly:False) : emit(Load(Var(n(x), loc(x))))
            (lx, ly) : false

      ;4. Emit any clears required
      for (x in xs, y in ys) do :
         match(saved?(x), saved?(y)) :
            (sx:False, sy:True) :
               val ref? = type(smap, n(x)) == tgt-REF-TYPE
               emit(Clear(Var(n(x)))) when ref?
            (sx, sy) : false

   for (b in wblocks, i in 0 to false) do :
      ;Check whether block n is upcoming
      defn upcoming? (b:Int) :
         if i < length(wblocks) - 1 :
            val upcoming = n(wblocks[i + 1])
            upcoming == b

      ;Emit block label
      emit(Label(n(b)))

      ;Emit entry glue
      if key?(glue-entry, n(b)) :
         glue-ports(in(b), glue-entry[n(b)])

      for e in ins(b) do :
         match(e) :
            (e:Branch) :
               val conseq = next(b)[0]
               val alt = next(b)[1]
               match(upcoming?(conseq), upcoming?(alt)) :
                  (fc:True, fa:False) :
                     emit(Break(alt, op(e), xs(e), true))
                  (fc:False, fa:True) :
                     emit(Break(conseq, op(e), xs(e), false))
                  (fc:False, fa:False) :
                     emit(Break(conseq, op(e), xs(e), false))
                     emit(Goto(alt))
            (e) :
               emit(e)

      ;Emit exit glue
      if key?(glue-exit, n(b)) :
         glue-ports(glue-exit[n(b)], out(b))

      ;Emit goto if necessary
      if length(next(b)) == 1 :
         val n = head(next(b))
         emit(Goto(n)) when not upcoming?(n)

   output


;                    Compilation to ASM
;                    ==================

;     Argument Value Language
;     -----------------------
deftype AVal
defmulti type (a:AVal) -> asm-AsmType
defstruct StackAV <: AVal :
   offset: Int
   type: asm-AsmType with: (as-method => true)
defstruct RegAV <: AVal :
   n: Int
   type: asm-AsmType with: (as-method => true)
defstruct FRegAV <: AVal :
   n: Int
   type: asm-AsmType with: (as-method => true)
defstruct RSPAV <: AVal
defstruct ImmAV <: AVal :
   value: Int|Long
   type: asm-AsmType with: (as-method => true)
defstruct NoneAV <: AVal :
   type: asm-AsmType with: (as-method => true)
defstruct MemAV <: AVal :
   n: Int
   offset: Int
defstruct ExMemAV <: AVal :
   name: Symbol
   offset: Int
defstruct Swap <: AVal :
   type: asm-AsmType with: (as-method => true)

defmethod type (x:RSPAV) : asm-LONG-TYPE
defmethod type (x:MemAV) : asm-LONG-TYPE
defmethod type (x:ExMemAV) : asm-LONG-TYPE

defn imm! (v:AVal) :
   match(v) :
      (v:RSPAV) : asm-RegSP()
      (v:RegAV) : asm-Reg(n(v))
      (v:FRegAV) : asm-FReg(n(v))
      (v:ImmAV) : asm-IntImm(value(v))
      (v:MemAV) : asm-Mem(n(v), offset(v))
      (v:ExMemAV) : asm-ExMem(name(v), offset(v))

defn loc! (v:AVal) :
   imm!(v) as asm-Loc

defmethod print (o:OutputStream, v:AVal) :
   print{o, _} $ match(v) :
      (v:StackAV) : "stk(%_,%_)" % [offset(v), type(v)]
      (v:RegAV) : "reg(%_,%_)" % [n(v), type(v)]
      (v:FRegAV) : "freg(%_,%_)" % [n(v), type(v)]
      (v:RSPAV) : "rsp"
      (v:ImmAV) : "imm(%_, %_)" % [value(v), type(v)]
      (v:NoneAV) : "none(%_)" % [type(v)]
      (v:MemAV) : "mem(%_ + %_)" % [n(v), offset(v)]
      (v:ExMemAV) : "mem(%_ + %_)" % [name(v), offset(v)]
      (v:Swap) : "swap(%_)" % [type(v)]

;     Compilation
;     -----------
defn compile (func-id:Int,
              tt:HashTable<Int,tgt-TgtType>,
              backend:Backend,
              ins:Vector<Ins>,
              stackmap:StackMap,
              output:Vector<asm-Ins>,
              infos:Vector<KeyValue<Int,FileInfo>>) -> False :

   ;     Output State
   ;     ------------
   defn emit (i:asm-Ins) :
      add(output, i)

   ;     Types Classification
   ;     --------------------
   defn int? (t:asm-AsmType) :
      contains?([asm-BYTE-TYPE, asm-INT-TYPE, asm-LONG-TYPE], t)
   defn float? (t:asm-AsmType) :
      contains?([asm-FLOAT-TYPE, asm-DOUBLE-TYPE], t)
   defn int? (x:AVal) : int?(type(x))
   defn float? (x:AVal) : float?(type(x))

   ;     Calling Convention
   ;     ------------------
   defn call-locations (xs:List<AVal>) :
      val regs = to-seq(call-regs(backend))
      val fregs = to-seq(call-fregs(backend))
      for x in xs map :
         if int?(x) : RegAV(next(regs), type(x))
         else : FRegAV(next(fregs), type(x))
   defn call-locations (f:AVal, xs:List<AVal>) :
      cons(RegAV(1, asm-LONG-TYPE), call-locations(xs))

   defn callc-locations (xs:List<AVal>) :
      val regs = to-seq(callc-regs(backend))
      val fregs = to-seq(callc-fregs(backend))
      for x in xs map :
         if int?(x) : RegAV(next(regs), type(x))
         else : FRegAV(next(fregs), type(x))
   defn callc-locations (f:AVal, xs:List<AVal>) :
      cons(RegAV(1, asm-LONG-TYPE), callc-locations(xs))
   defn callc-ret-locations (xs:List<AVal>) :
      fatal("Wrong number of returns.") when length(xs) > 1
      for x in xs map :
         if int?(x) : RegAV(0, type(x))
         else : FRegAV(0, type(x))

   defn carg-locations (xs:List<AVal>) :
      val [sp, args] = [head(xs), tail(xs)]
      cons(RegAV(6, type(sp))
           callc-locations(args))

   ;     Value Engine
   ;     ------------
   defn aval (x:Imm|Port) :
      defn asm-type (t:tgt-TgtType) :
         switch {t == _} :
            tgt-BYTE-TYPE : asm-BYTE-TYPE
            tgt-INT-TYPE : asm-INT-TYPE
            tgt-LONG-TYPE : asm-LONG-TYPE
            tgt-REF-TYPE : asm-LONG-TYPE
            tgt-FLOAT-TYPE : asm-FLOAT-TYPE
            tgt-DOUBLE-TYPE : asm-DOUBLE-TYPE

      match(x) :
         (x:Var|Port) :
            val t = asm-type(tt[n(x)])
            match(loc(x)) :
               (l:Reg) : RegAV(n(l), t)
               (l:FReg) : FRegAV(n(l), t)
               (l:Stack) : StackAV(offset(stackmap, l), t)
         (x:Val) :
            match(value(x)) :
               (x:tgt-ByteImm) : ImmAV(to-int(tgt-value(x)), asm-BYTE-TYPE)
               (x:tgt-IntImm) : ImmAV(tgt-value(x), asm-INT-TYPE)
               (x:tgt-LongImm) : ImmAV(tgt-value(x), asm-LONG-TYPE)
               (x:tgt-Mem) : MemAV(tgt-n(x), tgt-offset(x))
               (x:tgt-ExMem) : ExMemAV(tgt-name(x), tgt-offset(x))
               (x:tgt-RSP) : RSPAV()

   defn stack-aval (x:Var) :
      aval(Var(n(x), Stack(n(x))))

   defn to-asm-op (op:tgt-TgtOp) :
      switch {op == _} :
         tgt-ADD-OP : asm-ADD-OP
         tgt-SUB-OP : asm-SUB-OP
         tgt-MUL-OP : asm-MUL-OP
         tgt-DIV-OP : asm-DIV-OP
         tgt-MOD-OP : asm-MOD-OP
         tgt-AND-OP : asm-AND-OP
         tgt-OR-OP : asm-OR-OP
         tgt-XOR-OP : asm-XOR-OP
         tgt-SHL-OP : asm-SHL-OP
         tgt-SHR-OP : asm-SHR-OP
         tgt-ASHR-OP : asm-ASHR-OP
         tgt-EQ-OP : asm-EQ-OP
         tgt-NE-OP : asm-NE-OP
         tgt-LT-OP : asm-LT-OP
         tgt-GT-OP : asm-GT-OP
         tgt-LE-OP : asm-LE-OP
         tgt-GE-OP : asm-GE-OP
         tgt-ULE-OP : asm-ULE-OP
         tgt-ULT-OP : asm-ULT-OP
         tgt-UGT-OP : asm-UGT-OP
         tgt-UGE-OP : asm-UGE-OP
         tgt-NOT-OP : asm-NOT-OP
         tgt-NEG-OP : asm-NEG-OP

   defn av-mov (x:AVal, y:AVal) :
      defn mem-base (x:AVal) :
         match(x) :
            (x:StackAV) : asm-RegSP()
            (x:Swap) : asm-Mem(SWAP-LBL, 0)
      defn mem-offset (x:AVal) :
         match(x) :
            (x:StackAV) : offset(x)
            (x) : 0
      match(x, y) :
         (x:RSPAV|RegAV|FRegAV, y:RSPAV|RegAV|FRegAV|ImmAV|MemAV|ExMemAV) :
            emit(asm-SetIns(type(x), loc!(x), imm!(y)))
         (x:RSPAV|RegAV|FRegAV, y:StackAV|Swap) :
            emit(asm-Load(type(x), loc!(x), mem-base(y), mem-offset(y)))
         (x:StackAV|Swap, y:RSPAV|RegAV|FRegAV|ImmAV) :
            emit(asm-Store(type(y), mem-base(x), imm!(y), mem-offset(x)))
         (x, y) :
            fatal("Illegal mov: %_ = %_" % [x, y])

   defn av-binop (x:AVal, op:tgt-TgtOp, y:AVal, z:AVal) :
      emit(asm-BinOp(type(y), loc!(x), to-asm-op(op), imm!(y), imm!(z)))

   defn av-unaop (x:AVal, op:tgt-TgtOp, y:AVal) :
      emit(asm-UnaOp(type(y), loc!(x), to-asm-op(op), imm!(y)))

   defn av-add (x:AVal, y:AVal, z:AVal) :
      av-binop(x, tgt-ADD-OP, y, z)

   defn av-sub (x:AVal, y:AVal, z:AVal) :
      av-binop(x, tgt-SUB-OP, y, z)

   defn av-shl (x:AVal, y:AVal, z:AVal) :
      av-binop(x, tgt-SHL-OP, y, z)

   defn av-divmod (x1:AVal, x2:AVal, y:AVal, z:AVal) :
      emit(asm-DualOp(type(x1), loc!(x1), loc!(x2), asm-DIVMOD-OP, imm!(y), imm!(z)))

   defn av-load (v:AVal, a:AVal, o:Int) :
      emit(asm-Load(type(v), loc!(v), imm!(a), o))

   defn av-store (a:AVal, v:AVal, o:Int) :
      emit(asm-Store(type(v), imm!(a), imm!(v), o))

   defn av-conv (x:AVal, y:AVal) :
     emit(asm-ConvertIns(type(x), loc!(x), type(y), imm!(y)))

   defn av-interpret (x:AVal, y:AVal) :
     emit(asm-ReinterpretIns(type(x), loc!(x), type(y), imm!(y)))

   defn av-label (n:Int) :
     emit(asm-Label(n))

   defn av-goto (v:AVal) :
      emit(asm-Goto(imm!(v)))

   defn av-break (n:Int, op:tgt-TgtOp, x:AVal, y:AVal) :
      emit(asm-Branch(type(x), asm-Mem(n,0), to-asm-op(op), imm!(x), imm!(y)))

   defn av-long (v:Int) :
      ImmAV(v, asm-LONG-TYPE)

   defn av-return () :
      emit(asm-Return())

   defn av-call (f:AVal) :
      emit(asm-Call(imm!(f)))

   defn av-xchg (x:AVal, y:AVal) :
      emit(asm-XchgIns(loc!(x), loc!(y)))

   defn av-data () : emit(asm-DefData())
   defn av-text () : emit(asm-DefText())
   defn av-lit-long (i:Long) : emit(asm-DefLong(i))

   ;     Shuffle Engine
   ;     --------------
   val rxs = Vector<Int>()
   val rys = Vector<Int>()
   val fxs = Vector<Int>()
   val fys = Vector<Int>()
   val oxs = Vector<AVal>()
   val oys = Vector<AVal>()

   defn shuffle (int?:True|False, xs:List<Int>, ys:List<Int>, nreg:Int) :
      val LT = asm-LONG-TYPE
      val DT = asm-DOUBLE-TYPE
      stz/algorithms/shuffle{xs, ys, nreg, _} $ fn (i) :
         match(i) :
            (i:ShfMove) :
               if int? : av-mov(RegAV(dst(i), LT), RegAV(src(i), LT))
               else : av-mov(FRegAV(dst(i), DT), FRegAV(src(i), DT))
            (i:ShfSave) :
               if int? : av-mov(Swap(LT), RegAV(n(i), LT))
               else : av-mov(Swap(DT), FRegAV(n(i), DT))
            (i:ShfLoad) :
               if int? : av-mov(RegAV(n(i), LT), Swap(LT))
               else : av-mov(FRegAV(n(i), DT), Swap(DT))

   defn shuffle (xs:List<AVal>, ys:List<AVal>) :
      clear(rxs)
      clear(rys)
      clear(fxs)
      clear(fys)
      clear(oxs)
      clear(oys)
      for (x in xs, y in ys) do :
         match(x, y) :
            (x:RegAV, y:RegAV) :
               add(rxs, n(x))
               add(rys, n(y))
            (x:FRegAV, y:FRegAV) :
               add(fxs, n(x))
               add(fys, n(y))
            (x, y) :
               add(oxs, x)
               add(oys, y)
      shuffle(true, to-list(rxs), to-list(rys), num-regs(backend))
      shuffle(false, to-list(fxs), to-list(fys), num-fregs(backend))
      do(av-mov, oxs, oys)

   ;     Generate Header
   ;     ---------------
   val stack-map-id = fresh-id()
   let :
      val [n, bits] = mask(stackmap)
      av-data()
      av-label(stack-map-id)
      av-lit-long(to-long(n))
      do(av-lit-long, bits)
      av-text()
      av-label(func-id)

   ;     Convert Instructions
   ;     --------------------
   for e in ins do :
      match(e) :
         (e:Set) :
            av-mov(aval(x(e)), aval(y(e)))
         (e:Return) :
            val xs* = map(aval, xs(e))
            match(ctxt(e)) :
               (c:StanzaContext) :
                  val ts* = call-locations(xs*)
                  shuffle(ts*, xs*)
                  av-return()
               (c:CContext) :
                  ;Convenient registers
                  val RSP = RSPAV()
                  val R1 = RegAV(1, asm-LONG-TYPE)
                  val R6 = RegAV(6, asm-LONG-TYPE)
                  val R11 = RegAV(11, asm-LONG-TYPE)
                  val R12 = RegAV(12, asm-LONG-TYPE)
                  val R13 = RegAV(13, asm-LONG-TYPE)
                  val R14 = RegAV(14, asm-LONG-TYPE)

                  ;First argument is the stack pointer
                  val [sp, rets] = [head(xs*), tail(xs*)]
                  ;Restore c stack pointer
                  av-mov(RSP, sp)
                  ;Shuffle return arguments to correct location
                  shuffle(callc-ret-locations(rets), rets)
                  ;Restore C context
                  av-load(R1, RSP, -8)
                  av-load(R6, RSP, -16)
                  av-load(R11, RSP, -24)
                  av-load(R12, RSP, -32)
                  av-load(R13, RSP, -40)
                  av-load(R14, RSP, -48)
                  ;Return to C
                  av-return()
         (e:Op) :
            match(op(e)) :
               (op:tgt-LoadOp) :
                  val [x, y, o] = [xs(e)[0], ys(e)[0], tgt-offset(op)]
                  av-load(aval(x), aval(y), o)
               (op:tgt-StoreOp) :
                  val [x, y, o] = [ys(e)[0], ys(e)[1], tgt-offset(op)]
                  av-store(aval(x), aval(y), o)
               (op:tgt-AddrOp) :
                  val x = xs(e)[0]
                  av-mov(aval(x), MemAV(tgt-n(op), 0))
               (op) :
                  if op == tgt-DIVMOD-OP :
                     val [x1, x2, y, z] = [xs(e)[0], xs(e)[1], ys(e)[0], ys(e)[1]]
                     av-divmod(aval(x1), aval(x2), aval(y), aval(z))

                  else if op == tgt-CONV-OP :
                     val [x, y] = [head(xs(e)), head(ys(e))]
                     av-conv(aval(x), aval(y))

                  else if op == tgt-INTERPRET-OP :
                     val [x, y] = [head(xs(e)), head(ys(e))]
                     av-interpret(aval(x), aval(y))

                  else if op == tgt-SWITCH-STACK-OP :
                     val R0 = RegAV(0, asm-LONG-TYPE)
                     val R1 = RegAV(1, asm-LONG-TYPE)
                     val RSP = RSPAV()

                     ;1. Decrement number of free stacks
                     av-load(R0, MemAV(NUM-FREE-STACKS-LBL,0), 0)
                     av-sub(R0, R0, av-long(1))
                     av-store(MemAV(NUM-FREE-STACKS-LBL,0), R0, 0)

                     ;2. Retrieve the next free stack
                     ;R0 = next free stack
                     ;temporary R1 = stack pool
                     av-load(R1, MemAV(FREE-STACKS-LBL,0), 0)
                     av-load(R0, R1, 0)
                     av-add(R1, R1, av-long(8))
                     av-store(MemAV(FREE-STACKS-LBL,0), R1, 0)

                     ;3. Cap the current stack. Set current stack as parent of new stack.
                     ;R1 = current stack
                     ;preserve R0 = free stack
                     av-load(R1, MemAV(STACK-LBL,0), 0)
                     av-store(R1, RSP, STACK-SP-OFFSET - REF-TAG-BITS)
                     av-store(R0, R1, STACK-PARENT-OFFSET - REF-TAG-BITS)

                     ;4. update the current stack and limits
                     ;preserve R0 = free stack
                     ;temporary R1 = stack limit
                     ;Update stack register
                     av-add(RSP, R0, av-long(STACK-ITEMS-OFFSET - REF-TAG-BITS))
                     ;Update stack limit, and current stack
                     av-add(R1, R0, av-long(STACK-SIZE - REF-TAG-BITS))
                     av-store(MemAV(STACK-LIM-LBL,0), R1, 0)
                     av-store(MemAV(STACK-LBL,0), R0, 0)
                     ;Intercept return code
                     av-mov(R1, MemAV(RETRACT-STACK-LBL,0))
                     av-store(RSP, R1, 0)

                  else if op == tgt-ENTER-FROM-C :
                     val RSP = RSPAV()
                     val R1 = RegAV(1, asm-LONG-TYPE)
                     val R6 = RegAV(6, asm-LONG-TYPE)
                     val R11 = RegAV(11, asm-LONG-TYPE)
                     val R12 = RegAV(12, asm-LONG-TYPE)
                     val R13 = RegAV(13, asm-LONG-TYPE)
                     val R14 = RegAV(14, asm-LONG-TYPE)

                     ;Store C preserved registers
                     av-store(RSP, R1, -8)
                     av-store(RSP, R6, -16)
                     av-store(RSP, R11, -24)
                     av-store(RSP, R12, -32)
                     av-store(RSP, R13, -40)
                     av-store(RSP, R14, -48)

                     ;Move RSP to R6 for CArgs
                     av-mov(R6, RSP)

                     ;Restore Stanza context
                     av-load(RSP, MemAV(STACK-PTR-LBL,0), 0)

                  else if length(ys(e)) == 2 :
                     val [x, y, z] = [xs(e)[0], ys(e)[0], ys(e)[1]]
                     av-binop(aval(x), op, aval(y), aval(z))

                  else if length(ys(e)) == 1 :
                     val [x, y] = [xs(e)[0], ys(e)[0]]
                     av-unaop(aval(x), op, aval(y))

                  else :
                     fatal("Unsupported Op: %_" % [e])
         (e:Args) :
            ;Write stack map
            val R0 = RegAV(0, asm-LONG-TYPE)
            val RSP = RSPAV()
            av-mov(R0, MemAV(stack-map-id,0))
            av-store(RSP, R0, 8)

            ;Null out stack
            for off in ref-offsets(stackmap) do :
               av-store(RSP, av-long(VOID-TAG), off)

            ;Save argument values
            val xs* = map(aval, xs(e))
            val ts* = match(ctxt(e)) :
               (c:StanzaContext) : call-locations(xs*)
               (c:CContext) : carg-locations(xs*)
            shuffle(xs*, ts*)
         (e:Call) :
            match(type(e)) :
               (t:StanzaCall) :
                  ;Convert to AVals
                  val ys* = map(aval, ys(e))

                  ;Call in new stack?
                  if new-stack?(t) :
                     av-store(MemAV(STACK-LIM-LBL,0), av-long(0), 0)

                  ;Move arguments into position and call
                  val f* = match(aval(f(e))) :
                     (f*:MemAV|ExMemAV) :
                        val ts* = call-locations(ys*)
                        shuffle(ts*, ys*)
                        f*
                     (f*) :
                        val ts* = call-locations(f*, ys*)
                        shuffle(ts*, cons(f*,ys*))
                        head(ts*)

                  ;Arity register
                  val R0 = RegAV(0, asm-LONG-TYPE)
                  if tail?(t) :
                     ;Call
                     av-mov(R0, av-long(arity(t)))
                     av-goto(f*)
                  else :
                     ;Call
                     av-mov(R0, av-long(arity(t)))
                     av-add(RSPAV(), RSPAV(), av-long(size(stackmap) + 8))
                     av-call(f*)
                     if info(t) is FileInfo :
                        val lbl = fresh-id()
                        add(infos, lbl => info(t) as FileInfo)
                        av-label(lbl)
                     av-sub(RSPAV(), RSPAV(), av-long(size(stackmap) + 8))

                     ;Move return values out from Args
                     val xs* = map(aval, xs(e))
                     val ts* = call-locations(xs*)
                     shuffle(xs*, ts*)

               (t:StackCall) :
                  ;Convert to AVals
                  val ys* = map(aval, ys(e))

                  ;Move arguments into position
                  val ts* = call-locations(aval(f(e)), ys*)
                  shuffle(ts*, cons(aval(f(e)),ys*))

                  val R0 = RegAV(0, asm-LONG-TYPE)
                  val R1 = RegAV(1, asm-LONG-TYPE)
                  val RSP = RSPAV()

                  if tail?(t) :
                     ;Cap the current stack
                     ;R0 = current stack
                     av-load(R0, MemAV(STACK-LBL,0), 0)
                     av-store(R0, RSP, STACK-SP-OFFSET - REF-TAG-BITS)

                     ;Update the current stack and limits
                     ;R1 = target stack
                     ;temporary R0 = stack limit
                     ;Update stack limit, and current stack
                     av-add(R0, R1, av-long(STACK-SIZE - REF-TAG-BITS))
                     av-store(MemAV(STACK-LIM-LBL,0), R0, 0)
                     av-store(MemAV(STACK-LBL,0), R1, 0)
                     ;Recover stack register
                     av-load(RSP, R1, STACK-SP-OFFSET - REF-TAG-BITS)
                     av-return()

                  else :
                     ;Cap the current stack
                     ;R0 = current stack
                     val ret-lbl = fresh-id()
                     av-add(RSP, RSP, av-long(size(stackmap)))
                     av-load(R0, MemAV(STACK-LBL,0), 0)
                     av-store(R0, RSP, STACK-SP-OFFSET - REF-TAG-BITS)

                     ;Write return address
                     av-mov(R0, MemAV(ret-lbl,0))
                     av-store(RSP, R0, 0)

                     ;Update the current stack and limits
                     ;R1 = target stack
                     ;temporary R0 = stack limit
                     ;Update stack limit, and current stack
                     av-add(R0, R1, av-long(STACK-SIZE - REF-TAG-BITS))
                     av-store(MemAV(STACK-LIM-LBL,0), R0, 0)
                     av-store(MemAV(STACK-LBL,0), R1, 0)
                     ;Recover stack register
                     av-load(RSP, R1, STACK-SP-OFFSET - REF-TAG-BITS)
                     av-return()

                     ;Move return values out from Args
                     av-label(ret-lbl)
                     if info(t) is FileInfo :
                        add(infos, ret-lbl => info(t) as FileInfo)
                     av-sub(RSP, RSP, av-long(size(stackmap) + 8))
                     val xs* = map(aval, xs(e))
                     val ts* = call-locations(xs*)
                     shuffle(xs*, ts*)

               (t:CCall) :
                  ;Convert to AVals
                  val ys* = map(aval, ys(e))

                  ;Move arguments into position and call
                  val f* = match(aval(f(e))) :
                     (f*:MemAV|ExMemAV) :
                        val ts* = callc-locations(ys*)
                        shuffle(ts*, ys*)
                        f*
                     (f*) :
                        val ts* = callc-locations(f*, ys*)
                        shuffle(ts*, cons(f*,ys*))
                        head(ts*)

                  ;Calculate number of floating point registers
                  val num-fregs = count({_ is FRegAV}, ys*)

                  ;Call
                  val R0 = RegAV(0, asm-LONG-TYPE)
                  val SPL = MemAV(STACK-PTR-LBL,0)
                  av-mov(R0, av-long(num-fregs))
                  av-store(SPL, RSPAV(), 0)
                  av-load(RSPAV(), MemAV(C-RSP-LBL,0), 0)
                  av-sub(RSPAV(), RSPAV(), av-long(8 * (6 + num-on-stack(t))))
                  av-call(f*)
                  av-load(RSPAV(), SPL, 0)

                  ;Move return values out from Args
                  val xs* = map(aval, xs(e))
                  val ts* = callc-ret-locations(xs*)
                  shuffle(xs*, ts*)
         (e:Save) :
            val x* = aval(x(e))
            val sx* = stack-aval(x(e))
            av-mov(sx*, x*)
         (e:Clear) :
            val sx* = stack-aval(x(e))
            av-mov(sx*, av-long(VOID-TAG))
         (e:Load) :
            val x* = aval(x(e))
            val sx* = stack-aval(x(e))
            av-mov(x*, sx*)
         (e:Xchg) :
            av-xchg(aval(x(e)), aval(y(e)))
         (e:Glue) :
            val xs* = map(aval,xs(e))
            val ys* = map(aval,ys(e))
            shuffle(xs*, ys*)
         (e:Label) :
            av-label(n(e))
         (e:Goto) :
            av-goto(MemAV(n(e),0))
         (e:Break) :
            defn flip (op:tgt-TgtOp) :
               switch {op == _} :
                  tgt-EQ-OP : tgt-NE-OP
                  tgt-NE-OP : tgt-EQ-OP
                  tgt-LT-OP : tgt-GE-OP
                  tgt-GT-OP : tgt-LE-OP
                  tgt-LE-OP : tgt-GT-OP
                  tgt-GE-OP : tgt-LT-OP
                  tgt-ULE-OP : tgt-UGT-OP
                  tgt-ULT-OP : tgt-UGE-OP
                  tgt-UGT-OP : tgt-ULE-OP
                  tgt-UGE-OP : tgt-ULT-OP
            defn flip-op? (op:tgt-TgtOp) :
               if flip?(e) : flip(op)
               else : op

            switch {op(e) == _} :
               tgt-STACK-HAS-SPACE :
                  val R0 = RegAV(0, asm-LONG-TYPE)
                  val R1 = RegAV(1, asm-LONG-TYPE)
                  val RSP = RSPAV()
                  av-add(R0, RSP, av-long(size(stackmap) + 8)) ;+8 for extra return address
                  av-load(R1, MemAV(STACK-LIM-LBL,0), 0)
                  av-break(n(e), flip-op?(tgt-LE-OP), R0, R1)

               else :
                  match(op(e)) :
                     (op:tgt-ArityNEqOp) :
                        val R0 = RegAV(0, asm-LONG-TYPE)
                        av-break(n(e), flip-op?(tgt-NE-OP), R0, av-long(tgt-arity(op)))
                     (op) :
                        val [x, y] = [xs(e)[0], xs(e)[1]]
                        av-break(n(e), flip-op?(op), aval(x), aval(y))
