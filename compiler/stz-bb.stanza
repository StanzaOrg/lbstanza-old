defpackage stz/bb :
   import core
   import verse
   import stz/tgt-ir with :
      prefix => tgt-
   import stz/bb-ir


;                           Translation to IR
;                           =================

public defn to-bb-ir (d:tgt-DefFn) -> Unit :
   println("TODO: Not everything is a ComOp")
   println("TODO: Defs need to be properly populated.")
   println("TODO: Some operators need to have immediates pulled out to values.")
   
   ;     State
   ;     -----   
   val defs = Vector<tgt-DefVar>()
   val blocks = Vector<Block>()

   ;     Update State
   ;     ------------
   defn close-block (b:Block, ns:List<Symbol>) :
      add(blocks, Block(name(b), ins(b), ns))
   defn fresh-block (name:Symbol) :
      Block(name, Vector<Ins>(), List())


   ;     Find all blocks
   ;     ---------------   
   defn* scan-block (b:Block, str-i:Stream<tgt-Ins>) :
      defn to-imm (x:tgt-Imm) :
         match(x) :
            (x:tgt-Var) : Var(tgt-name(x))
            (x) : Val(x)
      defn to-var (x:tgt-Var) :
         to-imm(x) as Var
      
      if more?(str-i) :
         match(next(str-i)) :
            (i:tgt-SetIns) :
               val x = to-var(tgt-x(i))
               val y = to-imm(tgt-y(i))
               add(ins(b), Set(x, y))
               scan-block(b, str-i)
            (i:tgt-BinOp) :
               val x = to-var(tgt-x(i))
               val ys = list(to-imm(tgt-y(i)), to-imm(tgt-z(i)))
               add(ins(b), Op(ComOp(tgt-op(i)), list(x), ys))
               scan-block(b, str-i)
            (i:tgt-Call) :
               val xs = map(to-var, tgt-xs(i))
               val f = to-imm(tgt-f(i))
               val ys = map(to-imm, tgt-ys(i))
               add(ins(b), Call(tgt-arity(i), xs, f, ys))
               scan-block(b, str-i)
            (i:tgt-Return) :
               val xs = map(to-imm, tgt-xs(i))
               add(ins(b), Return(xs))
               close-block(b, List())
               scan-block(fresh-block(gensym()), str-i)            
            (i:tgt-Label) :
               close-block(b, list(tgt-name(i)))
               scan-block(fresh-block(tgt-name(i)), str-i)
            (i:tgt-Goto) :
               val n = gensym()
               close-block(b, list(tgt-name(i)))
               scan-block(fresh-block(n), str-i)
            (i:tgt-Branch) :
               val alt = gensym()
               val xs = list(to-imm(tgt-x(i)), to-imm(tgt-y(i)))
               val i* = Branch(ComOp(tgt-op(i)), xs)
               add(ins(b), i*)
               close-block(b, list(tgt-name(i), alt))
               scan-block(fresh-block(alt), str-i)

   ;     Entry Block
   ;     -----------
   val entry = fresh-block(gensym())
   add(ins(entry), Args(vs)) where :
      val vs = for def in tgt-args(d) map :
         Var(tgt-name(def))
   scan-block(entry, to-stream(tgt-body(d)))

   ;     Return result
   ;     -------------
   Unit(defs, blocks)



;                       Critical Edge Removal
;                       =====================

public defn remove-critical-edges (u:Unit) :

   ;     Forward past empty blocks
   ;     -------------------------   
   val forwards = HashTable<Symbol,Symbol>(symbol-hash)
   
   defn resolve (n:Symbol) :
      match(get?(forwards, n, false)) :
         (f:False) :
            n
         (f:Symbol) :
            val n* = resolve(f)
            forwards[n] = n*
            n*

   defn next* (b:Block) :
      map(resolve, next(b))
            
   for b in blocks(u) do :
      if empty?(ins(b)) :
         if length(next(b)) == 1 :
            forwards[name(b)] = head(next(b))


   ;     Count predecessors for blocks
   ;     -----------------------------
   val num-preds = HashTable<Symbol,Int>(symbol-hash)
   defn inc-pred (b:Symbol) :
      num-preds[b] = 1 + get?(num-preds, b, 0)

   for b in blocks(u) do :
      if not empty?(ins(b)) :
         do(inc-pred, next*(b))


   ;     Insert safe blocks
   ;     ------------------
   val safe-blocks = Vector<Block>()
   val blocks* = Vector<Block>()

   defn safe-block (n:Symbol) :
      val name = gensym(`safe)
      add(safe-blocks, Block(name, Vector<Ins>(), list(n)))
      name

   defn multi-in? (b:Symbol) :
      get?(num-preds, b, 0) > 1
      
   defn multi-out? (b:Block) :
      length(next(b)) > 1

   
   for b in blocks(u) map :
      add{blocks*, Block(name(b), ins(b), _)} $
         if multi-out?(b) :
            for n in next*(b) map :
               if multi-in?(n) : safe-block(n)
               else : n
         else :
            next*(b)
   do(add{blocks*, _}, safe-blocks)         

   ;     Return result
   ;     -------------
   Unit(defs(u), blocks*)