defpackage stz/bb :
   import core
   import verse
   import stz/algorithms
   import stz/tgt-ir with :
      prefix => tgt-
   import stz/bb-ir

;                            Main Driver
;                            ===========

public defn compile (d:tgt-DefFn) :
   var u = to-bb-ir(d)
   u = remove-critical-edges(u)
   u = analyze-liveness(u)
   println(u)

;                           Translation to IR
;                           =================

defn to-bb-ir (d:tgt-DefFn) -> Unit :
   println("TODO: Not everything is a ComOp")
   println("TODO: Defs need to be properly populated.")
   println("TODO: Some operators need to have immediates pulled out to values.")
   
   ;     State
   ;     -----   
   val defs = Vector<tgt-DefVar>()
   val blocks = Vector<Block>()

   ;     Update State
   ;     ------------
   defn close-block (b:Block, ns:List<Symbol>) :
      add(blocks, Block(name(b), ins(b), ns))
   defn fresh-block (name:Symbol) :
      Block(name, Vector<Ins>(), List())


   ;     Find all blocks
   ;     ---------------   
   defn* scan-block (b:Block, str-i:Stream<tgt-Ins>) :
      defn to-imm (x:tgt-Imm) :
         match(x) :
            (x:tgt-Var) : Var(tgt-name(x))
            (x) : Val(x)
      defn to-var (x:tgt-Var) :
         to-imm(x) as Var
      
      if more?(str-i) :
         match(next(str-i)) :
            (i:tgt-SetIns) :
               val x = to-var(tgt-x(i))
               val y = to-imm(tgt-y(i))
               add(ins(b), Set(x, y))
               scan-block(b, str-i)
            (i:tgt-BinOp) :
               val x = to-var(tgt-x(i))
               val ys = list(to-imm(tgt-y(i)), to-imm(tgt-z(i)))
               add(ins(b), Op(ComOp(tgt-op(i)), list(x), ys))
               scan-block(b, str-i)
            (i:tgt-Call) :
               val xs = map(to-var, tgt-xs(i))
               val f = to-imm(tgt-f(i))
               val ys = map(to-imm, tgt-ys(i))
               add(ins(b), Call(tgt-arity(i), xs, f, ys))
               scan-block(b, str-i)
            (i:tgt-Return) :
               val xs = map(to-imm, tgt-xs(i))
               add(ins(b), Return(xs))
               close-block(b, List())
               scan-block(fresh-block(gensym()), str-i)            
            (i:tgt-Label) :
               close-block(b, list(tgt-name(i)))
               scan-block(fresh-block(tgt-name(i)), str-i)
            (i:tgt-Goto) :
               val n = gensym()
               close-block(b, list(tgt-name(i)))
               scan-block(fresh-block(n), str-i)
            (i:tgt-Branch) :
               val alt = gensym()
               val xs = list(to-imm(tgt-x(i)), to-imm(tgt-y(i)))
               val i* = Branch(ComOp(tgt-op(i)), xs)
               add(ins(b), i*)
               close-block(b, list(tgt-name(i), alt))
               scan-block(fresh-block(alt), str-i)

   ;     Entry Block
   ;     -----------
   val entry = fresh-block(gensym())
   add(ins(entry), Args(vs)) where :
      val vs = for def in tgt-args(d) map :
         Var(tgt-name(def))
   scan-block(entry, to-stream(tgt-body(d)))

   ;     Return result
   ;     -------------
   Unit(defs, blocks)



;                       Critical Edge Removal
;                       =====================

defn remove-critical-edges (u:Unit) :

   ;     Forward past empty blocks
   ;     -------------------------   
   val forwards = HashTable<Symbol,Symbol>(symbol-hash)
   
   defn resolve (n:Symbol) :
      match(get?(forwards, n, false)) :
         (f:False) :
            n
         (f:Symbol) :
            val n* = resolve(f)
            forwards[n] = n*
            n*

   defn next* (b:Block) :
      map(resolve, next(b))
            
   for b in blocks(u) do :
      if empty?(ins(b)) :
         if length(next(b)) == 1 :
            forwards[name(b)] = head(next(b))


   ;     Count predecessors for blocks
   ;     -----------------------------
   val num-preds = HashTable<Symbol,Int>(symbol-hash)
   defn inc-pred (b:Symbol) :
      num-preds[b] = 1 + get?(num-preds, b, 0)

   for b in blocks(u) do :
      if not empty?(ins(b)) :
         do(inc-pred, next*(b))


   ;     Insert safe blocks
   ;     ------------------
   val safe-blocks = Vector<Block>()
   val blocks* = Vector<Block>()

   defn safe-block (n:Symbol) :
      val name = gensym(`safe)
      add(safe-blocks, Block(name, Vector<Ins>(), list(n)))
      name

   defn multi-in? (b:Symbol) :
      get?(num-preds, b, 0) > 1
      
   defn multi-out? (b:Block) :
      length(next(b)) > 1

   
   for b in blocks(u) map :
      add{blocks*, Block(name(b), ins(b), _)} $
         if multi-out?(b) :
            for n in next*(b) map :
               if multi-in?(n) : safe-block(n)
               else : n
         else :
            next*(b)
   do(add{blocks*, _}, safe-blocks)         

   ;     Return result
   ;     -------------
   Unit(defs(u), blocks*)



;                       Working IR
;                       ==========

;     Working Instructions
;     --------------------
definterface Working
defstruct WArgs <: Ins&Working :
   xs: List<Port>
defstruct WCall <: Ins&Working :
   arity: Int
   xs: List<Port>
   f: Imm
   ys: List<Imm>
defstruct Save <: Ins&Working :
   x: Var   
defstruct Load <: Ins&Working :
   x: Var
defstruct Unload <: Ins&Working :
   x: Var
defstruct Xchg <: Ins&Working :
   x: Var
   y: Var
   swap: Reg|False

defn cms (xs) : join(xs, ", ")
defmethod print (o:OutputStream, i:Ins&Working) :
   print{o, _} $ match(i) :
      (i:WArgs) : "(~@) = Args" << [cms(xs(i))]
      (i:WCall) : "(~@) = ~(~@)" << [cms(xs(i)), f(i), cms(ys(i))]
      (i:Save) : "save ~" << [x(i)]
      (i:Load) : "load ~" << [x(i)]
      (i:Unload) : "unload ~" << [x(i)]
      (i:Xchg) : "xchg ~ ~ through ~" << [x(i), y(i), swap(i)]

;     Any Value
;     ---------
defstruct Any
defmethod print (o:OutputStream, x:Any) :
   print(o, "any")

;     Port Definition
;     ---------------
definterface Port
defstruct LivePort <: Port :
   name: Symbol
   saved?: True|False|Any
   loaded?: True|False|Any
   loc: Loc
defstruct DeadPort <: Port

defmethod print (o:OutputStream, p:Port) :
   print{o, _} $ match(p) :
      (p:LivePort) : "~ (s:~, l:~, at:~)" << [name(p), saved?(p), loaded?(p), loc(p)]
      (p:DeadPort) : "dead"

;     Working Block
;     -------------
defstruct WBlock <: Block :
   name: Symbol with : (as-method => true)
   ins: Vector<Ins> with : (as-method => true)
   next: List<Symbol> with : (as-method => true)
   in: List<LivePort>
   out: List<LivePort>
   dist: List<Int>

defmethod print (o:OutputStream, b:WBlock) :
   val io = IndentedStream(o, 3)
   print(o, "block ~ :" << [name(b)])
   print(io, "\nin: ~@" << [cms(in(b))])
   for e in ins(b) do :
      print(io, "\n~" << [e])
   print(io, "\nnext ~@" << [cms(next(b))])
   print(io, "\nout: ~@" << [cms(out(b))])
   print(io, "\ndist: ~@" << [cms(dist(b))])



;                       Block Liveness
;                       ==============

defn in-reverse<?T> (xs:Vector<?T>) :
   for i in (length(xs) - 1) through 0 by -1 stream :
      xs[i]

defn analyze-liveness (u:Unit) :
   ;     Propagation Tables
   ;     ------------------
   defn bhash ([b,x]:[Symbol,Symbol]) : 7 * symbol-hash(b) + symbol-hash(x)
   val defs-tab = HashTable<[Symbol,Symbol],True>(bhash)
   val ins-tab = HashTable<[Symbol,Symbol],False|Int>(bhash)

   ;     Find immediate defs and live-ins
   ;     --------------------------------
   defn find-defs-uses (b:Block) :   
      ;Update def/ins tables      
      defn key (x:Var) : [name(b), name(x)]
      defn def (x:Var) :
         defs-tab[key(x)] = true
         ins-tab[key(x)] = false
      defn use (x:Imm, i:Int) :
         match(x) :
            (x:Var) : ins-tab[key(x)] = i
            (x) : false
      defn def (xs:List<Var>) : do(def, xs)
      defn use (xs:List<Imm>, i:Int) : do(use{_, i}, xs)

      ;Sweep through instructions      
      val n = length(ins(b))
      for (e in in-reverse(ins(b)), i in (n - 1) through 0 by -1) do :
         match(e) :
            (e:Set) : (def(x(e)), use(y(e), i))
            (e:Op) : (def(xs(e)), use(ys(e), i))
            (e:Call) : (def(xs(e)), use(f(e), i), use(ys(e), i))
            (e:Args) : def(xs(e))
            (e:Return) : use(xs(e), i)
            (e:Branch) : use(xs(e), i)
            
   do(find-defs-uses, blocks(u))

   ;     Find block predecessors and block lengths
   ;     -----------------------------------------
   val preds = HashTable<Symbol,List<Symbol>>(symbol-hash)
   val lengths = HashTable<Symbol,Int>(symbol-hash)
   for b in blocks(u) do :
      preds[name(b)] = List()
      lengths[name(b)] = length(ins(b))
   for b in blocks(u) do :
      for n in next(b) do :
         preds[n] = List(name(b), preds[n])

   ;     Propagation of live-ins and live-outs
   ;     -------------------------------------
   ;Iterate through a table of live vars
   defn do-for-live (f: [Symbol,Symbol,Int] -> False,
                     es: HashTable<[Symbol,Symbol],False|Int>) :
      for entry in es do :
         if value(entry) != false :
            val [b,x] = key(entry)
            f([b, x, value(entry) as Int])

   ;Propagate block liveness results
   val outs-tab = HashTable<[Symbol,Symbol],Int>(bhash)
   fixpoint $ fn (progress) :
      defn add-live (live:HashTable<[Symbol,Symbol],False|Int>,
                     b:Symbol, x:Symbol, d:Int) :
         match(get?(live, [b,x], false)) :
            (d2:Int) :
               if d < d2 :
                  live[[b,x]] = d
                  progress()
            (d2:False) :
               live[[b,x]] = d
               progress()

      for [b,x,d] in ins-tab do-for-live :
         for p in preds[b] do : add-live(outs-tab, p, x, d)
      for [b,x,d] in outs-tab do-for-live :
         if not key?(defs-tab, [b,x]) :
            add-live(ins-tab, b, x, d + lengths[b])

   ;     Create results table
   ;     --------------------
   defn to-port (x:Symbol) : LivePort(x, Any(), Any(), NoLoc())
   val in-lists = HashTable<Symbol,List<Symbol>>(symbol-hash)
   val out-lists = HashTable<Symbol,List<Symbol>>(symbol-hash)
   val dist-lists = HashTable<Symbol,List<Int>>(symbol-hash)
   for [b,x,d] in ins-tab do-for-live :
      in-lists[b] = List(x, get?(in-lists, b, List()))
   for [b,x,d] in outs-tab do-for-live :
      out-lists[b] = List(x, get?(out-lists, b, List()))
      dist-lists[b] = List(d, get?(dist-lists, b, List()))

   let :
      val blocks* = for b in blocks(u) map :
         WBlock(name(b),
                ins(b),
                next(b),
                map(to-port, get?(in-lists, name(b), List()))
                map(to-port, get?(out-lists, name(b), List()))
                get?(dist-lists, name(b), List()))

      Unit(defs(u), blocks*)



;                             Usage Table
;                             ===========

;     Interface
;     ---------
defclass UsageTable
defmulti get (t:UsageTable, x:Symbol, p:Pos) -> Int

;     Type of Usage
;     -------------
definterface Usage
defmulti n (u:Usage) -> Int
defstruct UsedUsage <: Usage : (n:Int with: (as-method => true))
defstruct KillUsage <: Usage : (n:Int with: (as-method => true))

;     Position Tracker
;     ----------------
defstruct Pos :
   index: Int
   mid?: True|False

defn hash (p:Pos) :
   match(mid?(p)) :
      (m:True) : index(p) * 2 + 1
      (m:False) : index(p) * 2

defn less-eq? (a:Pos, b:Pos) :
   hash(a) <= hash(b)

defmethod print (o:OutputStream, p:Pos) :
   print(o, "~~" << [
      index(p),
      ".5" when mid?(p) else ""])

;     Analysis
;     --------
defn find-usages (b:WBlock) :
   ;     State
   ;     -----
   val usages = HashTable<Symbol, Vector<Usage>>(symbol-hash)

   ;     Update usages state
   ;     -------------------
   defn ensure-usage-vector (x:Symbol) :
      if not key?(usages, x) : usages[x] = Vector<Usage>(4)
      
   defn add-use-usage (x:Symbol, p:Pos) :
      ensure-usage-vector(x)
      add(usages[x], UsedUsage(hash(p)))
      
   defn add-kill-usage (x:Symbol, p:Pos) :
      ensure-usage-vector(x)
      add(usages[x], KillUsage(hash(p)))

   ;     Search through expressions for usages
   ;     -------------------------------------
   defn used (x:Imm, p:Pos) :
      match(x) : 
         (x:Var) : add-use-usage(name(x), p)
         (x:Val) : false
   defn used (x:LivePort, p:Pos) :
      add-use-usage(name(x), p)
   defn used (xs:List<Imm>, p:Pos) :
      for x in xs do : used(x, p)
   defn defd (x:Var, p:Pos) :
      add-kill-usage(name(x), p)
   defn defd (xs:List<Var>, p:Pos) :
      for x in xs do : defd(x, p)
   
   for (e in ins(b), i in 0 to false) do :
      match(e) :
         (e:Set) :
            used(y(e), Pos(i, false))
            defd(x(e), Pos(i, true))
         (e:Args) :
            defd(xs(e), Pos(i, true))
         (e:Call) :
            used(f(e), Pos(i, false))
            used(ys(e), Pos(i, false))
            defd(xs(e), Pos(i, true))
         (e:Return) :
            used(xs(e), Pos(i, true))
         (e:Op) :
            used(ys(e), Pos(i, false))
            defd(xs(e), Pos(i, true))
         (e:Branch) :
            used(xs(e), Pos(i, false))
         (e:Save) :
            false

   for (x in out(b), d in dist(b)) do :
      val i = length(ins(b)) + d
      used(x, Pos(i, false))


   ;     Compute distance until use
   ;     --------------------------

   new UsageTable :
      defmethod get (this, x:Symbol, p:Pos) :
         val i = hash(p)
         val use = find({n(_) >= i}, usages[x])
         match(use) :
            (use:UsedUsage) : n(use) - i
            (use:KillUsage|False) : error("No usage found for ~." % [x])



;                      Release Table
;                      =============

;     Interface
;     ---------
defclass ReleaseTable
defmulti releases-up-to (r:ReleaseTable, p:Pos) -> Stream<Symbol>

;     Analysis
;     --------
defn release-table (b:WBlock) :
   ;     Algorithm State
   ;     ---------------
   val load-table = HashTable<Symbol,True|False>(symbol-hash)

   defn marked-loaded? (x:Symbol) :
      get?(load-table, x, false)

   defn clear-loaded () :
      clear(load-table)

   defn mark-loaded (x:Symbol|Imm|Port, v:True|False) :
      match(x) :
         (x:Symbol) : load-table[x] = v
         (x:Var) : load-table[name(x)] = v
         (x:LivePort) : (load-table[name(x)] = v) when loaded?(x) != false
         (x) : false
         
   defn mark-loaded (xs:List<Imm|Port>, v:True|False) :
      for x in xs do : mark-loaded(x, v)

   ;     Output State
   ;     ------------
   val release-list = Vector<KeyValue<Pos,Symbol>>()

   ;     Analysis
   ;     --------
   defn release-if-not-loaded (p:Pos, x:Symbol|Imm|Port) :
      match(x) :
         (x:Symbol) :
            add(release-list, p => x) when not marked-loaded?(x)
         (x:Var) : release-if-not-loaded(p, name(x))
         (x:LivePort) : release-if-not-loaded(p, name(x))
         (x) : false

   ;Initialize live-out as live
   mark-loaded(out(b), true)
      
   ;Analyze expression list
   val n = length(ins(b))
   for (e in in-reverse(ins(b)), i in (n - 1) through 0 by -1) do :
      defn defd (x:Imm|Port) :
         release-if-not-loaded(Pos(i + 1, false), x)
         mark-loaded(x, false)
      defn defd (xs:List<Imm|Port>) :
         do(defd, xs)
         
      defn used (x:Imm|Port) :
         release-if-not-loaded(Pos(i, true), x)
         mark-loaded(x, true)
      defn used (xs:List<Imm|Port>) :
         do(used, xs)   
      
      match(e) :
         (e:Set) : (defd(x(e)), used(y(e)))
         (e:WArgs) : defd(xs(e))
         (e:WCall) :
            defd(xs(e))
            clear-loaded()
            used(f(e))
            used(ys(e))
         (e:Return) : used(xs(e))
         (e:Op) : (defd(xs(e)), used(ys(e)))
         (e:Branch) : used(xs(e))
         (e:Save) : used(x(e)) 
         (e:Load) : defd(x(e))

   ;     Compute releases to a given position
   ;     ------------------------------------
   new ReleaseTable :
      defmethod releases-up-to (this, p:Pos) :
         generate<Symbol> :
            defn* loop () :
               if not empty?(release-list) :
                  val r = peek(release-list)
                  if key(r) <= p :
                     yield(value(r))
                     pop(release-list)
                     loop()
            loop()         



;                       Save Emission
;                       =============

defn emit-early-saves (b:WBlock) :
   ;     Algorithm State
   ;     ---------------
   ;requires-save = true implies a variable needs to be saved. (default = false)
   ;prefers-load = false implies no benefit if a variable is loaded. (default = true)
   ;is-live = true implies a variable is still going to be used. (default = false)
   
   val requires-save = HashTable<Symbol,True|False>(symbol-hash)
   val prefers-load = HashTable<Symbol,True|False>(symbol-hash)
   val is-live = HashTable<Symbol,True|False>(symbol-hash)

   defn currently-live () :
      stream(key, filter(value, is-live))

   ;     Output State
   ;     ------------
   val accum = Vector<Ins>()
   
   defn emit (i:Ins) :
      add(accum, i)

   ;     Analysis
   ;     --------

   defn defd (x:Var) :
      is-live[name(x)] = false
      requires-save[name(x)] = false
      prefers-load[name(x)] = false

   defn used (x:Imm) :
      match(x) :
         (x:Var) :
            is-live[name(x)] = true
            prefers-load[name(x)] = true
         (x) : false

   defn lived-through-call (x:Symbol) :
      requires-save[x] = true
      prefers-load[x] = false

   defn defd (xs:List<Var>) : do(defd, xs)
   defn used (xs:List<Imm>) : do(used, xs)
   defn lived-through-call (xs:Stream<Symbol>) : do(lived-through-call, xs)

   defn get-port (x:Symbol) :
      val sv = get?(requires-save, x, false)
      val ld = get?(prefers-load, x, true)
      val lv = get?(is-live, x, false)
      match(lv, sv, ld) :
         (lv:False, sv, ld) : DeadPort()
         (lv:True, sv:False, ld:False) : LivePort(x, Any(), false, NoLoc())
         (lv:True, sv:False, ld:True) : LivePort(x, Any(), Any(), NoLoc())
         (lv:True, sv:True, ld:False) : LivePort(x, true, false, NoLoc())
         (lv:True, sv:True, ld:True) : LivePort(x, true, Any(), NoLoc())    

   defn get-port (x:Var) :
      get-port(name(x))

   defn get-port (xs:List<Var>) :
      map(get-port, xs)

   defn save-if-required (x:Var) :
      if get?(requires-save, name(x), false) :
         emit(Save(x))

   defn save-if-required (xs:List<Var>) :
      do(save-if-required, xs)

   ;Exit variables
   for p in out(b) do :
      is-live[name(p)] = true
      
   ;Sweep through instructions
   ;For each instruction:
   ;1. Save any required values
   ;2. Emit the updated instruction
   ;3. Update the algorithm state
   for e in in-reverse(ins(b)) do :
      match(e) :
         (e:Set) :
            save-if-required(x(e))
            emit(e)
            defd(x(e))
            used(y(e))
         (e:Args) :
            emit(WArgs(get-port(xs(e))))
            defd(xs(e))
         (e:Call) :
            emit(WCall(arity(e), get-port(xs(e)), f(e), ys(e)))
            defd(xs(e))
            lived-through-call(currently-live())
            used(f(e))
            used(ys(e))
         (e:Return) :
            emit(e)
            used(xs(e))
         (e:Op) :
            save-if-required(xs(e))
            emit(e)
            defd(xs(e))            
            used(ys(e))
         (e:Branch) :
            emit(e)
            used(xs(e))

   val in* = for x in in(b) map :
      get-port(name(x)) as LivePort

   ;     Return results
   ;     --------------
   WBlock(name(b),
          accum,
          next(b),
          in*,
          out(b),
          dist(b))