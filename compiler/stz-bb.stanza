defpackage stz/bb :
   import core
   import verse
   import stz/algorithms
   import stz/utils
   import stz/tgt with :
      prefix => tgt-
   import stz/tgt-ir with :
      prefix => tgt-
   import stz/bb-ir
   import stz/asm-ir with :
      prefix => asm-

;                            Main Driver
;                            ===========

public defn compile (d:tgt-DefFn, output:Vector<asm-Ins>) :
   var u:Unit = to-bb-ir(d)
   println("Basic block IR:\n~" << [u])
   u = remove-critical-edges(u)
   u = analyze-liveness(u)
   u = map(emit-early-saves, u)
   println("Allocate classes for:\n~" << [u])
   u = map(allocate-classes, u)
   println("Propagate assumptions for:\n~" << [u])
   u = map(propagate-assumptions, u)
   println(u)
   println("Register assignment for:\n~" << [u])
   u = register-assignment(u)
   println("Finished:\n~" << [u])
   println("Verify Register Assignment")
   do(verify-register-assignment, blocks(u) as Vector<WBlock>)
   println("Calculate stack table")
   val stack-map = calculate-stack-map(u)
   println("Collapse Blocks")
   val ins = collapse-blocks(u)
   println("Collapsed Instructions:\n~@" << [join(ins, "\n")])
   compile(ins, stack-map, output)

;                          Various Utilities
;                          =================

defn map (f: WBlock -> Block, u:Unit) :
   Unit(defs(u),
        map(f, blocks(u) as Vector<WBlock>))

defn in-reverse<?T> (xs:Vector<?T>) :
   for i in (length(xs) - 1) through 0 by -1 stream :
      xs[i]

defn reverse!<?T> (xs:Vector<?T>) :
   val n = length(xs)
   for i in 0 to n / 2 do :
      val j = n - 1 - i
      val xi = xs[i]
      val xj = xs[j]
      xs[i] = xj
      xs[j] = xi

defn reverse-post-order (bs:Vector<Block>) -> Vector<Block> :
   ;Block Table
   val block = HashTable<Int,Block>({_})
   for b in bs do : block[n(b)] = b
   
   ;Mark Table
   val mark-table = HashTable<Int,True>({_})
   defn marked? (b:Block) : key?(mark-table, n(b))
   defn mark (b:Block) : mark-table[n(b)] = true

   ;Add blocks to ys
   val ys = Vector<Block>()
   defn* loop (b:Block) :
      if not marked?(b) :
         mark(b)
         do(loop{block[_]}, next(b))
         add(ys, b)            
   loop(bs[0])

   ;Return reversed
   reverse!(ys)
   ys

defn find!<?T> (f: T -> True|False, xs:Streamable<?T>) -> T :
   find(f, xs) as T


;                           Translation to IR
;                           =================

defn to-bb-ir (d:tgt-DefFn) -> Unit :
   println("TODO: Not everything is a ComOp")
   println("TODO: Defs need to be properly populated.")
   println("TODO: Some operators need to have immediates pulled out to values.")
   
   ;     State
   ;     -----   
   val defs = Vector<tgt-DefVar>()
   val blocks = Vector<Block>()
   val type-table = HashTable<Int,tgt-TgtType>({_})

   ;     Update State
   ;     ------------
   defn close-block (b:Block, ns:List<Int>) :
      add(blocks, Block(n(b), ins(b), ns))
   defn fresh-block (n:Int) :
      Block(n, Vector<Ins>(), List())

   ;     Populate Defs and Type Table
   ;     ----------------------------
   defn add-def (d:tgt-DefVar) :
      add(defs, d)
      type-table[tgt-n(d)] = tgt-type(d)
   defn imm-type (i:tgt-Imm) :
      match(i) :
         (i:tgt-ByteImm) : tgt-BYTE-TYPE
         (i:tgt-IntImm) : tgt-INT-TYPE
         (i:tgt-LongImm) : tgt-LONG-TYPE
         (i:tgt-Var) : type-table[tgt-n(i)]
   defn fresh-local (t:tgt-TgtType) :
      val n = fresh-id()
      add(defs, tgt-DefVar(n, t))
      type-table[n] = t
      Var(n)
   do(add-def, tgt-args(d))
   do(add-def, tgt-locals(d))

   ;     Find all blocks
   ;     ---------------   
   defn* scan-block (b:Block, str-i:Stream<tgt-Ins>) :
      defn emit (i:Ins) :
         add(ins(b), i)
         
      defn to-imm (x:tgt-Imm) :
         match(x) :
            (x:tgt-Var) : Var(tgt-n(x))
            (x) : Val(x)
            
      defn to-var (x:tgt-Imm) :
         match(x) :
            (x:tgt-Var) :
               to-imm(x) as Var
            (x) :
               val v = fresh-local(imm-type(x))
               emit(Set(v, Val(x)))
               v
      
      if more?(str-i) :
         match(next(str-i)) :
            (i:tgt-SetIns) :
               val x = to-var(tgt-x(i))
               val y = to-imm(tgt-y(i))
               emit(Set(x, y))
               scan-block(b, str-i)
            (i:tgt-BinOp) :
               ;     Classification
               ;     --------------
               defn com-op? (o:tgt-TgtOp) :
                  contains?([tgt-ADD-OP, tgt-MUL-OP, tgt-AND-OP, tgt-OR-OP, tgt-XOR-OP], o)
               defn ncom-op? (o:tgt-TgtOp) :
                  o == tgt-SUB-OP
               defn div-op? (o:tgt-TgtOp) :
                  contains?([tgt-DIV-OP, tgt-MOD-OP], o)
               defn cmp-op? (o:tgt-TgtOp) :
                  contains?([tgt-EQ-OP, tgt-NE-OP, tgt-LT-OP, tgt-GT-OP, tgt-LE-OP,
                             tgt-GE-OP, tgt-ULE-OP, tgt-ULT-OP, tgt-UGT-OP, tgt-UGE-OP], o)
               defn shf-op? (o:tgt-TgtOp) :
                  contains?([tgt-SHL-OP, tgt-SHR-OP, tgt-ASHR-OP], o)
               defn int-type? (t:tgt-TgtType) :
                  contains?([tgt-BYTE-TYPE, tgt-INT-TYPE, tgt-LONG-TYPE, tgt-REF-TYPE], t)
               defn float-type? (t:tgt-TgtType) :
                  contains?([tgt-FLOAT-TYPE, tgt-DOUBLE-TYPE], t)

               ;     Convenience Translators
               ;     -----------------------
               val t = imm-type(tgt-x(i))
               val top = tgt-op(i)
               defn x-var () : list(to-var(tgt-x(i)))
               defn y-imms () : list(to-imm(tgt-y(i)), to-imm(tgt-z(i)))
               defn y-vars () : list(to-var(tgt-y(i)), to-var(tgt-z(i)))

               ;     Dispatch on Operator Type
               ;     -------------------------
               if int-type?(t) :
                  switch _{top} :
                     com-op? : emit(Op(ComOp(top), x-var(), y-imms()))
                     ncom-op? : emit(Op(NComOp(top), x-var(), y-imms()))
                     div-op? :
                        if t == tgt-BYTE-TYPE :
                           emit(Op(DivOp(top), x-var(), y-vars()))
                        else if top == tgt-DIV-OP :
                           val tmp = fresh-local(t)
                           val x = to-var(tgt-x(i))
                           emit(Op(DivModOp(), list(x, tmp), y-vars()))
                        else if top == tgt-MOD-OP :
                           val tmp = fresh-local(t)
                           val x = to-var(tgt-x(i))
                           emit(Op(DivModOp(), list(tmp, x), y-vars()))
                        else :
                           error("Unreachable")                           
                     cmp-op? : emit(Op(CmpOp(top), x-var(), y-imms()))
                     shf-op? : emit(Op(ShfOp(top), x-var(), y-imms()))
               else if float-type?(t) :
                  switch _{top} :
                     com-op? : emit(Op(ComOp(top), x-var(), y-imms()))
                     ncom-op? : emit(Op(NComOp(top), x-var(), y-imms()))
                     div-op? : emit(Op(NComOp(top), x-var(), y-imms()))
                     cmp-op? : emit(Op(CmpOp(top), x-var(), y-imms()))
               else :
                  error("Unreachable")
               scan-block(b, str-i)
            (i:tgt-ConvertIns) :
               val x* = to-var(tgt-x(i))
               val y* = to-var(tgt-y(i))
               emit(Op(ConvOp(tgt-signed?(i)), list(x*), list(y*)))
               scan-block(b, str-i)
            (i:tgt-Load) :
               val x* = to-var(tgt-x(i))
               val y* = to-imm(tgt-y(i))
               emit(Op(LoadOp(tgt-offset(i)), list(x*), list(y*)))
               scan-block(b, str-i)
            (i:tgt-Store) :
               val x* = to-imm(tgt-x(i))
               val y* = to-imm(tgt-y(i))
               emit(Op(StoreOp(tgt-offset(i)), List(), list(x*, y*)))
               scan-block(b, str-i)
            (i:tgt-Addr) :
               val x* = to-var(tgt-x(i))
               val y* = to-imm(tgt-y(i))
               emit(Op(AddrOp(y*, tgt-offset(i)), list(x*), List()))
               scan-block(b, str-i)
            (i:tgt-Call) :
               val xs = map(to-var, tgt-xs(i))
               val f = to-imm(tgt-f(i))
               val ys = map(to-imm, tgt-ys(i))
               emit(Call(tgt-arity(i), xs, f, ys, false))
               scan-block(b, str-i)
            (i:tgt-TCall) :
               val f = to-imm(tgt-f(i))
               val ys = map(to-imm, tgt-ys(i))
               emit(Call(tgt-arity(i), List(), f, ys, true))
               close-block(b, List())
               scan-block(fresh-block(fresh-id()), str-i)
            (i:tgt-Return) :
               val xs = map(to-imm, tgt-xs(i))
               emit(Return(xs))
               close-block(b, List())
               scan-block(fresh-block(fresh-id()), str-i)            
            (i:tgt-Label) :
               close-block(b, list(tgt-n(i)))
               scan-block(fresh-block(tgt-n(i)), str-i)
            (i:tgt-Goto) :
               val n = fresh-id()
               close-block(b, list(tgt-n(i)))
               scan-block(fresh-block(n), str-i)
            (i:tgt-Branch) :
               val alt = fresh-id()
               val xs = list(to-imm(tgt-x(i)), to-imm(tgt-y(i)))
               emit(Branch(CmpOp(tgt-op(i)), xs))
               close-block(b, list(tgt-n(i), alt))
               scan-block(fresh-block(alt), str-i)

   ;     Entry Block
   ;     -----------
   val entry = fresh-block(fresh-id())
   add(ins(entry), Args(vs)) where :
      val vs = for def in tgt-args(d) map :
         Var(tgt-n(def))
   scan-block(entry, to-stream(tgt-body(d)))

   ;     Return result
   ;     -------------
   Unit(defs, blocks)



;                       Critical Edge Removal
;                       =====================

defn remove-critical-edges (u:Unit) :

   ;     Forward past empty blocks
   ;     -------------------------   
   val forwards = HashTable<Int,Int>({_})
   
   defn resolve (n:Int) :
      match(get?(forwards, n, false)) :
         (f:False) :
            n
         (f:Int) :
            val n* = resolve(f)
            forwards[n] = n*
            n*

   defn next* (b:Block) :
      map(resolve, next(b))
            
   for b in blocks(u) do :
      if empty?(ins(b)) :
         if length(next(b)) == 1 :
            forwards[n(b)] = head(next(b))


   ;     Count predecessors for blocks
   ;     -----------------------------
   val num-preds = HashTable<Int,Int>({_})
   defn inc-pred (b:Int) :
      num-preds[b] = 1 + get?(num-preds, b, 0)

   for b in blocks(u) do :
      if not empty?(ins(b)) :
         do(inc-pred, next*(b))


   ;     Insert safe blocks
   ;     ------------------
   val safe-blocks = Vector<Block>()
   val blocks* = Vector<Block>()

   defn safe-block (next:Int) :
      val n = fresh-id()
      add(safe-blocks, Block(n, Vector<Ins>(), list(next)))
      n

   defn multi-in? (b:Int) :
      get?(num-preds, b, 0) > 1
      
   defn multi-out? (b:Block) :
      length(next(b)) > 1

   
   for b in blocks(u) map :
      add{blocks*, Block(n(b), ins(b), _)} $
         if multi-out?(b) :
            for n in next*(b) map :
               if multi-in?(n) : safe-block(n)
               else : n
         else :
            next*(b)
   do(add{blocks*, _}, safe-blocks)         

   ;     Return result
   ;     -------------
   Unit(defs(u), blocks*)



;                       Working IR
;                       ==========

;     Working Instructions
;     --------------------
definterface Working
defstruct WArgs <: Ins&Working :
   xs: List<Port>
defstruct WCall <: Ins&Working :
   arity: Int
   xs: List<Port>
   f: Imm
   ys: List<Imm>
defstruct Save <: Ins&Working :
   x: Var   
defstruct Load <: Ins&Working :
   x: Var
defstruct Unload <: Ins&Working :
   x: Var
defstruct Xchg <: Ins&Working :
   x: Var
   y: Var
   swap: Reg|False
defstruct Shuffle <: Ins&Working :
   xs: List<Var>
   ys: List<Var>
defstruct Label <: Ins&Working :
   n: Int
defstruct Goto <: Ins&Working :
   n: Int
defstruct Break <: Ins&Working :
   n: Int
   op: BBOp
   xs: List<Imm>
   flip?: True|False

defn cms (xs) : join(xs, ", ")
defmethod print (o:OutputStream, i:Ins&Working) :
   print{o, _} $ match(i) :
      (i:WArgs) : "(~@) = Args" << [cms(xs(i))]
      (i:WCall) : "(~@) = ~(~@)" << [cms(xs(i)), f(i), cms(ys(i))]
      (i:Save) : "save ~" << [x(i)]
      (i:Load) : "load ~" << [x(i)]
      (i:Unload) : "unload ~" << [x(i)]
      (i:Xchg) : "xchg ~ ~ through ~" << [x(i), y(i), swap(i)]
      (i:Shuffle) : "shuffle (~@) = (~@)" << [cms(xs(i)), cms(ys(i))]
      (i:Label) : "label<~>" << [n(i)]
      (i:Goto) : "goto label<~>" << [n(i)]
      (i:Break) : "break label<~> when ~(~@) (flip:~)" << [n(i), op(i), cms(xs(i)), flip?(i)]

;     Any Value
;     ---------
defstruct Any
defmethod print (o:OutputStream, x:Any) :
   print(o, "any")

;     Port Definition
;     ---------------
definterface Port
defstruct LivePort <: Port :
   n: Int
   saved?: True|False|Any
   loaded?: True|False|Any
   loc: Loc
defstruct DeadPort <: Port

defmethod print (o:OutputStream, p:Port) :
   print{o, _} $ match(p) :
      (p:LivePort) : "~ (s:~, l:~, at:~)" << [n(p), saved?(p), loaded?(p), loc(p)]
      (p:DeadPort) : "dead"

;     Working Block
;     -------------
defstruct WBlock <: Block :
   n: Int with : (as-method => true)
   ins: Vector<Ins> with : (as-method => true)
   next: List<Int> with : (as-method => true)
   in: List<LivePort>
   out: List<LivePort>
   dist: List<Int>

defmethod print (o:OutputStream, b:WBlock) :
   val io = IndentedStream(o, 3)
   print(o, "block B~ :" << [n(b)])
   print(io, "\nin: ~@" << [cms(in(b))])
   for e in ins(b) do :
      print(io, "\n~" << [e])
   print(io, "\nnext ~@" << [cms(next(b))])
   print(io, "\nout: ~@" << [cms(out(b))])
   print(io, "\ndist: ~@" << [cms(dist(b))])



;                       Block Liveness
;                       ==============

defn analyze-liveness (u:Unit) :
   ;     Propagation Tables
   ;     ------------------
   defn bhash ([b,x]:[Int,Int]) : 7 * b + x
   val defs-tab = HashTable<[Int,Int],True>(bhash)
   val ins-tab = HashTable<[Int,Int],False|Int>(bhash)

   ;     Find immediate defs and live-ins
   ;     --------------------------------
   defn find-defs-uses (b:Block) :   
      ;Update def/ins tables      
      defn key (x:Var) : [n(b), n(x)]
      defn def (x:Var) :
         defs-tab[key(x)] = true
         ins-tab[key(x)] = false
      defn use (x:Imm, i:Int) :
         match(x) :
            (x:Var) : ins-tab[key(x)] = i
            (x) : false
      defn def (xs:List<Var>) : do(def, xs)
      defn use (xs:List<Imm>, i:Int) : do(use{_, i}, xs)

      ;Sweep through instructions      
      val n = length(ins(b))
      for (e in in-reverse(ins(b)), i in (n - 1) through 0 by -1) do :
         match(e) :
            (e:Set) : (def(x(e)), use(y(e), i))
            (e:Op) : (def(xs(e)), use(ys(e), i))
            (e:Call) : (def(xs(e)), use(f(e), i), use(ys(e), i))
            (e:Args) : def(xs(e))
            (e:Return) : use(xs(e), i)
            (e:Branch) : use(xs(e), i)
            
   do(find-defs-uses, blocks(u))

   ;     Find block predecessors and block lengths
   ;     -----------------------------------------
   val preds = HashTable<Int,List<Int>>({_})
   val lengths = HashTable<Int,Int>({_})
   for b in blocks(u) do :
      preds[n(b)] = List()
      lengths[n(b)] = length(ins(b))
   for b in blocks(u) do :
      for nx in next(b) do :
         preds[nx] = List(n(b), preds[nx])

   ;     Propagation of live-ins and live-outs
   ;     -------------------------------------
   ;Iterate through a table of live vars
   defn do-for-live (f: [Int,Int,Int] -> False,
                     es: HashTable<[Int,Int],False|Int>) :
      for entry in es do :
         if value(entry) != false :
            val [b,x] = key(entry)
            f([b, x, value(entry) as Int])

   ;Propagate block liveness results
   val outs-tab = HashTable<[Int,Int],Int>(bhash)
   fixpoint $ fn (progress) :
      defn add-live (live:HashTable<[Int,Int],False|Int>,
                     b:Int, x:Int, d:Int) :
         match(get?(live, [b,x], false)) :
            (d2:Int) :
               if d < d2 :
                  live[[b,x]] = d
                  progress()
            (d2:False) :
               live[[b,x]] = d
               progress()

      for [b,x,d] in ins-tab do-for-live :
         for p in preds[b] do : add-live(outs-tab, p, x, d)
      for [b,x,d] in outs-tab do-for-live :
         if not key?(defs-tab, [b,x]) :
            add-live(ins-tab, b, x, d + lengths[b])

   ;     Create results table
   ;     --------------------
   defn to-port (x:Int) : LivePort(x, Any(), Any(), NoLoc())
   val in-lists = HashTable<Int,List<Int>>({_})
   val out-lists = HashTable<Int,List<Int>>({_})
   val dist-lists = HashTable<Int,List<Int>>({_})
   for [b,x,d] in ins-tab do-for-live :
      in-lists[b] = List(x, get?(in-lists, b, List()))
   for [b,x,d] in outs-tab do-for-live :
      out-lists[b] = List(x, get?(out-lists, b, List()))
      dist-lists[b] = List(d, get?(dist-lists, b, List()))

   let :
      val blocks* = for b in blocks(u) map :
         WBlock(n(b),
                ins(b),
                next(b),
                map(to-port, get?(in-lists, n(b), List()))
                map(to-port, get?(out-lists, n(b), List()))
                get?(dist-lists, n(b), List()))

      Unit(defs(u), blocks*)



;                             Usage Table
;                             ===========

;     Interface
;     ---------
defclass UsageTable
defmulti get (t:UsageTable, x:Int, p:Pos) -> Int

;     Type of Usage
;     -------------
definterface Usage
defmulti n (u:Usage) -> Int
defstruct UsedUsage <: Usage : (n:Int with: (as-method => true))
defstruct KillUsage <: Usage : (n:Int with: (as-method => true))

;     Position Tracker
;     ----------------
defstruct Pos :
   index: Int
   mid?: True|False

defn hash (p:Pos) :
   match(mid?(p)) :
      (m:True) : index(p) * 2 + 1
      (m:False) : index(p) * 2

defn less-eq? (a:Pos, b:Pos) :
   hash(a) <= hash(b)

defmethod print (o:OutputStream, p:Pos) :
   print(o, "~~" << [
      index(p),
      ".5" when mid?(p) else ""])

;     Analysis
;     --------
defn usage-table (b:WBlock) :
   ;     State
   ;     -----
   val usages = HashTable<Int, Vector<Usage>>({_})

   ;     Update usages state
   ;     -------------------
   defn ensure-usage-vector (x:Int) :
      if not key?(usages, x) : usages[x] = Vector<Usage>(4)
      
   defn add-use-usage (x:Int, p:Pos) :
      ensure-usage-vector(x)
      add(usages[x], UsedUsage(hash(p)))
      
   defn add-kill-usage (x:Int, p:Pos) :
      ensure-usage-vector(x)
      add(usages[x], KillUsage(hash(p)))

   ;     Search through expressions for usages
   ;     -------------------------------------
   defn used (x:Imm, p:Pos) :
      match(x) : 
         (x:Var) : add-use-usage(n(x), p)
         (x:Val) : false
   defn used (x:LivePort, p:Pos) :
      add-use-usage(n(x), p)
   defn used (xs:List<Imm>, p:Pos) :
      for x in xs do : used(x, p)
   defn defd (x:Var|Port, p:Pos) :
      match(x) :
         (x:Var|LivePort) : add-kill-usage(n(x), p)
         (x) : false
   defn defd (xs:List<Var|Port>, p:Pos) :
      for x in xs do : defd(x, p)
      
   
   for (e in ins(b), i in 0 to false) do :
      match(e) :
         (e:Set) :
            used(y(e), Pos(i, false))
            defd(x(e), Pos(i, true))
         (e:WArgs) :
            defd(xs(e), Pos(i, true))
         (e:WCall) :
            used(f(e), Pos(i, false))
            used(ys(e), Pos(i, false))
            defd(xs(e), Pos(i, true))
         (e:Return) :
            used(xs(e), Pos(i, true))
         (e:Op) :
            used(ys(e), Pos(i, false))
            defd(xs(e), Pos(i, true))
         (e:Branch) :
            used(xs(e), Pos(i, false))
         (e:Save) :
            false

   for (x in out(b), d in dist(b)) do :
      val i = length(ins(b)) + d
      used(x, Pos(i, false))


   ;     Compute distance until use
   ;     --------------------------

   new UsageTable :
      defmethod get (this, x:Int, p:Pos) :
         val i = hash(p)
         val use = find({n(_) >= i}, usages[x])
         match(use) :
            (use:UsedUsage) : n(use) - i
            (use:KillUsage|False) : error("No usage found for ~." % [x])



;                      Release Table
;                      =============

;     Interface
;     ---------
defclass ReleaseTable
defmulti releases-up-to (r:ReleaseTable, p:Pos) -> Stream<Int>

;     Analysis
;     --------
defn release-table (b:WBlock) :
   ;     Algorithm State
   ;     ---------------
   val load-table = HashTable<Int,True|False>({_})

   defn marked-loaded? (x:Int) :
      get?(load-table, x, false)

   defn clear-loaded () :
      clear(load-table)

   defn mark-loaded (x:Int|Imm|Port, v:True|False) :
      match(x) :
         (x:Int) : load-table[x] = v
         (x:Var) : load-table[n(x)] = v
         (x:LivePort) : (load-table[n(x)] = v) when loaded?(x) != false
         (x) : false
         
   defn mark-loaded (xs:List<Imm|Port>, v:True|False) :
      for x in xs do : mark-loaded(x, v)

   ;     Output State
   ;     ------------
   val release-list = Vector<KeyValue<Pos,Int>>()

   ;     Analysis
   ;     --------
   defn release-if-not-loaded (p:Pos, x:Int|Imm|Port) :
      match(x) :
         (x:Int) :
            add(release-list, p => x) when not marked-loaded?(x)
         (x:Var) : release-if-not-loaded(p, n(x))
         (x:LivePort) : release-if-not-loaded(p, n(x))
         (x) : false

   ;Initialize live-out as live
   mark-loaded(out(b), true)
      
   ;Analyze expression list
   val n = length(ins(b))
   for (e in in-reverse(ins(b)), i in (n - 1) through 0 by -1) do :
      defn defd (x:Imm|Port) :
         release-if-not-loaded(Pos(i + 1, false), x)
         mark-loaded(x, false)
      defn defd (xs:List<Imm|Port>) :
         do(defd, xs)
         
      defn used (x:Imm|Port) :
         release-if-not-loaded(Pos(i, true), x)
         mark-loaded(x, true)
      defn used (xs:List<Imm|Port>) :
         do(used, xs)
      
      match(e) :
         (e:Set) : (defd(x(e)), used(y(e)))
         (e:WArgs) : defd(xs(e))
         (e:WCall) :
            defd(xs(e))
            clear-loaded()
            used(f(e))
            used(ys(e))
         (e:Return) : used(xs(e))
         (e:Op) : (defd(xs(e)), used(ys(e)))
         (e:Branch) : used(xs(e))
         (e:Save) : used(x(e)) 
         (e:Load) : defd(x(e))

   ;     Compute releases to a given position
   ;     ------------------------------------
   new ReleaseTable :
      defmethod releases-up-to (this, p:Pos) :
         generate<Int> :
            defn* loop () :
               if not empty?(release-list) :
                  val r = peek(release-list)
                  if key(r) <= p :
                     yield(value(r))
                     pop(release-list)
                     loop()
            loop()
      defmethod print (o:OutputStream, this) :
         val io = IndentedStream(o, 3)
         print(o, "Release Table:")
         for e in in-reverse(release-list) do :
            print(io, "\n~" << [e])



;                       Save Emission
;                       =============

defn emit-early-saves (b:WBlock) :
   ;     Algorithm State
   ;     ---------------
   ;requires-save = true implies a variable needs to be saved. (default = false)
   ;prefers-load = false implies no benefit if a variable is loaded. (default = true)
   ;is-live = true implies a variable is still going to be used. (default = false)
   
   val requires-save = HashTable<Int,True|False>({_})
   val prefers-load = HashTable<Int,True|False>({_})
   val is-live = HashTable<Int,True|False>({_})

   defn currently-live () :
      stream(key, filter(value, is-live))

   ;     Output State
   ;     ------------
   val accum = Vector<Ins>()
   
   defn emit (i:Ins) :
      add(accum, i)

   ;     Analysis Helpers
   ;     ----------------
   ;Updates state for a defined variable
   defn defd (x:Var) :
      is-live[n(x)] = false
      requires-save[n(x)] = false
      prefers-load[n(x)] = false

   ;Updates state for a used variable
   defn used (x:Imm) :
      match(x) :
         (x:Var) :
            is-live[n(x)] = true
            prefers-load[n(x)] = true
         (x) : false

   ;Updates state for a variable that was live through a call
   defn lived-through-call (x:Int) :
      requires-save[x] = true
      prefers-load[x] = false

   ;Convenience
   defn defd (xs:List<Var>) : do(defd, xs)
   defn used (xs:List<Imm>) : do(used, xs)
   defn lived-through-call (xs:Stream<Int>) : do(lived-through-call, xs)

   ;Retrieve the variable as a port according to the current algorithm state.
   defn get-port (x:Int) :
      val sv = get?(requires-save, x, false)
      val ld = get?(prefers-load, x, true)
      val lv = get?(is-live, x, false)
      match(lv, sv, ld) :
         (lv:False, sv, ld) : DeadPort()
         (lv:True, sv:False, ld:False) : LivePort(x, Any(), false, NoLoc())
         (lv:True, sv:False, ld:True) : LivePort(x, Any(), Any(), NoLoc())
         (lv:True, sv:True, ld:False) : LivePort(x, true, false, NoLoc())
         (lv:True, sv:True, ld:True) : LivePort(x, true, Any(), NoLoc())    

   defn get-port (x:Var) : get-port(n(x))
   defn get-port (xs:List<Var>) : map(get-port, xs)

   ;Insert a Save for the variable if it needs to be saved.
   defn save-if-required (x:Var) :
      if get?(requires-save, n(x), false) :
         emit(Save(x))

   defn save-if-required (xs:List<Var>) :
      do(save-if-required, xs)

   ;     Analysis
   ;     --------
   ;Exit variables
   for p in out(b) do :
      is-live[n(p)] = true
      
   ;Sweep through instructions
   ;For each instruction:
   ;1. Save any required values
   ;2. Emit the updated instruction
   ;3. Update the algorithm state
   for e in in-reverse(ins(b)) do :
      match(e) :
         (e:Set) :
            save-if-required(x(e))
            emit(e)
            defd(x(e))
            used(y(e))
         (e:Args) :
            emit(WArgs(get-port(xs(e))))
            defd(xs(e))
         (e:Call) :
            emit(WCall(arity(e), get-port(xs(e)), f(e), ys(e)))
            defd(xs(e))
            lived-through-call(currently-live())
            used(f(e))
            used(ys(e))
         (e:Return) :
            emit(e)
            used(xs(e))
         (e:Op) :
            save-if-required(xs(e))
            emit(e)
            defd(xs(e))            
            used(ys(e))
         (e:Branch) :
            emit(e)
            used(xs(e))

   ;Entry variables
   val in* = for x in in(b) map :
      get-port(n(x)) as LivePort

   ;     Return results
   ;     --------------
   reverse!(accum)
   WBlock(n(b),
          accum,
          next(b),
          in*,
          out(b),
          dist(b))


;                       Class Allocation
;                       ================

;     Return all unique Vars
;     ----------------------
val UNIQUE-TABLE = HashTable<Int,True>({_})
defn unique-vars (vs:List<Imm>) :
   val r = for v in vs filter :
      match(v) :
         (v:Var) :
            match(get?(UNIQUE-TABLE, n(v), false)) :
               (e:True) :
                  false
               (e:False) :
                  UNIQUE-TABLE[n(v)] = true
                  true
         (v:Val) :
            false
   to-list(r) as List<Var>
   

;     Allocate classes
;     ----------------
defn allocate-classes (b:WBlock) -> WBlock :
   println("TODO: Handle different types of registers.")
   println("TODO: Have the correct number of free registers.")

   ;     Algorithm State
   ;     ---------------
   ;saved = true : The variable has been saved.
   ;      | false : The variable is not saved.
   ;      | any : It is unknown whether the variable is saved or not.
   ;      | none : The variable is not live.
   ;loaded = true : The variable is loaded.
   ;       | false : The variable is not loaded.
   ;       | any : It is unknown whether the variable is loaded.
   ;       | none : The variable is not live.

   val saved = HashTable<Int, True|False|Any>({_})
   val loaded = HashTable<Int, True|False|Any>({_})
   val rt = release-table(b)
   val ut = usage-table(b)
   var num-free-reg = 8

   ;     Output State
   ;     ------------
   val accum = Vector<Ins>()
   
   defn emit (i:Ins) :
      add(accum, i)

   ;     Analysis Helpers
   ;     ----------------

   ;Saving / Loading / Defining / Killing
   defn kill (x:Int) :
      match(loaded[x]) :
         (l:True|Any) : num-free-reg = num-free-reg + 1
         (l:False) : false
      loaded[x] = false
      
   defn save (x:Int) :
      match(saved[x]) :
         (s:True) : false
         (s:False|Any) : emit(Save(Var(x)))
      saved[x] = true

   defn load (x:Int) :
      match(loaded[x]) :
         (l:True) : false
         (l:False) :
            emit(Load(Var(x)))
            num-free-reg = num-free-reg - 1
         (l:Any) :
            emit(Load(Var(x)))
      loaded[x] = true

   defn unload (x:Int) :
      match(loaded[x]) :
         (l:True|Any) :
            emit(Unload(Var(x)))
            num-free-reg = num-free-reg + 1
         (l:False) : false
      loaded[x] = false   

   defn define (x:Int) :
      loaded[x] = true
      saved[x] = false
      num-free-reg = num-free-reg - 1

   defn define (x:Port) :
      match(x) :
         (x:LivePort) :
            match(loaded?(x)) :
               (l:False) :
                  loaded[n(x)] = false
               (l:Any) :
                  loaded[n(x)] = Any()
                  num-free-reg = num-free-reg - 1
            match(saved?(x)) :
               (s:True|Any) : saved[n(x)] = s
         (x:DeadPort) :
            false

   defn currently-loaded () :
      stream{key, _} $
      for e in loaded filter :
         value(e) typeof True|Any

   ;Convenience
   defn save (x:Var) : save(n(x))
   defn load (x:Imm) : load(n(x as Var)) when x typeof Var
   defn load (xs:List<Imm>) : do(load, xs)
   defn kill (xs:Streamable<Int>) : do(kill, xs)
   defn define (x:Var) : define(n(x))
   defn define (xs:List<Var>) : do(define, xs)
   defn define (xs:List<Port>) : do(define, xs)

   ;Computes the number of spills required given the variables used,
   ;the releases following, and then the number of variables defined.
   defn num-spills-required (used:List<Imm>, rs:List<Int>, defs:List<Var>) :
      val num-loads = for u in unique-vars(used) count :
         loaded[n(u)] == false
      val num-released = for r in rs count :
         loaded[r] != false
      val num-results = length(defs)
      val additional = num-loads + max(0, num-results - num-released)
      max(0, additional - num-free-reg)

   defn spill (p:Pos, n:Int) :
      defn save-and-unload (x:Int) : (save(x), unload(x))
      defn dist (x:Int) : ut[x, p]
      if n == 1 :
         save-and-unload(maximum-by-key(currently-loaded(), dist))
      else if n > 1 :
         val vs = to-vector(currently-loaded())
         sort-by-key!(vs, dist)
         for i in 0 to n do :
            save-and-unload(pop(vs))

   ;     Analysis
   ;     --------   
   ;Live in variables
   let :
      define(in(b))
      val ns = max(0, neg(num-free-reg))
      spill(Pos(0,false), ns)

   ;Scan through instructions
   for (e in ins(b), i in 0 to false) do :      
      kill(releases-up-to(rt, Pos(i, false)))
      match(e) :
         (e:Set) :
            val rs = to-list(releases-up-to(rt, Pos(i, true)))
            val ns = num-spills-required(List(), rs, list(x(e)))
            spill(Pos(i,false), ns)
            kill(rs)
            define(x(e))
            emit(e)
         (e:Op) :
            val rs = to-list(releases-up-to(rt, Pos(i, true)))
            val ns = num-spills-required(ys(e), rs, xs(e))
            spill(Pos(i,false), ns)
            load(ys(e))
            kill(rs)
            define(xs(e))
            emit(e)
         (e:Branch) :
            val ns = num-spills-required(xs(e), List(), List())
            spill(Pos(i,false), ns)
            load(xs(e))
            emit(e)
         (e:Return) :
            emit(e)
         (e:Save) :
            save(x(e))
         (e:WArgs) :
            emit(e)
            define(xs(e))
            val ns = max(0, neg(num-free-reg))
            spill(Pos(i + 1,false), ns)
         (e:WCall) :
            emit(e)
            val rs = to-list(releases-up-to(rt, Pos(i, true)))
            kill(rs)
            define(xs(e))
            val ns = max(0, neg(num-free-reg))
            spill(Pos(i + 1, false), ns)

   ;Live out variables
   val out* = for x in out(b) map :
      LivePort(n(x),
               saved[n(x)],
               loaded[n(x)],
               loc(x))

   ;     Return Result
   ;     -------------
   WBlock(n(b), accum, next(b),
          in(b), out*, dist(b))



;                    Assumption Propagation
;                    ======================

definterface Assumption
defstruct Accept <: Assumption 
defstruct Assume <: Assumption : (value: True|False|Any)

defn propagate-assumptions (b:WBlock) :
   ;     Algorithm State
   ;     ---------------
   val save-assumptions = HashTable<Int, Assumption>({_})
   val load-assumptions = HashTable<Int, Assumption>({_})

   ;     Output State
   ;     ------------
   val accum = Vector<Ins>()
   defn emit (i:Ins) :
      add(accum, i)

   ;     Analysis Helpers
   ;     ----------------
   defn mark-port (x:Port) :
      match(x) :
         (x:LivePort) :
            load-assumptions[n(x)] = match(loaded?(x)) :
               (l:Any) : Accept()
               (l:True|False) : Assume(l)
            save-assumptions[n(x)] = match(saved?(x)) :
               (s:Any) : Accept()
               (s:True|False) : Assume(s)
         (x:DeadPort) :
            false

   defn get-port (x:Port) :
      defn get-value (x:Assumption) :
         match(x) :
            (x:Assume) : value(x)
            (x:Accept) : Any()            
      match(x) :
         (x:LivePort) :
            LivePort(n(x),
                     get-value(save-assumptions[n(x)]),
                     get-value(load-assumptions[n(x)]),
                     loc(x))
         (x:DeadPort) :
            x

   defn clear-assumptions () :
      clear(save-assumptions)
      clear(load-assumptions)

   defn save (x:Int) :
      match(get?(save-assumptions, x, false)) :
         (a:Accept) : save-assumptions[x] = Assume(true)
         (a:Assume|False) : emit(Save(Var(x)))
         
   defn load (x:Int) :
      match(get?(load-assumptions, x, false)) :
         (a:Accept) : load-assumptions[x] = Assume(true)
         (a:Assume|False) : emit(Load(Var(x)))

   defn unload (x:Int) :
      match(get?(load-assumptions, x, false)) :
         (a:Accept) : load-assumptions[x] = Assume(false)
         (a:Assume|False) : false

   defn define (x:Int) :
      if get?(load-assumptions, x, false) typeof Accept :
         load-assumptions[x] = Assume(Any())
      if get?(save-assumptions, x, false) typeof Accept :
         save-assumptions[x] = Assume(Any())

   ;Convenience
   defn save (x:Var) : save(n(x))
   defn load (x:Var) : load(n(x))
   defn unload (x:Var) : unload(n(x))
   defn define (x:Var) : define(n(x))
   defn define (xs:List<Var>) : do(define, xs)


   ;     Analysis
   ;     --------         
   defn* scan (ins:Stream<Ins>, process-assumptions: () -> False) :
      defn* continue () :
         scan(ins, process-assumptions)
         
      defn* continue-with-ports (ports:List<Port>, return: (List<Port>) -> Ins) :
         val i = length(accum)
         emit(Args(List())) ;Emit placeholder
         process-assumptions()
         clear-assumptions()
         do(mark-port, ports)
         scan{ins, _} $ fn* () :
            val ports* = map(get-port, ports)
            accum[i] = return(ports*)

      if more?(ins) :
         match(next(ins)) :
            (e:Set) : (define(x(e)), emit(e), continue())
            (e:Op) : (define(xs(e)), emit(e), continue())
            (e:Branch) : (emit(e), continue())
            (e:Return) : (emit(e), continue())
            (e:Save) : (save(x(e)), continue())
            (e:Load) : (load(x(e)), continue())
            (e:Unload) : (unload(x(e)), continue())
            (e:WArgs) : continue-with-ports(xs(e), WArgs{_})
            (e:WCall) : continue-with-ports(xs(e),
                           WCall{arity(e), _, f(e), ys(e)})
      else :
         process-assumptions()

   ;Scan and process input ports
   do(mark-port, in(b))
   var in*
   scan{to-stream(ins(b)), _} $ fn* () :
      in* = map(get-port, in(b)) as List<LivePort>

   ;     Return result
   ;     -------------
   WBlock(n(b),
          accum,
          next(b),
          in*,
          out(b),
          dist(b))



;                      Register Assignment
;                      ===================

;     Assignment Mini-Language
;     ------------------------
defstruct FreeReg <: Loc :
   prefer: List<Int>
   prefer-not: List<Int>
   
defn FreeReg (p:List<Int>) : FreeReg(p, List())
defn FreeReg () : FreeReg(List(), List())

defmethod print (o:OutputStream, f:FreeReg) :
   print(o, "FreeReg(~@ not ~@)" << [cms(prefer(f)) cms(prefer-not(f))])

;     Algorithm
;     ---------
defn register-assignment (b:WBlock, ports-in:List<LivePort>) :
   ;     Utilities
   ;     ---------
   ;Convert list of liveports to a table of locations
   defn ports-to-table (ports:List<LivePort>) :
      val table = HashTable<Int,Loc>({_})
      for p in ports do :
         table[n(p)] = loc(p)
      table

   ;Retrieve all the liveports in the given list
   defn liveports (ports:List<Port>) :
      val ports* = to-list $
         for p in ports filter :
            p typeof LivePort
      ports* as List<LivePort>

   ;Retrieve all Vars in given immediates
   defn vars-in (xs:Streamable<Imm>) :
      {_ as Stream<Var>} $
         for x in xs filter :
            x typeof Var

   ;Retrieve all Registers in given immediates
   defn regs-in (xs:List<Imm>) -> List<Int> :
      val locs = stream(loc, vars-in(xs))
      val regs = filter({_ typeof Reg}, locs)
      to-list(stream(n, regs as Stream<Reg>))

   ;     Algorithm State
   ;     ---------------
   val locs = HashTable<Int,Loc>({_})
   val reg-slots = Array<False|Int>(8, false)
   val rt = release-table(b)

   ;     Output State
   ;     ------------
   val accum = Vector<Ins>()
   defn emit (i:Ins) :
      add(accum, i)      

   ;     State Updaters
   ;     --------------
   defn assign (x:Int, l:Loc) :
      defn next-free-reg (pref:List<Int>, npref:List<Int>) :
         label<Reg> return :
            ;First try preferred registers
            for r in pref do :
               if not contains?(npref, r) :
                  return(Reg(r)) when reg-slots[r] == false
            ;Otherwise search for free register   
            val i = for i in 0 to length(reg-slots) find! :
               reg-slots[i] == false
            Reg(i)

      match(l) :
         (l:FreeReg) : assign(x, next-free-reg(prefer(l), prefer-not(l)))
         (l:Stack) : locs[x] = l
         (l:Reg) :
            locs[x] = l
            reg-slots[n(l)] = x
      
   defn assign (xs:List<Int>, ls:List<Loc>) :         
      ;First assign stacks and regs
      for (x in xs, l in ls) do :
         assign(x, l) when l typeof Stack|Reg            
      ;Next assign free registers
      for (x in xs, l in ls) do :
         assign(x, l) when l typeof FreeReg

   ;Convenience
   defn assign (x:Var, l:Loc) :
      assign(n(x), l)
   defn assign (xs:List<Var>, ls:List<Loc>) :
      assign(map(n, xs), ls)      
   defn assign (xs:List<LivePort>, ls:List<Loc>) :
      assign(map(n, xs), ls)

   ;Update state by freeing the given variable
   defn free (x:Int) :
      match(locs[x]) :
         (loc:Reg) :
            reg-slots[n(loc)] = false
            locs[x] = Stack(x)
         (loc) : false

   defn free (xs:Streamable<Int>) :
      do(free, xs)

   ;     State Reader
   ;     ------------
   ;Fill the given immediate with its location
   defn fill<?T> (x:?T&Imm) :
      {_ as T&Imm} $ match(x) :
         (x:Var) : Var(n(x), locs[n(x)])
         (x:Val) : x
   defn fill<?T> (xs:List<?T&Imm>) -> List<T> :
      map(fill, xs)

   ;Fill the given port with its location
   defn fill<?T> (x:?T&Port) :
      {_ as T&Port} $ match(x) :
         (x:LivePort) :
            val sv = match(saved?(x)) :
               (sv:True) : sv
               (sv:False|Any) : false
            val loc = locs[n(x)]
            val ld = loc typeof Reg
            LivePort(n(x), sv, ld, loc)
         (x:DeadPort) : x
   defn fill<?T> (xs:List<?T&Port>) -> List<T> :
      map(fill, xs)

   ;     Swap Helpers
   ;     ------------
   ;Find a register that is either free, or one of the given registers
   ;and is not vetoed.
   defn swap-reg (free:List<Int>, veto:List<Int>) :
      label<Int> return :
         ;Try to find a free register
         val i = for i in 0 to length(reg-slots) find :
            (not contains?(veto, i)) and
            reg-slots[i] == false
         return(i as Int) when i typeof Int
         ;Find one of the given registers
         for i in 0 to length(reg-slots) find! :
            (not contains?(veto, i)) and
            contains?(free, reg-slots[i])

   ;Swap the two register contents
   defn swap (src:Int, dst:Int) :
      if reg-slots[dst] == false :
         val x = reg-slots[src] as Int
         emit(Set(Var(x, Reg(dst)), Var(x, Reg(src))))
         free(x)
         assign(x, Reg(dst))
      else :
         val x = reg-slots[src] as Int
         val y = reg-slots[dst] as Int
         val swap = for i in 0 to length(reg-slots) search :
            if (i != src) and (i != dst) and (reg-slots[i] == false) :
               Reg(i)
         emit(Xchg(Var(x, Reg(src)), Var(y, Reg(dst)), swap))
         free(x)
         free(y)
         assign(x, Reg(dst))
         assign(y, Reg(src))
            
   ;Ensure that the following registers are free
   defn ensure-free (reg:List<Int>, rs:List<Int>) :
      defn* loop (reg:List<Int>, veto:List<Int>) :
         if not empty?(reg) :
            val r = head(reg)
            if (reg-slots[r] != false) and not contains?(rs, reg-slots[r]) :
               swap(r, swap-reg(rs, veto))
            loop(tail(reg), List(r, veto))
      loop(reg, List())

   ;Ensure that the following value is in a certain register
   defn ensure-reg (x:Int, r:Int) :
      val src = n(locs[x] as Reg)
      swap(src, r) when src != r

   ;     Analysis
   ;     --------
   
   ;Assign initial registers   
   val in* = let :
      val pt = ports-to-table(ports-in)
      val locs = for x in in(b) map :
         match(loaded?(x), pt[n(x)]) :
            (ld:True, loc:Reg) : loc
            (ld:True, loc:Stack) : FreeReg()
            (ld:False, loc) : Stack(n(x))
            (ld:Any, loc) : loc
      assign(in(b), locs)
      fill(in(b))
   
   ;Assign concrete locations
   for (e in ins(b), i in 0 to false) do :
      free(releases-up-to(rt, Pos(i, false)))
      match(e) :
         (e:Set) :
            val y* = fill(y(e))
            free(releases-up-to(rt, Pos(i, true)))
            assign(x(e), FreeReg(regs-in(list(y*))))
            emit(Set(fill(x(e)), y*))
         (e:Op) :
            ;Implement different rules depending on operation type
            val ys* = match(op(e)) :
               (op:ComOp) :
                  val ys* = fill(ys(e))
                  free(releases-up-to(rt, Pos(i, true)))
                  assign(head(xs(e)), FreeReg(regs-in(ys*)))
                  ys*
               (op:NComOp) :
                  val ys* = fill(ys(e))
                  free(releases-up-to(rt, Pos(i, true)))
                  assign(head(xs(e)), FreeReg(regs-in(list(ys*[0])),
                                              regs-in(list(ys*[1]))))
                  ys*
               (op:DivOp) :
                  val rs = to-list(releases-up-to(rt, Pos(i, true)))
                  ensure-free(list(0), rs)
                  val ys* = fill(ys(e))
                  free(rs)
                  assign(head(xs(e)), Reg(0))
                  ys*
            emit(Op(op(e), fill(xs(e)), ys*))
         (e:Branch) :
            emit(Branch(op(e), fill(xs(e))))
         (e:Return) :
            emit(Return(fill(xs(e))))
         (e:Save) :
            emit(Save(fill(x(e))))            
         (e:Load) :
            assign(list(x(e)), list(FreeReg()))
            emit(Load(fill(x(e))))
         (e:WArgs) :
            val lxs = liveports(xs(e))
            val locs = for x in lxs map :
               match(loaded?(x)) :
                  (l:True|Any) : FreeReg()
                  (l:False) : Stack(n(x))
            assign(lxs, locs)
            emit(WArgs(fill(xs(e))))
         (e:WCall) :
            val f* = fill(f(e))
            val ys* = fill(ys(e))
            free(releases-up-to(rt, Pos(i, true)))
            val lxs = liveports(xs(e))
            val locs = for x in lxs map :
               match(loaded?(x)) :
                  (l:True|Any) : FreeReg()
                  (l:False) : Stack(n(x))
            assign(lxs, locs)
            emit(WCall(arity(e), fill(xs(e)), f*, ys*))
   
   ;Output locations
   val out* = fill(out(b))

   ;     Return result
   ;     -------------
   WBlock(n(b), accum, next(b),
          in*, out*, dist(b))


defn register-assignment (p:Unit) :
   ;     Algorithm State
   ;     ---------------
   val block-table = HashTable<Int,False|WBlock>({_})
   val blocks* = Vector<Block>()

   ;     Algorithm
   ;     ------------------   
   ;Initially fill table
   for b in blocks(p) do :
      block-table[n(b)] = b as WBlock

   ;Assign registers to the given block   
   defn assign-regs (b:WBlock, ports-in:List<LivePort>) :
      val b* = register-assignment(b, ports-in)
      add(blocks*, b*)
      block-table[n(b*)] = false
      b*

   ;Assign registers to successors
   defn* assign-successors (b:WBlock) :
      for n in next(b) do :
         match(block-table[n]) :
            (s:WBlock) : assign-successors(assign-regs(s, out(b)))
            (s:False) : false

   ;Driver
   val b0 = blocks(p)[0] as WBlock
   val b0* = assign-regs(b0, List())
   assign-successors(b0*)
   Unit(defs(p), blocks*)
   



;                   Register Assignment Verification
;                   ================================

defn verify-register-assignment (b:WBlock) :
   ;     Algorithm State
   ;     ---------------
   val regs = Array<False|Int>(8, false)
   val saved = HashTable<Int,True|False>({_})

   ;     State Updaters
   ;     --------------
   defn define (x:Port) :
      match(x) :
         (x:LivePort) :
            match(saved?(x), loaded?(x), loc(x)) :
               (sv:True, ld:True, loc:Reg) :
                  regs[n(loc)] = n(x)
                  saved[n(x)] = true
               (sv:False, ld:True, loc:Reg) :
                  regs[n(loc)] = n(x)
                  saved[n(x)] = false
               (sv:True, ld:False, loc:Stack) :
                  saved[n(x)] = true
         (x:DeadPort) :
            false

   defn define (x:Var) :
      val r = n(loc(x) as Reg)
      regs[r] = n(x)
      saved[n(x)] = false

   defn mov (x:Var, y:Imm) :
      val r = n(loc(x) as Reg)
      regs[r] = n(x)
      match(y) :
         (y:Val) :
            saved[n(x)] = false
         (y:Var) : 
            if n(x) != n(y) :
               saved[n(x)] = false

   defn load (x:Var) :
      val r = n(loc(x) as Reg)
      regs[r] = n(x)

   defn save (x:Var) :
      saved[n(x)] = true

   defn clear-registers () :
      for i in 0 to length(regs) do :
         regs[i] = false

   defn swap-register-contents (x:Reg, y:Reg) :
      val vx = regs[n(x)]
      val vy = regs[n(y)]
      regs[n(x)] = vy
      regs[n(y)] = vx   

   ;     State Checkers
   ;     --------------
   defn reg! (x:Imm) :
      match(x) :
         (x:Var) : loc(x) as Reg
         (x:Val) : false
   defn saved! (x:Int) : saved[x] as True
   defn saved! (x:Var) : saved!(n(x))
   defn not-saved! (x:Int) : saved[x] as False
   defn holds! (r:Reg, x:Int) : (regs[n(r)] == x) as True
   defn holds! (r:Reg, x:Var) : holds!(r, n(x))
   
   defn check! (p:Port) :
      match(p) :
         (p:LivePort) :
            match(saved?(p), loaded?(p), loc(p)) :
               (sv:True, ld:True, lc:Reg) :
                  holds!(lc, n(p))
                  saved!(n(p))
               (sv:False, ld:True, lc:Reg) :
                  holds!(lc, n(p))
                  not-saved!(n(p))
               (sv:True, ld:False, lc:Stack) :
                  saved!(n(p))
         (p:DeadPort) :
            false

   defn check! (x:Imm) :
      match(x) :
         (x:Var) :
            match(loc(x)) :
               (l:Reg) : holds!(l, n(x))
               (l:Stack) : saved!(n(x))
         (x:Val) : false

   ;     Algorithm
   ;     ---------
   
   ;Input ports
   do(define, in(b))

   ;Check each instruction
   for e in ins(b) do :
      match(e) :
         (e:Set) :
            check!(y(e))
            reg!(x(e))
            mov(x(e), y(e))
         (e:Xchg) :
            check!(x(e))
            check!(y(e))
            val rx = loc(x(e)) as Reg
            val ry = loc(y(e)) as Reg
            swap-register-contents(rx, ry)
         (e:Op) :
            ;General operations
            for y in ys(e) do : (check!(y), reg!(y))
            for x in xs(e) do : (reg!(x), define(x))

            ;OpClass post conditions
            match(op(e)) :
               (op:DivOp) : holds!(Reg(0), head(xs(e)))
               (op) : false
         (e:Branch) :
            for x in xs(e) do : (check!(x), reg!(x))
         (e:Return) :
            do(check!, xs(e))
         (e:Save) :
            check!(x(e))
            save(x(e))
         (e:Load) :
            saved!(x(e))
            load(x(e))
         (e:WArgs) :
            do(define, xs(e))
         (e:WCall) :
            do(check!, ys(e))
            check!(f(e))
            clear-registers()
            do(define, xs(e))

   ;Output ports
   do(check!, out(b))



;                    Stack Location Calculation
;                    ==========================

;     Interval Structure
;     ------------------
definterface Interval
defstruct StartInterval <: Interval :
   n: Int
defstruct EndInterval <: Interval :
   n: Int

defmethod print (o:OutputStream, i:Interval) :
   print{o, _} $ match(i) :
      (i:StartInterval) : "Start(~)" << [n(i)]
      (i:EndInterval) : "End(~)" << [n(i)]


;     Calculating Stack Intervals
;     ---------------------------
defn stack-intervals (p:Unit) :
   ;     Algorithm State
   ;     ---------------
   val var-start = HashTable<Int,Int>({_})
   val var-end = HashTable<Int,Int>({_})

   ;     State Updaters
   ;     --------------
   defn note-usage (x:Int, i:Int) :
      if key?(var-start, x) :
         var-start[x] = min(i, var-start[x])
         var-end[x] = max(i, var-end[x])
      else :
         var-start[x] = i
         var-end[x] = i

   defn note-usage (p:Port, i:Int) :
      match(p) :
         (p:LivePort) : note-usage(n(p), i) when saved?(p) == true
         (p:DeadPort) : false

   defn note-usage (x:Imm, i:Int) :
      match(x) :
         (x:Var) :
            match(loc(x)) :
               (l:Stack) : note-usage(n(x), i)
               (l) : false
         (x) : false

   ;Convenience
   defn note-usage (ps:List<Port>, i:Int) :
      for p in ps do : note-usage(p, i)
   defn note-usage (xs:List<Imm>, i:Int) :
      for x in xs do : note-usage(x, i)

   ;     Note all usages in instructions
   ;     -------------------------------
   defn find-usages (st:Int, b:WBlock) -> Int :
      val cnt = to-stream(st to false)
      note-usage(in(b), next(cnt))
      for e in ins(b) do :
         val i = next(cnt)
         match(e) :
            (e:Set) : note-usage(y(e), i)
            (e:Xchg) : false
            (e:Op) : false
            (e:Branch) : false
            (e:Return) : note-usage(xs(e), i)
            (e:Save) : note-usage(n(x(e)), i)
            (e:Load) : note-usage(n(x(e)), i)
            (e:WArgs) : note-usage(xs(e), i)
            (e:WCall) :
               note-usage(ys(e), i)
               note-usage(f(e), i)
               note-usage(xs(e), i)
      note-usage(out(b), next(cnt))
      next(cnt)
      
   val num-pos = let :
      val bs = reverse-post-order(blocks(p))
      reduce(find-usages, 0, bs as Vector<WBlock>)

   ;     Return ordered result
   ;     ---------------------
   val intervals = Array<List<Interval>>(num-pos, List())
   for e in var-end do :
      val v = key(e)
      val i = value(e)
      intervals[i] = List(EndInterval(v), intervals[i])
   for e in var-start do :
      val v = key(e)
      val i = value(e)
      intervals[i] = List(StartInterval(v), intervals[i])
   concat-all(intervals)
      


;     Calculating Stack Map
;     ---------------------

;Interface
defclass StackMap
defmulti stack-offset (s:StackMap, x:Stack) -> Int
defmulti size (s:StackMap) -> Int

;Location Calculation
defn calculate-stack-map (u:Unit) :
   println("TODO: Needs to take different types into account.")
   
   ;     Algorithm State
   ;     ---------------
   val ints = stack-intervals(u)
   val occupied = Vector<False|True>()

   ;     Output State
   ;     ------------
   val var-locs = HashTable<Int,Int>({_})

   ;     Utilities
   ;     ---------
   defn assign-loc (x:Int, s:Int) :
      occupied[s] as False ;Ensure unoccupied
      var-locs[x] = s
      occupied[s] = true

   defn free-var (x:Int) :
      val l = var-locs[x]
      occupied[l] as True
      occupied[l] = false

   defn next-free-loc () :
      label<Int> return :
         ;Find unoccupied location
         val n = length(occupied)
         for i in 0 to n do :
            return(i) when occupied[i] == false
         ;Or create a new location
         add(occupied, false)
         n

   ;     Algorithm
   ;     ---------
   for i in ints do :
      match(i) :
         (i:StartInterval) : assign-loc(n(i), next-free-loc())
         (i:EndInterval) : free-var(n(i))

   ;     Return table
   ;     ------------
   new StackMap :
      defmethod stack-offset (this, x:Stack) :
         val i = var-locs[n(x)]
         16 + 8 * i
      defmethod size (this) :
         val n = length(occupied)
         16 + 8 * n


;                      Block Collapsing
;                      ================

defn collapse-blocks (u:Unit) -> Vector<Ins> :
   ;     Utilities
   ;     ---------
   ;Convert list of liveports to a table of ports
   defn ports-to-table (ports:List<LivePort>) :
      val table = HashTable<Int,LivePort>({_})
      for p in ports do :
         table[n(p)] = p
      table
      
   ;     Block Statistics
   ;     ----------------
   val block-table = HashTable<Int, WBlock>({_})
   val block-pos = HashTable<Int,Int>({_})
   val block-preds = HashTable<Int, List<Int>>({_})
   val glue-entry = HashTable<Int, True>({_})
   val glue-exit = HashTable<Int, True>({_})

   ;Retrieve the predecessors of a block
   defn preds (b:WBlock) :
      for p in get?(block-preds, n(b), List()) map :
         block-table[p]

   ;Retrieve the successors of a block
   defn succs (b:WBlock) :
      for n in next(b) map :
         block-table[n]

   ;Fill block statistics
   for (b in blocks(u), i in 0 to false) do :
      block-table[n(b)] = b as WBlock
      block-pos[n(b)] = i
      val multi-out? = length(next(b)) > 1
      for nx in next(b) do :
         block-preds[nx] = List(n(b), get?(block-preds, nx, List()))
         (glue-entry[nx] = true) when multi-out?

   ;Compute exit glue
   for e in block-preds do :
      val multi-in? = length(value(e)) > 1
      if multi-in? :
         for p in value(e) do :
            glue-exit[p] = true

   ;     Utilities
   ;     ---------
   defn follows? (b:Block, nx:Int) :
      block-pos[nx] == block-pos[n(b)] + 1

   ;     Output State
   ;     ------------
   val accum = Vector<Ins>()
   defn emit (i:Ins) : add(accum, i)

   ;     Algorithm
   ;     ---------
   ;Glue src ports to dst ports
   defn glue (src:List<LivePort>, dst:List<LivePort>) :
      ;Calculate src table first
      val src-table = ports-to-table(src)
      val src* = for d in dst map :
         src-table[n(d)]
      
      ;Emit Required Saves
      for (x in src*, y in dst) do :
         match(saved?(x), saved?(y)) :
            (sx:False, sy:True) :
               emit(Save(Var(n(x), loc(x))))
            (sx, sy) : false
            
      ;Emit Shuffle
      val es = Vector<KeyValue<Var,Var>>()
      for (x in src*, y in dst) do :
         match(loc(x), loc(y)) :
            (lx:Reg, ly:Reg) : add(es, Var(n(y), ly) => Var(n(x), lx))
            (lx, ly) : false
      emit(Shuffle(to-list(stream(key,es)),
                   to-list(stream(value,es))))
         
      ;Emit Required Loads
      for (x in src*, y in dst) do :
         match(loaded?(x), loaded?(y)) :
            (lx:False, ly:True) :
               emit(Load(Var(n(y), loc(y))))
            (sx, sy) : false
            
   ;Emit instructions needed to collapse the given block
   defn collapse (b:WBlock, i:Int) :
      ;Emit block label
      emit(Label(n(b)))
      
      ;Emit entry glue
      if key?(glue-entry, n(b)) :
         val pred = head(preds(b))
         glue(out(pred), in(b))

      ;Emit instructions
      for e in ins(b) do :
         match(e) :
            (e:Branch) :
               val conseq = next(b)[0]
               val alt = next(b)[1]
               match(follows?(b, conseq), follows?(b, alt)) :
                  (fc:True, fa:False) :
                     emit(Break(alt, op(e), xs(e), true))
                  (fc:False, fa:True) :
                     emit(Break(conseq, op(e), xs(e), false))
                  (fc:False, fa:False) :
                     emit(Break(conseq, op(e), xs(e), false))
                     emit(Goto(alt))
            (e) :
               emit(e)

      ;Emit exit glue
      if key?(glue-exit, n(b)) :
         val succ = head(succs(b))
         glue(out(b), in(succ))

      ;Emit goto if necessary
      if length(next(b)) == 1 :
         val n = head(next(b))
         emit(Goto(n)) when not follows?(b, n)

   ;     Driver
   ;     ------
   for (b in blocks(u), i in 0 to false) do :
      collapse(b as WBlock, i)
   accum   
      
      
            
;                    Compilation to ASM
;                    ==================

;     Parallel Assignment Mini-Language
;     ---------------------------------
defstruct Arg <: Loc :
   n: Int

defmethod print (o:OutputStream, a:Arg) :
   print(o, "Arg(~)" << [n(a)])
   
;     Compilation
;     -----------
defn compile (ins:Vector<Ins>, stackmap:StackMap, output:Vector<asm-Ins>) :
   println("TODO: Need Args label here.")
   println("TODO: Need to calculate stack offsets properly still.")

   ;     Output State
   ;     ------------
   defn emit (i:asm-Ins) :
      add(output, i)

   ;     Helper Conversion Functions
   ;     ---------------------------
   ;Abbreviations for asm types
   val LT = asm-LONG-TYPE

   ;Move value from y to x
   defn mov (x:Loc, y:Loc|Val) :
      emit $ match(x, y) :
         (x:Reg, y:Reg|Val) :
            asm-SetIns(LT, reg(x), imm(y))
         (x:Reg, y:Arg|Stack) :
            asm-Load(LT, reg(x), base(y), offset(y))
         (x:Arg|Stack, y:Reg|Val) :
            asm-Store(LT, base(x), imm(y), offset(x))
         (x:Arg|Stack, y:Arg|Stack) :
            error("Cannot be moved directly.")

   ;Exchange values in two locations
   defn xchg (x:Loc, y:Loc) :
      emit(asm-XchgIns(LT, reg(x), reg(y)))

   ;Convert a value into an asm immediate
   defn imm (x:Loc|Val) :
      match(x) :
         (x:Reg) :
            asm-Reg(n(x))
         (x:Val) :
            match(value(x)) :
               (v:tgt-ByteImm|tgt-IntImm|tgt-LongImm) :
                  asm-IntImm(tgt-value(v))
               (v:tgt-Mem) :
                  asm-Mem(tgt-n(v))

   ;Convert a value into an asm register
   defn reg (x:Loc) :
      imm(x) as asm-Reg

   ;Retrieve the base address of a value
   defn base (x:Loc) :
      match(x) :
         (x:Stack) : asm-RegSP()
         (x:Arg) : asm-Mem(tgt-ARG-LBL)

   ;Retrieve the offset of a value
   defn offset (x:Loc) :
      match(x) :
         (x:Stack) : stack-offset(stackmap, x)
         (x:Arg) : 8 * n(x)

   ;Retrieve the stack location of the given variable
   defn stack-loc (x:Var) :
      Stack(n(x))

   ;Retrieve the corresponding asm operator from a TGT operator
   defn op-of (x:tgt-TgtOp) :
      switch {x == _} :
         tgt-ADD-OP : asm-ADD-OP
         tgt-SUB-OP : asm-SUB-OP
         tgt-MUL-OP : asm-MUL-OP
         tgt-DIV-OP : asm-DIV-OP
         tgt-MOD-OP : asm-MOD-OP
         tgt-AND-OP : asm-AND-OP
         tgt-OR-OP : asm-OR-OP
         tgt-XOR-OP : asm-XOR-OP
         tgt-SHL-OP : asm-SHL-OP
         tgt-SHR-OP : asm-SHR-OP
         tgt-ASHR-OP : asm-ASHR-OP
         tgt-EQ-OP : asm-EQ-OP
         tgt-NE-OP : asm-NE-OP
         tgt-LT-OP : asm-LT-OP
         tgt-GT-OP : asm-GT-OP
         tgt-LE-OP : asm-LE-OP
         tgt-GE-OP : asm-GE-OP
         tgt-ULE-OP : asm-ULE-OP
         tgt-ULT-OP : asm-ULT-OP
         tgt-UGT-OP : asm-UGT-OP
         tgt-UGE-OP : asm-UGE-OP

   ;Return the opposite comparison operator
   defn invert (op:asm-AsmOp) :
      switch {op == _} :
         asm-EQ-OP : asm-NE-OP
         asm-NE-OP : asm-EQ-OP
         asm-LT-OP : asm-GE-OP
         asm-GT-OP : asm-LE-OP
         asm-LE-OP : asm-GT-OP
         asm-GE-OP : asm-LT-OP
         asm-ULE-OP : asm-UGT-OP
         asm-ULT-OP : asm-UGE-OP
         asm-UGT-OP : asm-ULE-OP
         asm-UGE-OP : asm-ULT-OP

   ;     Utilities
   ;     ---------
   ;Retrieve from the stack table the appropriate locations
   defn immloc (x:Imm) -> Loc|Val :
      match(x) :
         (x:Var) : loc(x)
         (x:Val) : x

   defn portloc (x:Port) :
      match(x) :
         (x:LivePort) : loc(x)
         (x:DeadPort) : false

   ;     Parallel Assignment
   ;     -------------------
   val occupied = Array<True|False>(8)
   defn unused (xs:Streamable<Reg>) :
      val nr = length(occupied)
      for i in 0 to nr do : occupied[i] = false
      for x in xs do : occupied[n(x)] = true
      val i = for i in 0 to 8 find : not occupied[i]
      Reg(i as Int) when i != false
         
   defn parmov (xs:List<False|Loc>, ys:List<Loc|Val>) :
      ;Different Assignment Priorities
      val saves = Vector<KeyValue<Loc, Loc|Val>>()
      val shuffles = Vector<KeyValue<Reg, Reg>>()
      val swaps = Vector<KeyValue<Loc, Loc|Val>>()
      val loads = Vector<KeyValue<Reg, Loc|Val>>()

      ;Convenience
      defn keys<?K> (vs:Streamable<KeyValue<?K,?>>) : 
         to-list(stream(key, vs))
      defn values<?V> (vs:Streamable<KeyValue<?,?V>>) : 
         to-list(stream(value, vs))

      ;Set priorities
      for (x in xs, y in ys) do :
         match(x, y) :
            (x:Arg|Stack, y:Reg|Val) : add(saves, x => y)
            (x:Reg, y:Reg) : add(shuffles, x => y)
            (x:Arg|Stack, y:Arg|Stack) : add(swaps, x => y)
            (x:Reg, y:Arg|Stack|Val) : add(loads, x => y)
            (x:False, y) : false
            
      ;Emit saves
      for e in saves do :
         mov(key(e), value(e))
      ;Emit shuffle
      shuffle(keys(shuffles), values(shuffles))
      ;Emit swaps
      let :
         val swap = unused(keys(shuffles)) as Reg
         for e in swaps do :
            mov(swap, value(e))
            mov(key(e), swap)
      ;Emit loads
      for e in loads do :
         mov(key(e), value(e))   

   ;     Calling Convention
   ;     ------------------
   defn call-locations (xs:List<False|Loc|Val>) :
      val locs = concat(
         stream(Reg, [2 3 4 5 6 7])
         stream(Arg, 0 to false))         
      to-list $ for (x in xs, l in locs) stream :
         l
   defn call-locations (f:Loc|Val, xs:List<Loc|Val>) :
      List(Reg(1), call-locations(xs))

   ;     Register Shuffling
   ;     ------------------
   defn shuffle (xs:List<Reg>, ys:List<Reg>) :
      ;Create predecessor and successor table
      val pred = Array<False|Int>(8,false)
      val succs = Array<List<Int>>(8, List())
      
      ;Fill tables
      for (x in xs, y in ys) do :
         pred[n(x)] = n(y)
         succs[n(y)] = List(n(x), succs[n(y)])

      ;Resolve a cycle
      defn* cycle (xs:List<Int>) :
         if not empty?(tail(xs)) :
            val x = head(xs)
            val p = pred[x] as Int
            xchg(Reg(x), Reg(p))
            for s in succs[x] do :
               pred[s] = p
            cycle(tail(xs))

      ;Issue shuffling commands
      val graph = stream(KeyValue, 0 to false, succs)
      for c in strong-components(graph) do :
         match(c) :
            (c:List<Int>) :
               cycle(c)
            (c:Int) :
               if pred[c] != false :
                  mov(Reg(c), Reg(pred[c] as Int))

   ;     Convert Instructions
   ;     --------------------
   for e in ins do :
      println("Converting ~" << [e])
      match(e) :
         (e:Set) :
            mov(loc(x(e)), immloc(y(e)))
         (e:Xchg) :
            xchg(loc(x(e)), loc(y(e)))
         (e:Op) :
            emit $ match(op(e)) :
               (opc:ComOp|NComOp|DivOp|CmpOp) :
                  val rx = reg(loc(xs(e)[0]))
                  val ry = imm(immloc(ys(e)[0]))
                  val rz = imm(immloc(ys(e)[1]))
                  val op = op-of(op(opc))
                  asm-BinOp(LT, rx, op, ry, rz)
         (e:Return) :
            val ys* = map(immloc, xs(e))
            val xs* = call-locations(ys*)
            parmov(xs*, ys*)
            emit(asm-Return())
         (e:Save) :
            mov(stack-loc(x(e)), loc(x(e)))
         (e:Load) :
            mov(loc(x(e)), stack-loc(x(e)))
         (e:WArgs) :
            val xs* = map(portloc, xs(e))
            val ys* = call-locations(xs*)
            println("xs* = ~, ys* = ~" << [xs*, ys*])
            parmov(xs*, ys*)
         (e:WCall) :
            ;Move arguments into position, and call
            val f* = match(f(e)) :
               (f:Var) :               
                  val f* = immloc(f)
                  val ys* = map(immloc, ys(e))
                  val xs* = call-locations(f*, ys*)
                  parmov(xs*, List(f*, ys*))
                  imm(f*)
               (f:Val) :
                  val ys* = map(immloc, ys(e))
                  val xs* = call-locations(ys*)
                  parmov(xs*, ys*)
                  imm(f)
            ;Call
            mov(Reg(0), Val(tgt-IntImm(arity(e))))
            emit(asm-BinOp(LT, asm-RegSP(), asm-ADD-OP, asm-RegSP(), asm-IntImm(size(stackmap) + 8)))
            emit(asm-Call(f*))
            emit(asm-BinOp(LT, asm-RegSP(), asm-SUB-OP, asm-RegSP(), asm-IntImm(size(stackmap) + 8)))
            
            ;Move return values out from Args
            let :
               val xs* = map(portloc, xs(e))
               val ys* = call-locations(xs*)
               parmov(xs*, ys*)
         (e:Shuffle) :
            val xs* = map(loc, xs(e))
            val ys* = map(loc, ys(e))
            shuffle(xs* as List<Reg>, ys* as List<Reg>)
         (e:Label) :
            emit(asm-Label(n(e)))
         (e:Goto) :
            emit(asm-Goto(asm-Mem(n(e))))
         (e:Break) :
            emit $ match(op(e)) :
               (opc:CmpOp) :
                  val rx = imm(immloc(xs(e)[0]))
                  val ry = imm(immloc(xs(e)[1]))
                  val op = op-of(op(opc))
                  asm-Branch{LT, asm-Mem(n(e)), _, rx, ry} $
                     if flip?(e) : invert(op)
                     else : op
