defpackage stz/earley-main :
  import core
  import collections
  import stz/earley-lang
  import stz/earley-grammar
  import stz/earley-grammar-analysis
  import stz/earley-syntax-package
  import stz/earley-syntax-package-rules
  import stz/earley-parser
  import stz/earley-errors

;============================================================
;=============== Register Syntax Packages ===================
;============================================================

val SYNTAX-PACKAGES = HashTable<Symbol,SyntaxPackage>()

public defn register-syntax-package (p:SyntaxPackage) :
  if key?(SYNTAX-PACKAGES, name(p)) :
    fatal("Syntax package definition not yet supported.")
  SYNTAX-PACKAGES[name(p)] = p

;============================================================
;====================== Overlays ============================
;============================================================

var ACTIVE-SYNTAX:Tuple<Symbol> = []

defn resolve-syntaxes (syntaxes:List<Symbol>) -> Tuple<Symbol> :
  val syntax-set = HashSet<Symbol>()
  val syntax-list = Vector<Symbol>()
  defn add-syntax (name:Symbol) :
    add(syntax-list,name) when add(syntax-set, name)
  for name in syntaxes do :
    if name == `current-overlays : do(add-syntax, ACTIVE-SYNTAX)
    else : add-syntax(name)
  to-tuple(syntax-list)

defn with-active-syntax<?T> (body:() -> ?T, syntaxes:Tuple<Symbol>) :
  let-var ACTIVE-SYNTAX = syntaxes :
    body()

;============================================================
;================ Syntax Package Analysis ===================
;============================================================

val ANALYZED-PACKAGES = HashTable<Tuple<Symbol>, AnalyzedSyntaxPackage>()

;Returns the AnalyzedSyntaxPackage corresponding to the given packages.
;Throws an exception if syntax packages contain errors.
defn analyzed-syntax-package (packages:Tuple<Symbol>) -> AnalyzedSyntaxPackage :
  if not key?(ANALYZED-PACKAGES, packages) :
    ;Get syntax packages
    val pkgs = for name in packages map :
      match(get?(SYNTAX-PACKAGES, name)) :
        (p:SyntaxPackage) : p
        (f:False) : throw(CannotResolveSyntaxPackage(name))
    val package-tables = new SyntaxPackageTables :
      defmethod get (this, name:Symbol) : get?(SYNTAX-PACKAGES, name)
    match(analyze(pkgs[0], pkgs[1 to false], package-tables)) :
      (p:AnalyzedSyntaxPackage) : ANALYZED-PACKAGES[packages] = p
      (e:EarleySyntaxErrors) : throw(e)
  ANALYZED-PACKAGES[packages]    

;============================================================
;=================== Pattern Analysis =======================
;============================================================

deftype PatternStructure <: Hashable & Equalable
defmulti packages (s:PatternStructure) -> Tuple<Symbol>

defstruct MatchPatternStructure <: PatternStructure :
  packages: Tuple<Symbol> with: (as-method => true)
  patterns: Tuple<List>

defstruct ParsePatternStructure <: PatternStructure :
  packages: Tuple<Symbol> with: (as-method => true)
  pattern: List

defmethod hash (s:MatchPatternStructure) :
  hash([packages(s), patterns(s)])

defmethod hash (s:ParsePatternStructure) :
  hash([packages(s), pattern(s)])

defmethod equal? (a:MatchPatternStructure, b:MatchPatternStructure) :
  packages(a) == packages(b) and
  patterns(a) == patterns(b)

defmethod equal? (a:ParsePatternStructure, b:ParsePatternStructure) :
  packages(a) == packages(b) and
  pattern(a) == pattern(b)

val PATTERN-GRAMMARS = HashTable<PatternStructure,Grammar>()
defn pattern-grammar (s:PatternStructure) -> Grammar :
  if not key?(PATTERN-GRAMMARS,s) :
    val pkg = analyzed-syntax-package(packages(s))
    val grules = match(s) :
      (s:MatchPatternStructure) :
        val start-rules = to-tuple $
          for (pat in patterns(s), index in 0 to false) seq :
            StartRule(
              parse-pattern(pat)
              fn (binders) : MatchResult(index,binders))
        make-rules(pkg, start-rules)            
      (s:ParsePatternStructure) :
        val pattern = parse-pattern(pattern(s))
        make-rules(pkg, pattern)
    val grammar = Grammar(grules)
    PATTERN-GRAMMARS[s] = grammar    
  PATTERN-GRAMMARS[s]

;============================================================
;===================== Syntax Match =========================
;============================================================

defstruct MatchResult :
  index:Int
  binders:ParsedBinders

public defn syntax-match (base:Symbol, overlays:List<Symbol>,
                          input:List,
                          patterns:Tuple<List>,
                          actions:Tuple<(ParsedBinders -> ?)>) -> ? :
  val syntaxes = resolve-syntaxes(cons(base,overlays))
  val grammar = pattern-grammar(MatchPatternStructure(syntaxes, patterns))
  val result:MatchResult = parse(grammar, input)
  val action = actions[index(result)]
  action(binders(result))

;============================================================
;====================== Syntax Parse ========================
;============================================================

public defn syntax-parse (base:Symbol, overlays:List<Symbol>,
                          input:List,
                          pattern:List) -> ? :
  val syntaxes = resolve-syntaxes(cons(base,overlays))
  val grammar = pattern-grammar(ParsePatternStructure(syntaxes, pattern))
  parse(grammar, input)