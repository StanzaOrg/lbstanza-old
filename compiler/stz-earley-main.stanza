defpackage stz/earley-main :
  import core
  import collections
  import stz/earley-lang
  import stz/earley-grammar
  import stz/earley-syntax-package
  import stz/earley-parser

;============================================================
;=============== Register Syntax Packages ===================
;============================================================

val SYNTAX-PACKAGES = HashTable<Symbol,SyntaxPackage>()

public defn register-syntax-package (p:SyntaxPackage) :
  if key?(SYNTAX-PACKAGES, name(p)) :
    fatal("Syntax package definition not yet supported.")
  SYNTAX-PACKAGES[name(p)] = p

;============================================================
;====================== Overlays ============================
;============================================================

var ACTIVE-SYNTAX:Tuple<Symbol> = []

defn resolve-syntaxes (syntaxes:List<Symbol>) -> Tuple<Symbol> :
  val syntax-set = HashSet<Symbol>()
  val syntax-list = Vector<Symbol>()
  defn add-syntax (name:Symbol) :
    add(syntax-list,name) when add(syntax-set, name)
  for name in syntaxes do :
    if name == `current-overlays : do(add-syntax, ACTIVE-SYNTAX)
    else : add-syntax(name)
  to-tuple(syntax-list)

defn with-active-syntax<?T> (body:() -> ?T, syntaxes:Tuple<Symbol>) :
  let-var ACTIVE-SYNTAX = syntaxes :
    body()

;============================================================
;================ Syntax Package Analysis ===================
;============================================================

;Returns the AnalyzedSyntaxPackage corresponding to the given packages.
;Throws an exception if syntax packages contain errors.
defn analyzed-syntax-package (packages:List<Symbol>) -> AnalyzedSyntaxPackage :
  fatal("Not yet implemented")

;============================================================
;=================== Pattern Analysis =======================
;============================================================

deftype PatternStructure <: Hashable & Equalable

defstruct MatchPatternStructure <: PatternStructure :
  packages: Tuple<Symbol>
  patterns: Tuple<List>

defstruct ParsePatternStructure <: PatternStructure :
  packages: Tuple<Symbol>
  pattern: List

defn pattern-grammar (s:PatternStructure) -> Grammar :
  fatal("Not yet implemented")

;============================================================
;===================== Syntax Match =========================
;============================================================

defstruct MatchResult :
  index:Int
  binders:ParsedBinders

public defn syntax-match (base:Symbol, overlays:List<Symbol>,
                          input:List,
                          patterns:Tuple<List>,
                          actions:Tuple<(ParsedBinders -> ?)>) -> ? :
  val syntaxes = resolve-syntaxes(cons(base,overlays))
  val grammar = pattern-grammar(MatchPatternStructure(syntaxes, patterns))
  val result:MatchResult = parse(grammar, input)
  val action = actions[index(result)]
  action(binders(result))

;============================================================
;====================== Syntax Parse ========================
;============================================================

public defn syntax-parse (base:Symbol, overlays:List<Symbol>,
                          input:List,
                          pattern:List) -> ? :
  val syntaxes = resolve-syntaxes(cons(base,overlays))
  val grammar = pattern-grammar(ParsePatternStructure(syntaxes, pattern))
  parse(grammar, input)