defpackage stz/type-utils :
  import core
  import collections
  import stz/types

;============================================================
;====================== Blockers ============================
;============================================================

;Used to represent that an operation could not complete to
;due some variables being unknown.
public defstruct Blocked:
  vars:List<Int>

;Helper: Append the type variables in the Blocked structs.
public defn append (a:Blocked, b:Blocked) -> Blocked :
  Blocked(append(vars(a), vars(b)))

;============================================================
;===================== Simplifiers ==========================
;============================================================

;Eliminates redundancy in TOr, and TAnd types.
public defn simplify (t:Type) -> Type :
  match(t) :
    (t:TOr) :
      val ts = simplified-or-types(t)
      if empty?(ts) : TBot()
      else : reduce(TOr,ts)
    (t:TAnd) :
      val ts = simplified-and-types(t)
      if empty?(ts) : TTop()
      else : reduce(TAnd,ts)
    (t) :
      map-type(simplify, t)

;Simplify the given and types.
defn simplified-and-types (t:TAnd) -> Tuple<Type> :
  label<Tuple<Type>> return :
    val table = HashSet<Type>()
    let loop (t:Type = t) :
      match(t:TAnd) :
        loop(a(t))
        loop(b(t))
      else :
        match(simplify(t)) :
          (st:TTop) : false
          (st:TBot) : return([TBot()])
          (st) : add(table,st)
    to-tuple(table)

;Simplify the given or types.
defn simplified-or-types (t:TOr) -> Tuple<Type> :
  label<Tuple<Type>> return :
    val table = HashSet<Type>()
    let loop (t:Type = t) :
      match(t:TOr) :
        loop(a(t))
        loop(b(t))
      else :
        match(simplify(t)) :
          (st:TTop) : return([TTop()])
          (st:TBot) : false
          (st) : add(table,st)
    to-tuple(table)

;============================================================
;=================== Substitute Variables ===================
;============================================================

;Perform the given substitutions into the given type.
public defn sub (t:Type, env:Seqable<KeyValue<Int, Type>>) -> Type :
  ;Sanity check.
  if not user-type?(t,false) :
    fatal("Illegal type for substitution: %_." % [t])

  ;Put substitutions in table.
  val table = to-inttable<Type>(env)

  ;Recursively substitute all TVar.
  let loop (t:Type = t) :
    match(t) :
      (t:TVar) : get?(table, n(t), t)
      (t) : map-type(loop, t)

;Perform the given substitutions into the given type, treating
;captures specially.
;It is assumed that if value(entry) is Int, then it is the identifier
;of a TUVar.
public defn sub-caps (t:Type, env:Seqable<KeyValue<Int,Type|Int>>) -> Type :
  ;Sanity check.
  if not fnarg-type?(t,false) :
    fatal("Illegal type for substitution: %_." % [t])

  ;Put substitutions in table.
  val table = to-inttable<Type|Int>(env)

  ;Recursively substitute all TVar.
  let loop (t:Type = t) :
    match(t) :
      (t:TVar) :
        match(get?(table,n(t))) :
          (t:Type) : t
          (n:Int) : TUVar(n)
          (f:False) : t
      (t:TCap) :
        match(get?(table,n(t))) :
          (t:Type) : t
          (n:Int) : TCap(n,false)
          (f:False) : t          
      (t) :
        map-type(loop, t)

;Convenience: Perform on multiple types.
public defn sub-caps (ts:Tuple<Type>, env:Seqable<KeyValue<Int,Type|Int>>) -> Tuple<Type> :
  println("[TODO] Slow implementation")
  map(sub-caps{_, to-tuple(env)}, ts)

;Convenience: Perform on multiple types.
public defn sub (ts:Tuple<Type>, env:Seqable<KeyValue<Int,Type>>) -> Tuple<Type> :
  println("[TODO] Slow implementation")
  map(sub{_, to-tuple(env)}, ts)

;============================================================
;================== Uncap Types =============================
;============================================================

;Convert all captured variables to TVar.
public defn uncap (t:Type) -> Type :
  match(t:TCap) : TVar(n(t),false)
  else : map-type(uncap, t)

;Convert all captured variables to TVar.
public defn uncap (t:LSType) -> LSType :
  match(t:RefT) : RefT(uncap(type(t)))
  else : map-lstype(uncap, t)