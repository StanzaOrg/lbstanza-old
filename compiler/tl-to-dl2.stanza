defpackage stz/tl-to-dl2 :
  import core
  import collections
  import stz/tl-ir2
  import stz/dl-ir
  import stz/types

;============================================================
;=============== Conversion from DL to TL ===================
;============================================================

;Convert a DL record into a type-level type definition.
;Requires an active DL id environment.
public defn to-deftype (rec:StructRec|TypeRec) -> TDefType|TLDefType :

  ;Helper: Create a Tuple<TVar> from their ids.
  defn to-tvars (xs:Seqable<Int>) -> Tuple<TVar> :
    to-tuple(seq(TVar{_, false}, xs))

  ;Helper: Append 'b' to 'a' if b is given. 
  defn append? (a:Seqable<Field>, b:Field|False) -> Tuple<Field> :
    match(b:Field) : to-tuple(cat(a, [b]))
    else : to-tuple(a)
    
  match(rec) :
    (rec:StructRec) :
      val n = env-id(id(rec))
      val targ-ns = to-tuple(0 to ntargs(rec))
      val type-args = to-tvars(targ-ns)
      val parent = to-type?(parent(rec), type-args)
      val base-fields = for f in base(rec) seq :
        val type = to-lstype(type(f), type-args)
        Field(name(f), type, mutable?(f))
      val item-field = match(items(rec)) :
        (items:StructField) :
          val type = RestT(to-lstype(type(items), type-args))
          Field(name(items), type, mutable?(items))
        (items:False) : false
      TLDefType(false, n, targ-ns, parent, append?(base-fields, item-field))
      
    (rec:TypeRec) :
      val n = env-id(id(rec))
      val targ-ns = to-tuple(0 to ntargs(rec))
      val type-args = to-tvars(targ-ns)      
      val parent = to-type?(parent(rec), type-args)
      val children = for c in children(rec) map :
        val n = env-id(id(c))
        val targ-ns = to-tuple(0 to ntargs(c))
        val type-args = to-tvars(targ-ns)        
        val parent = to-type(/parent(c), type-args)
        Child(n, targ-ns, parent)
      TDefType(false, n, targ-ns, parent, children)

;Convert DType with the given type arguments into Type.
public defn to-type (t:DType, type-args:Tuple<Type>) -> Type :
  let loop (t:DType = t) :
    match(t) :
      (t:DOf) : TOf(env-id(id(t)), map(loop,targs(t)))
      (t:DTVar) : type-args[index(t)]
      (t:DCap) : TCap(n(loop(tvar(t)) as TVar), false)
      (t:DAnd) : reduce(TAnd, seq(loop, types(t)))
      (t:DOr) : reduce(TOr, seq(loop, types(t)))
      (t:DTop) : TGradual()
      (t:DBot) : TBot()
      (t:DTuple)  : TTuple(map(loop,types(t)))
      (t:DArrow)  : TArrow(map(loop,a1(t)), loop(a2(t)))

;Convert DType with the given type arguments into LSType.
public defn to-lstype (t:DType, type-args:Tuple<Type>) -> LSType :
  let loop (t:DType = t) :
    match(t) :
      (t:DByte) : ByteT()
      (t:DInt) : IntT()
      (t:DLong) : LongT()
      (t:DFloat) : FloatT()
      (t:DDouble) : DoubleT()
      (t:DUnknown) : UnknownT()
      (t:DPtrT) : PtrT(loop(type(t)))
      (t:DFnT) : FnT(map(loop,a(t)), to-lstype?(r(t),type-args), loop(b(t)))
      (t:DStructT) : StructT(env-id(id(t)), map(to-type{_, type-args},targs(t)))
      (t) : RefT(to-type(t, type-args))

;------------------------------------------------------------
;--------------------- Convenience --------------------------
;------------------------------------------------------------

;Convert an optional DType into an optional Type.
public defn to-type? (t:DType|False, type-args:Tuple<Type>) -> Type|False :
  match(t:DType) : to-type(t, type-args)

;Convert an optional DType into an optional LSType.
public defn to-lstype? (t:DType|False, type-args:Tuple<Type>) -> LSType|False :
  match(t:DType) : to-lstype?(t, type-args)