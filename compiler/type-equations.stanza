defpackage stz/type-equations :
  import core
  import collections
  import stz/types
  import stz/type-variance
  import stz/type-locs

;<doc>=======================================================
;============================================================
;============================================================

Operations:

- Calling a function. Check whether a function can be
  called in the given scenario.

- Calling a function or expression. What are the injected
  expected types into each argument expression?

- Passing an argument to a function. Check whether one type
  is a subtype of another.

- Casting an expression to some type. Is the cast allowed?

- Matching an expression. Is the match type allowed?

- Defining a method. Is this an appropriate method for
  a multi?

- Injecting an expected type to an anonymous function. Retrieve
  the type of the function argument(s) from the injected type.

- Injecting an expected type to a tuple. What is the resulting
  injected types to each of the tuple elements?

- Destructuring a tuple. Given the type of an expression,
  what are the types of the destructured tuple elements.

- Determine whether a mixture of overloaded functions are
  disjoint and hence allowed to be mixed.

- Referencing an overloaded function. Which ones are
  appropriate. 

- Analyzing an anonymous function: The anonymous function
  is expected to be of type T. Then, what is the expected
  type of the body of the function?  

;============================================================
;=======================================================<doc>

;Represents a type equation.
public deftype TypeEqn

;Capture all the given variables to satisfy a <: b.
public defstruct CaptureAllEqn <: TypeEqn :
  ns:Tuple<Int>
  a:Type
  b:Type with:
    ensure => fnarg-type!

;Capture a specific variable n, to satisfy a <: b.
public defstruct CaptureEqn <: TypeEqn :
  n:Int
  variance:Variance
  a:Type
  b:Type with:
    ensure => fnarg-type!

;Infer a variables n.
public defstruct InferEqn <: TypeEqn :
  n:Int
  a:Type|InferLoc
  b:Type|InferLoc

;Infer the type of an overloaded function in expression
;position.
public defstruct OverloadExpEqn <: TypeEqn :
  n:Int
  sel:Int
  xs:Tuple<TFunction> with:
    ensure => tuple-of!<TFunction>(no-type-args!)
  y:Type

;Infer the type of an overloaded function in call
;position.
public defstruct OverloadCallEqn <: TypeEqn :
  n:Int
  sel:Int
  xs:Tuple<TFunction> with:
    ensure => tuple-of!<TFunction>(no-type-args!)
  args:Tuple<FArg>

;Perform the given substitutions in the given
;type. 
public defstruct SubEqn <: TypeEqn :
  n:Int
  x:Type
  ys:Tuple<KeyValue<Int,Type>>

;Indicate that n :> x.
public defstruct SuperEqn <: TypeEqn :
  n:Int
  x:Type

;Directly indicate the type of a variable.
public defstruct EqualEqn <: TypeEqn :
  n:Int
  type:Type

;============================================================
;=================== Printers ===============================
;============================================================

defmethod print (o:OutputStream, e:CaptureAllEqn) :
  print(o, "capture(%,) %_ <: %_" % [ns(e), a(e), b(e)])

defmethod print (o:OutputStream, e:CaptureEqn) :
  print(o, "capture(%_) (%_) %_ <: %_" % [n(e), variance(e), a(e), b(e)])

defmethod print (o:OutputStream, e:InferEqn) :
  print(o, "infer(%_) %_ <: %_" % [n(e), a(e), b(e)])

defmethod print (o:OutputStream, e:OverloadExpEqn) :
  print(o, "overload(%_, sel: %_) %_ <: %_" % [n(e), sel(e), xs(e), y(e)])

defmethod print (o:OutputStream, e:OverloadCallEqn) :
  print(o, "overload(%_, sel: %_) call %_ with %_" % [n(e), sel(e), xs(e), args(e)])

defmethod print (o:OutputStream, e:SubEqn) :
  print(o, "sub %_ = %_ [%,]" % [n(e), x(e), ys(e)])

defmethod print (o:OutputStream, e:SuperEqn) :
  print(o, "sub %_ :> %_" % [n(e), x(e)])

defmethod print (o:OutputStream, e:EqualEqn) :
  print(o, "var %_ = %_" % [n(e), type(e)])