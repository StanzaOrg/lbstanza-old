defpackage stz/type-equations :
  import core
  import collections
  import stz/types
  import stz/type-variance
  import stz/type-locs
  import stz/type-formatter
  import stz/printing-utils

;<doc>=======================================================
;============================================================
;============================================================

Operations:

- Calling a function. Check whether a function can be
  called in the given scenario.

- Calling a function or expression. What are the injected
  expected types into each argument expression?

- Passing an argument to a function. Check whether one type
  is a subtype of another.

- Casting an expression to some type. Is the cast allowed?

- Matching an expression. Is the match type allowed?

- Defining a method. Is this an appropriate method for
  a multi?

- Injecting an expected type to an anonymous function. Retrieve
  the type of the function argument(s) from the injected type.

- Injecting an expected type to a tuple. What is the resulting
  injected types to each of the tuple elements?

- Destructuring a tuple. Given the type of an expression,
  what are the types of the destructured tuple elements.

- Determine whether a mixture of overloaded functions are
  disjoint and hence allowed to be mixed.

- Referencing an overloaded function. Which ones are
  appropriate. 

- Analyzing an anonymous function: The anonymous function
  is expected to be of type T. Then, what is the expected
  type of the body of the function?  

;============================================================
;=======================================================<doc>

;Represents a type equation.
public deftype TypeEqn

;Capture all the given variables to satisfy a <: b.
public defstruct CaptureAllEqn <: TypeEqn :
  ns:Tuple<Int>
  a:Type
  b:Type with:
    ensure => fnarg-type!

;Capture a specific variable n, to satisfy a <: b.
public defstruct CaptureEqn <: TypeEqn :
  n:Int
  variance:Variance
  a:Type
  b:Type with:
    ensure => fnarg-type!

;Infer a variables n.
public defstruct InferEqn <: TypeEqn :
  n:Int
  a:Type|InferLoc
  b:Type|InferLoc

;Infer the type of an overloaded function in expression
;position.
;- functions: These are the known types of the functions
;  that are overloaded.
;- y: This is the expected type for this expression.
;- instantiations: Starts as None. When y is solved, functions
;  are instantiated and the instantiation information is
;  saved here.
;- arrows: The instantiated arrow types are saved here. 
public defstruct OverloadExpEqn <: TypeEqn :
  n:Int
  sel:Int
  functions:Tuple<TFunction>
  instantiations:Maybe<Tuple<FnInst>>
  arrows:Maybe<Tuple<TArrow>>
  y:Type

;Infer the type of an overloaded function in call
;position.
public defstruct OverloadCallEqn <: TypeEqn :
  n:Int
  sel:Int
  xs:Tuple<TArrow>
  args:Tuple<Type>

;Perform the given substitutions in the given
;type. 
public defstruct SubEqn <: TypeEqn :
  n:Int
  x:Type
  ys:Tuple<KeyValue<Int,Type>>

;Indicate that n :> x.
public defstruct SuperEqn <: TypeEqn :
  n:Int
  x:Type

;Directly indicate the type of a variable.
public defstruct EqualEqn <: TypeEqn :
  n:Int
  type:Type

;Directly indicate a variable is unsatisfiable.
public defstruct UnsatisfiableEqn <: TypeEqn :
  n:Int

;============================================================
;=================== Printers ===============================
;============================================================

defmethod print (o:OutputStream, e:CaptureAllEqn) :
  print(o, "capture(%,) %_ <: %_" % [ns(e), a(e), b(e)])

defmethod print (o:OutputStream, e:CaptureEqn) :
  print(o, "capture(%_) (%_) %_ <: %_" % [n(e), variance(e), a(e), b(e)])

defmethod print (o:OutputStream, e:InferEqn) :
  print(o, "infer(%_) %_ <: %_" % [n(e), a(e), b(e)])

defmethod print (o:OutputStream, e:OverloadExpEqn) :
  print(o, "overload(%_, sel: %_) (%,) <: %_" % [n(e), sel(e), functions(e), y(e)])

defmethod print (o:OutputStream, e:OverloadCallEqn) :
  print(o, "overload(%_, sel: %_) call (%,) with %_" % [n(e), sel(e), xs(e), args(e)])

defmethod print (o:OutputStream, e:SubEqn) :
  print(o, "sub %_ = %_ [%,]" % [n(e), x(e), ys(e)])

defmethod print (o:OutputStream, e:SuperEqn) :
  print(o, "var %_ :> %_" % [n(e), x(e)])

defmethod print (o:OutputStream, e:EqualEqn) :
  print(o, "var %_ = %_" % [n(e), type(e)])

;============================================================
;================== Formatting ==============================
;============================================================

public defn format (f:TypeFormatter, e:TypeEqn) :
  defn fmt (t:Type) : format(f,t)
  defn fmt (n:Int) : format(f,TVar(n,false))
  defn fmt (ns:Tuple<Int>) : seq(fmt,ns)
  defn fmt (l:InferLoc) : l
  defn fmt (t:Tuple<Type>) : seq(fmt,t)
  defn fmt (a:FArg) : format(f,a)
  defn fmt (a:Tuple<FArg>) : seq(fmt,a)
  defn fmt (e:KeyValue<Int,Type>) : fmt(key(e)) => fmt(value(e))
  defn fmt (e:Tuple<KeyValue<Int,Type>>) : seq(fmt,e)
  match(e) :
    (e:CaptureAllEqn) : "capture(%,) %_ <: %_" % [fmt(ns(e)), fmt(a(e)), fmt(b(e))]
    (e:CaptureEqn) : "capture(%_) (%_) %_ <: %_" % [fmt(n(e)), variance(e), fmt(a(e)), fmt(b(e))]
    (e:InferEqn) : "infer(%_) %_ <: %_" % [fmt(n(e)), fmt(a(e)), fmt(b(e))]
    (e:OverloadExpEqn) :
      val fs = fmt(functions(e))
      "overload(%_, sel: %_) (%,) <: %_" % [fmt(n(e)), sel(e), indented-field-list(fs), fmt(y(e))]
    (e:OverloadCallEqn) :
      "overload(%_, sel: %_) call (%,) with (%,)" % [fmt(n(e)), sel(e), fmt(xs(e)), fmt(args(e))]
    (e:SubEqn) : "sub %_ = %_ [%,]" % [fmt(n(e)), fmt(x(e)), fmt(ys(e))]
    (e:SuperEqn) : "var %_ :> %_" % [fmt(n(e)), fmt(x(e))]
    (e:EqualEqn) : "var %_ = %_" % [fmt(n(e)), fmt(type(e))]
    (e:UnsatisfiableEqn) : "var %_ is unsatisfiable" % [fmt(n(e))]