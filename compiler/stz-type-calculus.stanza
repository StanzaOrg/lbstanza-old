defpackage stz/type-calculus :
   import core
   import verse
   import stz/tl-ir

;======== Utilities ========
var CURRENT-HIERARCHY: False|THierarchy = false
defn current-hierarchy () :
   match(CURRENT-HIERARCHY) :
      (h:False) : error("Current hierarchy not set.")
      (h:THierarchy) : h

defn set-current-hierarchy (h:THierarchy|False) :
   CURRENT-HIERARCHY = h
      
public defn parent (h:THierarchy, t:TOf) -> Type :
   val e = h[n(t)]
   val env = match(type(t)) :
      (t:TTuple) : map(KeyValue, args(e), types(t))
      (t:TGradual) : map(KeyValue{_, t}, args(e))
   sub(parent(e), env)

public defn parent (t:TOf) :
   parent(current-hierarchy(), t)

public defn parents (t:TOf, class:Int) -> List<TOf> :
   defn loop (t:Type) :
      match(t) :
         (t:TOf) :
            if n(t) == class : list(t)
            else : loop(parent(t))
         (t:TAnd) :
            append(loop(a(t)), loop(b(t)))
         (t:TNone) :
            list()
   loop(t)

;======== Type Operations ========
public defn sub (t:Type, env:List<KeyValue<Int, Type>>) :
   match(t) :
      (t:TVar) : lookup(env, n(t), t)
      (t:TCap) : lookup(env, n(t), t)
      (t) : map(sub{_, env}, t)

public defn lookup<?T> (env:List<KeyValue<Int,?T>>, n:Int, default:?T) :
   val e = for e in env find :
      key(e) == n
   match(e) :
      (e:KeyValue<Int,T>) : value(e)
      (e:False) : default

public defn lookup!<?T> (env:List<KeyValue<Int,?T>>, n:Int) :
   val e = for e in env find :
      key(e) == n
   match(e) :
      (e:KeyValue<Int,T>) : value(e)
      (e:False) : error("No entry for ~ in env." % [n])      

;;============ Unknown =============
;public defclass Unknown
;public val unknown:Unknown = new Unknown
;defmethod print (o:OutputStream, u:Unknown) :
;   print(o, "unknown")
;
;public defn and3 (x: True|Unknown|False, y: True|Unknown|False) -> True|Unknown|False :
;   match(x, y) :
;      (x:False, y) : false
;      (x, y:False) : false
;      (x:Unknown, y) : unknown
;      (x, y:Unknown) : unknown
;      (x:True, y:True) : true
;
;public defn or3 (x: True|Unknown|False, y: True|Unknown|False) -> True|Unknown|False :
;   match(x, y) :
;      (x:True, y) : true
;      (x, y:True) : true
;      (x:Unknown, y) : unknown
;      (x, y:Unknown) : unknown
;      (x:False, y:False) : false
;
;public defn all3?<?T> (pred?: (T) -> True|Unknown|False, xs:Streamable<?T>) :
;   val s = to-stream(xs)
;   defn loop () :
;      if more?(s) :
;         and3(pred?(next(s)), loop())
;      else : true
;   loop()   
;
;public defn all3?<?S,?T> (pred?: (S,T) -> True|Unknown|False, xs:Streamable<?S>, ys:Streamable<?T>) :
;   val s = to-stream(xs)
;   val t = to-stream(ys)
;   defn loop () :
;      if more?(s) and more?(t) :
;         and3(pred?(next(s), next(t)), loop())
;      else : true
;   loop()   
;
;public defn any3?<?T> (pred?: (T) -> True|Unknown|False, xs:Streamable<?T>) :
;   val s = to-stream(xs)
;   defn loop () :
;      if more?(s) :
;         or3(pred?(next(s)), loop())
;      else : false
;   loop()   
;
;public defn any3?<?S,?T> (pred?: (S,T) -> True|Unknown|False, xs:Streamable<?S>, ys:Streamable<?T>) :
;   val s = to-stream(xs)
;   val t = to-stream(ys)
;   defn loop () :
;      if more?(s) and more?(t) :
;         or3(pred?(next(s), next(t)), loop())
;      else : false
;   loop()   
;
;;======== Subtyping Relation ========
;public defn expand-gradual (t:Type) :
;   match(t) :
;      (t:TOf) : TOf(n(t), TGradual())
;      (t:TTuple) : TTuple(map(TGradual{}, types(t)))
;      (t:TArrow) : TArrow(TGradual(), TGradual())
;      (t:TVar) : t
;      (t:TBot) : t
;      (t) : error("Cannot expand gradual to ~." << [t])
;      
;public defn subtype? (x:Type, y:Type) -> True|False|Unknown :
;   match(x, y) :
;      (x:TOf, y:TOf) : any3?(subtype{_, type(y)}, parents(x, n(y)))
;      (x:TTuple, y:TTuple) :
;         if length(types(x)) == length(types(y)) :
;            all3?(subtype?, types(x), types(y))
;      (x:TArrow, y:TArrow) : and3(subtype?(a(y), a(x)), subtype?(b(x), b(y)))
;      (x:TOr, y) : and3(subtype?(a(x), y), subtype?(b(x), y))
;      (x, y:TAnd) : and3(subtype?(x, a(y)), subtype?(x, b(y)))
;      (x:TAnd, y) : or3(subtype?(a(x), y), subtype?(b(x), y))
;      (x, y:TOr) : or3(subtype?(x, a(y)), subtype?(x, b(y)))
;      (x:TGradual, y:TGradual) : true
;      (x:TGradual, y) : subtype?(expand-gradual(y), y)
;      (x, y:TGradual) : subtype?(x, expand-gradual(x))
;      (x:TVar, y:TVar) : n(x) == n(y)
;      (x:TBot, y) : true
;      (x:TUVar, y:TUVar) :
;         if n(x) == n(y) : true
;         else : unknown
;      (x:TUVar, y) : unknown
;      (x, y:TUVar) : unknown
;      (x, y) : false
;      
;;======== Flow Relation ========
;definterface FlowResult
;defstruct FAnd <: FlowResult :
;   a: FlowResult
;   b: FlowResult
;defstruct FOr <: FlowResult :
;   a: FlowResult
;   b: FlowResult
;defstruct FFalse
;defstruct FUnknown
;defstruct FType <: FlowResult :
;   type: Type
;
;defn simplify (r:FlowResult, top?) :
;   match(r, top?) :
;      (r:FOr, top?) :
;         match(simplify(a(r), false), simplify(b(r), false)) :
;            (a:FFalse, b) : simplify(b, true) when top? else b
;            (a, b:FFalse) : simplify(a, true) when top? else a
;            (a:FUnknown, b) : a
;            (a, b:FUnknown) : b
;            (a, b) : FOr(a, b)
;      (r:FAnd, top?:True) :
;         match(simplify(a(r), true), simplify(b(r), true)) :
;            (a:FFalse|FUnknown, b) : b
;            (a, b:FFalse|FUnknown) : a               
;            (a, b) : FAnd(a, b)
;      (r:FAnd, top?:False) :
;         match(simplify(a(r), false), simplify(b(r), false)) :
;            (a:FFalse, b:FFalse) : false
;            (a, b) : FAnd(a, b)
;      (r, top?) :
;         r
;
;defn eval (r:FlowResult) -> Type|False|Unknown :
;   match(r) :
;      (r:FOr) :
;         match(eval(a(r)), eval(b(r))) :
;            (a:False, b) : b
;            (a, b:False) : a
;            (a:Unknown, b) : a
;            (a, b:Unknown) : b
;            (a, b) : TOr(a, b)
;      (r:FAnd) :
;         match(eval(a(r)), eval(b(r))) :
;            (a:False|Unknown, b) : a
;            (a, b:False|Unknown) : b
;            (a, b) : TOr(a, b)
;      (r:FFalse) : false
;      (r:FUnknown) : unknown
;      (r:FType) : type(t)
;
;defn flow (cn:Int, x:Type, y:Type) -> Type|False|Unknown :
;   defn fl (xs:List<Type>, y:Type) :
;      stream(fl{_, y}, xs)
;   defn fl (x:Type, ys:List<Type>) :
;      stream(fl{x, _}, ys)
;   defn fl (xs:List<Type>, ys:List<Type>) :
;      stream(fl, xs, ys)
;   defn fl (x:Type, y:Type) :   
;      match(x, y) :
;         (x, y:TCap) :
;            error("Cap n does not match flow n") when n(y) != cn
;            FType(x)
;         (x:TCap, y) :
;            error("Cap n does not match flow n") when n(x) != cn
;            FType(y)
;         (x:TOf, y:TOf) :
;            if n(x) == n(y) :
;               fl(a(x), b(y))
;            else :
;               val rs = concat(fl(parents(x, n(y)), y), fl(x, parents(y, n(x))))
;               reduce(FOr, rs) when more?(rs) else FFalse()
;         (x:TTuple, y:TTuple) :
;            if length(x) == length(y) :
;               val ts = fl(types(x), types(y))
;               if more?(ts) : reduce(FAnd, ts)
;               else : FType(TBot())
;         (x:TArrow, y:TArrow) :
;            FAnd(fl(a(y), a(x)), fl(b(x), b(y)))
;         (x:TVar, y:TVar) : FType(TBot()) when n(x) == n(y) else FFalse()
;         (x:TOr, y) : FAnd(fl(a(x), y), fl(b(x), y))
;         (x, y:TOr) : FOr(fl(x, a(y)), fl(x, b(y)))
;         (x, y:TAnd) : FAnd(fl(x, a(y)), fl(x, b(y)))
;         (x:TAnd, y) : FOr(fl(a(x), y), fl(b(x), y))
;         (x:TBot, y) : FType(TBot())
;         (x:TUVar, y:TUVar) :
;            if n(x) == n(y) : FType(TBot())
;            else : FUnknown()
;         (x:TUVar, y) : FUnknown()
;         (x, y:TUVar) : FUnknown()
;         (x:TGradual, y:TGradual) : FType(TBot())
;         (x:TGradual, y) : fl(expand-gradual(y), y)
;         (x, y:TGradual) : fl(x, expand-gradual(x))
;         (x, y) : FFalse()
;   eval(simplify(fl(x, y), true))   
;
;;======== Overlap Relation ========
;defn overlap? (x:Type, y:Type) -> True|False :
;   match(x, y) :
;      (x:TOf, y:TOf) :
;         if n(x) == n(y) :
;            overlap?(type(x), type(y))
;         else :
;            any?(overlap?{_, y}, parents(x, n(y))) or
;            any?(overlap?{x, _}, parents(y, n(x)))
;      (x:TTuple, y:TTuple) :
;         if length(types(x)) == length(types(y)) :
;            all?(overlap?, types(x), types(y))
;      (x:TArrow, y:TArrow) :
;         overlap?(a(y), a(x)) and overlap?(b(x), b(y))
;      (x:TVar, y:TVar) : n(x) == n(y)
;      (x:TGradual, y) : true
;      (x, y:TGradual) : true
;      (x:TBot, y) : true
;      (x, y:TBot) : true
;      (x:TOr, y) : overlap?(a(x), y) or overlap?(b(x), y)
;      (x, y:TOr) : overlap?(x, a(y)) or overlap?(x, b(y))
;      (x:TAnd, y) : overlap?(a(x), y) or overlap?(b(x), y)
;      (x, y:TAnd) : overlap?(x, a(y)) or overlap?(x, b(y))
;      (x:TUVar, y) : error("Unhandled")
;      (x, y:TUVar) : error("Unhandled")
;      (x, y) : false
;
;;======== Part Relation ========
;defn passable? (x:Type, y:Type) -> True|False|Maybe|Unknown :
;   match(x, y) :
;      (x:TOr, y) : passable?(a(x), y) or passable?(b(x), y)
;      (x, y:TOr) : passable?(x, a(y)) or passable?(x, b(y))
;      (x, y:TAnd) : passable?(x, a(y)) and passable?(x, b(y))
;      (x:TAnd, y) : passable?(a(x), y) or passable?(b(x), y)
;
;      (x:TGradual, y:TGradual) : true
;      (x:TGradual, y) : maybe or expand-gradual(y)
;      (x:TOf, y:TOf) :
;         if n(x) == n(y) :
;            subtype?(type(x), type(y))
;         else :
;            any?(passable?{_, y}, parents(x, n(y))) or
;            any?(passable?{x, _}, parents(y, n(x)))
;
;      (x:TGradual, y:TGradual) : 
;      (x, y) : subtype?(x, y)
;      