defpackage stz/type-calculus :
   import core
   import verse
   import stz/tl-ir
   import stz/utils
   import stz/ids

;======== Utilities ========
var CURRENT-HIERARCHY: False|THierarchy = false
public defn current-hierarchy () :
   match(CURRENT-HIERARCHY) :
      (h:False) : error("Current hierarchy not set.")
      (h:THierarchy) : h

public defn set-current-hierarchy (h:THierarchy|False) :
   CURRENT-HIERARCHY = h
      
public defn parent (h:THierarchy, t:TOf) -> Type :
   val e = h[n(t)]
   val env = match(type(t)) :
      (t:TTuple) : map(KeyValue, args(e), types(t))
      (t:TGradual) : map({_ => t}, args(e))
   sub(parent(e), env)

public defn parent (t:TOf) :
   parent(current-hierarchy(), t)

public defn parents (t:TOf, class:Int) -> List<TOf> :
   defn loop (t:Type) :
      match(t) :
         (t:TOf) :
            if n(t) == class : list(t)
            else : loop(parent(t))
         (t:TAnd) :
            append(loop(a(t)), loop(b(t)))
         (t:TNone) :
            list()
   loop(t)

;======== Type Operations ========
public defn sub (t:Type, env:List<KeyValue<Int, Type>>) :
   match(t) :
      (t:TVar) : lookup(env, n(t), t)
      (t:TCap) :
         match(lookup(env, n(t))) :
            (t*:False) : t
            (t*:TUVar) : TCap(n(t*))
            (t*) : error("Cannot substitute ~ for ~" % [t, t*])
      (t) : map(sub{_, env}, t)

public defn sub (t:LSType, env:List<KeyValue<Int,Type>>) :
   mapr(sub{_, env}, t)

public defn valid? (t:Type) :
   match(t) :
      (t:TNone) : false
      (t) : all?(valid?, children(t))

public defn valid? (t:LSType) :
   match(t) :
      (t:NoneT) : false
      (t:RefT) : valid?(type(t))
      (t:StructT) : valid?(type(t))
      (t:FnT) :
         val rvalid? = (r(t) typeof NoneT) or valid?(r(t))
         rvalid? and all?(valid?, a(t)) and valid?(b(t))
      (t) : all?(valid?, children(t))

public defn uncap (t:Type) -> Type :
   match(t) :
      (t:TCap) : TVar(n(t))
      (t) : map(uncap, t)
      
public defn uncap (t:LSType) -> LSType :
   mapr(uncap, t)

public defn bounded-type? (n:Int) :
   val e = current-hierarchy()[n] as LSHEntry
   rfield(e) == false

public defn bounded? (t:LSType) :
   match(t) :
      (t:ByteT|IntT|LongT|FloatT|DoubleT|PtrT|RefT) : true
      (t:UnknownT|PolyT|FnT) : false
      (t:StructT) : bounded-type?(n(t))
      (t) : error("Invalid type: ~" % [t])

public defn rest-field? (n:Int, fname:Symbol) :
   val e = current-hierarchy()[n] as LSHEntry
   match(rfield(e)) :
      (rt:Field) : name(rt) == fname
      (rt) : false

;======== Field Type ========
public defn lstype? (n:Int) :
   current-hierarchy()[n] typeof LSHEntry

public defn type-tarity (n:Int) :
   val e = current-hierarchy()[n]
   length(args(e))
   
public defn field-type (t:StructT, fname:Symbol) :
   match(current-hierarchy()[n(t)]) :
      (e:LSHEntry) :
         val env = match(type(t)) :
            (t:TGradual) : map({_ => TGradual()}, args(e))
            (t:TTuple) : map(KeyValue, args(e), types(t))
         label<LSType> return :
            for f in fields(e) do :
               if name(f) == fname :
                  return(sub(type(f), env))
            if rfield(e) != false :
               val rf = rfield(e) as Field
               if name(rf) == fname :
                  return(PtrT(sub(type(rf), env)))
            NoneT()
      (e:HSHEntry) :
         NoneT()

public defn field-types (n:Int, targ:Type) :
   label<False|List<LSType>> return :
      match(current-hierarchy()[n]) :
         (e:LSHEntry) :
            val env = match(targ) :
               (t:TGradual) :
                  map({_ => TGradual()}, args(e))
               (t:TTuple) :
                  return(false) when length(args(e)) != length(types(t))
                  map(KeyValue, args(e), types(t))
            for f in fields(e) map :
               sub(type(f), env)
         (e) :
            false

public defn field-types! (n:Int, targ:Type) :
   field-types(n, targ) as List<LSType>

;============ Unknown|Maybe =============
public defn and3 (x: True|False|Unknown, y: True|False|Unknown) :
   and4(x, y) as True|False|Unknown
public defn or3 (x: True|False|Unknown, y: True|False|Unknown) :
   or4(x, y) as True|False|Unknown
public defn all3?<?T> (pred?: (T) -> True|Unknown|False, xs:Streamable<?T>) :
   all4?(pred?, xs) as True|False|Unknown
public defn all3?<?S,?T> (pred?: (S,T) -> True|Unknown|False, xs:Streamable<?S>, ys:Streamable<?T>) :
   all4?(pred?, xs, ys) as True|False|Unknown
public defn any3?<?T> (pred?: (T) -> True|Unknown|False, xs:Streamable<?T>) :
   any4?(pred?, xs) as True|False|Unknown
public defn any3?<?S,?T> (pred?: (S,T) -> True|Unknown|False, xs:Streamable<?S>, ys:Streamable<?T>) :
   any4?(pred?, xs, ys) as True|False|Unknown

public defn and4 (x: True|Unknown|False|Maybe, y: True|Unknown|False|Maybe) -> True|Unknown|False|Maybe :
   match(x, y) :
      (x:False, y) : false
      (x, y:False) : false
      (x:Unknown, y) : unknown
      (x, y:Unknown) : unknown
      (x:Maybe, y) : maybe
      (x, y:Maybe) : maybe
      (x:True, y:True) : true

public defn or4 (x: True|Unknown|False|Maybe, y: True|Unknown|False|Maybe) -> True|Unknown|False|Maybe :
   match(x, y) :
      (x:True, y) : true
      (x, y:True) : true
      (x:Unknown, y) : unknown
      (x, y:Unknown) : unknown
      (x:Maybe, y) : maybe
      (x, y:Maybe) : maybe
      (x:False, y:False) : false

public defn all4?<?T> (pred?: (T) -> True|Unknown|False|Maybe, xs:Streamable<?T>) :
   val s = to-stream(xs)
   defn loop () :
      if more?(s) :
         and4(pred?(next(s)), loop())
      else : true
   loop()   

public defn all4?<?S,?T> (pred?: (S,T) -> True|Unknown|False|Maybe, xs:Streamable<?S>, ys:Streamable<?T>) :
   val s = to-stream(xs)
   val t = to-stream(ys)
   defn loop () :
      if more?(s) and more?(t) :
         and4(pred?(next(s), next(t)), loop())
      else : true
   loop()   

public defn any4?<?T> (pred?: (T) -> True|Unknown|False|Maybe, xs:Streamable<?T>) :
   val s = to-stream(xs)
   defn loop () :
      if more?(s) :
         or4(pred?(next(s)), loop())
      else : false
   loop()   

public defn any4?<?S,?T> (pred?: (S,T) -> True|Unknown|False|Maybe, xs:Streamable<?S>, ys:Streamable<?T>) :
   val s = to-stream(xs)
   val t = to-stream(ys)
   defn loop () :
      if more?(s) and more?(t) :
         or4(pred?(next(s), next(t)), loop())
      else : false
   loop()   

;======== Tuple Collapsing ========
defn collapse (t:TTuple) :
   val t* = reduce(TOr, TBot(), types(t))
   TOf(TUPLE-TYPE-ID, TTuple(list(t*)))

;======== Subtyping Relation ========
public defn subtype? (x:Type, y:Type) -> True|False|Unknown :
   match(x, y) :
      ;5. Bottom Type: Fast Path
      (x:TBot, y) : true
      ;4. Gradual Type: Fast Path
      (x:TGradual, y) : true
      (x, y:TGradual) : true
      ;3. Combinatory Types
      (x:TOr, y) : and3(subtype?(a(x), y), subtype?(b(x), y))
      (x, y:TOr) : or3(subtype?(x, a(y)), subtype?(x, b(y)))
      (x, y:TAnd) : and3(subtype?(x, a(y)), subtype?(x, b(y)))
      (x:TAnd, y) : or3(subtype?(a(x), y), subtype?(b(x), y))
      ;2. Unitary Types
      (x:TOf, y:TOf) :
         if n(x) == n(y) : subtype?(type(x), type(y))
         else : any3?(subtype?{_, type(y)}, parents(x, n(y)))
      (x:TTuple, y:TTuple) : 
         if length(types(x)) == length(types(y)) :
            all3?(subtype?, types(x), types(y))
      (x:TTuple, y:TOf) :
         subtype?(collapse(x), y)
      (x:TArrow, y:TArrow) :
         and3(subtype?(a(y), a(x)), subtype?(b(x), b(y)))
      ;1. Ground Types
      (x:TVar, y:TVar) : n(x) == n(y)
      ;6. Type Variables
      (x:TUVar, y:TUVar) :
         if n(x) == n(y) : true
         else : unknown
      (x:TUVar, y) : unknown
      (x, y:TUVar) : unknown
      ;7. Fall through
      (x:TOf|TTuple|TArrow|TVar, y:TOf|TTuple|TArrow|TVar|TBot) : false
      ;8. Error Condition
      (x, y) : error("Inappropriate subtype inputs: ~ and ~" % [x, y])

;======== Strict Subtyping Relation ========
;x <! y => x is definitely a subtype of y.
;Transitive. Used only for type simplification.
defn subtype! (x:Type, y:Type) -> True|False :
   match(x, y) :
      ;4. Bottom Type: Fast Path
      (x:TBot, y) : true
      ;3. Combinatory Types
      (x:TOr, y) : subtype!(a(x), y) and subtype!(b(x), y)
      (x, y:TOr) : subtype!(x, a(y)) or subtype!(x, b(y))
      (x, y:TAnd) : subtype!(x, a(y)) and subtype!(x, b(y))
      (x:TAnd, y) : subtype!(a(x), y) or subtype!(b(x), y)
      ;2. Unitary Types
      (x:TOf, y:TOf) :
         if n(x) == n(y) : subtype!(type(x), type(y))
         else : any?(subtype!{_, type(y)}, parents(x, n(y)))
      (x:TTuple, y:TTuple) : 
         if length(types(x)) == length(types(y)) :
            all?(subtype!, types(x), types(y))
      (x:TTuple, y:TOf) :
         subtype!(collapse(x), y)
      (x:TArrow, y:TArrow) :
         subtype!(a(y), a(x)) and subtype!(b(x), b(y))
      ;1. Ground Types
      (x:TVar, y:TVar) : n(x) == n(y)
      (x:TGradual, y:TGradual) : true
      ;5. Type Variables
      (x:TUVar, y:TUVar) : n(x) == n(y)
      (x:TUVar, y) : false
      (x, y:TUVar) : false      
      ;6. Fall through
      (x:TOf|TTuple|TArrow|TVar|TGradual, y:TOf|TTuple|TArrow|TVar|TGradual|TBot) : false
      ;7. Error
      (x, y) : error("Invalid combination of types: ~ and ~" % [x, y])

public defn simplify (t:Type) -> Type :
   defn* or-ts (t:Type, accum:List<Type>) :
      match(t) :
         (t:TOr) : or-ts(b(t), or-ts(a(t), accum))
         (t) : List(t, accum)
   defn* and-ts (t:Type, accum:List<Type>) :
      match(t) :
         (t:TAnd) : and-ts(b(t), and-ts(a(t), accum))
         (t) : List(t, accum)
   defn supertype! (a:Type, b:Type) : subtype!(b, a)
   defn st (t:Type) -> Type :
      match(t) :
         (t:TOr) :
            reduce(TOr, ts*) where :
               val ts = minima(or-ts(t, List()), supertype!)
               val ts* = stream(st, ts)
         (t:TAnd) :
            reduce(TAnd, ts*) where :
               val ts = minima(and-ts(t, List()), subtype!)
               val ts* = stream(st, ts)
         (t) :
            map(st, t)
   if valid?(t) : st(t)
   else : TNone()

public defn simplify (t:LSType) -> LSType :
   if valid?(t) : mapr(simplify, t)
   else : NoneT()

;======== Flow Relation ========
defn expand-gradual (t:Type) :
   match(t) :
      (t:TOf) : TOf(n(t), TGradual())
      (t:TTuple) : TTuple(map(TGradual{}, types(t)))
      (t:TArrow) : TArrow(TGradual(), TGradual())
      (t:TVar) : t
      (t:TBot) : t

definterface FlowResult
defstruct FAnd <: FlowResult : (a:FlowResult, b:FlowResult)
defstruct FOr <: FlowResult : (a:FlowResult, b:FlowResult)
defstruct FFalse <: FlowResult
defstruct FTrue <: FlowResult
defstruct FTrueOrFalse <: FlowResult
defstruct FUnknown <: FlowResult
defstruct FType <: FlowResult : (type:Type)

#with-overlay(stz/printer-lang) :
   defprinter (r:FlowResult) :
      FAnd :
         ($and a b)
      FOr :
         ($or a b)
      FFalse :
         ($false)
      FTrue :
         ($true)
      FTrueOrFalse :
         ($true-or-false)
      FUnknown :
         ($unknown-type)
      FType :
         custom{type(r)}


defn cap? (cn:Int, t:Type) :
   match(t) :
      (t:TCap) : n(t) == cn
      (t) : any?(cap?{cn, _}, children(t))
      
defn cap? (cn:Int, t:LSType) :   
   match(t) :
      (t:RefT) : cap?(cn, type(t))
      (t:StructT) : cap?(cn, type(t))
      (t) : any?(cap?{cn, _}, children(t))      

defn flow-result (cn:Int, x:Type, y:Type) -> FlowResult :         
   defn fl (xs:List<Type>, y:Type) : stream(fl{_, y}, xs)
   defn fl (x:Type, ys:List<Type>) : stream(fl{x, _}, ys)
   defn fl (xs:List<Type>, ys:List<Type>) : stream(fl, xs, ys)
   defn fl (x:Type, y:Type) -> FlowResult :
      match(x, y) :
         ;8. Capture
         (x, y:TCap) :
            error("Cap n does not match flow n") when n(y) != cn
            FType(x)
         (x:TCap, y) :
            error("Cap n does not match flow n") when n(x) != cn
            FType(y)
         ;5. Bottom Type: Fast Path
         (x:TBot, y) : FType(TBot())
         ;3. Combinatory types
         (x:TOr, y) : FAnd(fl(a(x), y), fl(b(x), y))
         (x, y:TOr) : FOr(fl(x, a(y)), fl(x, b(y)))
         (x, y:TAnd) : FAnd(fl(x, a(y)), fl(x, b(y)))
         (x:TAnd, y) : FOr(fl(a(x), y), fl(b(x), y))
         ;2. Unitary Types
         (x:TOf, y:TOf) :
            if n(x) == n(y) :
               fl(type(x), type(y))
            else :
               val rs = concat(fl(parents(x, n(y)), y), fl(x, parents(y, n(x))))
               if more?(rs) : reduce(FOr, rs)
               else : FFalse()
         (x:TTuple, y:TTuple) :
            if length(types(x)) == length(types(y)) :
               if empty?(types(x)) : FTrue()
               else : reduce(FAnd, fl(types(x), types(y)))
            else : FFalse()
         (x:TTuple, y:TOf) : fl(collapse(x), y)
         (x:TOf, y:TTuple) : fl(x, collapse(y))
         (x:TArrow, y:TArrow) : FAnd(fl(a(y), a(x)), fl(b(x), b(y)))
         ;1. Ground Types
         (x:TVar, y:TVar) :
            if n(x) == n(y) : FTrue()
            else : FFalse()
         ;4. Gradual Type
         (x:TGradual, y:TGradual) : FTrue()
         (x:TGradual, y:TUVar) : FTrue()
         (x:TUVar, y:TGradual) : FTrue()
         (x:TGradual, y) : fl(expand-gradual(y), y)
         (x, y:TGradual) : fl(x, expand-gradual(x))
         ;6. Unknown Type
         (x:TUVar, y:TUVar) :
            if n(x) == n(y) : FTrue()
            else : FTrueOrFalse()
         (x:TUVar, y) : FUnknown() when cap?(cn,y) else FTrueOrFalse()
         (x, y:TUVar) : FUnknown() when cap?(cn,x) else FTrueOrFalse()
         ;7. Fall through
         (x:TOf|TTuple|TArrow|TVar, y:TOf|TTuple|TArrow|TVar|TBot) : FFalse()
   fl(x, y)

defn flow-result (cn:Int, x:LSType, y:LSType) -> FlowResult :         
   match(x, y) :
      ;2. Unitary Types
      (x:PtrT, y:PtrT) :
         flow-result(cn, type(x), type(y))
      (x:RefT, y:RefT) :
         flow-result(cn, type(x), type(y))
      (x:FnT, y:FnT) :
         FAnd(flow-result(cn, a(y), r(y), a(x), r(x))
              flow-result(cn, b(x), b(y)))
      (x:StructT, y:StructT) :
         if n(x) == n(y) : flow-result(cn, type(x), type(y))
         else : FFalse()      
      ;1. Ground types
      (x:ByteT, y:ByteT) : FTrue()
      (x:IntT, y:IntT) : FTrue()
      (x:LongT, y:LongT) : FTrue()
      (x:FloatT, y:FloatT) : FTrue()
      (x:DoubleT, y:DoubleT) : FTrue()
      ;3. Unknown Type
      (x:UnknownT, y) : FTrue()
      (x, y:UnknownT) : FTrue()
      ;4. Var Type
      (x:UVarT, y:UVarT) :
         if n(x) == n(y) : FTrue()
         else : FTrueOrFalse()
      (x:UVarT, y) : FUnknown() when cap?(cn,y) else FTrueOrFalse()
      (x, y:UVarT) : FUnknown() when cap?(cn,x) else FTrueOrFalse()
      ;5. Fall through
      (x:PtrT|RefT|FnT|StructT|ByteT|IntT|LongT|FloatT|DoubleT,
       y:PtrT|RefT|FnT|StructT|ByteT|IntT|LongT|FloatT|DoubleT) : FFalse()
      ;6. Error
      (x, y) : error("Invalid type combination: ~ and ~" % [x, y])
      

defn flow-result (cn:Int,
                  a1:List<LSType>, r1:LSType,
                  a2:List<LSType>, r2:LSType) -> FlowResult :
   defn ex (ts:List<LSType>, r:LSType) : concat(ts, stream({r}, 0 to false))
   defn ap (ts:List<LSType>, r:LSType) : concat(ts, [r])
   defn fand (fs:Stream<FlowResult>) :
      if more?(fs) : reduce(FAnd, fs)
      else : FFalse()
   defn fall (xs:Streamable<LSType>, ys:Streamable<LSType>) :
      fand(stream(flow-result{cn, _, _}, xs, ys))
   val n1 = length(a1)
   val n2 = length(a2)
   match(r1, r2) :
      (r1:NoneT, r2:NoneT) : fall(a1, a2) when n1 == n2 else FFalse()
      (r1:NoneT, r2) : fall(a1, ex(a2, r2)) when n1 >= n2 else FFalse()
      (r1, r2:NoneT) : fall(ex(a1, r1), a2) when n1 <= n2 else FFalse()
      (r1, r2) :
         if n1 <= n2 : fall(ex(a1,r1), ap(a2,r2))
         else : fall(ap(a1,r1), ex(a2,r2))

defn simplify (r:FlowResult, top?) -> FlowResult :
   match(r, top?) :
      (r:FAnd, top?:True) :
         match(simplify(a(r), true), simplify(b(r), true)) :
            (a:FTrue|FFalse|FTrueOrFalse, b) : b
            (a, b:FTrue|FFalse|FTrueOrFalse) : a
            (a, b) : FAnd(a, b)
      (r:FAnd, top?:False) :
         match(simplify(a(r), false), simplify(b(r), false)) :
            (a:FTrue, b) : b
            (a, b:FTrue) : a
            (a:FFalse, b) : a
            (a, b:FFalse) : b
            (a:FTrueOrFalse, b) : FUnknown()
            (a, b:FTrueOrFalse) : FUnknown()
            (a, b) : FAnd(a, b)
      (r:FOr, top?) :
         match(simplify(a(r), false), simplify(b(r), false)) :
            (a:FTrue, b) : a
            (a, b:FTrue) : b
            (a:FFalse, b:FFalse) : a
            (a:FFalse, b) : simplify(b, true) when top? else b
            (a, b:FFalse) : simplify(a, true) when top? else a
            (a:FTrueOrFalse, b) : FUnknown()
            (a, b:FTrueOrFalse) : FUnknown()
            (a, b) : FOr(a, b)
      (r, top?) :
         r

defn eval (r:FlowResult) -> False|Unknown|Type :
   match(r) :
      (r:FOr) :
         match(eval(a(r)), eval(b(r))) :
            (a:False, b) : b
            (a, b:False) : a
            (a:Unknown, b) : a
            (a, b:Unknown) : b
            (a:Type, b:Type) : TOr(a, b)
      (r:FAnd) :
         match(eval(a(r)), eval(b(r))) :
            (a:False|Unknown, b) : a
            (a, b:False|Unknown) : b
            (a:Type, b:Type) : TOr(a, b)
      (r:FTrue) : TBot()
      (r:FFalse) : false
      (r:FTrueOrFalse) : unknown
      (r:FUnknown) : unknown
      (r:FType) : type(r)

public defn flow (cn:Int, x:Type, y:Type) -> Type|Unknown :
   println("\nflow(~, ~, ~)" << [cn, x, y])
   val r = flow-result(cn, x, y)
   println("r = ~" << [r])
   val t = eval(simplify(r, true))
   println("t = ~" << [t])
   match(t) :
      (t:False) : TNone()
      (t:Type|Unknown) : t

public defn flow (cn:Int, x:LSType, y:LSType) -> Type|Unknown :
   val r = flow-result(cn, x, y)
   match(eval(simplify(r, true))) :
      (t:False) : TNone()
      (t:Type|Unknown) : t

;======== Overlap Relation ========
public defn overlap? (x:Type, y:Type) -> True|False :
   match(x, y) :
      ;5. Bottom Type: Fast Path
      (x:TBot, y) : true
      (x, y:TBot) : true      
      ;4. Gradual Type: Fast Path
      (x:TGradual, y) : true
      (x, y:TGradual) : true      
      ;3. Combinatory Types
      (x:TOr, y) : overlap?(a(x), y) or overlap?(b(x), y)
      (x, y:TOr) : overlap?(x, a(y)) or overlap?(x, b(y))
      (x:TAnd, y) : overlap?(a(x), y) or overlap?(b(x), y)
      (x, y:TAnd) : overlap?(x, a(y)) or overlap?(x, b(y))      
      ;2. Unitary Types
      (x:TOf, y:TOf) :
         if n(x) == n(y) :
            overlap?(type(x), type(y))
         else :
            any?(overlap?{_, y}, parents(x, n(y))) or
            any?(overlap?{x, _}, parents(y, n(x)))
      (x:TTuple, y:TTuple) :
         if length(types(x)) == length(types(y)) :
            all?(overlap?, types(x), types(y))
      (x:TTuple, y:TOf) : overlap?(collapse(x), y)
      (x:TOf, y:TTuple) : overlap?(x, collapse(y))
      (x:TArrow, y:TArrow) :
         overlap?(a(x), a(y)) and overlap?(b(x), b(y))      
      ;1. Ground Types
      (x:TVar, y:TVar) : n(x) == n(y)
      ;6. Fall Through
      (x:TVar|TArrow|TTuple|TOf, y:TVar|TArrow|TTuple|TOf) : false

public defn overlap? (x:RefT, y:RefT) :
   overlap?(type(x), type(y))

;======== Partof Relation ========
defn passable? (x:Type, y:Type) -> True|False|Maybe|Unknown :
   match(x, y) :
      ;5. Bottom Type: Fast Path
      (x:TBot, y) : true
      ;3. Combinatory Types
      (x:TOr, y) : or4(passable?(a(x), y), passable?(b(x), y))
      (x, y:TOr) : or4(passable?(x, a(y)), passable?(x, b(y)))
      (x, y:TAnd) : and4(passable?(x, a(y)), passable?(x, b(y)))
      (x:TAnd, y) : or4(passable?(a(x), y), passable?(b(x), y))
      ;2. Unitary Types
      (x:TOf, y:TOf) :
         if n(x) == n(y) :
            subtype?(type(x), type(y))
         else :
            or4(any4?(passable?{_, y}, parents(x, n(y))),
                any4?(passable?{x, _}, parents(y, n(x))))
      (x:TTuple, y:TOf) : passable?(collapse(x), y)
      (x:TOf, y:TTuple) : passable?(x, collapse(y))
      ;1. Inherited Behavior
      (x:TVar|TTuple|TArrow, y:TVar|TTuple|TArrow) : subtype?(x, y)
      ;4. Gradual Type
      (x:TGradual, y:TGradual) : true
      (x:TGradual, y) : maybe
      (x, y:TGradual) : true      
      ;6. Type Variables
      (x:TUVar, y:TUVar) : subtype?(x, y)
      (x:TUVar, y) : unknown
      (x, y:TUVar) : unknown      
      ;7. Fall Through
      (x:TOf|TVar|TTuple|TArrow, y:TOf|TVar|TTuple|TArrow|TBot) : false

defn passable? (x:LSType, y:LSType) -> True|False|Maybe|Unknown :
   match(x, y) :
      (x:RefT, y:RefT) : passable?(type(x), type(y))
      (x:StructT, y:StructT) : passable?(type(x), type(y)) when n(x) == n(y)
      (x, y) : subtype?(x, y)

public defn partof? (x:TArrow, y:Type) -> True|False|Maybe|Unknown :
   defn passable-a1? (x:Type, y:Type) :
      match(x, y) :
         (x:TTuple, y:TTuple) :
            if length(types(x)) == length(types(y)) :
               all4?(passable?, types(x), types(y))
         (x:TGradual, y:TTuple) :
            maybe
   match(y) :
      ;2. Combinatory Types
      (y:TOr) : or4(partof?(x, a(y)), partof?(x, b(y)))
      (y:TAnd) : and4(partof?(x, a(y)), partof?(x, b(y)))
      ;1. Unitary Types
      (y:TArrow) :
         and4(passable-a1?(a(y), a(x)), subtype?(b(x), b(y)))
      ;3. Gradual Type
      (y:TGradual) : partof?(x, expand-gradual(x))
      ;4. Type Variables
      (y:TUVar) : unknown
      ;5. Fall through
      (y:TOf|TTuple|TVar|TBot) : false

public defn part-callable? (x:TArrow, args:List<List<Type>>) :
   defn pass? (arg:List<Type>, t:Type) :
      any4?(passable?{_, t}, arg)         
   val a1 = types(a(x) as TTuple)
   if length(a1) == length(args) :
      all4?(pass?, args, a1)

public defn part-callable? (x:FnT, args:List<List<LSType>>) -> True|False|Maybe|Unknown :
   defn ex (ts:List<LSType>, r:LSType) :
      concat(ts, stream({r}, 0 to false))
   defn pass? (arg:List<LSType>, t:LSType) :
      any4?(passable?{_, t}, arg)
   match(r(x)) :
      (rx:NoneT) :
         if length(a(x)) == length(args) :
            all4?(pass?, args, a(x))
      (rx) :
         if length(a(x)) <= length(args) :
            all4?(pass?, args, ex(a(x), rx))

;======== Converting Between LoStanza and HiStanza ======
public defn to-ls-fn (t:TArrow|TPoly) :
   defn conv (t:TArrow) :
      val args = types(a(t) as TTuple)
      FnT(map(RefT, args), NoneT(), RefT(b(t)))
   match(t) :
      (t:TArrow) : conv(t)
      (t:TPoly) : PolyT(targs(t), cargs(t), conv(func(t)))

public defn to-hs-fn (t:FnT|PolyT) :
   label<Type> return :
      ;Return type within Ref 
      defn ref-type (t:LSType) :
         match(t) :
            (t:RefT) : type(t)
            (t) : return(TNone())
      ;Convert function      
      defn conv (t:FnT) :
         return(TNone()) when r(t) not-typeof NoneT
         TArrow(TTuple(map(ref-type, a(t))), ref-type(b(t)))
      ;Convert
      match(t) :
         (t:FnT) : conv(t)
         (t:PolyT) : TPoly(targs(t), cargs(t), conv(func(t)))

;======== Function Mixing ========
public defn mix (sel:List<True|Maybe|False>, ts:List<Type>) -> Type :
   ;======== State ========
   val funcs = HashTable<Int, TArrow>({_})

   ;======== Utilities ========
   defn remove-ret (t:TArrow) :
      TArrow(a(t), TGradual())
   defn combine (t1:TArrow, t2:TArrow) :
      val a* = TTuple(map(TOr, a1, a2)) where :
         val a1 = types(a(t1) as TTuple)
         val a2 = types(a(t2) as TTuple)
      val b* = TOr(b(t1), b(t2))
      TArrow(a*, b*) 
   defn combine (t1:False, t2:TArrow) :
      t2
   defn arity (t:TArrow) :
      length(types(a(t) as TTuple))
      
   ;======== Driver ========
   defn combine! (t:TArrow) :
      val n = arity(t)
      val t* = get?(funcs, n, false)
      funcs[n] = combine(t*, t)
      
   for (s in sel, t in ts) do :
      match(s) :
         (s:True) : combine!(t as TArrow)
         (s:Maybe) : combine!(remove-ret(t as TArrow))
         (s:False) : false
   val fs = to-stream(values(funcs))
   if more?(fs) : reduce(TAnd, fs)
   else : TNone()

;In order for two LoStanza functions to be mixed,
;all arguments must be compatible.
defn compatible? (x:LSType, y:LSType) -> True|False :
   match(x, y) :
      ;1. Primitive Types
      (x:ByteT, y:ByteT) : true
      (x:IntT, y:IntT) : true
      (x:LongT, y:LongT) : true
      (x:FloatT, y:FloatT) : true
      (x:DoubleT, y:DoubleT) : true
      (x:UnknownT, y:UnknownT) : true
      ;2. Parametric Types
      (x:PtrT, y:PtrT) : compatible?(type(x), type(y))
      (x:StructT, y:StructT) : n(x) == n(y)
      (x:RefT, y:RefT) : true
      (x:FnT, y:FnT) :
         if length(a(x)) == length(a(y)) :
            match(r(x), r(y)) :
               (rx:NoneT, ry:NoneT) :
                  all?(compatible?,a(x),a(y)) and
                  compatible?(b(x), b(y))
               (rx:LSType, ry:LSType) :
                  all?(compatible?,a(x),a(y)) and
                  compatible?(b(x), b(y)) and
                  compatible?(rx, ry)
               (rx, ry) : false
      ;3. Fall through      
      (x, y) : false

;Take the OR of two LoStanza types. Assumes that x and y are compatible.
defn mix (x:LSType, y:LSType) :
   match(x, y) :
      ;1. Primitive Types
      (x:ByteT|IntT|LongT|FloatT|DoubleT|UnknownT, y) : x
      ;2. Parametric Types
      (x:PtrT, y:PtrT) : PtrT(mix(type(x), type(y)))
      (x:StructT, y:StructT) : StructT(n(x), TOr(type(x), type(y)))
      (x:RefT, y:RefT) : RefT(TOr(type(x), type(y)))
      (x:FnT, y:FnT) :
         match(r(x), r(y)) :
            (rx:NoneT, ry:NoneT) : FnT(map(mix,a(x),a(y)), rx, mix(b(x),b(y)))
            (rx, ry) : FnT(map(mix,a(x),a(y)), mix(rx,ry), mix(b(x),b(y)))
      ;3. Fall through      
      (x, y) : error("Cannot be mixed: ~ and ~" % [x, y])

;LoStanza mixing in calling context
public defn mix (sel:List<True|Maybe|False>, ts:List<LSType>) -> LSType :
   label<LSType> return :
      defn remove-ret (t:FnT) :
         match(b(t)) :
            (b:RefT) : FnT(a(t), r(t), RefT(TGradual()))
            (b) : return(NoneT())

      defn ensure-compatible (t1:FnT, t2:FnT) :
         match(r(t1), r(t2)) :
            (r1:NoneT, r2:NoneT) : fail() when not compatible?(t1, t2)
            (r1, r2) : return(NoneT())
            
      defn ensure-all-compatible (funcs:Vector<FnT>) :
         fail() when empty?(funcs)
         val fs = to-stream(funcs)
         val f = next(fs)
         do(ensure-compatible{f, _}, fs)

      val funcs = Vector<FnT>()
      for (s in sel, t in ts) do :
         match(s) :
            (s:True) : add(funcs, t as FnT)
            (s:Maybe) : add(funcs, remove-ret(t as FnT))
            (s:False) : false
      ensure-all-compatible(funcs)
      reduce(mix, funcs) as FnT         
            
;======== Disjoint Relation ========
defn erase (t:Type) -> Type :
   match(t) :
      (t:TOf) : TOf(n(t), TGradual())
      (t:TArrow) :TArrow(TGradual(), TGradual())
      (t:TTuple) : erase(collapse(t))
      (t:TVar) : TGradual()
      (t:TAnd|TOr) : map(erase, t)
      (t:TGradual) : t
      (t:TBot) : t
      (t) : error("Invalid type to erase: ~" % [t])

defn disjoint? (x:Type, y:Type, u:Type) :
   defn ps! (x:Type, y:Type) :
      passable?(x, y) == true
   match(u) :
      (u:TOr|TAnd) :
         disjoint?(x, y, a(u)) and disjoint?(x, y, b(u))
      (u) :
         val ex = erase(x)
         val ey = erase(y)
         val eu = erase(u)
         if overlap?(ex, ey) : false
         else : not (ps!(eu, ex) and ps!(eu, ey))

defn disjoint? (x:LSType, y:LSType, u:LSType) :
   match(x, y, u) :
      (x:RefT, y:RefT, u:RefT) : disjoint?(type(x), type(y), type(u))
      (x:RefT, y:RefT, u) : disjoint?(type(x), type(y), TGradual())
      (x, y, u) : false
      
public defn disjoint-fns? (x:TArrow, y:TArrow, u:Type) :      
   defn disjoint-a1? (x:TTuple, y:TTuple, u:Type) :
      val xts = types(x)
      val yts = types(y)
      if length(xts) != length(yts) :
         true
      else :
         match(u) :
            (u:TTuple) :
               val uts = types(u)
               if length(uts) == length(xts) : any?(disjoint?, xts, yts, uts)
               else : any?(disjoint?{_, _, TGradual()}, xts, yts)
            (u:TGradual) :
               any?(disjoint?{_, _, u}, xts, yts)
   match(u) :
      (u:TOr|TAnd) : disjoint-fns?(x, y, a(u)) and disjoint-fns?(x, y, b(u))
      (u:TArrow) : disjoint-a1?(a(x) as TTuple, a(y) as TTuple, a(u))
      (u) : disjoint-a1?(a(x) as TTuple, a(y) as TTuple, TGradual())

public defn disjoint-fns? (x:FnT, y:FnT, u:LSType) :
   defn disjoint-a? (x:List<LSType>, y:List<LSType>, u:List<LSType>) :
      if length(x) != length(y) :
         true
      else if length(x) == length(u) :
         any?(disjoint?, x, y, u)
      else :
         any?(disjoint?{_, _, NoneT()}, x, y)         
   match(u) :
      (u:FnT) : disjoint-a?(a(x), a(y), a(u))
      (u) : disjoint-a?(a(x), a(y), List())

;======== Submethod Relation ========
public defn submethod? (x:TArrow, y:TArrow) -> True|False|Unknown :
   defn st? (x:Type, y:Type) :
      match(subtype?(x, y)) :
         (r:True|Maybe) : true
         (r:False|Unknown) : r
   val [ax, bx] = [a(x), b(x)]
   val [ay, by] = [a(y), b(y)]
   and3(st?(ax, ay), st?(bx, by))

;====== LoStanza Subtyping ======
public defn subtype? (x:LSType, y:LSType) -> True|False|Unknown :
   match(x, y) :
      ;3. Unknown Type Fast Path
      (x:UnknownT, y) : true
      (x, y:UnknownT) : true
      ;1. Primitive Types
      (x:ByteT, y:ByteT) : true
      (x:IntT, y:IntT) : true
      (x:LongT, y:LongT) : true
      (x:FloatT, y:FloatT) : true
      (x:DoubleT, y:DoubleT) : true
      ;2. Parametric Types
      (x:PtrT, y:PtrT) : subtype?(type(x), type(y))
      (x:StructT, y:StructT) : subtype?(type(x), type(y)) when n(x) == n(y)
      (x:RefT, y:RefT) : subtype?(type(x), type(y))
      (x:FnT, y:FnT) : and3(subtype?(a(y), r(y), a(x), r(x)), subtype?(b(x), b(y)))
      ;4. Type Variables
      (x:UVarT, y:UVarT) :
         if n(x) == n(y) : true
         else : unknown
      (x:UVarT, y) : unknown
      (x, y:UVarT) : unknown
      ;5. Fall through
      (x:PtrT|RefT|FnT|StructT|ByteT|IntT|LongT|FloatT|DoubleT,
       y:PtrT|RefT|FnT|StructT|ByteT|IntT|LongT|FloatT|DoubleT) : false
      ;6. Error 
      (x, y) : error("Cannot compute subtype?(~, ~)" % [x, y])

public defn subtype? (a1:List<LSType>, r1:LSType, 
                      a2:List<LSType>, r2:LSType) -> True|False|Unknown :
   defn ex (ts:List<LSType>, r:LSType) : concat(ts, stream({r}, 0 to false))
   defn ap (ts:List<LSType>, r:LSType) : concat(ts, [r])
   val n1 = length(a1)
   val n2 = length(a2)
   match(r1, r2) :
      (r1:NoneT, r2:NoneT) : all3?(subtype?, a1, a2) when n1 == n2
      (r1:NoneT, r2:LSType) : all3?(subtype?, a1, ex(a2,r2)) when n1 >= n2
      (r1:LSType, r2:NoneT) : all3?(subtype?, ex(a1,r1), a2) when n1 <= n2
      (r1:LSType, r2:LSType) :
         if n1 <= n2 : all3?(subtype?, ex(a1,r1), ap(a2,r2))
         else : all3?(subtype?, ap(a1,r1), ex(a2,r2))
         
;;====== LoStanza Castable ======
public defn primitive-size (t:LSType) :
   match(t) :
      (t:ByteT) : 1
      (t:IntT) : 4
      (t:LongT) : 8
      (t:FloatT) : 4
      (t:DoubleT) : 8
      (t:PtrT|RefT) : 8

public defn reinterpret? (x:LSType, y:LSType) :
   match(x, y) :
      (x:RefT, y:RefT) : overlap?(type(x), type(y))
      (x:PtrT|LongT|RefT, y:PtrT|LongT|RefT) : true
      (x, y) : false

public defn convert? (x:LSType, y:LSType) :
   match(x, y) :
      (x:ByteT|IntT|LongT|FloatT|DoubleT, y:ByteT|IntT|LongT|FloatT|DoubleT) : true
      (x, y) : false

public defn castable? (x:LSType, y:LSType) :
   reinterpret?(x, y) or convert?(x, y)

public defn implicit-upcast? (x:LSType, y:LSType) :
   match(x, y) :
      (x:ByteT|IntT|LongT, y:ByteT|IntT|LongT) : primitive-size(x) < primitive-size(y)
      (x:FloatT|DoubleT, y:FloatT|DoubleT) : primitive-size(x) < primitive-size(y)
      (x, y) : false

;Is x assignable to y
public defn assignable? (x:LSType, y:LSType) :
   or3(implicit-upcast?(x, y), subtype?(x, y))

public defn callable? (x:FnT, a2:List<LSType>) :
   defn ex (ts:List<LSType>, r:LSType) : concat(ts, stream({r}, 0 to false))
   val a1 = a(x)
   val n1 = length(a1)
   val n2 = length(a2)
   match(r(x)) :
      (rx:NoneT) : all3?(assignable?, a2, a1) when n1 == n2
      (rx:LSType) : all3?(assignable?, a2, ex(a1, rx)) when n1 <= n2      