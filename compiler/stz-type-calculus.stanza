defpackage stz/type-calculus :
   import core
   import verse
   import stz/tl-ir
   import stz/utils
   import stz/ids

;======== Utilities ========
var CURRENT-HIERARCHY: False|THierarchy = false
public defn current-hierarchy () :
   match(CURRENT-HIERARCHY) :
      (h:False) : error("Current hierarchy not set.")
      (h:THierarchy) : h

public defn set-current-hierarchy (h:THierarchy|False) :
   CURRENT-HIERARCHY = h
      
public defn parent (h:THierarchy, t:TOf) -> Type :
   val e = h[n(t)]
   val env = match(type(t)) :
      (t:TTuple) : map(KeyValue, args(e), types(t))
      (t:TGradual) : map(KeyValue{_, t}, args(e))
   sub(parent(e), env)

public defn parent (t:TOf) :
   parent(current-hierarchy(), t)

public defn parents (t:TOf, class:Int) -> List<TOf> :
   defn loop (t:Type) :
      match(t) :
         (t:TOf) :
            if n(t) == class : list(t)
            else : loop(parent(t))
         (t:TAnd) :
            append(loop(a(t)), loop(b(t)))
         (t:TNone) :
            list()
   loop(t)

;======== Type Operations ========
public defn sub (t:Type, env:List<KeyValue<Int, Type>>) :
   match(t) :
      (t:TVar) : lookup(env, n(t), t)
      (t:TCap) : lookup(env, n(t), t)
      (t) : map(sub{_, env}, t)

public defn lookup<?T> (env:List<KeyValue<Int,?T>>, n:Int, default:?T) :
   val e = for e in env find :
      key(e) == n
   match(e) :
      (e:KeyValue<Int,T>) : value(e)
      (e:False) : default

public defn lookup!<?T> (env:List<KeyValue<Int,?T>>, n:Int) :
   val e = for e in env find :
      key(e) == n
   match(e) :
      (e:KeyValue<Int,T>) : value(e)
      (e:False) : error("No entry for ~ in env." % [n])      

;============ Unknown|Maybe =============
public defn and3 (x: True|False|Unknown, y: True|False|Unknown) :
   and4(x, y) as True|False|Unknown
public defn or3 (x: True|False|Unknown, y: True|False|Unknown) :
   or4(x, y) as True|False|Unknown
public defn all3?<?T> (pred?: (T) -> True|Unknown|False, xs:Streamable<?T>) :
   all4?(pred?, xs) as True|False|Unknown
public defn all3?<?S,?T> (pred?: (S,T) -> True|Unknown|False, xs:Streamable<?S>, ys:Streamable<?T>) :
   all4?(pred?, xs, ys) as True|False|Unknown
public defn any3?<?T> (pred?: (T) -> True|Unknown|False, xs:Streamable<?T>) :
   any4?(pred?, xs) as True|False|Unknown
public defn any3?<?S,?T> (pred?: (S,T) -> True|Unknown|False, xs:Streamable<?S>, ys:Streamable<?T>) :
   any4?(pred?, xs, ys) as True|False|Unknown

public defn and4 (x: True|Unknown|False|Maybe, y: True|Unknown|False|Maybe) -> True|Unknown|False|Maybe :
   match(x, y) :
      (x:False, y) : false
      (x, y:False) : false
      (x:Unknown, y) : unknown
      (x, y:Unknown) : unknown
      (x:Maybe, y) : maybe
      (x, y:Maybe) : maybe
      (x:True, y:True) : true

public defn or4 (x: True|Unknown|False|Maybe, y: True|Unknown|False|Maybe) -> True|Unknown|False|Maybe :
   match(x, y) :
      (x:True, y) : true
      (x, y:True) : true
      (x:Unknown, y) : unknown
      (x, y:Unknown) : unknown
      (x:Maybe, y) : maybe
      (x, y:Maybe) : maybe
      (x:False, y:False) : false

public defn all4?<?T> (pred?: (T) -> True|Unknown|False|Maybe, xs:Streamable<?T>) :
   val s = to-stream(xs)
   defn loop () :
      if more?(s) :
         and4(pred?(next(s)), loop())
      else : true
   loop()   

public defn all4?<?S,?T> (pred?: (S,T) -> True|Unknown|False|Maybe, xs:Streamable<?S>, ys:Streamable<?T>) :
   val s = to-stream(xs)
   val t = to-stream(ys)
   defn loop () :
      if more?(s) and more?(t) :
         and4(pred?(next(s), next(t)), loop())
      else : true
   loop()   

public defn any4?<?T> (pred?: (T) -> True|Unknown|False|Maybe, xs:Streamable<?T>) :
   val s = to-stream(xs)
   defn loop () :
      if more?(s) :
         or4(pred?(next(s)), loop())
      else : false
   loop()   

public defn any4?<?S,?T> (pred?: (S,T) -> True|Unknown|False|Maybe, xs:Streamable<?S>, ys:Streamable<?T>) :
   val s = to-stream(xs)
   val t = to-stream(ys)
   defn loop () :
      if more?(s) and more?(t) :
         or4(pred?(next(s), next(t)), loop())
      else : false
   loop()   

;======== Tuple Collapsing ========
defn collapse (t:TTuple) :
   val t* = reduce(TOr, TBot(), types(t))
   TOf(TUPLE-TYPE-ID, TTuple(list(t*)))

;======== Subtyping Relation ========
public defn subtype? (x:Type, y:Type) -> True|False|Unknown :
   match(x, y) :
      ;5. Bottom Type: Fast Path
      (x:TBot, y) : true
      ;4. Gradual Type: Fast Path
      (x:TGradual, y) : true
      (x, y:TGradual) : true
      ;3. Combinatory Types
      (x:TOr, y) : and3(subtype?(a(x), y), subtype?(b(x), y))
      (x, y:TOr) : or3(subtype?(x, a(y)), subtype?(x, b(y)))
      (x, y:TAnd) : and3(subtype?(x, a(y)), subtype?(x, b(y)))
      (x:TAnd, y) : or3(subtype?(a(x), y), subtype?(b(x), y))
      ;2. Unitary Types
      (x:TOf, y:TOf) :
         if n(x) == n(y) : subtype?(type(x), type(y))
         else : any3?(subtype?{_, type(y)}, parents(x, n(y)))
      (x:TTuple, y:TTuple) : 
         if length(types(x)) == length(types(y)) :
            all3?(subtype?, types(x), types(y))
      (x:TTuple, y:TOf) :
         subtype?(collapse(x), y)
      (x:TArrow, y:TArrow) :
         and3(subtype?(a(y), a(x)), subtype?(b(x), b(y)))
      ;1. Ground Types
      (x:TVar, y:TVar) : n(x) == n(y)
      ;6. Type Variables
      (x:TUVar, y:TUVar) :
         if n(x) == n(y) : true
         else : unknown
      (x:TUVar, y) : unknown
      (x, y:TUVar) : unknown
      ;7. Fall through
      (x:TOf|TTuple|TArrow|TVar, y:TOf|TTuple|TArrow|TVar|TBot) : false

;======== Strict Subtyping Relation ========
;x <! y => x is definitely a subtype of y.
;Transitive. Used only for type simplification.
defn subtype! (x:Type, y:Type) -> True|False :
   match(x, y) :
      ;4. Bottom Type: Fast Path
      (x:TBot, y) : true
      ;3. Combinatory Types
      (x:TOr, y) : subtype!(a(x), y) and subtype!(b(x), y)
      (x, y:TOr) : subtype!(x, a(y)) or subtype!(x, b(y))
      (x, y:TAnd) : subtype!(x, a(y)) and subtype!(x, b(y))
      (x:TAnd, y) : subtype!(a(x), y) or subtype!(b(x), y)
      ;2. Unitary Types
      (x:TOf, y:TOf) :
         if n(x) == n(y) : subtype!(type(x), type(y))
         else : any?(subtype!{_, type(y)}, parents(x, n(y)))
      (x:TTuple, y:TTuple) : 
         if length(types(x)) == length(types(y)) :
            all?(subtype!, types(x), types(y))
      (x:TTuple, y:TOf) :
         subtype!(collapse(x), y)
      (x:TArrow, y:TArrow) :
         subtype!(a(y), a(x)) and subtype!(b(x), b(y))
      ;1. Ground Types
      (x:TVar, y:TVar) : n(x) == n(y)
      (x:TGradual, y:TGradual) : true
      ;5. Type Variables
      (x:TUVar, y:TUVar) : n(x) == n(y)
      (x:TUVar, y) : false
      (x, y:TUVar) : false      
      ;6. Fall through
      (x:TOf|TTuple|TArrow|TVar|TGradual, y:TOf|TTuple|TArrow|TVar|TGradual|TBot) : false

public defn simplify (t:Type) -> Type :
   defn* or-ts (t:Type, accum:List<Type>) :
      match(t) :
         (t:TOr) : or-ts(b(t), or-ts(a(t), accum))
         (t) : List(t, accum)
   defn* and-ts (t:Type, accum:List<Type>) :
      match(t) :
         (t:TAnd) : and-ts(b(t), and-ts(a(t), accum))
         (t) : List(t, accum)
   defn supertype! (a:Type, b:Type) : subtype!(b, a)
   defn st (t:Type) -> Type :
      match(t) :
         (t:TOr) :
            reduce(TOr, ts*) where :
               val ts = minima(or-ts(t, List()), supertype!)
               val ts* = stream(st, ts)
         (t:TAnd) :
            reduce(TAnd, ts*) where :
               val ts = minima(and-ts(t, List()), subtype!)
               val ts* = stream(st, ts)
         (t) :
            map(st, t)
   st(t)

;======== Flow Relation ========
defn expand-gradual (t:Type) :
   match(t) :
      (t:TOf) : TOf(n(t), TGradual())
      (t:TTuple) : TTuple(map(TGradual{}, types(t)))
      (t:TArrow) : TArrow(TGradual(), TGradual())
      (t:TVar) : t
      (t:TBot) : t

definterface FlowResult
defstruct FAnd <: FlowResult : (a:FlowResult, b:FlowResult)
defstruct FOr <: FlowResult : (a:FlowResult, b:FlowResult)
defstruct FFalse <: FlowResult
defstruct FUnknown <: FlowResult
defstruct FType <: FlowResult : (type:Type)

#with-overlay(stz/printer-lang) :
   defprinter (r:FlowResult) :
      FAnd :
         ($and a b)
      FOr :
         ($or a b)
      FFalse :
         ($false)
      FUnknown :
         ($unknown)
      FType :
         custom{type(r)}

defn flow-result (cn:Int, x:Type, y:Type) -> FlowResult :
   defn fl (xs:List<Type>, y:Type) : stream(fl{_, y}, xs)
   defn fl (x:Type, ys:List<Type>) : stream(fl{x, _}, ys)
   defn fl (xs:List<Type>, ys:List<Type>) : stream(fl, xs, ys)
   defn fl (x:Type, y:Type) -> FlowResult :
      match(x, y) :
         ;8. Capture
         (x, y:TCap) :
            error("Cap n does not match flow n") when n(y) != cn
            FType(x)
         (x:TCap, y) :
            error("Cap n does not match flow n") when n(x) != cn
            FType(y)
         ;5. Bottom Type: Fast Path
         (x:TBot, y) : FType(TBot())
         ;3. Combinatory types
         (x:TOr, y) : FAnd(fl(a(x), y), fl(b(x), y))
         (x, y:TOr) : FOr(fl(x, a(y)), fl(x, b(y)))
         (x, y:TAnd) : FAnd(fl(x, a(y)), fl(x, b(y)))
         (x:TAnd, y) : FOr(fl(a(x), y), fl(b(x), y))
         ;2. Unitary Types
         (x:TOf, y:TOf) :
            if n(x) == n(y) :
               fl(type(x), type(y))
            else :
               val rs = concat(fl(parents(x, n(y)), y), fl(x, parents(y, n(x))))
               if more?(rs) : reduce(FOr, rs)
               else : FFalse()
         (x:TTuple, y:TTuple) :
            if length(types(x)) == length(types(y)) :
               if empty?(types(x)) : FType(TBot())
               else : reduce(FAnd, fl(types(x), types(y)))
            else : FFalse()
         (x:TTuple, y:TOf) : fl(collapse(x), y)
         (x:TOf, y:TTuple) : fl(x, collapse(y))
         (x:TArrow, y:TArrow) : FAnd(fl(a(y), a(x)), fl(b(x), b(y)))
         ;1. Ground Types
         (x:TVar, y:TVar) :
            if n(x) == n(y) : FType(TBot())
            else : FFalse()
         ;4. Gradual Type
         (x:TGradual, y:TGradual) : FType(TBot())
         (x:TGradual, y:TUVar) : FType(TBot())
         (x:TUVar, y:TGradual) : FType(TBot())
         (x:TGradual, y) : fl(expand-gradual(y), y)
         (x, y:TGradual) : fl(x, expand-gradual(x))
         ;6. Unknown Type
         (x:TUVar, y:TUVar) :
            if n(x) == n(y) : FType(TBot())
            else : FUnknown()
         (x:TUVar, y) : FUnknown()
         (x, y:TUVar) : FUnknown()
         ;7. Fall through
         (x:TOf|TTuple|TArrow|TVar|TNone, y:TOf|TTuple|TArrow|TVar|TBot|TNone) : FFalse()
   fl(x, y)

public defn flow (cn:Int, x:Type, y:Type) -> Type|False|Unknown :
   defn simplify (r:FlowResult, top?) -> FlowResult :
      match(r, top?) :
         (r:FAnd, top?:True) :
            match(simplify(a(r), true), simplify(b(r), true)) :
               (a:FFalse|FUnknown, b) : b
               (a, b:FFalse|FUnknown) : a               
               (a, b) : FAnd(a, b)
         (r:FAnd, top?:False) :
            match(simplify(a(r), false), simplify(b(r), false)) :
               (a:FFalse, b:FFalse) : FFalse()
               (a:FUnknown, b:FUnknown) : FUnknown()
               (a, b) : FAnd(a, b)
         (r:FOr, top?) :
            match(simplify(a(r), false), simplify(b(r), false)) :
               (a:FFalse, b) : simplify(b, true) when top? else b
               (a, b:FFalse) : simplify(a, true) when top? else a
               (a:FUnknown, b) : a
               (a, b:FUnknown) : b
               (a, b) : FOr(a, b)
         (r, top?) :
            r

   defn eval (r:FlowResult) :
      match(r) :
         (r:FOr) :
            match(eval(a(r)), eval(b(r))) :
               (a:False, b) : b
               (a, b:False) : a
               (a:Unknown, b) : a
               (a, b:Unknown) : b
               (a:Type, b:Type) : TOr(a, b)
         (r:FAnd) :
            match(eval(a(r)), eval(b(r))) :
               (a:False|Unknown, b) : a
               (a, b:False|Unknown) : b
               (a:Type, b:Type) : TOr(a, b)
         (r:FFalse) : false
         (r:FUnknown) : unknown
         (r:FType) : type(r)

   val r = flow-result(cn, x, y)
   eval(simplify(r, true))

;======== Overlap Relation ========
public defn overlap? (x:Type, y:Type) -> True|False :
   match(x, y) :
      ;5. Bottom Type: Fast Path
      (x:TBot, y) : true
      (x, y:TBot) : true      
      ;4. Gradual Type: Fast Path
      (x:TGradual, y) : true
      (x, y:TGradual) : true      
      ;3. Combinatory Types
      (x:TOr, y) : overlap?(a(x), y) or overlap?(b(x), y)
      (x, y:TOr) : overlap?(x, a(y)) or overlap?(x, b(y))
      (x:TAnd, y) : overlap?(a(x), y) or overlap?(b(x), y)
      (x, y:TAnd) : overlap?(x, a(y)) or overlap?(x, b(y))      
      ;2. Unitary Types
      (x:TOf, y:TOf) :
         if n(x) == n(y) :
            overlap?(type(x), type(y))
         else :
            any?(overlap?{_, y}, parents(x, n(y))) or
            any?(overlap?{x, _}, parents(y, n(x)))
      (x:TTuple, y:TTuple) :
         if length(types(x)) == length(types(y)) :
            all?(overlap?, types(x), types(y))
      (x:TTuple, y:TOf) : overlap?(collapse(x), y)
      (x:TOf, y:TTuple) : overlap?(x, collapse(y))
      (x:TArrow, y:TArrow) :
         overlap?(a(x), a(y)) and overlap?(b(x), b(y))      
      ;1. Ground Types
      (x:TVar, y:TVar) : n(x) == n(y)
      ;6. Fall Through
      (x:TVar|TArrow|TTuple|TOf, y:TVar|TArrow|TTuple|TOf) : false

;======== Partof Relation ========
defn passable? (x:Type, y:Type) -> True|False|Maybe|Unknown :
   match(x, y) :
      ;5. Bottom Type: Fast Path
      (x:TBot, y) : true
      ;3. Combinatory Types
      (x:TOr, y) : or4(passable?(a(x), y), passable?(b(x), y))
      (x, y:TOr) : or4(passable?(x, a(y)), passable?(x, b(y)))
      (x, y:TAnd) : and4(passable?(x, a(y)), passable?(x, b(y)))
      (x:TAnd, y) : or4(passable?(a(x), y), passable?(b(x), y))
      ;2. Unitary Types
      (x:TOf, y:TOf) :
         if n(x) == n(y) :
            subtype?(type(x), type(y))
         else :
            or4(any4?(passable?{_, y}, parents(x, n(y))),
                any4?(passable?{x, _}, parents(y, n(x))))
      (x:TTuple, y:TOf) : passable?(collapse(x), y)
      (x:TOf, y:TTuple) : passable?(x, collapse(y))
      ;1. Inherited Behavior
      (x:TVar|TTuple|TArrow, y:TVar|TTuple|TArrow) : subtype?(x, y)
      ;4. Gradual Type
      (x:TGradual, y:TGradual) : true
      (x:TGradual, y) : maybe
      (x, y:TGradual) : true
      ;6. Type Variables
      (x:TUVar, y:TUVar) : subtype?(x, y)
      (x:TUVar, y) : unknown
      (x, y:TUVar) : unknown
      ;7. Fall Through
      (x:TOf|TVar|TTuple|TArrow, y:TOf|TVar|TTuple|TArrow|TBot) : false

public defn partof? (x:Type, y:Type) -> True|False|Maybe|Unknown :
   defn passable-a1? (x:Type, y:Type) :
      match(x, y) :
         (x:TTuple, y:TTuple) :
            if length(types(x)) == length(types(y)) :
               all4?(passable?, types(x), types(y))
         (x:TGradual, y:TTuple) :
            maybe
   match(x, y) :
      ;2. Combinatory Types
      (x, y:TOr) : or4(partof?(x, a(y)), partof?(x, b(y)))
      (x, y:TAnd) : and4(partof?(x, a(y)), partof?(x, b(y)))
      ;1. Unitary Types
      (x:TArrow, y:TArrow) :
         and4(passable-a1?(a(y), a(x)), subtype?(b(x), b(y)))
      ;3. Gradual Type
      (x, y:TGradual) : partof?(x, expand-gradual(x))
      ;4. Type Variables
      (x:TUVar, y:TUVar) : subtype?(x, y)
      (x:TUVar, y) : unknown
      (x, y:TUVar) : unknown
      ;5. Fall through
      (x:TArrow|TNone, y:TOf|TTuple|TArrow|TVar|TBot) : false

;======== Function Mixing ========
public defn mix (sel:List, ts:List<Type>) -> Type :
   ;======== State ========
   val funcs = HashTable<Int, TArrow>({_})

   ;======== Utilities ========
   defn remove-ret (t:TArrow) :
      TArrow(a(t), TGradual())
   defn combine (t1:TArrow, t2:TArrow) :
      val a* = TTuple(map(TOr, a1, a2)) where :
         val a1 = types(a(t1) as TTuple)
         val a2 = types(a(t2) as TTuple)
      val b* = TOr(b(t1), b(t2))
      TArrow(a*, b*) 
   defn combine (t1:False, t2:TArrow) :
      t2
   defn arity (t:TArrow) :
      length(types(a(t) as TTuple))
      
   ;======== Driver ========
   defn combine! (t:TArrow) :
      val n = arity(t)
      val t* = get?(funcs, n, false)
      funcs[n] = combine(t*, t)
      
   for (s in sel, t in ts) do :
      match(s) :
         (s:True) : combine!(t as TArrow)
         (s:Maybe) : combine!(remove-ret(t as TArrow))
         (s:False) : false
   val fs = to-stream(values(funcs))
   if more?(fs) : reduce(TAnd, fs)
   else : TNone()
            
;======== Disjoint Relation ========
defn erase (t:Type) -> Type :
   match(t) :
      (t:TOf) : TOf(n(t), TGradual())
      (t:TArrow) :TArrow(TGradual(), TGradual())
      (t:TTuple) : erase(collapse(t))
      (t:TVar) : TGradual()
      (t:TAnd|TOr) : map(erase, t)
      (t:TGradual) : t
      (t:TBot) : t
      
public defn disjoint? (x:TArrow, y:TArrow, u:Type) :
   defn ps! (x:Type, y:Type) :
      passable?(x, y) == true
      
   defn disjoint? (x:Type, y:Type, u:Type) :
      match(u) :
         (u:TOr|TAnd) :
            disjoint?(x, y, a(u)) and disjoint?(x, y, b(u))
         (u) :
            val ex = erase(x)
            val ey = erase(y)
            val eu = erase(u)
            if overlap?(ex, ey) : false
            else : not (ps!(eu, ex) and ps!(eu, ey))
      
   defn disjoint-a1? (x:TTuple, y:TTuple, u:Type) :
      val xts = types(x)
      val yts = types(y)
      if length(xts) != length(yts) :
         true
      else :
         match(u) :
            (u:TTuple) :
               val uts = types(u)
               if length(uts) == length(xts) : any?(disjoint?, xts, yts, uts)
               else : any?(disjoint?{_, _, TGradual()}, xts, yts)
            (u:TGradual) :
               any?(disjoint?{_, _, u}, xts, yts)

   match(u) :
      (u:TOr|TAnd) : disjoint?(x, y, a(u)) and disjoint?(x, y, b(u))
      (u:TArrow) : disjoint-a1?(a(x) as TTuple, a(y) as TTuple, a(u))
      (u) : disjoint-a1?(a(x) as TTuple, a(y) as TTuple, TGradual())

;======== Submethod Relation ========
public defn submethod? (x:TArrow, y:TArrow) -> True|False|Unknown :
   defn st? (x:Type, y:Type) :
      match(subtype?(x, y)) :
         (r:True|Maybe) : true
         (r:False|Unknown) : r
   val [ax, bx] = [a(x), b(x)]
   val [ay, by] = [a(y), b(y)]
   and3(st?(ax, ay), st?(bx, by))

;====== LoStanza Subtyping ======
;public defn size (t:LSType) :
;   match(t) :
;      (t:ByteT) : 1
;      (t:IntT) : 4
;      (t:LongT) : 8
;      (t:FloatT) : 4
;      (t:DoubleT) : 8
;      (t:PtrT|RefT) : 8
;      (t:StructT) : error("Cannot compute struct size without hierarchy.")
;      (t:UnknownT) : error("Unknown type has no size.")
;      
;public defn subtype? (x:LSType, y:LSType) -> True|False :
;   match(x, y) :
;      (x:UnknownT, y) : true
;      (x, y:UnknownT) : true
;      (x:ByteT|IntT|LongT, y:ByteT|IntT|LongT) : size(x) <= size(y)
;      (x:FloatT|DoubleT, y:FloatT|DoubleT) : size(x) <= size(y)
;      (x:PtrT, y:PtrT) : subtype?(type(x), type(y))
;      (x:RefT, y:RefT) : subtype?(type(x), type(y))
;      (x:StructT, y:StructT) : n(x) == n(y)
;      (x:FnT, y:FnT) : subtype?(a(y), r(y), a(x), r(x)) and subtype?(b(x), b(y))
;
;public defn subtype? (a1:List<LSType>, r1:False|LSType, 
;                      a2:List<LSType>, r2:False|LSType) :
;   defn ex (ts:List<LSType>, r:LSType) : concat(ts, stream({r}, 0 to false))
;   defn ap (ts:List<LSType>, r:LSType) : concat(ts, [r])
;   val n1 = length(a1)
;   val n2 = length(a2)
;   match(r1, r2) :
;      (r1:False, r2:False) : all?(subtype?, a1, a2) when n1 == n2
;      (r1:False, r2:LSType) : all?(subtype?, a1, ex(a2,r2)) when n1 >= n2
;      (r1:LSType, r2:False) : all?(subtype?, ex(a1,r1), a2) when n1 <= n2
;      (r1:LSType, r2:LSType) :
;         all?(subtype?, ex(a1,r1), ap(a2,r2)) when n1 <= n2 else
;         all?(subtype?, ap(a1,r2), ex(a2,r2))
;         
;;====== LoStanza Castable ======
;public defn reinterpret? (x:LSType, y:LSType) :
;   match(x, y) :
;      (x:PtrT|RefT|LongT, y:PtrT|RefT|LongT) : true
;      (x, y) : false
;
;public defn convert? (x:LSType, y:LSType) :
;   match(x, y) :
;      (x:ByteT|IntT|LongT|FloatT|DoubleT, y:ByteT|IntT|LongT|FloatT|DoubleT) : true
;      (x, y) : false
;
;public defn castable? (x:LSType, y:LSType) :
;   reinterpret?(x, y) or convert?(x, y)