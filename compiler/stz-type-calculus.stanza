defpackage stz/type-calculus :
   import core
   import verse

;======== Type Definition ========
#with-overlay(stz/ast-lang) :
   public defast :
      deftype Type

      defmap (f:Type -> Type, t:Type) -> Type :
         (x:Int) : x
         (x:Type) : f(x)
         (x:List<Type>) : map(f, x)
         
      defdo (f:Type -> ?, t:Type) -> ? :
         (x:Int) : x
         (x:Type) : f(x)
         (x:List<Type>) : do(f, x)         

      defnodes Type :
         TCap : (n:Int)
         TOf : (n:Int, type:Type)
         TTuple : (types:List<Type>)
         TOr : (a:Type, b:Type)
         TAnd : (a:Type, b:Type)
         TVar : (n:Int)
         TArrow : (a:Type, b:Type)
         TGradual : ()
         TBot : ()
         TNone: ()

#with-overlay(stz/printer-lang) :
   defprinter (t:Type) :
      TCap :
         ($cap n)
      TOf :
         ($of n type)
      TTuple :
         ($tuple types ...)
      TOr :
         ($and a b)
      TAnd :
         ($and a b)
      TVar :
         custom{to-symbol("$t~" << [n(t)])}
      TArrow :
         ($-> a b)
      TGradual :
         custom{`?}
      TBot :
         custom{`void}
      TNone :
         custom{`none}

;======== Hierarchy ========
defstruct HEntry :
   n: Int
   args: List<Int>
   parent: Type
   
definterface THierarchy
public defn THierarchy () :
   val entries = HashTable<Int,HEntry>({_})
   new THierarchy :
      defmethod add (this, n:Int, args:List<Int>, p:Type) :
         entries[n] = HEntry(n, args, p)
      defmethod entry (this, n:Int) :
         entries[n]
      defmethod entries (this) :
         values(entries)

public defn parent (h:THierarchy, t:TOf) -> Type :
   val e = entry(h, n(t))
   sub(parent(e), map(KeyValue, args(e), args(t)))

;======== Implicit Type Hierarchy =======
var CURRENT-HIERARCHY: False|THierarchy = false
defn current-hierarchy () :
   match(CURRENT-HIERARCHY) :
      (h:False) : error("Current hierarchy not set.")
      (h:THierarchy) : h

defn set-current-hierarchy (h:THierarchy|False) :
   CURRENT-HIERARCHY = h

public defn parent (t:TOf) :
   parent(current-hierarchy(), t)

public defn parents (t:TOf, class:Int) -> List<TOf> :
   defn loop (t:Type) :
      match(t) :
         (t:TOf) :
            if n(t) == class : list(t)
            else : loop(parent(t))
         (t:TAnd) :
            append(loop(a(t)), loop(b(t)))
         (t:TNone) :
            list()
   loop(t)

;======== Type Operations ========
public defn sub (t:Type, env:List<KeyValue<Int, Type>>) :
   match(t) :
      (t:TVar) : lookup(env, name(t), t)
      (t:TCap) : lookup(env, name(t), t)
      (t) : map(sub{_, env}, t)

;======== Subtyping Relation ========
public defn expand-gradual (t:Type) :
   match(t) :
      (t:TOf) : TOf(n(t), TGradual())
      (t:TTuple) : TTuple(map(TGradual{}, types(t)))
      (t:TVar) : t
      (t:TBot) : t
      (t:TArrow) : TArrow(TGradual(), TGradual())
      (t) : error("Cannot expand gradual to ~." << [t])
      
public defn subtype? (x:Type, y:Type) :
   match(x, y) :
      (x:TOf, y:TOf) : any?(subtype{_, type(y)}, parents(x, n(y)))
      (x:TTuple, y:TTuple) :
         if length(types(x)) == length(types(y)) :
            all?(subtype?, types(x), types(y))
      (x:TArrow, y:TArrow) : subtype?(a(y), a(x)) and subtype?(b(x), b(y))
      (x:TOr, y) : subtype?(a(x), y) and subtype?(b(x), y)
      (x, y:TAnd) : subtype?(x, a(y)) and subtype?(x, b(y))
      (x:TAnd, y) : subtype?(a(x), y) or subtype?(b(x), y)
      (x, y:TOr) : subtype?(x, a(y)) or subtype?(x, b(y))
      (x:TGradual, y:TGradual) : true
      (x:TGradual, y) : subtype?(expand-gradual(y), y)
      (x, y:TGradual) : subtype?(x, expand-gradual(x))
      (x:TVar, y:TVar) : n(x) == n(y)
      (x:TBot, y) : true
      (x, y) : false
      
;======== Flow Relation ========
definterface FlowResult
defstruct FAnd <: FlowResult :
   a: FlowResult
   b: FlowResult
defstruct FOr <: FlowResult :
   a: FlowResult
   b: FlowResult
defstruct FFalse
defstruct FType <: FlowResult :
   type: Type

defn flow (cn:Int, x:Type, y:Type) -> Type|False :
   defn fl (xs:List<Type>, y:Type) :
      stream(fl{_, y}, xs)
   defn fl (x:Type, ys:List<Type>) :
      stream(fl{x, _}, ys)
   defn fl (xs:List<Type>, ys:List<Type>) :
      stream(fl, xs, ys)
   defn fl (x:Type, y:Type) :   
      match(x, y) :
         (x, y:TCap) :
            error("Cap n does not match flow n") when n(y) != cn
            FType(x)
         (x:TOf, y:TOf) :
            if n(x) == n(y) :
               fl(a(x), b(y))
            else :
               val rs = concat(fl(parents(x, n(y)), y), fl(x, parents(y, n(x))))
               reduce(FOr, rs) when more?(rs) else FFalse()
         (x:TTuple, y:TTuple) :
            if length(x) == length(y) :
               val ts = fl(types(x), types(y))
               if more?(ts) : reduce(FAnd, ts)
               else : FType(TBot())
         (x:TArrow, y:TArrow) :
            FAnd(fl(a(y), a(x)), fl(b(x), b(y)))
         (x:TOr, y) : FAnd(fl(a(x), y), fl(b(x), y))
         (x, y:TOr) : FOr(fl(x, a(y)), fl(x, b(y)))
         (x, y:TAnd) : FAnd(fl(x, a(y)), fl(x, b(y)))
         (x:TAnd, y) : FOr(fl(a(x), y), fl(b(x), y))
         (x:TGradual, y:TGradual) : FType(TBot())
         (x:TGradual, y) : fl(expand-gradual(y), y)
         (x, y:TGradual) : fl(x, expand-gradual(x))
         (x:TVar, y:TVar) : FType(TBot()) when n(x) == n(y) else FFalse()
         (x:TBot, y) : FType(TBot())
         (x, y) : FFalse()

   defn simplify (r:FlowResult, top?) :
      match(r, top?) :
         (r:FOr, top?:True) :
            match(simplify(a(r), false), simplify(b(r), false)) :
               (a:FFalse, b) : simplify(b, true)
               (a, b:FFalse) : simplify(a, true)
               (a, b) : FOr(a, b)
         (r:FOr, top?:False) :
            match(simplify(a(r), false), simplify(b(r), false)) :
               (a:FFalse, b) : b
               (a, b:FFalse) : a
               (a, b) : FOr(a, b)
         (r:FAnd, top?:True) :
            match(simplify(a(r), true), simplify(b(r), true)) :
               (a:FFalse, b) : b
               (a, b:FFalse) : a
               (a, b) : FAnd(a, b)
         (r:FAnd, top?:False) :
            match(simplify(a(r), false), simplify(b(r), false)) :
               (a:FFalse, b:FFalse) : false
               (a, b) : FAnd(a, b)
         (r, top?) :
            r

   defn eval (r:FlowResult) -> Type|False :
      match(r) :
         (r:FOr) :
            match(eval(a(r)), eval(b(r))) :
               (a:False, b) : b
               (a, b:False) : a
               (a, b) : TOr(a, b)         
         (r:FAnd) :
            match(eval(a(r)), eval(b(r))) :
               (a:False, b) : a
               (a, b:False) : b
               (a, b) : TOr(a, b)
         (r:FFalse) : false
         (r:FType) : type(t)

   eval(simplify(fl(x, y), true))
