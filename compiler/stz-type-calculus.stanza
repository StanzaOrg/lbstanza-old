defpackage stz/type-calculus :
   import core
   import verse
   import stz/tl-ir

;======== Utilities ========
var CURRENT-HIERARCHY: False|THierarchy = false
defn current-hierarchy () :
   match(CURRENT-HIERARCHY) :
      (h:False) : error("Current hierarchy not set.")
      (h:THierarchy) : h

defn set-current-hierarchy (h:THierarchy|False) :
   CURRENT-HIERARCHY = h
      
public defn parent (h:THierarchy, t:TOf) -> Type :
   val e = h[n(t)]
   val env = match(type(t)) :
      (t:TTuple) : map(KeyValue, args(e), types(t))
      (t:TGradual) : map(KeyValue{_, t}, args(e))
   sub(parent(e), env)

public defn parent (t:TOf) :
   parent(current-hierarchy(), t)

public defn parents (t:TOf, class:Int) -> List<TOf> :
   defn loop (t:Type) :
      match(t) :
         (t:TOf) :
            if n(t) == class : list(t)
            else : loop(parent(t))
         (t:TAnd) :
            append(loop(a(t)), loop(b(t)))
         (t:TNone) :
            list()
   loop(t)

;======== Type Operations ========
public defn sub (t:Type, env:List<KeyValue<Int, Type>>) :
   match(t) :
      (t:TVar) : lookup(env, n(t), t)
      (t:TCap) : lookup(env, n(t), t)
      (t) : map(sub{_, env}, t)

public defn lookup<?T> (env:List<KeyValue<Int,?T>>, n:Int, default:?T) :
   val e = for e in env find :
      key(e) == n
   match(e) :
      (e:KeyValue<Int,T>) : value(e)
      (e:False) : default

public defn lookup!<?T> (env:List<KeyValue<Int,?T>>, n:Int) :
   val e = for e in env find :
      key(e) == n
   match(e) :
      (e:KeyValue<Int,T>) : value(e)
      (e:False) : error("No entry for ~ in env." % [n])      

;;============ Unknown =============
;public defclass Unknown
;public val unknown:Unknown = new Unknown
;defmethod print (o:OutputStream, u:Unknown) :
;   print(o, "unknown")
;
;public defn and3 (x: True|Unknown|False, y: True|Unknown|False) -> True|Unknown|False :
;   match(x, y) :
;      (x:False, y) : false
;      (x, y:False) : false
;      (x:Unknown, y) : unknown
;      (x, y:Unknown) : unknown
;      (x:True, y:True) : true
;
;public defn or3 (x: True|Unknown|False, y: True|Unknown|False) -> True|Unknown|False :
;   match(x, y) :
;      (x:True, y) : true
;      (x, y:True) : true
;      (x:Unknown, y) : unknown
;      (x, y:Unknown) : unknown
;      (x:False, y:False) : false
;
;public defn all3?<?T> (pred?: (T) -> True|Unknown|False, xs:Streamable<?T>) :
;   val s = to-stream(xs)
;   defn loop () :
;      if more?(s) :
;         and3(pred?(next(s)), loop())
;      else : true
;   loop()   
;
;public defn all3?<?S,?T> (pred?: (S,T) -> True|Unknown|False, xs:Streamable<?S>, ys:Streamable<?T>) :
;   val s = to-stream(xs)
;   val t = to-stream(ys)
;   defn loop () :
;      if more?(s) and more?(t) :
;         and3(pred?(next(s), next(t)), loop())
;      else : true
;   loop()   
;
;public defn any3?<?T> (pred?: (T) -> True|Unknown|False, xs:Streamable<?T>) :
;   val s = to-stream(xs)
;   defn loop () :
;      if more?(s) :
;         or3(pred?(next(s)), loop())
;      else : false
;   loop()   
;
;public defn any3?<?S,?T> (pred?: (S,T) -> True|Unknown|False, xs:Streamable<?S>, ys:Streamable<?T>) :
;   val s = to-stream(xs)
;   val t = to-stream(ys)
;   defn loop () :
;      if more?(s) and more?(t) :
;         or3(pred?(next(s), next(t)), loop())
;      else : false
;   loop()   
;
;======== Subtyping Relation ========
public defn subtype? (x:Type, y:Type) -> True|False|Unknown :
   match(x, y) :
      ;5. Bottom Type: Fast Path
      (x:TBot, y) : true
      ;4. Gradual Type: Fast Path
      (x:TGradual, y) : true
      (x, y:TGradual) : true
      ;3. Combinatory Types
      (x:TOr, y) : and3(subtype?(a(x), y), subtype?(b(x), y))
      (x, y:TOr) : or3(subtype?(x, a(y)), subtype?(x, b(y)))
      (x, y:TAnd) : and3(subtype?(x, a(y)), subtype?(x, b(y)))
      (x:TAnd, y) : or3(subtype?(a(x), y), subtype?(b(x), y))
      ;2. Unitary Types
      (x:TOf, y:TOf) :
         any3?(subtype?(_, type(y)), parents(x, n(y)))
      (x:TTuple, y:TTuple) : 
         if length(types(x)) == length(types(y)) :
            all3?(subtype?, types(x), types(y))
      (x:TArrow, y:TArrow) :
         and3(subtype?(a(y), a(x)), subtype?(b(x), b(y)))
      ;1. Ground Types
      (x:TVar, y:TVar) : n(x) == n(y)
      ;6. Type Variables
      (x:TUVar, y:TUVar) :
         if n(x) == n(y) : true
         else : unknown
      (x:TUVar, y) : unknown
      (x, y:TUVar) : unknown
      ;7. Fall through
      (x:TOf|TTuple|TArrow|TVar, y:TOf|TTuple|TArrow|TVar|TBot) : false

;======== Strict Subtyping Relation ========
defn subtype! (x:Type, y:Type) -> True|False :
   match(x, y) :
      ;4. Bottom Type: Fast Path
      (x:TBot, y) : true
      ;3. Combinatory Types
      (x:TOr, y) : subtype!(a(x), y) and subtype!(b(x), y)
      (x, y:TOr) : subtype!(x, a(y)) or subtype!(x, b(y))
      (x, y:TAnd) : subtype!(x, a(y)) and subtype!(x, b(y))
      (x:TAnd, y) : subtype!(a(x), y) or subtype!(b(x), y)
      ;2. Unitary Types
      (x:TOf, y:TOf) :
         any?(subtype!(_, type(y)), parents(x, n(y)))
      (x:TTuple, y:TTuple) : 
         if length(types(x)) == length(types(y)) :
            all?(subtype!, types(x), types(y))
      (x:TArrow, y:TArrow) :
         subtype!(a(y), a(x)) and subtype!(b(x), b(y))
      ;1. Ground Types
      (x:TVar, y:TVar) : n(x) == n(y)
      (x:TGradual, y:TGradual) : true
      ;5. Fall through
      (x:TOf|TTuple|TArrow|TVar|TGradual, y:TOf|TTuple|TArrow|TVar|TGradual|TBot) : false

;======== Flow Relation ========
defn expand-gradual (t:Type) :
   match(t) :
      (t:TOf) : TOf(n(t), TGradual())
      (t:TTuple) : TTuple(map(TGradual{}, types(t)))
      (t:TArrow) : TArrow(TGradual(), TGradual())
      (t:TVar) : t
      (t:TBot) : t

definterface FlowResult
defstruct FAnd <: FlowResult :
   a: FlowResult
   b: FlowResult
defstruct FOr <: FlowResult :
   a: FlowResult
   b: FlowResult
defstruct FFalse
defstruct FUnknown
defstruct FType <: FlowResult :
   type: Type

defn flow-result (cn:Int, x:Type, y:Type) -> FlowResult :
   defn fl (xs:List<Type>, y:Type) : stream(fl{_, y}, xs)
   defn fl (x:Type, ys:List<Type>) : stream(fl{x, _}, ys)
   defn fl (xs:List<Type>, ys:List<Type>) : stream(fl, xs, ys)
   defn fl (x:Type, y:Type) :
      match(x, y) :
         ;8. Capture
         (x, y:TCap) :
            error("Cap n does not match flow n") when n(y) != cn
            FType(x)
         (x:TCap, y) :
            error("Cap n does not match flow n") when n(x) != cn
            FType(y)
         ;5. Bottom Type: Fast Path
         (x:TBot, y) : FType(TBot())
         ;3. Combinatory types
         (x:TOr, y) : FAnd(fl(a(x), y), fl(b(x), y))
         (x, y:TOr) : FOr(fl(x, a(y)), fl(x, b(y)))
         (x, y:TAnd) : FAnd(fl(x, a(y)), fl(x, b(y)))
         (x:TAnd, y) : FOr(fl(a(x), y), fl(b(x), y))
         ;2. Unitary Types
         (x:TOf, y:TOf) :
            if n(x) == n(y) :
               fl(type(x), type(y))
            else :
               val rs = concat(fl(parents(x, n(y)), y), fl(x, parents(y, n(x))))
               if more?(rs) : reduce(FOr, rs)
               else : FFalse()
         (x:TTuple, y:TTuple) :
            if length(types(x)) == length(types(y)) :
               val rs = fl(types(x), types(y))
               if more?(rs) : reduce(FAnd, rs)
               else : FFalse()
            else : FFalse()
         (x:TArrow, y:TArrow) :
            FAnd(fl(a(y), a(x)), fl(b(x), b(y)))
         ;1. Ground Types
         (x:TVar, y:TVar) :
            if n(x) == n(y) : FType(TBot())
            else : FFalse()
         ;4. Gradual Type
         (x:TGradual, y:TGradual) : FType(TBot())
         (x:TGradual, y) : fl(expand-gradual(y), y)
         (x, y:TGradual) : fl(x, expand-gradual(x))
         ;6. Unknown Type
         (x:TUVar, y:TUVar) :
            if n(x) == n(y) : FType(TBot())
            else : FUnknown()
         (x:TUVar, y) : FUnknown()
         (x, y:TUVar) : FUnknown()
         ;7. Fall through
         (x:TOf|TTuple|TArrow|TVar, y:TOf|TTuple|TArrow|TVar|TBot) : false
   fl(x, y)

public defn flow (cn:Int, x:Type, y:Type) -> Type|False|Unknown :
   defn simplify (r:FlowResult, top?) :
      match(r, top?) :
         (r:FOr, top?) :
            match(simplify(a(r), false), simplify(b(r), false)) :
               (a:FFalse, b) : simplify(b, true) when top? else b
               (a, b:FFalse) : simplify(a, true) when top? else a
               (a, b) : FOr(a, b)
         (r:FAnd, top?:True) :
            match(simplify(a(r), true), simplify(b(r), true)) :
               (a:FFalse|FUnknown, b) : b
               (a, b:FFalse|FUnknown) : a               
               (a, b) : FAnd(a, b)
         (r:FAnd, top?:False) :
            match(simplify(a(r), false), simplify(b(r), false)) :
               (a:FFalse, b:FFalse) : false
               (a, b) : FAnd(a, b)
         (r, top?) :
            r

   defn eval (r:FlowResult) :
      match(r) :
         (r:FOr) :
            match(eval(a(r)), eval(b(r))) :
               (a:False, b) : b
               (a, b:False) : a
               (a:Unknown, b) : a
               (a, b:Unknown) : b
               (a, b) : TOr(a, b)
         (r:FAnd) :
            match(eval(a(r)), eval(b(r))) :
               (a:False|Unknown, b) : a
               (a, b:False|Unknown) : b
               (a, b) : TOr(a, b)
         (r:FFalse) : false
         (r:FUnknown) : unknown
         (r:FType) : type(t)

   val r = flow-result(cn, x, y)
   eval(simplify(r, true))

;======== Overlap Relation ========
public defn overlap? (x:Type, y:Type) -> True|False :
   match(x, y) :
      ;5. Bottom Type: Fast Path
      (x:TBot, y) : true
      (x, y:TBot) : true      
      ;4. Gradual Type: Fast Path
      (x:TGradual, y) : true
      (x, y:TGradual) : true      
      ;3. Combinatory Types
      (x:TOr, y) : overlap?(a(x), y) or overlap?(b(x), y)
      (x, y:TOr) : overlap?(x, a(y)) or overlap?(x, b(y))
      (x:TAnd, y) : overlap?(a(x), y) or overlap?(b(x), y)
      (x, y:TAnd) : overlap?(x, a(y)) or overlap?(x, b(y))      
      ;2. Unitary Types
      (x:TOf, y:TOf) :
         if n(x) == n(y) :
            overlap?(type(x), type(y))
         else :
            any?(overlap?{_, y}, parents(x, n(y))) or
            any?(overlap?{x, _}, parents(y, n(x)))
      (x:TTuple, y:TTuple) :
         if length(types(x)) == length(types(y)) :
            all?(overlap?, types(x), types(y))
      (x:TArrow, y:TArrow) :
         overlap?(a(x), a(y)) and overlap?(b(x), b(y))      
      ;1. Ground Types
      (x:TVar, y:TVar) : n(x) == n(y)
      ;6. Fall Through
      (x:TVar|TArrow|TTuple|TOf, y:TVar|TArrow|TTuple|TOf) : false

;======== Partof Relation ========
defn passable? (x:Type, y:Type) -> True|False|Maybe|Unknown :
   match(x, y) :
      ;5. Bottom Type: Fast Path
      (x:TBot, y) : true
      ;3. Combinatory Types
      (x:TOr, y) : or4(passable?(a(x), y), passable?(b(x), y))
      (x, y:TOr) : or4(passable?(x, a(y)), passable?(x, b(y)))
      (x, y:TAnd) : and4(passable?(x, a(y)), passable?(x, b(y)))
      (x:TAnd, y) : or4(passable?(a(x), y), passable?(b(x), y))
      ;2. Unitary Types
      (x:TOf, y:TOf) :
         if n(x) == n(y) :
            subtype?(type(x), type(y))
         else :
            any?(passable?{_, y}, parents(x, n(y))) or
            any?(passable?{x, _}, parents(y, n(x)))
      ;1. Inherited Behavior
      (x:TVar|TTuple|TArrow, y:TVar|TTuple|TArrow) : subtype?(x, y)
      ;4. Gradual Type
      (x:TGradual, y:TGradual) : true
      (x:TGradual, y) : maybe
      (x, y:TGradual) : true
      ;6. Type Variables
      (x:TUVar, y:TUVar) : subtype?(x, y)
      (x:TUVar, y) : unknown
      (x, y:TUVar) : unknown
      ;7. Fall Through
      (x:TOf|TVar|TTuple|TArrow, y:TOf|TVar|TTuple|TArrow|TBot) : false

public defn partof? (x:Type, y:Type) -> True|False|Maybe|Unknown :
   defn passable-a1? (x:Type, y:Type) :
      match(x, y) :
         (x:TTuple, y:TTuple) :
            if length(types(x)) == length(types(y)) :
               all4?(passable?, types(x), types(y))
         (x:TTuple, y:TGradual) :
            maybe
   match(x, y) :
      ;2. Combinatory Types
      (x, y:TOr) : or4(partof?(x, a(y)), partof?(x, b(y)))
      (x, y:TAnd) : and4(partof?(x, a(y)), partof?(x, b(y)))
      ;1. Unitary Types
      (x:TArrow, y:TArrow) :
         and4(passable-a1?(a(y), a(x)), subtype?(b(x), b(y)))
      ;3. Gradual Type
      (x, y:TGradual) : partof?(x, expand-gradual(x))
      ;4. Type Variables
      (x:TUVar, y:TUVar) :
         if n(x) == n(y) : true
         else : unknown
      (x:TUVar, y) : unknown
      (x, y:TUVar) : unknown
      ;5. Fall through
      (x:TArrow|TNone, y:TOf|TTuple|TArrow|TVar|TBot) : false