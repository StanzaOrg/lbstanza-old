#use-added-syntax(earley-test-syntax)
defpackage test-earley :
  import core
  import collections

defsyntax mypackage :

  ;============================================================
  ;=================== Core Form Tags =========================
  ;============================================================
  public defkeywords stanza-keywords

  ;============================================================
  ;==================== Stanza Identifiers ====================
  ;============================================================
  
  public defproduction id
  defrule id = (?x) when unwrap-token(x) is Symbol :
    unwrap-token(x)
  defrule id != (#stanza-keywords)

  ;============================================================
  ;==================== Stanza Primitives =====================
  ;============================================================

  defproduction int
  defrule int = (?x) when unwrap-token(x) is Int :
    x

  defproduction string
  defrule string = (?x) when unwrap-token(x) is String :
    x

  defproduction literal
  defrule literal = (?x) when unwrap-token(x) is Char|Byte|Int|Long|String|True|False :
    x

  ;============================================================
  ;=================== Core Form Tags =========================
  ;============================================================

  val TAG-TABLE = to-hashset<Symbol> $ `(
    $package $import $prefix-of $prefix $public $protected $private $doc $deftype $defchild $def
    $defvar $defn $defn* $defmulti $defmethod $defmethod* $fn $fn*
    $multi $begin $let $match $branch $new $as $as? $set $do
    $prim $tuple $quote $none $of $and $or $->
    $cap $void $? $ls-new $ls-struct $ls-addr $ls-addr! $ls-deref
    $ls-slot $ls-field $ls-do $ls-call-c $ls-prim $ls-sizeof $ls-tagof $ls-as
    $ls-letexp $ls-and $ls-or $ls-set $ls-labels $ls-block $ls-goto $ls-return
    $ls-let $ls-if $ls-match $ls-branch $ls-func $ls-def $ls-defvar $ls-deftype $ls-deffield
    $ls-defn $ls-defn* $ls-defmethod $ls-defmethod* $ls-extern $ls-extern-fn $ls-byte $ls-int $ls-long $ls-float $ls-double
    $ls-? $ls-of $ls-ptr $ls-ref $ls-fn)

  defn core-form? (input) :
    val x = unwrap-token(input)
    if x is List :
      if not empty?(x) :
        match(unwrap-token(head(x))) :
          (s:Symbol) : TAG-TABLE[s]
          (s) : false

      
  public defproduction stanza-core-form  
  defrule stanza-core-form = (?x) when core-form?(x) : x

  public defkeywords stanza-tag
  defrule stanza-tag = ($package)
  defrule stanza-tag = ($import)
  defrule stanza-tag = ($prefix-of)
  defrule stanza-tag = ($prefix)
  defrule stanza-tag = ($public)
  defrule stanza-tag = ($protected)
  defrule stanza-tag = ($private)
  defrule stanza-tag = ($doc)
  defrule stanza-tag = ($deftype)
  defrule stanza-tag = ($defchild)
  defrule stanza-tag = ($def)
  defrule stanza-tag = ($defvar)
  defrule stanza-tag = ($defn)
  defrule stanza-tag = ($defn*)
  defrule stanza-tag = ($defmulti)
  defrule stanza-tag = ($defmethod)
  defrule stanza-tag = ($defmethod*)
  defrule stanza-tag = ($fn)
  defrule stanza-tag = ($fn*)
  defrule stanza-tag = ($multi)
  defrule stanza-tag = ($begin)
  defrule stanza-tag = ($let)
  defrule stanza-tag = ($match)
  defrule stanza-tag = ($branch)
  defrule stanza-tag = ($new)
  defrule stanza-tag = ($as)
  defrule stanza-tag = ($as?)
  defrule stanza-tag = ($set)
  defrule stanza-tag = ($do)
  defrule stanza-tag = ($prim)
  defrule stanza-tag = ($tuple)
  defrule stanza-tag = ($quote)
  defrule stanza-tag = ($none)
  defrule stanza-tag = ($of)
  defrule stanza-tag = ($and)
  defrule stanza-tag = ($or)
  defrule stanza-tag = ($->)
  defrule stanza-tag = ($cap)
  defrule stanza-tag = ($void)
  defrule stanza-tag = ($?)
  defrule stanza-tag = ($ls-new)
  defrule stanza-tag = ($ls-struct)
  defrule stanza-tag = ($ls-addr)
  defrule stanza-tag = ($ls-addr!)
  defrule stanza-tag = ($ls-deref)
  defrule stanza-tag = ($ls-slot)
  defrule stanza-tag = ($ls-field)
  defrule stanza-tag = ($ls-do)
  defrule stanza-tag = ($ls-call-c)
  defrule stanza-tag = ($ls-prim)
  defrule stanza-tag = ($ls-sizeof)
  defrule stanza-tag = ($ls-tagof)
  defrule stanza-tag = ($ls-as)
  defrule stanza-tag = ($ls-letexp)
  defrule stanza-tag = ($ls-and)
  defrule stanza-tag = ($ls-or)
  defrule stanza-tag = ($ls-set)
  defrule stanza-tag = ($ls-labels)
  defrule stanza-tag = ($ls-block)
  defrule stanza-tag = ($ls-goto)
  defrule stanza-tag = ($ls-return)
  defrule stanza-tag = ($ls-let)
  defrule stanza-tag = ($ls-if)
  defrule stanza-tag = ($ls-match)
  defrule stanza-tag = ($ls-branch)
  defrule stanza-tag = ($ls-func)
  defrule stanza-tag = ($ls-def)
  defrule stanza-tag = ($ls-defvar)
  defrule stanza-tag = ($ls-deftype)
  defrule stanza-tag = ($ls-deffield)
  defrule stanza-tag = ($ls-defn)
  defrule stanza-tag = ($ls-defn*)
  defrule stanza-tag = ($ls-defmethod)
  defrule stanza-tag = ($ls-defmethod*)
  defrule stanza-tag = ($ls-extern)
  defrule stanza-tag = ($ls-extern-fn)
  defrule stanza-tag = ($ls-byte)
  defrule stanza-tag = ($ls-int)
  defrule stanza-tag = ($ls-long)
  defrule stanza-tag = ($ls-float)
  defrule stanza-tag = ($ls-double)
  defrule stanza-tag = ($ls-?)
  defrule stanza-tag = ($ls-of)
  defrule stanza-tag = ($ls-ptr)
  defrule stanza-tag = ($ls-ref)
  defrule stanza-tag = ($ls-fn)
  defrule id != (#stanza-tag)

  public defkeywords lexer-tag
  defrule lexer-tag = (@do)
  defrule lexer-tag = (@do-afn)
  defrule lexer-tag = (@afn)
  defrule lexer-tag = (@get)
  defrule lexer-tag = (@tuple)
  defrule lexer-tag = (@of)
  defrule lexer-tag = (@cap)
  defrule lexer-tag = (@quote)
  defrule lexer-tag = (:)
  defrule id != (#lexer-tag)

  ;============================================================
  ;====================== Types ===============================
  ;============================================================

  public defproduction type

  defrule type = (?x:#stanza-core-form) : x
  defrule type = (?) : `($?)
  defrule type = (Void) : `($void)
  defrule type = (?x:#id) : x
  defrule type = ((~ @cap ?x:#id)) : qquote($cap ~ x)
  defrule type = ((?t:#type)) : t
  defrule type = ([?ts:#type ...]) : qquote($tuple ~@ ts)
  
  defrule type = (?x:#type -> ?y:#type) :
    qquote($-> (~ x) ~ y)
  with:
    associativity => right
    priority => 90

  defrule type = ((?xs:#type ...) -> ?y:#type) :
    qquote($-> ~ xs ~ y)
  with:
    associativity => right
    priority => 80

  defrule type = (?x:#type ~ | ?y:#type) :
    qquote($or ~ x ~ y)
  with:
    associativity => left
    priority => 70

  defrule type = (?x:#type & ?y:#type) :
    qquote($and ~ x ~ y)
  with:
    associativity => left
    priority => 60

  defrule type = (?x:#id<?ys:#type ...>) :
    qquote($of ~ x ~@ ys)
  with:
    priority => 50

  defrule stanza-keywords = (Void | ? | & | -> | ~ |)

  ;============================================================
  ;====================== Operators ===========================
  ;============================================================

  public defproduction exp

  defrule exp = (?x:#exp or ?y:#exp) :
    qquote($or ~ x ~ y)
  with :
    associativity => left
    priority => 90

  defrule exp = (?x:#exp and ?y:#exp) :
    qquote($and ~ x ~ y)
  with :
    associativity => left
    priority => 80

  defrule exp = (not ?x:#exp) :
    qquote($not ~ x)
  with :
    associativity => left
    priority => 70

  defproduction comparison-op
  defrule comparison-op = (==) : `$equal?
  defrule comparison-op = (!=) : `$not-equal?
  defrule comparison-op = (<) : `$less?
  defrule comparison-op = (>) : `$greater?
  defrule comparison-op = (<=) : `$less-eq?
  defrule comparison-op = (>=) : `$greater-eq?
  defrule stanza-keywords = (==)
  defrule stanza-keywords = (!=)
  defrule stanza-keywords = (<)
  defrule stanza-keywords = (>)
  defrule stanza-keywords = (<=)
  defrule stanza-keywords = (>=)  

  defrule exp = (?x:#exp ?op:#comparison-op ?y:#exp) :
    qquote(~ op ~ x ~ y)
  with :
    associativity => left
    priority => 60

  defproduction plus-op
  defrule plus-op = (+) : `$plus
  defrule plus-op = (-) : `$minus
  defrule plus-op = (~ |) : `$bit-or
  defrule stanza-keywords = (+)
  defrule stanza-keywords = (-)
  defrule stanza-keywords = (~ |)

  defrule exp = (?x:#exp ?op:#plus-op ?y:#exp) :
    qquote(~ op ~ x ~ y)
  with :
    associativity => left
    priority => 50

  defproduction times-op
  defrule times-op = (*) : `$times
  defrule times-op = (%) : `$modulo
  defrule times-op = (/) : `$divide
  defrule times-op = (&) : `$bit-and
  defrule times-op = (^) : `$bit-xor
  defrule stanza-keywords = (*)
  defrule stanza-keywords = (%)
  defrule stanza-keywords = (/)
  defrule stanza-keywords = (&)
  defrule stanza-keywords = (^)

  defrule exp = (?x:#exp ?op:#times-op ?y:#exp) :
    qquote(~ op ~ x ~ y)
  with :
    associativity => left
    priority => 40

  defproduction shift-op
  defrule shift-op = (<<) : `$shift-left
  defrule shift-op = (>>) : `$shift-right
  defrule shift-op = (>>>) : `$arithmetic-shift-right
  defrule stanza-keywords = (<<)
  defrule stanza-keywords = (>>)
  defrule stanza-keywords = (>>>)

  defrule exp = (?x:#exp ?op:#shift-op ?y:#exp) :
    qquote(~ op ~ x ~ y)
  with :
    associativity => left
    priority => 30

  defrule exp = (?x:#expterm) : x

  ;============================================================
  ;===================== Basic Terms ==========================
  ;============================================================

  defproduction expterm

  defrule expterm = (?x:#stanza-core-form) : x
  defrule expterm = (?x:#id) : x
  defrule expterm = (?x:#literal) : x

  defrule expterm = ((?e:#exp)) :
    e
    
  defrule expterm = ((?es:#exp ...)) :
    qquote($begin ~@ es)

  ;============================================================
  ;==================== Set/Get ===============================
  ;============================================================
  defrule exp = (?x:#expterm[?args:#exp ...] = ?v:#exp) :
    qquote($set ~ x ~ args ~ v)
  defrule stanza-keywords = (=)  
    
  defrule expterm = (?x:#expterm[?args:#exp ...]) :
    qquote($get ~ x ~ args)

  ;============================================================
  ;===================== Doc String ===========================
  ;============================================================

  defrule exp = (?e:#doc-string) : e

  defproduction doc-string
  defrule doc-string = (doc : ?x:#string) : qquote($doc ~ x)

  defproduction doc-string?
  defrule doc-string? = (?x:#doc-string) : One(x)
  defrule doc-string? = () : None()

  ;============================================================
  ;======================= Function Call ======================
  ;============================================================

  defrule expterm = (?x:#expterm(?ys:#exp ...)) :
    qquote($do ~ x ~@ ys)

  defrule expterm = (?x:#expterm<?ys:#type ...>) :
    qquote($of ~ x ~@ ys)

  defrule expterm = (?x:#expterm{?body ...}) :
    qquote($do-afn ~ x ~ body)

  ;============================================================
  ;===================== Anonymous Function ===================
  ;============================================================
  defrule expterm = ({?body:#exp ...}) :
    qquote($afn ~ body)

  ;============================================================
  ;====================== Quote ===============================
  ;============================================================
  defrule expterm = ((@quote ?rest ...)) :
    qquote($quote ~@ rest)

  ;============================================================
  ;====================== Casts ===============================
  ;============================================================
  defrule expterm = (?x:#expterm as? ?t:#type) :
    qquote($as? ~ x ~ t)

  defrule expterm = (?x:#expterm as ?t:#type) :
    qquote($as ~ x ~ t)

  defrule expterm = (?x:#expterm upcast-as ?t:#type) :
    qquote($upcast-as ~ x ~ t)

  defrule stanza-keywords = (as? | as | upcast-as)

  ;============================================================
  ;==================== Functions =============================
  ;============================================================

  defproduction binder
  defrule binder = (?x:#id) : x
  defrule binder = ([?xs:#binder ...]) : qquote($tuple ~@ xs)

  defproduction argbinding
  defrule argbinding = (?x:#binder : ?t:#type) : qquote($arg ~ x ~ t)
  defrule argbinding = (?x:#binder) : qquote($arg ~ x ($none))

  defproduction arglist
  defrule arglist = (?xs:(#argbinding ...)) : xs

  defproduction fnheader
  defrule fnheader = (?a1:#arglist -> ?a2:#type) : qquote($fnheader ~ a1 ~ a2)
  defrule fnheader = (?a1:#arglist) : qquote($fnheader ~ a1 ($none))

  defrule exp = (?tag:(fn | fn*) ?header:#fnheader : ?body:#exp) :
    val tag* = symbol-join(["$" tag])
    qquote(~ tag* ~ header ~ body)
  defrule stanza-keywords = (fn | fn*)  

  defproduction targ
  defrule targ = ((~ @cap ?x:#id)) : qquote($cap ~ x)
  defrule targ = (?x:#id) : x

  defproduction fnname
  defrule fnname = (?x:#id<?ts:#targ ...>) : qquote($of ~ x ~@ ts)
  defrule fnname = (?x:#id) : x

  defproduction defmethod
  defrule defmethod = (?tag:(defn | defn* | defmethod | defmethod*) ?name:#fnname ?header:#fnheader : ?body:#exp) :
    val tag* = symbol-join(["$" tag])
    qquote(~ tag* ~ name ~ header ~ body)
  defrule exp = (?x:#defmethod) : x
  defrule stanza-keywords = (defn | defn*)  

  defrule exp = (defmulti ?name:#fnname ?header:#fnheader) :
    qquote($defmulti ~ name ~ header)
  defrule stanza-keywords = (defmulti)  

  defrule exp = (?tag:(multifn | multifn*) :
                   (?headers:#fnheader : ?bodies:#exp) @...) :
    val tag* = symbol-join(["$" tag])               
    qquote(~ tag* ~ headers ~ bodies)
  defrule stanza-keywords = (multifn | multifn*)

  ;============================================================
  ;=================== Variables ==============================
  ;============================================================
  defrule exp = (var ?name:#binder : ?type:#type = ?value:#exp) :
    qquote($defvar ~ name ~ type ~ value)
  defrule exp = (var ?name:#binder : ?type:#type) :
    qquote($defvar ~ name ~ type ($none))
  defrule exp = (var ?name:#binder = ?value:#exp) :
    qquote($defvar ~ name ($none) ~ value)
  defrule exp = (var ?name:#binder) :
    qquote($defvar ~ name ($none) ($none))
  defrule stanza-keywords = (var)

  ;============================================================
  ;=================== Values =================================
  ;============================================================
  defrule exp = (val ?name:#binder : ?type:#type = ?value:#exp) :
    qquote($defval ~ name ~ type ~ value)
  defrule exp = (val ?name:#binder = ?value:#exp) :
    qquote($defval ~ name ($none) ~ value)
  defrule stanza-keywords = (val)

  ;============================================================
  ;================== Set Variable ============================
  ;============================================================
  defrule exp = (?x:#expterm = ?y:#exp) :
    qquote($set ~ x ~ y)

  ;============================================================
  ;===================== Visibility ===========================
  ;============================================================
  defrule exp = (?tag:(public | protected | private) (| :) ?body:#exp) :
    val tag* = symbol-join(["$" tag])
    qquote(~ tag* ~ body)
  defrule stanza-keywords = (public | protected | private)

  ;============================================================
  ;================== Conditional Visibility ==================
  ;============================================================
  defrule exp = (?tag:(public-when | protected-when | private-when)(?flag:#id) (| :) ?body:#exp) :
    qquote(~ tag ~ flag ~ body)
  defrule stanza-keywords = (public-when | protected-when | private-when)

  ;============================================================
  ;======================= New Objects ========================
  ;============================================================
  defrule exp = (new ?type:#type : (?methods:#defmethod ...)) :
    qquote($new ~ type ~@ methods)
  defrule exp = (new ?type:#type) :
    qquote($new ~ type)
  defrule stanza-keywords = (new)

  ;============================================================
  ;====================== Def Type ============================
  ;============================================================
  defproduction typename
  defrule typename = (?x:#id<?ts:#id ...>) : qquote($of ~ x ~@ ts)
  defrule typename = (?x:#id) : x

  defproduction defchild
  defrule defchild = (?a:#typename <: ?b:#type) : qquote($defchild ~ a ~ b)

  defrule exp = (deftype ?name:#typename (| <: ?type:#type) (| : (?children:#defchild ...))) :
    val parent* = `($none) when type is False else type
    val children* = `(($none)) when children is False else children
    qquote($deftype ~ name ~ parent* ~@ children*)
  defrule stanza-keywords = (deftype | <:)

  ;============================================================
  ;====================== Type Objects ========================
  ;============================================================
  defrule expterm = (TypeObject<?t:#type ...>()) :
    qquote($typeobject ~ t)
  with :
    priority => 110

  ;============================================================
  ;====================== Tuples ==============================
  ;============================================================
  defrule expterm = ([?es:#exp ...]) :
    qquote($tuple ~@ es)

  ;============================================================
  ;======================= Quick Match ========================
  ;============================================================
  defrule exp = (match((?xs:#exp : ?ts:#type) @...) : ?conseq:#exp
                   (| ?elsekeyword:else : ?alt:#exp)) :
    if elsekeyword is False :
      qquote($quickmatch ~ xs ~ ts ~ conseq)
    else :
      qquote($quickmatch ~ xs ~ ts ~ conseq ~ alt)
  defrule stanza-keywords = (match)

  ;============================================================
  ;========================== Match ===========================
  ;============================================================
  defrule exp = (match(?xs:#exp ...) :
                   (?argss:#arglist : ?bodies:#exp) @...) :
    qquote($match ~ xs ~ argss ~ bodies)

  ;============================================================
  ;=========================== If =============================
  ;============================================================
  defproduction if-exp
  defrule if-exp = (if ?pred:#exp : ?conseq:#exp else (: ?alt:#exp | ?alt:#if-exp)) :
    qquote($if ~ pred ~ conseq ~ alt)
  defrule if-exp = (if ?pred:#exp : ?conseq:#exp) :
    qquote($if ~ pred ~ conseq)
  defrule exp = (?e:#if-exp) : e
  defrule stanza-keywords = (if | else)

  ;============================================================
  ;========================== #For ============================
  ;============================================================
  defproduction for-binding
  defrule for-binding = (?x:#id in [?vs ...]) :
    qquote($forbinding ~ x ~ vs)
  defrule for-binding = (?x:#id in splice([?vs ...])) :    
    qquote($forbinding ~ x splice(~ vs))
    
  defproduction for-body
  defrule for-body = (~ #for ?binding:#for-binding : ?body) :
    qquote($#for (~ binding) ~ body)
  defrule for-body = (~ #for (?bindings:#for-binding ...) : ?body) :
    qquote($#for ~ bindings ~ body)
  defrule stanza-keywords = (~ #for)  

  ;============================================================
  ;========================== Let =============================
  ;============================================================
  defrule exp = (let : ?body:#exp) :
    qquote($let ~ body)
  defrule stanza-keywords = (let)

  ;============================================================
  ;========================== Where ===========================
  ;============================================================
  defrule exp = (?x:#expterm where : ?body:#exp) :
    qquote($where ~ x ~ body)
  defrule stanza-keywords = (where)

  ;============================================================
  ;========================= For ==============================
  ;============================================================
  defproduction in-binding
  defrule in-binding = (?x:#binder (| : ?t:#type) in ?y:#exp) :
    val t* = `($none) when t is False else t
    qquote($in-binding ~ x ~ t ~ y)

  defproduction in-bindings
  defrule in-bindings = (?e:#in-binding) : List(e)
  defrule in-bindings = (?es:(#in-bindings ...)) : es

  defrule exp = (for ?bindings:#in-bindings ?f:#exp : ?body:#exp) :
    qquote($for ~ bindings ~ f ~ body)
  defrule stanza-keywords = (for)
  
  ;============================================================
  ;======================== Within ============================
  ;============================================================
  defproduction binders
  defrule binders = (?x:#binder) : List(x)
  defrule binders = (?xs:(#binder ...)) : xs

  defrule exp = (within (| ?binders:#binders =) ?value:#exp : ?body:#exp) :
    val binders* = List() when binders is False else binders
    qquote($within ~ binders* ~ value ~ body)
  defrule stanza-keywords = (within)

  ;============================================================
  ;======================= While ==============================
  ;============================================================
  defrule exp = (while ?pred:#exp : ?body:#exp) :
    qquote($while ~ pred ~ body)
  defrule stanza-keywords = (while)

  ;============================================================
  ;======================= When ===============================
  ;============================================================
  defrule exp = (?e:#expterm when ?pred:#exp (| ?alt?:else ?alt:#exp)) :
    val alt* = List() when alt? is False else List(alt)
    qquote($when ~ e ~ pred ~@ alt*)
  defrule stanza-keywords = (when)

  ;============================================================
  ;======================= Filter-By ==========================
  ;============================================================
  defrule expterm = (filter-by<?t:#type>(?e:#exp)) :
    qquote($filter-by ~ t ~ e)
  with:
    priority => 110
  defrule stanza-keywords = (filter-by)

  ;============================================================
  ;======================= Find-By ============================
  ;============================================================
  defrule expterm = (find-by<?t:#type>(?e:#exp)) :
    qquote($find-by ~ t ~ e)
  with:
    priority => 110
  defrule stanza-keywords = (find-by)

  defrule expterm = (find-by!<?t:#type>(?e:#exp)) :
    qquote($find-by! ~ t ~ e)
  with:
    priority => 110
  defrule stanza-keywords = (find-by!)

  ;============================================================
  ;======================== To/Through ========================
  ;============================================================
  ;defrule exp = (?start:#expterm ?tag:(to | through) ?end:#exp (| ?step?:by ?step:#exp)) :
  ;  val step* = `($none) when step? is False else step
  ;  qquote($range ~ tag ~ start ~ end ~ step*)

  defrule exp = (?start:#expterm ?tag:(to | through) ?end:#exp) :
    qquote($range ~ tag ~ start ~ end ($none))

  defrule exp = (?start:#expterm ?tag:(to | through) ?end:#exp ?step?:by ?step:#exp) :
    qquote($range ~ tag ~ start ~ end ~ step)

  defrule stanza-keywords = (to | through | by)

  ;============================================================
  ;======================== Is/Is-Not =========================
  ;============================================================
  defrule exp = (?e:#expterm ?op:(is | is-not) ?t:#type) :
    qquote($is ~ op ~ e ~ t)
  defrule stanza-keywords = (is | is-not)

  ;============================================================  
  ;========================== Label ===========================
  ;============================================================
  defrule exp = (label<?t:#type> ?break:#id : ?body:#exp) :
    qquote($label ~ t ~ break ~ body)
  defrule exp = (label ?break:#id : ?body:#exp) :
    qquote($label ($none) ~ break ~ body)
  defrule stanza-keywords = (label)

  ;============================================================
  ;========================== Generate ========================
  ;============================================================
  defrule exp = (generate<?t:#type> : ?body:#exp) :
    qquote($generate ~ t ~ body)
  defrule exp = (generate : ?body:#exp) :
    qquote($generate ($none) ~ body)
  defrule stanza-keywords = (generate)

  ;============================================================
  ;========================= Switch ===========================
  ;============================================================
  defrule exp = (switch(?item:#exp) :
                   (?xs:#exp : ?bodies:#exp) @...
                   (| ?else?:else : ?alt:#exp)) :
    val alt* = `($none) when else? is False else alt
    qquote($switch ~ item ~ xs ~ bodies ~ alt*)

  defrule exp = (switch ?pred:#exp :
                   (?xs:#exp : ?bodies:#exp) @...
                   (| ?else?:else : ?alt:#exp)) :
    val alt* = `($none) when else? is False else alt
    qquote($switch-pred ~ pred ~ xs ~ bodies ~ alt*)

  ;============================================================
  ;========================= LetVar ===========================
  ;============================================================
  defrule exp = (let-var ?name:#id = ?e:#exp : ?body:#exp) :
    qquote($let-var ~ name ~ e ~ body)
  defrule stanza-keywords = (let-var)

  ;============================================================
  ;======================= Resource ===========================
  ;============================================================
  defrule exp = (resource ?name:#id : ?type:#type = ?value:#exp ?rest:#exp ...) :
    qquote($resource ~ name ~ type ~ value ~@ rest)
  defrule stanza-keywords = (resource)

  ;============================================================
  ;======================= Try ================================
  ;============================================================
  defproduction catch-clause
  defrule catch-clause = (catch ?args:#arglist : ?body:#exp) :
    qquote($catch ~ args ~ body)
  defrule exp = (try : ?body:#exp ?clauses:#catch-clause ... finally : ?final:#exp) :
    qquote($try ~ body ~@ clauses ~ final)
  defrule exp = (try : ?body:#exp ?clauses:#catch-clause ... ?cn:#catch-clause) :
    qquote($try ~ body ~@ clauses ~ cn)
  defrule stanza-keywords = (try | catch | finally)

  ;============================================================
  ;======================= Attempt ============================
  ;============================================================
  defproduction attempt-exp
  defrule attempt-exp = (attempt : ?conseq:#exp (else ?alt:#attempt-exp | else : ?alt:#exp)) :
    qquote($attempt ~ conseq ~ alt)
  defrule attempt-exp = (attempt : ?conseq:#exp) :
    qquote($attempt ~ conseq)
  defrule exp  = (?e:#attempt-exp) :
    e
  defrule stanza-keywords = (attempt)

  ;============================================================
  ;======================= DefPackage =========================
  ;============================================================
  defproduction prefix-clause
  defrule prefix-clause = (prefix => ?name:#id) :
    qquote($prefix ~ name)
  defrule prefix-clause = (prefix(?xs:#id ...) => ?name:#id) :
    qquote($prefix ~ xs ~ name)

  defproduction import-clause
  defrule import-clause = (import ?name:#id (| with : (?prefixes:#prefix-clause ...))) :
    if prefixes is False :
      qquote($import ~ name)
    else :
      qquote($import ~ name ~@ prefixes)

  defrule exp = (defpackage ?name:#id (| : (?imports:#import-clause ...))) :
    if imports is False :
      qquote($package ~ name)
    else :
      qquote($package ~ name ~@ imports)
  defrule stanza-keywords = (defpackage)

  ;============================================================    
  ;==================== DefStruct =============================
  ;============================================================
  defrule exp = (defstruct ?name:#id (| (@of ?tvars:#id ...)) (| <: ?parent:#type)
                 (| : (?fields:#struct-field ...))
                 (| with : (?options:#struct-option ...))) :
    val fields* = List() when fields is False else fields
    val options* = List() when options is False else options
    val tvars* = List() when tvars is False else tvars
    val parent* = `($none) when parent is False else parent
    qquote($defstruct ~ name ~@ tvars* ~ parent* ~@ fields* ~@ options*)
  defrule stanza-keywords = (defstruct)

  defproduction struct-field
  defrule struct-field = (?doc:#doc-string? ?name:#id (| : ?type:#type) (| with: (?options:#field-option ...))) :
    val type* = `($none) when type is False else type
    val options* = List() when options is False else options
    qquote($field ~ doc ~ name ~ type* ~@ options*)

  defproduction field-option
  defrule field-option = (as-method => ?v) :
    qquote($as-method ~ v)
  defrule field-option = (setter => ?v:#id) :
    qquote($setter ~ v)
  defrule field-option = (updater => ?v:#id) :
    qquote($updater ~ v)
  defrule field-option = (init => ?v:#id) :
    qquote($init ~ v)
  defrule field-option = (default => ?v:#exp) :
    qquote($default ~ v)
  defrule field-option = (ensure => ?v:#exp) :
    qquote($ensure ~ v)

  defproduction struct-option
  defrule struct-option = (constructor => ?v:#id) :
    qquote($constructor ~ v)
  defrule struct-option = (printer => ?v) :
    qquote($printer ~ v)

  ;============================================================
  ;===================== DefEnum ==============================
  ;============================================================
  defrule exp = (defenum ?name:#id (| <: ?parent:#type) : (?args:#id ...)) :
    qquote($defenum ~ name ~ parent ~ args)
  defrule stanza-keywords = (defenum)

  ;============================================================
  ;===================== Quasiquote ===========================
  ;============================================================
  defrule expterm = (qquote(?sexp ...)) :
    qquote($qquote ~@ sexp)
  defrule stanza-keywords = (qquote)
  

defn main () :
  ;val form = `(val x:[?T -> Int, (Int) -> Int&Int|String]|String = y
  ;             x == y and x > y and not x < y or not x > y)
  ;val form = `(x + x[w, y, z] = y + y[w, z])
  ;val form = `(
  ;  ;defn myfunction (x:Int<String>, y) -> String|Int :
  ;  ;  x + y
  ;  ;public defn* myfunction<T,?S> ([x [y, z]]:?T, y:T&T) :
  ;  ;  var x:Int|String
  ;  ;  val y:Int = x + y
  ;  ;private :
  ;  ;  val x = x + y[x]
  ;  ;  val y = multifn :
  ;  ;    (x:Int, y:String) : x + y
  ;  ;    (x, y:String -> String) : y(x)
  ;  ;defn f (x:Int) -> Table :
  ;  ;  new Table :
  ;  ;    defmethod update (this, x:Int) :
  ;  ;      f(x) + y
  ;  ;deftype MyParent<T>
  ;  ;deftype MyParent <: String :
  ;  ;  MyChild <: MyParent
  ;  ;deftype MyParent :
  ;  ;  MyChild <: MyParent
  ;  ;  MyChild <: MyParent
  ;  ;val x = [y, z, 3]
  ;  ;val y = TypeObject<Int|String>()
  ;  ;val z = TypeObject<Int|String>(3)
  ;  ;match(x) :
  ;  ;  (x:Int -> Int) :
  ;  ;    println(x)
  ;  ;match(x:Int) :
  ;  ;  println(x)
  ;  ;else :
  ;  ;  println(x)
  ;  ;if x < y :
  ;  ;  println(hi)
  ;  ;else if x > y :
  ;  ;  println(helloe)
  ;  ;else :
  ;  ;  x
  ;  ;for (x in y, [z, y, z] in [x y z]) do :
  ;  ;  println(x)
  ;  ;within (x, y, [z]) = f(x, y, z) :
  ;  ;  println(x)
  ;  ;within x = y :
  ;  ;  println(x)
  ;  ;within (x, y) = y :
  ;  ;  println(x)
  ;  ;within y :
  ;  ;  println(x)
  ;
  ;
  ;  try :
  ;    println(0)
  ;  catch (e:Exception) :
  ;    println(1)
  ;  catch (e:Exception) :
  ;    println(2)
  ;  finally :
  ;    return(2)
  ;
  ;  defpackage mysyntax :
  ;    import core
  ;    import collections with:
  ;      prefix(id, name) => pre-
  ;      prefix => pre-
  ;  defpackage mypackage
  ;
  ;  defstruct MyStruct
  ;  defstruct MyStruct<Int> <: Int<String> :
  ;    field
  ;    fieldb
  ;    fieldc
  ;  defstruct MyStruct<Int> <: Int<String> :
  ;    field:String
  ;    fieldb:String -> String with: (as-method => true)
  ;    fieldc:Int
  ;  with:
  ;    printer => true
  ;
  ;)
  ;;val form = `(($package x + x))
  
  val form = reader/read-file("compiler/stz-tree-list.stanza")
  do(println, parse-syntax[mypackage / #exp ...](form))               
;  match-syntax[mypackage](form) :
;    (?x:#exp) : println(x)

main()