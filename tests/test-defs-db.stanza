#use-added-syntax(tests)
defpackage stz/test-defs-db : 
  import core
  import collections
  import stz/defs-db
  import stz/defs-db-serializer

defn extract (db:DefinitionsDatabase, package-name:Symbol) -> Tuple<Definition> : 
  to-tuple $ 
    for kv in definitions(db) seq-cat : 
      for def in value(kv) filter : 
        pkg-name(def) == package-name

defn test-harness (defs-db:DefinitionsDatabase, package:String) : 
  val defs = extract(defs-db, to-symbol(package))
  #EXPECT(length(defs) != 0)
  val expected-items = [
    "function" => SrcDefFunction
    "multi"    => SrcDefMulti
    "Type"     => SrcDefType
    ; TODO : 
    ; SrcDefVariable
    ; SrcDefMethod
    ; SrcDefPackage
    ; SrcDefUnknown
  ]
  for expected in expected-items do : 
    val sym = to-symbol $ "%_-%_" % [package, key(expected)]
    val found? = find({name(_) == sym}, defs)
    #EXPECT(found? is-not False)
    match(found?:Definition):
      #EXPECT(kind(found?) == value(expected))

defn compile-db (input-files:Tuple<String>) : 
  val filename = "test-defs.db"
  val input = DefsDbInput(["tests/defs-db-data/stanza.proj"], false, [], false)
  defs-db(input, "test-defs.db")
  val istream = FileInputStream(filename)
  val defs-db = deserialize-definitions-database(istream)
  close(istream)
  defs-db

deftest(defsdb) single-proj-file : 
  val db = compile-db(["tests/defs-db-data/stanza.proj"])
  for package in ["package1", "package2"] do : 
    test-harness(db, package)

deftest(defsdb) single-source-file : 
  val db = compile-db(["tests/defs-db-data/package1.stanza"])
  test-harness(db, "package1")

deftest(defsdb) multi-source-files : 
  val db = compile-db(["tests/defs-db-data/package1.stanza", "tests/defs-db-data/package2.stanza"])
  for package in ["package1", "package2"] do : 
    test-harness(db, package)

deftest(defsdb) mixed-proj-and-source-files : 
  val db = compile-db(["tests/defs-db-data/stanza.proj", "tests/defs-db-data/package2.stanza"])
  for package in ["package1", "package2"] do : 
    test-harness(db, package)
