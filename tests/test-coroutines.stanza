#use-added-syntax(tests)
defpackage stz/test-coroutines :
  import core
  import collections

;Let-var needs to restore current value of variable.
deftest coroutine-01 :
  var x:String = "Default X"

  val gen = generate<String> :
    let-var x = "Generator X" :
      #ASSERT(x == "Generator X")
      yield("Hello")
      #ASSERT(x == "Generator X")
      yield("My")
      #ASSERT(x == "Generator X")
      yield("World")

  #ASSERT(x == "Default X")
  #ASSERT(next(gen) == "Hello")
  #ASSERT(x == "Default X")
  x = "Changed X"
  #ASSERT(x == "Changed X")
  #ASSERT(next(gen) == "My")
  #ASSERT(x == "Changed X")
  #ASSERT(next(gen) == "World")
  #ASSERT(x == "Changed X")

;Finally needs to execute.
deftest coroutine-02 :
  val out = Vector<String>()
  
  val co = Coroutine<False,Int> $ fn (co, x0) :
    try :
      try :
        try :
          suspend(co, 0)
          suspend(co, 1)
          suspend(co, 2)
          3
        finally :
          add(out, "A")
      finally :
        add(out, "B")
    finally :
      add(out, "C")
    
  #ASSERT(empty?(out))
  #ASSERT(resume(co,false) == 0)
  #ASSERT(empty?(out))
  #ASSERT(resume(co,false) == 1)
  #ASSERT(empty?(out))
  #ASSERT(resume(co,false) == 2)
  #ASSERT(empty?(out))
  #ASSERT(resume(co,false) == 3)
  #ASSERT(to-tuple(out) == ["A" "B" "C"] )

;Finally needs to execute.
deftest coroutine-03 :
  val out = Vector<String>()
  
  val co = Coroutine<False,Int> $ fn (co, x0) :
    try :
      try :
        try :
          suspend(co, 0)
          suspend(co, 1)
          suspend(co, 2)
          3
        finally :
          add(out, "A")
      finally :
        add(out, "B")
    finally :
      add(out, "C")
    
  #ASSERT(empty?(out))
  #ASSERT(resume(co,false) == 0)
  #ASSERT(empty?(out))
  #ASSERT(resume(co,false) == 1)
  #ASSERT(empty?(out))
  close(co)
  #ASSERT(to-tuple(out) == ["A" "B" "C"] )

;Finally needs to execute.
deftest coroutine-04 :
  val out = Vector<String>()
  
  val co = Coroutine<False,Int> $ fn (co, x0) :
    try :
      try :
        try :
          suspend(co, 0)
          suspend(co, 1)
          suspend(co, 2)
          3
        finally :
          add(out, "A")
          throw(Exception("Exception in Finally"))
      finally :
        add(out, "B")
    finally :
      add(out, "C")
    
  #ASSERT(empty?(out))
  #ASSERT(resume(co,false) == 0)
  #ASSERT(empty?(out))
  #ASSERT(resume(co,false) == 1)
  #ASSERT(empty?(out))
  try :
    close(co)
  catch (e) :
    false
  #ASSERT(to-tuple(out) == ["A" "B" "C"] )

deftest coroutine-05 :

  defn wrap (body:() -> ?, name:String, exit?:True|False) :
    dynamic-wind(
      fn () :
        println("%_-enter" % [name])
      body
      fn () :
        println("%_-exit" % [name])
        if exit? :
          println("EXITING OUT %_-exit" % [name])
          throw(Exception("EXIT")))

  val gen = generate<String> :
    try :
      yield("Hello")
      yield("This")
      yield("Is")
      yield("Dog")      
    catch (e) :
      false

  try :
    #ASSERT(next(gen) == "Hello")
  catch (e) :
    false

  try :
    within wrap("D", true) :
      #ASSERT(next(gen) == "This")
  catch (e) :
    false

  #ASSERT(next(gen) == "Is")
  #ASSERT(next(gen) == "Dog")

deftest coroutine-06 :
  defn func () :
    try :
      try :
        throw(Exception("Exception A"))
      finally :
        throw(Exception("Exception B"))
    catch (e) :
      #ASSERT(to-string(e) == "Exception B")
      throw(Exception("Exception C: %_" % [e]))

  try :
    func()
  catch (e) :
    #ASSERT(to-string(e) == "Exception C: Exception B")
  
deftest coroutine-07 :
  var x:String = "Default X"

  val gen = generate<String> :
    let-var x = "Generator X" :
      yield(x)
    yield(x)
    let-var x = "Generator X" :
      yield(x)

  #ASSERT(x == "Default X")
  #ASSERT(next(gen) == "Generator X")
  #ASSERT(x == "Default X")
  #ASSERT(next(gen) == "Default X")
  #ASSERT(x == "Default X")
  #ASSERT(next(gen) == "Generator X")
  #ASSERT(x == "Default X")