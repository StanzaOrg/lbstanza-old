defpackage stz-test-suite/type-reader :
  import core
  import collections
  import stz/types
  import stz/printing-utils

;============================================================
;=================== Entry Point ============================
;============================================================

public defn read-test-type-program (filename:String) -> TestTypeProgram :
  val forms = reader/read-file(filename)
  parse-syntax[type-syntax / #type-program](forms)

;============================================================
;==================== Type Test Program =====================
;============================================================

defstruct TestTypeProgram :
  hierarchy: Tuple<TRelation>
  stmts:Tuple<TypeStmt>

;============================================================
;================ Structures for Parsing ====================
;============================================================

defstruct TNamedOf <: Type :
  name:Symbol
  args:Tuple<Type>

defstruct TRelation :
  child:Type
  parent:Type|False

deftype TypeStmt

defstruct Capture <: TypeStmt :
  args:Tuple<Symbol|Int>
  a:Type
  b:Type

defstruct Subtype <: TypeStmt :
  a:Type
  b:Type

;============================================================
;======================= Printing ===========================
;============================================================

defmethod print (o:OutputStream, p:TestTypeProgram) :
  val items = cat(hierarchy(p), stmts(p))
  print(o, "TestTypeProgram%_" % [colon-field-list(items)])

defmethod print (o:OutputStream, s:TRelation) :
  val parent-str = "" when parent(s) is False
              else " <: %_" % [parent(s)]
  print(o, "deftype %_%_" % [child(s), parent-str])

defmethod print (o:OutputStream, s:Capture) :
  print(o, "capture(%,) %_ <: %_" % [args(s), a(s), b(s)])

defmethod print (o:OutputStream, s:Subtype) :
  print(o, "subtype %_ <: %_" % [a(s), b(s)])

;============================================================
;===================== Type Syntax ==========================
;============================================================

defsyntax type-syntax :

  ;----------------------------------------------------------
  ;---------------------- Type Program ----------------------
  ;----------------------------------------------------------
  public defproduction type-program: TestTypeProgram
  
  defrule type-program = (?relations:#type-rel ...
                          ?stmts:#type-stmt! ...) :
    val prog = TestTypeProgram(to-tuple(relations), to-tuple(stmts))
    prog

  ;----------------------------------------------------------
  ;---------------------- Type Relations --------------------
  ;----------------------------------------------------------
  defproduction type-rel:TRelation
  
  defrule type-rel = (deftype ?c:#type <: ?p:#type) :
    ensure-child-type(closest-info(), c)
    ensure-parent-type(closest-info(), p)
    TRelation(c, p)
    
  defrule type-rel = (deftype ?c:#type) :
    ensure-child-type(closest-info(), c)
    TRelation(c, false)

  defn ensure-child-type (info:FileInfo|False, t:Type) :
    match(t) :
      (t:TVar) :
        false
      (t:TNamedOf) :
        if all?({_ is TVar}, args(t)) :
          throw(TSE(info, "Type %_ cannot be used as child specifier." % [t]))
      (t) :
        throw(TSE(info, "Type %_ cannot be used as child specifier." % [t]))

  defn ensure-parent-type (info:FileInfo|False, t:Type) :
    match(t) :
      (t:TNamedOf) :
        false
      (t:TAnd) :
        ensure-parent-type(info, a(t))
        ensure-parent-type(info, b(t))
      (t:TVar) :
        false
      (t) :
        throw(TSE(info, "Type %_ cannot be used as parent specifier." % [t]))

  ;----------------------------------------------------------
  ;---------------------- Test Statement --------------------
  ;----------------------------------------------------------
  defproduction type-stmt: TypeStmt
  
  defrule type-stmt = (capture(?args:#id ...) ?x:#type! <: ?y:#type!) :
    Capture(to-tuple(args), x, y)

  defrule type-stmt = (subtype ?x:#type! <: ?y:#type!) :
    Subtype(x,y)

  ;----------------------------------------------------------
  ;-------------------- Type Productions --------------------
  ;----------------------------------------------------------

  defproduction type: Type
  defproduction type0: Type
  defproduction type1: Type

  defrule type = (?x:#type0 -> ?y:#type!) : TArrow([x], y)
  defrule type = (() -> ?y:#type!) : TArrow([], y)
  defrule type = ((?x0:#type ?xs:#types!) -> ?y:#type!) : TArrow(to-tuple(cons(x0,xs)), y)
  defrule type = (?x:#type0)

  defrule type0 = (?x:#type0 & ?y:#type1!) : TAnd(x,y)
  defrule type0 = (?x:#type0 ~ | ?y:#type1!) : TOr(x,y)
  defrule type0 = (?x:#type1)

  defrule type1 = ((~ @cap ?x:#id)) : TCap(0,x)
  defrule type1 = ([?xs:#types!]) : TTuple(to-tuple(xs))
  defrule type1 = ((?x:#type))
  defrule type1 = (?x:#id<?ys:#types!>) : TNamedOf(x,to-tuple(ys))
  defrule type1 = (Void) : TBot()
  defrule type1 = (?) : TGradual()
  defrule type1 = (?x:#id) : TVar(0,x)

  ;----------------------------------------------------------
  ;----------------------- Errors ---------------------------
  ;----------------------------------------------------------

  defproduction type!: Type
  defproduction type1!: Type
  defproduction type$: Type
  defproduction types!: List<Type>
  defproduction type-stmt!: TypeStmt
  defrule type! = (?x:#type)
  fail-if type! = () : TSE(closest-info(), "Type expected here.")
  defrule type1! = (?x:#type1)
  fail-if type1! = () : TSE(closest-info(), "Type expected here.")
  defrule type$ = (?x:#type! (! _))
  fail-if type$ = () : TSE(closest-info(), "Expected a single type here.")      
  defrule types! = (?x:#type! ...)
  defrule type-stmt! = (?x:#type-stmt)
  fail-if type-stmt! = () : TSE(closest-info(), "Invalid syntax for type testing statement.")

  ;----------------------------------------------------------
  ;----------------------- Primitives -----------------------
  ;----------------------------------------------------------

  defproduction id:Symbol
  defrule id = (?x) when unwrap-token(x) is Symbol :
    unwrap-token(x)

;============================================================
;====================== Error Definitions ===================
;============================================================

defstruct TypeSyntaxError <: Exception :
  info:FileInfo|False
  message
with:
  constructor => TSE

defmethod print (o:OutputStream, e:TypeSyntaxError) :
  print(o, "%_%_" % [info-str(info(e)), message(e)])

defn info-str (i:FileInfo|False) :
  "" when i is False else "%_: " % [i]