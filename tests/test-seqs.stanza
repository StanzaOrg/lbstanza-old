defpackage stz/test-seqs :
  import core
  import collections
  
defn same? (name:String, a:Equalable, b:Equalable) :
  ; println("  %_: %_ =? %_" % [name, a, b])
  if a != b :
    println("  %_: %_ != %_" % [name, a, b])

defstruct Check :
  name: String
  run: String -> True|False

defstruct Test :
  name: String
  init: Test -> ?
  checks: Vector<Check> with: (init => Vector<Check>())

val tests = Vector<Test>()

defn install-test (test:Test) :
  init(test)(test)
  add(tests, test)

install-test $ Test("TUPLE", fn (test:Test) :
  val i = [1, 2, 3]
  val r = to-tuple $ to-seq $ i
  add(checks(test), Check("E", same?{_, r, i}))
  )

install-test $ Test("LIST", fn (test:Test) :
  val i = [1, 2, 3]
  val r = to-tuple $ to-seq $ to-list $ i
  add(checks(test), Check("E", same?{_, r, i}))
  )

install-test $ Test("RANGE", fn (test:Test) :
  val i = 0 to 3
  val o = [0, 1, 2]
  val r = to-tuple $ i
  add(checks(test), Check("E", same?{_, r, o}))
  )

install-test $ Test("VECTOR", fn (test:Test) :
  val i = Vector<Int>()
  add(i, 0)
  add(i, 1)
  add(i, 2)
  val o = [0, 1, 2]
  val r = to-tuple $ i
  add(checks(test), Check("E", same?{_, r, o}))
  )

install-test $ Test("SEQ-1", fn (test:Test) :
  val xs = seq({ _ + 1 }, [1, 2, 3])
  add(checks(test), Check("A", same?{_, next(xs), 2}))
  add(checks(test), Check("B", same?{_, next(xs), 3}))
  add(checks(test), Check("C", same?{_, next(xs), 4}))
  add(checks(test), Check("D", same?{_, empty?(xs), true}))
  )

install-test $ Test("SEQ-2", fn (test:Test) :
  val xs = seq(plus, [1, 2, 3], [2, 3, 4])
  add(checks(test), Check("A", same?{_, next(xs), 3}))
  add(checks(test), Check("B", same?{_, next(xs), 5}))
  add(checks(test), Check("C", same?{_, next(xs), 7}))
  add(checks(test), Check("D", same?{_, empty?(xs), true}))
  )

install-test $ Test("SEQ-3", fn (test:Test) :
  val xs = seq(fn (a, b, c): a + b + c, [1, 2, 3], [2, 3, 4], [3, 4, 5])
  add(checks(test), Check("A", same?{_, next(xs), 6}))
  add(checks(test), Check("B", same?{_, next(xs), 9}))
  add(checks(test), Check("C", same?{_, next(xs), 12}))
  add(checks(test), Check("D", same?{_, empty?(xs), true}))
  )

install-test $ Test("SEQ-TO-TUPLE", fn (test:Test) :
  val xs = seq({ _ + 1 }, [1, 2, 3])
  add(checks(test), Check("A", same?{_, to-tuple(xs), [2, 3, 4]}))
  add(checks(test), Check("B", same?{_, empty?(xs), true}))
  )

install-test $ Test("PEEK-SEQ-1", fn (test:Test) :
  val i = [1, 2, 3]
  val xs = to-peek-seq $ i
  add(checks(test), Check("A", same?{_, peek(xs), 1}))
  add(checks(test), Check("B", same?{_, next(xs), 1}))
  add(checks(test), Check("C", same?{_, next(xs), 2}))
  add(checks(test), Check("D", same?{_, next(xs), 3}))
  add(checks(test), Check("D", same?{_, empty?(xs), true}))
  )

install-test $ Test("TAKE-WHILE", fn (test:Test) :
  val i = [1, 2, 3]
  val xs = to-peek-seq $ i
  val os = take-while({ _ < 3 }, xs)
  add(checks(test), Check("A", same?{_, to-tuple(os), [1, 2]}))
  add(checks(test), Check("B", same?{_, to-tuple(xs), [3]}))
  )

install-test $ Test("TAKE-UNTIL", fn (test:Test) :
  val i = [1, 2, 3]
  val xs = to-peek-seq $ i
  val os = take-until({ _ > 2 }, xs)
  add(checks(test), Check("A", same?{_, to-tuple(os), [1, 2]}))
  add(checks(test), Check("B", same?{_, to-tuple(xs), [3]}))
  )

install-test $ Test("TAKE-N", fn (test:Test) :
  val i = [1, 2, 3]
  val xs = (to-seq $ i) as Seq<Int>&Lengthable
  val os = take-n(2, xs)
  add(checks(test), Check("A", same?{_, to-tuple(os), [1, 2]}))
  add(checks(test), Check("B", same?{_, to-tuple(xs), [3]}))
  )

install-test $ Test("TAKE-UP-TO-N", fn (test:Test) :
  val i = [1, 2, 3]
  val xs = to-seq $ i
  val os = take-up-to-n(2, xs)
  add(checks(test), Check("A", same?{_, to-tuple(os), [1, 2]}))
  add(checks(test), Check("B", same?{_, to-tuple(xs), [3]}))
  )

install-test $ Test("CAT", fn (test:Test) :
  val a = [1, 2, 3]
  val b = [4, 5, 6]
  val r = [1, 2, 3, 4, 5, 6]
  val os = cat(a, b)
  add(checks(test), Check("A", same?{_, to-tuple(os), r}))
  )

install-test $ Test("CAT-ALL", fn (test:Test) :
  val a1 = [1, 2, 3]
  val b1 = [4, 5, 6]
  val c1 = [7, 8, 9]
  val r1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
  val os1 = cat-all $ [a1, b1, c1]
  add(checks(test), Check("A", same?{_, to-tuple(os1), r1}))
  val a2 = [1, 2, 3]
  val b2 = []
  val c2 = [4, 5, 6]
  val r2 = [1, 2, 3, 4, 5, 6]
  val os2 = cat-all $ [a2, b2, c2]
  add(checks(test), Check("B", same?{_, to-tuple(os2), r2}))
  val a3 = []
  val b3 = []
  val c3 = [1, 2, 3]
  val r3 = [1, 2, 3]
  val os3 = cat-all $ [a3, b3, c3]
  add(checks(test), Check("C", same?{_, to-tuple(os3), r3}))
  val a4 = []
  val b4 = []
  val c4 = []
  val r4 = []
  val os4 = cat-all $ [a4, b4, c4]
  add(checks(test), Check("D", same?{_, to-tuple(os4), r4}))
  )

install-test $ Test("JOIN", fn (test:Test) :
  val a = [1, 2, 3]
  val r = [1, 0, 2, 0, 3]
  val os = join(a, 0)
  add(checks(test), Check("A", same?{_, to-tuple(os), r}))
  )

install-test $ Test("INTERLEAVE", fn (test:Test) :
  val a1 = [1, 2, 3]
  val b1 = [4, 5, 6]
  val r1 = [1, 4, 2, 5, 3, 6]
  val os1 = interleave(a1, b1)
  add(checks(test), Check("A", same?{_, to-tuple(os1), r1}))
  val a2 = [1, 2, 3]
  val b2 = [4, 5]
  val r2 = [1, 4, 2, 5]
  val os2 = interleave(a2, b2)
  add(checks(test), Check("B", same?{_, to-tuple(os2), r2}))
  )

install-test $ Test("REPEAT", fn (test:Test) :
  val r = [1, 1, 1]
  val os = repeat(1, 3)
  add(checks(test), Check("A", same?{_, to-tuple(os), r}))
  )

defn run-all-tests () :
  for test in tests do :
    println("RUNNING %_ TEST" % [name(test)])
    for check in checks(test) do :
      ; println("  RUNNING %_ CHECK" % [name(check)])
      run(check)(name(check))

run-all-tests()
