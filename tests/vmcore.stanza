;################################################################################
;############################## C Library #######################################
;################################################################################

;================================================================================
;================================ Boot Sequence =================================
;================================================================================

defpackage clib

protected extern memcpy: (ptr<?>, ptr<?>, long) -> int
protected extern remove: (ptr<byte>) -> int
protected extern ftell: (ptr<?>) -> long
protected extern fclose: (ptr<?>) -> int
protected extern fflush: (ptr<?>) -> int
protected extern fopen: (ptr<byte>, ptr<byte>) -> ptr<?>
protected extern fputs: (ptr<byte>, ptr<?>) -> int
protected extern fputc: (byte, ptr<?>) -> int
protected extern fgetc: (ptr<?>) -> int
protected extern ferror: (ptr<?>) -> int
protected extern fprintf: (ptr<?>, ptr<byte>, ? ...) -> int
protected extern sprintf: (ptr<byte>, ptr<byte>, ? ...) -> int
protected extern sscanf: (ptr<byte>, ptr<byte>, ptr<?> ...) -> int
protected extern printf: (ptr<byte>, ? ...) -> int
protected extern malloc: long -> ptr<?>
protected extern free: ptr<?> -> int
protected extern exit: int -> int
protected extern get_stdout: () -> ptr<?>
protected extern get_stderr: () -> ptr<?>
protected extern get_stdin: () -> ptr<?>
protected extern get_eof: () -> int
protected extern input_argc: int
protected extern input_argv: ptr<ptr<byte>>
protected extern strlen: ptr<byte> -> int
protected extern current_time_us: () -> long
protected extern current_time_ms: () -> long
protected extern getenv: (ptr<byte>) -> ptr<byte>
protected extern setenv: (ptr<byte>, ptr<byte>, int) -> int
protected extern unsetenv: (ptr<byte>) -> int
protected extern system: (ptr<byte>) -> int
protected extern strerror: (int) -> ptr<byte>
protected extern get_errno: () -> int
protected extern resolve_path: (ptr<byte>) -> ptr<byte>
protected extern get_file_size: ptr<?> -> long
protected extern file_set_length: (ptr<?>, long) -> int
protected extern file_seek: (ptr<?>, long) -> int
protected extern file_skip: (ptr<?>, long) -> int
protected extern file_read_block: (ptr<?>, ptr<byte>, long) -> long
protected extern file_write_block: (ptr<?>, ptr<byte>, long) -> long
protected extern file_time_modified: ptr<byte> -> long

;Process libraries
protected extern launch_process: (ptr<byte>, ptr<ptr<byte>>, int, int, int, ptr<?>) -> int
protected extern retrieve_process_state: (long, ptr<?>) -> int
protected extern initialize_launcher_process: () -> int

;Math libraries
protected extern exp: double -> double
protected extern log: double -> double
protected extern log10: double -> double
protected extern sqrt: double -> double
protected extern pow: (double, double) -> double
protected extern sin: double -> double
protected extern cos: double -> double
protected extern tan: double -> double
protected extern asin: double -> double
protected extern acos: double -> double
protected extern atan: double -> double
protected extern atan2: (double, double) -> double
protected extern sinh: double -> double
protected extern cosh: double -> double
protected extern tanh: double -> double
protected extern ceil: double -> double
protected extern floor: double -> double
protected extern round: double -> double

;################################################################################
;############################## Core Library ####################################
;################################################################################

;================================================================================
;=============================== Boot Sequence ==================================
;================================================================================

defpackage core :
  import collections

;============================================================
;===================== Internal Types =======================
;============================================================

protected lostanza deftype Fn :
   length: long
   code: ptr<?>
   free: ref<?> ...
protected lostanza deftype Box :
   item: ref<?>
protected lostanza deftype Type :
   length: long
   code: ptr<?>
   free: ref<?> ...
protected lostanza deftype StackFrame :
  return: long
  liveness-map: long
  slots: long ...
protected lostanza deftype Stack :
  size: long
  frames: ptr<StackFrame>
  stack-pointer: ptr<StackFrame>
  pc: int
protected lostanza deftype VMState :
  ;Permanent State
  ;Changes in-between each code load
  instructions: ptr<byte>
  registers: ptr<long>
  global-offsets: ptr<long>
  global-mem: ptr<byte>
  const-table: ptr<long>
  const-mem: ptr<byte>
  data-offsets: ptr<int>
  data-mem: ptr<byte>
  extern-addresses: ptr<long>
  extern-defn-addresses: ptr<long>
  code-offsets: ptr<int>
  extend-heap-id: int
  extend-stack-id: int
  ;Variable State
  ;Changes in-between each boundary change
  heap: ptr<long>      
  heap-top: ptr<long>  
  heap-limit: ptr<long>
  free: ptr<long>      
  free-limit: ptr<long>
  current-stack: long
  ;Need for system stubs
  system-stack: long
  system-registers: ptr<long>  
  

;============================================================
;================== Internal Callbacks ======================
;============================================================

protected lostanza defn arity-error (arity:long) -> ref<Void> :
  return fatal(arity-message(new Int{arity as int}))
defn arity-message (arity:Int) :
  "Function cannot be called with %_ arguments." % [arity]

protected defn no-method-error (multi:String, args:Tuple) :
  fatal("Multi %_ has no appropriate method for arguments of type (%,)." % [multi, seq(object-type,args)])
  
protected defn amb-method-error (multi:String, args:Tuple) :
  fatal("Multi %_ has multiple appropriate methods for arguments of type (%,)." % [multi, seq(object-type,args)])
   
protected defn no-branch-error (args:Tuple) :  
  fatal("No appropriate branch for arguments of type (%,)." % [seq(object-type, args)])
  
protected defn amb-branch-error (args:Tuple) :
  fatal("Multiple appropriate branches for arguments of type (%,)." % [seq(object-type, args)])

protected lostanza defn tuple-length-error (actual-len:long, expected-len:long) -> ref<Void> :
  return fatal(tuple-length-message(new Int{actual-len as int}, new Int{expected-len as int}))
defn tuple-length-message (actual-len:Int, expected-len:Int) :
  "Cannot destructure tuple of length %_ into %_ items." % [actual-len, expected-len]
  
protected defn variable-uninitialized-error (name:String|False) -> Void :
  match(name) :
    (name:String) : fatal("Variable %_ has not been initialized." % [name])
    (name:False) : fatal("Variable has not been initialized.")

protected lostanza defn cast-error (type:ref<Type>, obj:ref<?>, ctxt:int) -> ref<Void> :
  return fatal(cast-message(type, obj, new Int{ctxt}))

protected lostanza defn invalid-return-error () -> ref<Void> :
  return fatal("Unexpected return from function declared with Void return type.")

defn cast-message (t:Type, x, ctxt:Int) :
  val objt = object-type(x)
  switch(ctxt) :
    0 : "Cannot cast value of type %_ to type %_." % [objt, t]
    1 : "Argument was expected to be of type %_, but was passed a value of type %_." % [
          t, objt]
    2 : "The expected return type of this function is %_, but a value of type %_ was returned." % [
          t, objt]
    3 : "Cannot initialize a variable of type %_ with a value of type %_." % [t, objt]
    4 : "Cannot assign a value of type %_ to a variable with declared type %_." % [objt, t]
    5 : "Cannot call a value of type %_ as if it were a function." % [objt]
    6 : "Cannot deconstruct a value of type %_ into a tuple." % [objt]
    7 : "The variable was expected to have type %_, but we retrieved a value of type %_ from it." % [
          t, objt]
    8 : "Branch argument was expected to be of type %_, but was passed a value of type %_." % [
          t, objt]

;============================================================
;=================== Fatal Errors ===========================
;============================================================

public lostanza defn fatal (msg:ptr<byte>) -> ref<Void> :
  call-c clib/fprintf(stderr, "FATAL ERROR: %s\n", msg)
  print-stack-trace()
  return halt()

public defn fatal (msg) -> Void :
  print(STANDARD-ERROR-STREAM, "FATAL ERROR: ")
  println(STANDARD-ERROR-STREAM, msg)
  print-stack-trace()
  halt()

lostanza defn print-stack-trace () -> ref<False> :
  call-prim flush-vm()
  labels :
    begin :      
      goto loop(current-coroutine)
    loop (co:ref<RawCoroutine>) :
      call-prim print-stack-trace(co.stack)
      match(co.parent) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : ()
  return false

var EXECUTION-HALT:() -> Void
  
defn halt () -> Void :
  EXECUTION-HALT()

defn initialize-launcher () :
  EXECUTION-HALT = fn () : exit(-1)

defn execute-toplevel-command (f:() -> False) :
  label break :
    let-var EXECUTION-HALT = break :
      f()

;============================================================
;======================= Core Types =========================
;============================================================

public lostanza deftype Byte :
  value: byte
  
public lostanza deftype Char :
  value: byte

public lostanza deftype Int :
  value: int

public lostanza deftype Long :
  value: long

public lostanza deftype Float :
  value: float

public lostanza deftype Double :
  value: double

public lostanza deftype String :
  length: long
  hash: int
  chars: byte ...

public deftype Symbol
public lostanza deftype StringSymbol <: Symbol :
  name: ref<String>
public deftype GenSymbol <: Symbol

public lostanza deftype True
public lostanza deftype False

public lostanza deftype Tuple<T> :
  length: long
  items: ref<T> ...

public deftype List<T>
lostanza deftype FullList<T> <: List<T> :
  head: ref<T>
  tail: ref<List<T>>
lostanza deftype NilList <: List<Void>

public deftype Coroutine<I,O>

;============================================================
;============== Standard Streams ============================
;============================================================

lostanza val stdout:ptr<?> = call-c clib/get_stdout()
lostanza val stderr:ptr<?> = call-c clib/get_stderr()
lostanza val stdin:ptr<?> = call-c clib/get_stdin()
lostanza val EOF:int = call-c clib/get_eof()

;============================================================
;================ Constant Initialization ===================
;============================================================

lostanza var const-ptr:ptr<?>
lostanza val BYTE-CONST-TAG : int = 0
lostanza val CHAR-CONST-TAG : int = 1
lostanza val INT-CONST-TAG : int = 2
lostanza val LONG-CONST-TAG : int = 3
lostanza val FLOAT-CONST-TAG : int = 4
lostanza val DOUBLE-CONST-TAG : int = 5
lostanza val TRUE-CONST-TAG : int = 6
lostanza val FALSE-CONST-TAG : int = 7
lostanza val LIST-CONST-TAG : int = 8
lostanza val STRING-CONST-TAG : int = 9
lostanza val SYMBOL-CONST-TAG : int = 10
lostanza val TYPE-CONST-TAG : int = 11
lostanza val FN-CONST-TAG : int = 12
lostanza val INTERNED-CONST-TAG : int = 13
lostanza var initialized-symbol-table? : long = 0L
lostanza var consts-top : long = 4L
lostanza var num-loaded-consts : long = 0L

protected lostanza defn initialize-constants () -> ref<False> :
  ;Initialize read pointer to beginning of the constant table
  ;[num, constants ...]
  val consts-data = call-prim consts-data()

  ;Read total number of constants
  const-ptr = consts-data
  val n-consts = read-const-int()

  ;Populate constants vector
  const-ptr = consts-data + consts-top
  var cs:ptr<ref<?>> = call-prim consts()
  while num-loaded-consts < n-consts :  
    cs[num-loaded-consts] = read-const()
    num-loaded-consts = num-loaded-consts + 1

  ;Set new top
  consts-top = const-ptr - consts-data  
  return false

lostanza defn read-const () -> ref<?> :
  val tag = read-const-int()
  if tag == BYTE-CONST-TAG :
    return new Byte{read-const-byte()}
  else if tag == CHAR-CONST-TAG :
    return new Char{read-const-byte()}
  else if tag == INT-CONST-TAG :
    return new Int{read-const-int()}
  else if tag == LONG-CONST-TAG :
    return new Long{read-const-long()}
  else if tag == FLOAT-CONST-TAG :
    return new Float{read-const-float()}
  else if tag == DOUBLE-CONST-TAG :
    return new Double{read-const-double()}
  else if tag == TRUE-CONST-TAG :
    return true
  else if tag == FALSE-CONST-TAG :
    return false
  else if tag == LIST-CONST-TAG :
    val len = read-const-int()
    return read-const-list(len)
  else if tag == STRING-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)
    return String(len, chars)
  else if tag == SYMBOL-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)    
    val str = String(len, chars)
    if initialized-symbol-table? : return to-symbol(str)
    else : return new StringSymbol{str}
  else if tag == TYPE-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Type{0, code}
  else if tag == FN-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Fn{0, code}
  else if tag == INTERNED-CONST-TAG :
    val i = read-const-int()
    val cs:ptr<ref<?>> = call-prim consts()
    return cs[i]
  else :
    call-c clib/printf("Unknown constant tag: %d\n", tag)
    return fatal("Unknown constant tag")

lostanza defn read-const-list (n:int) -> ref<List> :
  if n == 0 : return new NilList{}
  else : return new FullList{read-const(), read-const-list(n - 1)}

lostanza defn read-const-byte () -> byte :
  val value = [const-ptr as ptr<byte>]
  const-ptr = const-ptr + sizeof(byte)
  return value

lostanza defn read-const-int () -> int :
  val value = [const-ptr as ptr<int>]
  const-ptr = const-ptr + sizeof(int)
  return value

lostanza defn read-const-long () -> long :
  val value = [const-ptr as ptr<long>]
  const-ptr = const-ptr + sizeof(long)
  return value

lostanza defn read-const-float () -> float :
  val value = [const-ptr as ptr<float>]
  const-ptr = const-ptr + sizeof(float)
  return value

lostanza defn read-const-double () -> double :
  val value = [const-ptr as ptr<double>]
  const-ptr = const-ptr + sizeof(double)
  return value

lostanza defn read-const-chars (len:long) -> ptr<byte> :
  val value = const-ptr as ptr<byte>
  ;length chars + pad to nearest 4 bytes
  val n = (len + 3) & -4
  const-ptr = (const-ptr + n) as ptr<?>
  return value

;============================================================
;=================== Garbage Collection =====================
;============================================================

lostanza var initialized-gc-notifiers? : long = 0L

lostanza defn extend-heap (size:long) -> long :
  ;Collect garbage, and ensure we freed enough space
  val remaining = call-prim collect-garbage(size)
  if remaining < size : fatal("Out of memory.")
  ;Now run the GC notifiers, if they have been initialized
  if initialized-gc-notifiers? :
    run-gc-notifiers()
  ;If GC notifiers allocated too much space, then collect the garbage again
  ;(Happens rarely.)
  val remaining2 = call-prim heap-remaining()
  if remaining2 < size :
    ;Collect garbage, and ensure we freed enough space
    val remaining = call-prim collect-garbage(size)
    if remaining < size : fatal("Out of memory.")
  return 0

;============================================================
;================== GC Notifiers ============================
;============================================================

var GC-NOTIFIERS:Vector<(() -> ?)>

lostanza defn initialize-gc-notifiers () -> ref<False> :
  GC-NOTIFIERS = Vector<(() -> ?)>()
  initialized-gc-notifiers? = 1L
  return false

defn run-gc-notifiers () :
  for f in GC-NOTIFIERS do :
    f()

public defn add-gc-notifier (f: () -> ?) :
   add(GC-NOTIFIERS, f)

;============================================================
;====================== Stack Extension =====================
;============================================================

lostanza defn extend-stack (size:long) -> long :
  ;Retrieve stack
  val vms:ptr<VMState> = call-prim flush-vm()
  val s:ptr<Stack> = addr!([vms.system-stack as ref<Stack>])

  ;Compute new size of stack
  val desired-size = s.stack-pointer + size - s.frames
  var size*:long = s.size
  while size* < desired-size : size* = size* * 2

  ;Allocate new frames and copy over old frames
  val frames* = call-c clib/malloc(size*)
  call-c clib/memcpy(frames*, s.frames, s.size)
  call-c clib/free(s.frames)
  
  ;Swap in new frames
  s.stack-pointer = s.stack-pointer + (frames* - s.frames)
  s.size = size*
  s.frames = frames*
  
  ;Return
  return 0

;============================================================
;====================== CONSTANTS ===========================
;============================================================

val COROUTINE-ACTIVE = 0
val COROUTINE-CLOSED = 1
val COROUTINE-SUSPENDED = 2
val COROUTINE-OPEN = 3

lostanza val INT-TAG-BITS:long = 0L
lostanza val REF-TAG-BITS:long = 1L
lostanza val MARKER-TAG-BITS:long = 2L
lostanza val BYTE-TAG-BITS:long = 3L
lostanza val CHAR-TAG-BITS:long = 4L
lostanza val FLOAT-TAG-BITS:long = 5L

lostanza val FALSE-TYPE:int = 0
lostanza val TRUE-TYPE:int = 1
lostanza val BYTE-TYPE:int = 2
lostanza val CHAR-TYPE:int = 3
lostanza val INT-TYPE:int = 4
lostanza val FLOAT-TYPE:int = 5

public lostanza val null:ptr<?> = 0L as ptr<?>  

;============================================================
;======================= Bytes ==============================
;============================================================

public lostanza defn shift-left (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value << b.value}

public lostanza defn shift-right (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value >> b.value}

public lostanza defn bit-or (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value | b.value}

public lostanza defn bit-xor (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value & b.value}

public lostanza defn bit-not (a:ref<Byte>) -> ref<Byte> :
  return new Byte{(~ a.value)}

public lostanza defn plus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value + b.value}

public lostanza defn minus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value - b.value}

public lostanza defn times (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value * b.value}

public lostanza defn divide (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  ensure-divide-non-zero(b)
  return new Byte{a.value / b.value}

public lostanza defn modulo (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  ensure-divide-non-zero(b)
  return new Byte{a.value % b.value}

;============================================================
;====================== Integers ============================
;============================================================

public defn shift-left (a:Int, b:Int) -> Int :
  ($prim shl a b)

public defn shift-right (a:Int, b:Int) -> Int :
  ($prim shr a b)

public defn arithmetic-shift-right (a:Int, b:Int) -> Int :
  ($prim ashr a b)

public defn bit-or (a:Int, b:Int) -> Int :
  ($prim or a b)

public defn bit-and (a:Int, b:Int) -> Int :
  ($prim and a b)

public defn bit-xor (a:Int, b:Int) -> Int :
  ($prim xor a b)

public defn bit-not (a:Int) -> Int :
  ($prim not a)

public defn negate (a:Int) -> Int :
  ($prim neg a)

public defn abs (a:Int) -> Int :
  (- a) when a < 0 else a

public defn plus (a:Int, b:Int) -> Int :
  ($prim add a b)

public defn minus (a:Int, b:Int) -> Int :
  ($prim sub a b)

public defn times (a:Int, b:Int) -> Int :
  ($prim mul a b)

public defn divide (a:Int, b:Int) -> Int :
  ensure-divide-non-zero(b)
  ($prim div a b)

public defn modulo (a:Int, b:Int) -> Int :
  ensure-divide-non-zero(b)
  ($prim mod a b)

;============================================================
;======================== Longs =============================
;============================================================

public lostanza defn shift-left (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value << b.value}

public lostanza defn shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value >> b.value}

public lostanza defn arithmetic-shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value >>> b.value}

public lostanza defn bit-or (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value | b.value}

public lostanza defn bit-xor (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value & b.value}

public lostanza defn bit-not (a:ref<Long>) -> ref<Long> :
  return new Long{(~ a.value)}

public lostanza defn negate (a:ref<Long>) -> ref<Long> :
  return new Long{(- a.value)}

public defn abs (a:Long) -> Long :
  (- a) when a < 0L else a

public lostanza defn plus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value + b.value}

public lostanza defn minus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value - b.value}

public lostanza defn times (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value * b.value}

public lostanza defn divide (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  ensure-divide-non-zero(b)
  return new Long{a.value / b.value}

public lostanza defn modulo (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  ensure-divide-non-zero(b)
  return new Long{a.value % b.value}

;============================================================
;======================= Floats =============================
;============================================================

public lostanza defn negate (a:ref<Float>) -> ref<Float> :
  return new Float{(- a.value)}

public defn abs (a:Float) -> Float :
  (- a) when a < 0.0f else a

public lostanza defn plus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value + b.value}

public lostanza defn minus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value - b.value}

public lostanza defn times (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value * b.value}

public lostanza defn divide (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value / b.value}

public lostanza defn nan? (x:ref<Float>) -> ref<True|False> :
  val v = x.value
  if v != v : return true
  else : return false

;============================================================
;======================= Doubles ============================
;============================================================

public lostanza defn negate (a:ref<Double>) -> ref<Double> :
  return new Double{(- a.value)}

public defn abs (a:Double) -> Double :
  (- a) when a < 0.0 else a

public lostanza defn plus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value + b.value}

public lostanza defn minus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value - b.value}

public lostanza defn times (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value * b.value}

public lostanza defn divide (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value / b.value}

public lostanza defn nan? (x:ref<Double>) -> ref<True|False> :
  val v = x.value
  if v != v : return true
  else : return false

;============================================================
;======================== Strings ===========================
;============================================================

public lostanza defn String (len:long) -> ref<String> :
  return new String{len + 1, 0}

public lostanza defn String (len:long, chars:ptr<byte>) -> ref<String> :
  val s = String(len)
  call-c clib/memcpy(addr!(s.chars), chars, len)
  s.chars[len] = 0 as byte
  return s

;============================================================
;======================= Lists ==============================
;============================================================

public lostanza defn List () -> ref<List> :
  return new NilList{}

public lostanza defn cons<?T> (x:ref<?T>, t:ref<List<?T>>) -> ref<List<T>> :
  return new FullList<T>{x, t}

public defmulti head<?T> (x:List<?T>) -> T
public defmulti tail<?T> (x:List<?T>) -> List<T>
public defmulti empty? (x:List) -> True|False

defmethod head (x:NilList) : fatal("Cannot retrieve head of empty list.")
defmethod tail (x:NilList) : fatal("Cannot retrieve tail of empty list.")
defmethod empty? (x:NilList) : true
lostanza defmethod head (x:ref<FullList>) -> ref<?> : return x.head
lostanza defmethod tail (x:ref<FullList>) -> ref<?> : return x.tail
defmethod empty? (x:FullList) : false

;============================================================
;======================= Booleans ===========================
;============================================================

public defn complement (a:True|False) -> True|False :
  if a : false
  else : true

;============================================================
;====================== Comparable ==========================
;============================================================

public deftype Comparable<T> :
  Char <: Comparable<Char>
  Byte <: Comparable<Byte>
  Int <: Comparable<Int>
  Long <: Comparable<Long>
  Float <: Comparable<Float>
  Double <: Comparable<Double>
  Tuple<T> <: Comparable<Tuple<T>>
  String <: Comparable<String>
  Symbol <: Comparable<Symbol>
  List<T> <: Comparable<List<T>>

public defmulti compare<?T> (a:Comparable<?T>, b:T) -> Int
public defmulti less?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti greater?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti less-eq?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti greater-eq?<?T> (a:Comparable<?T>, b:T) -> True|False

defmethod less?<?T> (a:Comparable<?T>, b:T) : compare(a, b) < 0
defmethod greater?<?T> (a:Comparable<?T>, b:T) : compare(a, b) > 0
defmethod less-eq?<?T> (a:Comparable<?T>, b:T) : compare(a, b) <= 0
defmethod greater-eq?<?T> (a:Comparable<?T>, b:T) : compare(a, b) >= 0

lostanza defmethod compare (a:ref<Char>, b:ref<Char>) -> ref<Int> :
  return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Byte>, b:ref<Byte>) -> ref<Int> :
  return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

defmethod compare (a:Int, b:Int) -> Int :
  if a < b : -1
  else if a > b : 1
  else : 0

defmethod less? (a:Int, b:Int) -> True|False :
  ($prim lt a b)

defmethod less-eq? (a:Int, b:Int) -> True|False :
  ($prim le a b)

defmethod greater? (a:Int, b:Int) -> True|False :
  ($prim gt a b)

defmethod greater-eq? (a:Int, b:Int) -> True|False :
  ($prim ge a b)

lostanza defmethod compare (a:ref<Long>, b:ref<Long>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Float>, b:ref<Float>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Double>, b:ref<Double>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Tuple<Comparable>>, b:ref<Tuple<Comparable>>) -> ref<Int> :
  val la = a.length
  val lb = b.length
  labels :
    begin :
      goto loop(0)
    loop (i:long) :
      if i < la and i < lb :
        val c = compare(a.items[i], b.items[i])        
        if c.value : return c
        else : goto loop(i + 1)
      else :
        return compare(new Int{la as int}, new Int{lb as int})

lostanza defmethod compare (a:ref<String>, b:ref<String>) -> ref<Int> :
  val na = strlen(a)
  val nb = strlen(b)
  labels :
    begin :
      goto loop(0)
    loop (i:long) :
      if (i == na) and (i == nb) :
        return new Int{0}
      else if i == na :
        return new Int{-1}
      else if i == nb :
        return new Int{1}
      else :
        val ac = a.chars[i]
        val bc = b.chars[i]
        if ac < bc : return new Int{-1}
        else if ac > bc : return new Int{1}
        else : goto loop(i + 1)

defmethod compare (xs:List<Comparable>, ys:List<Comparable>) -> Int :
  defn* loop (xs:List<Comparable>, ys:List<Comparable>) :
    match(empty?(xs), empty?(ys)) :
      (ex:True, ey:True) : 0
      (ex:True, ey:False) : -1
      (ex:False, ey:True) : 1
      (ex:False, ey:False) :
        val c = compare(head(xs), head(ys))
        if c == 0 : loop(tail(xs), tail(ys))
        else : c
  loop(xs, ys)

defmethod compare (a:Symbol, b:Symbol) :
  defn rank (s:Symbol) :
    match(s) :
      (s:StringSymbol) : 0
      (s:GenSymbol) : 1
  match(a, b) :
    (a:StringSymbol, b:StringSymbol) :
      compare(name(a), name(b))
    (a:GenSymbol, b:GenSymbol) :
      val c = compare(name(a), name(b))
      if c == 0 : compare(id(a), id(b))
      else : c
    (a, b) :
      compare(rank(a), rank(b))

;============================================================
;======================== Equalable =========================
;============================================================

public deftype Equalable :
  Char <: Equalable
  Byte <: Equalable
  Int <: Equalable
  Long <: Equalable
  Float <: Equalable
  Double <: Equalable
  Tuple<T> <: Equalable
  String <: Equalable
  Symbol <: Equalable
  List<T> <: Equalable
  True <: Equalable
  False <: Equalable

public defmulti equal? (a:Equalable, b:Equalable) -> True|False
defmethod equal? (a:Equalable, b:Equalable) : false

public defn not-equal? (a:Equalable, b:Equalable) -> True|False :
  not equal?(a, b)

defmethod equal? (a:Char, b:Char) -> True|False :
  ($prim identical? a b)

defmethod equal? (a:Byte, b:Byte) -> True|False :
  ($prim identical? a b)

defmethod equal? (a:Int, b:Int) -> True|False :
  ($prim eq a b)

lostanza defmethod equal? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

lostanza defmethod equal? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

lostanza defmethod equal? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

defmethod equal? (a:True|False, b:True|False) -> True|False :
  ($prim identical? a b)

lostanza defmethod equal? (x:ref<Tuple>, y:ref<Tuple>) -> ref<True|False> :
  val n = x.length
  if n != y.length : return false
  for (var i:long = 0, i < n, i = i + 1) :
    if equal?(x.items[i], y.items[i]) == false :
      return false
  return true

lostanza defmethod equal? (a:ref<String>, b:ref<String>) -> ref<True|False> :
  val n = strlen(a)
  if n == strlen(b) :
    for (var i:long = 0, i < n, i = i + 1) :
      if a.chars[i] != b.chars[i] :
        return false
    return true
  else :
    return false

defmethod equal? (a:List, b:List) -> True|False :
  defn* loop (a:List, b:List) :
    match(empty?(a), empty?(b)) :
      (ea:True, eb:True) : true
      (ea:False, eb:False) :
        if head(a) == head(b) :
          loop(tail(a), tail(b))
      (ea, eb) : false
  loop(a, b)

defmethod equal? (a:Symbol, b:Symbol) -> True|False :
  ($prim identical? a b)

;============================================================
;====================== Lengthable ==========================
;============================================================

public deftype Lengthable :
  String <: Lengthable
  Tuple<T> <: Lengthable
  List<T> <: Lengthable

public defmulti length (l:Lengthable) -> Int

lostanza defmethod length (x:ref<Tuple>) -> ref<Int> :
  return new Int{x.length as int}

lostanza defmethod length (s:ref<String>) -> ref<Int> :
  return new Int{s.length as int - 1}

defmethod length (x:List) :
  defn* loop (x:List, n:Int) :
    if empty?(x) : n
    else : loop(tail(x), n + 1)
  loop(x, 0)

;============================================================
;=================== Winders ================================
;============================================================
defstruct Winder :
  in: False|(() -> ?)
  out: False|(? -> ?)
   
var WINDER-STACK:List<Winder>
var NUM-WINDERS:Int

defn initialize-winders () :
  WINDER-STACK = List()
  NUM-WINDERS = 0  

defn pop-winder () :
  val w = head(WINDER-STACK)
  WINDER-STACK = tail(WINDER-STACK)
  NUM-WINDERS = NUM-WINDERS - 1
  w

defn push-winder (w:Winder) :
  WINDER-STACK = cons(w, WINDER-STACK)
  NUM-WINDERS = NUM-WINDERS + 1

defn pop-winders (n:Int) :
  defn pop (n:Int) :
    if n > 0 : cons(pop-winder(), pop(n - 1))
    else : List()
  pop(NUM-WINDERS - n)   

defn push-winders (ws:List<Winder>) :
  if not empty?(ws) :
    push-winders(tail(ws))
    push-winder(head(ws))

defn total-winders (c:False|RawCoroutine) -> Int :
  match(c) :
    (c:False) : 0
    (c:RawCoroutine) : total-winders(parent(c)) + num-winders(c)

defn wind-in (ws:List<Winder>) :
  if not empty?(ws) :
    wind-in(tail(ws))
    call?(in(head(ws)))

defn wind-out (ws:List<Winder>, f:True|False) :
  if not empty?(ws) :
    call?(out(head(ws)), f)
    wind-out(tail(ws), f)

defn* call? (f: False|(() -> ?)) :
  match(f) :
    (f:() -> ?) : f()
    (f:False) : false

defn* call? (f: False|(? -> ?), x: ?) :
  match(f) :
    (f:? -> ?) : f(x)
    (f:False) : false

lostanza defn inc-winders (c:ref<RawCoroutine>, n:ref<Int>) -> ref<False> :
  c.num-winders = c.num-winders + n.value
  return false

lostanza defn num-winders (c:ref<RawCoroutine>) -> ref<Int> :
  return new Int{c.num-winders}
      
public defn dynamic-wind<?T> (in:False|(() -> ?),
                              body:() -> ?T,
                              out:False|(True|False -> ?)) -> T :
  call?(in)
  push-winder(Winder(in, out))
  inc-winders(current-coroutine, 1)
  val result = body()
  pop-winder()
  inc-winders(current-coroutine, -1)
  call?(out, true)
  result

;============================================================
;====================== Coroutines ==========================
;============================================================

public defmulti active? (c:Coroutine) -> True|False
public defmulti open? (c:Coroutine) -> True|False
public defmulti resume<?I,?O> (c:Coroutine<?I,?O>, x:I) -> O
public defmulti suspend<?I,?O> (c:Coroutine<?I,?O>, x:O) -> I
public defmulti break<?O> (c:Coroutine<?,?O>, x:O) -> Void
public defmulti close (c:Coroutine) -> False

;                  Wrapped Coroutines
;                  ==================

#if-defined(OPTIMIZE) :

  public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
    RawCoroutine(enter)

#else :

  deftype WrappedCoroutine<I,O> <: Coroutine<I,O>
  defmulti raw (c:WrappedCoroutine) -> RawCoroutine

  public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
    var rc
    val c = new WrappedCoroutine<I,O> :
      defmethod active? (this) : active?(rc)
      defmethod open? (this) : open?(rc)
      defmethod resume (this, x:I) : resume(rc, x)
      defmethod suspend (this, x:O) : suspend(rc, x)
      defmethod break (this, x:O) : break(rc, x)
      defmethod close (this) : close(rc)
      defmethod raw (this) : rc
    rc = RawCoroutine $ fn (rc, x0) :
      enter(c, x0)
    c

protected lostanza deftype RawCoroutine <: Coroutine :
  id: long
  stack: ref<Stack>
  parent: ref<False|RawCoroutine>
  status: ref<Int>
  num-winders: int

lostanza deftype CoroutineParams :
  parent-stack: ref<Stack>
  coroutine: ref<RawCoroutine>
  enter: ref<((RawCoroutine, ?) -> ?)>

protected lostanza var current-coroutine:ref<RawCoroutine>
lostanza var COROUTINE-COUNTER:long

lostanza defn initialize-coroutines () -> ref<False> :
  current-coroutine = new RawCoroutine{0L, call-prim stack(), false, COROUTINE-ACTIVE, 0}
  COROUTINE-COUNTER = 1L
  return false

public lostanza defn RawCoroutine (enter:ref<((RawCoroutine, ?) -> ?)>) -> ref<RawCoroutine> :
  return call-prim new-stack(addr(setup-coroutine), call-prim stack(), enter)

lostanza defn parent (c:ref<RawCoroutine>) -> ref<False|RawCoroutine> :
  return c.parent
lostanza defn status (c:ref<RawCoroutine>) -> ref<Int> :
  return c.status
lostanza defn id (c:ref<RawCoroutine>) -> ref<Int> :
  return new Int{c.id as int}

lostanza defmethod active? (c:ref<RawCoroutine>) -> ref<True|False> :
  if c.status == COROUTINE-ACTIVE : return true
  else : return false

lostanza defmethod open? (c:ref<RawCoroutine>) -> ref<True|False> :
  if c.status == COROUTINE-OPEN : return true
  else : return false

lostanza defn* setup-coroutine (stack:ref<Stack>, parent-stack:ref<Stack>, enter:ref<((RawCoroutine, ?) -> ?)>) -> ref<?> :
  val co = new RawCoroutine{COROUTINE-COUNTER, stack, false, COROUTINE-OPEN, 0}
  COROUTINE-COUNTER = COROUTINE-COUNTER + 1L
  val x0 = call-prim yield(parent-stack, co)
  return break(co, [enter](co, x0))

lostanza defmethod resume (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
  ;Ensure coroutine is re-entrant
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot resume coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-ACTIVE :
    return fatal("Cannot resume coroutine. Coroutine is already active.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot resume coroutine. Coroutine's parent is suspended.")  

  ;Adjust state
  attach-coroutine(c)

  ;Begin execution
  return call-prim yield(current-coroutine.stack, x)

lostanza defmethod* suspend (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
  ;Ensure coroutine is active
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot suspend coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-OPEN :
    return fatal("Cannot suspend coroutine. Coroutine is already suspended.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot suspend coroutine. Coroutine is already suspended.")

  ;Set target winder environment and wind out
  val winders = pop-winders(total-winders(c.parent))
  wind-out(winders, false)

  ;Detach coroutine
  detach-coroutine(c)

  ;Return to resume
  val result = call-prim yield(current-coroutine.stack, x)

  ;Wind in and restore original winder environment
  wind-in(winders)
  push-winders(winders)

  ;Return execution
  return result

lostanza defmethod close (c:ref<RawCoroutine>) -> ref<False> :
  ;Ensure coroutine is re-entrant
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot close coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-ACTIVE :
    return fatal("Cannot close coroutine. Coroutine is active.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot close coroutine. Coroutine's parent is suspended.")
  free-coroutine(c)
  return false

lostanza defmethod break (c:ref<RawCoroutine>, x:ref<?>) -> ref<Void> :
  ;Ensure coroutine is active
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot break from coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-OPEN :
    return fatal("Cannot break from coroutine. Coroutine is already suspended.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot break from coroutine. Coroutine is already suspended.")

  ;Set target winder environment and wind out
  val winders = pop-winders(total-winders(c.parent))
  wind-out(winders, false)

  ;Adjust state
  detach-coroutine(c)
  free-coroutine(c)
  
  ;Begin execution
  return call-prim yield(current-coroutine.stack, x)

lostanza defn free-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(c)
    loop (c:ref<RawCoroutine>) :
      val parent = c.parent
      c.parent = false
      c.status = COROUTINE-CLOSED
      ;free-stacks(top(c), bottom(c))
      match(parent) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : return 0  

lostanza defn attach-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(c)
    loop (c:ref<RawCoroutine>) :
      val p = c.parent
      c.parent = current-coroutine
      c.status = COROUTINE-ACTIVE
      current-coroutine = c
      match(p) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : return 0

lostanza defn detach-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(false)
    loop (tail:ref<RawCoroutine|False>) :
      val cc = current-coroutine
      val ccp = current-coroutine.parent as ref<RawCoroutine>
      cc.parent = tail
      current-coroutine = ccp
      if cc == c :
        cc.status = COROUTINE-OPEN
        return 0
      else :
        cc.status = COROUTINE-SUSPENDED
        goto loop(cc)

;============================================================
;=================== Generic Printing =======================
;============================================================

lostanza defn object-type-id (x:ref<?>) -> int :
  val ref = x as long
  val tagbits = ref & 0x7L
  if tagbits == INT-TAG-BITS : return INT-TYPE
  else if tagbits == BYTE-TAG-BITS : return BYTE-TYPE
  else if tagbits == CHAR-TAG-BITS : return CHAR-TYPE
  else if tagbits == FLOAT-TAG-BITS : return FLOAT-TYPE  
  else if tagbits == MARKER-TAG-BITS :
    return (ref >> 3L) as int
  else if tagbits == REF-TAG-BITS :
    val p = (ref - REF-TAG-BITS) as ptr<long>
    return [p] as int
  else :
    fatal("Illegal tag bits\n")
    return 0

lostanza defn object-type (x:ref<?>) -> ref<String> :
  val chars = call-prim class-name(object-type-id(x))
  return String(chars)

;============================================================
;=================== Initialize Constants ===================
;============================================================
initialize-constants()

;============================================================
;=================== Compound Constants =====================
;============================================================

lostanza deftype Sentinel
lostanza val sentinel:ref<Sentinel> = new Sentinel{}

protected deftype Uninitialized
protected val uninitialized = new Uninitialized

#if-defined(PLATFORM-WINDOWS) :
  lostanza val LS-NL:ptr<?> = "\r\n"
  val NL = "\r\n"
#else :  
  lostanza val LS-NL:ptr<?> = "\n"
  val NL = "\n"

;============================================================
;=================== Initialize Remaining ===================
;============================================================

initialize-launcher()
initialize-winders()
initialize-coroutines()
initialize-gc-notifiers()
initialize-symbol-table()

;================================================================================
;========================== End of Boot Sequence ================================
;================================================================================

;============================================================
;===================== Utilities ============================
;============================================================

protected lostanza defn linux-error-msg () -> ref<String> :
  val s = call-c clib/strerror(call-c clib/get_errno())
  return String(s)

;============================================================
;====================== ToString ============================
;============================================================

public defmulti to-string (x) -> String

;                Default Implementation
;                ======================

defmethod to-string (x) -> String :
   val s = StringBuffer()
   print(s, x)
   to-string(s)

defmethod to-string (x:String) : x
defmethod to-string (x:True) : "true"
defmethod to-string (x:False) : "false"

;============================================================
;====================== Error Preconditions =================
;============================================================

defn ensure-divide-non-zero (i:Byte) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0Y)
defn ensure-divide-non-zero (i:Int) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0)
defn ensure-divide-non-zero (i:Long) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0L)

protected defn ensure-index-in-bounds (xs:Lengthable, i:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if i < 0 or i >= length(xs) :
      fatal("Index (%_) out of bounds." % [i])

protected defn ensure-length-in-bounds (xs:Lengthable, i:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if i < 0 or i > length(xs) :
      fatal("Index (%_) out of bounds." % [i])

defn ensure-start-before-end (s:Int, e:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if e < s :
      fatal("Given end index (%_) is smaller than start index (%_)." % [e, s])

protected defn ensure-non-negative (quantity:String, n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if n < 0 :
      fatal("Given %_ (%_) is negative." % [quantity, n])

protected defn ensure-positive (quantity:String, n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if n <= 0 :
      fatal("Given %_ (%_) is not positive." % [quantity, n])

protected defn ensure-non-negative-length (n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    ensure-non-negative("length", n)

protected defn ensure-index-range (xs:Lengthable, r:Range) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if step(r) != 1 :
      fatal("Given index range (%_) does not have a step of 1." % [r])
    val s = start(r)
    match(end(r), inclusive?(r)) :
      (e:Int, inc?:True) :
        ensure-index-in-bounds(xs, s)
        ensure-index-in-bounds(xs, e)
        ensure-start-before-end(s, e)
      (e:Int, inc?:False) :
        ensure-length-in-bounds(xs, s)
        ensure-length-in-bounds(xs, e)
        ensure-start-before-end(s, e)
      (e:False, inc?) :
        ensure-length-in-bounds(xs, s)

protected defn range-bound (s:Lengthable, r:Range) -> [Int, Int] :
  match(end(r), inclusive?(r)) :
    (e:Int, i:True) : [start(r), e + 1]
    (e:Int, i:False) : [start(r), e]
    (e:False, i) : [start(r), length(s)]

;============================================================
;===================== Hashable =============================
;============================================================

public deftype Hashable :
  Char <: Hashable
  Byte <: Hashable
  Int <: Hashable
  Long <: Hashable
  Float <: Hashable
  Double <: Hashable
  Tuple<T> <: Hashable
  List<T> <: Hashable
  String <: Hashable
  Symbol <: Hashable
  True <: Hashable
  False <: Hashable

public defmulti hash (h:Hashable) -> Int

lostanza defmethod hash (a:ref<Char>) -> ref<Int> :
  return new Int{a.value}

lostanza defmethod hash (a:ref<Byte>) -> ref<Int> :
  return new Int{a.value}

defmethod hash (a:Int) -> Int :
  a

lostanza defmethod hash (a:ref<Long>) -> ref<Int> :
  val v = a.value
  return new Int{(v ^ (v >> 32)) as int}

defmethod hash (a:Float) -> Int :
  bits(a)

lostanza defmethod hash (a:ref<Double>) -> ref<Int> :
  val v = a.value
  val bits = ($ls-prim bits v)
  return new Int{(bits ^ (bits >> 32)) as int}

defmethod hash (xs:Tuple<Hashable>) :
  var i = length(xs)
  for x in xs do :
     i = (7 * i) + hash(x)
  i

defmethod hash (xs:List<Hashable>) -> Int :
  var i = 0
  for x in xs do :
    i = (7 * i) + hash(x)
  i

defmethod hash (a:True) : 1
defmethod hash (a:False) : 0

public lostanza defmethod hash (s:ref<String>) -> ref<Int> :
  if s.hash == 0 :
    val n = strlen(s)
    var h:int = 0
    for (var i:long = 0, i < n, i = i + 1) :
      h = (31 * h) + s.chars[i]
    if h == 0 : s.hash = 1
    else : s.hash = h
  return new Int{s.hash}

lostanza defmethod hash (s:ref<StringSymbol>) -> ref<Int> :
  return hash(s.name)

lostanza defmethod hash (s:ref<GenSymbol>) -> ref<Int> :
  return id(s)

;============================================================
;======================= Symbols ============================
;============================================================

public defmulti name (a:Symbol) -> String
public defmulti qualified? (a:Symbol) -> True|False
public defmulti qualifier (a:Symbol) -> [False|Symbol, Symbol]

;                   StringSymbol Functions
;                   ======================
lostanza defn StringSymbol (name:ref<String>) -> ref<StringSymbol> :
  return new StringSymbol{name}

lostanza defmethod name (s:ref<StringSymbol>) -> ref<String> :
  return s.name

defmethod qualified? (s:StringSymbol) :
   contains?(name(s), '/')

defmethod qualifier (s:StringSymbol) :
   match(last-index-of-char(name(s), '/')) :
      (i:Int) :
         val part1 = intern-symbol(name(s)[0 to i])
         val part2 = intern-symbol(name(s)[(i + 1) to false])
         [part1, part2]
      (i:False) :
         [false, s]

defmethod to-string (s:StringSymbol) :
   name(s)

;                  GenSymbol Functions
;                  ===================
public defmulti id (s:GenSymbol) -> Int

defn GenSymbol (name:String) :
   defn make-sym (name:String) :
      val id = genid()
      new GenSymbol :
         defmethod id (this) : id
         defmethod name (this) : name
         defmethod qualified? (this) : false
         defmethod qualifier (this) : [false, this]

   match(last-index-of-char(name, '/')) :
      (i:Int) :
         val id = genid()
         val qualifier = intern-symbol(name[0 to i])
         val unqualified-sym = make-sym(name[(i + 1) to false])
         new GenSymbol :
            defmethod id (this) : id
            defmethod name (this) : name
            defmethod qualified? (this) : true
            defmethod qualifier (this) : [qualifier, unqualified-sym]
      (i:False) :
         make-sym(name)

val ID-COUNTER = to-seq(0 to false)

public defn gensym (x) :
   match(x) :
      (x:Symbol) : gensym(name(x))
      (s:String) : GenSymbol(s)
      (x) : gensym(to-string(x))

public defn gensym () :
   gensym("$gen")

public defn genid () :
   next(ID-COUNTER)

;                    General Functions
;                    =================

public defn prefix? (a:Symbol, p:String) -> True|False :
   prefix?(name(a), p)

;                    Symbol Interning
;                    ================

var INTERNED-SYMBOLS : HashTable<String,Symbol>

lostanza defn initialize-symbol-table () -> ref<False> :
  ;Read number of consts
  val cdata:ptr<int> = call-prim consts-data()
  val n-consts = [cdata]

  ;Get pointer to constant table
  val consts:ptr<ref<?>> = call-prim consts()

  ;Initialize symbol table
  INTERNED-SYMBOLS = HashTable-init<String,Symbol>(fn(StringSymbol))
  for (var i:int = 0, i < n-consts, i = i + 1) :    
    match(consts[i]) :
      (s:ref<Symbol>) : set(INTERNED-SYMBOLS, name(s), s)
      (s) : ()  

  ;Done initialization
  initialized-symbol-table? = 1L
  return false

defn intern-symbol (name:String) :
   INTERNED-SYMBOLS[name]

public defn to-symbol (x) :
   match(x) :
      (x:Symbol) : x
      (x:String) : intern-symbol(x)
      (x) : to-symbol(to-string(x))

;============================================================
;===================== OutputStream =========================
;============================================================

;                   General Interface
;                   =================
public deftype OutputStream
public defmulti print (o:OutputStream, x) -> False
public defmulti print-all (o:OutputStream, xs:Seqable) -> False
public defmulti put (o:OutputStream, x) -> False

;                Default Implementations
;                =======================

lostanza val CONVERSION-BUFFER: ptr<byte> = call-c clib/malloc(64)

lostanza defn print-conversion-buffer-float (o:ref<OutputStream>, n:int) -> ref<False> :
  labels :
    begin :
      goto loop(0)
    loop (i:int) :
      if i < n :
        val c = CONVERSION-BUFFER[i]
        if c == '.' : goto rest(i)
        else if c == 'e' : goto add-dot(i)
        else :
          print(o, new Char{c})
          goto loop(i + 1)
      else : goto add-dot(i)
    add-dot (i:int) :
      print(o, new Char{'.'})
      print(o, new Char{'0'})
      goto rest(i)
    rest (i:int) :
      if i < n :
        print(o, new Char{CONVERSION-BUFFER[i]})
        goto rest(i + 1)        
  return false

lostanza defn print-conversion-buffer-float (o:ptr<?>, n:int) -> ref<False> :
  labels :
    begin :
      goto loop(0)
    loop (i:int) :
      if i < n :
        val c = CONVERSION-BUFFER[i]
        if c == '.' : goto rest(i)
        else if c == 'e' : goto add-dot(i)
        else :
          call-c clib/fputc(c, o)
          goto loop(i + 1)
      else : goto add-dot(i)
    add-dot (i:int) :
      call-c clib/fputc('.', o)
      call-c clib/fputc('0', o)
      goto rest(i)
    rest (i:int) :
      if i < n :
        call-c clib/fputc(CONVERSION-BUFFER[i], o)
        goto rest(i + 1)        
  return false

lostanza defn print-conversion-buffer (o:ref<OutputStream>, n:int) -> ref<False> :
   for (var i:int = 0, i < n, i = i + 1) :
      print(o, new Char{CONVERSION-BUFFER[i]})
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Byte>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value as int)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Int>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Long>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%lld", x.value)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Float>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.6g", x.value as double)
   print-conversion-buffer-float(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Double>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.15g", x.value)
   print-conversion-buffer-float(o, n)
   return false

defmethod print (o:OutputStream, x:True) :
   print(o, "true")

defmethod print (o:OutputStream, x:False) :
   print(o, "false")

defmethod print (o:OutputStream, x:String) :
   print-all(o, x)

defmethod print (o:OutputStream, c:RawCoroutine) :
  val s = switch {status(c) == _} :
    COROUTINE-ACTIVE : "ACTIVE"
    COROUTINE-CLOSED : "CLOSED"
    COROUTINE-SUSPENDED : "SUSPENDED"
    COROUTINE-OPEN : "OPEN"
  print(o, "<Coroutine #%_ : %_>" % [id(c), s])
defmethod print (o:OutputStream, c:WrappedCoroutine) :
  print(o, raw(c))

defmethod print (o:OutputStream, t:Tuple) -> False :
   print(o, "[%@]" % [t])

defmethod print (o:OutputStream, xs:List) -> False :
   print(o, "(%@)" % [xs])

defmethod print (o:OutputStream, s:StringSymbol) :
   print(o, name(s))

defmethod print (o:OutputStream, s:GenSymbol) :
   print(o, name(s))
   print(o, id(s))

defmethod print (o:OutputStream, x) :
  print(o, "[GENERIC OBJECT]")
  ;print(o, "[%_ object]" % [object-type(x)])

defmethod print-all (o:OutputStream, xs:Seqable) :
   do(print{o, _}, xs)

;                 Convenience Functions
;                 =====================

public defn println (o:OutputStream, x) :
   print(o, x)
   print(o, NL)

public defn println-all (o:OutputStream, xs:Seqable) :
   print-all(o, xs)
   print(o, NL)

;============================================================
;==================== Printing of Types =====================
;============================================================

defmethod print (o:OutputStream, t:Type) :
  defn loop (t:String|Type) :
    match(t) :
      (t:String) : print(o, t)
      (t:Type) : do(loop, parts(t))
  do(loop, parts(t))

lostanza defn parts (t:ref<Type>) -> ref<Tuple<String|Type>> :
  val code = t.code as ptr<(ref<Type> -> ref<Tuple>)>
  return [code](t)

;============================================================
;=================== FileOutputStream =======================
;============================================================

public lostanza deftype FileOutputStream <: OutputStream :
  file: ptr<?>
  closable?: long

public lostanza defn FileOutputStream (filename:ref<String>, append?:ref<True|False>) -> ref<FileOutputStream> :
   var file : ptr<?>
   if append? == true : file = call-c clib/fopen(addr!(filename.chars), "ab")
   else : file = call-c clib/fopen(addr!(filename.chars), "wb")
   if file == null : throw(FileOpenException(filename, linux-error-msg()))
   return new FileOutputStream{file, 1}

public defn FileOutputStream (filename:String) :
   FileOutputStream(filename, false)

public lostanza defn close (o:ref<FileOutputStream>) -> ref<False> :
   if o.closable? :
      val err = call-c clib/fclose(o.file)
      if err != 0 : throw(FileCloseException(linux-error-msg()))
   else : fatal("System OutputStream is not closable.")
   return false

public lostanza defn flush (o:ref<FileOutputStream>) -> ref<False> :
  val err = call-c clib/fflush(o.file)
  if err != 0 : throw(FileFlushException(linux-error-msg()))
  return false

lostanza defmethod put (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod put (o:ref<FileOutputStream>, x:ref<Char>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

defmethod put (o:OutputStream, c:Char) -> False :
   put(o, to-byte(c))

defmethod put (o:OutputStream, i:Int) -> False :
   put(o, to-byte(i))
   put(o, to-byte(i >> 8))
   put(o, to-byte(i >> 16))
   put(o, to-byte(i >> 24))

defmethod put (o:OutputStream, i:Long) -> False :
   put(o, to-byte(i))
   put(o, to-byte(i >> 8L))
   put(o, to-byte(i >> 16L))
   put(o, to-byte(i >> 24L))
   put(o, to-byte(i >> 32L))
   put(o, to-byte(i >> 40L))
   put(o, to-byte(i >> 48L))
   put(o, to-byte(i >> 56L))

defmethod put (o:OutputStream, i:Float) -> False :
   put(o, bits(i))

defmethod put (o:OutputStream, i:Double) -> False :
   put(o, bits(i))

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<String>) -> ref<False> :
   val r = call-c clib/fputs(addr!(x.chars), o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value as int)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Char>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Int>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Long>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%lld", x.value)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Float>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.6g", x.value as double)
   print-conversion-buffer-float(o.file, n)
   if call-c clib/ferror(o.file) != 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Double>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.15g", x.value)
   print-conversion-buffer-float(o.file, n)
   if call-c clib/ferror(o.file) != 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<True>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "true")
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<False>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "false")
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

public defn with-output-file<?T> (file:FileOutputStream, f: () -> ?T) -> T :
   try : with-output-stream(file, f)
   finally : close(file)

public defn spit (filename:String, x) -> False :
   val o = FileOutputStream(filename, false)
   try : print(o, x)
   finally : close(o)

;============================================================
;================ System Output Streams =====================
;============================================================

;                 System Output Streams
;                 =====================

public lostanza val STANDARD-OUTPUT-STREAM : ref<OutputStream> =
   new FileOutputStream{stdout, 0}

public lostanza val STANDARD-ERROR-STREAM : ref<OutputStream> =
   new FileOutputStream{stderr, 0}

public lostanza val STANDARD-INPUT-STREAM : ref<InputStream> =
   new FileInputStream{stdin, 0}

;                 Current Output Stream
;                 =====================

var CURRENT-OUTPUT-STREAM : OutputStream = STANDARD-OUTPUT-STREAM

public defn with-output-stream<?T> (o:OutputStream, f: () -> ?T) -> T :
   let-var CURRENT-OUTPUT-STREAM = o :
      f()

public defn current-output-stream () :
   CURRENT-OUTPUT-STREAM

public defn set-current-output-stream (o:OutputStream) :
  CURRENT-OUTPUT-STREAM = o

public defn print (x) :
   print(CURRENT-OUTPUT-STREAM, x)

public defn println (x) :
   println(CURRENT-OUTPUT-STREAM, x)

public defn print-all (xs:Seqable) :
   do(print, xs)

public defn println-all (xs:Seqable) :
   println-all(CURRENT-OUTPUT-STREAM, xs)

;============================================================
;=================== Input Streams ==========================
;============================================================

;                      Interface
;                      =========

public deftype InputStream
public defmulti get-char (i:InputStream) -> Char|False
public defmulti get-byte (i:InputStream) -> Byte|False
public defmulti fill (xs:CharArray, r:Range, i:InputStream) -> Int

;                Abstract Implementations
;                ========================

defmethod fill (xs:CharArray, r:Range, s:InputStream) -> Int :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   defn* loop (i:Int) :
      if i < e :
         match(get-char(s)) :
            (c:Char) :
               xs[i] = c
               loop(i + 1)
            (c:False) : i - b
      else : i - b
   loop(b)

;============================================================
;=============== Buffered Input Streams =====================
;============================================================

public deftype BufferedInputStream <: InputStream

;                      Interface
;                      =========

public defmulti peek? (i:BufferedInputStream, n:Int) -> Char|False
public defmulti peek-fill (xs:CharArray, r:Range, i:BufferedInputStream) -> Int

;                Abstract Implementations
;                ========================

public defn peek? (i:BufferedInputStream) -> Char|False :
   peek?(i, 0)

;                     Creation
;                     ========

deftype CharQueue <: Lengthable
defmulti peek (c:CharQueue, i:Int) -> Char
defmulti pop (c:CharQueue) -> Char
defmulti peek-fill (xs:CharArray, b:Int, e:Int, c:CharQueue) -> Int
defmulti pop-fill (xs:CharArray, b:Int, e:Int, c:CharQueue) -> Int
defmulti fill (xs:CharQueue, stream:InputStream) -> False

defn CharQueue (cap:Int) :
   val array = CharArray(cap)
   var start:Int = 0
   var len:Int = 0
   
   defn wrap (i:Int) :
      val idx = start + i
      idx when idx < cap else idx - cap

   defn copy (xs:CharArray, b:Int, e:Int) :
      val n = e - b
      val n1 = cap - start
      val n2 = n - n1
      if n <= n1 :
         block-copy(n, xs, b, array, start)
      else :
         block-copy(n1, xs, b, array, start)
         block-copy(n2, xs, b + n1, array, 0)

   new CharQueue :
      defmethod length (this) :
         len         
      defmethod peek (this, i:Int) :
         array[wrap(i)]         
      defmethod pop (this) :
         val c = array[start]
         start = wrap(1)
         len = len - 1
         c
      defmethod peek-fill (xs:CharArray, b:Int, e:Int, this) -> Int :
         val n = min(e - b, len)   
         copy(xs, b, b + n)
         n         
      defmethod pop-fill (xs:CharArray, b:Int, e:Int, this) -> Int :
         val n = peek-fill(xs, b, e, this)
         start = wrap(n)
         len = len - n
         n
      defmethod fill (this, stream:InputStream) -> False :
         val pos = wrap(len)
         val total-read =
            if len == 0 :
               start = 0
               fill(array, 0 to cap, stream)
            else if start < pos :
               val n1 = cap - pos
               val n1* = fill(array, pos to cap, stream)
               if n1* < n1 : n1*
               else : n1* + fill(array, 0 to start, stream)
            else :
               fill(array, pos to start, stream)
         len = len + total-read

public defn BufferedInputStream (i:InputStream) -> BufferedInputStream :
   BufferedInputStream(i, 1024)

public defn BufferedInputStream (stream:InputStream, size:Int) -> BufferedInputStream :
   ensure-positive("buffer size", size)
      
   val buffer = CharQueue(size)
   
   new BufferedInputStream :
      defmethod peek? (this, i:Int) -> False|Char :
         #if-not-defined(OPTIMIZE) :
            if i < 0 :
               fatal("Cannot peek? into a BufferedInputStream at a negative index.")
            if i >= size :
               fatal("Cannot peek? %_ chars ahead into BufferedInputStream with buffer size %_." % [i, size])
         if length(buffer) > i :
            peek(buffer, i)
         else :
            fill(buffer, stream)
            peek(buffer, i) when length(buffer) > i

      defmethod peek-fill (xs:CharArray, r:Range, this) -> Int :
         val [b, e] = range-bound(xs, r)
         val n = e - b
         #if-not-defined(OPTIMIZE) :
            if n > size :
               fatal("Cannot peek more characters (%_) than capacity of buffer (%_)." % [n, size])
         fill(buffer, stream) when length(buffer) < n
         peek-fill(xs, b, e, buffer)
         
      defmethod fill (xs:CharArray, r:Range, this) -> Int :
         val [b, e] = range-bound(xs, r)
         val n = e - b
         if n < size :
            fill(buffer, stream) when length(buffer) < n
            pop-fill(xs, b, e, buffer)
         else :
            val n1 = pop-fill(xs, b, e, buffer)
            if n1 < n : n1 + fill(xs, (b + n1) to e, stream)
            else : n1

      defmethod get-char (this) -> False|Char :
         fill(buffer, stream) when length(buffer) == 0
         pop(buffer) when length(buffer) > 0
         
      defmethod get-byte (this) :
         match(get-char(this)) :
            (c:Char) : to-byte(c)
            (c:False) : false

;============================================================
;================= File Input Streams =======================
;============================================================

public lostanza deftype FileInputStream <: InputStream :
  file: ptr<?>
  closable?: long

public lostanza defn FileInputStream (filename:ref<String>) -> ref<FileInputStream> :
   val file = call-c clib/fopen(addr!(filename.chars), "rb")
   if file == null : throw(FileOpenException(filename, linux-error-msg()))
   return new FileInputStream{file, 1}

public lostanza defn close (i:ref<FileInputStream>) -> ref<False> :
   if i.closable? :
      val err = call-c clib/fclose(i.file)
      if err != 0 : throw(FileCloseException(linux-error-msg()))
   else : fatal("System Input Stream is not closable.")
   return false

lostanza defmethod get-char (i:ref<FileInputStream>) -> ref<Char|False> :
   val c = call-c clib/fgetc(i.file)
   if c == EOF :
      val err = call-c clib/ferror(i.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Char{c as byte}

lostanza defmethod get-byte (i:ref<FileInputStream>) -> ref<Byte|False> :
   val c = call-c clib/fgetc(i.file)
   if c == EOF :
      val err = call-c clib/ferror(i.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Byte{c as byte}

public defn get-int (i:InputStream) -> False|Int :
   defn get-byte! (i:InputStream) :
      match(get-byte(i)) :
         (b:Byte) : b
         (b:False) : fail()
   attempt :
      val b0 = to-int(get-byte!(i))
      val b1 = to-int(get-byte!(i))
      val b2 = to-int(get-byte!(i))
      val b3 = to-int(get-byte!(i))
      (b0) |
      (b1 << 8) |
      (b2 << 16) |
      (b3 << 24)

public defn get-long (i:InputStream) -> False|Long :
   defn get-int! (i:InputStream) :
      match(get-int(i)) :
         (x:Int) : x
         (x:False) : fail()
   attempt :
      val w0 = to-long(get-int!(i))
      val w1 = to-long(get-int!(i))
      (w0 & 0xFFFFFFFFL) |
      (w1 << 32L)

public defn get-float (i:InputStream) -> False|Float :
   match(get-int(i)) :
      (x:Int) : bits-as-float(x)
      (x:False) : false

public defn get-double (i:InputStream) -> False|Double :
   match(get-long(i)) :
      (x:Long) : bits-as-double(x)
      (x:False) : false

public defn slurp (filename:String) :
   val s = FileInputStream(filename)
   try :
      val buffer = StringBuffer()
      defn* loop () :
         match(get-char(s)) :
            (c:Char) :
               add(buffer, c)
               loop()
            (c:False) : false
      loop()
      to-string(buffer)
   finally : close(s)

public defn file-exists? (filename:String) :
   try :
      close(FileInputStream(filename))
      true
   catch (e:Exception) :
      false

;============================================================
;================== RandomAccessFiles =======================
;============================================================

public lostanza deftype RandomAccessFile :
  file: ptr<?>
  writable: ref<True|False>

public lostanza defn RandomAccessFile (filename:ref<String>, writable:ref<True|False>) -> ref<RandomAccessFile> :
  if writable == true :
    var file:ptr<?> = call-c clib/fopen(addr!(filename.chars), "r+b")
    if file == null :
      file = call-c clib/fopen(addr!(filename.chars), "w+b")
      if file == null : throw(FileOpenException(filename, linux-error-msg()))
      return new RandomAccessFile{file, writable}
    else :
      return new RandomAccessFile{file, writable}
  else :
    val file = call-c clib/fopen(addr!(filename.chars), "rb")
    if file == null : throw(FileOpenException(filename, linux-error-msg()))
    return new RandomAccessFile{file, writable}

public lostanza defn close (f:ref<RandomAccessFile>) -> ref<False> :
  val err = call-c clib/fclose(f.file)
  if err != 0 : throw(FileCloseException(linux-error-msg()))
  return false

public lostanza defn flush (f:ref<RandomAccessFile>) -> ref<False> :
  val err = call-c clib/fflush(f.file)
  if err != 0 : throw(FileFlushException(linux-error-msg()))
  return false

public lostanza defn writable? (f:ref<RandomAccessFile>) -> ref<True|False> :
  return f.writable

public lostanza defn length (f:ref<RandomAccessFile>) -> ref<Long> :
  return new Long{call-c clib/get_file_size(f.file)}

public lostanza defn position (f:ref<RandomAccessFile>) -> ref<Long> :
  return new Long{call-c clib/ftell(f.file)}

public lostanza defn time-modified (filename:ref<String>) -> ref<Long> :
  val t = call-c clib/file_time_modified(addr!(filename.chars))
  if t == 0 : throw(FileStatException(filename, linux-error-msg()))
  return new Long{t}

public lostanza defn set-length (f:ref<RandomAccessFile>, len:ref<Long>) -> ref<False> :
  val err = call-c clib/file_set_length(f.file, len.value)
  if err != 0 : throw(FileSetLengthException(linux-error-msg()))
  return false

public lostanza defn seek (f:ref<RandomAccessFile>, pos:ref<Long>) -> ref<False> :
  val err = call-c clib/file_seek(f.file, pos.value)
  if err != 0 : throw(FileSeekException(linux-error-msg()))
  return false

public lostanza defn skip (f:ref<RandomAccessFile>, pos:ref<Long>) -> ref<False> :
  val err = call-c clib/file_skip(f.file, pos.value)
  if err != 0 : throw(FileSeekException(linux-error-msg()))
  return false

public lostanza defn get-byte (f:ref<RandomAccessFile>) -> ref<Byte|False> :
  val c = call-c clib/fgetc(f.file)
  if c == EOF :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
    return false
  else :
    return new Byte{c as byte}   

public defn get-char (f:RandomAccessFile) -> Char|False :
  match(get-byte(f)) :
    (b:Byte) : to-char(b)
    (b:False) : b
      
public lostanza defn get-int (f:ref<RandomAccessFile>) -> ref<Int|False> :
  val b0 = call-c clib/fgetc(f.file)
  val b1 = call-c clib/fgetc(f.file)
  val b2 = call-c clib/fgetc(f.file)
  val b3 = call-c clib/fgetc(f.file)
  if b3 == EOF :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
    return false
  else :
    return new Int{
      (b0) |
      (b1 << 8) |
      (b2 << 16) |
      (b3 << 24)}

public lostanza defn get-long (f:ref<RandomAccessFile>) -> ref<Long|False> :
  val b0 = call-c clib/fgetc(f.file)
  val b1 = call-c clib/fgetc(f.file)
  val b2 = call-c clib/fgetc(f.file)
  val b3 = call-c clib/fgetc(f.file)
  val b4 = call-c clib/fgetc(f.file)
  val b5 = call-c clib/fgetc(f.file)
  val b6 = call-c clib/fgetc(f.file)
  val b7 = call-c clib/fgetc(f.file)
  if b7 == EOF :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
    return false
  else :
    return new Long{
      (b0) |
      (b1 << 8L) |
      (b2 << 16L) |
      (b3 << 24L) |
      (b4 << 32L) |
      (b5 << 40L) |
      (b6 << 48L) |
      (b7 << 56L)}

public defn get-float (f:RandomAccessFile) -> Float|False :
  match(get-int(f)) :
    (i:Int) : bits-as-float(i)
    (i:False) : false

public defn get-double (f:RandomAccessFile) -> Double|False :
  match(get-long(f)) :
    (i:Long) : bits-as-double(i)
    (i:False) : false

public lostanza defn fill (a:ref<ByteArray>, r:ref<Range>, f:ref<RandomAccessFile>) -> ref<Long> :
  ;Get range bounds
  ensure-index-range(a, r)
  val rb = range-bound(a, r)
  val b = get(rb, new Int{0}).value
  val e = get(rb, new Int{1}).value
  val len = e - b
  ;Read block
  val ptr = addr!(a.data) + b
  val n = call-c clib/file_read_block(f.file, ptr, len)   
  ;Check errors
  if n < len :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileReadException(linux-error-msg()))
  ;Return bytes read
  return new Long{n}

public defn fill (a:ByteArray, f:RandomAccessFile) -> Long :
  fill(a, 0 to false, f)

defn ensure-writable (f:RandomAccessFile) :  
  #if-defined(OPTIMIZE) :
    false
  #else :
    if not writable?(f) :
      fatal("RandomAccessFile is not writable.")

public lostanza defn put (f:ref<RandomAccessFile>, xs:ref<ByteArray>, r:ref<Range>) -> ref<False> :
  ensure-writable(f)
  ;Get range bounds
  ensure-index-range(xs, r)
  val rb = range-bound(xs, r)
  val b = get(rb, new Int{0}).value
  val e = get(rb, new Int{1}).value
  val len = e - b
  ;Write block
  val ptr = addr!(xs.data) + b
  val n = call-c clib/file_write_block(f.file, ptr, len)
  ;Check errors
  if n < len :
    val err = call-c clib/ferror(f.file)
    if err != 0 : throw(FileWriteException(linux-error-msg()))
  ;Done   
  return false

public defn put (f:RandomAccessFile, xs:ByteArray) -> False :
  put(f, xs, 0 to false)

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Byte>) -> ref<False> :
  ensure-writable(f)
  val r = call-c clib/fputc(x.value, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Char>) -> ref<False> :
  ensure-writable(f)
  val r = call-c clib/fputc(x.value, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Int>) -> ref<False> :
  ensure-writable(f)
  val fp = f.file   
  val xv = x.value
  call-c clib/fputc(xv as byte, f.file)
  call-c clib/fputc((xv >> 8) as byte, f.file)
  call-c clib/fputc((xv >> 16) as byte, f.file)
  val r = call-c clib/fputc((xv >> 24) as byte, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public lostanza defn put (f:ref<RandomAccessFile>, x:ref<Long>) -> ref<False> :
  ensure-writable(f)
  val fp = f.file   
  val xv = x.value
  call-c clib/fputc(xv as byte, f.file)
  call-c clib/fputc((xv >> 8L) as byte, f.file)
  call-c clib/fputc((xv >> 16L) as byte, f.file)
  call-c clib/fputc((xv >> 24L) as byte, f.file)
  call-c clib/fputc((xv >> 32L) as byte, f.file)
  call-c clib/fputc((xv >> 40L) as byte, f.file)
  call-c clib/fputc((xv >> 48L) as byte, f.file)
  val r = call-c clib/fputc((xv >> 56L) as byte, f.file)
  if r == EOF : throw(FileWriteException(linux-error-msg()))
  return false

public defn put (f:RandomAccessFile, x:Float) -> False :
  put(f, bits(x))

public defn put (f:RandomAccessFile, x:Double) -> False :
  put(f, bits(x))

;============================================================
;===================== ByteBuffer ===========================
;============================================================

public deftype ByteBuffer <: IndexedCollection<Byte> & OutputStream
public defmulti clear (b:ByteBuffer) -> False

public defn ByteBuffer (n:Int) -> ByteBuffer :
  ensure-non-negative("length", n)
  var buffer = ByteArray(n)
  var len = 0

  defn ensure-capacity (c:Int) :
    defn set-capacity (c:Int) :
      val buffer* = ByteArray(c)
      block-copy(len, buffer*, 0, buffer, 0)
      buffer = buffer*
    val cur-c = length(buffer)
    set-capacity(max(c, 2 * cur-c)) when c > cur-c

  new ByteBuffer :
    defmethod backing-array (this) :
      buffer
      
    defmethod put (this, c:Byte) :
      ensure-capacity(len + 1)
      buffer[len] = c
      len = len + 1      

    defmethod clear (this) :
      len = 0

    defmethod get (this, i:Int) :
      ensure-index-in-bounds(this, i)
      buffer[i]
       
    defmethod get (this, r:Range) :
      ensure-index-range(this, r)
      val [b, e] = range-bound(this, r)   
      buffer[b to e]

    defmethod set (this, i:Int, b:Byte) :
      if i == len :
        put(this, b)
      else :
        ensure-index-in-bounds(this, i)
        buffer[i] = b

    defmethod length (this) :
      len

defmulti backing-array (b:ByteBuffer) -> ByteArray
public lostanza defn data (b:ref<ByteBuffer>) -> ptr<byte> :
  return addr!(backing-array(b).data)

public defn ByteBuffer () :
  ByteBuffer(32)
  
defmethod print (b:ByteBuffer, c:Char) :
  put(b, to-byte(c))

defmethod print (o:OutputStream, b:ByteBuffer) :
  print(o, "[ByteBuffer: %_ bytes]" % [length(b)])

public defn OutputStream (b:ByteBuffer, i:Int) :
  var pos = i
  defn inc-pos () :
    val cur-pos = pos
    pos = pos + 1
    cur-pos
  new OutputStream :
    defmethod put (this, x:Byte) : b[inc-pos()] = x
    defmethod print (this, x:Char) : b[inc-pos()] = to-byte(x)

public defn InputStream (b:ByteBuffer, i:Int) :
  var pos = i
  defn inc-pos () :
    val cur-pos = pos
    pos = pos + 1
    cur-pos
  new InputStream :
    defmethod get-char (this) : to-char(b[inc-pos()]) when pos < length(b)
    defmethod get-byte (this) : b[inc-pos()] when pos < length(b)

public defn OutputStream (b:ByteBuffer) : OutputStream(b, 0)
public defn InputStream (b:ByteBuffer) : InputStream(b, 0)

;============================================================
;=================== StringBuffer ===========================
;============================================================

public deftype StringBuffer <: IndexedCollection<Char> & OutputStream

;                     Interface
;                     =========

public defmulti add (s:StringBuffer, c:Char) -> False
public defmulti add-all (s:StringBuffer, c:Seqable<Char>) -> False
public defmulti clear (s:StringBuffer) -> False

;               Abstract Implementation
;               =======================

defmethod add-all (s:StringBuffer, xs:Seqable<Char>) :
   do(add{s, _}, xs)

defmethod print (s:StringBuffer, c:Char) : add(s, c)
defmethod print (s:StringBuffer, cs:String) : add-all(s, cs)
defmethod print (s:StringBuffer, cs:StringBuffer) : add-all(s, cs)
defmethod print (s:StringBuffer, cs:CharArray) : add-all(s, cs)

defmethod print-all (s:StringBuffer, cs:String) : add-all(s, cs)
defmethod print-all (s:StringBuffer, cs:StringBuffer) : add-all(s, cs)
defmethod print-all (s:StringBuffer, cs:CharArray) : add-all(s, cs)

defmethod write (o:OutputStream, s:StringBuffer) :
   print(o, '"')
   for c in s do :
      escape-for-string(o, c)
   print(o, '"')

;                   Implementation
;                   ==============

public defn StringBuffer (n:Int) -> StringBuffer :
   ensure-non-negative("length", n)
   var buffer = CharArray(n)
   var len = 0

   defn ensure-capacity (c:Int) :
      defn set-capacity (c:Int) :
         val buffer* = CharArray(c)
         block-copy(len, buffer*, 0, buffer, 0)
         buffer = buffer*
      val cur-c = length(buffer)
      set-capacity(max(c, 2 * cur-c)) when c > cur-c

   new StringBuffer :
      defmethod add (this, c:Char) :
         ensure-capacity(len + 1)
         buffer[len] = c
         len = len + 1

      defmethod add-all (this, xs:Seqable<Char> & Lengthable) :
         val n = length(xs)
         ensure-capacity(len + n)
         for (x in xs, i in 0 to n) do :
            buffer[len + i] = x
         len = len + n

      defmethod clear (this) :
         len = 0

      defmethod get (this, i:Int) :
         ensure-index-in-bounds(this, i)
         buffer[i]
         
      defmethod get (this, r:Range) :
         ensure-index-range(this, r)
         val [b, e] = range-bound(this, r)   
         buffer[b to e]   

      defmethod set (this, i:Int, c:Char) :
         if i == len :
            add(this, c)
         else :
            ensure-index-in-bounds(this, i)
            buffer[i] = c

      defmethod length (this) :
         len

      defmethod to-string (this) :
         buffer[0 to len] as String

public defn StringBuffer () :
   StringBuffer(32)

;============================================================
;==================== Remove File ===========================
;============================================================

public lostanza defn delete-file (path:ref<String>) -> ref<False> :
   val r = call-c clib/remove(addr!(path.chars))
   if r == -1 : throw(FileDeletionError(path, linux-error-msg()))
   return false

public deftype FileDeletionError <: Exception
public defn FileDeletionError (path:String, msg:String) :
   new FileDeletionError :
      defmethod print (o:OutputStream, this) :
         print{o, _} $
         "Error when attempting to delete %_. %_." % [path, msg]

;============================================================
;===================== FilePaths ============================
;============================================================

public lostanza defn resolve-path (path:ref<String>) -> ref<String|False> :
   val rpath = call-c clib/resolve_path(addr!(path.chars))
   if rpath == null :
      return false
   else :
      val s = String(rpath)
      call-c clib/free(rpath)
      return s

public defn norm-path (path) -> String :
   #if-defined(PLATFORM-WINDOWS) :
      replace(to-string(path), '/', '\\')
   #else :
      to-string(path)

;============================================================
;================ Environment Variables =====================
;============================================================

public lostanza defn get-env (name:ref<String>) -> ref<String|False> :
  val value = call-c clib/getenv(addr!(name.chars))
  if value == null : return false
  else : return String(value)

public lostanza defn set-env (name:ref<String>, value:ref<String>, overwrite:ref<True|False>) -> ref<False> :
  var ov:int = 0
  if overwrite == true : ov = 1
  val r = call-c clib/setenv(addr!(name.chars), addr!(value.chars), ov)
  if r != 0 : throw(SetEnvException(name, value, linux-error-msg()))
  return false

public defn set-env (name:String, value:String) :
  set-env(name, value, true)

public lostanza defn unset-env (name:ref<String>) -> ref<False> :
  val r = call-c clib/unsetenv(addr!(name.chars))
  if r != 0 : throw(UnsetEnvException(name, linux-error-msg()))
  return false

public defstruct SetEnvException <: Exception :
  name: String
  value: String
  cause: String

defmethod print (o:OutputStream, e:SetEnvException) :
   print(o, "Could not set environment variable %_ to %~. %_." % [name(e), value(e), cause(e)])

public defstruct UnsetEnvException <: Exception :
  name: String
  cause: String
defmethod print (o:OutputStream, e:UnsetEnvException) :
  print(o, "Could not unset environment variable %_. %_." % [name(e), cause(e)])

;============================================================
;================== Exit System =============================
;============================================================

public lostanza defn exit (code:ref<Int>) -> ref<Void> :
   call-c clib/exit(code.value)
   return null as ref<Void>

;============================================================
;===================== Exceptions ===========================
;============================================================

public deftype Exception

public defn Exception (msg) :
   new Exception :
      defmethod print (o:OutputStream, this) :
         print(o, msg)

var CURRENT-EXCEPTION-HANDLER : Exception -> Void =
   fn (e:Exception) :
      fatal(e)

defmethod print (o:OutputStream, e:Exception) :
   print(o, "Exception")

public defn throw (e:Exception) :
   CURRENT-EXCEPTION-HANDLER(e)

defstruct ExceptionResult : (exception: Exception)
defstruct NormalResult : (result)

public defn with-exception-handler<?T> (body: () -> ?T,
                                        handler: Exception -> ?T) -> T :
   val r = label<ExceptionResult|NormalResult> break :
      let-var CURRENT-EXCEPTION-HANDLER = break{ExceptionResult(_)} :
         NormalResult(body())
   match(r) :
      (r:ExceptionResult) : handler(exception(r))
      (r:NormalResult) : result(r)

public defn with-finally<?T> (body: () -> ?T, finally: (True|False) -> ?) -> T :
   var entered? = false
   dynamic-wind(
      fn () :
         fatal("Cannot re-enter body with finally clause.") when entered?
         entered? = true
      body
      finally)

;============================================================
;============== Input/Output Exceptions =====================
;============================================================

public deftype IOException <: Exception

public defstruct FileStatException <: IOException :
  filename: String
  cause: String

defmethod print (o:OutputStream, e:FileStatException) :
  print(o, "Error occurred when attempting to read statistics of file %_. %_." % [
    filename(e), cause(e)])

public defstruct FileOpenException <: IOException :
   filename: String
   cause: String

defmethod print (o:OutputStream, e:FileOpenException) :
   print(o, "Error occurred when attempting to open file %_. %_." % [filename(e), cause(e)])

public defstruct FileCloseException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileCloseException) :
   print(o, "Error occurred when attempting to close file. %_." % [cause(e)])

public defstruct FileFlushException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileFlushException) :
   print(o, "Error occurred when attempting to flush file. %_." % [cause(e)])

public defstruct FileReadException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileReadException) :
   print(o, "Error occurred when attempting to read from file. %_." % [cause(e)])

public defstruct FileWriteException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileWriteException) :
   print(o, "Error occurred when attempting to write to file. %_." % [cause(e)])

public defstruct FileSeekException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileSeekException) :
   print(o, "Error occurred when attempting to seek in file. %_." % [cause(e)])

public defstruct FileSetLengthException <: IOException :
   cause: String

defmethod print (o:OutputStream, e:FileSetLengthException) :
   print(o, "Error occurred when attempting to seek in file. %_." % [cause(e)])

;============================================================
;================ String Input Streams ======================
;============================================================

public deftype StringInputStream <: InputStream & Lengthable

;                       Interface
;                       =========

public defmulti peek? (s:StringInputStream, i:Int) -> False|Char
public defmulti info (s:StringInputStream) -> FileInfo
public defmulti get-chars (s:StringInputStream, n:Int) -> String


;                Abstract Implementations
;                ========================

public defn peek? (s:StringInputStream) :
   peek?(s, 0)

public defn peek (s:StringInputStream, i:Int) :
   match(peek?(s, i)) :
      (c:Char) : c
      (c:False) : fatal("No more characters in stream.")

public defn peek (s:StringInputStream) :
   peek(s, 0)

;                   Implementation
;                   ==============

public defn StringInputStream (string:String, filename:String) :
   var start = 0
   var line = 1
   var column = 0
   val n = length(string)

   new StringInputStream :
      defmethod get-char (this) :
         if start < n :
            val c = string[start]
            start = start + 1
            if c == '\n' :
               line = line + 1
               column = 0
            else :
               column = column + 1
            c

      defmethod get-chars (this, n:Int) :
         #if-not-defined(OPTIMIZE) :
            if length(this) < n :
               fatal("Cannot eat %_ chars from StringInputStream with %_ chars remaining." % [n, length(this)])
         val ret = string[start to start + n]
         do(get-char{this}, 0 to n)
         ret

      defmethod get-byte (this) :
         match(get-char(this)) :
            (c:Char) : to-byte(c)
            (c:False) : false

      defmethod info (this) :
         FileInfo(filename, line, column)

      defmethod peek? (this, i:Int) :
         string[start + i] when start + i < n

      defmethod length (this) :
         n - start

public defn StringInputStream (string:String) :
   StringInputStream(string, "UnnamedStream")

;============================================================
;======================= Chars ==============================
;============================================================

public lostanza defn digit? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= '0' and b <= '9' : return true
   else : return false

public lostanza defn letter? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'a' and b <= 'z' : return true
   else if b >= 'A' and b <= 'Z' : return true
   else : return false

public lostanza defn upper-case? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'A' and b <= 'Z' : return true
   else : return false

public lostanza defn lower-case? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'a' and b <= 'z' : return true
   else : return false

public lostanza defn lower-case (c:ref<Char>) -> ref<Char> :
   val cv = c.value
   if cv >= 'A' and cv <= 'Z' : return new Char{cv - 'A' + 'a'}
   else : return c

public lostanza defn upper-case (c:ref<Char>) -> ref<Char> :
   val cv = c.value
   if cv >= 'a' and cv <= 'z' : return new Char{cv - 'a' + 'A'}
   else : return c

;============================================================
;===================== Tuples ===============================
;============================================================

protected lostanza defn void-tuple (n:long) -> ref<Tuple> :
  val x = new Tuple{n}
  for (var i:long = 0, i < n, i = i + 1) :
    x.items[i] = sentinel
  return x   

public lostanza defn Tuple<?T> (n:ref<Int>, x:ref<?T>) -> ref<Tuple<T>> :
   ensure-non-negative-length(n)
   val len = n.value
   val t = new Tuple<T>{len}
   for (var i:long = 0, i < len, i = i + 1) :
      t.items[i] = x
   return t

lostanza defn set<?T> (x:ref<Tuple<?T>>, i:ref<Int>, v:ref<T>) -> ref<False> :
   ensure-index-in-bounds(x, i)
   x.items[i.value] = v
   return false

public lostanza defn get<?T> (x:ref<Tuple<?T>>, i:ref<Int>) -> ref<T> :
   ensure-index-in-bounds(x, i)
   return x.items[i.value]

public defn get<?T> (xs:Tuple<?T>, r:Range) -> Tuple<T> :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])

public defn empty? (t:Tuple) :
   length(t) == 0

public defn map<?T,?R> (f:T -> ?R, xs:Tuple<?T>) -> Tuple<R> :
   to-tuple(seq(f, xs))

;============================================================
;===================== Strings ==============================
;============================================================

public lostanza defn String (chars:ptr<byte>) -> ref<String> :
  val len = call-c clib/strlen(chars)
  return String(len, chars)

public lostanza defn String (len:long, c:byte) -> ref<String> :
  val s = String(len)
  for (var i:long = 0, i < len, i = i + 1) :
    s.chars[i] = c
  s.chars[len] = 0 as byte
  return s

public lostanza defn String (len:ref<Int>, c:ref<Char>) -> ref<String> :
  ensure-non-negative-length(len)
  return String(len.value, c.value)

public lostanza defn get (s:ref<String>, i:ref<Int>) -> ref<Char> :
  ensure-index-in-bounds(s, i)
  return new Char{s.chars[i.value]}

lostanza defn set (s:ref<String>, i:ref<Int>, c:ref<Char>) -> ref<False> :
  ensure-index-in-bounds(s, i)
  s.chars[i.value] = c.value
  return false

;============================================================
;======================= String Library =====================
;============================================================

lostanza defn strlen (s:ref<String>) -> long :
  return s.length - 1

lostanza defn copy (dst:ref<String>, src:ref<String>, dst-i:long) -> ref<False> :
   val src-len = strlen(src)
   call-c clib/memcpy(addr!(dst.chars[dst-i]), addr!(src.chars), src-len)
   return false

public defn matches? (a:String, start:Int, b:String) :
   ensure-length-in-bounds(a, start)
   val an = length(a)
   val bn = length(b)
   if (start + bn) <= an :
      for i in 0 to bn all? :
         a[start + i] == b[i]

public defn prefix? (s:String, prefix:String) :
   matches?(s, 0, prefix)

public defn suffix? (s:String, suffix:String) :
   val start = max(0, length(s) - length(suffix))
   matches?(s, start, suffix)

public defn empty? (s:String) :
   length(s) == 0

lostanza defn substring! (str:ref<String>, b:ref<Int>, e:ref<Int>) -> ref<String> :
   val s = b.value
   val n = e.value - s
   val ret = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      ret.chars[i] = str.chars[i + s]
   ret.chars[n] = 0 as byte
   return ret

public defn get (s:String, r:Range) -> String :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   substring!(s, b, e)

public lostanza defn append (a:ref<String>, b:ref<String>) -> ref<String> :
   val al = strlen(a)
   val bl = strlen(b)
   val n = al + bl
   val s = String(n)
   copy(s, a, 0)
   copy(s, b, al)
   s.chars[n] = 0 as byte
   return s

public lostanza defn append-all (xs:ref<Seqable<String>>) -> ref<String> :
   match(xs) :
      (xs:ref<Collection<String>>) :
         val len = sum(seq(fn(length), xs))
         val ret = String(len.value)
         val xs-seq = to-seq(xs)
         var accum : long = 0
         while empty?(xs-seq) == false :
            val s = next(xs-seq)
            copy(ret, s, accum)
            accum = accum + strlen(s)
         ret.chars[len.value] = 0 as byte
         return ret
      (xs:ref<Seqable<String>>) :
         return append-all(to-vector<String>(xs))

public defn string-join (xs:Seqable) -> String :
   val s = StringBuffer()
   print-all(s, xs)
   to-string(s)

public defn string-join (xs:Seqable, j) -> String :
   string-join(join(xs, j))

public defn index-of-char (s:String, r:Range, c:Char) -> False|Int :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   for i in b to e find :
      s[i] == c

public defn index-of-char (s:String, c:Char) -> False|Int :
   index-of-char(s, 0 to false, c)

public defn index-of-chars (a:String, r:Range, b:String) -> False|Int :
   ensure-index-range(a, r)
   val [s, e] = range-bound(a, r)
   val an = e - s
   val bn = length(b)
   if bn <= an :
      for i in s through (e - bn) find :
         matches?(a, i, b)

public defn index-of-chars (a:String, b:String) -> False|Int :
   index-of-chars(a, 0 to false, b)

public defn last-index-of-char (s:String, r:Range, c:Char) -> False|Int :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   for i in (e - 1) through b by -1 find :
      s[i] == c

public defn last-index-of-char (s:String, c:Char) -> False|Int :
   last-index-of-char(s, 0 to false, c)

public defn last-index-of-chars (a:String, r:Range, b:String) -> False|Int :
   ensure-index-range(a, r)
   val [s, e] = range-bound(a, r)
   val an = e - s
   val bn = length(b)
   if bn <= an :
      for i in (e - bn) through s by -1 find :
         matches?(a, i, b)

public defn last-index-of-chars (a:String, b:String) -> False|Int :
   last-index-of-chars(a, 0 to false, b)

public lostanza defn replace (s:ref<String>, c1:ref<Char>, c2:ref<Char>) -> ref<String> :
   val b1 = c1.value
   val b2 = c2.value
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc == b1 : r.chars[i] = b2
      else : r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public defn replace (str:String, s1:String, s2:String) -> String :
   fatal("String to be replaced cannot be empty.") when empty?(s1)
   val buf = StringBuffer(length(str))
   val n = length(str)
   val s1n = length(s1)
   defn* loop (i:Int) :
      if i < n :
         if matches?(str, i, s1) :
            print(buf, s2)
            loop(i + s1n)
         else :
            print(buf, str[i])
            loop(i + 1)
   loop(0)
   to-string(buf)

public defn split (str:String, s:String) -> Seq<String> :
   generate<String> :
      val strl = length(str)
      val sl = length(s)
      defn loop (b:Int) :
         if b < strl :
            match(index-of-chars(str, b to false, s)) :
               (i:Int) :
                  yield(str[b to i])
                  loop(i + sl)
               (i:False) :
                  yield(str[b to false])
      loop(0)

public defn split (str:String, s:String, n:Int) -> Seq<String> :
   if n <= 0 :
      fatal("Maximum number of splits (%_) is not positive." % [n])
   generate<String> :
      val strl = length(str)
      val sl = length(s)
      defn* loop (b:Int, n:Int) :
         if b < strl :
            if n > 1 :
               match(index-of-chars(str, b to false, s)) :
                  (i:Int) :
                     yield(str[b to i])
                     loop(i + sl, n - 1)
                  (i:False) :
                     yield(str[b to false])
            else :
               yield(str[b to false])
      loop(0, n)

public lostanza defn lower-case (s:ref<String>) -> ref<String> :
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc >= 'A' and sc <= 'Z' :
         r.chars[i] = sc - 'A' + 'a'
      else :
         r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public lostanza defn upper-case (s:ref<String>) -> ref<String> :
   val n = strlen(s)
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc >= 'a' and sc <= 'z' :
         r.chars[i] = sc - 'a' + 'A'
      else :
         r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public defn trim (pred: Char -> True|False, s:String) :
   defn not-pred (c:Char) : not pred(c)
   match(index-when(not-pred, s)) :
      (i:Int) :
         val n = length(s)
         val j = for i in (n - 1) through 0 by -1 find! :
            not-pred(s[i])
         s[i through j]
      (i:False) : ""

public defn trim (s:String) -> String :
   defn whitespace? (c:Char) :
      (c == ' ') or
      (c == '\n') or
      (c == '\t') or
      (c == '\b') or
      (c == '\r')
   trim(whitespace?, s)

;============================================================
;======================= Lists ==============================
;============================================================

public defn cons<?T> (x:?T, y:?T, t:List<?T>) -> List<T> :
   cons(x, cons(y, t))

public defn cons<?T> (x:?T, y:?T, z:?T, t:List<?T>) -> List<T> :
   cons(x, cons(y, cons(z, t)))

public defn List<?T> (x:?T) -> List<T> :
   cons(x, List())

public defn List<?T> (x:?T, y:?T) -> List<T> :
   cons(x, cons(y, List()))

public defn List<?T> (x:?T, y:?T, z:?T) -> List<T> :
   cons(x, cons(y, cons(z, List())))

public defn List<?T> (w:?T, x:?T, y:?T, z:?T) -> List<T> :
   cons(w, cons(x, cons(y, cons(z, List()))))

;============================================================
;====================== List Library ========================
;============================================================

public defn* get<?T> (xs:List<?T>, i:Int) -> T :
   if i == 0 : head(xs)
   else : get(tail(xs), i - 1)

public defn headn<?T> (l:List<?T>, n:Int) -> List<T> :
   if n == 0 : List()
   else : cons(head(l), headn(tail(l), n - 1))

public defn* tailn<?T> (l:List<?T>, n:Int) -> List<T> :
   if n == 0 : l
   else : tailn(tail(l), n - 1)

public defn append<?T> (xs:Seqable<?T>, ys:List<?T>) -> List<T> :
   if empty?(ys) :
      to-list(xs)
   else :
      val items = to-vector<T>(xs)
      defn* loop (i:Int, tail:List<T>) :
         if i >= 0 : loop(i - 1, cons(items[i], tail))
         else : tail
      loop(length(items) - 1, ys)   

public defn append-all<?T> (xs:Seqable<List<?T>>) -> List<T> :
   val xs-seq = to-seq(xs)
   defn loop () :
      if empty?(xs-seq) : List()
      else : append(next(xs-seq), loop())
   loop()

public defn seq-append<?T,?R> (f: T -> List<?R>, xs:Seqable<?T>) -> List<R> :
   append-all(seq(f, xs))

public defn seq-append<?T,?S,?R> (f: (T,S) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> List<R> :
   append-all(seq(f, xs, ys))

public defn seq-append<?T,?S,?U,?R> (f: (T,S,U) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R> :
   append-all(seq(f, xs, ys, zs))

public defn map<?T,?R> (f: T -> ?R, xs:List<?T>) -> List<R> :
  let loop (xs:List<T> = xs, i:Int = 0) :
    if i < 16 :
      if empty?(xs) : List()
      else : cons(f(head(xs)), loop(tail(xs), i + 1))
    else : to-list(seq(f, xs))

public defn map<?T,?S,?R> (f: (T,S) -> ?R, xs:List<?T>, ys:Seqable<?S>) -> List<R> :
   to-list(seq(f, xs, ys))

public defn map<?T,?S,?U,?R> (f: (T,S,U) -> ?R, xs:List<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R> :
   to-list(seq(f, xs, ys, zs))

public defn transpose<?T> (xs:List<List<?T>>) -> List<List<T>> :
   if empty?(xs) :
      List()
   else if any?(empty?, xs) :
      List()
   else :
      val hs = map(head, xs)
      val ts = map(tail, xs)
      cons(hs, transpose(ts))

public defn last<?T> (xs:List<?T>) -> T :
   fatal("Empty List") when empty?(xs)
   defn* loop (xs:List<T>) :
      if empty?(tail(xs)) : head(xs)
      else : loop(tail(xs))
   loop(xs)

public defn but-last<?T> (xs:List<?T>) -> List<T> :
   fatal("Empty List") when empty?(xs)
   defn* loop (xs:List<T>) :
      if empty?(tail(xs)) : List()
      else : cons(head(xs), but-last(tail(xs)))
   loop(xs)

public defn reverse<?T> (xs:List<?T>) -> List<T> :
   if empty?(xs) :
      xs
   else :
      var accum = List()
      for x in xs do :
         accum = cons(x, accum)
      accum

;============================================================
;====================== Formatting ==========================
;============================================================

public deftype Printable

public defn modulo (format:String, args:Seqable) -> Printable :
  new Printable :
    defmethod* print (o:OutputStream, this) :
      val seq = to-seq(args)
      defn next-arg () :
        #if-not-defined(OPTIMIZE) :
          fatal("Format string %~ is expecting more arguments." % [format]) when empty?(seq)
        next(seq)
      defn next-seq () :
        val x = next-arg()
        #if-not-defined(OPTIMIZE) :
          if x is-not Seqable :
            fatal("Format string %~ is expecting a sequence, but received: %~." % [format, x])
        x

      val n = length(format)
      defn* loop (i:Int) :
        if i < n :
          val c = format[i]
          if c == '%' :
            if i + 1 < n :
              val modifier = format[i + 1]
              switch {modifier == _} :
                '_' : print(o, next-arg())
                '*' : print-all(o, next-seq())
                ',' : print-all(o, join(next-seq(), ", "))
                's' : print-all(o, join(next-seq(), " "))
                'n' : print-all(o, join(next-seq(), "\n"))
                '~' : write(o, next-arg())
                '@' : write-all(o, next-seq())
                '%' : print(o, c)
                else : fatal("Invalid argument specifier %~ in format string %~." % [modifier, format])
              loop(i + 2)
            else :
              fatal("Incomplete argument specifier %% at end of format string %~." % [format])
          else :
            print(o, c)
            loop(i + 1)
        else :
          if not empty?(seq) :
            fatal("Unexpected end of format string %~. More arguments remaining." % [format])
      loop(0)

;============================================================
;=================== Indented Streams =======================
;============================================================

public deftype IndentedStream <: OutputStream
public defmulti stream (s:IndentedStream) -> OutputStream
public defmulti indent (s:IndentedStream) -> Int

public defn IndentedStream (o:OutputStream) :
  IndentedStream(o, 2)

public defn IndentedStream (o:OutputStream, n:Int) :
   match(o) :
      (o:IndentedStream) :
         IndentedStream(stream(o), n + indent(o))
      (o) :
         var start-of-line? = true
         val spaces = String(n, ' ')
         defn put (c:Char) :
            if start-of-line? :
               print(o, spaces)
               start-of-line? = false
            print(o, c)
            if c == '\n' :
               start-of-line? = true

         new IndentedStream :
            defmethod stream (this) : o
            defmethod indent (this) : n
            defmethod print (this, c:Char) : put(c)

public defn do-indented<?T> (f: IndentedStream -> ?T, o:OutputStream) :
   f(IndentedStream(o))

public defn indented<?T> (f: () -> ?T) :
   let-var CURRENT-OUTPUT-STREAM = IndentedStream(CURRENT-OUTPUT-STREAM) :
      f()

;============================================================
;===================== Generators ===========================
;============================================================

public defn Generator<T> (thunk : (T -> False, (T -> Void) & (() -> Void)) -> ?) -> Seq<T> :
   ;State
   var item = sentinel

   ;Generator Coroutine
   val co = Coroutine<False, T|Sentinel> $ fn (co, x0) :
      defn co-yield (x:T) :
         suspend(co, x)
      val co-break = multifn :
         (x:T) : break(co, x)
         () : break(co, sentinel)
      thunk(co-yield, co-break)
      sentinel

   ;Fill state: Returns whether empty
   defn fill () :
      if (item is Sentinel) and open?(co) :
         item = resume(co, false)
      item is Sentinel

   ;Peek
   defn peek () :
      if item is Sentinel :
         fatal("Empty Sequence")
      item as T

   ;Empty bucket
   defn empty () :
      val x = peek()
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         peek()
      defmethod empty? (this) :
         fill()
      defmethod free (this) :
         close(co) when open?(co)

;============================================================
;====================== Labels ==============================
;============================================================

public defn* LabeledScope<T> (thunk: (T -> Void) -> T) -> T :
   val c = Coroutine<False,T> $ fn* (c, x0) :
      thunk(break{c, _})
   resume(c, false)

public defn* LabeledScope* (thunk: (() -> Void) -> ?) -> False :
   val c = Coroutine<False,False> $ fn* (c, x0) :
      thunk(fn () : break(c, false))
      false
   resume(c, false)   

;============================================================
;================== Failure Handler =========================
;============================================================

var CURRENT-FAILURE-HANDLER : () -> Void =
   fn () :
      fatal("Uncaught failure")

public defn fail () :
   CURRENT-FAILURE-HANDLER()

public defn with-attempt<?T> (conseq: () -> ?T, alt: () -> ?T) :
   val result = label<Maybe<T>> return :
      let-var CURRENT-FAILURE-HANDLER = fn* () : return(None()) :
         One(conseq())
   match(result) :
      (r:One<T>) : value(r)
      (r:None) : alt()

;============================================================
;=================== IndexedCollections =====================
;============================================================

public deftype IndexedCollection<T> <: Lengthable

;                       Interface
;                       =========

public defmulti get<?T> (a:IndexedCollection<?T>, i:Int) -> T
public defmulti set<?T> (a:IndexedCollection<?T>, i:Int, v:T) -> False
public defmulti get<?T> (a:IndexedCollection<?T>, r:Range) -> Collection<T>
public defmulti set<?T> (a:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False
public defmulti set-all<?T> (a:IndexedCollection<?T>, r:Range, v:T) -> False
public defmulti map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False

;                 Abstract Implementations
;                 ========================

public defn empty? (v:IndexedCollection) :
   length(v) == 0

defmethod print (o:OutputStream, a:IndexedCollection) -> False :
   print(o, "[%@]" % [a])

defmethod map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False :
   for i in 0 to length(xs) do :
      xs[i] = f(xs[i])

defmethod get<?T> (xs:IndexedCollection<?T>, r:Range) -> Tuple<T> :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])

defmethod set<?T> (xs:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   val vs-seq = to-seq(vs)
   for i in b to e do : xs[i] = next(vs-seq)

defmethod set-all<?T> (xs:IndexedCollection<?T>, r:Range, v:T) -> False :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   for i in b to e do : xs[i] = v

public defn reverse!<?T> (xs:IndexedCollection<?T>) -> False :
   val n = length(xs)
   for i in 0 to n / 2 do :
      val j = n - 1 - i
      val xi = xs[i]
      val xj = xs[j]
      xs[i] = xj
      xs[j] = xi

;                       Sorting
;                       =======

public defn qsort!<?T> (xs:IndexedCollection<?T>, is-less?:(T,T) -> True|False) -> False :
   ;Random
   val rand = Random(0L)
   
   ;Swap element i with element j
   defn swap (i:Int, j:Int) :
      if i != j :
         val xi = xs[i]
         val xj = xs[j]
         xs[i] = xj
         xs[j] = xi

   ;Rearrange elements from b to e, such that the first elements is less than pivot.
   ;Returns a s.t. all elements from b to a are less than pivot.
   defn partition (b:Int, e:Int, pivot:T) :
      defn* loop (a:Int, b:Int) -> Int :
         if b < e :
            val xb = xs[b]
            if is-less?(xb, pivot) :
               swap(a, b)
               loop(a + 1, b + 1)
            else : loop(a, b + 1)
         else : a
      loop(b, b)

   ;Driver
   defn* sort (b:Int, e:Int) :
      val n = e - b
      if n > 2 :
         swap(next-int(rand,b to e), e - 1) when n > 10
         val e1 = partition(b, e - 1, xs[e - 1])
         swap(e1, e - 1)
         sort(b, e1)
         sort(e1 + 1, e)
      else if n == 2 :
         swap(b, b + 1) when is-less?(xs[b + 1], xs[b])

   sort(0, length(xs))

public defn qsort!<?T> (xs:IndexedCollection<?T>, cmp:(T,T) -> Int) -> False :
   ;Random
   val rand = Random(0L)
   
   ;Swap element i with element j
   defn swap (i:Int, j:Int) :
      if i != j :
         val xi = xs[i]
         val xj = xs[j]
         xs[i] = xj
         xs[j] = xi

   ;Rearrange elements from b to e, such that:
   ;   b to lt is less than v
   ;   lt to gt is equal to v
   ;   gt to e is greater than v
   ;Returns [lt, gt]
   defn partition (b:Int, e:Int, pivot:T) -> [Int, Int] :      
      defn* loop (lt:Int, gt:Int, i:Int) :         
         if i < gt :
            val c = cmp(xs[i], pivot)
            if c < 0 :
               swap(i, lt)
               loop(lt + 1, gt, i + 1)
            else if c > 0 :
               swap(i, gt - 1)
               loop(lt, gt - 1, i)
            else :
               loop(lt, gt, i + 1)
         else :
            [lt, gt]            
      loop(b, e, b)      

   ;Driver
   defn* sort (b:Int, e:Int) :
      val n = e - b
      if n > 2 :
         val [lt, gt] = partition(b, e, xs[next-int(rand, b to e)])
         sort(b, lt)
         sort(gt, e)
      else if n == 2 :
         swap(b, b + 1) when cmp(xs[b + 1], xs[b]) < 0

   sort(0, length(xs))

public defn qsort!<?T> (xs:IndexedCollection<?T&Comparable<T>>) -> False :
   qsort!(xs, compare)

public defn qsort!<?T,?S> (key:T -> ?S&Comparable<S>, xs:IndexedCollection<?T>) -> False :
   qsort!(xs, compare{key(_), key(_)})

;                        Non-Destructive Sorting
;                        =======================

val SORT-BUFFER = Vector<?>()
defn clear-sort-buffer () :
  val ret = to-tuple(SORT-BUFFER)
  clear(SORT-BUFFER)
  ret

public defn qsort<?T> (coll:Seqable<?T>, is-less?:(T,T) -> True|False) -> Tuple<T> :
  add-all(SORT-BUFFER, coll)
  qsort!(SORT-BUFFER, is-less?)
  clear-sort-buffer()

public defn qsort<?T> (coll:Seqable<?T>, cmp:(T,T) -> Int) -> Tuple<T> :
  add-all(SORT-BUFFER, coll)
  qsort!(SORT-BUFFER, cmp)
  clear-sort-buffer()

public defn qsort<?T> (coll:Seqable<?T&Comparable<T>>) -> Tuple<T> :
  add-all(SORT-BUFFER, coll)
  qsort!(SORT-BUFFER)
  clear-sort-buffer()

public defn qsort<?T,?S> (key:T -> ?S&Comparable<S>, coll:Seqable<?T>) -> Tuple<T> :
  add-all(SORT-BUFFER, coll)
  qsort!(key as ? -> ?, SORT-BUFFER)
  clear-sort-buffer()  

;                       Lazy Sorting
;                       ============

public defn lazy-qsort<?T> (coll:Seqable<?T>, is-less?:(T,T) -> True|False) -> Collection<T> & Lengthable :
   ;Random
   val rand = Random(0L)

   ;Convert to a vector
   val xs = to-vector<T>(coll)

   ;Sort Progress
   defn sort-progress () :
      generate<Int> :
         ;Swap element i with element j
         defn swap (i:Int, j:Int) :
            if i != j :
               val xi = xs[i]
               val xj = xs[j]
               xs[i] = xj
               xs[j] = xi

         ;Rearrange elements from b to e, such that the first elements is less than pivot.
         ;Returns a s.t. all elements from b to a are less than pivot.
         defn partition (b:Int, e:Int, pivot:T) :
            defn* loop (a:Int, b:Int) -> Int :
               if b < e :
                  val xb = xs[b]
                  if is-less?(xb, pivot) :
                     swap(a, b)
                     loop(a + 1, b + 1)
                  else : loop(a, b + 1)
               else : a
            loop(b, b)

         ;Driver
         defn* sort (b:Int, e:Int) :
            val n = e - b
            if n > 2 :
               swap(next-int(rand, b to e), e - 1) when n > 10
               val e1 = partition(b, e - 1, xs[e - 1])
               swap(e1, e - 1)
               sort(b, e1)
               yield(e1 + 1)
               sort(e1 + 1, e)
            else if n == 2 :
               swap(b, b + 1) when is-less?(xs[b + 1], xs[b])

         sort(0, length(xs))
         break(length(xs))

   ;Ensuring Progress
   var sorted = 0
   val sorter = sort-progress()
   defn* ensure-sorted (n:Int) :
      if sorted < n :
         sorted = next(sorter)
         ensure-sorted(n)

   ;Return object
   new Collection<T> & Lengthable :
      defmethod length (this) :
         length(xs)
      defmethod to-seq (this) :
         for i in 0 to length(xs) seq :
            ensure-sorted(i + 1)
            xs[i]


public defn lazy-qsort<?T> (coll:Seqable<?T>, cmp:(T,T) -> Int) -> Collection<T> & Lengthable :
   ;Random
   val rand = Random(0L)
   
   ;Convert to a vector
   val xs = to-vector<T>(coll)

   ;Sort Progress
   defn sort-progress () :
      generate<Int> :
         ;Swap element i with element j
         defn swap (i:Int, j:Int) :
            if i != j :
               val xi = xs[i]
               val xj = xs[j]
               xs[i] = xj
               xs[j] = xi

         ;Rearrange elements from b to e, such that:
         ;   b to lt is less than v
         ;   lt to gt is equal to v
         ;   gt to e is greater than v
         ;Returns [lt, gt]
         defn partition (b:Int, e:Int, pivot:T) -> [Int, Int] :      
            defn* loop (lt:Int, gt:Int, i:Int) :         
               if i < gt :
                  val c = cmp(xs[i], pivot)
                  if c < 0 :
                     swap(i, lt)
                     loop(lt + 1, gt, i + 1)
                  else if c > 0 :
                     swap(i, gt - 1)
                     loop(lt, gt - 1, i)
                  else :
                     loop(lt, gt, i + 1)
               else :
                  [lt, gt]            
            loop(b, e, b)      

         ;Driver
         defn* sort (b:Int, e:Int) :
            val n = e - b
            if n > 2 :
               val [lt, gt] = partition(b, e, xs[next-int(rand,b to e)])
               sort(b, lt)
               yield(gt)
               sort(gt, e)
            else if n == 2 :
               swap(b, b + 1) when cmp(xs[b + 1], xs[b]) < 0

         sort(0, length(xs))
         break(length(xs))

   ;Ensuring Progress
   var sorted = 0
   val sorter = sort-progress()
   defn* ensure-sorted (n:Int) :
      if sorted < n :
         sorted = next(sorter)
         ensure-sorted(n)

   ;Return object
   new Collection<T> & Lengthable :
      defmethod length (this) :
         length(xs)
      defmethod to-seq (this) :
         for i in 0 to length(xs) seq :
            ensure-sorted(i + 1)
            xs[i]

public defn lazy-qsort<?T> (coll:Seqable<?T&Comparable<T>>) :
   lazy-qsort(coll, compare)

public defn lazy-qsort<?T,?S> (key:T -> ?S&Comparable<S>, coll:Seqable<?T>) :
   lazy-qsort(coll, compare{key(_), key(_)})

;============================================================
;======================= Arrays =============================
;============================================================

public deftype Array<T> <: IndexedCollection<T> & Equalable

;                     Implementation
;                     ==============

lostanza deftype RawArray <: Array :
   length: long
   items: ref<?> ...

lostanza defn RawArray (n:ref<Int>, x:ref<?>) -> ref<RawArray> :
   val l = n.value
   val a = new RawArray{l}
   for (var i:long = 0, i < l, i = i + 1) :
      a.items[i] = x
   return a

lostanza defmethod get (a:ref<RawArray>, i:ref<Int>) -> ref<?> :
  return a.items[i.value]

lostanza defmethod set (a:ref<RawArray>, i:ref<Int>, v:ref<?>) -> ref<False> :
  a.items[i.value] = v
  return false

lostanza defmethod set-all (xs:ref<RawArray>, r:ref<Range>, v:ref<?>) -> ref<False> :
   val range = range-bound(xs, r) as ref<Tuple<Int>>
   val b = range.items[0].value
   val e = range.items[1].value
   for (var i:long = b, i < e, i = i + 1) :
      xs.items[i] = v
   return false

lostanza defmethod length (a:ref<RawArray>) -> ref<Int> :
   return new Int{a.length as int}

defmethod print (o:OutputStream, a:RawArray) -> False :
   print(o, "[%@]" % [a])

defmethod equal? (a:RawArray, b:RawArray) :
   ($prim identical? a b)

;                     Wrapping
;                     ========

#if-defined(OPTIMIZE) :

   public defn Array<T> (n:Int) -> Array<T> :
      RawArray(n, sentinel)

   public defn Array<T> (n:Int, x:T) -> Array<T> :
      RawArray(n, x)

#else :

   deftype WrappedArray<T> <: Array<T>
   defmulti raw (a:WrappedArray) -> RawArray

   public defn Array<T> (n:Int) -> Array<T> :
      ensure-non-negative("length", n)
      Array<T>(RawArray(n, sentinel))

   public defn Array<T> (n:Int, x:T) -> Array<T> :
      ensure-non-negative("length", n)
      Array<T>(RawArray(n, x))

   defn Array<T> (a:RawArray) -> Array<T> :
      new WrappedArray<T> :
         defmethod raw (this) : a
         defmethod get (this, i:Int) :
            ensure-index-in-bounds(a, i)
            match(a[i]) :
               (v:Sentinel) : fatal("Index (%_) is uninitialized." % [i])
               (v) : v
         defmethod set (this, i:Int, v:T) :
            ensure-index-in-bounds(a, i)
            a[i] = v
         defmethod set-all (this, r:Range, v:T) :
            ensure-index-range(a, r)
            set-all(a, r, v)
         defmethod length (this) :
            length(a)
         defmethod print (o:OutputStream, this) :
            print(o, a)
         defmethod equal? (this, x:WrappedArray) :
            a == raw(x)

public defn map<R,?T> (f: T -> R, xs:Array<?T>) -> Array<R> :
   val ret = Array<R>(length(xs))
   for (x in xs, i in 0 to false) do :
      ret[i] = f(x)
   ret

;============================================================
;==================== Primitive Arrays ======================
;============================================================

#for (Prim in [Byte Int Long Float Double]
      prim in [byte int long float double]
      PrimArray in [ByteArray IntArray LongArray FloatArray DoubleArray]
      x0 in [0Y 0 0L 0.0F 0.0]) :

  ;                     Declaration
  ;                     ===========
  public lostanza deftype PrimArray <: Array<Prim> :
    length: long
    data: prim ...
      
  ;                     Implementation
  ;                     ==============
  public lostanza defn PrimArray (n:ref<Int>, x:ref<Prim>) -> ref<PrimArray> :
    ensure-non-negative-length(n)
    val l = n.value
    val a = new PrimArray{l}
    val xv = x.value
    for (var i:long = 0, i < l, i = i + 1) :
      a.data[i] = xv
    return a

  public defn PrimArray (n:Int) -> PrimArray :
    PrimArray(n, x0)

  lostanza defmethod get (a:ref<PrimArray>, i:ref<Int>) -> ref<Prim> :
    ensure-index-in-bounds(a, i)
    return new Prim{a.data[i.value]}

  lostanza defmethod set (a:ref<PrimArray>, i:ref<Int>, x:ref<Prim>) -> ref<False> :
    ensure-index-in-bounds(a, i)
    a.data[i.value] = x.value   
    return false   

  lostanza defmethod length (a:ref<PrimArray>) -> ref<Int> :
    return new Int{a.length as int}

  lostanza defmethod get (a:ref<PrimArray>, r:ref<Range>) -> ref<PrimArray> :
    ensure-index-range(a, r)
    val rb = range-bound(a, r)
    val b = get(rb, new Int{0}).value
    val e = get(rb, new Int{1}).value
    val len = e - b
    val ret = new PrimArray{len}
    for (var i:long = 0, i < len, i = i + 1) :
      ret.data[i] = a.data[i + b]
    return ret   

  lostanza defmethod set (a:ref<PrimArray>, r:ref<Range>, xs:ref<PrimArray>) -> ref<False> :
    ensure-index-range(a, r)
    val rb = range-bound(a, r)
    val b = get(rb, new Int{0}).value
    val e = get(rb, new Int{1}).value
    val len = e - b
    #if-not-defined(OPTIMIZE) :
      ensure-len-le-xs(new Int{len}, xs)
    for (var i:long = 0, i < len, i = i + 1) :
      a.data[i + b] = xs.data[i]
    return false
  defn ensure-len-le-xs (len:Int, xs:PrimArray) :
    if len > length(xs) :
      fatal("Length of range (%_) is greater than length of values array (%_)." % [
        len, length(xs)])

;============================================================
;==================== CharArrays ============================
;============================================================

public lostanza deftype CharArray <: Array<Char> :
  length: long
  chars: byte ...

;                     Implementation
;                     ==============

public lostanza defn CharArray (n:ref<Int>, x:ref<Char>) -> ref<CharArray> :
   ensure-non-negative-length(n)
   val l = n.value
   val a = new CharArray{l}
   val c = x.value
   for (var i:long = 0, i < l, i = i + 1) :
      a.chars[i] = c
   return a

public defn CharArray (n:Int) -> CharArray :
   CharArray(n, ' ')

lostanza defmethod get (a:ref<CharArray>, i:ref<Int>) -> ref<Char> :
  ensure-index-in-bounds(a, i)
  return new Char{a.chars[i.value]}

lostanza defmethod set (a:ref<CharArray>, i:ref<Int>, v:ref<Char>) -> ref<False> :
  ensure-index-in-bounds(a, i)
  a.chars[i.value] = v.value
  return false

lostanza defmethod length (a:ref<CharArray>) -> ref<Int> :
   return new Int{a.length as int}

lostanza defn substring! (a:ref<CharArray>, b:ref<Int>, e:ref<Int>) -> ref<String> :
   val len = e.value - b.value
   val start = b.value
   val s = String(len)
   for (var i:long = 0, i < len, i = i + 1) :
      s.chars[i] = a.chars[i + start]
   s.chars[len] = 0 as byte
   return s

defmethod get (a:CharArray, r:Range) -> String :
   ensure-index-range(a, r)
   val [b, e] = range-bound(a, r)
   substring!(a, b, e)

;                     Looping
;                     =======

defmethod do (f: Char -> ?, xs:CharArray) :
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(xs[i])
         loop(i + 1, n - 1)
   loop(0, length(xs))

;============================================================
;==================== Block Copying =========================
;============================================================

public defmulti block-copy<?T> (n:Int, dst:IndexedCollection<?T>, di:Int, src:IndexedCollection<T>, si:Int) -> False

defmethod block-copy<?T> (n:Int, dst:IndexedCollection<?T>, di:Int, src:IndexedCollection<T>, si:Int) :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative("number of elements", n)
      ensure-non-negative("destination index", di)
      ensure-non-negative("source index", si)
      if length(dst) < di + n : fatal("Attempt to write past bounds of destination collection.")
      if length(src) < si + n : fatal("Attempt to write past bounds of source collection.")      
   for i in 0 to n do :
      dst[di + i] = src[si + i]

;============================================================
;==================== Conversions ===========================
;============================================================

;                 Numeric Conversions
;                 ===================

public lostanza defn to-byte (b:ref<Byte>) -> ref<Byte> : return b
public lostanza defn to-byte (c:ref<Char>) -> ref<Byte> : return new Byte{c.value}
public lostanza defn to-byte (i:ref<Int>) -> ref<Byte> : return new Byte{i.value as byte}
public lostanza defn to-byte (l:ref<Long>) -> ref<Byte> : return new Byte{l.value as byte}
public lostanza defn to-byte (f:ref<Float>) -> ref<Byte> : return new Byte{f.value as byte}
public lostanza defn to-byte (d:ref<Double>) -> ref<Byte> : return new Byte{d.value as byte}
public lostanza defn to-char (b:ref<Byte>) -> ref<Char> : return new Char{b.value}
public lostanza defn to-char (c:ref<Char>) -> ref<Char> : return c
public lostanza defn to-char (i:ref<Int>) -> ref<Char> : return new Char{i.value as byte}
public lostanza defn to-int (b:ref<Byte>) -> ref<Int> : return new Int{b.value}
public lostanza defn to-int (c:ref<Char>) -> ref<Int> : return new Int{c.value}
public lostanza defn to-int (i:ref<Int>) -> ref<Int> : return i
public lostanza defn to-int (l:ref<Long>) -> ref<Int> : return new Int{l.value as int}
public lostanza defn to-int (f:ref<Float>) -> ref<Int> : return new Int{f.value as int}
public lostanza defn to-int (d:ref<Double>) -> ref<Int> : return new Int{d.value as int}
public lostanza defn to-long (b:ref<Byte>) -> ref<Long> : return new Long{b.value}
public lostanza defn to-long (i:ref<Int>) -> ref<Long> : return new Long{i.value}
public lostanza defn to-long (l:ref<Long>) -> ref<Long> : return l
public lostanza defn to-long (f:ref<Float>) -> ref<Long> : return new Long{f.value as long}
public lostanza defn to-long (d:ref<Double>) -> ref<Long> : return new Long{d.value as long}
public lostanza defn to-float (b:ref<Byte>) -> ref<Float> : return new Float{b.value as float}
public lostanza defn to-float (i:ref<Int>) -> ref<Float> : return new Float{i.value as float}
public lostanza defn to-float (l:ref<Long>) -> ref<Float> : return new Float{l.value as float}
public lostanza defn to-float (f:ref<Float>) -> ref<Float> : return f
public lostanza defn to-float (d:ref<Double>) -> ref<Float> : return new Float{d.value as float}
public lostanza defn to-double (b:ref<Byte>) -> ref<Double> : return new Double{b.value as double}
public lostanza defn to-double (i:ref<Int>) -> ref<Double> : return new Double{i.value as double}
public lostanza defn to-double (l:ref<Long>) -> ref<Double> : return new Double{l.value as double}
public lostanza defn to-double (f:ref<Float>) -> ref<Double> : return new Double{f.value}
public lostanza defn to-double (d:ref<Double>) -> ref<Double> : return d

;                Numeric Reinterpretations
;                =========================

public lostanza defn bits (f:ref<Float>) -> ref<Int> :
  val v = f.value
  return new Int{($ls-prim bits v)}

public lostanza defn bits (d:ref<Double>) -> ref<Long> :
  val v = d.value
  return new Long{($ls-prim bits v)}

public lostanza defn bits-as-float (i:ref<Int>) -> ref<Float> :
  val v = i.value
  return new Float{($ls-prim fnum v)}

public lostanza defn bits-as-double (i:ref<Long>) -> ref<Double> :
  val v = i.value
  return new Double{($ls-prim fnum v)}

;============================================================
;==================== Number Parsing ========================
;============================================================

;                     Error Checking
;                     ==============

#for (to-value! in [to-byte! to-int! to-long! to-float! to-double!]
      to-value in [to-byte to-int to-long to-float to-double]
      Value in [Byte Int Long Float Double]
      name in ["byte" "int" "long" "float" "double"]) :
  public defn to-value! (s:String) -> Value :
    #if-defined(OPTIMIZE) :
      to-value(s) as Value
    #else :
      match(to-value(s)) :
        (v:Value) : v
        (v:False) : fatal("String %~ cannot be converted to a %_." % [s, name])

;                        Drivers
;                        =======

public defn to-byte (s:String) -> False|Byte :
  match(to-int(s)) :
    (i:Int) : to-byte(i) when i >= 0 and i <= 255
    (i:False) : false

public lostanza defn to-int (s:ref<String>) -> ref<False|Int> :
  if prefix?(s, "-") :
    return neg-to-int(s, 1, 10)
  else if prefix?(s, "0x") :
    return bits-to-int(s, 2, 16, 4)
  else if prefix?(s, "0o") :
    return bits-to-int(s, 2, 8, 3)
  else if prefix?(s, "0b") :
    return bits-to-int(s, 2, 2, 1)
  else :
    return pos-to-int(s, 0, 10)

public lostanza defn to-long (s:ref<String>) -> ref<False|Long> :
  if prefix?(s, "-") :
    return neg-to-long(s, 1, 10)
  else if prefix?(s, "0x") :
    return bits-to-long(s, 2, 16, 4)
  else if prefix?(s, "0o") :
    return bits-to-long(s, 2, 8, 3)
  else if prefix?(s, "0b") :
    return bits-to-long(s, 2, 2, 1)
  else :
    return pos-to-long(s, 0, 10)

;TODO: This is necessary because addresses of local variables don't work yet.
lostanza var DOUBLE-BUFFER : double
lostanza var CHAR-BUFFER : byte
public lostanza defn to-double (s:ref<String>) -> ref<False|Double> :
  val n = call-c clib/sscanf(addr!(s.chars), "%lf%c", addr(DOUBLE-BUFFER), addr(CHAR-BUFFER))
  if n != 1 : return false
  else : return new Double{DOUBLE-BUFFER}

lostanza var FLOAT-BUFFER : float
public lostanza defn to-float (s:ref<String>) -> ref<False|Float> :
  val n = call-c clib/sscanf(addr!(s.chars), "%f%c", addr(FLOAT-BUFFER), addr(CHAR-BUFFER))
  if n != 1 : return false
  else : return new Float{FLOAT-BUFFER}

;                        Utilities
;                        =========

lostanza defn prefix? (str:ref<String>, prefix:ptr<byte>) -> int :
  for (var i:long = 0, 1, i = i + 1) :
    if prefix[i] == 0 : return 1
    else if str.chars[i] == 0 : return 0
    else if prefix[i] != str.chars[i] : return 0
  return 0

lostanza defn digit (c:byte, radix:int) -> int :
  var d:int
  if c >= '0' and c <= '9' : d = c - '0'
  else if c >= 'a' and c <= 'f' : d = c - 'a' + 10
  else if c >= 'A' and c <= 'F' : d = c - 'A' + 10
  else : return -1
  if d < radix : return d
  else : return -1

;                        Parsing Integers
;                        ================

lostanza defn pos-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
  var n:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix + d
        if n < 0 : return false
  fatal("Unreachable")
  return false

lostanza defn neg-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
  var n:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix - d
        if n > 0 : return false
  fatal("Unreachable")
  return false

lostanza defn bits-to-int (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Int> :
  var n:int = 0
  var nbits:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = (n << bits) | d
        nbits = nbits + bits
        if nbits >= 32 + bits : return false
  fatal("Unreachable")
  return false

;                        Parsing Longs
;                        =============

lostanza defn pos-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
  var n:long = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix + d
        if n < 0 : return false
  fatal("Unreachable")
  return false

lostanza defn neg-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
  var n:long = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix - d
        if n > 0 : return false
  fatal("Unreachable")
  return false

lostanza defn bits-to-long (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Long> :
  var n:long = 0
  var nbits:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = (n << bits) | d
        nbits = nbits + bits
        if nbits >= 64 + bits : return false
  fatal("Unreachable")
  return false

;============================================================
;=================== Limits =================================
;============================================================

public val BYTE-MAX = 255Y
public val BYTE-MIN = 0Y
public lostanza val INT-MAX:ref<Int> = new Int{(1 << 31) - 1}
public lostanza val INT-MIN:ref<Int> = new Int{1 << 31}
public lostanza val LONG-MAX:ref<Long> = new Long{(1L << 63L) - 1L}
public lostanza val LONG-MIN:ref<Long> = new Long{1L << 63L}

public val FLOAT-MAX = bits-as-float(0x7F7FFFFF)
public val FLOAT-MIN-NORMAL = bits-as-float(0x00800000)
public val FLOAT-MIN = bits-as-float(0x1)
public val FLOAT-NAN = bits-as-float(0x7FC00000)
public val FLOAT-POSITIVE-INFINITY = bits-as-float(0x7F800000)
public val FLOAT-NEGATIVE-INFINITY = bits-as-float(0xFF800000)

public val DOUBLE-MAX = bits-as-double(0x7fefffffffffffffL)
public val DOUBLE-MIN-NORMAL = bits-as-double(0x0010000000000000L)
public val DOUBLE-MIN = bits-as-double(0x1L)
public val DOUBLE-NAN = bits-as-double(0x7ff8000000000000L)
public val DOUBLE-POSITIVE-INFINITY = bits-as-double(0x7ff0000000000000L)
public val DOUBLE-NEGATIVE-INFINITY = bits-as-double(0xfff0000000000000L)

;============================================================
;==================== Arithmetic ============================
;============================================================

public defn max<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T :
  b when a < b else a

public defn min<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T :
  a when a < b else b

public defn minimum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, xs} $ fn (x, y) :
    if x < y : x
    else : y

public defn minimum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, x0, xs} $ fn (x, y) :
    if x < y : x
    else : y

public defn maximum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, xs} $ fn (x, y) :
    if x < y : y
    else : x

public defn maximum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, x0, xs} $ fn (x, y) :
    if x < y : y
    else : x

public defn minimum<?T> (xs:Seqable<?T&Comparable>) -> T : minimum(xs, less?)
public defn maximum<?T> (xs:Seqable<?T&Comparable>) -> T : maximum(xs, less?)

public defn minimum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : minimum(x0, xs, less?)
public defn maximum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : maximum(x0, xs, less?)

public defn minimum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T : minimum(xs, {key(_) < key(_)})
public defn maximum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T : maximum(xs, {key(_) < key(_)})

public defn ceil-log2 (i:Int) -> Int :
  defn* loop (n:Int, l:Int) :
    if i > n :
      if l == 30 : l + 1
      else : loop(n << 1, l + 1)
    else : l
  fatal("Log of non-positive number!") when i <= 0
  loop(1, 0)

public defn floor-log2 (i:Int) -> Int :
  defn* loop (n:Int, l:Int) :
    if i == n : l
    else if i < n : l - 1
    else if l == 30 : l
    else : loop(n << 1, l + 1)
  fatal("Log of non-positive number!") when i <= 0
  loop(1, 0)

public defn ceil-log2 (i:Long) -> Int :
  defn* loop (n:Long, l:Int) :
    if i > n :
      if l == 62 : l + 1
      else : loop(n << to-long(1), l + 1)
    else : l
  fatal("Log of non-positive number!") when i <= to-long(0)
  loop(to-long(1), 0)

public defn floor-log2 (i:Long) -> Int :
  defn* loop (n:Long, l:Int) :
    if n == i : l
    else if i < n : l - 1
    else if l == 62 : l
    else : loop(n << to-long(1), l + 1)
  fatal("Log of non-positive number!") when i <= to-long(0)
  loop(to-long(1), 0)

public defn next-pow2 (i:Int) -> Int :
  ensure-non-negative("value", i)
  if i == 0 :
    i
  else :
    val n = ceil-log2(i)
    if n <= 30 : 1 << n
    else : fatal("Overflow")

public defn prev-pow2 (i:Int) -> Int :
  ensure-non-negative("value", i)
  if i == 0 :
    i
  else :
    1 << floor-log2(i)

public defn next-pow2 (i:Long) -> Long :
  val n = ceil-log2(i)
  if n <= 62 : to-long(1) << to-long(n)
  else : fatal("Overflow")

public defn prev-pow2 (i:Long) -> Long :
  to-long(1) << to-long(floor-log2(i))

public defn sum (xs: Seqable<Int>) -> Int : reduce(plus, 0, xs)
public defn sum (xs: Seqable<Long>) -> Long : reduce(plus, 0L, xs)
public defn sum (xs: Seqable<Float>) -> Float : reduce(plus, 0.0f, xs)
public defn sum (xs: Seqable<Double>) -> Double : reduce(plus, 0.0, xs)

public defn product (xs: Seqable<Int>) -> Int : reduce(times, 1, xs)
public defn product (xs: Seqable<Long>) -> Long : reduce(times, 1L, xs)
public defn product (xs: Seqable<Float>) -> Float : reduce(times, 1.0f, xs)
public defn product (xs: Seqable<Double>) -> Double : reduce(times, 1.0, xs)

;============================================================
;====================== Maybe ===============================
;============================================================

public deftype Maybe<T> <: Equalable & Comparable<Maybe<T>> & Hashable
public deftype None <: Maybe<Void>
public deftype One<T> <: Maybe<T>

;                      Interface
;                      =========

public defmulti value<?T> (x:One<?T>) -> T

;                     Constructors
;                     ============

public defn None () :
   new None

public defn One<?T> (x:?T) :
   new One<T> :
      defmethod value (this) : x

;                     Printers
;                     ========

defmethod print (o:OutputStream, x:None) :
   print(o, "None")
defmethod print (o:OutputStream, x:One) :
   print(o, "One(%~)" % [value(x)])

;                   Implementation
;                   ==============

public defn value!<?T> (x:Maybe<?T>) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : fatal("Object of type None has no value.")

public defn value?<?T> (x:Maybe<?T>, default:?T) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : default

public defn value?<?T> (x:Maybe<?T>) -> T|False :
   value?(x, false)

public defn empty? (x:Maybe) :
   x is None

defmethod equal? (a:None, b:None) :
   true

defmethod equal? (a:One, b:One) :
   value(a) == value(b)

defmethod hash (a:None) :
  1817

defmethod hash (a:One) :
  hash(value(a)) * 17

;                   Comparisons
;                   ===========

defmethod* compare<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : 0
      (x:None, y:One<T>) : -1
      (x:One<T>, y:None) : 1
      (x:One<T&Comparable<T>>, y:One<T>) : compare(value(x), value(y))

defmethod less?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) < value(y)

defmethod less-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) <= value(y)

defmethod greater?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) > value(y)

defmethod greater-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) >= value(y)

;============================================================
;====================== Ranges ==============================
;============================================================

public deftype Range <: Equalable

;                      Interface
;                      =========

public defmulti start (r:Range) -> Int
public defmulti end (r:Range) -> Int|False
public defmulti step (r:Range) -> Int
public defmulti inclusive? (r:Range) -> True|False

;                     Constructor
;                     ===========

public defn Range (start:Int, end:Int|False, step:Int, inclusive?:True|False) :
   ;Compute the length of the range
   val length = match(end, inclusive?) :
      (end:Int, inc:False) :
         if step == 0 :
            if start == end : 0
            else : false
         else if step == 1 :
            end - start
         else if step == -1 :
            start - end
         else if step > 0 :
            (end - start + step - 1) / step
         else :
            (end - start + step + 1) / step
      (end:Int, inc:True) :
         if step == 0 :
            false
         else if step == 1 :
            end - start + 1
         else if step == -1 :
            start - end + 1
         else :
            (end - start + step) / step
      (end:False, inc) :
         false

   match(length) :
      (length:Int) :
         new Range & Lengthable :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?
            defmethod length (this) : max(length, 0)
      (length:False) :
         new Range :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?

;                Conversion to Sequence
;                ======================



;             Reverse
;             =======
public defn reverse (r:Range) :
  ;Fields
  val start = start(r)
  val end = end(r)
  val step = step(r)
  val inc = inclusive?(r)

  ;Cases
  defn* empty-range () :
    Range(end as Int, start, (- step), inc)
  defn* reverse-range (last:Int) :
    last through start by (- step)
  defn* infinite-range () :
    start through start by 0
  defn* no-last-element () :
    fatal("Range %_ cannot be reversed." % [r])

  if step == 0 :
    match(start == end, inc) :
      (eq:False, inc) : infinite-range()
      (eq:True, inc:True) : infinite-range()
      (eq:True, inc:False) : empty-range()
  else if end is False :
    no-last-element()
  else :
    val end = end as Int    
    match(step > 0, end > start) :
      (r1:True, r2:False) :
        empty-range()
      (r1:False, r2:True) :
        empty-range()
      (r1, r2) :
        val sgn-step = 1 when r1 else -1
        val n = if inc : (end - start + step) / step
                else : (end - start + step - sgn-step) / step
        reverse-range(start + (n - 1) * step)       



;             Looping
;             =======

defmethod do (f: Int -> ?, r:Range&Lengthable) :
   val s = step(r)
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(i)
         loop(i + s, n - 1)
   loop(start(r), length(r))

defmethod do (f: Int -> ?, r:Range) :
   val s = step(r)
   defn* loop (i:Int) :
      f(i)
      loop(i + s)
   loop(start(r))

;                  Inclusion
;                  =========

defmethod contains? (r:Range, x:Int) :
  val start = start(r)
  val step = step(r)
  match(end(r), inclusive?(r)) :
    (end:Int, inc:False) :
      if step == 0 :
        if start == end : false
        else : start == x
      else if step == 1 :
        x >= start and x < end
      else if step == -1 :
        x <= start and x > end
      else if step > 0 :
        x >= start and x < end and ((x - start) % step == 0)
      else :
        x <= start and x > end and ((x - start) % step == 0)
    (end:Int, inc:True) :
      if step == 0 :
        start == x
      else if step == 1 :
        x >= start and x <= end
      else if step == -1 :
        x <= start and x >= end
      else if step > 0 :
        x >= start and x <= end and ((x - start) % step == 0)
      else :
        x <= start and x >= end and ((x - start) % step == 0)
    (end:False, inc) :
      if step == 0 :
        start == x
      else if step == 1 :
        x >= start
      else if step == -1 :
        x <= start
      else if step > 0 :
        x >= start and ((x - start) % step == 0)
      else :
        x <= start and ((x - start) % step == 0)

;                 Comparison
;                 ==========

defmethod equal? (a:Range, b:Range) :
   start(a) == start(b) and
   end(a) == end(b) and
   step(a) == step(b) and
   inclusive?(a) == inclusive?(b)

;                  Printing
;                  ========

defmethod print (o:OutputStream, x:Range) :
   val op = "through" when inclusive?(x) else "to"
   if step(x) == 1 : print(o, "%_ %_ %_" % [start(x), op, end(x)])
   else : print(o, "%_ %_ %_ by %_" % [start(x), op, end(x), step(x)])

;                  Mapping
;                  =======

public defn map<?R> (f: Int -> ?R, r:Range) -> List<R> :
   fatal("Infinite Range") when r is-not Range&Lengthable
   to-list(seq(f, r))

;============================================================
;==================== KeyValue Pairs ========================
;============================================================

public deftype KeyValue<K,V> <: Equalable & Hashable

;                       Interface
;                       =========

public defmulti key<?K> (kv:KeyValue<?K,?>) -> K
public defmulti value<?V> (kv:KeyValue<?,?V>) -> V

;                      Constructor
;                      ===========

public defn KeyValue<?K,?V> (k:?K, v:?V) -> KeyValue<K,V> :
   new KeyValue<K,V> :
      defmethod key (this) : k
      defmethod value (this) : v

defmethod print (o:OutputStream, v:KeyValue) :
   write(o, key(v))
   print(o, " => ")
   write(o, value(v))

defmethod equal? (a:KeyValue, b:KeyValue) :
   key(a) == key(b) and
   value(a) == value(b)

defmethod hash (x:KeyValue<Hashable,Hashable>) :
   hash(key(x)) + 7 * hash(value(x))

;============================================================
;====================== Tokens ==============================
;============================================================

public deftype Token <: Equalable

;                      Interface
;                      =========

public defmulti item (t:Token) -> ?
public defmulti info (t:Token) -> FileInfo

;                     Constructor
;                     ===========

public defn Token (item, info:FileInfo) :
   new Token :
      defmethod item (this) : item
      defmethod info (this) : info

public defn unwrap-token (t) :
   match(t) :
      (t:Token) : unwrap-token(item(t))
      (t) : t

public defn unwrap-all (t) -> ? :
   match(t) :
      (t:Token) : unwrap-all(item(t))
      (t:List) : map(unwrap-all, t)
      (t) : t

defmethod print (o:OutputStream, t:Token) :
   write(o, item(t))

defmethod equal? (a:Token, b:Token) :
   (item(a) == item(b)) and
   (info(a) == info(b))

;============================================================
;===================== FileInfo =============================
;============================================================

public deftype FileInfo <: Equalable & Hashable & Comparable<FileInfo>

;                     Interface
;                     =========

public defmulti filename (i:FileInfo) -> String
public defmulti line (i:FileInfo) -> Int
public defmulti column (i:FileInfo) -> Int

;                  Implementation
;                  ==============

public defn FileInfo (f:String, l:Int, c:Int) :
   new FileInfo :
      defmethod filename (this) : f
      defmethod line (this) : l
      defmethod column (this) : c

defmethod equal? (a:FileInfo, b:FileInfo) :
   filename(a) == filename(b) and
   line(a) == line(b) and
   column(a) == column(b)

defmethod hash (i:FileInfo) :
   hash(filename(i)) +
   7 * hash(line(i)) +
   49 * hash(column(i))

defmethod compare (a:FileInfo, b:FileInfo) :
   val c = compare(filename(a), filename(b))
   if c == 0 :
      val c = compare(line(a), line(b))
      if c == 0 :
         compare(column(a), column(b))
      else : c
   else : c

defmethod print (o:OutputStream, i:FileInfo) :
   print(o, filename(i))
   print(o, ":")
   print(o, line(i))
   print(o, ".")
   print(o, column(i))

;============================================================
;======================= Sequences ==========================
;============================================================

public deftype Seqable<T> :
  Collection<T> <: Seqable<T>
  
public deftype Seq<T> <: Seqable<T>

public deftype Collection<T> :
  Range <: Collection<Int>
  String <: Collection<Char>
  List<T> <: Collection<T>
  Tuple<T> <: Collection<T>
  IndexedCollection<T> <: Collection<T>

public defmulti to-seq<?T> (s:Seqable<?T>) -> Seq<T>
defmethod to-seq<?T> (s:Seq<?T>) : s

public defmulti next<?T> (s:Seq<?T>) -> T
public defmulti peek<?T> (s:Seq<?T>) -> T
public defmulti empty? (s:Seq) -> True|False
public defmulti free (s:Seq) -> False
defmethod free (s:Seq) : false

defn* do-seq<?T,?R> (f: Seq<T> -> ?R, s:Seqable<?T>) -> R :
   match(s) :
      (s:Seq<T>) :
         f(s)
      (s) :
         val s-seq = to-seq(s)
         dynamic-wind(
            false,
            fn* () : f(s-seq)
            fn* (final?) : free(s-seq) when final?)

;===== Conversion to Sequence =====

defmethod to-seq<?T> (x:Tuple<?T>) :
   seq({x[_]}, 0 to length(x))

defmethod to-seq (s:String) :
   seq({s[_]}, 0 to length(s))

defmethod to-seq<?T> (x:List<?T>) :
   var l = x
   new Seq<T> :
      defmethod empty? (this) :
         empty?(l)
      defmethod next (this) :
         val x = peek(this)
         l = tail(l)
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         head(l)

defmethod to-seq<?T> (xs:IndexedCollection<?T>) -> Seq<T> :
   seq({xs[_]}, 0 to length(xs))

defmethod to-seq (r:Range) :
  match(r) :
    (r:Range & Lengthable) :
      var i = start(r)
      var n = length(r)
      new Seq<Int> & Lengthable :
        defmethod next (this) :
          val i* = peek(this)
          i = i + step(r)
          n = n - 1
          i*
        defmethod peek (this) :
          fatal("Empty Sequence") when empty?(this)
          i
        defmethod empty? (this) :
          n == 0
        defmethod length (this) :
          n
    (r:Range) :
      var i = start(r)
      new Seq<Int> :
        defmethod next (this) :
          val i* = i
          i = i + step(r)
          i*
        defmethod peek (this) :
          i
        defmethod empty? (this) :
          false

;===== Conversion from Sequence =====

public defn to-tuple<?T> (xs:Seqable<?T>) -> Tuple<T> :
   match(xs) :
      (xs:Tuple<T>) :
         xs
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val t = Tuple(n, false as ?)
         for (x in xs, i in 0 to n) do :
            t[i] = x
         t
      (xs) :
         to-tuple(to-vector<T>(xs))

public defn String (cs:Seqable<Char>) -> String :
   match(cs) :
      (cs:Seqable<Char> & Lengthable) :
         val n = length(cs)
         val s = String(n, ' ')
         for (c in cs, i in 0 to false) do :
            s[i] = c
         s
      (c) :
         String(to-vector<Char>(cs))

public defn to-list<?T> (xs:Seqable<?T>) -> List<T> :
   match(xs) :
      (xs:List<T>) :
         xs
      (xs) :
         val vec = to-vector<T>(xs)
         defn* loop (i:Int, accum:List<T>) :
            if i >= 0 : loop(i - 1, cons(vec[i], accum))
            else : accum
         loop(length(vec) - 1, List())

public defn to-array<T> (xs:Seqable<T>) -> Array<T> :
   match(xs) :
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val a = Array<T>(n)
         for (x in xs, i in 0 to n) do :
            a[i] = x
         a
      (xs) :
         to-array<T>(to-list(xs))

public defn symbol-join (xs:Seqable) -> Symbol :   
   to-symbol(string-join(xs))

;============================================================
;================== Sequence Library ========================
;============================================================

public defmulti do<?T> (f:T -> ?, xs:Seqable<?T>) -> False
public defmulti do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False
public defmulti do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False

defmethod do<?T> (f:T -> ?, xs:Seqable<?T>) -> False :
   for xs-seq in xs do-seq :
      while not empty?(xs-seq) :
         f(next(xs-seq))

defmethod do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         while (not empty?(xs-seq)) and (not empty?(ys-seq)) :
            f(next(xs-seq), next(ys-seq))

defmethod do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            while (not empty?(xs-seq)) and (not empty?(ys-seq)) and (not empty?(zs-seq)) :
               f(next(xs-seq), next(ys-seq), next(zs-seq))

;Specialization
defmethod do<?T> (f: T -> ?, xs:Array<?T>) :
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(xs[i])
         loop(i + 1, n - 1)
   loop(0, length(xs))

#for (Prim in [Byte Int Long Float Double]
      PrimArray in [ByteArray IntArray LongArray FloatArray DoubleArray]) :
  defmethod do (f: Prim -> ?, xs:PrimArray) :
    defn* loop (i:Int, n:Int) :
      if n > 0 :
        f(xs[i])
        loop(i + 1, n - 1)
    loop(0, length(xs))

defmethod do (f: Char -> ?, xs:String) :
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(xs[i])
         loop(i + 1, n - 1)
   loop(0, length(xs))

defmethod do<?T> (f:T -> ?, xs:List<?T>) -> False :
   defn* loop (xs:List<T>) :
      if not empty?(xs) :
         f(head(xs))
         loop(tail(xs))
   loop(xs)

defn wrap-length<?T> (xs:Seq<?T>, length:() -> Int) :
  new Seq<T> & Lengthable :
    defmethod next (this) : next(xs)
    defmethod peek (this) : peek(xs)
    defmethod empty? (this) : empty?(xs)
    defmethod length (this) : length()

public defn seq<?T,?S> (f:T -> ?S, xs:Seqable<?T>) -> Seq<S> :
  val xs-seq = to-seq(xs)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) : None()
    else : One(f(next(xs-seq)))
  match(xs-seq) :
    (xs:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + length(xs)})
    (xs) : rs

public defn seq<?T,?S,?R> (f:(T,S) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
  val xs-seq = to-seq(xs)
  val ys-seq = to-seq(ys)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) or empty?(ys-seq) : None()
    else : One(f(next(xs-seq), next(ys-seq)))
  match(xs-seq, ys-seq) :
    (xs:Seq&Lengthable, ys:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + min(length(xs), length(ys))})
    (xs, ys) : rs

public defn seq<?T,?S,?U,?R> (f:(T,S,U) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
  val xs-seq = to-seq(xs)
  val ys-seq = to-seq(ys)
  val zs-seq = to-seq(zs)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) or empty?(ys-seq) or empty?(zs-seq) : None()
    else : One(f(next(xs-seq), next(ys-seq), next(zs-seq)))
  match(xs-seq, ys-seq, zs-seq) :
    (xs:Seq&Lengthable, ys:Seq&Lengthable, zs:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + min(length(xs), min(length(ys), length(zs)))})
    (xs, ys, zs) : rs

public defmulti in-reverse<?T> (xs:Seqable<?T>) -> Seq<T>
defmethod in-reverse<?T> (xs:Seqable<?T>) :
  in-reverse(to-vector<T>(xs))
  
defmethod in-reverse<?T> (xs:IndexedCollection<?T>) :
  val n = length(xs)
  for i in (n - 1) through 0 by -1 seq :
    xs[i]
    
defmethod in-reverse (r:Range) :
  to-seq(reverse(r))

defmethod in-reverse<?T> (xs:List<?T>) -> Seq<T> :
  generate<T> :
    defn loop (xs:List<T>) :
      if not empty?(xs) :
        loop(tail(xs))
        yield(head(xs))
    loop(xs)

public defmulti contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False
defmethod contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False :
   label<False|True> return :
      for x in xs do :
         return(true) when x == y

public defn find<?T> (f: T -> True|False, xs:Seqable<?T>) -> T|False :
   label<False|T> return :
      for x in xs do :
         return(x) when f(x)

public defn find<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> T|False :
   label<False|T> return :
      for (x in xs, y in ys) do :
         return(x) when f(x, y)

public defn find!<?T> (f: T -> True|False, xs:Seqable<?T>) : find(f, xs) as T
public defn find!<?T, ?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : find(f, xs, ys) as T

public defn first<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Maybe<R> :
   label<Maybe<R>> return :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()

public defn first<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Maybe<R> :
   label<Maybe<R>> return :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()

public defn first!<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) : value!(first(f, xs))
public defn first!<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) : value!(first(f, xs, ys))

public defn seq?<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Seq<R> :
   generate<R> :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?U,?R> (f: (T,S,U) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys, z in zs) do :
         match(f(x, y, z)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn filter<?T> (f: T -> True|False, xs:Seqable<?T>) -> Seq<T> :
   generate<T> :
      for x in xs do :
         yield(x) when f(x)

public defn filter<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<T> :
   generate<T> :
      for (x in xs, y in ys) do :
         yield(x) when f(x, y)

public defn filter<?T> (xs:Seqable<?T>, sel:Seqable<True|False>) -> Seq<T> :
   for (x in xs, s in sel) filter : s

public defn index-of (xs:Seqable<Equalable>, y:Equalable) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when x == y

public defn index-of! (xs:Seqable<Equalable>, y:Equalable) : index-of(xs, y) as Int

public defn index-when<?T> (f: T -> True|False, xs:Seqable<?T>) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when f(x)

public defn index-when<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Int|False :
   label<Int|False> return :
      for (x in xs, y in ys, i in 0 to false) do :
         return(i) when f(x, y)

public defn index-when!<?T> (f: T -> True|False, xs:Seqable<?T>) : index-when(f, xs) as Int
public defn index-when!<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : index-when(f, xs, ys) as Int

public defn split!<?T> (f: T -> True|False, xs: Seqable<?T>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for x in xs do :
      add{_, x} $
         if f(x) : true-xs
         else : false-xs
   [true-xs, false-xs]

public defn split!<?T,?S> (f: (T, S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
  val true-xs = Vector<T>()
  val false-xs = Vector<T>()
  for (x in xs, y in ys) do :
    add{_, x} $
      if f(x, y) : true-xs
      else : false-xs
  [true-xs, false-xs]

public defn split!<?T> (xs:Seqable<?T>, ss:Seqable<True|False>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for (x in xs, s in ss) do :
      add{_, x} $
         if s : true-xs
         else : false-xs
   [true-xs, false-xs]

public defn split<?T> (f:T -> True|False, xs-items:Seqable<?T>) -> [Seq<T>, Seq<T>] :
  val xs = to-seq(xs-items)
  val a-items = Queue<T>()
  val b-items = Queue<T>()

  ;Pull next item onto queues
  defn pull () :
    val x = next(xs)
    if f(x) : add(a-items, x)
    else : add(b-items, x)

  ;Try to fill a queue, returns true if filled
  defn* fill (items:Queue<T>) -> True|False :
    if empty?(items) :
      if not empty?(xs) :
        pull()
        fill(items)
    else :
      true

  ;Create seq from queue
  defn queue-seq (items:Queue<T>) :
    new Seq<T> :
      defmethod next (this) :
        if fill(items) : pop(items)
        else : fatal("No more items")
      defmethod peek (this) :
        if fill(items) : peek(items)
        else : fatal("No more items")
      defmethod empty? (this) :
        not fill(items)

  [queue-seq(a-items), queue-seq(b-items)]

public defn fork<?T> (xs-items:Seqable<?T>) -> [Seq<T>, Seq<T>] :
  val xs = to-seq(xs-items)
  val a-items = Queue<T>()
  val b-items = Queue<T>()
  
  defn queue-seq (items:Queue<T>, other:Queue<T>) :
    new Seq<T> :
      defmethod next (this) :
        if empty?(items) :
          val x = next(xs)
          add(other, x)
          x
        else :
          pop(items)
      defmethod peek (this) :
        if empty?(items) : peek(xs)
        else : peek(items)
      defmethod empty? (this) :
        empty?(items) and empty?(xs)

  [queue-seq(a-items, b-items),
   queue-seq(b-items, a-items)]

public defn fork<?T> (xs-items:Seqable<?T>, n:Int) -> Tuple<Seq<T>> :
  val xs = to-seq(xs-items)
  val items = to-tuple(repeatedly(Queue<T>{}, n))

  ;Pull next item all queues except queue n
  defn pull (n:Int) :
    val x = next(xs)
    for (q in items, i in 0 to false) do :
      add(q, x) when i != n
    x

  to-tuple $ for i in 0 to n seq :
    val items = items[i]
    new Seq<T> :
      defmethod next (this) :
        if empty?(items) : pull(i)
        else : pop(items)
      defmethod peek (this) :
        if empty?(items) : peek(xs)
        else : peek(items)
      defmethod empty? (this) :
        empty?(items) and empty?(xs)

public defn take-while<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = peek(xs-seq)
               if f(x) :
                  next(xs-seq)
                  yield(x)
                  loop()
         loop()

public defn take-until<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = next(xs-seq)
               yield(x)
               loop() when not f(x)
         loop()

public defn take-n<?T> (n:Int, xs:Seqable<?T>) :
   ensure-non-negative("length", n)
   var len = n
   val xs-seq = to-seq(xs)
   new Seq<T> & Lengthable :
      defmethod next (this) :
         val v = peek(this)
         next(xs-seq)
         len = len - 1
         v
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         peek(xs-seq)
      defmethod empty? (this) :
         len == 0
      defmethod length (this) :
         len
      defmethod free (this) :
         free(xs-seq)

public defn take-up-to-n<?T> (n:Int, xs:Seqable<?T>) :
   ensure-non-negative("length", n)
   var len = n
   val xs-seq = to-seq(xs)
   new Seq<T> :
      defmethod next (this) :
         val v = peek(this)
         next(xs-seq)
         len = len - 1
         v
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         peek(xs-seq)
      defmethod empty? (this) :
         (len == 0) or empty?(xs-seq)
      defmethod free (this) :
         free(xs-seq)

public defn cat<?T> (a:Seqable<?T>, b:Seqable<?T>) -> Seq<T> :
   cat-all([a, b])

public defn cat-all<?T> (xss: Seqable<Seqable<?T>>) -> Seq<T> :
   generate<T> :
      for xs in xss do :
         do(yield, xs)

public defn seq-cat<?T,?R> (f:T -> Seqable<?R>, xs:Seqable<?T>) -> Seq<R> :
   cat-all(seq(f, xs))

public defn seq-cat<?T,?S,?R> (f:(T,S) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   cat-all(seq(f, xs, ys))

public defn seq-cat<?T,?S,?U,?R> (f:(T,S,U) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   cat-all(seq(f, xs, ys, zs))

public defn all?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   for xs-seq in xs do-seq :
      defn* loop () :
         if empty?(xs-seq) : true
         else : pred?(next(xs-seq)) and loop()
      loop()

public defn all?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         defn* loop () :
            if empty?(xs-seq) or empty?(ys-seq) : true
            else : pred?(next(xs-seq), next(ys-seq)) and loop()
         loop()

public defn all?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            defn* loop () :
               if empty?(xs-seq) or empty?(ys-seq) or empty?(zs-seq) : true
               else : pred?(next(xs-seq), next(ys-seq), next(zs-seq)) and loop()
            loop()

public defn none?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   defn notp (x) : not pred?(x)
   all?(notp, xs)

public defn none?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   defn notp (x1, x2) : not pred?(x1, x2)
   all?(notp, xs, ys)

public defn none?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   defn notp (x1, x2, x3) : not pred?(x1, x2, x3)
   all?(notp, xs, ys, zs)

public defn any?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   not none?(pred?, xs)

public defn any?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   not none?(pred?, xs, ys)

public defn any?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   not none?(pred?, xs, ys, zs)

public defn count (xs:Seqable) -> Int :
   match(xs) :
      (xs:Seqable & Lengthable) :
         length(xs)
       (xs) :
         var accum:Int = 0
         for x in xs do :
            accum = accum + 1
         accum

public defn count<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> Int :
   var accum:Int = 0
   for x in xs do :
      if pred?(x) : accum = accum + 1
   accum

public defn join<?T,?S> (xs0:Seqable<?T>, y:?S) -> Seq<T|S> :
  val xs = to-seq(xs0)
  var join? = false
  val rs = new Seq<T|S> :
    defmethod next (this) :
      fatal("Empty Sequence") when empty?(xs)
      val result = y when join? else next(xs)
      join? = not join?
      result
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(xs)
      y when join? else peek(xs)
    defmethod empty? (this) :
      empty?(xs)
  match(xs) :
    (xs:Seq<T> & Lengthable) :
      defn rs-length () :
        if join? : length(xs) * 2
        else : length(xs) * 2 - 1
      wrap-length(rs, rs-length)
    (xs) : rs

public defn interleave<?T,?S> (xs0:Seqable<?T>, ys0:Seqable<?S>) -> Seq<T|S> :
  val xs = to-seq(xs0)
  val ys = to-seq(ys0)
  var yield-x? = true
  val rs = new Seq<T|S> :
    defmethod next (this) :
      fatal("Empty Sequence") when empty?(this)
      val result = next(xs) when yield-x? else next(ys)
      yield-x? = not yield-x?
      result
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(this)
      peek(xs) when yield-x? else peek(ys)
    defmethod empty? (this) :
      empty?(xs) when yield-x? else empty?(ys)
  match(xs, ys) :
    (xs:Seq<T> & Lengthable, ys:Seq<S> & Lengthable) :
      defn rs-length () :
        if yield-x? : 2 * min(length(xs), length(ys))
        else : 1 + 2 * min(length(xs), length(ys) - 1)
      wrap-length(rs, rs-length)
    (xs, ys) : rs

public defn reduce<?T,?S> (f: (T, S) -> ?T, x0: ?T, xs:Seqable<?S>) -> T :
   var accum = x0
   for x in xs do :
      accum = f(accum, x)
   accum

public defn reduce<?T,?S> (f: (T|S, T) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      reduce(f, next(xs-seq), xs-seq)

public defn reduce-right<?T,?S> (f: (S, T) -> ?T, xs:Seqable<?S>, xn:?T) -> T :
   for xs-seq in xs do-seq :
      defn loop () :
         if empty?(xs-seq) : xn
         else : f(next(xs-seq), loop())
      loop()

public defn reduce-right<?T,?S> (f: (T, T|S) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      defn loop (x:T) :
         if empty?(xs-seq) : x
         else : f(x, loop(next(xs-seq)))
      loop(next(xs-seq))

public defn repeat<?T> (x:?T) -> Seq<T> :
   new Seq<T> :
      defmethod next (this) : x
      defmethod peek (this) : x
      defmethod empty? (this) : false

public defn repeat<?T> (x:?T, n:Int) :
   ensure-non-negative("length", n)
   var len = n
   new Seq<T> & Lengthable :
      defmethod next (this) :
         fatal("Empty Sequence") when len == 0
         len = len - 1
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         x
      defmethod empty? (this) :
         len == 0
      defmethod length (this) :
         len

deftype RepeatWhileSeq<T> <: Seq<T>
defmulti cached (s:RepeatWhileSeq) -> Int

public defn repeat-while<?T> (f: () -> Maybe<?T>) -> RepeatWhileSeq<T> :
  var item = sentinel
  defn fill () : (item = f()) when item is Sentinel
  
  new RepeatWhileSeq<T> :
    defmethod next (this) :
      val x = peek(this)
      item = sentinel
      x
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(this)
      value(item as One<T>)
    defmethod empty? (this) :
      fill()
      item is None
    defmethod cached (this) :
      1 when item is One else 0

public defn repeatedly<?T> (f:() -> ?T) -> Seq<T> :
   var item = sentinel
   defn fill () : (item = f()) when item is Sentinel

   defn empty () :
      val x = item as T
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         item as T
      defmethod empty? (this) :
         false

public defn repeatedly<?T> (f:() -> ?T, n:Int) :
   take-n(n, repeatedly(f))

public defn zip<?T,?S> (xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<[T,S]> :
   for (x in xs, y in ys) seq : [x, y]

public defn zip<?T,?S,?U> (xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<[T,S,U]> :
   for (x in xs, y in ys, z in zs) seq : [x, y, z]

public defn zip-all<?T> (xs:Seqable<Seqable<?T>>) :
   val seqs = to-tuple(seq(to-seq, xs))
   fatal("No Sequences Given") when empty?(seqs)
   val ret-seq = new Seq<Tuple<T>> :
      defmethod next (this) :
         map(next, seqs)
      defmethod peek (this) :
         map(peek, seqs)
      defmethod empty? (this) :
         any?(empty?, seqs)
   if all?({_ is Lengthable&Seq}, seqs) :
      val len = minimum{seq(length{_ as Lengthable&Seq}, seqs)}
      wrap-length(ret-seq, len)
   else :
      ret-seq

public defn unique<?T> (xs:Seqable<?T&Equalable>) -> List<T> :
   ;Manage Visited Set
   val table = HashTable<Hashable,True|False>()
   val accum = Vector<Equalable>()

   defn add-to-unique-set (x:T&Equalable) :
      match(x) :
         (x:T&Equalable&Hashable) : table[x] = true
         (x:T&Equalable) : add(accum, x)
   defn visited? (x:T&Equalable) :
      match(x) :
         (x:T&Equalable&Hashable) : key?(table, x)
         (x:T&Equalable) : contains?(accum, x)

   ;Filter
   to-list $ for x in xs filter :
      if not visited?(x) :
         add-to-unique-set(x)
         true

public defn lookup?<?K,?V,?D> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable, default:?D) -> D|V :
   label<V|D> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      default

public defn lookup?<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> False|V :
   lookup?(xs, k, false)

public defn lookup<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> V :
   label<V> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      fatal("Key %~ not found in entries." % [k])

public defn fork-on-seq<?T,?X,?Y> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y) -> [X,Y] :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val fco = make-co(f)
   val gco = make-co(g)

   ;Store function results
   var fresult = resume(fco, None())
   var gresult = resume(gco, None())

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         if fresult is None :
            fresult = resume(fco, v)
         if gresult is None :
            gresult = resume(gco, v)
         (fresult is None) or
         (gresult is None)
      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   [value!(fresult),
    value!(gresult)]

public defn fork-on-seq<?T,?X,?Y,?Z> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y, h:Seq<T> -> ?Z) -> [X,Y,Z] :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val fco = make-co(f)
   val gco = make-co(g)
   val hco = make-co(h)

   ;Store function results
   var fresult = resume(fco, None())
   var gresult = resume(gco, None())
   var hresult = resume(hco, None())

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         if fresult is None :
            fresult = resume(fco, v)
         if gresult is None :
            gresult = resume(gco, v)
         if hresult is None :
            hresult = resume(hco, v)
         (fresult is None) or
         (gresult is None) or
         (hresult is None)
      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   [value!(fresult),
    value!(gresult),
    value!(hresult)]

public defn fork-on-seq<?T,?S> (xs:Seqable<?T>, fs:Seqable<(Seq<T> -> ?S)>) -> Tuple<S> :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val cos = to-tuple(seq(make-co, fs))

   ;Store function results
   val results = to-array<Maybe<S>>(seq(resume{_, None()}, cos))

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         var more? = false
         for (co in cos, i in 0 to false) do :
            if results[i] is None :
               val r = resume(co, v)
               results[i] = r
               more? = more? or (r is None)
         more?

      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   to-tuple(seq(value!, results))

;============================================================
;=============== Commandline Arguments ======================
;============================================================

public lostanza defn command-line-arguments () -> ref<Array<String>> :
   val r = Array<String>(new Int{clib/input_argc})
   for (var i:int = 0, i < clib/input_argc, i = i + 1) :
      val str = clib/input_argv[i]
      set(r, new Int{i}, String(str))
   return r

;============================================================
;===================== Random Numbers =======================
;============================================================

public lostanza deftype Random :
  state: long
lostanza defn next-state (s0:long) -> long :
  return (s0 * 0x5deece66dL + 0xbL) & 0xFFFFFFFFFFFFL
lostanza defn extract-bits (s:long, n:int) -> int :
  return (s >>> (48 - n)) as int
lostanza defn next-bits (r:ref<Random>, n:int) -> int :
  val s = next-state(r.state)
  r.state = s
  return extract-bits(s, n)

public lostanza defn Random (state:ref<Long>) -> ref<Random> :
  return new Random{next-state(state.value)}

public lostanza defn state (r:ref<Random>) -> ref<Long> :
  return new Long{r.state}

public lostanza defn set-state (r:ref<Random>, state:ref<Long>) -> ref<False> :
  r.state = state.value
  return false

public defn Random () :
  Random(current-time-us())

public lostanza defn next-int (r:ref<Random>) -> ref<Int> :
  return new Int{next-bits(r, 31)}

public lostanza defn next-signed-int (r:ref<Random>) -> ref<Int> :
  return new Int{next-bits(r, 32)}

val LIMIT-STR = String("limit")
public lostanza defn next-int (r:ref<Random>, n0:ref<Int>) -> ref<Int> :
  ensure-positive(LIMIT-STR, n0)

  ;Extract lostanza values
  val n = n0.value

  ;Power of 2
  if n & (- n) == n :
    val bits = next-bits(r, 31) as long
    return new Int{((n * bits) >> 31) as int}

  ;Otherwise
  labels :
    loop :
      val bits = next-bits(r, 31)
      val v = bits % n
      if bits - v + (n - 1) < 0 : goto loop
      else : return new Int{v}

public lostanza defn next-bytes (r:ref<Random>, bs:ref<ByteArray>) -> ref<False> :
  val n = bs.length
  labels :
    begin: goto loop(r.state, 0)
    loop (s:long, i:long) :
      if i + 4 < n :
        val s* = next-state(s)
        [addr!(bs.data[i]) as ptr<int>] = extract-bits(s*, 32)
        goto loop(s*, i + 4)
      else : goto end(s, i)
    end (s:long, i:long) :
      if i < n :
        val s* = next-state(s)
        bs.data[i] = extract-bits(s*, 8) as byte
        goto end(s*, i + 1)
      else :
        r.state = s
        return false

public defn next-int (rand:Random, r:Range) :
  ;Returns an integer between lo and hi inclusive
  defn from-interval (lo:Int, hi:Int) :
    val spread = hi - lo + 1
    if spread < 0 :
      let loop () :
        val r = next-int(rand)
        if r >= lo and r <= hi : r
        else : loop()
    else :
      lo + next-int(rand, spread)

  ;Check
  #if-not-defined(OPTIMIZE) :
    if step(r) != 1 :
      fatal("Ranges with step sizes other than 1 not supported.")      
  val s = start(r)
  match(end(r), inclusive?(r)) :
    (e:Int, inc:True) :
      ensure-start-before-end(s, e)      
      from-interval(s, e)
    (e:Int, inc:False) :
      #if-not-defined(OPTIMIZE) :
        if e == s : fatal("Empty range.")
        else : ensure-start-before-end(s, e)
      from-interval(s, e - 1)
    (e:False, inc) :
      from-interval(s, INT-MAX)     

public lostanza defn next-long (rand:ref<Random>) -> ref<Long> :
  val x0 = next-bits(rand, 31) as long
  val x1 = next-bits(rand, 32) as long & 0xFFFFFFFFL
  val r0 = (x0 << 32L)
  return new Long{x0 << 32L | x1}

public lostanza defn next-signed-long (rand:ref<Random>) -> ref<Long> :
  val x0 = next-bits(rand, 32) as long
  val x1 = next-bits(rand, 32) as long & 0xFFFFFFFFL
  return new Long{x0 << 32L | x1}

public lostanza defn next-float (rand:ref<Random>) -> ref<Float> :
  return new Float{next-bits(rand,24) as float / (1 << 24) as float}

public lostanza defn next-double (rand:ref<Random>) -> ref<Double> :
  val num = ((next-bits(rand, 26) as long) << 27) + next-bits(rand, 27)
  val den = (1L << 53L) as double
  return new Double{num as double / den}

val RANDOM = Random(current-time-us())
public defn current-random () : RANDOM
public defn srand (n:Long) : set-state(RANDOM, n)
public defn rand () : next-int(RANDOM)
public defn rand-long () : next-long(RANDOM)
public defn rand-float () : next-float(RANDOM)
public defn rand-double () : next-double(RANDOM)
public defn rand (n:Int) : next-int(RANDOM, n)
public defn rand (r:Range) : next-int(RANDOM, r)

;============================================================
;=================== Process Library ========================
;============================================================

;                   Process Structure
;                   =================

public lostanza deftype Process :
  pid: long
  input: ptr<?>
  output: ptr<?>
  error: ptr<?>
  input-stream: ref<False|FileOutputStream>
  output-stream: ref<False|FileInputStream>
  error-stream: ref<False|FileInputStream>

;                 Process State Structure
;                 =======================

public deftype ProcessState
public defstruct ProcessRunning <: ProcessState
public defstruct ProcessDone <: ProcessState : (value:Int)
public defstruct ProcessTerminated <: ProcessState : (signal:Int)
public defstruct ProcessStopped <: ProcessState : (signal:Int)

defmethod print (o:OutputStream, s:ProcessState) :
  print{o, _} $ match(s) :
    (s:ProcessRunning) : "Running"
    (s:ProcessDone) : "Done(exit value = %_)" % [value(s)]
    (s:ProcessTerminated) : "Terminated(signal = %_)" % [signal(s)]
    (s:ProcessStopped) : "Stopped(signal = %_)" % [signal(s)]

;                   Stream Specifier
;                   ================

public defstruct StreamSpecifier <: Equalable : (value:Int)
public val STANDARD-IN = StreamSpecifier(0)
public val STANDARD-OUT = StreamSpecifier(1)
public val PROCESS-IN = StreamSpecifier(2)
public val PROCESS-OUT = StreamSpecifier(3)
public val STANDARD-ERR = StreamSpecifier(4)
public val PROCESS-ERR = StreamSpecifier(5)

defmethod equal? (a:StreamSpecifier, b:StreamSpecifier) :
  value(a) == value(b)

defmethod print (o:OutputStream, s:StreamSpecifier) :
  print{o, _} $ switch(value(s)) :
    0 : "STANDARD-IN"
    1 : "STANDARD-OUT"
    2 : "PROCESS-IN"
    3 : "PROCESS-OUT"
    4 : "STANDARD-ERR"
    5 : "PROCESS-ERR"

;                      Process Errors
;                      ==============
public defstruct ProcessAbortedError <: Exception :
  state: ProcessState
defmethod print (o:OutputStream, e:ProcessAbortedError) :
  match(state(e)) :
    (s:ProcessTerminated) : print(o, "Process prematurely terminated with signal %_." % [signal(s)])
    (s:ProcessStopped) : print(o, "Process prematurely stopped with signal %_." % [signal(s)])     

public deftype SystemCallException <: Exception
defn SystemCallException (msg:String) :
  new SystemCallException :
    defmethod print (o:OutputStream, this) :
      print(o, msg)

#if-defined(PLATFORM-WINDOWS) :
  #for (F in splice([
         (Process (filename:String, args:Seqable<String>,
                   input:StreamSpecifier, output:StreamSpecifier, error:StreamSpecifier))
         (Process (filename:String, args:Seqable<String>))
         (input-stream (p:Process))
         (output-stream (p:Process))
         (error-stream (p:Process))
         (state (p:Process))])) :
    public defn F :
      fatal("Process library not yet supported on Windows.")

  public defn call-system (file:String, args:Seqable<String>) -> Int :
    val args-seq = to-seq(args)
    fatal("Arguments list is empty.") when empty?(args-seq)
    next(args-seq) ;Remove first one
    val cmd = escape-shell-command(cat([file], args-seq))
    val r = call-system(cmd)
    throw(SystemCallException(linux-error-msg())) when r < 0
    r

  public defn initialize-process-launcher () :
    false  

  lostanza defn call-system (cmd:ref<String>) -> ref<Int> :
    return new Int{call-c clib/system(addr!(cmd.chars))}
  
#else :

  ;                           Constructor
  ;                           ===========
  public lostanza defn Process (filename:ref<String>,
                                args0:ref<Seqable<String>>,
                                input:ref<StreamSpecifier>,
                                output:ref<StreamSpecifier>,
                                error:ref<StreamSpecifier>) -> ref<Process> :
    ensure-valid-stream-specifiers(input, output, error)
    val args = to-tuple(args0)
    val proc = new Process{0, null, null, null, false, false, false}
    val input_v = value(input).value
    val output_v = value(output).value
    val error_v = value(error).value
    val nargs = args.length
    val argvs:ptr<ptr<byte>> = call-c clib/malloc((nargs + 1) * sizeof(ptr<?>))
    argvs[nargs] = null
    for (var i:long = 0, i < nargs, i = i + 1) :
      argvs[i] = addr!(args.items[i].chars)
    val launch_succ = call-c clib/launch_process(addr!(filename.chars), argvs,
      input_v, output_v, error_v, addr!([proc]))
    if launch_succ < 0 :
      throw(SystemCallException(linux-error-msg()))
    return proc
  public defn Process (filename:String, args:Seqable<String>) :
    Process(filename, args, STANDARD-IN, STANDARD-OUT, STANDARD-ERR)

  defn ensure-valid-stream-specifiers (input:StreamSpecifier, output:StreamSpecifier, error:StreamSpecifier) :
    if not contains?([STANDARD-IN, PROCESS-IN], input) :
      fatal("%_ is not a valid input stream specifier." % [input])
    if not contains?([STANDARD-OUT, PROCESS-OUT, PROCESS-ERR], output) :
      fatal("%_ is not a valid output stream specifier." % [output])
    if not contains?([STANDARD-ERR, PROCESS-OUT, PROCESS-ERR], error) :
      fatal("%_ is not a valid error stream specifier." % [error])

  ;                            Stream API
  ;                            ==========
  public lostanza defn input-stream (p:ref<Process>) -> ref<FileOutputStream> :
    if p.input-stream == false :
      if p.input == null : fatal(String("Process has no input stream."))
      p.input-stream = new FileOutputStream{p.input, 0}
    return p.input-stream as ref<FileOutputStream>
  public lostanza defn output-stream (p:ref<Process>) -> ref<InputStream> :
    if p.output-stream == false :
      if p.output == null : fatal(String("Process has no output stream."))
      p.output-stream = new FileInputStream{p.output, 0}
    return p.output-stream as ref<FileInputStream>
  public lostanza defn error-stream (p:ref<Process>) -> ref<InputStream> :
    if p.error-stream == false :
      if p.error == null : fatal(String("Process has no error stream."))
      p.error-stream = new FileInputStream{p.error, 0}
    return p.error-stream as ref<FileInputStream>

  ;                          Initialization
  ;                          ==============
  public lostanza defn initialize-process-launcher () -> ref<False> :
    call-c clib/initialize_launcher_process()
    return false  

  ;                            State API
  ;                            =========
  lostanza deftype StateStruct :
    state: int
    code: int
  public lostanza defn state (p:ref<Process>) -> ref<ProcessState> :
    val s = new StateStruct{0, 0}
    call-c clib/retrieve_process_state(p.pid, addr!([s]))
    
    ;State Codes
    val RUNNING = 0
    val DONE = 1
    val TERMINATED = 2
    val STOPPED = 3

    ;Translation
    if s.state == RUNNING :
      return ProcessRunning()
    else if s.state == DONE :
      return ProcessDone(new Int{s.code})
    else if s.state == TERMINATED :
      return ProcessTerminated(new Int{s.code})
    else if s.state == STOPPED :
      return ProcessStopped(new Int{s.code})
    else :
      return fatal(String("Unreachable"))

  ;                         System Call API
  ;                         ===============
  public defn call-system (file:String, args:Seqable<String>) -> Int :
    val p = Process(file, args)
    let loop () :
      match(state(p)) :
        (s:ProcessRunning) : loop()
        (s:ProcessDone) : value(s)
        (s) : throw(ProcessAbortedError(s))

;============================================================
;================== Shell Escaping ==========================
;============================================================

;Tokenize the given string using typical shell parsing rules.
public defn tokenize-shell-command (s:String) -> Collection<String> :
  defn whitespace? (c:Char) :
    (c == ' ') or
    (c == '\n') or
    (c == '\t') or
    (c == '\b') or
    (c == '\r')

  ;Buffer management
  val buffer = StringBuffer()
  val args = Vector<String>()
  defn add-char (c:Char) :
    add(buffer, c)
  defn make-arg () :
    add(args, to-string(buffer))
    clear(buffer)

  ;View characters as stream
  val stream = StringInputStream(s)

  ;General read dispatch
  defn* read () :
    val c = peek?(stream)
    match(c:Char) :
      if whitespace?(c) :
        get-char(stream)
        read()
      else :
        read-arg()

  defn* read-arg () :
    val c = peek?(stream)
    match(c:Char) :
      if whitespace?(c) :
        make-arg()
        read()
      else if c == '"' or c == '\'' :
        get-char(stream)
        read-until(c)
        read-arg()
      else if c == '\\' :
        get-char(stream)
        val c2 = get-char(stream)
        match(c2:Char) :
          add-char(c2)
          read-arg()
        else :
          make-arg()
      else :
        get-char(stream)
        add-char(c)
        read-arg()      
    else :
      make-arg()


  defn* read-until (end:Char) :
    val c = get-char(stream)
    match(c:Char) :
      if c == '\\' :
        val c2 = peek?(stream)
        match(c2:Char) :
          if c2 == end :
            get-char(stream)
            add-char(c2)
            read-until(end)
          else :
            add-char(c)
            read-until(end)
        else :
          add-char(c)
      else if c != end :
        add-char(c)
        read-until(end)

  ;End
  read()
  args

;Escape shell command
public defn escape-shell-command (args:Seqable<String>) -> String :
  #if-defined(PLATFORM-WINDOWS) :
    defn escape (s:String, i:Int) :
      val s* =
        replace{_, "\"", "\\\""} $
        replace{_, "\\", "\\\\"} $
        s
      if i == 0 : s*
      else : "\"%_\"" % [s*]
    val escaped = seq(escape, args, 0 to false)
    to-string("%s" % [escaped])
  #else :
    defn escape (s:String) :
      {"\"%_\"" % [_]} $
      replace{_, "\"", "\\\""} $
      replace{_, "\\", "\\\\"} $
      s
    to-string("%s" % [seq(escape, args)])

;============================================================
;===================== Id Pool ==============================
;============================================================

val ID-SEQ = to-seq(0 to false)
val FREE-IDS = Vector<Int>()
val OBJ-MAP = Vector<?>()

public lostanza defn box-object (x:ref<?>) -> int :
   var id:ref<Int>
   if empty?(FREE-IDS) == true : id = next(ID-SEQ)
   else : id = pop(FREE-IDS)
   set(OBJ-MAP, id, x)
   return id.value

public lostanza defn free-box (id:int) -> ref<False> :
   add(FREE-IDS, new Int{id})
   set(OBJ-MAP, new Int{id}, false)
   return false

public lostanza defn boxed-object (id:int) -> ref<?> :
   return get(OBJ-MAP, new Int{id})

;============================================================
;==================== Resources =============================
;============================================================

public deftype Resource
public defmulti free (r:Resource) -> False

protected defn with-resource<?T,?S> (f:T -> ?S, x:?T&Resource) -> S :
   try : f(x)
   finally : free(x)

;============================================================
;==================== LivenessTracker =======================
;============================================================

public deftype Unique

public lostanza deftype LivenessTracker :
  value: ref<False|Unique>
  tail: ptr<?>

public lostanza defn LivenessTracker (value:ref<Unique>) -> ref<LivenessTracker> :
  return new LivenessTracker{value, null}

public lostanza defn value (t:ref<LivenessTracker>) -> ref<False|Unique> :
  return t.value

;============================================================
;======================= Finalizers =========================
;============================================================

;LivenessHandler/run returns true if the LivenessHandler ran,
;and thus should be removed from the LivenessHandler list.
deftype LivenessHandler
defmulti run (f:LivenessHandler) -> True|False

val LIVENESS-HANDLERS = Vector<LivenessHandler>()
val QUEUED-LIVENESS-HANDLERS = Vector<LivenessHandler>()
add-gc-notifier $ fn () :
  add-all(LIVENESS-HANDLERS, QUEUED-LIVENESS-HANDLERS)
  clear(QUEUED-LIVENESS-HANDLERS)
  remove-when(run, LIVENESS-HANDLERS)

public deftype Finalizer
public defmulti run (f:Finalizer) -> ?

public defn add-finalizer (f:Finalizer, v:Unique) :
  val tracker = LivenessTracker(v)
  val liveness-handler = new LivenessHandler :
    defmethod run (this) :
      if value(tracker) is False :
        run(f)
        true
  add(QUEUED-LIVENESS-HANDLERS, liveness-handler)

public defn add-finalizer (f:() -> ?, v:Unique) :
  val tracker = LivenessTracker(v)
  val liveness-handler = new LivenessHandler :
    defmethod run (this) :
      if value(tracker) is False :
        f()
        true
  add(QUEUED-LIVENESS-HANDLERS, liveness-handler)

;============================================================
;==================== Autofree ==============================
;============================================================
;
;lostanza deftype FreeCallback :
;   c-convention:int
;   free:ptr<(ptr<?> -> int)>
;   value:ptr<?>
;
;lostanza defn free (c:ref<FreeCallback>) -> ref<False> :
;   if c.c-convention :
;      call-c [c.free](c.value)
;   else :
;      [c.free](c.value)
;   return false
;
;public lostanza defn c-autofree-marker (free:ptr<(ptr<?> -> int)>, value:ptr<?>) -> ref<LivenessMarker> :
;   val t = LivenessTracker(new FreeCallback{1, free, value})
;   add(FREE-CALLBACKS, t)
;   return marker!(t)
;
;public lostanza defn autofree-marker (free:ptr<(ptr<?> -> int)>, value:ptr<?>) -> ref<LivenessMarker> :
;   val t = LivenessTracker(new FreeCallback{0, free, value})
;   add(FREE-CALLBACKS, t)
;   return marker!(t)
;
;val FREE-CALLBACKS = Vector<LivenessTracker<FreeCallback>>()
;add-gc-notifier $ fn () :
;   for t in FREE-CALLBACKS remove-when :
;      if marker(t) is False :
;         free(value(t))
;         true
;
;============================================================
;=================== Pretty Printer =========================
;============================================================

;                  General Interface
;                  =================

public defmulti write (o:OutputStream, x) -> False

;                Default Implementation
;                ======================

defmethod write (o:OutputStream, x) :
   print(o, x)

public defn write-all (o:OutputStream, xs:Seqable) -> False :
   val xs-seq = to-seq(xs)
   if not empty?(xs-seq) :
      write(o, next(xs-seq))
   while not empty?(xs-seq) :
      print(o, " ")
      write(o, next(xs-seq))

;                    Escape Sequences
;                    ================

defn general-escape (o:OutputStream, c:Char) :
   defn escape (c:Char) :
      print(o, '\\')
      print(o, c)
   switch {c == _} :
      '\t' : escape('t')
      '\b' : escape('b')
      '\r' : escape('r')
      '\n' : escape('n')
      '\\' : escape('\\')
      else : print(o, c)

defn escape-for-string (o:OutputStream, c:Char) :
   if c == '\"' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

defn escape-for-symbol (o:OutputStream, c:Char) :
   if c == '|' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

defn escape-for-char (o:OutputStream, c:Char) :
   if c == '\'' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)

;              Determination Whether Symbol Requires Escape
;              ============================================

lostanza var NECESSARY-IDENTIFIER-CHARS:ref<String>
lostanza var IDENTIFIER-CHARS:ref<String>
lostanza var OPERATOR-CHARS:ref<String>

lostanza defn tag-char (table:ref<String>, c:byte) -> int :
   table.chars[c] = 1 as byte
   return 0

lostanza defn tag-chars (table:ref<String>, cs:ptr<byte>) -> int :
   for (var i:long = 0, 1, i = i + 1) :
      val c = cs[i]
      if c == 0 : return 0
      tag-char(table, c)
   fatal("Unreachable")
   return 0

lostanza let :
  NECESSARY-IDENTIFIER-CHARS = String(256, 0 as byte)
  IDENTIFIER-CHARS = String(256, 0 as byte)
  OPERATOR-CHARS = String(256, 0 as byte)

  val L = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
  val U = "_?"
  val D = "0123456789"
  val P = "~!@#$%^*+-=/"
  val S = ".:<>&|"

  tag-chars(NECESSARY-IDENTIFIER-CHARS, L)
  tag-chars(NECESSARY-IDENTIFIER-CHARS, U)

  tag-chars(IDENTIFIER-CHARS, L)
  tag-chars(IDENTIFIER-CHARS, U)
  tag-chars(IDENTIFIER-CHARS, D)
  tag-chars(IDENTIFIER-CHARS, P)

  tag-chars(OPERATOR-CHARS, P)
  tag-chars(OPERATOR-CHARS, S)

public deftype SymbolParseClass
public defstruct NumberClass <: SymbolParseClass
public defstruct IdentifierClass <: SymbolParseClass
public defstruct OperatorClass <: SymbolParseClass

defmethod print (o:OutputStream, c:SymbolParseClass) :
  print{o, _} $ match(c) :
    (c:NumberClass) : "Number"
    (c:IdentifierClass) : "Identifier"
    (c:OperatorClass) : "Operator"

lostanza defn digit-char? (b:byte) -> long :
  if b >= '0' and b <= '9' : return 1
  else : return 0

lostanza defn gensymbol? (s:ref<Symbol>) -> long :
  match(s) :
    (s:ref<GenSymbol>) : return 1
    (s) : return 0

public lostanza defn parse-as? (c:ref<Symbol>) -> ref<SymbolParseClass|False> :
  ;Does it parse as a number?
  val name = name(c)
  val l = length(name).value
  if (l == 0 and gensymbol?(c)) or
     digit-char?(name.chars[0]) or
     (name.chars[0] == '-' and l == 1 and gensymbol?(c)) or
     (name.chars[0] == '-' and l > 1 and digit-char?(name.chars[1])) :
    return NumberClass()

  ;Collect statistics
  var all-id:long = 1
  var all-op:long = 1
  var has-nid:long = 0
  for (var i:long = 0, i < l, i = i + 1) :
    val c = name.chars[i]
    if NECESSARY-IDENTIFIER-CHARS.chars[c] == 1 : has-nid = 1
    if IDENTIFIER-CHARS.chars[c] == 0 : all-id = 0
    if OPERATOR-CHARS.chars[c] == 0 : all-op = 0
  if gensymbol?(c) : all-op = 0

  ;Classify
  if l == 0 : return false
  else if all-id and has-nid : return IdentifierClass()
  else if all-op : return OperatorClass()
  else : return false

public defn escape? (s:Symbol) :
  parse-as?(s) is NumberClass|False

;                  Escaped Primitive Values
;                  ========================

defmethod write (o:OutputStream, c:Char) :
   print(o, '\'')
   escape-for-char(o, c)
   print(o, '\'')

defmethod write (o:OutputStream, s:String) :
   print(o, '"')
   for c in s do :
      escape-for-string(o, c)
   print(o, '"')

defmethod write (o:OutputStream, x:Byte) :
   print(o, x)
   print(o, 'Y')

defmethod write (o:OutputStream, x:Long) :
   print(o, x)
   print(o, 'L')

defmethod write (o:OutputStream, b:Float) :
   print(o, b)
   print(o, 'f')

defmethod write (o:OutputStream, s:StringSymbol) :
   if escape?(s) :
      print(o, "\\|")
      for c in name(s) do :
         escape-for-symbol(o, c)
      print(o, '|')
   else :
      print(o, name(s))

defmethod write (o:OutputStream, s:GenSymbol) :
   if escape?(s) :
      print(o, "\\|")
      for c in name(s) do :
         escape-for-symbol(o, c)
      print(o, id(s))
      print(o, '|')
   else :
      print(o, name(s))
      print(o, id(s))

;============================================================
;===================== Timers ===============================
;============================================================

public lostanza defn current-time-ms () -> ref<Long> :
   val ms = call-c clib/current_time_ms()
   return new Long{ms}

public lostanza defn current-time-us () -> ref<Long> :
   val us = call-c clib/current_time_us()
   return new Long{us}

public deftype Timer
public defmulti start (t:Timer) -> False
public defmulti stop (t:Timer) -> False
public defmulti time (t:Timer) -> Long

defn Timer (name:String, get-time: () -> Long) :
   var total-time:Long = 0L
   var last-time:Long = 0L
   var running = false
   new Timer :
      defmethod start (this) :
         fatal("Timer already running.") when running
         last-time = get-time()
         running = true
      defmethod stop (this) :
         fatal("Timer is not running.") when not running
         val time = get-time()
         total-time = total-time + time - last-time
         last-time = time
         running = false
      defmethod time (this) :
         if running : total-time + get-time() - last-time
         else : total-time
      defmethod print (o:OutputStream, this) :
         print(o, "[%_ Timer : %_]" % [name, time(this)])

public defn MillisecondTimer (name:String) :
   Timer(name, current-time-ms)

public defn MicrosecondTimer (name:String) :
   Timer(name, current-time-us)

public defn PiggybackTimer (name:String, t:Timer) :
   Timer(name, time{t})

;############################################################
;################## Math Package ############################
;############################################################

defpackage math :
   import core

public lostanza val PI:ref<Double> = new Double{3.141592653589793}
public lostanza val PI-F:ref<Float> = new Float{3.1415927f}

public lostanza defn exp (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/exp(x.value)}
public lostanza defn exp (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/exp(x.value) as float}

public lostanza defn log (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/log(x.value)}
public lostanza defn log (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/log(x.value) as float}

public lostanza defn log10 (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/log10(x.value)}
public lostanza defn log10 (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/log10(x.value) as float}

public lostanza defn sqrt (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sqrt(x.value)}
public lostanza defn sqrt (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sqrt(x.value) as float}

public lostanza defn pow (x:ref<Double>, y:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/pow(x.value, y.value)}
public lostanza defn pow (x:ref<Float>, y:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/pow(x.value, y.value) as float}

public lostanza defn sin (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sin(x.value)}
public lostanza defn sin (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sin(x.value) as float}

public lostanza defn cos (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/cos(x.value)}
public lostanza defn cos (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/cos(x.value) as float}

public lostanza defn tan (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/tan(x.value)}
public lostanza defn tan (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/tan(x.value) as float}

public lostanza defn asin (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/asin(x.value)}
public lostanza defn asin (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/asin(x.value) as float}

public lostanza defn acos (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/acos(x.value)}
public lostanza defn acos (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/acos(x.value) as float}

public lostanza defn atan (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/atan(x.value)}
public lostanza defn atan (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/atan(x.value) as float}

public lostanza defn atan2 (y:ref<Double>, x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/atan2(y.value, x.value)}
public lostanza defn atan2 (y:ref<Float>, x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/atan2(y.value, x.value) as float}

public lostanza defn sinh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sinh(x.value)}
public lostanza defn sinh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sinh(x.value) as float}

public lostanza defn cosh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/cosh(x.value)}
public lostanza defn cosh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/cosh(x.value) as float}

public lostanza defn tanh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/tanh(x.value)}
public lostanza defn tanh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/tanh(x.value) as float}

public lostanza defn ceil (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/ceil(x.value)}
public lostanza defn ceil (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/ceil(x.value) as float}

public lostanza defn floor (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/floor(x.value)}
public lostanza defn floor (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/floor(x.value) as float}

public lostanza defn round (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/round(x.value)}
public lostanza defn round (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/round(x.value) as float}

public lostanza defn to-radians (degrees:ref<Double>) -> ref<Double> :
   val pi = 3.141592653589793
   return new Double{degrees.value * pi / 180.0}

public lostanza defn to-degrees (radians:ref<Double>) -> ref<Double> :
   val pi = 3.141592653589793
   return new Double{radians.value * 180.0 / pi}

;################################################################################
;################################## Scratchpad ##################################
;################################################################################
;
;defpackage scratchpad :
;  import core
;
;
;lostanza defn println-num (x:ref<Int>) -> ref<False> :
;  call-c clib/printf("%d\n", x.value)
;  return false
;
;lostanza defn println-str (x:ref<String>) -> ref<False> :
;  call-c clib/printf("%s\n", addr!(x.chars))
;  return false
;  
;defn main () :
;  val c = Coroutine<Int,Int> $ fn (co, x0) :
;    var i:Int = 0
;    dynamic-wind(
;      fn () :
;        println-str("Entering winder")
;        println-num(i)
;        i = i + 1
;      fn () :
;        println-str("x0 = ")
;        println-num(x0)
;        val x1 = suspend(co, 42)
;        println-str("x1 = ")
;        println-num(x1)
;        val x2 = suspend(co, 43)
;        println-str("x2 = ")
;        println-num(x2)
;        44
;      fn (f) :
;        println-str("Exiting winder"))
;
;  println-str("enter")
;  val y0 = resume(c, -42)
;  println-str("y0 = ")
;  println-num(y0)
;  val y1 = resume(c, -43)
;  println-str("y1 = ")
;  println-num(y1)
;  val y2 = resume(c, -44)
;  println-str("y2 = ")
;  println-num(y2)
;
;let :
;  val a = `myconst
;  val b = `(myconst a b c)
;  println(a)
;  println(b[0])
;  println(a == b[0])
;
;main()
;
;;;defn main2 () :
;;;  val f = (multifn :
;;;    (x:Int) :
;;;      println-str("One Argument")
;;;    (x:Int, y:Int) :
;;;      println-str("Two Arguments")
;;;    (x:Int, y:Int, z:Int) :
;;;      println-str("Three Arguments")) as ?
;;;  f(10)
;;;  f(11, 12)
;;;  f(11, 12, 13)
;;;  f(11, 12, 13, 14)
;;;
;;;main2()
;;  
;;
