#use-added-syntax(tests)
defpackage destruct-tests :
  import core
  import collections

defstruct Person <: Equalable :
  age : Int

defmethod equal? (a:Person, b:Person) -> True|False : age(a) == age(b)

defstruct Family <: Equalable :
  p0 : Person
  p1 : Person

defmethod equal? (a:Family, b:Family) -> True|False : (p0(a) == p0(b)) and (p1(a) == p1(b)) 

deftest empty :
  val r = destruct(1) :
    (_) : false
  #EXPECT(r == false)

deftest id :
  val z = 2
  val r = destruct(z) :
    (?x) : x
  #EXPECT(r == z)

deftest id-int :
  val z = 2
  val r = destruct(z) :
    (?x:Int) : x
  #EXPECT(r == z)

deftest id-and-int :
  val z = 2
  val r = destruct(z) :
    (?x:Int and (x < 10)) : x
  #EXPECT(r == z)

deftest family :
  val p0 = Person(1)
  val p1 = Person(2)
  val f = Family(p0, p1)
  val [x, y, z] = destruct(f) :
    (?x:Family(?y, ?z)) : [x, y, z]
  #EXPECT(x == f and y == p0 and z == p1)

deftest person :
  val p0 = Person(1)
  val [x, a] = destruct(p0) :
    (?x:Person(?a:Int)) : [x, a]
  #EXPECT(x == p0 and a == age(p0))

deftest people :
  val p0 = Person(1)
  val p1 = Person(2)
  val f = Family(p0, p1)
  val [x, people] = destruct(f) :
    (?x:Family(?people:Person ...)) : [x, people]
  #EXPECT(x == f and people == [p0, p1])

deftest person-or-family :
  val p0 = Person(1)
  val f = Family(p0, p0)
  val r1 = destruct(f) :
    (?x:Family|Person) : x
  val r2 = destruct(p0) :
    (?x:Family|Person) : x
  #EXPECT(r1 == f and r2 == p0)

deftest tuple :
  val t1 = [1]
  val t2 = [1 2]
  val r1 = destruct(t1) :
    ([ ?x:Int ]) : x
    ([ ?x:Int ?y:Int ]) : [x y]
  val r2 = destruct(t2) :
    ([ ?x:Int ]) : x
    ([ ?x:Int ?y:Int ]) : [x y]
  #EXPECT(r1 == t1[0])
  #EXPECT(r2 == t2)

deftest tuple-rest :
  val t2 = [1 2]
  val r2 = destruct(t2) :
    ([ ?xs:Int ... ]) : xs
  #EXPECT(r2 == t2)

deftest nested-tuple :
  val t2 = [[1] [2]]
  val [a, b] = destruct(t2) :
    ([ [?x:Int] [?y:Int] ]) : [x y]
  #EXPECT(a == 1 and b == 2)

deftest list :
  val t2 = [1 2]
  val l2 = to-list $ t2
  val r2 = destruct(l2) :
    (List(?x, ?y)) : [x y]
  #EXPECT(r2 == t2)
