;################################################################################
;############################## C Library #######################################
;################################################################################

;================================================================================
;================================ Boot Sequence =================================
;================================================================================

defpackage clib
protected extern memcpy: (ptr<?>, ptr<?>, long) -> int
protected extern printf: (ptr<byte>, ? ...) -> int
protected extern fprintf: (ptr<?>, ptr<byte>, ? ...) -> int
protected extern malloc: long -> ptr<?>
protected extern free: ptr<?> -> int
protected extern exit: int -> int
protected extern get_stdout: () -> ptr<?>
protected extern get_stderr: () -> ptr<?>
protected extern get_stdin: () -> ptr<?>
protected extern get_eof: () -> int
protected extern input_argc: int
protected extern input_argv: ptr<ptr<byte>>
protected extern strlen: ptr<byte> -> int
protected extern system: (ptr<byte>) -> int
protected extern strerror: (int) -> ptr<byte>
protected extern get_errno: () -> int

;################################################################################
;############################## Core Library ####################################
;################################################################################

defpackage core

protected lostanza deftype Fn :
   length: long
   code: ptr<?>
   free: ref<?> ...
protected lostanza deftype Box :
   item: ref<?>
protected lostanza deftype Type :
   length: long
   code: ptr<?>
   free: ref<?> ...
protected lostanza deftype StackFrame :
  return: long
  liveness-map: long
  slots: long ...
protected lostanza deftype Stack :
  size: long
  frames: ptr<StackFrame>
  stack-pointer: ptr<StackFrame>
  pc: long
protected lostanza deftype VMState :
  ;Permanent State
  ;Changes in-between each code load
  instructions: ptr<byte>
  registers: ptr<long>
  global-offsets: ptr<long>
  global-mem: ptr<byte>
  const-table: ptr<long>
  const-mem: ptr<byte>
  data-offsets: ptr<int>
  data-mem: ptr<byte>
  extern-addresses: ptr<long>
  extern-defn-addresses: ptr<long>
  code-offsets: ptr<int>
  extend-heap-id: int
  extend-stack-id: int
  ;Variable State
  ;Changes in-between each boundary change
  heap: ptr<long>      
  heap-top: ptr<long>  
  heap-limit: ptr<long>
  free: ptr<long>      
  free-limit: ptr<long>
  current-stack: long
  ;Need for system stubs
  system-stack: long
  system-registers: ptr<long>
  ;Tables
  class-table: ptr<ptr<ClassRecord>>
  global-root-table: ptr<GlobalRoots>
  stackmap-table: ptr<ptr<StackMap>>

public deftype Unique

public lostanza deftype LivenessTracker :
  value: ref<False|Unique>
  tail: ptr<?>
  

protected lostanza defn arity-error (arity:long) -> ref<Void> :
  return fatal("arity error")

protected defn no-method-error (multi:String, args:Tuple) :  
  fatal("no method error")
  
protected defn amb-method-error (multi:String, args:Tuple) :
  fatal("amb method error")
   
protected defn no-branch-error (args:Tuple) :
  fatal("no branch error")
  
protected defn amb-branch-error (args:Tuple) :
  fatal("amb branch error")

protected lostanza defn tuple-length-error (actual-len:long, expected-len:long) -> ref<Void> :
  return fatal("tuple length error")
  
protected defn variable-uninitialized-error (name:String|False) -> Void :
  fatal("variable uninitialized error")

protected lostanza defn cast-error (type:ref<Type>, obj:ref<?>, ctxt:int) -> ref<Void> :
  call-c clib/printf("cast-error %ld\n", ctxt)
  return fatal("cast error")

protected lostanza defn invalid-return-error () -> ref<Void> :
  return fatal("invalid return error")

public lostanza defn fatal (msg:ptr<byte>) -> ref<Void> :
  return halt()

public defn fatal (msg) -> Void :  
  halt()

lostanza defn halt () -> ref<Void> :
  call-c clib/exit(-1)
  return false as ref<?>

lostanza defn print-stack-trace () -> ref<False> :
  return false

defn execute-toplevel-command (f:() -> False) :
  false

lostanza defn print-stack-trace (s:ref<Stack>) -> ref<False> :
  return false

public lostanza deftype Byte :
  value: byte
  
public lostanza deftype Char :
  value: byte

public lostanza deftype Int :
  value: int

public lostanza deftype Long :
  value: long

public lostanza deftype Float :
  value: float

public lostanza deftype Double :
  value: double

public lostanza deftype String :
  length: long
  hash: int
  chars: byte ...

public deftype Symbol
public lostanza deftype StringSymbol <: Symbol :
  name: ref<String>
public deftype GenSymbol <: Symbol

public lostanza deftype True
public lostanza deftype False

public lostanza deftype Tuple<T> :
  length: long
  items: ref<T> ...

public deftype List<T>
lostanza deftype FullList<T> <: List<T> :
  head: ref<T>
  tail: ref<List<T>>
lostanza deftype NilList <: List<Void>

lostanza val stdout:ptr<?> = call-c clib/get_stdout()
lostanza val stderr:ptr<?> = call-c clib/get_stderr()
lostanza val stdin:ptr<?> = call-c clib/get_stdin()
lostanza val EOF:int = call-c clib/get_eof()

lostanza deftype Sentinel
lostanza val sentinel:ref<Sentinel> = new Sentinel{}

;============================================================
;================ Constant Initialization ===================
;============================================================

lostanza var const-ptr:ptr<?>
lostanza val BYTE-CONST-TAG : int = 0
lostanza val CHAR-CONST-TAG : int = 1
lostanza val INT-CONST-TAG : int = 2
lostanza val LONG-CONST-TAG : int = 3
lostanza val FLOAT-CONST-TAG : int = 4
lostanza val DOUBLE-CONST-TAG : int = 5
lostanza val TRUE-CONST-TAG : int = 6
lostanza val FALSE-CONST-TAG : int = 7
lostanza val LIST-CONST-TAG : int = 8
lostanza val STRING-CONST-TAG : int = 9
lostanza val SYMBOL-CONST-TAG : int = 10
lostanza val TYPE-CONST-TAG : int = 11
lostanza val FN-CONST-TAG : int = 12
lostanza val INTERNED-CONST-TAG : int = 13
lostanza var initialized-symbol-table? : long = 0L
lostanza var consts-top : long = 4L
lostanza var num-loaded-consts : long = 0L

protected lostanza defn initialize-constants () -> ref<False> :
  call-c clib/printf("initializing constants\n")
  ;Initialize read pointer to beginning of the constant table
  ;[num, constants ...]
  val vms:ptr<VMState> = call-prim flush-vm()
  val consts-data = vms.const-mem

  ;Read total number of constants
  const-ptr = consts-data
  val n-consts = read-const-int()
  call-c clib/printf("n-consts = %d\n", n-consts)

  ;Populate constants vector
  const-ptr = consts-data + consts-top
  var cs:ptr<ref<?>> = vms.const-table as ptr<ref<?>>
  while num-loaded-consts < n-consts :
    call-c clib/printf("initializing constant %d\n", num-loaded-consts)
    cs[num-loaded-consts] = read-const(vms)
    num-loaded-consts = num-loaded-consts + 1

  ;Set new top
  consts-top = const-ptr - consts-data  
  return false

lostanza defn read-const (vms:ptr<VMState>) -> ref<?> :
  val tag = read-const-int()
  call-c clib/printf("constant tag %d\n", tag)
  if tag == BYTE-CONST-TAG :
    return new Byte{read-const-byte()}
  else if tag == CHAR-CONST-TAG :
    return new Char{read-const-byte()}
  else if tag == INT-CONST-TAG :
    return new Int{read-const-int()}
  else if tag == LONG-CONST-TAG :
    return new Long{read-const-long()}
  else if tag == FLOAT-CONST-TAG :
    return new Float{read-const-float()}
  else if tag == DOUBLE-CONST-TAG :
    return new Double{read-const-double()}
  else if tag == TRUE-CONST-TAG :
    return true
  else if tag == FALSE-CONST-TAG :
    return false
  else if tag == LIST-CONST-TAG :
    val len = read-const-int()
    return read-const-list(len, vms)
  else if tag == STRING-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)
    return String(len, chars)
  else if tag == SYMBOL-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)    
    val str = String(len, chars)
    return str
    ;if initialized-symbol-table? : return to-symbol(str)
    ;else : return new StringSymbol{str}
  else if tag == TYPE-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Type{0, code}
  else if tag == FN-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Fn{0, code}
  else if tag == INTERNED-CONST-TAG :
    val i = read-const-int()
    val cs = vms.const-table as ptr<ref<?>>
    return cs[i]
  else :
    call-c clib/printf("Unknown constant tag: %d\n", tag)
    return fatal("Unknown constant tag")

initialize-constants()

lostanza defn read-const-list (n:int, vms:ptr<VMState>) -> ref<List> :
  if n == 0 : return new NilList{}
  else : return new FullList{read-const(vms), read-const-list(n - 1, vms)}

lostanza defn read-const-byte () -> byte :
  val value = [const-ptr as ptr<byte>]
  const-ptr = const-ptr + sizeof(byte)
  return value

lostanza defn read-const-int () -> int :
  val value = [const-ptr as ptr<int>]
  const-ptr = const-ptr + sizeof(int)
  return value

lostanza defn read-const-long () -> long :
  val value = [const-ptr as ptr<long>]
  const-ptr = const-ptr + sizeof(long)
  return value

lostanza defn read-const-float () -> float :
  val value = [const-ptr as ptr<float>]
  const-ptr = const-ptr + sizeof(float)
  return value

lostanza defn read-const-double () -> double :
  val value = [const-ptr as ptr<double>]
  const-ptr = const-ptr + sizeof(double)
  return value

lostanza defn read-const-chars (len:long) -> ptr<byte> :
  val value = const-ptr as ptr<byte>
  ;length chars + pad to nearest 4 bytes
  val n = (len + 3) & -4
  const-ptr = (const-ptr + n) as ptr<?>
  return value

lostanza defn extend-heap (size:long) -> long :
  ;Collect garbage, and ensure we freed enough space
  val remaining = call-prim collect-garbage(size)
  if remaining < size : fatal("Out of memory.")
  ;Now run the GC notifiers, if they have been initialized
  ;if initialized-gc-notifiers? :
  ;  run-gc-notifiers()
  ;If GC notifiers allocated too much space, then collect the garbage again
  ;(Happens rarely.)
  val vms:ptr<VMState> = call-prim flush-vm()
  val remaining-after-notifiers = vms.heap-limit - vms.heap-top
  if remaining-after-notifiers < size :
    ;Collect garbage, and ensure we freed enough space
    val remaining = call-prim collect-garbage(size)
    if remaining < size : fatal("Out of memory.")
  return 0

lostanza defn extend-stack (size:long) -> long :
  call-c clib/printf("extend-stack by %ld bytes\n", size)

  ;Retrieve stack
  val vms:ptr<VMState> = call-prim flush-vm()

  call-c clib/printf("current-stack = %p\n", vms.current-stack)
  call-c clib/printf("system-stack = %p\n", vms.system-stack)
  call-c clib/printf("current stack frames = %p\n", addr!([vms.current-stack as ref<Stack>]).frames)
  call-c clib/printf("system stack frames = %p\n", addr!([vms.system-stack as ref<Stack>]).frames)

  val s:ptr<Stack> = addr!([vms.system-stack as ref<Stack>])
  call-c clib/printf("s.stack-pointer = %p\n", s.stack-pointer)
  call-c clib/printf("size = %ld\n", size)
  call-c clib/printf("s.frames = %p\n", s.frames)
  call-c clib/printf("s.size = %ld\n", s.size)
  call-c clib/printf("desired-size = %ld\n", s.stack-pointer + size - s.frames)

  ;Compute new size of stack
  val desired-size = s.stack-pointer + size - s.frames
  var size*:long = s.size
  while size* < desired-size : size* = size* * 2
  call-c clib/printf("extended to %ld bytes\n", size*)

  ;Allocate new frames and copy over old frames
  val frames* = call-c clib/malloc(size*)
  call-c clib/memcpy(frames*, s.frames, s.size)
  call-c clib/free(s.frames)
  
  ;Swap in new frames
  s.stack-pointer = s.stack-pointer + (frames* - s.frames)
  s.size = size*
  s.frames = frames*
  
  ;Return
  return 0
  
protected lostanza defn void-tuple (n:long) -> ref<Tuple> :
  val x = new Tuple{n}
  for (var i:long = 0, i < n, i = i + 1) :
    x.items[i] = sentinel
  return x   

public lostanza defn String (len:long) -> ref<String> :
  return new String{len + 1, 0}

public lostanza defn String (chars:ptr<byte>) -> ref<String> :
  val len = call-c clib/strlen(chars)
  return String(len, chars)

public lostanza defn String (len:long, chars:ptr<byte>) -> ref<String> :
  val s = String(len)
  call-c clib/memcpy(addr!(s.chars), chars, len)
  s.chars[len] = 0 as byte
  return s

;============================================================
;============= Garbage Collector with Resizing ==============
;============================================================

lostanza defn collect-garbage (size:long) -> long :
  ;Retrieve state
  val vms:ptr<VMState> = call-prim flush-vm()
  
  ;Maximum heap size
  val maximum-heap-size = 4L * 1024L * 1024L * 1024L
  
  ;First run the garbage collector,
  collect-garbage(vms)

  ;Check whether we're still out of space.
  if vms.heap-top + size > vms.heap-limit :
    ;Compute desired heap size
    val desired-space = vms.heap-top + size - vms.heap
    ;Extend-heap failure if we're out of space.
    if desired-space > maximum-heap-size :
      call-c clib/printf("extend-heap failed\n")
      return 0
    ;Expand the heap
    var space:long = vms.heap-limit - vms.heap
    while space < desired-space : space = space * 2
    ;Resize the heap and use the GC to move contents over
    resize-freespace(vms, space)
    collect-garbage(vms)
    resize-freespace(vms, space)
    ;Now we have enough space.
    return vms.heap-limit - vms.heap

  ;We're not out of space, so we don't need to expand the heap,
  ;but we might want to for next time.
  else :
    ;Expand the freeheap if we're using more than 50% of it,
    ;or if the heapspace is bigger than the freespace.
    val used-space = vms.heap-top - vms.heap
    val heap-space = vms.heap-limit - vms.heap
    val free-space = vms.free-limit - vms.free
    val usage-ratio = (used-space as float) / (heap-space as float)
    ;Resize free if the usage-ratio is too high
    if usage-ratio > 0.5f :
      resize-freespace(vms, heap-space * 2)
    ;Otherwise resize free if the heap is larger than free
    else if heap-space > free-space :
      resize-freespace(vms, heap-space)
    ;We have enough space to satisfy the request
    return vms.heap-limit - vms.heap

lostanza defn resize-freespace (vms:ptr<VMState>, space:long) -> int :
  call-c clib/free(vms.free)
  vms.free = call-c clib/malloc(space)
  vms.free-limit = vms.free + space
  return 0

;============================================================
;==================== Garbage Collector =====================
;============================================================

lostanza deftype GlobalRoots :
  length: int
  roots: int ...

lostanza deftype LivenessTrackerObj :
  tag: long
  value: long
  tail: ptr<LivenessTrackerObj>

lostanza deftype ObjectLayout :
  tag: long
  slots: long ...

lostanza deftype BrokenHeartLayout :
  tag: long
  forward: long

lostanza deftype StackMap :
  size: int
  num-roots: int
  roots: int ...

public lostanza val null:ptr<?> = 0L as ptr<?>  

lostanza var TRACKER-CHAIN:ptr<LivenessTrackerObj>
lostanza defn collect-garbage (vms:ptr<VMState>) -> long :
  ;Swap free with heap
  val heap = vms.heap
  val heap-limit = vms.heap-limit
  val free = vms.free
  val free-limit = vms.free-limit
  vms.heap = free
  vms.heap-top = free
  vms.heap-limit = free-limit
  vms.free = heap
  vms.free-limit = heap-limit

  ;Initialize tracker chain
  TRACKER-CHAIN = null

  ;Scan global roots
  call-c clib/printf("scan globals\n")
  val globals = vms.global-mem as ptr<long>
  val roots = vms.global-root-table
  val nroots = roots.length
  for (var i:int = 0, i < nroots, i = i + 1) :
    val r = roots.roots[i]
    globals[r] = post-gc-object(globals[r], vms)

  ;Scan const roots
  call-c clib/printf("scan consts\n")
  val consts = vms.const-table
  val nconsts = [vms.const-mem as ptr<int>]
  for (var i:int = 0, i < nconsts, i = i + 1) :
    consts[i] = post-gc-object(consts[i], vms)
  
  ;Scan stack roots
  call-c clib/printf("scan stacks\n")
  vms.current-stack = post-gc-object(vms.current-stack, vms)
  vms.system-stack = post-gc-object(vms.system-stack, vms)

  ;Scan heap
  call-c clib/printf("scan heap\n")
  scan-heap(vms)

  ;Scan tracker chain
  ;scan-tracker-chain(TRACKER-CHAIN)

  ;Return
  call-c clib/printf("GC done. exiting\n")
  halt()
  return 0

lostanza defn object-size-on-heap (sz:long) -> long :
  val ceiled = (8L + sz + 7L) & -8L
  return max(ceiled, 16L)
lostanza defn object-size-on-heap (sz:ref<Int>) -> ref<Int> :
  return new Int{object-size-on-heap(sz.value) as int}

lostanza defn scan-frames (frames:ptr<StackFrame>, f-end:ptr<StackFrame>, vms:ptr<VMState>) -> int :
  var f:ptr<StackFrame> = frames
  while f <= f-end :
    val map = vms.stackmap-table[f.liveness-map]
    val num-live = map.num-roots
    for (var i:int = 0, i < num-live, i = i + 1) :
      val s = map.roots[i]
      f.slots[s] = post-gc-object(f.slots[s], vms)
    f = f + map.size
  return 0

lostanza defn scan-heap (vms:ptr<VMState>) -> int :
  var p:ptr<long> = vms.heap
  while p < vms.heap-top :
    p = scan-object(p, vms)
  return 0

;lostanza defn scan-tracker-chain (tracker-chain:ptr<LivenessTrackerObj>) -> int :
;  var t:ptr<LivenessTrackerObj> = tracker-chain
;  while t != null :
;    t.value = post-gc-weak-object(t.value)
;    t = t.tail    
;  return 0
;
;lostanza defn post-gc-weak-object (ref:long) -> long :
;  val tagbits = ref & 7L
;  if tagbits == REF-TAG-BITS :
;    val obj = (ref - REF-TAG-BITS) as ptr<long>
;    val obj-tag = [obj]
;    ;Case: Broken Heart
;    if obj-tag == -1L :
;      val heart = obj as ptr<BrokenHeartLayout>
;      return heart.forward
;    ;Case: Uncopied object
;    else :
;      return false-marker()
;  else :
;    return ref
;

lostanza defn scan-object (p:ptr<long>, vms:ptr<VMState>) -> ptr<long> :
  ;p is [tag, cells ...]
  val tag = [p] as int
  val class-rec = vms.class-table[tag]
  
  ;Leaf class
  if class-rec.item-size == 0 :
    ;If it's a LivenessTracker, then extend the chain
    if tag == tagof(LivenessTracker) :
      val t = p as ptr<LivenessTrackerObj>
      t.tail = TRACKER-CHAIN
      TRACKER-CHAIN = t
      return p + sizeof(LivenessTrackerObj)
    else :
      ;Scan the frames of a stack
      if tag == tagof(Stack) :
        val s = (p + 8) as ptr<Stack>
        scan-frames(s.frames, s.stack-pointer, vms)
      ;Get properties
      val size = object-size-on-heap(class-rec.size)
      val roots = addr(class-rec.roots)
      val num-roots = class-rec.num-roots
      ;Scan slots
      val obj = p as ptr<ObjectLayout>
      for (var i:int = 0, i < num-roots, i = i + 1) :
        val r = roots[i]
        obj.slots[r] = post-gc-object(obj.slots[r], vms)
      ;Return end of object
      return p + size
  ;Array class
  else :
    val array-rec = class-rec as ptr<ArrayRecord>
    ;Get properties
    val base-size = array-rec.base-size
    val item-size = array-rec.item-size
    val num-base-roots = array-rec.num-base-roots
    val num-item-roots = array-rec.num-item-roots
    val base-roots = addr(array-rec.roots)
    val item-roots = addr(array-rec.roots[num-base-roots])
    ;Scan base roots
    val array = p as ptr<ObjectLayout>
    val len = array.slots[0]
    for (var i:int = 0, i < num-base-roots, i = i + 1) :
      val r = base-roots[i]
      array.slots[r] = post-gc-object(array.slots[r], vms)
    ;Scan item roots
    var items:ptr<long> = addr(array.slots) + base-size
    if num-item-roots > 0 :
      for (var n:long = 0, n < len, n = n + 1) :
        for (var i:int = 0, i < num-item-roots, i = i + 1) :
          val r = item-roots[i]
          items[r] = post-gc-object(items[r], vms)
        items = items + item-size
    ;Return end of array
    return p + object-size-on-heap(base-size + item-size * len)
  
lostanza defn post-gc-object (ref:long, vms:ptr<VMState>) -> long :
  call-c clib/printf("post-gc-object(%p)\n", ref)
  val tagbits = ref & 7L
  if tagbits == 1L :
    val obj = (ref - 1L) as ptr<long>
    val obj-tag = [obj]
    ;Case: Broken Heart
    if obj-tag == -1L :
      val heart = obj as ptr<BrokenHeartLayout>
      return heart.forward
    ;Case: Uncopied object
    else :
      val obj* = tag(vms.heap-top)
      val class-rec = vms.class-table[obj-tag]
      copy-bytes-to-heap(obj, num-bytes(obj, class-rec, vms), vms)
      set-broken-heart(obj, obj*)
      return obj*
  else :
    return ref

;lostanza defn set-broken-heart (obj:ptr<long>, obj*:long) -> int :
;  val heart = obj as ptr<BrokenHeartLayout>
;  heart.tag = -1L
;  heart.forward = obj*
;  return 0
;
;lostanza defn num-bytes (obj:ptr<?>, class:ref<VMClass>, vms:ptr<VMState>) -> long :
;  match(class) :
;    (class:ref<VMLeafClass>) :
;      return object-size-on-heap(size(class).value)
;    (class:ref<VMArrayClass>) :
;      val array = obj as ptr<ObjectLayout>
;      val len = array.slots[0]
;      val base-size = base-size(class).value
;      val item-size = item-size(class).value
;      return object-size-on-heap(base-size + len * item-size)
;
;lostanza defn copy-bytes-to-heap (p:ptr<?>, n:long, vms:ptr<VMState>) -> int :
;  val heap = vms.heap-top
;  val nwords = n >>> 3
;  val src = p as ptr<long>
;  for (var i:long = 0, i < nwords, i = i + 1) :
;    heap[i] = src[i]
;  vms.heap-top = heap + n
;  return 0
;
lostanza defn max (x:long, y:long) -> long :
  if x < y : return y
  else : return x

;============================================================
;==================== Class Name ============================
;============================================================

lostanza deftype ClassRecord :
  name:ptr<byte>
  size:int
  item-size:int
  num-roots:int
  roots:int ...
  
lostanza deftype ArrayRecord :
  name:ptr<byte>
  base-size:int
  item-size:int
  num-base-roots:int
  num-item-roots:int
  roots:int ...

lostanza defn class-name (x:int) -> ptr<byte> :
  val vms:ptr<VMState> = call-prim flush-vm()
  val record = vms.class-table[x]
  return record.name

lostanza deftype MyUniqueMarker <: Unique
lostanza deftype MyMarker

lostanza defn allocate-stack () -> ref<Stack> :
  val stack-size = 4 * 1024
  val frames:ptr<StackFrame> = call-c clib/malloc(stack-size)
  frames.return = -1L
  frames.liveness-map = 0L
  val null = 0L as ptr<?>
  return new Stack{stack-size, frames, null, 0}

public lostanza defn try-stack () -> ref<?> :
  call-c clib/printf("try-stack\n")
  val stk = allocate-stack()
  stk.pc = addr(setup-coroutine) as long
  val vms:ptr<VMState> = call-prim flush-vm()
  val current-stack = vms.current-stack as ref<Stack>
  
  val reta:ref<Int> = call-prim enter-stack(stk, current-stack)
  call-c clib/printf("reta = %d\n", reta.value)

  val retb:ref<Int> = call-prim yield(stk, new Int{2})
  call-c clib/printf("retb = %d\n", retb.value)

  val retc:ref<Int> = call-prim yield(stk, new Int{3})
  call-c clib/printf("retc = %d\n", retc.value)
  
  return false

lostanza defn* setup-coroutine (stack:ref<Stack>, parent-stack:ref<Stack>) -> ref<?> :
  call-c clib/printf("inside setup-coroutine\n")
  
  val ret0:ref<Int> = call-prim yield(parent-stack, new Int{10})
  call-c clib/printf("ret0 = %d\n", ret0.value)

  val ret1:ref<Int> = call-prim yield(parent-stack, new Int{11})
  call-c clib/printf("ret1 = %d\n", ret1.value)

  val ret2:ref<Int> = call-prim yield(parent-stack, new Int{12})
  call-c clib/printf("ret2 = %d\n", ret2.value)
  
  return halt()

;try-stack()

lostanza defn blow-heap (n:int) -> int :
  for (var i:int = 0, i < n, i = i + 1) :
    call-c clib/printf("i = %d\n", i)
    void-tuple(50)
  return 0

lostanza defn blow-stack (i:int, n:int) -> int :
  call-c clib/printf("i = %d\n", i)
  if i < n :
    blow-stack(i + 1, n)
  return 0

lostanza let :
  blow-heap(1000)

lostanza defn hello-world () -> ref<False> :
  call-c clib/printf("hello world\n")
  return false

lostanza defn goodbye-world () -> ref<False> :
  call-c clib/printf("Goodbye world\n")
  return false

defn f<T> (x) :
  hello-world()
  val y:T = x
  goodbye-world()

f<Int>(10)

;lostanza let :
;  for (var i:int = 0, i < 5, i = i + 1) :
;    val comparison = i < 5
;    call-c clib/printf("comparison = %d\n", comparison)
;    call-c clib/printf("Class %d = %s\n", i, class-name(i))