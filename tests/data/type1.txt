deftype Num
deftype Int <: Num
deftype String
deftype Seqable<T>
deftype Collection<T> <: Seqable<T>
deftype Tuple<T> <: Collection<T>
deftype Array<T> <: Collection<T>
;<comment>
subtype Int <: Int

subtype Array<Int> <: Array<Int>

subtype Array<Int> & String <: Array<Int>

subtype Array<Int> <: Seqable<Int|String>

subtype Int -> Num <: Int -> Int

subtype Int -> Num <: Int -> Num

subtype Int -> Num <: ?

subtype [Int, Int] <: String

subtype [Int, Num] <: Seqable<Num>

subtype [Int, Num] <: Seqable<Int>

subtype [Int, Int] <: Seqable<String>

subtype Int <: $a

subtype Int <: Array<$a>

subtype Int <: $a | Int

capture(X) $a <: Array<?X> | ?

capture(X) $a&Num <: Array<?X> | Num

capture(U) Int <: Array<?U>

capture(T) Array<Int> <: Seqable<?T>

capture(T) ? <: Int|?T

capture(T) ? <: ?|?T

capture(T) Int <: Num|?T

capture(T) Array<Int> <: Seqable<Num>|?T

capture(T) Array<Int> <: Seqable<String>|?T

capture(T) [Int, String] <: Seqable<?T>

capture(T) [Int, Int, String] <: Seqable<?T>

capture(T) Array<Int> <: Seqable<?T&Num>

capture(T) Array<Int> <: Seqable<?T&String>

infer [Int, Num, String] <: tuple-slot(0 of 3)

infer [Int, Num, String] <: tuple-slot(1 of 3)

infer [Int, Num, String] <: tuple-slot(2 of 3)

infer [Int, Num, String] <: tuple-slot(1 of 2)

infer [Int, Num]|[String, Num] <: tuple-slot(0 of 2)

infer [Int, Num]&[String, Num] <: tuple-slot(0 of 2)

infer [Int, Num]|? <: tuple-slot(1 of 2)

infer ? <: tuple-slot(1 of 2)

infer Int -> Int <: arg(0 of 1)

infer (Int -> Int) | (String -> Int) <: arg(0 of 1)

infer Int|String -> Int <: arg(0 of 1)

infer (Int -> Int) & ((String, String) -> Int) <: arg(0 of 1)

infer (Int -> Int) & ((String, String) -> Int) <: arg(0 of 2)

infer arg(0 of 1) <: Int -> Int

infer arg(0 of 1) <: (Int -> Int) | (String -> Int)

infer arg(0 of 1) <: (Int -> Int) & ((String, String) -> Int)

infer arg(0 of 1) <: (Int -> Int) & ((String, String) -> Int)

infer arg(0 of 2) <: (Int -> Int)

infer arg(0 of 1) <: (Int -> Int) | ((String, String) -> Int)

infer arg(0 of 2) <: (Int -> Int) | ((String, String) -> Int)

;Capture from tuple.
solve :
  capture(T) [Int,Int] <: Seqable<?T>

;seq(to-string, int-tuple)
solve :
  capture($T,$S) [Int -> String, [Int,Int]] <: [$T -> ?$S, Seqable<?$T>]


;val xs = seq(to-string, int-tuple)
;seq(to-int, xs)
solve :
  capture($T,$S) [Int -> String, [Int,Int]] <: [$T -> ?$S, Seqable<?$T>]
  var $XS = Seqable<$S>
  capture($T2,$S2) [String -> Int, $XS] <: [$T2 -> ?$S2, Seqable<?$T2>]
  var $YS = Seqable<$S2>

;<comment>

;TRY:
;  map(fn (x) : make-tuple(x), make-tuple(int))
;ADDED VARIABLES:
;  map<$T,$S>(fn (x:$X) -> $Y : make-tuple(x) (EXP: $Z), make-tuple(int))
solve :
  ;Call to map
  capture($T,$S) [$X -> $Y, Tuple<Int>] <: [$T -> ?$S, Seqable<?$T>]
  ;Inference of X
  infer $X arg(0 of 1) <: $Z
  ;Return type of closure
  var $Y = Tuple<$X>
  ;Expected type Z (first argument of map function)
  infer $Z ($T -> $S, Seqable<$T>) -> Seqable<$S>  <:  arg(0 of 2)
