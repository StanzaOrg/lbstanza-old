############################################################
################## Core Library ############################
############################################################

The core library consists of the functions and types defined in the
"core" package.

============================================================
================== Number Types ============================
============================================================

The following types make up Stanza's basic numerical types.

   deftype Byte <: Equalable & Hashable & Comparable<Byte>
   deftype Int <: Equalable & Hashable & Comparable<Int>
   deftype Long <: Equalable & Hashable & Comparable<Long>
   deftype Float <: Equalable & Hashable & Comparable<Float>
   deftype Double <: Equalable & Hashable & Comparable<Double>
   
A Byte represents an 8-bit unsigned integer between 0 and 255
(inclusive). An Int represents a 32-bit signed integer. A Long
represents a 64-bit signed integer. A Float represents a 32-bit real
number in IEEE 754 encoding. A Double represents a 64-bit real number
in IEEE 754 encoding.

Note that the numerical types are each subtypes of Equalable,
Hashable, and Comparable. This means that they support the equality
operator, implements an appropriate method for the hash multi, and can
be compared against themselves.

                  Equality
                  ========

Each of the numerical types are subtypes of Equalable, and hence
implements an appropriate method for the equal? multi. Note that
numerical values of different types are never defined to be equal to
one another. Thus the Int, 0, is not equal to the Long, 0L. 

   defmethod equal? (x:Byte, y:Byte) -> True|False
   defmethod equal? (x:Int, y:Int) -> True|False
   defmethod equal? (x:Long, y:Long) -> True|False
   defmethod equal? (x:Float, y:Float) -> True|False
   defmethod equal? (x:Double, y:Double) -> True|False

                 Comparable
                 ==========

Each of the numerical types are subtypes of Comparable, and hence
implements an appropriate methods for comparison operations: compare, less?,
less-eq?, greater?, greater-eq?. Note that values of different
numerical types cannot be compared with each other. Attempting to do
so is a fatal error.

   defmethod compare (x:Byte, y:Byte) -> Int
   defmethod compare (x:Int, y:Int) -> Int
   defmethod compare (x:Long, y:Long) -> Int
   defmethod compare (x:Float, y:Float) -> Int
   defmethod compare (x:Double, y:Double) -> Int

   defmethod less? (x:Byte, y:Byte) -> True|False
   defmethod less? (x:Int, y:Int) -> True|False
   defmethod less? (x:Long, y:Long) -> True|False
   defmethod less? (x:Float, y:Float) -> True|False
   defmethod less? (x:Double, y:Double) -> True|False

   defmethod less-eq? (x:Byte, y:Byte) -> True|False
   defmethod less-eq? (x:Int, y:Int) -> True|False
   defmethod less-eq? (x:Long, y:Long) -> True|False
   defmethod less-eq? (x:Float, y:Float) -> True|False
   defmethod less-eq? (x:Double, y:Double) -> True|False

   defmethod greater? (x:Byte, y:Byte) -> True|False
   defmethod greater? (x:Int, y:Int) -> True|False
   defmethod greater? (x:Long, y:Long) -> True|False
   defmethod greater? (x:Float, y:Float) -> True|False
   defmethod greater? (x:Double, y:Double) -> True|False

   defmethod greater-eq? (x:Byte, y:Byte) -> True|False
   defmethod greater-eq? (x:Int, y:Int) -> True|False
   defmethod greater-eq? (x:Long, y:Long) -> True|False
   defmethod greater-eq? (x:Float, y:Float) -> True|False
   defmethod greater-eq? (x:Double, y:Double) -> True|False

                Hashable
                ========

Each of the numerical types are subtypes of Hashable, and hence
implements an appropriate method for the hash multi. They can hence be
used as keys for a HashTable.

   defmethod hash (x:Byte) -> Int
   defmethod hash (x:Int) -> Int
   defmethod hash (x:Long) -> Int
   defmethod hash (x:Float) -> Int
   defmethod hash (x:Double) -> Int

              Arithmetic
              ==========

Integer numerical types support the standard arithmetic operations.

   defn plus (x:Byte, y:Byte) -> Byte
   defn minus (x:Byte, y:Byte) -> Byte
   defn times (x:Byte, y:Byte) -> Byte
   defn divide (x:Byte, y:Byte) -> Byte
   defn modulo (x:Byte, y:Byte) -> Byte

   defn plus (x:Int, y:Int) -> Int
   defn minus (x:Int, y:Int) -> Int
   defn times (x:Int, y:Int) -> Int
   defn divide (x:Int, y:Int) -> Int
   defn modulo (x:Int, y:Int) -> Int

   defn plus (x:Long, y:Long) -> Long
   defn minus (x:Long, y:Long) -> Long
   defn times (x:Long, y:Long) -> Long
   defn divide (x:Long, y:Long) -> Long
   defn modulo (x:Long, y:Long) -> Long

Floating point numerical types support the all standard arithmetic
operations except the modulo operation.

   defn plus (x:Float, y:Float) -> Float
   defn minus (x:Float, y:Float) -> Float
   defn times (x:Float, y:Float) -> Float
   defn divide (x:Float, y:Float) -> Float

   defn plus (x:Double, y:Double) -> Double
   defn minus (x:Double, y:Double) -> Double
   defn times (x:Double, y:Double) -> Double
   defn divide (x:Double, y:Double) -> Double

Note that arithmetic operations must be performed on values of the
numerical type. Users must manually convert values from one type to
another if their types differ.

All numerical values except of type Byte support the additional
negation and absolute value operations. Byte values are unsigned and
hence do not support these operations.

   defn negate (x:Int) -> Int
   defn negate (x:Long) -> Long
   defn negate (x:Double) -> Double
   defn negate (x:Float) -> Float

   defn abs (x:Int) -> Int
   defn abs (x:Long) -> Long
   defn abs (x:Double) -> Double
   defn abs (x:Float) -> Float

           Bitwise Operations
           ==================

Integer numerical types support the standard bitwise operations.

   defn shift-left (x:Byte, y:Byte) -> Byte
   defn shift-right (x:Byte, y:Byte) -> Byte
   defn bit-or (x:Byte, y:Byte) -> Byte
   defn bit-and (x:Byte, y:Byte) -> Byte
   defn bit-xor (x:Byte, y:Byte) -> Byte
   defn bit-not (x:Byte) -> Byte
   
   defn shift-left (x:Int, y:Int) -> Int
   defn shift-right (x:Int, y:Int) -> Int
   defn arithmetic-shift-right (x:Int, y:Int) -> Int
   defn bit-or (x:Int, y:Int) -> Int
   defn bit-and (x:Int, y:Int) -> Int
   defn bit-xor (x:Int, y:Int) -> Int
   defn bit-not (x:Int) -> Int
   
   defn shift-left (x:Long, y:Long) -> Long
   defn shift-right (x:Long, y:Long) -> Long
   defn arithmetic-shift-right (x:Long, y:Long) -> Long
   defn bit-or (x:Long, y:Long) -> Long
   defn bit-and (x:Long, y:Long) -> Long
   defn bit-xor (x:Long, y:Long) -> Long
   defn bit-not (x:Long) -> Long

               Limits
               ======

The maximum and minimum values for values of type Byte, Int, Long are
defined in the following global values.

   val BYTE-MAX : Byte
   val BYTE-MIN : Byte
   val INT-MAX : Int
   val INT-MIN : Int
   val LONG-MAX : Long
   val LONG-MIN : Long


            Numerical Conversions
            =====================

Numerical types can be converted from one type to another using the
following functions.

   defn to-byte (b:Byte) -> Byte
   defn to-byte (i:Int) -> Byte
   defn to-byte (l:Long) -> Byte
   defn to-byte (f:Float) -> Byte
   defn to-byte (d:Double) -> Byte
   defn to-int (b:Byte) -> Int
   defn to-int (i:Int) -> Int
   defn to-int (l:Long) -> Int
   defn to-int (f:Float) -> Int
   defn to-int (d:Double) -> Int
   defn to-long (b:Byte) -> Long
   defn to-long (i:Int) -> Long
   defn to-long (l:Long) -> Long
   defn to-long (f:Float) -> Long
   defn to-long (d:Double) -> Long
   defn to-float (b:Byte) -> Float
   defn to-float (i:Int) -> Float
   defn to-float (l:Long) -> Float
   defn to-float (f:Float) -> Float
   defn to-float (d:Double) -> Float
   defn to-double (b:Byte) -> Double
   defn to-double (i:Int) -> Double
   defn to-double (l:Long) -> Double
   defn to-double (f:Float) -> Double
   defn to-double (d:Double) -> Double

Integer types can be converted without loss of precision from a type
with less bits to a type with more bits. When converting from a type
with more bits to a type with less bits, the most significant bits are
truncated.

When converting integer types to floating point types, the closest
floating point number is returned. 


           Numerical Reinterpretations
           ===========================

The following functions return an integer type whose bit
representation is equivalent to the IEEE754 bit representation of the
given floating point number.

   defn bits (x:Float) -> Int
   defn bits (x:Double) -> Long

The following functions return a floating point number whose IEEE754
bit representation is equivalent to the bit representation of the
given integer.

   defn bits-as-float (x:Int) -> Float
   defn bits-as-double (x:Long) -> Double

             Random Number Generation
             ========================

The following function generates a random positive integer.

   defn rand () -> Int

The following function generates a random positive integer that is
guaranteed to be strictly less than n.

   defn rand (n:Int) -> Int

The following function generates a random positive integer within the
range specified by r. r must have a step size of one. 

   defn rand (r:Range) -> Int

             Convenience Functions
             =====================

The following functions computes the ceiling of the base-2 logarithm of
the integer i.

   defn ceil-log2 (i:Int) -> Int
   defn ceil-log2 (i:Long) -> Int

The following functions computes the floor of the base-2 logarithm of
the integer i.

   defn floor-log2 (i:Int) -> Int
   defn floor-log2 (i:Long) -> Long

The following functions compute the smallest power of 2 that is
greater than or equal to the given integer i. i cannot be negative.

   defn next-pow2 (i:Int) -> Int
   defn next-pow2 (i:Long) -> Long

The following functions compute the largest power of 2 that is smaller
than or equal to the given integer i. i cannot be negative.

   defn prev-pow2 (i:Int) -> Int
   defn prev-pow2 (i:Long) -> Long

The following functions computes the sum of the given sequence of
numbers.

   defn sum (xs:Seqable<Int>) -> Int
   defn sum (xs:Seqable<Long>) -> Long
   defn sum (xs:Seqable<Float>) -> Float
   defn sum (xs:Seqable<Double>) -> Double

The following functions computes the product of the given sequence of
numbers.

   defn product (xs:Seqable<Int>) -> Int
   defn product (xs:Seqable<Long>) -> Long
   defn product (xs:Seqable<Float>) -> Float
   defn product (xs:Seqable<Double>) -> Double

============================================================
================= Boolean Types ============================
============================================================

Boolean values are represented using the types True and False.

   deftype True <: Equalable
   deftype False <: Equalable

                   Equality
                   ========

Both True and False are subtypes of Equalable and hence support the
equal? operation. Values of type True are only equal to other values
of type True. And values of type False are only equal to other values
of type False.

               Logical Complement
               ==================

The following function returns the logical complement of its
argument. If a is true, then it returns false, otherwise it returns
true.

   defn complement (a:True|False) -> True|False
   
============================================================
================= Character Type ===========================
============================================================
   
A Char represents a single byte ascii character.

   deftype Char <: Equalable & Hashable & Comparable<Char>

Char is defined to be a subtype of Equalable, Hashable, and
Comparable. Thus it supports the equality operator, implements an
appropriate method for the hash multi, and can be compared other
values of type Char.

                    Equality
                    ========

The equality operator can be used on two values of type Char.

   defmethod equal? (a:Char, b:Char) -> True|False

                   Comparable
                   ==========

Two values of types Char may be compared using the standard comparison
operations.

   defmethod compare (x:Char, y:Char) -> Int
   defmethod less? (x:Char, y:Char) -> True|False
   defmethod less-eq? (x:Char, y:Char) -> True|False
   defmethod greater? (x:Char, y:Char) -> True|False
   defmethod greater-eq? (x:Char, y:Char) -> True|False

Two values of type Char are compared according to the numerical value
of their ascii encoding.

                    Hashable
                    ========

Char is a subtype of Hashable, and implements an appropriate method
for the hash multi. Values of type Char can hence be used as keys for
a HashTable.

   defmethod hash (x:Char) -> Int

              Convenience Functions
              =====================

The digit? function checks whether a given character is a digit
character, representing one of the numerals between 0 and 9.

   defn digit? (c:Char) -> True|False

The letter? function checks whether a given character is either a
lower or upper-case character, representing one of the letters between
'A' and 'Z'.

   defn letter? (c:Char) -> True|False

============================================================
====================== Range ===============================
============================================================

A Range represents a span of integers between a starting index and an
optional ending index. 

   deftype Range <: Collection<Int> & Equalable  

                    Creation
                    ========

The following function creates a range with a given starting index,
and optional ending index, and step size, and a flag indicating
whether the ending index is inclusive or exclusive.

   defn Range (start:Int, end:Int|False, step:Int, inclusive?:True|False) -> Range

Users will typically use one of the macro forms for creating a
range. The following form creates a range with the starting index a,
exclusive ending index b, and step size 1.

   a to b 

The keyword by can be used to provide a custom step size.

   a to b by n

To create ranges with inclusive ending indices, use the keyword
through instead of to.

   a through b
   a through b by n

                    Getters
                    =======

The properties of a range can be retrieved using the following functions.

   defn start (r:Range) -> Int
   defn end (r:Range) -> Int|False
   defn step (r:Range) -> Int
   defn inclusive? (r:Range) -> True|False

                   Collection
                   ==========

Range is a subtype of Collection and implements an appropriate method
for the to-seq multi.

   defmethod to-seq (r:Range) -> Seq<Int>

A range is viewed as a sequence of numbers starting from its given
starting index, and proceeding until its ending index, in terms of the
given step size. If the ending index is inclusive, then the sequence
may contain the ending index. If the ending index is exclusive, then
the sequence will not contain the ending index. If no ending index is
given, then the sequence is infinite.

                    Equalable
                    =========

Range is a subtype of Equalable and two ranges are defined to be equal
if they have equivalent starting and ending indices, step sizes, and
inclusion flags.

                 Convenience Functions
                 =====================

The following function returns a list containing the result of
applying the function f to each integer within the given range. It is
a fatal error to call map on a range with infinite length.

   defn map<?R> (f: Int -> ?R, r:Range) -> List<R>

                  Dense Index Ranges
                  ==================

For many of the core library functions, ranges are used to specify
bounds within a Lengthable collection. For these ranges, the range
argument must be a "dense index range" with respect to the given
collection. A range is a "dense index range" with respect to a
collection if it satisfies the following restrictions:

- The step size of the range must be 1. 

- If the range is infinite, then the starting index must be non-negative
and less than or equal to the length of the collection.

- If the range is finite and inclusive, then the starting and ending
indices must be non-negative and less than the length of the
collection. The starting index must be less than or equal to the
ending index.

- If the range is finite and exclusive, then the starting and ending
indices must be non-negative and less than or equal to the length of
the collection. The starting index must be less than or equal to the
ending index.

============================================================
===================== Strings ==============================
============================================================

A String represents an immutable collection of values of type Char.

   deftype String <: Lengthable &
                     Collection<Char> &
                     Equalable &
                     Hashable &
                     Comparable<String>

                 Equality
                 ========

String is a subtype of Equalable and hence supports the equal?
operation. Two Strings are equal if they have the same length and all
of their characters are respectively equal.

   defmethod equal? (x:String, y:String) -> True|False

                Lengthable
                ==========

String is a subtype of Lengthable and hence supports the length
operation.

   defmethod length (x:String) -> Int

                Hashable
                ========

String is a subtype of Hashable, hence supports the hash operation and
can be used as keys in a HashTable.

   defmethod hash (x:String) -> Int

               Comparable
               ==========

String is a subtype of Comparable, and two values of type String can
be compared using the standard comparison operations.

   defmethod compare (x:String, y:String) -> Int
   defmethod less? (x:String, y:String) -> True|False
   defmethod less-eq? (x:String, y:String) -> True|False
   defmethod greater? (x:String, y:String) -> True|False
   defmethod greater-eq? (x:String, y:String) -> True|False

Strings are compared according to their lexicographic ordering.

                Collection
                ==========

String is a subtype of Collection, and hence supports the to-seq
operation to view the String as a sequence of Chars with known length.

   defmethod to-seq (x:String) -> Seq<Char> & Lengthable

              String Creation
              ===============

The following function creates a new String containing n copies of the
c character.

   defn String (n:Int, c:Char) -> String

The following function converts the given sequence of characters into
a String.

   defn String (cs:Seqable<Char>) -> String

            Retrieving Characters
            =====================

The following function allows for retrieval of individual characters
in a String by index. It is a fatal error to provide an index that is
negative or greater or equal to the length of the string.

   defn get (s:String, i:Int) -> Char

            Retrieving Substrings
            =====================

The following function allows for retrieval of a range of characters
in a String.

   defn get (s:String, r:Range) -> String

If the range is finite, then the substring between the starting index
and the ending index of the range is returned. If the range is
inclusive, then the starting and ending index must be positive and
less than the length of the string. If the range is exclusive, then
the starting and ending index must be positive and less than or equal
to the length of the string. Note that the starting index must always
be less than or equal to the ending index.

If the range is infinite, then the substring between the starting
index and the end of the string is returned. The starting index must
be positive and less than or equal to the length of the string.

The step size of the range must be one.

For example, assuming that s contains the string "Hello World", here
is what various calls to get will return.

   s[1 to 4] returns "ell"
   s[1 through 4] returns "ello"
   s[1 to false] returns "ello World"

               Parsing Numbers
               ===============

The following functions convert the string representations of numbers
to their numerical types.

   defn to-byte (s:String) -> False|Byte
   defn to-int (s:String) -> False|Int
   defn to-long (s:String) -> False|Long
   defn to-float (s:String) -> False|Float
   defn to-double (s:String) -> False|Double

Each of the above functions returns false if the given string cannot
be converted to the appropriate type, either because of an incorrectly
formatted string, or because the resulting number cannot be
represented using the appropriate number of bits.

             Conversion to String
             ====================

The following multi converts a given object to its string
representation.

   defmulti to-string (x) -> String

A default method defined in terms of print is provided to convert
arbitrary objects to their string representation. User defined types
are advised to rely upon this default method and *not* provide their
own method of to-string. To provide custom printing behaviour for a
type, users should provide methods for print instead.             

            Convenience Functions
            =====================

The following function returns true if the string b can be found at
position start in the string a, or false otherwise.

   defn matches? (a:String, start:Int, b:String) -> True|False

The following function returns true if the string a starts with the
given prefix, or false otherwise.

   defn prefix? (s:String, prefix:String) -> True|False

The following function returns true if the string a ends with the
given suffix, or false otherwise.

   defn suffix? (s:String, suffix:String) -> True|False

The following function returns true if the string contains no
characters.

   defn empty? (s:String) -> True|False

The following function returns a new string resulting from
concatenating string b to the end of string a.

   defn append (a:String, b:String) -> String

The following function returns a new string resulting from
concatenating together all strings in a sequence.

   defn append-all (xs:Seqable<String>) -> String

The following functions returns the string resulting from printing out
each item in the sequence xs. If the argument j is given, then each
item in the sequence is separated by j.

   defn string-join (xs:Seqable) -> String
   defn string-join (xs:Seqable, j) -> String

The following functions searches the string s, within the bounds
indicated the range r, for the first occurrence of the character c. If
c is found, then its index is returned, otherwise false is
returned. See the definition of get for Strings for possible settings
of the range. If a range is not given, then by default the function
searches through the entire String.

   defn index-of-char (s:String, r:Range, c:Char) -> False|Int
   defn index-of-char (s:String, c:Char) -> False|Int

The following functions searches the string s, within the bounds
indicated by the range r, for the first occurrence of the substring
b. If it is found, then its index is returned, otherwise false is
returned. See the definition of get for Strings for possible settings
of the range. If a range is not given, then by default the function
searches through the entire String.

   defn index-of-chars (a:String, r:Range, b:String) -> False|Int
   defn index-of-chars (a:String, b:String) -> False|Int

The following functions searches the string s, within the bounds
indicated the range r, for the last occurrence of the character c. If
c is found, then its index is returned, otherwise false is
returned. See the definition of get for Strings for possible settings
of the range. If a range is not given, then by default the function
searches through the entire String.

   defn last-index-of-char (s:String, r:Range, c:Char) -> False|Int
   defn last-index-of-char (s:String, c:Char) -> False|Int

The following functions searches the string s, within the bounds
indicated by the range r, for the last occurrence of the substring
b. If it is found, then its index is returned, otherwise false is
returned. See the definition of get for Strings for possible settings
of the range. If a range is not given, then by default the function
searches through the entire String.

   defn last-index-of-chars (a:String, r:Range, b:String) -> False|Int
   defn last-index-of-chars (a:String, b:String) -> False|Int

The following function returns the result of replacing every
occurrence of the character c1 in the string s with the character c2.

   defn replace (s:String, c1:Char, c2:Char) -> String

The following function returns the result of replacing every
occurrence of the substring s2 in the string str with the substring
s2.

   defn replace (str:String, s1:String, s2:String) -> String

The following functions returns a lazily computed sequence resulting
from splitting the string str at occurrences of the substring s. If
the argument n is given, then the resulting sequence is restricted to
contain at most n strings, where the last string contains the
unsplitted remainder of the str.

   defn split (str:String, s:String) -> Seq<String>   
   defn split (str:String, s:String, n:Int) -> Seq<String>

The following relation is guaranteed return true.

   string-join(split(str, s), s) == str

The following functions returns the result of converting all letters
contained within the string s to either lower-case or upper-case.

   defn lower-case (s:String) -> String
   defn upper-case (s:String) -> String

The following function returns the result of removing leading and
trailing whitespace characters from the string s.

   defn trim (s:String) -> String

============================================================
===================== Tuples ===============================
============================================================

A Tuple represents a finite and immutable series of items each with an
integer index.

   deftype Tuple<T> <: Lengthable &
                       Collection<T> &
                       Equalable &
                       Hashable &
                       Comparable<Tuple<T>>

                    Creation
                    ========

The following function creates a tuple of length n with each element
initialized to x.

   defn Tuple<?T> (n:Int, x:?T) -> Tuple<T>              

The following function converts a finite sequence of items into a
tuple. The function will not terminate if given an infinite sequence.

   defn to-tuple<?T> (xs:Seqable<?T>) -> Tuple<T>

                   Equality
                   ========

Tuple is a subtype of Equalable and two tuples are defined to be equal
if they have the same length and all of their components are equal.

                   Lengthable
                   ==========

The length of a tuple can be queried by calling the length multi.

   defmethod length (x:Tuple) -> Int

                 Retrieving Elements
                 ===================

The following function will return the item at index i within the
tuple x. i must be within the bounds of the range.

   defn get<?T> (x:Tuple<?T>, i:Int) -> T

The following function will return a new Tuple containing the items
spanned by the given range. The range must be a dense index range. 

   defn get<?T> (xs:Tuple<?T>, r:Range) -> Tuple<T>

                  Collection
                  ==========

Tuple is a subtype of Collection and implements an appropriate method
for the to-seq multi to access the elements of the tuple as a
sequence.

   defmethod to-seq<?T> (t:Tuple<?T>) -> Seq<T>

                  Hashable
                  ========

Tuple is a subtype of Hashable and computes its hash by combining the
hashes of all of its items. It is a fatal error to call hash on a
tuple containing items that are not Hashable.

   defmethod hash (t:Tuple<Hashable>) -> Int

                 Comparable
                 ==========

Tuple is a subtype of Comparable and implements an appropriate method
for the compare multi that compares two tuples by their lexicographic
order. It is a fatal error to compare two tuples containing elements
that are not Comparable with each other.

   defmethod compare (a:Tuple<Comparable>, b:Tuple<Comparable>) -> Int

             Convenience Functions
             =====================

The following function returns a new tuple containing the result of
calling the function f on each item in the tuple xs.

   defn map<?T,?R> (f:T -> ?R, xs:Tuple<?T>) -> Tuple<R>

The following function returns true if the tuple t is empty, otherwise
it returns false.

   defn empty? (t:Tuple) -> True|False


============================================================
===================== Equalable ============================
============================================================

Values that support the equal? operation are indicated as subtypes of
Equalable.

   deftype Equalable

The multi equal? takes as argument two Equalable values and returns
true if they are equal or false otherwise.

   defmulti equal? (a:Equalable, b:Equalable) -> True|False

A default method for equal? is provided that simply returns false.

Equality in Stanza is defined to be invariant to substitution. That
is, suppose that our program contains a call to a function, f, with a
value x.

   f(x)

But earlier, we have determined that

   x == y

returns true, indicating that x is equal to y. Then we should we able
to substitute the usage of x with y instead without changing the
behaviour of the program.

   f(y)

Consistent to this definition, in Stanza's core library, values of
immutable types are defined to be equal if their subfields are
equal. Different mutable values, such as Arrays, are never defined to
be equal unless they refer to the same object.

                 Convenience Functions
                 =====================

The following function returns true if its two arguments are not equal
and false otherwise.

   defn not-equal? (a:Equalable, b:Equalable) -> True|False

============================================================
==================== Comparable ============================
============================================================

The Comparable type is used to indicate that a value can compared
against other values using the comparison operations. A value of type
Comparable<T> can be compared against values of type T.

   deftype Comparable<T>

             Fundamental Comparison Operation
             ================================

The following multi compares values of type Comparable<T> against
values of type T. All subtypes of Comparable must implement an
appropriate method for this multi. The multi returns a negative
integer if the item a is less than the item b, zero if the two are
equal, and a positive integer if the item a is greater than the item
b. For values that are subtypes of both Equalable and Comparable, the
compare operation must be consistently defined against the equal?
operation, and return 0 if equal? returns true.

   defmulti compare<?T> (a:Comparable<?T>, b:T) -> Int

              Derived Comparison Operations
              =============================

The following multis are provided for subtypes to provide efficient
implementations. Any defined method must return results consistent
with the compare operation. Default methods are provided for these
multis that are defined in terms of the compare operation.

   defmulti less?<?T> (a:Comparable<?T>, b:T) -> True|False
   defmulti greater?<?T> (a:Comparable<?T>, b:T) -> True|False
   defmulti less-eq?<?T> (a:Comparable<?T>, b:T) -> True|False
   defmulti greater-eq?<?T> (a:Comparable<?T>, b:T) -> True|False

                Convenience Functions
                =====================

The following functions compute the maximum or minimum of their two
given arguments.

   defn max<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T
   defn min<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T

The following functions compute the minimum between an initial value
x0, and a sequence of items xs using the provided comparison
function. If no initial value is provided, then the sequence xs cannot
be empty.

   defn minimum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T
   defn minimum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T

The following functions compute the maximum between an initial value
x0, and a sequence of items xs using the provided comparison
function. If no initial value is provided, then the sequence xs cannot
be empty.

   defn maximum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T
   defn maximum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T

The following functions compute the minimum between an initial value
x0, and a sequence of comparable items xs using the less? multi. If no
initial value is provided, then the sequence xs cannot be empty.

   defn minimum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T
   defn minimum<?T> (xs:Seqable<?T&Comparable>) -> T

The following functions compute the maximum between an initial value
x0, and a sequence of comparable items xs using the less? multi. If no
initial value is provided, then the sequence xs cannot be empty.

   defn maximum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T
   defn maximum<?T> (xs:Seqable<?T&Comparable>) -> T

The following function returns the minimum in a sequence of items xs
by comparing the keys extracted from each item using the provided key
function.

   defn minimum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T

The following function returns the maximum in a sequence of items xs
by comparing the keys extracted from each item using the provided key
function.

   defn maximum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T

============================================================
==================== Hashable ==============================
============================================================

The type Hashable indicates that a value supports the hash multi and
can represented (non-uniquely) as an Int value.

   deftype Hashable

The hash multi takes a Hashable argument and returns an Int. For the
correct operation of HashTable implementations, the definition of hash
must be consistent with the definition of equal?. If two values are
equal, then they must also return the same hash.

   defmulti hash (h:Hashable) -> Int

============================================================
===================== Seq ==================================
============================================================

A Seq represents a possibly finite sequence of items.

   deftype Seq<T> <: Seqable<T>

A Seq supports the following fundamental operations.

   defmulti empty? (s:Seq) -> True|False
   defmulti next<?T> (s:Seq<?T>) -> T
   defmulti peek<?T> (s:Seq<?T>) -> T

The empty? multi returns true if the sequence contains more items, or
false otherwise.

The next multi returns the next item in the sequence. Repeated calls
to next results in successive items in the sequence to be returned. It
is a fatal error to call next on an empty sequence.

The peek multi inspects the next item in the sequence but does not
consume it. Repeated calls to peek results in the same item begin
returned. It is a fatal error to call peek on an empty sequence.

============================================================
=================== Seqable ================================
============================================================

A Seqable represents any value that may be viewed as a sequence of
items. It supports the fundamental operation

   defmulti to-seq<?T> (s:Seqable<?T>) -> Seq<T>

to return a Seq that represents a sequential view of its given
argument.

A value of type Seq is defined to also be a Seqable and trivially
returns itself when called with to-seq.

============================================================
=================== Collection =============================
============================================================

A Collection is defined to be a subtype of Seqable and thus must also
support the to-seq operation. The crucial difference between a
Collection and Seqable is that a Collection must be *repeatedly*
viewable as a sequence of items.

As an example, consider a function, print-all-twice, that iterates
through and prints out the items in a sequence twice.

   defn print-all-twice (xs:Seqable) -> False :
      val seq1 = to-seq(xs)
      while not empty?(seq1) :
         println(next(seq1))

      val seq2 = to-seq(xs)
      while not empty?(seq2) :
         println(next(seq2))

Such a function would not work as expected when called with a
Seq. Recall that calling to-seq on a Seq is a trivial operation that
returns the Seq directly. Thus the first while loop will print out
every item in the sequence, but the second while loop will not
complete a single iteration as the sequence is already empty. The
correct type signature for print-all-twice would be

   defn print-all-twice (xs:Collection) -> False

Seq is a subtype of Seqable, but Seq is not a subtype of
Collection. Thus the new type signature correctly disallows
print-all-twice from being called with Seqs.

============================================================
=================== Lengthable =============================
============================================================

A Lengthable is a value that has either a fixed or variable length.

   deftype Lengthable

Any subtype of Lengthable must implement an appropriate method for the
length multi.

   defmulti length (l:Lengthable) -> Int

============================================================
=========== Liveness Trackers and Markers ==================
============================================================

Stanza's support for automatic garbage collection means that users do
not need to manually delete objects after their use. However, it is
often useful to know when an object has been reclaimed to perform
additional cleanup operations. LivenessTrackers and LivenessMarkers
are used to track whether an object is still live. 

                   Creation
                   ========

A LivenessTracker can be created using the following function. For
convenience, every LivenessTracker may be associated with a value to
indicate the identity of the tracker.

   defn LivenessTracker<?T> (value:?T) -> LivenessTracker<T>

The following function can be used to retrieve the value associated
with a tracker.

   defn value<?T> (tracker:LivenessTracker<?T>) -> T

           Creating and Checking Markers
           =============================

The following function is used to create or check upon a LivenessMarker.

   defn marker (tracker:LivenessTracker) -> False|LivenessMarker

The first time this function is called on a LivenessTracker it is
guaranteed to return its associated LivenessMarker. This marker may
then be stored with an object whose liveness the user wishes to
track. On subsequent calls to marker, the function will either return
the created marker, which indicates that the marker is still live. Or
it will return false, which indicates that the marker is now longer
live, and hence neither is the object in which it is stored.
                
Consider tracking the liveness of values of type Car. Intuitively, it
is helpful to imagine a LivenessTracker as a futuristic pistol that
can shoot a tracking beacon (its LivenessMarker) which sticks to the
Car. Periodically, you may ask the tracker whether it is still
receiving signal from the beacon, in which case the marker and hence
the Car is still live. If the beacon is no longer sending a signal
(marker returns false), then the marker and hence the Car is no longer
live.


============================================================
================= IndexedCollection ========================
============================================================

An IndexedCollection represents a mutable collection containing a
series of items, each of which is associated with an integer index.

   deftype IndexedCollection<T> <: Lengthable & Collection<T>

It is a subtype of Lengthable and all values with type
IndexedCollection must implement an appropriate method for the length
multi.

All IndexedCollections are subtypes of Collection and support the
to-seq operation. A default method for to-seq defined in terms of
length and get is provided. For efficiency purposes, subtypes of
IndexedCollections may provide a customized method of to-seq, but it
is not required.


                 Fundamental Operations
                 ======================

Appropriate methods for getting and setting an item at a given index i
must be provided for all subtypes.

   defmulti get<?T> (a:IndexedCollection<?T>, i:Int) -> T
   defmulti set<?T> (a:IndexedCollection<?T>, i:Int, v:T) -> False

                 Convenience Functions
                 =====================

The following function returns a range of items with an
IndexedCollection. The range must have a step size of 1. If the range
is finite, then the starting index must be less than or equal to the
ending index. If the range is inclusive, than the starting and ending
index must be non-negative and less than the length of the
collection. If the range is exclusive, than the starting and ending
index must be non-negative and less than or equal to the length of the
collection. A default method defined in terms of get is provided, but
subtypes may provide customized methods for efficiency purposes if
desired.

   defmulti get<?T> (a:IndexedCollection<?T>, r:Range) -> Collection<T>

The following function sets a range of indices within the collection
to items taken sequentially from vs. See the definition of get for
restrictions upon the range r. The sequence vs must contain at least
as many items as indices being assigned. A default method defined in
terms of set is provided, but subtypes may provide customized methods
for efficiency purposes if desired.

   defmulti set<?T> (a:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False

The following function iterates through the given collection and
replaces each item with the result of calling f on the item. A default
method defined in terms of get and set is provided, but subtypes may
provide customized methods for efficiency purposes if desired.

   defmulti map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False

The following function returns true if the collection is empty or
false otherwise.

   defn empty? (v:IndexedCollection) -> True|False

The following function reverses the order in which items appear in the
collection.

   defn reverse!<?T> (xs:IndexedCollection<?T>) -> False

The following function returns a sequence containing the items in the
collection in reversed order. The original collection is unchanged.

   defn in-reverse<?T> (xs:IndexedCollection<?T>) -> Seq<T>

============================================================
=================== Sorting ================================
============================================================

The following function sorts the collection using the given comparison
function and the quick sort algorithm.

   defn qsort!<?T> (xs:IndexedCollection<?T>, is-less?:(T,T) -> True|False) -> False

The following function sorts the collection using the less? multi and
the quick sort algorithm.

   defn qsort!<?T> (xs:IndexedCollection<?T&Comparable>) -> False

The following function sorts the collection by comparing keys
extracted using the key function and the quick sort algorithm.

   defn qsort!<?T> (key:T -> Comparable, xs:IndexedCollection<?T>) -> False

The following function returns a lazily sorted sequence of the given
sequence xs using the given comparison function and the quick sort algorithm.

   defn lazy-qsort<?T> (xs:Seqable<?T>, is-less?:(T,T) -> True|False) -> Collection<T> & Lengthable

The following function returns a lazily sorted collection of the given
sequence xs using the less? multi and the quick sort algorithm.

   defn lazy-qsort<?T> (xs:Seqable<?T&Comparable>) -> Collection<T> & Lengthable

The following function returns a lazily sorted collection of the given
sequence xs by comparing keys extracted using the key function and the quick sort algorithm.

   defn lazy-qsort<?T> (key:T -> Comparable, xs:Seqable<?T>) -> Collection<T> & Lengthable

============================================================
==================== Arrays ================================
============================================================

Arrays are the most fundamental IndexedCollection in Stanza,
representing a finite series of items with constant time access to
elements by index.

   deftype Array<T> <: IndexedCollection<T> & Equalable

An array is a subtype of IndexedCollection and hence supports the
fundamental get and set and length operations.

                   Equality
                   ========

Two arrays are defined to be equal only if are the same array.

                   Creation
                   ========

The following function creates an Array with length n for holding
values of type T. It is a fatal error to read from an index that has
not been initialized, and n cannot be negative.

   defn Array<T> (n:Int) -> Array<T>

The following function creates an Array with length n for holding
values of type T with each index initialized to the item x. n cannot
be negative.

   defn Array<T> (n:Int, x:T) -> Array<T>

               Convenience Functions
               =====================

The following function converts a sequence of items of type T to an
array.

   defn to-array<T> (xs:Seqable<T>) -> Array<T>

The following function creates a new array where each item is
initialized to the result of calling the function f on each item in
the given array xs.

   defn map<R,?T> (f:T -> R, xs:Array<?T>) -> Array<R>


============================================================
================== CharArrays ==============================
============================================================

CharArrays are specialized arrays designed specifically for
efficiently storing Chars.

   deftype CharArray <: Array<Char>

CharArrays implement appropriate methods for each of the multis
required by Array and behaves equivalently to an Array<Char>.

                   Creation
                   ========

The following function creates a CharArray of length n, with each
index initialized to the space character.

   defn CharArray (n:Int) -> CharArray

The following function creates a CharArray of length n, with each
index initialized to the given character x.

   defn CharArray (n:Int, x:Char) -> CharArray

             Efficient Char Retrieval
             ========================

The following function allows for efficient retrieval of characters
from a CharArray. See the definition of get for restrictions on the
range r.

   defn get-chars (cs:CharArray, r:Range) -> String
   
The following function allows for efficient assignment of characters
in a CharArray. See the definition of get for restrictions on the
range r.

   defn set-chars (cs:CharArray, r:Range, s:String) -> False

CharArray implements efficient methods for getting and setting
characters which call get-chars and set-chars appropriately.

   defmethod get (cs:CharArray, r:Range) -> String
   defmethod set (cs:CharArray, r:Range, s:String) -> False
