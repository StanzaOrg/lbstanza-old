############################################################
################## Core Library ############################
############################################################

The core library consists of the functions and types defined in the
"core" package.

============================================================
================== Number Types ============================
============================================================

The following types make up Stanza's basic numerical types.

   deftype Byte <: Equalable & Hashable & Comparable<Byte>
   deftype Int <: Equalable & Hashable & Comparable<Int>
   deftype Long <: Equalable & Hashable & Comparable<Long>
   deftype Float <: Equalable & Hashable & Comparable<Float>
   deftype Double <: Equalable & Hashable & Comparable<Double>
   
A Byte represents an 8-bit unsigned integer between 0 and 255
(inclusive). An Int represents a 32-bit signed integer. A Long
represents a 64-bit signed integer. A Float represents a 32-bit real
number in IEEE 754 encoding. A Double represents a 64-bit real number
in IEEE 754 encoding.

Note that the numerical types are each subtypes of Equalable,
Hashable, and Comparable. This means that they support the equality
operator, implements an appropriate method for the hash multi, and can
be compared against themselves.

                  Equality
                  ========

Each of the numerical types are subtypes of Equalable, and hence
implements an appropriate method for the equal? multi. Note that
numerical values of different types are never defined to be equal to
one another. Thus the Int, 0, is not equal to the Long, 0L. 

   defmethod equal? (x:Byte, y:Byte) -> True|False
   defmethod equal? (x:Int, y:Int) -> True|False
   defmethod equal? (x:Long, y:Long) -> True|False
   defmethod equal? (x:Float, y:Float) -> True|False
   defmethod equal? (x:Double, y:Double) -> True|False

                 Comparable
                 ==========

Each of the numerical types are subtypes of Comparable, and hence
implements an appropriate methods for comparison operations: compare, less?,
less-eq?, greater?, greater-eq?. Note that values of different
numerical types cannot be compared with each other. Attempting to do
so is a fatal error.

   defmethod compare (x:Byte, y:Byte) -> Int
   defmethod compare (x:Int, y:Int) -> Int
   defmethod compare (x:Long, y:Long) -> Int
   defmethod compare (x:Float, y:Float) -> Int
   defmethod compare (x:Double, y:Double) -> Int

   defmethod less? (x:Byte, y:Byte) -> True|False
   defmethod less? (x:Int, y:Int) -> True|False
   defmethod less? (x:Long, y:Long) -> True|False
   defmethod less? (x:Float, y:Float) -> True|False
   defmethod less? (x:Double, y:Double) -> True|False

   defmethod less-eq? (x:Byte, y:Byte) -> True|False
   defmethod less-eq? (x:Int, y:Int) -> True|False
   defmethod less-eq? (x:Long, y:Long) -> True|False
   defmethod less-eq? (x:Float, y:Float) -> True|False
   defmethod less-eq? (x:Double, y:Double) -> True|False

   defmethod greater? (x:Byte, y:Byte) -> True|False
   defmethod greater? (x:Int, y:Int) -> True|False
   defmethod greater? (x:Long, y:Long) -> True|False
   defmethod greater? (x:Float, y:Float) -> True|False
   defmethod greater? (x:Double, y:Double) -> True|False

   defmethod greater-eq? (x:Byte, y:Byte) -> True|False
   defmethod greater-eq? (x:Int, y:Int) -> True|False
   defmethod greater-eq? (x:Long, y:Long) -> True|False
   defmethod greater-eq? (x:Float, y:Float) -> True|False
   defmethod greater-eq? (x:Double, y:Double) -> True|False

                Hashable
                ========

Each of the numerical types are subtypes of Hashable, and hence
implements an appropriate method for the hash multi. They can hence be
used as keys for a HashTable.

   defmethod hash (x:Byte) -> Int
   defmethod hash (x:Int) -> Int
   defmethod hash (x:Long) -> Int
   defmethod hash (x:Float) -> Int
   defmethod hash (x:Double) -> Int

              Arithmetic
              ==========

Integer numerical types support the standard arithmetic operations.

   defn plus (x:Byte, y:Byte) -> Byte
   defn minus (x:Byte, y:Byte) -> Byte
   defn times (x:Byte, y:Byte) -> Byte
   defn divide (x:Byte, y:Byte) -> Byte
   defn modulo (x:Byte, y:Byte) -> Byte

   defn plus (x:Int, y:Int) -> Int
   defn minus (x:Int, y:Int) -> Int
   defn times (x:Int, y:Int) -> Int
   defn divide (x:Int, y:Int) -> Int
   defn modulo (x:Int, y:Int) -> Int

   defn plus (x:Long, y:Long) -> Long
   defn minus (x:Long, y:Long) -> Long
   defn times (x:Long, y:Long) -> Long
   defn divide (x:Long, y:Long) -> Long
   defn modulo (x:Long, y:Long) -> Long

Floating point numerical types support the all standard arithmetic
operations except the modulo operation.

   defn plus (x:Float, y:Float) -> Float
   defn minus (x:Float, y:Float) -> Float
   defn times (x:Float, y:Float) -> Float
   defn divide (x:Float, y:Float) -> Float

   defn plus (x:Double, y:Double) -> Double
   defn minus (x:Double, y:Double) -> Double
   defn times (x:Double, y:Double) -> Double
   defn divide (x:Double, y:Double) -> Double

Note that arithmetic operations must be performed on values of the
numerical type. Users must manually convert values from one type to
another if their types differ.

All numerical values except of type Byte support the additional
negation and absolute value operations. Byte values are unsigned and
hence do not support these operations.

   defn negate (x:Int) -> Int
   defn negate (x:Long) -> Long
   defn negate (x:Double) -> Double
   defn negate (x:Float) -> Float

   defn abs (x:Int) -> Int
   defn abs (x:Long) -> Long
   defn abs (x:Double) -> Double
   defn abs (x:Float) -> Float

           Bitwise Operations
           ==================

Integer numerical types support the standard bitwise operations.

   defn shift-left (x:Byte, y:Byte) -> Byte
   defn shift-right (x:Byte, y:Byte) -> Byte
   defn bit-or (x:Byte, y:Byte) -> Byte
   defn bit-and (x:Byte, y:Byte) -> Byte
   defn bit-xor (x:Byte, y:Byte) -> Byte
   defn bit-not (x:Byte) -> Byte
   
   defn shift-left (x:Int, y:Int) -> Int
   defn shift-right (x:Int, y:Int) -> Int
   defn arithmetic-shift-right (x:Int, y:Int) -> Int
   defn bit-or (x:Int, y:Int) -> Int
   defn bit-and (x:Int, y:Int) -> Int
   defn bit-xor (x:Int, y:Int) -> Int
   defn bit-not (x:Int) -> Int
   
   defn shift-left (x:Long, y:Long) -> Long
   defn shift-right (x:Long, y:Long) -> Long
   defn arithmetic-shift-right (x:Long, y:Long) -> Long
   defn bit-or (x:Long, y:Long) -> Long
   defn bit-and (x:Long, y:Long) -> Long
   defn bit-xor (x:Long, y:Long) -> Long
   defn bit-not (x:Long) -> Long

               Limits
               ======

The maximum and minimum values for values of type Byte, Int, Long are
defined in the following global values.

   val BYTE-MAX : Byte
   val BYTE-MIN : Byte
   val INT-MAX : Int
   val INT-MIN : Int
   val LONG-MAX : Long
   val LONG-MIN : Long


            Numerical Conversions
            =====================

Numerical types can be converted from one type to another using the
following functions.

   defn to-byte (b:Byte) -> Byte
   defn to-byte (i:Int) -> Byte
   defn to-byte (l:Long) -> Byte
   defn to-byte (f:Float) -> Byte
   defn to-byte (d:Double) -> Byte
   defn to-int (b:Byte) -> Int
   defn to-int (i:Int) -> Int
   defn to-int (l:Long) -> Int
   defn to-int (f:Float) -> Int
   defn to-int (d:Double) -> Int
   defn to-long (b:Byte) -> Long
   defn to-long (i:Int) -> Long
   defn to-long (l:Long) -> Long
   defn to-long (f:Float) -> Long
   defn to-long (d:Double) -> Long
   defn to-float (b:Byte) -> Float
   defn to-float (i:Int) -> Float
   defn to-float (l:Long) -> Float
   defn to-float (f:Float) -> Float
   defn to-float (d:Double) -> Float
   defn to-double (b:Byte) -> Double
   defn to-double (i:Int) -> Double
   defn to-double (l:Long) -> Double
   defn to-double (f:Float) -> Double
   defn to-double (d:Double) -> Double

Integer types can be converted without loss of precision from a type
with less bits to a type with more bits. When converting from a type
with more bits to a type with less bits, the most significant bits are
truncated.

When converting integer types to floating point types, the closest
floating point number is returned. 


           Numerical Reinterpretations
           ===========================

The following functions return an integer type whose bit
representation is equivalent to the IEEE754 bit representation of the
given floating point number.

   defn bits (x:Float) -> Int
   defn bits (x:Double) -> Long

The following functions return a floating point number whose IEEE754
bit representation is equivalent to the bit representation of the
given integer.

   defn bits-as-float (x:Int) -> Float
   defn bits-as-double (x:Long) -> Double

             Random Number Generation
             ========================

The following function generates a random positive integer.

   defn rand () -> Int

The following function generates a random positive integer that is
guaranteed to be strictly less than n.

   defn rand (n:Int) -> Int

The following function generates a random positive integer within the
range specified by r. r must have a step size of one. 

   defn rand (r:Range) -> Int

             Convenience Functions
             =====================

The following functions computes the ceiling of the base-2 logarithm of
the integer i.

   defn ceil-log2 (i:Int) -> Int
   defn ceil-log2 (i:Long) -> Int

The following functions computes the floor of the base-2 logarithm of
the integer i.

   defn floor-log2 (i:Int) -> Int
   defn floor-log2 (i:Long) -> Long

The following functions compute the smallest power of 2 that is
greater than or equal to the given integer i. i cannot be negative.

   defn next-pow2 (i:Int) -> Int
   defn next-pow2 (i:Long) -> Long

The following functions compute the largest power of 2 that is smaller
than or equal to the given integer i. i cannot be negative.

   defn prev-pow2 (i:Int) -> Int
   defn prev-pow2 (i:Long) -> Long

The following functions computes the sum of the given sequence of
numbers.

   defn sum (xs:Seqable<Int>) -> Int
   defn sum (xs:Seqable<Long>) -> Long
   defn sum (xs:Seqable<Float>) -> Float
   defn sum (xs:Seqable<Double>) -> Double

The following functions computes the product of the given sequence of
numbers.

   defn product (xs:Seqable<Int>) -> Int
   defn product (xs:Seqable<Long>) -> Long
   defn product (xs:Seqable<Float>) -> Float
   defn product (xs:Seqable<Double>) -> Double

============================================================
================= Boolean Types ============================
============================================================

Boolean values are represented using the types True and False.

   deftype True <: Equalable
   deftype False <: Equalable

                   Equality
                   ========

Both True and False are subtypes of Equalable and hence support the
equal? operation. Values of type True are only equal to other values
of type True. And values of type False are only equal to other values
of type False.

               Logical Complement
               ==================

The following function returns the logical complement of its
argument. If a is true, then it returns false, otherwise it returns
true.

   defn complement (a:True|False) -> True|False
   
============================================================
================= Character Type ===========================
============================================================
   
A Char represents a single byte ascii character.

   deftype Char <: Equalable & Hashable & Comparable<Char>

Char is defined to be a subtype of Equalable, Hashable, and
Comparable. Thus it supports the equality operator, implements an
appropriate method for the hash multi, and can be compared other
values of type Char.

                    Equality
                    ========

The equality operator can be used on two values of type Char.

   defmethod equal? (a:Char, b:Char) -> True|False

                   Comparable
                   ==========

Two values of types Char may be compared using the standard comparison
operations.

   defmethod compare (x:Char, y:Char) -> Int
   defmethod less? (x:Char, y:Char) -> True|False
   defmethod less-eq? (x:Char, y:Char) -> True|False
   defmethod greater? (x:Char, y:Char) -> True|False
   defmethod greater-eq? (x:Char, y:Char) -> True|False

Two values of type Char are compared according to the numerical value
of their ascii encoding.

                    Hashable
                    ========

Char is a subtype of Hashable, and implements an appropriate method
for the hash multi. Values of type Char can hence be used as keys for
a HashTable.

   defmethod hash (x:Char) -> Int

              Convenience Functions
              =====================

The digit? function checks whether a given character is a digit
character, representing one of the numerals between 0 and 9.

   defn digit? (c:Char) -> True|False

The letter? function checks whether a given character is either a
lower or upper-case character, representing one of the letters between
'A' and 'Z'.

   defn letter? (c:Char) -> True|False

============================================================
====================== Range ===============================
============================================================

A Range represents a span of integers between a starting index and an
optional ending index. 

   deftype Range <: Collection<Int> & Equalable  

                    Creation
                    ========

The following function creates a range with a given starting index,
and optional ending index, and step size, and a flag indicating
whether the ending index is inclusive or exclusive.

   defn Range (start:Int, end:Int|False, step:Int, inclusive?:True|False) -> Range

Users will typically use one of the macro forms for creating a
range. The following form creates a range with the starting index a,
exclusive ending index b, and step size 1.

   a to b 

The keyword by can be used to provide a custom step size.

   a to b by n

To create ranges with inclusive ending indices, use the keyword
through instead of to.

   a through b
   a through b by n

                    Getters
                    =======

The properties of a range can be retrieved using the following functions.

   defn start (r:Range) -> Int
   defn end (r:Range) -> Int|False
   defn step (r:Range) -> Int
   defn inclusive? (r:Range) -> True|False

                   Collection
                   ==========

Range is a subtype of Collection and implements an appropriate method
for the to-seq multi.

   defmethod to-seq (r:Range) -> Seq<Int>

A range is viewed as a sequence of numbers starting from its given
starting index, and proceeding until its ending index, in terms of the
given step size. If the ending index is inclusive, then the sequence
may contain the ending index. If the ending index is exclusive, then
the sequence will not contain the ending index. If no ending index is
given, then the sequence is infinite.

                    Equalable
                    =========

Range is a subtype of Equalable and two ranges are defined to be equal
if they have equivalent starting and ending indices, step sizes, and
inclusion flags.

                 Convenience Functions
                 =====================

The following function returns a list containing the result of
applying the function f to each integer within the given range. It is
a fatal error to call map on a range with infinite length.

   defn map<?R> (f: Int -> ?R, r:Range) -> List<R>

                  Dense Index Ranges
                  ==================

For many of the core library functions, ranges are used to specify
bounds within a Lengthable collection. For these ranges, the range
argument must be a "dense index range" with respect to the given
collection. A range is a "dense index range" with respect to a
collection if it satisfies the following restrictions:

- The step size of the range must be 1. 

- If the range is infinite, then the starting index must be non-negative
and less than or equal to the length of the collection.

- If the range is finite and inclusive, then the starting and ending
indices must be non-negative and less than the length of the
collection. The starting index must be less than or equal to the
ending index.

- If the range is finite and exclusive, then the starting and ending
indices must be non-negative and less than or equal to the length of
the collection. The starting index must be less than or equal to the
ending index.

============================================================
===================== Strings ==============================
============================================================

A String represents an immutable collection of values of type Char.

   deftype String <: Lengthable &
                     Collection<Char> &
                     Equalable &
                     Hashable &
                     Comparable<String>

                 Equality
                 ========

String is a subtype of Equalable and hence supports the equal?
operation. Two Strings are equal if they have the same length and all
of their characters are respectively equal.

   defmethod equal? (x:String, y:String) -> True|False

                Lengthable
                ==========

String is a subtype of Lengthable and hence supports the length
operation.

   defmethod length (x:String) -> Int

                Hashable
                ========

String is a subtype of Hashable, hence supports the hash operation and
can be used as keys in a HashTable.

   defmethod hash (x:String) -> Int

               Comparable
               ==========

String is a subtype of Comparable, and two values of type String can
be compared using the standard comparison operations.

   defmethod compare (x:String, y:String) -> Int
   defmethod less? (x:String, y:String) -> True|False
   defmethod less-eq? (x:String, y:String) -> True|False
   defmethod greater? (x:String, y:String) -> True|False
   defmethod greater-eq? (x:String, y:String) -> True|False

Strings are compared according to their lexicographic ordering.

                Collection
                ==========

String is a subtype of Collection, and hence supports the to-seq
operation to view the String as a sequence of Chars with known length.

   defmethod to-seq (x:String) -> Seq<Char> & Lengthable

              String Creation
              ===============

The following function creates a new String containing n copies of the
c character.

   defn String (n:Int, c:Char) -> String

The following function converts the given sequence of characters into
a String.

   defn String (cs:Seqable<Char>) -> String

            Retrieving Characters
            =====================

The following function allows for retrieval of individual characters
in a String by index. It is a fatal error to provide an index that is
negative or greater or equal to the length of the string.

   defn get (s:String, i:Int) -> Char

            Retrieving Substrings
            =====================

The following function allows for retrieval of a range of characters
in a String.

   defn get (s:String, r:Range) -> String

If the range is finite, then the substring between the starting index
and the ending index of the range is returned. If the range is
inclusive, then the starting and ending index must be positive and
less than the length of the string. If the range is exclusive, then
the starting and ending index must be positive and less than or equal
to the length of the string. Note that the starting index must always
be less than or equal to the ending index.

If the range is infinite, then the substring between the starting
index and the end of the string is returned. The starting index must
be positive and less than or equal to the length of the string.

The step size of the range must be one.

For example, assuming that s contains the string "Hello World", here
is what various calls to get will return.

   s[1 to 4] returns "ell"
   s[1 through 4] returns "ello"
   s[1 to false] returns "ello World"

               Parsing Numbers
               ===============

The following functions convert the string representations of numbers
to their numerical types.

   defn to-byte (s:String) -> False|Byte
   defn to-int (s:String) -> False|Int
   defn to-long (s:String) -> False|Long
   defn to-float (s:String) -> False|Float
   defn to-double (s:String) -> False|Double

Each of the above functions returns false if the given string cannot
be converted to the appropriate type, either because of an incorrectly
formatted string, or because the resulting number cannot be
represented using the appropriate number of bits.

             Conversion to String
             ====================

The following multi converts a given object to its string
representation.

   defmulti to-string (x) -> String

A default method defined in terms of print is provided to convert
arbitrary objects to their string representation. User defined types
are advised to rely upon this default method and *not* provide their
own method of to-string. To provide custom printing behaviour for a
type, users should provide methods for print instead.             

            Convenience Functions
            =====================

The following function returns true if the string b can be found at
position start in the string a, or false otherwise.

   defn matches? (a:String, start:Int, b:String) -> True|False

The following function returns true if the string a starts with the
given prefix, or false otherwise.

   defn prefix? (s:String, prefix:String) -> True|False

The following function returns true if the string a ends with the
given suffix, or false otherwise.

   defn suffix? (s:String, suffix:String) -> True|False

The following function returns true if the string contains no
characters.

   defn empty? (s:String) -> True|False

The following function returns a new string resulting from
concatenating string b to the end of string a.

   defn append (a:String, b:String) -> String

The following function returns a new string resulting from
concatenating together all strings in a sequence.

   defn append-all (xs:Seqable<String>) -> String

The following functions returns the string resulting from printing out
each item in the sequence xs. If the argument j is given, then each
item in the sequence is separated by j.

   defn string-join (xs:Seqable) -> String
   defn string-join (xs:Seqable, j) -> String

The following functions searches the string s, within the bounds
indicated the range r, for the first occurrence of the character c. If
c is found, then its index is returned, otherwise false is
returned. See the definition of get for Strings for possible settings
of the range. If a range is not given, then by default the function
searches through the entire String.

   defn index-of-char (s:String, r:Range, c:Char) -> False|Int
   defn index-of-char (s:String, c:Char) -> False|Int

The following functions searches the string s, within the bounds
indicated by the range r, for the first occurrence of the substring
b. If it is found, then its index is returned, otherwise false is
returned. See the definition of get for Strings for possible settings
of the range. If a range is not given, then by default the function
searches through the entire String.

   defn index-of-chars (a:String, r:Range, b:String) -> False|Int
   defn index-of-chars (a:String, b:String) -> False|Int

The following functions searches the string s, within the bounds
indicated the range r, for the last occurrence of the character c. If
c is found, then its index is returned, otherwise false is
returned. See the definition of get for Strings for possible settings
of the range. If a range is not given, then by default the function
searches through the entire String.

   defn last-index-of-char (s:String, r:Range, c:Char) -> False|Int
   defn last-index-of-char (s:String, c:Char) -> False|Int

The following functions searches the string s, within the bounds
indicated by the range r, for the last occurrence of the substring
b. If it is found, then its index is returned, otherwise false is
returned. See the definition of get for Strings for possible settings
of the range. If a range is not given, then by default the function
searches through the entire String.

   defn last-index-of-chars (a:String, r:Range, b:String) -> False|Int
   defn last-index-of-chars (a:String, b:String) -> False|Int

The following function returns the result of replacing every
occurrence of the character c1 in the string s with the character c2.

   defn replace (s:String, c1:Char, c2:Char) -> String

The following function returns the result of replacing every
occurrence of the substring s2 in the string str with the substring
s2.

   defn replace (str:String, s1:String, s2:String) -> String

The following functions returns a lazily computed sequence resulting
from splitting the string str at occurrences of the substring s. If
the argument n is given, then the resulting sequence is restricted to
contain at most n strings, where the last string contains the
unsplitted remainder of the str.

   defn split (str:String, s:String) -> Seq<String>   
   defn split (str:String, s:String, n:Int) -> Seq<String>

The following relation is guaranteed return true.

   string-join(split(str, s), s) == str

The following functions returns the result of converting all letters
contained within the string s to either lower-case or upper-case.

   defn lower-case (s:String) -> String
   defn upper-case (s:String) -> String

The following function returns the result of removing leading and
trailing whitespace characters from the string s.

   defn trim (s:String) -> String

============================================================
===================== Tuples ===============================
============================================================

A Tuple represents a finite and immutable series of items each with an
integer index.

   deftype Tuple<T> <: Lengthable &
                       Collection<T> &
                       Equalable &
                       Hashable &
                       Comparable<Tuple<T>>

                    Creation
                    ========

The following function creates a tuple of length n with each element
initialized to x.

   defn Tuple<?T> (n:Int, x:?T) -> Tuple<T>              

The following function converts a finite sequence of items into a
tuple. The function will not terminate if given an infinite sequence.

   defn to-tuple<?T> (xs:Seqable<?T>) -> Tuple<T>

                   Equality
                   ========

Tuple is a subtype of Equalable and two tuples are defined to be equal
if they have the same length and all of their components are equal. It
is an error to check whether two tuples are equal if they contain
elements that are not Equalable.

                   Lengthable
                   ==========

The length of a tuple can be queried by calling the length multi.

   defmethod length (x:Tuple) -> Int

                 Retrieving Elements
                 ===================

The following function will return the item at index i within the
tuple x. i must be within the bounds of the range.

   defn get<?T> (x:Tuple<?T>, i:Int) -> T

The following function will return a new Tuple containing the items
spanned by the given range. The range must be a dense index range. 

   defn get<?T> (xs:Tuple<?T>, r:Range) -> Tuple<T>

                  Collection
                  ==========

Tuple is a subtype of Collection and implements an appropriate method
for the to-seq multi to access the elements of the tuple as a
sequence.

   defmethod to-seq<?T> (t:Tuple<?T>) -> Seq<T>

                  Hashable
                  ========

Tuple is a subtype of Hashable and computes its hash by combining the
hashes of all of its items. It is a fatal error to call hash on a
tuple containing items that are not Hashable.

   defmethod hash (t:Tuple<Hashable>) -> Int

                 Comparable
                 ==========

Tuple is a subtype of Comparable and implements an appropriate method
for the compare multi that compares two tuples by their lexicographic
order. It is a fatal error to compare two tuples containing elements
that are not Comparable with each other.

   defmethod compare (a:Tuple<Comparable>, b:Tuple<Comparable>) -> Int

             Convenience Functions
             =====================

The following function returns a new tuple containing the result of
calling the function f on each item in the tuple xs.

   defn map<?T,?R> (f:T -> ?R, xs:Tuple<?T>) -> Tuple<R>

The following function returns true if the tuple t is empty, otherwise
it returns false.

   defn empty? (t:Tuple) -> True|False


============================================================
====================== Lists ===============================
============================================================

A List represents an immutable linked list of items.

   deftype List<T> <: Lengthable &
                      Collection<T> &
                      Equalable &
                      Hashable &
                      Comparable<List<T>>   

                 Fundamental Operations
                 ======================

A List supports two fundamental operations, accessors for retrieving
the head and the tail of the list.

   defmulti head<?T> (x:List<?T>) -> T
   defmulti tail<?T> (x:List<?T>) -> List<T>

A List has two immediate subtypes, FullList and NilList, representing
respectively a list with a head and some tail, and the empty list. It
is a fatal error to call head or tail on a NilList.

   deftype FullList<T> <: List<T>
   deftype NilList <: List<Void>

                     Creation
                     ========

The following functions create lists with no, one, two, three, or four
elements respectively. The to-list function can be used to create
lists with more than four elements.

   defn List () -> NilList
   defn List<?T> (x:?T) -> FullList<T>
   defn List<?T> (x:?T, y:?T) -> FullList<T>
   defn List<?T> (x:?T, y:?T, z:?T) -> FullList<T>
   defn List<?T> (w:?T, x:?T, y:?T, z:?T) -> FullList<T>

The following function creates new lists by appending one, two, or
three elements to the head of an existing list. The append function
can be used to append more than three elements to a list.

   defn cons<?T> (x:?T, t:List<?T>) -> FullList<T>
   defn cons<?T> (x:?T, y:?T, t:List<?T>) -> FullList<T>
   defn cons<?T> (x:?T, y:?T, z:?T, t:List<?T>) -> FullList<T>

The following function creates a new list containing the items in the
sequence xs. The function will not terminate if given an infinite
sequence.

   defn to-list<?T> (xs:Seqable<?T>) -> List<T>
                     
                     Lengthable
                     ==========

List is a subtype of Lengthable and implements an appropriate method
for the length multi. Note that the length of a list is not cached,
and computing the length of a list takes time proportional to the
length of the list.

   defmethod length (x:List) -> Int

                     Collection
                     ==========

List is a subtype of Collection and implements an appropriate method
for the to-seq multi that allows for the list to be viewed as a
sequence.

   defmethod to-seq<?T> (x:List<?T>) -> Seq<T>
                     
                     Equalable
                     =========

List is a subtype of Equalable and two lists are defined to be equal
if they have the same length and all of their components are equal. It
is a fatal error to check whether two lists are equal if they contain
elements that are not Equalable.

   defmethod equal? (a:List<Equalable>, b:List<Equalable>) -> True|False
                     
                     Hashable
                     ========

List is a subtype of Hashable and implements an appropriate method for
the hash multi. The hash is computed by combining the hashes of all
the items in the list. It is a fatal error to call hash on a list
containing elements that are not Hashable.

   defmethod hash (a:List<Hashable>) -> Int

                     Comparable
                     ==========

List is a subtype of Comparable and implements an appropriate method
for the compare multi. Two lists are compared according to their
lexicographic ordering. If is a fatal error to compare two lists that
contain elements that are not Comparable to each other.

   defmethod compare (a:List<Comparable>, b:List<Comparable>) -> True|False
                     
                 Convenience Functions
                 =====================

The following function returns true if the given list is empty
(i.e. is a NilList) or false otherwise.

   defn empty? (x:List) -> True|False

The following function returns a sequence containing the items in the
list in reverse order.

   defn in-reverse<?T> (xs:List<?T>) -> Seq<T>

============================================================
===================== FileInfo =============================
============================================================

A FileInfo object contains position information about a specific point
in a text file.

   deftype FileInfo <: Equalable &
                       Hashable &
                       Comparable<FileInfo>

                  Accessors
                  =========

The following functions are used to retrieve a FileInfo's filename,
line, and column information.

   defn filename (i:FileInfo) -> String
   defn line (i:FileInfo) -> Int
   defn column (i:FileInfo) -> Int

                  Creation
                  ========

The following function creates a FileInfo from the given filename,
line, and column information.

   defn FileInfo (f:String, l:Int, c:Int) -> FileInfo

                  Equalable
                  =========

FileInfo is a subtype of Equalable and two FileInfo objects are equal
when their filenames, lines, and columns are equal.

   defmethod equal? (a:FileInfo, b:FileInfo) -> True|False

                  Hashable
                  ========

FileInfo is a subtype of Hashable and implements an appropriate method
for the hash multi by combining the hashes of its filename, line, and
column information.

   defmethod hash (i:FileInfo) -> Int

                  Comparable
                  ==========

FileInfo is a subtype of Comparable and implements an appropriate
method for the compare multi. Two FileInfo objects are compared by
ordering their filenames, followed their line index, followed by their
column index.

============================================================
======================= Token ==============================
============================================================

A Token represents a value that has been associated with a FileInfo
object indicating the position it originated from in a text file.

   deftype Token <: Equalable
   
                      Accessors
                      =========

The following functions are used to access a Token's wrapped value and
its associated FileInfo object.

   defn item (t:Token) -> ?
   defn info (t:Token) -> FileInfo

                      Creation
                      ========

The following function creates a Token from the given value and its
associated FileInfo object.

   defn Token (item, info:FileInfo) -> Token

                      Equalable
                      =========

A Token is a subtype of Equalable and two tokens are considered equal
if its FileInfo object is equal and the wrapped values are equal. It
is a fatal error to check whether two Tokens are equal if their
wrapped values are not Equalable.

   defmethod equal? (a:Token, b:Token) -> True|False

                Convenience Functions
                =====================

The following function returns the possibly wrapped value in a token
by recursively unwrapping the value if it is a token.

   defn unwrap-token (t) -> ?

The following function recursively calls unwrap-token in all tokens
and lists in the given value. This function is commonly used to strip
away all file information from an s-expression.

   defn unwrap-all (t) -> ?


============================================================
==================== KeyValue Pairs ========================
============================================================

A KeyValue pair represents a pairing of a key object with a value
object. It is typically used to represent entries in datastructures
where values are looked up according to a given key.

   deftype KeyValue<K,V> 

                       Accessors
                       =========

The following functions are used to retrieve the key and the value
from a KeyValue object.

   defn key<?K> (kv:KeyValue<?K,?>) -> K
   defn value<?V> (kv:KeyValue<?,?V>) -> V

                       Creation
                       ========

The following function creates a KeyValue pair from the given key and
value objects.

   defn KeyValue<?K,?V> (k:?K, v:?V) -> KeyValue<K,V>

Typically, users will use the following macro form for creating
KeyValue pairs.

   k => v

============================================================
===================== Exceptions ===========================
============================================================

An Exception object is used to represent the conditions under which an
exceptional behaviour as occurred.

   deftype Exception  

                  Creating Exceptions
                  ===================

Users are encouraged to create their own subtypes of Exception to
represent different types of exceptional behaviour. However, the
following function may be used to create a generic Exception object
with the given error message.

   defn Exception (msg) -> Exception

                  Throwing Exceptions
                  ===================

The following function throws the given exception object to the
current exception handler.

   defn throw (e:Exception) -> Void

                 Catching Exceptions
                 ===================

The following function runs the body function after installing the
handler function as the current exception handler. If the body runs
without throwing an exception, then its result is returned. Otherwise
the result of the exception handler is returned.

   defn with-exception-handler<?T> (body: () -> ?T, handler: Exception -> ?T) -> T

                   Finalization
                   ============

The following function runs the body function ensuring that the given
finally function is run immediately afterwards. If the body runs to
completion, then its result is returned after running the finally
function. Otherwise, the finally function is run before execution
exits the scope. Note that once the body function has started,
execution is not allowed to exit and then re-enter the scope.

   defn with-finally<?T> (body: () -> ?T, finally: (True|False) -> ?) -> T

                    Macro Forms
                    ===========

Users will not typically call with-exception-handler or with-finally
directly and instead use the standard macro forms. The following form
runs the given body with a handler for catching MyExceptions. The code
within the optional finally block is ensured to run whether or not the
body runs to completion.

   try :
      body code
   catch (e:MyException) :
      exception handling code
   finally :
      finalization code

============================================================
================= Attempt and Failure ======================
============================================================

The attempt and failure functions provide a convenient non-local exit
for users. The fail function exits from the current attempt scope and
calls the current failure handler.

   defn fail () -> Void

The following function calls the conseq function after installing the
alt function as the current failure handler. If the conseq function
runs to completion then its result is returned. Otherwise, if fail is
called during execution of conseq, the alt function is called and its
result is returned.

   defn with-attempt<?T> (conseq: () -> ?T, alt: () -> ?T) -> T

                    Macro Forms
                    ===========

Users will not typically call with-attempt directly and instead use
the standard macro forms. The following form runs the given body with
a failure handler that executes when fail is called.

   attempt :
      body code
   else :
      failure code

If no else branch is provided, then a default else branch is provided
that simply returns false.

============================================================
===================== Equalable ============================
============================================================

Values that support the equal? operation are indicated as subtypes of
Equalable.

   deftype Equalable

The multi equal? takes as argument two Equalable values and returns
true if they are equal or false otherwise.

   defmulti equal? (a:Equalable, b:Equalable) -> True|False

A default method for equal? is provided that simply returns false.

Equality in Stanza is defined to be invariant to substitution. That
is, suppose that our program contains a call to a function, f, with a
value x.

   f(x)

But earlier, we have determined that

   x == y

returns true, indicating that x is equal to y. Then we should we able
to substitute the usage of x with y instead without changing the
behaviour of the program.

   f(y)

Consistent to this definition, in Stanza's core library, values of
immutable types are defined to be equal if their subfields are
equal. Different mutable values, such as Arrays, are never defined to
be equal unless they refer to the same object.

                 Convenience Functions
                 =====================

The following function returns true if its two arguments are not equal
and false otherwise.

   defn not-equal? (a:Equalable, b:Equalable) -> True|False

============================================================
==================== Comparable ============================
============================================================

The Comparable type is used to indicate that a value can compared
against other values using the comparison operations. A value of type
Comparable<T> can be compared against values of type T.

   deftype Comparable<T>

             Fundamental Comparison Operation
             ================================

The following multi compares values of type Comparable<T> against
values of type T. All subtypes of Comparable must implement an
appropriate method for this multi. The multi returns a negative
integer if the item a is less than the item b, zero if the two are
equal, and a positive integer if the item a is greater than the item
b. For values that are subtypes of both Equalable and Comparable, the
compare operation must be consistently defined against the equal?
operation, and return 0 if equal? returns true.

   defmulti compare<?T> (a:Comparable<?T>, b:T) -> Int

              Derived Comparison Operations
              =============================

The following multis are provided for subtypes to provide efficient
implementations. Any defined method must return results consistent
with the compare operation. Default methods are provided for these
multis that are defined in terms of the compare operation.

   defmulti less?<?T> (a:Comparable<?T>, b:T) -> True|False
   defmulti greater?<?T> (a:Comparable<?T>, b:T) -> True|False
   defmulti less-eq?<?T> (a:Comparable<?T>, b:T) -> True|False
   defmulti greater-eq?<?T> (a:Comparable<?T>, b:T) -> True|False

                Convenience Functions
                =====================

The following functions compute the maximum or minimum of their two
given arguments.

   defn max<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T
   defn min<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T

The following functions compute the minimum between an initial value
x0, and a sequence of items xs using the provided comparison
function. If no initial value is provided, then the sequence xs cannot
be empty.

   defn minimum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T
   defn minimum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T

The following functions compute the maximum between an initial value
x0, and a sequence of items xs using the provided comparison
function. If no initial value is provided, then the sequence xs cannot
be empty.

   defn maximum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T
   defn maximum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T

The following functions compute the minimum between an initial value
x0, and a sequence of comparable items xs using the less? multi. If no
initial value is provided, then the sequence xs cannot be empty.

   defn minimum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T
   defn minimum<?T> (xs:Seqable<?T&Comparable>) -> T

The following functions compute the maximum between an initial value
x0, and a sequence of comparable items xs using the less? multi. If no
initial value is provided, then the sequence xs cannot be empty.

   defn maximum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T
   defn maximum<?T> (xs:Seqable<?T&Comparable>) -> T

The following function returns the minimum in a sequence of items xs
by comparing the keys extracted from each item using the provided key
function.

   defn minimum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T

The following function returns the maximum in a sequence of items xs
by comparing the keys extracted from each item using the provided key
function.

   defn maximum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T

============================================================
==================== Hashable ==============================
============================================================

The type Hashable indicates that a value supports the hash multi and
can represented (non-uniquely) as an Int value.

   deftype Hashable

The hash multi takes a Hashable argument and returns an Int. For the
correct operation of HashTable implementations, the definition of hash
must be consistent with the definition of equal?. If two values are
equal, then they must also return the same hash.

   defmulti hash (h:Hashable) -> Int

============================================================
===================== Seq ==================================
============================================================

A Seq represents a possibly finite sequence of items.

   deftype Seq<T> <: Seqable<T>

A Seq supports the following fundamental operations.

   defmulti empty? (s:Seq) -> True|False
   defmulti next<?T> (s:Seq<?T>) -> T
   defmulti peek<?T> (s:Seq<?T>) -> T

The empty? multi returns true if the sequence contains more items, or
false otherwise.

The next multi returns the next item in the sequence. Repeated calls
to next results in successive items in the sequence to be returned. It
is a fatal error to call next on an empty sequence.

The peek multi inspects the next item in the sequence but does not
consume it. Repeated calls to peek results in the same item begin
returned. It is a fatal error to call peek on an empty sequence.

============================================================
=================== Seqable ================================
============================================================

A Seqable represents any value that may be viewed as a sequence of
items. It supports the fundamental operation

   defmulti to-seq<?T> (s:Seqable<?T>) -> Seq<T>

to return a Seq that represents a sequential view of its given
argument.

A value of type Seq is defined to also be a Seqable and trivially
returns itself when called with to-seq.

============================================================
=================== Collection =============================
============================================================

A Collection is defined to be a subtype of Seqable and thus must also
support the to-seq operation. The crucial difference between a
Collection and Seqable is that a Collection must be *repeatedly*
viewable as a sequence of items.

As an example, consider a function, print-all-twice, that iterates
through and prints out the items in a sequence twice.

   defn print-all-twice (xs:Seqable) -> False :
      val seq1 = to-seq(xs)
      while not empty?(seq1) :
         println(next(seq1))

      val seq2 = to-seq(xs)
      while not empty?(seq2) :
         println(next(seq2))

Such a function would not work as expected when called with a
Seq. Recall that calling to-seq on a Seq is a trivial operation that
returns the Seq directly. Thus the first while loop will print out
every item in the sequence, but the second while loop will not
complete a single iteration as the sequence is already empty. The
correct type signature for print-all-twice would be

   defn print-all-twice (xs:Collection) -> False

Seq is a subtype of Seqable, but Seq is not a subtype of
Collection. Thus the new type signature correctly disallows
print-all-twice from being called with Seqs.

============================================================
================= Sequence Library =========================
============================================================

The core package contains a large number of convenience functions that
operate on sequences. The majority of collection datastructures in
Stanza's core library are subtypes of Seqable and thus can be used
with this sequence library.

                 Operating Functions
                 ===================

Operating functions, such as do, seq, and find, are functions with
type signatures compatible with the for macro form. The following
macro form:

   for x in xs do :
      body code

is equivalent to the following direct call to the do operating
function:

   do(fn (x) :
         body code
      xs)

Multi-argument operating functions are used with the following macro
form.

   for (x in xs, y in ys, z in zs) do :
      body code

is equivalent to the following direct call to the do operating
function:

   do(fn (x, y, z) :
         body code
      xs, ys, zs)   

As a matter of style, if the body consists of more than a single
function call then the macro form is used, as in the following
example:

   val x = 671
   val prime? = for i in 2 to x none? :
      x % i == 0

If the body consists of a single function call then the standard
function call form is used instead.

   val x = 671
   defn divides-x? (i:Int) : x % i == 0
   val prime? = none?(divides-x?, 2 to x)

The above example can also be written using anonymous function
notation as follows:

   val x = 671
   val prime? = none?({x % _ == 0}, 2 to x)

              The Do Operating Function
              =========================

The following multi calls the function f on each item in the
sequence xs. A default method defined in terms of the fundamental
sequence operations is provided, but users may provide customized
methods for subtypes of Seqable for efficiency.

   defmulti do<?T> (f:T -> ?, xs:Seqable<?T>) -> False

The following multis operate similarly to the single collection
version of do but instead calls the function f with successive items
from multiple sequences. The sequences are stepped through in parallel
and iteration stops as soon as one of them is empty.

   defmulti do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False
   defmulti do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False

            The Find Operating Function
            ===========================

The following function iterates through the sequence xs and calls the
function f on each item, searching for the first item for which f
returns true. If f returns true on some item, then that item is
returned by find. If f does not return true on any item in the
sequence, then find returns false.

   defn find<?T> (f: T -> True|False, xs:Seqable<?T>) -> T|False

The following function iterates through the sequence xs and ys in
parallel and calls the function f with an item from each
sequence. Iteration stops as soon as either sequence is empty. If f
returns true when called by an item, x, from xs and an item, y, from
ys, then x is returned by find.

   defn find<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> T|False

The following functions behaves identically to find except that it
assumes that their exists an item (or pair of items) for which f
returns true.

   defn find!<?T> (f: T -> True|False, xs:Seqable<?T>) -> T
   defn find!<?T, ?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> T

          The First Operating Function
          ============================

The following function iterates through the sequence xs and calls the
function f on each item, searching for the first item for which f
returns a One object. If f returns a One object on some item, then the
One object is returned. If f returns a None object for all items in
the sequence, then a None object is returned by first.

   defn first<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Maybe<R>

The following function iterates through the sequence xs and ys in
parallel and calls the function f repeatedly with an item from each
sequence. Iteration stops as soon as either sequence is empty. If f
returns a One object on some pair of items, then the One object is
returned. If f returns a None object for all items in the sequences,
then a None object is returned by first.

   defn first<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Maybe<R>

The following functions behave identically to first except that it
assumes that their exists an item (or pair of items) for which f
returns a One object. The wrapped value within the One object is
returned.

   defn first!<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> R
   defn first!<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> R

           The Seq Operating Function
           ==========================

The following function constructs the sequence resulting from calling
the function f on each item in the sequence xs.

   defn seq<?T,?S> (f:T -> ?S, xs:Seqable<?T>) -> Seq<S>

The following multis operate similarly to the single collection
version of seq but instead calls the function f with successive items
from multiple sequences. The sequences are stepped through in parallel
and iteration stops as soon as one of them is empty.

   defn seq<?T,?S,?R> (f:(T,S) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R>
   defn seq<?T,?S,?U,?R> (f:(T,S,U) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R>

          The Seq? Operating Function
          ===========================

The following function constructs a sequence by calling the function f
on each item in the sequence xs. For each item in xs, if f returns a
One object, then the unwrapped value is included in the result
sequence. If f returns a None object then the item is not included in
the result sequence.

   defn seq?<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Seq<R>

The following functions constructs a sequence by iterating through the
given sequences in parallel and calling the function f repeatedly with
an item from each sequence. For each pair (or triplet) of items, if f
returns a One object, then the unwrapped value is included in the
result sequence. If f returns a None object then the item is not
included in the result sequence.

   defn seq?<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R>
   defn seq?<?T,?S,?U,?R> (f: (T,S,U) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R>

          The Filter Operating Function
          =============================

The following function constructs a sequence by calling the function f
on each item in the sequence xs, and including the item in the result
sequence only if the call to f returns true.

   defn filter<?T> (f: T -> True|False, xs:Seqable<?T>) -> Seq<T>

The following function constructs a sequence by iterating through the
xs and ys sequences in parallel and calling the function f repeatedly
with an item from each sequence. For each pair of items, if f returns
true, then the item from the xs sequence is included in the result
sequence.

   defn filter<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<T>

           The Index-When Operating Function
           =================================

The following function iterates through the items in the xs sequence,
calling f on each one, and returns the first index at which the call
to f returns true. If no call to f returns true, then index-when
returns false.

   defn index-when<?T> (f: T -> True|False, xs:Seqable<?T>) -> Int|False

The following function iterates through the xs and ys sequences in
parallel, calling f on each pair of items from xs and ys, and returns
the first index at which the call to f returns true. If no call to f
returns true, then index-when returns false.

   defn index-when<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Int|False

The following functions behaves identically to index-when except that
it assumes there exists an item (or pair of items) for which the call
to f returns true.

   defn index-when!<?T> (f: T -> True|False, xs:Seqable<?T>) -> Int
   defn index-when!<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Int

           The Split Operating Function
           ============================

The following function iterates through the items in the xs sequence,
separating them into two collections depending on whether calling f on
the item returns true or false. The function returns a tuple of two
collections, the first of which contains all items in the sequence for
which f returned true, and the second of which contains all items for
which f returned false.

   defn split<?T> (f: T -> True|False, xs: Seqable<?T>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable]

          The Take-While Operating Function
          =================================

The following function constructs a sequence by taking items
successively from the xs sequence as long as calling f upon the item
returns true. The resulting sequence ends as soon as xs is empty or f
returns false. The item for which f returns false is not included in
the resulting sequence.

   defn take-while<?T> (f: T -> True|False, xs:Seqable<?T>) -> Seq<T>

           The Take-Until Operating Function
           =================================

The following function constructs a sequence by taking items
successively from the xs sequence as long as calling f upon the item
returns false. The resulting sequence ends as soon as xs is empty or f
returns true. The item for which f returns true is included in the
resulting sequence.

   defn take-until<?T> (f: T -> True|False, xs:Seqable<?T>) -> Seq<T>

           The Seq-Cat Operating Function
           ==============================

The following function constructs a sequence by calling f upon each
item on the xs sequence. seq-cat then returns the concatenation of all
sequences returned by f.

   defn seq-cat<?T,?R> (f:T -> Seqable<?R>, xs:Seqable<?T>) -> Seq<R>

The following functions constructs a sequence by iterating through the
given sequences in parallel and calling f upon each pair (or triplet)
of items from each sequence. seq-cat then returns the concatenation of
all sequences returned by f.

   defn seq-cat<?T,?S,?R> (f:(T,S) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R>
   defn seq-cat<?T,?S,?U,?R> (f:(T,S,U) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R>

           The All? Operating Function
           ===========================

The following function iterates through the items in the sequence xs
and calls pred? on each one. If pred? returns true for every item in
the sequence all?  returns true. If pred? returns false for any item,
then all?  immediately returns false.

   defn all?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False

The following functions iterates through the given sequences in
parallel and calls pred? on each pair (or triplet) of items from each
sequence. Iteration stops as soon as any sequence is empty. all?
returns true if all calls to pred? returns true. all? returns false
immediately after a call to pred? returns false.

   defn all?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False
   defn all?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False

         The None? Operating Function
         ============================

The following function iterates through the items in the sequence xs
and calls pred? on each one. If pred? returns true for no item in the
sequence then none?  returns true. If pred? returns true for any item,
then none?  immediately returns false.

   defn none?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False

The following functions iterates through the given sequences in
parallel and calls pred? on each pair (or triplet) of items from each
sequence. Iteration stops as soon as any sequence is empty. none?
returns true if no calls to pred? returns true. none? returns false
immediately after a call to pred? returns true.

   defn none?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False
   defn none?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False


         The Any? Operating Function
         ===========================

The following function iterates through the items in the sequence xs
and calls pred? on each one. If pred? returns true for no item in the
sequence then any?  returns false. If pred? returns true for any item,
then any?  immediately returns true.

   defn any?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False

The following functions iterates through the given sequences in
parallel and calls pred? on each pair (or triplet) of items from each
sequence. Iteration stops as soon as any sequence is empty. any?
returns false if no calls to pred? returns true. any? returns true
immediately after a call to pred? returns true.

   defn any?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False
   defn any?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False

        The Count Operating Function
        ============================

The following function iterates through the items in the sequence xs
and calls pred? on each one. count returns the number of times that
pred? returned true.

   defn count<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> Int


              Sequence Constructors
              =====================

The following function creates an infinite sequence resulting from
repeating x indefinitely.

   defn repeat<?T> (x:?T) -> Seq<T>

The following function creates a sequence resulting from repeating x
for n number of times.

   defn repeat<?T> (x:?T, n:Int) -> Seq<T> & Lengthable

The following function creates an infinite sequence from the results
of calling f repeatedly.

   defn repeatedly<?T> (f:() -> ?T) -> Seq<T>

The following function creates a sequence resulting from the results
of calling f n number of times.

   defn repeatedly<?T> (f:() -> ?T, n:Int) -> Seq<T> & Lengthable

The following function creates a sequence resulting from calling f
repeatedly and including, in the result sequence, the unwrapped values
of every One object returned by f. The sequence ends as soon as f
returns a None object.

   defn repeat-while<?T> (f: () -> Maybe<?T>) -> Seq<T>


              Sequence Operators
              ==================

The following function constructs a sequence by iterating through the
xs and sel sequences in parallel and including items from the xs
sequence in the result sequence only if the corresponding item from
the sel sequence is true.

   defn filter<?T> (xs:Seqable<?T>, sel:Seqable<True|False>) -> Seq<T>

The following function constructs a sequence by taking the first n
items from the xs sequence. The xs sequence must contain at least n
items.

   defn take-n<?T> (n:Int, xs:Seqable<?T>) -> Seq<T>

The following function constructs a new sequence by concatenating the
a sequence with the b sequence.

   defn cat<?T> (a:Seqable<?T>, b:Seqable<?T>) -> Seq<T>

The following function constructs a new sequence by concatenating
together all sequences in the xss sequence.

   defn cat-all<?T> (xss: Seqable<Seqable<?T>>) -> Seq<T>

The following function constructs a new sequence by including the item
y in between each item in xs.

   defn join<?T,?S> (xs:Seqable<?T>, y:?S) -> Seq<T|S>
   

              Sequence Reducers
              =================

The following function returns true if the xs sequence contains the
item y; otherwise it returns false.

   defn contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False

The following function returns the first index at which the item in
the xs sequence is equal to the item y. If no item in xs is equal to y
then index-of returns false.

   defn index-of (xs:Seqable<Equalable>, y:Equalable) -> Int|False

The following function behaves identically to index-of except that it
assumes there exists an item in xs that is equal to y.

   defn index-of! (xs:Seqable<Equalable>, y:Equalable) -> Int

The following function iterates through the items in the xs and ss
sequence in parallel, and separates the items from xs into two
collections depending on whether the corresponding item from ss is
true or false. The function returns a tuple of two collections, the
first of which contains all items in xs for which the corresponding
item in ss is true, and the second of which contains the other items
in xs

   defn split<?T> (xs:Seqable<?T>, ss:Seqable<True|False>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable]

The following function returns the number of items in the given
sequence. If the sequence is a subtype of Lengthable, then the length
is returned directly. Otherwise, the length is calculated by iterating
through the entire sequence.

   defn count (xs:Seqable) -> Int

The following function computes the left oriented reduction using
function f on the sequence xs starting with initial value x0. If xs is
empty then x0 is returned. Otherwise, the function f is applied on x0
and the first element in xs, then f is applied again on that result
and the second element in xs, then f is applied on that result and
third element in xs, and so forth until xs is empty. reduce returns
the final result returned by f.

   defn reduce<?T,?S,?U> (f: (T|U, S) -> ?U, x0: ?T, xs:Seqable<?S>) -> T|U

When no initial value is provided, then the first element in xs is
used as the initial value of the reduction. xs must not be empty.

   defn reduce<?T,?S> (f: (T|S, T) -> ?S, xs:Seqable<?T>) -> T|S

The following function computes the right oriented reduction using
function f on the sequence xs with final value xn. If xs is empty then
xn is returned. If xs has a single element, then f is applied on that
element and xn. If xs has two elements, then f is applied on the first
element and the result of applying f on the second element and xn. If
xs has three elements, then f is applied on the first element and the
result of applying f on the second element and the result of applying
f on the third element and xn. Et cetera. 

   defn reduce-right<?T,?S,?U> (f: (S, T|U) -> ?U, xn:?T, xs:Seqable<?S>) -> T|U

When no final value is provided, then the last element in xs is used
as the final value of the reduction. xs must not be empty.

   defn reduce-right<?T,?S> (f: (T, T|S) -> ?S, xs:Seqable<?T>) -> T|S

============================================================
=================== Lengthable =============================
============================================================

A Lengthable is a value that has either a fixed or variable length.

   deftype Lengthable

Any subtype of Lengthable must implement an appropriate method for the
length multi.

   defmulti length (l:Lengthable) -> Int

============================================================
=========== Liveness Trackers and Markers ==================
============================================================

Stanza's support for automatic garbage collection means that users do
not need to manually delete objects after their use. However, it is
often useful to know when an object has been reclaimed to perform
additional cleanup operations. LivenessTrackers and LivenessMarkers
are used to track whether an object is still live. 

                   Creation
                   ========

A LivenessTracker can be created using the following function. For
convenience, every LivenessTracker may be associated with a value to
indicate the identity of the tracker.

   defn LivenessTracker<?T> (value:?T) -> LivenessTracker<T>

The following function can be used to retrieve the value associated
with a tracker.

   defn value<?T> (tracker:LivenessTracker<?T>) -> T

           Creating and Checking Markers
           =============================

The following function is used to create or check upon a LivenessMarker.

   defn marker (tracker:LivenessTracker) -> False|LivenessMarker

The first time this function is called on a LivenessTracker it is
guaranteed to return its associated LivenessMarker. This marker may
then be stored with an object whose liveness the user wishes to
track. On subsequent calls to marker, the function will either return
the created marker, which indicates that the marker is still live. Or
it will return false, which indicates that the marker is now longer
live, and hence neither is the object in which it is stored.
                
Consider tracking the liveness of values of type Car. Intuitively, it
is helpful to imagine a LivenessTracker as a futuristic pistol that
can shoot a tracking beacon (its LivenessMarker) which sticks to the
Car. Periodically, you may ask the tracker whether it is still
receiving signal from the beacon, in which case the marker and hence
the Car is still live. If the beacon is no longer sending a signal
(marker returns false), then the marker and hence the Car is no longer
live.


============================================================
================= IndexedCollection ========================
============================================================

An IndexedCollection represents a mutable collection containing a
series of items, each of which is associated with an integer index.

   deftype IndexedCollection<T> <: Lengthable & Collection<T>

It is a subtype of Lengthable and all values with type
IndexedCollection must implement an appropriate method for the length
multi.

All IndexedCollections are subtypes of Collection and support the
to-seq operation. A default method for to-seq defined in terms of
length and get is provided. For efficiency purposes, subtypes of
IndexedCollections may provide a customized method of to-seq, but it
is not required.


                 Fundamental Operations
                 ======================

Appropriate methods for getting and setting an item at a given index i
must be provided for all subtypes.

   defmulti get<?T> (a:IndexedCollection<?T>, i:Int) -> T
   defmulti set<?T> (a:IndexedCollection<?T>, i:Int, v:T) -> False

                 Convenience Functions
                 =====================

The following function returns a range of items with an
IndexedCollection. The range must have a step size of 1. If the range
is finite, then the starting index must be less than or equal to the
ending index. If the range is inclusive, than the starting and ending
index must be non-negative and less than the length of the
collection. If the range is exclusive, than the starting and ending
index must be non-negative and less than or equal to the length of the
collection. A default method defined in terms of get is provided, but
subtypes may provide customized methods for efficiency purposes if
desired.

   defmulti get<?T> (a:IndexedCollection<?T>, r:Range) -> Collection<T>

The following function sets a range of indices within the collection
to items taken sequentially from vs. See the definition of get for
restrictions upon the range r. The sequence vs must contain at least
as many items as indices being assigned. A default method defined in
terms of set is provided, but subtypes may provide customized methods
for efficiency purposes if desired.

   defmulti set<?T> (a:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False

The following function iterates through the given collection and
replaces each item with the result of calling f on the item. A default
method defined in terms of get and set is provided, but subtypes may
provide customized methods for efficiency purposes if desired.

   defmulti map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False

The following function returns true if the collection is empty or
false otherwise.

   defn empty? (v:IndexedCollection) -> True|False

The following function reverses the order in which items appear in the
collection.

   defn reverse!<?T> (xs:IndexedCollection<?T>) -> False

The following function returns a sequence containing the items in the
collection in reversed order. The original collection is unchanged.

   defn in-reverse<?T> (xs:IndexedCollection<?T>) -> Seq<T>

============================================================
=================== Sorting ================================
============================================================

The following function sorts the collection using the given comparison
function and the quick sort algorithm.

   defn qsort!<?T> (xs:IndexedCollection<?T>, is-less?:(T,T) -> True|False) -> False

The following function sorts the collection using the less? multi and
the quick sort algorithm.

   defn qsort!<?T> (xs:IndexedCollection<?T&Comparable>) -> False

The following function sorts the collection by comparing keys
extracted using the key function and the quick sort algorithm.

   defn qsort!<?T> (key:T -> Comparable, xs:IndexedCollection<?T>) -> False

The following function returns a lazily sorted sequence of the given
sequence xs using the given comparison function and the quick sort algorithm.

   defn lazy-qsort<?T> (xs:Seqable<?T>, is-less?:(T,T) -> True|False) -> Collection<T> & Lengthable

The following function returns a lazily sorted collection of the given
sequence xs using the less? multi and the quick sort algorithm.

   defn lazy-qsort<?T> (xs:Seqable<?T&Comparable>) -> Collection<T> & Lengthable

The following function returns a lazily sorted collection of the given
sequence xs by comparing keys extracted using the key function and the quick sort algorithm.

   defn lazy-qsort<?T> (key:T -> Comparable, xs:Seqable<?T>) -> Collection<T> & Lengthable

============================================================
==================== Arrays ================================
============================================================

Arrays are the most fundamental IndexedCollection in Stanza,
representing a finite series of items with constant time access to
elements by index.

   deftype Array<T> <: IndexedCollection<T> & Equalable

An array is a subtype of IndexedCollection and hence supports the
fundamental get and set and length operations.

                   Equality
                   ========

Two arrays are defined to be equal only if are the same array.

                   Creation
                   ========

The following function creates an Array with length n for holding
values of type T. It is a fatal error to read from an index that has
not been initialized, and n cannot be negative.

   defn Array<T> (n:Int) -> Array<T>

The following function creates an Array with length n for holding
values of type T with each index initialized to the item x. n cannot
be negative.

   defn Array<T> (n:Int, x:T) -> Array<T>

               Convenience Functions
               =====================

The following function converts a sequence of items of type T to an
array.

   defn to-array<T> (xs:Seqable<T>) -> Array<T>

The following function creates a new array where each item is
initialized to the result of calling the function f on each item in
the given array xs.

   defn map<R,?T> (f:T -> R, xs:Array<?T>) -> Array<R>


============================================================
================== CharArrays ==============================
============================================================

CharArrays are specialized arrays designed specifically for
efficiently storing Chars.

   deftype CharArray <: Array<Char>

CharArrays implement appropriate methods for each of the multis
required by Array and behaves equivalently to an Array<Char>.

                   Creation
                   ========

The following function creates a CharArray of length n, with each
index initialized to the space character.

   defn CharArray (n:Int) -> CharArray

The following function creates a CharArray of length n, with each
index initialized to the given character x.

   defn CharArray (n:Int, x:Char) -> CharArray

             Efficient Char Retrieval
             ========================

The following function allows for efficient retrieval of characters
from a CharArray. See the definition of get for restrictions on the
range r.

   defn get-chars (cs:CharArray, r:Range) -> String
   
The following function allows for efficient assignment of characters
in a CharArray. See the definition of get for restrictions on the
range r.

   defn set-chars (cs:CharArray, r:Range, s:String) -> False

CharArray implements efficient methods for getting and setting
characters which call get-chars and set-chars appropriately.

   defmethod get (cs:CharArray, r:Range) -> String
   defmethod set (cs:CharArray, r:Range, s:String) -> False
