############################################################
################## Core Macros #############################
############################################################

The core macros are the default macros used for expanding
s-expressions into Stanza core forms.

============================================================   
====================== Types ===============================
============================================================

The following form creates a function type.

   (Int, Int) -> Int

If there is exactly a single argument, then the parenthesis may be
omitted.

   Int -> Int

The following form creates an intersection type.

   Int & String

The following form creates a union type.

   Int | String

The following form represents a captured type argument.

   ?T

The following form represents a tuple type.

   [Int, Int]

The following form represents a parametric type.

   Array<Int, String>

The following form represents the unknown type.

   ?

The following form represents the bottom type.

   Void

============================================================
==================== Expressions ===========================
============================================================

The backtick form represents a literal s-expression. For example, the
following form creates a list consisting of three elements: the symbol
f, the integer 3, and the symbol g.

   `(f 3 g)

Multiple expressions surrounded with parenthesis represent a sequence
of expressions, whose value is equal to the value of the last
expression.

   (x + 3, 3, f(3))

Expressions followed immediately opening parenthesis expand to
function call forms.

   f(x)

Expressions followed by angle brackets then opening parenthesis expand
to polymorphic function call forms.

   f<Int>(x)

Expressions followed by opening square brackets expand to a call to
the get function.

   f[x, y] expands to get(f, x, y)

Expressions followed by opening square brackets and then an equal sign
expands to a call to the set function.

   f[x, y] = v expands to set(f, x, y, v)

Expressions followed by an opening curly bracket expand to an
anonymous function, with underscores replaced by arguments.

   f{_, y} expands to fn (x) : f(x, y)

If there are no underscores, then the created anonymous function can
take both no arguments and a single argument.

   f{y} expands to multifn :
                      () : f(y)
                      (x) : f(y)

Expressions wrapped in curly brackets expand to an anonymous function,
with underscores replaced by arguments.

   {_ + y} expands to fn (x) : x + y

If there are no underscores, then the created anonymous function can
take both no arguments and a single argument.

   {y} expands to multifn :
                     () : y
                     (x) : y

The as operator represents a cast to a type.

   x as Int

If followed with an else clause, then the as operator will return the
given default value if the expression is not of the given type.

   x as Int else y

The as? operator represents an upcast to a type.

   x as? Int

The following form represents the creation of a tuple.

   [x, y]

The following form creates a new object of the type MyType with no
instance methods.

   new MyType

The following form creates a new object of the type MyType with
instance methods.

   new MyType :
      defmethod f (this) :
         x

The following form creates a Range from a to b (exclusive) with a step
size of 1.

   a to b

A step size may be provided explicit using the by keyword.

   a to b by 2

To indicate that the ending index should be inclusive rather than
exclusive, the through keyword may be used in place of the to keyword.

   a through b
   a through b by 2   

The following operator calls the expression f with the argument x.

   f $ x

The following form evaluates one of two branches depending on whether
the predicate is true or false.

   if p :
      consequent
   else :
      alternate

If the else branch is omitted, then a default else branch is provided
that simply returns false.

   if p :
      consequent

If the else branch consists of a single if expression, then the colon
following the else may be omitted. This allows multiple if expressions
to be chained elegantly.

   if p1 :
      consequent1
   else if p2 :
      consequent2
   else if p3 :
      consequent3
   else :
      alternate

The following form allows for branches on true/false to be written
concisely.

   consequent when p else alternate

expands to:

   if p :
      consequent
   else :
      alternate

If the else clause is omitted, then it returns false by default.

The following form evaluates one of a multiple of branches depending
on the types of its arguments. If no type is given for a branch
argument then it is inferred from the type of the input arguments.

   match(x, y) :
      (x:Int, y:Int) : body0
      (x:Int, y:String) : body1
      (x:String, y:Int) : body2
      (x, y) : body3

The following form evaluates its body under a new scope.

   let :
      body

The following form evaluates an expression with a set of declared
bindings.

   exp where :
      body

expands to:

   let :
      body
      exp

The following example shows assigning x to the result of 42 - (10 *
y).

   x = (42 - z) where :
      val z = 10 * y

The following form calls an operating function with an anonymous
function and a list of arguments.

   for (x in xs, y in ys, z in zs) do : body

expands to:

   do((fn (x, y, z) : body), xs, ys, zs)

If there is only a single set of bindings, then the parenthesis may be
omitted.

   for x in xs do : body

The following form creates a while loop that repeats as long as a
given predicate returns true.

   while p :
      body





                      Operators
                      =========

Operators in Stanza expand to function calls. The following is a
listing of the core operators and their expanded form.

   (- x) : negate(x)
   (~ x) : bit-not(x)
   not x : complement(x)
   x == y : equal?(x, y)
   x != y : not-equal?(x, y)
   x < y : less?(x, y)
   x <= y : less-eq?(x, y)
   x > y : greater?(x, y)
   x >= y : greater-eq?(x, y)
   x + y : plus?(x, y)
   x - y : minus?(x, y)
   x * y : times(x, y)
   x / y : divide(x, y)
   x % y : modulo(x, y)
   x << y : shift-left(x, y)
   x >> y : shift-right(x, y)
   x >>> y : arithmetic-shift-right(x, y)
   x & y : bit-and(x, y)
   x | y : bit-or(x, y)
   x ^ y : bit-xor(x, y)

                 Type Declarations
                 =================

The following form defines the type MyType.

   deftype MyType

The following form defines the type MyType as a subtype of Collection
and Lengthable.

   deftype MyType <: Collection & Lengthable

The following form defines the type MyType, and also defines the types
Int and String to be subtypes of MyType.

   deftype MyType :
      Int <: MyType
      String <: MyType

Parametric types may be defined as follows.

   deftype MyType<T>

These type parameters may be used in the specification of the types
parents.

   deftype MyType<T> <: Collection<T> & Lengthable

                Function Declarations
                =====================

Argument lists have the following form:

   (x:Int, y:Int, z)

Each argument binding consists of a binding expression followed by a
colon and a type for the argument. If the binding expression is not
followed by a colon, then it has no given type, and its type will
either be inferred (as in the case for anonymous functions) or will
have the unknown type. Tuples (and nested tuples) may be used for
binding expressions in order to deconstruct an argument's value.

   ([x, y]:[Int, String], y:Int, z)

The following form creates an anonymous function with two arguments.

   fn (x, y) : x + y

Users may optionally declare the types of the arguments and the return
value using the following form.

   fn (x:Int, y:String) -> Char : x + y

The following forms creates an anonymous function with multiple
arities.

   multifn :
      (x) : x + 1
      (x, y) : x + 2

Users may optionally declare the types of the arguments and the return
values using the following form.

   multifn :
      (x:Int) -> Int : x + 1
      (x:Int, y:String) -> String : x + 2

The following form defines a named function.

   defn f (x, y) : x + y

Users may optionally declare the types of the arguments and the return
value using the following form.

   defn f (x:Int, y:String) -> Char : x + y

The following form declares a multi with the given type signature.

   defmulti f (x:Int, y:String) -> String

If no types are provided for the arguments or return type, then they
have the unknown type by default.

   defmulti f (x, y)   

The following form declares a method for the given multi.

   defmethod f (x, y) : x + y

Users may optionally declare the types of the arguments and the return
value using the following form.

   defmethod f (x:Int, y:String) -> Int : x + y

                 Tail Calls
                 ==========

To enable tail calls for a function, use the following tags in place
of the default tags.

   fn* instead of fn
   multifn* instead of multifn
   defn* instead of defn
   defmethod* instead of defmethod


           Value and Variable Declarations
           ===============================

The following form declares a value.

   val x : Int = v

If the type is omitted then it is inferred from the given value.

   val x = v

Tuples may be used within the binding expression to destructure the
given value.

   val [x, [y, z]] = v

The following form declares a variable.

   var x : Int = v

If the type is omitted then it is inferred from any assignments to the
variable.

   var x = v

The initializing expression may be omitted to declare an
uninitialized variable. It is an error to read from a variable that is
not yet initialized.

   var x

The following form represents an assignment to a variable.

   x = v

                Packages and Visibility
                =======================

Either of the following forms can be used to indicate that the
following declaration(s) is publicly visible.

   public decl
   public : decl

The colon version is typically used to indicate the visibility of
multiple declarations.

   public :
      val x = 10
      val y = 20

The following forms are used to indicate that the following
declaration(s) has protected visibility.

   protected decl
   protected : decl

The following form declares a new package with no imports.

   defpackage mypackage

Bindings from other packages may be imported using the import
statement.

   defpackage mypackage :
      import core
      import collections

Prefixes may be added to bindings from an imported package. The
following form will append the prefix "core-" to every imported
binding from the core package, except for bindings named
False. Bindings named False will have the prefix "C" appended.

   defpackage mypackage :
      import core with :
         prefix => core-
         prefix(False) => C





############################################################
################## Core Library ############################
############################################################

The core package consists of functions and types used for basic
programming.

============================================================
================== Number Types ============================
============================================================

The following types make up Stanza's basic numerical types.

   deftype Byte <: Equalable & Hashable & Comparable<Byte>
   deftype Int <: Equalable & Hashable & Comparable<Int>
   deftype Long <: Equalable & Hashable & Comparable<Long>
   deftype Float <: Equalable & Hashable & Comparable<Float>
   deftype Double <: Equalable & Hashable & Comparable<Double>
   
A Byte represents an 8-bit unsigned integer between 0 and 255
(inclusive). An Int represents a 32-bit signed integer. A Long
represents a 64-bit signed integer. A Float represents a 32-bit real
number in IEEE 754 encoding. A Double represents a 64-bit real number
in IEEE 754 encoding.

Note that the numerical types are each subtypes of Equalable,
Hashable, and Comparable. This means that they support the equality
operator, implements an appropriate method for the hash multi, and can
be compared against themselves.

                  Equality
                  ========

Each of the numerical types are subtypes of Equalable, and hence
implements an appropriate method for the equal? multi. Note that
numerical values of different types are never defined to be equal to
one another. Thus the Int, 0, is not equal to the Long, 0L. 

   defmethod equal? (x:Byte, y:Byte) -> True|False
   defmethod equal? (x:Int, y:Int) -> True|False
   defmethod equal? (x:Long, y:Long) -> True|False
   defmethod equal? (x:Float, y:Float) -> True|False
   defmethod equal? (x:Double, y:Double) -> True|False

                 Comparable
                 ==========

Each of the numerical types are subtypes of Comparable, and hence
implements an appropriate methods for comparison operations: compare, less?,
less-eq?, greater?, greater-eq?. Note that values of different
numerical types cannot be compared with each other. Attempting to do
so is a fatal error. 

   defmethod compare (x:Byte, y:Byte) -> Int
   defmethod compare (x:Int, y:Int) -> Int
   defmethod compare (x:Long, y:Long) -> Int
   defmethod compare (x:Float, y:Float) -> Int
   defmethod compare (x:Double, y:Double) -> Int

   defmethod less? (x:Byte, y:Byte) -> True|False
   defmethod less? (x:Int, y:Int) -> True|False
   defmethod less? (x:Long, y:Long) -> True|False
   defmethod less? (x:Float, y:Float) -> True|False
   defmethod less? (x:Double, y:Double) -> True|False

   defmethod less-eq? (x:Byte, y:Byte) -> True|False
   defmethod less-eq? (x:Int, y:Int) -> True|False
   defmethod less-eq? (x:Long, y:Long) -> True|False
   defmethod less-eq? (x:Float, y:Float) -> True|False
   defmethod less-eq? (x:Double, y:Double) -> True|False

   defmethod greater? (x:Byte, y:Byte) -> True|False
   defmethod greater? (x:Int, y:Int) -> True|False
   defmethod greater? (x:Long, y:Long) -> True|False
   defmethod greater? (x:Float, y:Float) -> True|False
   defmethod greater? (x:Double, y:Double) -> True|False

   defmethod greater-eq? (x:Byte, y:Byte) -> True|False
   defmethod greater-eq? (x:Int, y:Int) -> True|False
   defmethod greater-eq? (x:Long, y:Long) -> True|False
   defmethod greater-eq? (x:Float, y:Float) -> True|False
   defmethod greater-eq? (x:Double, y:Double) -> True|False

                Hashable
                ========

Each of the numerical types are subtypes of Hashable, and hence
implements an appropriate method for the hash multi. They can hence be
used as keys for a HashTable.

   defmethod hash (x:Byte) -> Int
   defmethod hash (x:Int) -> Int
   defmethod hash (x:Long) -> Int
   defmethod hash (x:Float) -> Int
   defmethod hash (x:Double) -> Int

              Arithmetic
              ==========

Integer numerical types support the standard arithmetic operations.

   defn plus (x:Byte, y:Byte) -> Byte
   defn minus (x:Byte, y:Byte) -> Byte
   defn times (x:Byte, y:Byte) -> Byte
   defn divide (x:Byte, y:Byte) -> Byte
   defn modulo (x:Byte, y:Byte) -> Byte

   defn plus (x:Int, y:Int) -> Int
   defn minus (x:Int, y:Int) -> Int
   defn times (x:Int, y:Int) -> Int
   defn divide (x:Int, y:Int) -> Int
   defn modulo (x:Int, y:Int) -> Int

   defn plus (x:Long, y:Long) -> Long
   defn minus (x:Long, y:Long) -> Long
   defn times (x:Long, y:Long) -> Long
   defn divide (x:Long, y:Long) -> Long
   defn modulo (x:Long, y:Long) -> Long

Floating point numerical types support the all standard arithmetic
operations except the modulo operation.

   defn plus (x:Float, y:Float) -> Float
   defn minus (x:Float, y:Float) -> Float
   defn times (x:Float, y:Float) -> Float
   defn divide (x:Float, y:Float) -> Float

   defn plus (x:Double, y:Double) -> Double
   defn minus (x:Double, y:Double) -> Double
   defn times (x:Double, y:Double) -> Double
   defn divide (x:Double, y:Double) -> Double

Note that arithmetic operations must be performed on values of the
numerical type. Users must manually convert values from one type to
another if their types differ.

All numerical values except of type Byte support the additional
negation and absolute value operations. Byte values are unsigned and
hence do not support these operations.

   defn negate (x:Int) -> Int
   defn negate (x:Long) -> Long
   defn negate (x:Double) -> Double
   defn negate (x:Float) -> Float

   defn abs (x:Int) -> Int
   defn abs (x:Long) -> Long
   defn abs (x:Double) -> Double
   defn abs (x:Float) -> Float

           Bitwise Operations
           ==================

Integer numerical types support the standard bitwise operations.

   defn shift-left (x:Byte, y:Byte) -> Byte
   defn shift-right (x:Byte, y:Byte) -> Byte
   defn bit-or (x:Byte, y:Byte) -> Byte
   defn bit-and (x:Byte, y:Byte) -> Byte
   defn bit-xor (x:Byte, y:Byte) -> Byte
   defn bit-not (x:Byte) -> Byte
   
   defn shift-left (x:Int, y:Int) -> Int
   defn shift-right (x:Int, y:Int) -> Int
   defn arithmetic-shift-right (x:Int, y:Int) -> Int
   defn bit-or (x:Int, y:Int) -> Int
   defn bit-and (x:Int, y:Int) -> Int
   defn bit-xor (x:Int, y:Int) -> Int
   defn bit-not (x:Int) -> Int
   
   defn shift-left (x:Long, y:Long) -> Long
   defn shift-right (x:Long, y:Long) -> Long
   defn arithmetic-shift-right (x:Long, y:Long) -> Long
   defn bit-or (x:Long, y:Long) -> Long
   defn bit-and (x:Long, y:Long) -> Long
   defn bit-xor (x:Long, y:Long) -> Long
   defn bit-not (x:Long) -> Long

               Limits
               ======

The maximum and minimum values for values of type Byte, Int, Long are
defined in the following global values.

   val BYTE-MAX : Byte
   val BYTE-MIN : Byte
   val INT-MAX : Int
   val INT-MIN : Int
   val LONG-MAX : Long
   val LONG-MIN : Long


            Numerical Conversions
            =====================

Numerical types can be converted from one type to another using the
following functions.

   defn to-byte (b:Byte) -> Byte
   defn to-byte (i:Int) -> Byte
   defn to-byte (l:Long) -> Byte
   defn to-byte (f:Float) -> Byte
   defn to-byte (d:Double) -> Byte
   defn to-int (b:Byte) -> Int
   defn to-int (i:Int) -> Int
   defn to-int (l:Long) -> Int
   defn to-int (f:Float) -> Int
   defn to-int (d:Double) -> Int
   defn to-long (b:Byte) -> Long
   defn to-long (i:Int) -> Long
   defn to-long (l:Long) -> Long
   defn to-long (f:Float) -> Long
   defn to-long (d:Double) -> Long
   defn to-float (b:Byte) -> Float
   defn to-float (i:Int) -> Float
   defn to-float (l:Long) -> Float
   defn to-float (f:Float) -> Float
   defn to-float (d:Double) -> Float
   defn to-double (b:Byte) -> Double
   defn to-double (i:Int) -> Double
   defn to-double (l:Long) -> Double
   defn to-double (f:Float) -> Double
   defn to-double (d:Double) -> Double

Integer types can be converted without loss of precision from a type
with less bits to a type with more bits. When converting from a type
with more bits to a type with less bits, the most significant bits are
truncated.

When converting integer types to floating point types, the closest
floating point number is returned. 


           Numerical Reinterpretations
           ===========================

The following functions return an integer type whose bit
representation is equivalent to the IEEE754 bit representation of the
given floating point number.

   defn bits (x:Float) -> Int
   defn bits (x:Double) -> Long

The following functions return a floating point number whose IEEE754
bit representation is equivalent to the bit representation of the
given integer.

   defn bits-as-float (x:Int) -> Float
   defn bits-as-double (x:Long) -> Double

             Random Number Generation
             ========================

The following function generates a random positive integer.

   defn rand () -> Int

The following function generates a random positive integer that is
guaranteed to be strictly less than n.

   defn rand (n:Int) -> Int

The following function generates a random positive integer within the
range specified by r. r must have a step size of one. 

   defn rand (r:Range) -> Int

             Convenience Functions
             =====================

The following functions computes the ceiling of the base-2 logarithm of
the integer i.

   defn ceil-log2 (i:Int) -> Int
   defn ceil-log2 (i:Long) -> Int

The following functions computes the floor of the base-2 logarithm of
the integer i.

   defn floor-log2 (i:Int) -> Int
   defn floor-log2 (i:Long) -> Long

The following functions compute the smallest power of 2 that is
greater than or equal to the given integer i. i cannot be negative.

   defn next-pow2 (i:Int) -> Int
   defn next-pow2 (i:Long) -> Long

The following functions compute the largest power of 2 that is smaller
than or equal to the given integer i. i cannot be negative.

   defn prev-pow2 (i:Int) -> Int
   defn prev-pow2 (i:Long) -> Long

The following functions computes the sum of the given sequence of
numbers.

   defn sum (xs:Seqable<Int>) -> Int
   defn sum (xs:Seqable<Long>) -> Long
   defn sum (xs:Seqable<Float>) -> Float
   defn sum (xs:Seqable<Double>) -> Double

The following functions computes the product of the given sequence of
numbers.

   defn product (xs:Seqable<Int>) -> Int
   defn product (xs:Seqable<Long>) -> Long
   defn product (xs:Seqable<Float>) -> Float
   defn product (xs:Seqable<Double>) -> Double

============================================================
================= Boolean Types ============================
============================================================

Boolean values are represented using the types True and False.

   deftype True <: Equalable
   deftype False <: Equalable

                   Equality
                   ========

Both True and False are subtypes of Equalable and hence support the
equal? operation. Values of type True are only equal to other values
of type True. And values of type False are only equal to other values
of type False.

               Logical Complement
               ==================

The following function returns the logical complement of its
argument. If a is true, then it returns false, otherwise it returns
true.

   defn complement (a:True|False) -> True|False
   
============================================================
================= Character Type ===========================
============================================================
   
A Char represents a single byte ascii character.

   deftype Char <: Equalable & Hashable & Comparable<Char>

Char is defined to be a subtype of Equalable, Hashable, and
Comparable. Thus it supports the equality operator, implements an
appropriate method for the hash multi, and can be compared other
values of type Char.

                    Equality
                    ========

The equality operator can be used on two values of type Char.

   defmethod equal? (a:Char, b:Char) -> True|False

                   Comparable
                   ==========

Two values of types Char may be compared using the standard comparison
operations.

   defmethod compare (x:Char, y:Char) -> Int
   defmethod less? (x:Char, y:Char) -> True|False
   defmethod less-eq? (x:Char, y:Char) -> True|False
   defmethod greater? (x:Char, y:Char) -> True|False
   defmethod greater-eq? (x:Char, y:Char) -> True|False

Two values of type Char are compared according to the numerical value
of their ascii encoding.

                    Hashable
                    ========

Char is a subtype of Hashable, and implements an appropriate method
for the hash multi. Values of type Char can hence be used as keys for
a HashTable.

   defmethod hash (x:Char) -> Int

              Convenience Functions
              =====================

The digit? function checks whether a given character is a digit
character, representing one of the numerals between 0 and 9.

   defn digit? (c:Char) -> True|False

The letter? function checks whether a given character is either a
lower or upper-case character, representing one of the letters between
'A' and 'Z'.

   defn letter? (c:Char) -> True|False

============================================================
====================== Range ===============================
============================================================

A Range represents a span of integers between a starting index and an
optional ending index. 

   deftype Range <: Collection<Int> & Equalable  

                    Creation
                    ========

The following function creates a range with a given starting index,
and optional ending index, and step size, and a flag indicating
whether the ending index is inclusive or exclusive.

   defn Range (start:Int, end:Int|False, step:Int, inclusive?:True|False) -> Range

Users will typically use one of the macro forms for creating a
range. The following form creates a range with the starting index a,
exclusive ending index b, and step size 1.

   a to b 

The keyword by can be used to provide a custom step size.

   a to b by n

To create ranges with inclusive ending indices, use the keyword
through instead of to.

   a through b
   a through b by n

                    Getters
                    =======

The properties of a range can be retrieved using the following functions.

   defn start (r:Range) -> Int
   defn end (r:Range) -> Int|False
   defn step (r:Range) -> Int
   defn inclusive? (r:Range) -> True|False

                   Collection
                   ==========

Range is a subtype of Collection and implements an appropriate method
for the to-seq multi.

   defmethod to-seq (r:Range) -> Seq<Int>

A range is viewed as a sequence of numbers starting from its given
starting index, and proceeding until its ending index, in terms of the
given step size. If the ending index is inclusive, then the sequence
may contain the ending index. If the ending index is exclusive, then
the sequence will not contain the ending index. If no ending index is
given, then the sequence is infinite.

                    Equalable
                    =========

Range is a subtype of Equalable and two ranges are defined to be equal
if they have equivalent starting and ending indices, step sizes, and
inclusion flags.

                 Convenience Functions
                 =====================

The following function returns a list containing the result of
applying the function f to each integer within the given range. It is
a fatal error to call map on a range with infinite length.

   defn map<?R> (f: Int -> ?R, r:Range) -> List<R>

                  Dense Index Ranges
                  ==================

For many of the core library functions, ranges are used to specify
bounds within a Lengthable collection. For these ranges, the range
argument must be a "dense index range" with respect to the given
collection. A range is a "dense index range" with respect to a
collection if it satisfies the following restrictions:

- The step size of the range must be 1. 

- If the range is infinite, then the starting index must be non-negative
and less than or equal to the length of the collection.

- If the range is finite and inclusive, then the starting and ending
indices must be non-negative and less than the length of the
collection. The starting index must be less than or equal to the
ending index.

- If the range is finite and exclusive, then the starting and ending
indices must be non-negative and less than or equal to the length of
the collection. The starting index must be less than or equal to the
ending index.

============================================================
===================== Strings ==============================
============================================================

A String represents an immutable collection of values of type Char.

   deftype String <: Lengthable &
                     Collection<Char> &
                     Equalable &
                     Hashable &
                     Comparable<String>

                 Equality
                 ========

String is a subtype of Equalable and hence supports the equal?
operation. Two Strings are equal if they have the same length and all
of their characters are respectively equal.

   defmethod equal? (x:String, y:String) -> True|False

                Lengthable
                ==========

String is a subtype of Lengthable and hence supports the length
operation.

   defmethod length (x:String) -> Int

                Hashable
                ========

String is a subtype of Hashable, hence supports the hash operation and
can be used as keys in a HashTable.

   defmethod hash (x:String) -> Int

               Comparable
               ==========

String is a subtype of Comparable, and two values of type String can
be compared using the standard comparison operations.

   defmethod compare (x:String, y:String) -> Int
   defmethod less? (x:String, y:String) -> True|False
   defmethod less-eq? (x:String, y:String) -> True|False
   defmethod greater? (x:String, y:String) -> True|False
   defmethod greater-eq? (x:String, y:String) -> True|False

Strings are compared according to their lexicographic ordering.

                Collection
                ==========

String is a subtype of Collection, and hence supports the to-seq
operation to view the String as a sequence of Chars with known length.

   defmethod to-seq (x:String) -> Seq<Char> & Lengthable

              String Creation
              ===============

The following function creates a new String containing n copies of the
c character.

   defn String (n:Int, c:Char) -> String

The following function converts the given sequence of characters into
a String.

   defn String (cs:Seqable<Char>) -> String

            Retrieving Characters
            =====================

The following function allows for retrieval of individual characters
in a String by index. It is a fatal error to provide an index that is
negative or greater or equal to the length of the string.

   defn get (s:String, i:Int) -> Char

            Retrieving Substrings
            =====================

The following function allows for retrieval of a range of characters
in a String.

   defn get (s:String, r:Range) -> String

If the range is finite, then the substring between the starting index
and the ending index of the range is returned. If the range is
inclusive, then the starting and ending index must be positive and
less than the length of the string. If the range is exclusive, then
the starting and ending index must be positive and less than or equal
to the length of the string. Note that the starting index must always
be less than or equal to the ending index.

If the range is infinite, then the substring between the starting
index and the end of the string is returned. The starting index must
be positive and less than or equal to the length of the string.

The step size of the range must be one.

For example, assuming that s contains the string "Hello World", here
is what various calls to get will return.

   s[1 to 4] returns "ell"
   s[1 through 4] returns "ello"
   s[1 to false] returns "ello World"

               Parsing Numbers
               ===============

The following functions convert the string representations of numbers
to their numerical types.

   defn to-byte (s:String) -> False|Byte
   defn to-int (s:String) -> False|Int
   defn to-long (s:String) -> False|Long
   defn to-float (s:String) -> False|Float
   defn to-double (s:String) -> False|Double

Each of the above functions returns false if the given string cannot
be converted to the appropriate type, either because of an incorrectly
formatted string, or because the resulting number cannot be
represented using the appropriate number of bits.

             Conversion to String
             ====================

The following multi converts a given object to its string
representation.

   defmulti to-string (x) -> String

A default method defined in terms of print is provided to convert
arbitrary objects to their string representation. User defined types
are advised to rely upon this default method and *not* provide their
own method of to-string. To provide custom printing behaviour for a
type, users should provide methods for print instead.    


             String Interpolation
             ====================

The following function creates a printable object given a format
string and a sequence of arguments.

   defn modulo (format:String, args:Seqable) -> Printable

The characters in the format string are printed one by one, where
occurrences of a splicing operator prints the next item in the
sequence. The available splicing operators are:

   %_ : Prints the next item in the sequence.
   %* : Assumes the next item in the sequence is Seqable, and
        prints all elements in the item.
   %, : Assumes the next item in the sequence is Seqable, and
        prints all elements in the item separated by commas.
   %~ : Pretty prints the next item in the sequence using the write
        function.
   %@ : Assumes the next item in sequence is Seqable, and pretty
        prints all elements in the item separated by commas.
   %% : Prints the percentage sign character.

For example, the following command will print "On Tuesdays, Thursdays,
Wednesdays, Patrick goes for a walk.".

   val days = ["Tuesdays", "Thursdays", "Wednesdays"]
   val name = "Patrick"
   val activity = "walk"
   println("On %,, %_ goes for a %_." % [days, name, activity])

Note that the modulo function does *not* return a String. The
to-string function may be used to convert the printable object into a
string.

   val days = ["Tuesdays", "Thursdays", "Wednesdays"]
   val name = "Patrick"
   val activity = "walk"
   to-string("On %,, %_ goes for a %_." % [days, name, activity])

            Convenience Functions
            =====================

The following function returns true if the string b can be found at
position start in the string a, or false otherwise.

   defn matches? (a:String, start:Int, b:String) -> True|False

The following function returns true if the string a starts with the
given prefix, or false otherwise.

   defn prefix? (s:String, prefix:String) -> True|False

The following function returns true if the string a ends with the
given suffix, or false otherwise.

   defn suffix? (s:String, suffix:String) -> True|False

The following function returns true if the string contains no
characters.

   defn empty? (s:String) -> True|False

The following function returns a new string resulting from
concatenating string b to the end of string a.

   defn append (a:String, b:String) -> String

The following function returns a new string resulting from
concatenating together all strings in a sequence.

   defn append-all (xs:Seqable<String>) -> String

The following functions returns the string resulting from printing out
each item in the sequence xs. If the argument j is given, then each
item in the sequence is separated by j.

   defn string-join (xs:Seqable) -> String
   defn string-join (xs:Seqable, j) -> String

The following functions searches the string s, within the bounds
indicated the range r, for the first occurrence of the character c. If
c is found, then its index is returned, otherwise false is
returned. See the definition of get for Strings for possible settings
of the range. If a range is not given, then by default the function
searches through the entire String.

   defn index-of-char (s:String, r:Range, c:Char) -> False|Int
   defn index-of-char (s:String, c:Char) -> False|Int

The following functions searches the string s, within the bounds
indicated by the range r, for the first occurrence of the substring
b. If it is found, then its index is returned, otherwise false is
returned. See the definition of get for Strings for possible settings
of the range. If a range is not given, then by default the function
searches through the entire String.

   defn index-of-chars (a:String, r:Range, b:String) -> False|Int
   defn index-of-chars (a:String, b:String) -> False|Int

The following functions searches the string s, within the bounds
indicated the range r, for the last occurrence of the character c. If
c is found, then its index is returned, otherwise false is
returned. See the definition of get for Strings for possible settings
of the range. If a range is not given, then by default the function
searches through the entire String.

   defn last-index-of-char (s:String, r:Range, c:Char) -> False|Int
   defn last-index-of-char (s:String, c:Char) -> False|Int

The following functions searches the string s, within the bounds
indicated by the range r, for the last occurrence of the substring
b. If it is found, then its index is returned, otherwise false is
returned. See the definition of get for Strings for possible settings
of the range. If a range is not given, then by default the function
searches through the entire String.

   defn last-index-of-chars (a:String, r:Range, b:String) -> False|Int
   defn last-index-of-chars (a:String, b:String) -> False|Int

The following function returns the result of replacing every
occurrence of the character c1 in the string s with the character c2.

   defn replace (s:String, c1:Char, c2:Char) -> String

The following function returns the result of replacing every
occurrence of the substring s2 in the string str with the substring
s2.

   defn replace (str:String, s1:String, s2:String) -> String

The following functions returns a lazily computed sequence resulting
from splitting the string str at occurrences of the substring s. If
the argument n is given, then the resulting sequence is restricted to
contain at most n strings, where the last string contains the
unsplitted remainder of the str.

   defn split (str:String, s:String) -> Seq<String>   
   defn split (str:String, s:String, n:Int) -> Seq<String>

The following relation is guaranteed return true.

   string-join(split(str, s), s) == str

The following functions returns the result of converting all letters
contained within the string s to either lower-case or upper-case.

   defn lower-case (s:String) -> String
   defn upper-case (s:String) -> String

The following function returns the result of removing leading and
trailing whitespace characters from the string s.

   defn trim (s:String) -> String

============================================================
===================== Tuples ===============================
============================================================

A Tuple represents a finite and immutable series of items each with an
integer index.

   deftype Tuple<T> <: Lengthable &
                       Collection<T> &
                       Equalable &
                       Hashable &
                       Comparable<Tuple<T>>

                    Creation
                    ========

The following function creates a tuple of length n with each element
initialized to x.

   defn Tuple<?T> (n:Int, x:?T) -> Tuple<T>              

The following function converts a finite sequence of items into a
tuple. The function will not terminate if given an infinite sequence.

   defn to-tuple<?T> (xs:Seqable<?T>) -> Tuple<T>

                   Equality
                   ========

Tuple is a subtype of Equalable and two tuples are defined to be equal
if they have the same length and all of their components are equal. It
is an error to check whether two tuples are equal if they contain
elements that are not Equalable.

                   Lengthable
                   ==========

The length of a tuple can be queried by calling the length multi.

   defmethod length (x:Tuple) -> Int

                 Retrieving Elements
                 ===================

The following function will return the item at index i within the
tuple x. i must be within the bounds of the range.

   defn get<?T> (x:Tuple<?T>, i:Int) -> T

The following function will return a new Tuple containing the items
spanned by the given range. The range must be a dense index range. 

   defn get<?T> (xs:Tuple<?T>, r:Range) -> Tuple<T>

                  Collection
                  ==========

Tuple is a subtype of Collection and implements an appropriate method
for the to-seq multi to access the elements of the tuple as a
sequence.

   defmethod to-seq<?T> (t:Tuple<?T>) -> Seq<T>

                  Hashable
                  ========

Tuple is a subtype of Hashable and computes its hash by combining the
hashes of all of its items. It is a fatal error to call hash on a
tuple containing items that are not Hashable.

   defmethod hash (t:Tuple<Hashable>) -> Int

                 Comparable
                 ==========

Tuple is a subtype of Comparable and implements an appropriate method
for the compare multi that compares two tuples by their lexicographic
order. It is a fatal error to compare two tuples containing elements
that are not Comparable with each other.

   defmethod compare (a:Tuple<Comparable>, b:Tuple<Comparable>) -> Int

             Convenience Functions
             =====================

The following function returns a new tuple containing the result of
calling the function f on each item in the tuple xs.

   defn map<?T,?R> (f:T -> ?R, xs:Tuple<?T>) -> Tuple<R>

The following function returns true if the tuple t is empty, otherwise
it returns false.

   defn empty? (t:Tuple) -> True|False


============================================================
====================== Lists ===============================
============================================================

A List represents an immutable linked list of items.

   deftype List<T> <: Lengthable &
                      Collection<T> &
                      Equalable &
                      Hashable &
                      Comparable<List<T>>   

                 Fundamental Operations
                 ======================

A List supports two fundamental operations, accessors for retrieving
the head and the tail of the list.

   defmulti head<?T> (x:List<?T>) -> T
   defmulti tail<?T> (x:List<?T>) -> List<T>

A List has two immediate subtypes, FullList and NilList, representing
respectively a list with a head and some tail, and the empty list. It
is a fatal error to call head or tail on a NilList.

   deftype FullList<T> <: List<T>
   deftype NilList <: List<Void>

                     Creation
                     ========

The following functions create lists with no, one, two, three, or four
elements respectively. The to-list function can be used to create
lists with more than four elements.

   defn List () -> NilList
   defn List<?T> (x:?T) -> FullList<T>
   defn List<?T> (x:?T, y:?T) -> FullList<T>
   defn List<?T> (x:?T, y:?T, z:?T) -> FullList<T>
   defn List<?T> (w:?T, x:?T, y:?T, z:?T) -> FullList<T>

The following function creates new lists by appending one, two, or
three elements to the head of an existing list. The append function
can be used to append more than three elements to a list.

   defn cons<?T> (x:?T, t:List<?T>) -> FullList<T>
   defn cons<?T> (x:?T, y:?T, t:List<?T>) -> FullList<T>
   defn cons<?T> (x:?T, y:?T, z:?T, t:List<?T>) -> FullList<T>

The following function creates a new list containing the items in the
sequence xs. The function will not terminate if given an infinite
sequence.

   defn to-list<?T> (xs:Seqable<?T>) -> List<T>
                     
                     Lengthable
                     ==========

List is a subtype of Lengthable and implements an appropriate method
for the length multi. Note that the length of a list is not cached,
and computing the length of a list takes time proportional to the
length of the list.

   defmethod length (x:List) -> Int

                     Collection
                     ==========

List is a subtype of Collection and implements an appropriate method
for the to-seq multi that allows for the list to be viewed as a
sequence.

   defmethod to-seq<?T> (x:List<?T>) -> Seq<T>
                     
                     Equalable
                     =========

List is a subtype of Equalable and two lists are defined to be equal
if they have the same length and all of their components are equal. It
is a fatal error to check whether two lists are equal if they contain
elements that are not Equalable.

   defmethod equal? (a:List<Equalable>, b:List<Equalable>) -> True|False
                     
                     Hashable
                     ========

List is a subtype of Hashable and implements an appropriate method for
the hash multi. The hash is computed by combining the hashes of all
the items in the list. It is a fatal error to call hash on a list
containing elements that are not Hashable.

   defmethod hash (a:List<Hashable>) -> Int

                     Comparable
                     ==========

List is a subtype of Comparable and implements an appropriate method
for the compare multi. Two lists are compared according to their
lexicographic ordering. If is a fatal error to compare two lists that
contain elements that are not Comparable to each other.

   defmethod compare (a:List<Comparable>, b:List<Comparable>) -> True|False
                     
                 Convenience Functions
                 =====================

The following function returns true if the given list is empty
(i.e. is a NilList) or false otherwise.

   defn empty? (x:List) -> True|False

The following function returns the i'th element in the list xs. i must
be less than the length of xs.

   defn get<?T> (xs:List<?T>, i:Int) -> T

The following function returns a list containing the n first elements
in the list l. n must be less than or equal to the length of the list.

   defn headn<?T> (l:List<?T>, n:Int) -> List<T>

The following function returns the list after removing the first n
elements from the head of the list l. n must be less than or equal to
the length of the list.

   defn tailn<?T> (l:List<?T>, n:Int) -> List<T>

The following function returns a new list containing the items in xs
in reversed order.

   defn reverse<?T> (xs:List<?T>) -> List<T>

The following function returns a sequence containing the items in the
list in reverse order.

   defn in-reverse<?T> (xs:List<?T>) -> Seq<T>

The following function returns the last element in the list. The list
must not be empty.

   defn last<?T> (xs:List<?T>) -> T

The following function returns a list containing all elements in xs
except the last. xs must not be empty.

   defn but-last<?T> (xs:List<?T>) -> List<T>

The following function returns the list resulting from appending all
items from xs to the beginning of the list ys.

   defn append<?T> (xs:Seqable<?T>, ys:List<?T>) -> List<T>

The following function returns the list resulting from appending
together all lists in the sequence xs.

   defn append-all<?T> (xs:Seqable<List<?T>>) -> List<T>

The following function returns a transposed version of the input list
xs. The first element in the result list is a list containing the
first elements in each list within xs. The second element in the
result list is a list containing the second elements in each list
within xs. The third element in the result list is a list containing
the third elements in each list within xs, et cetera. The result list
has the same length as the shortest list within xs.

   defn transpose<?T> (xs:List<List<?T>>) -> List<List<T>>

The following function returns a new list consisting of the results of
applying the function f to each element in the input list xs.

   defn map<?T,?R> (f: T -> ?R, xs:List<?T>) -> List<R>

The following functions returns a new list consisting of the results of
applying the function f to each pair (or triplet) of elements in the
given input lists (or sequences). The result list has the same length
as the shortest input list or sequence.

   defn map<?T,?S,?R> (f: (T,S) -> ?R, xs:List<?T>, ys:Seqable<?S>) -> List<R>
   defn map<?T,?S,?U,?R> (f: (T,S,U) -> ?R, xs:List<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R>

The following function returns a new list by calling the function f on
every item in the sequence xs, and then appending together all of the
resultant lists.

   defn seq-append<?T,?R> (f: T -> List<?R>, xs:Seqable<?T>) -> List<R>

The following functions returns a new list by calling the function f
on each pair (or triplet) of items in the input sequences, and then
appending together all of the resultant lists.

   defn seq-append<?T,?S,?R> (f: (T,S) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> List<R>
   defn seq-append<?T,?S,?U,?R> (f: (T,S,U) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R>

============================================================
===================== FileInfo =============================
============================================================

A FileInfo object contains position information about a specific point
in a text file.

   deftype FileInfo <: Equalable &
                       Hashable &
                       Comparable<FileInfo>

                  Accessors
                  =========

The following functions are used to retrieve a FileInfo's filename,
line, and column information.

   defn filename (i:FileInfo) -> String
   defn line (i:FileInfo) -> Int
   defn column (i:FileInfo) -> Int

                  Creation
                  ========

The following function creates a FileInfo from the given filename,
line, and column information.

   defn FileInfo (f:String, l:Int, c:Int) -> FileInfo

                  Equalable
                  =========

FileInfo is a subtype of Equalable and two FileInfo objects are equal
when their filenames, lines, and columns are equal.

   defmethod equal? (a:FileInfo, b:FileInfo) -> True|False

                  Hashable
                  ========

FileInfo is a subtype of Hashable and implements an appropriate method
for the hash multi by combining the hashes of its filename, line, and
column information.

   defmethod hash (i:FileInfo) -> Int

                  Comparable
                  ==========

FileInfo is a subtype of Comparable and implements an appropriate
method for the compare multi. Two FileInfo objects are compared by
ordering their filenames, followed their line index, followed by their
column index.

============================================================
======================= Token ==============================
============================================================

A Token represents a value that has been associated with a FileInfo
object indicating the position it originated from in a text file.

   deftype Token <: Equalable
   
                      Accessors
                      =========

The following functions are used to access a Token's wrapped value and
its associated FileInfo object.

   defn item (t:Token) -> ?
   defn info (t:Token) -> FileInfo

                      Creation
                      ========

The following function creates a Token from the given value and its
associated FileInfo object.

   defn Token (item, info:FileInfo) -> Token

                      Equalable
                      =========

A Token is a subtype of Equalable and two tokens are considered equal
if its FileInfo object is equal and the wrapped values are equal. It
is a fatal error to check whether two Tokens are equal if their
wrapped values are not Equalable.

   defmethod equal? (a:Token, b:Token) -> True|False

                Convenience Functions
                =====================

The following function returns the possibly wrapped value in a token
by recursively unwrapping the value if it is a token.

   defn unwrap-token (t) -> ?

The following function recursively calls unwrap-token in all tokens
and lists in the given value. This function is commonly used to strip
away all file information from an s-expression.

   defn unwrap-all (t) -> ?


============================================================
==================== KeyValue Pairs ========================
============================================================

A KeyValue pair represents a pairing of a key object with a value
object. It is typically used to represent entries in datastructures
where values are looked up according to a given key.

   deftype KeyValue<K,V> 

                       Accessors
                       =========

The following functions are used to retrieve the key and the value
from a KeyValue object.

   defn key<?K> (kv:KeyValue<?K,?>) -> K
   defn value<?V> (kv:KeyValue<?,?V>) -> V

                       Creation
                       ========

The following function creates a KeyValue pair from the given key and
value objects.

   defn KeyValue<?K,?V> (k:?K, v:?V) -> KeyValue<K,V>

Typically, users will use the following macro form for creating
KeyValue pairs.

   k => v

============================================================
====================== Symbols =============================
============================================================

Symbols are used to represent identifiers in s-expressions, and can be
compared against each other efficiently and used as keys in
hashtables.

   deftype Symbol <: Equalable & Hashable

Symbols are divided into two categories: symbols created from strings,
and uniquely generated symbols.                      

                     Construction
                     ============

The following function constructs a symbol from the given value by
converting it to a string using to-string and then creating a symbol
from the resulting string. If x is already a symbol then it is
returned directly.

   defn to-symbol (x) -> Symbol

The following function constructs a symbol from the given sequence by
converting it to a string using string-join and then creating a symbol
from the resulting string.

   defn symbol-join (xs:Seqable) -> Symbol

The following function generates a unique symbol given an object x
whose string representation is used as the name. The resulting symbol
is guaranteed to be equal to no other symbol currently live in the
program.

   defn gensym (x) -> Symbol

If no object x is provided, then the default prefix is the string
"$gen".

   defn gensym () -> Symbol

                     Accessors
                     =========

The following function can be used to retrieve the string that the
symbol was constructed with.

   defn prefix (x:Symbol) -> String

                   Qualified Symbols
                   =================

A qualified symbol is a symbol created from a string containing a '/'
character. In Stanza, qualified symbols are used to indicate a package
qualified identifier. The following function returns true if the given
symbols is a qualified symbol, or false otherwise.

   defn qualified? (a:Symbol) -> True|False
   
The following function splits a qualified symbol into a 2 element
tuple containing its qualifier and its unqualified name. If the
argument is not a qualified symbol, then the qualifier is false.

   defn qualifier (a:Symbol) -> [False|Symbol, Symbol]

                      Equality
                      ========

Symbols are a subtype of Equalable and two symbols can be efficiently
compared to see whether they are equal. Two symbols created from
strings are equal if the strings they are created from are equal. Two
uniquely generated symbols are equal if and only if they were created
by the same call to gensym.

   defmethod equal? (a:Symbol, b:Symbol) -> True|False

                      Hashable
                      ========

Symbols are a subtype of Hashable and implements an appropriate method
for the hash multi. For symbols constructed from strings, the hash is
computed from its name. For generated symbols, the hash is computed
from its id.

   defmethod hash (a:Symbol) -> Int

                  String Representation
                  =====================

Note that two unique symbols that are not equal to each other, may
still have equivalent string representations. For example, a generated
symbol with the name "x" and the id 253 has the same string
representation as the symbol created from the string "x253".

============================================================
===================== Exceptions ===========================
============================================================

An Exception object is used to represent the conditions under which an
exceptional behaviour as occurred.

   deftype Exception  

                  Creating Exceptions
                  ===================

Users are encouraged to create their own subtypes of Exception to
represent different types of exceptional behaviour. However, the
following function may be used to create a generic Exception object
with the given error message.

   defn Exception (msg) -> Exception

                  Throwing Exceptions
                  ===================

The following function throws the given exception object to the
current exception handler.

   defn throw (e:Exception) -> Void

                 Catching Exceptions
                 ===================

The following function runs the body function after installing the
handler function as the current exception handler. If the body runs
without throwing an exception, then its result is returned. Otherwise
the result of the exception handler is returned.

   defn with-exception-handler<?T> (body: () -> ?T, handler: Exception -> ?T) -> T

                   Finalization
                   ============

The following function runs the body function ensuring that the given
finally function is run immediately afterwards. If the body runs to
completion, then its result is returned after running the finally
function. Otherwise, the finally function is run before execution
exits the scope. Note that once the body function has started,
execution is not allowed to exit and then re-enter the scope.

   defn with-finally<?T> (body: () -> ?T, finally: (True|False) -> ?) -> T

                    Macro Forms
                    ===========

Users will not typically call with-exception-handler or with-finally
directly and instead use the standard macro forms. The following form
runs the given body with a handler for catching MyExceptions. The code
within the optional finally block is ensured to run whether or not the
body runs to completion.

   try :
      body code
   catch (e:MyException) :
      exception handling code
   finally :
      finalization code

============================================================
===================== Fatal Errors =========================
============================================================

A fatal error occurs when a program somehow enters a state that
indicates there is an error in the program. The following function
will print out the given error message to the screen, display a stack
trace allowing users to find the source of the error, and immediately
terminate the program.

   defn fatal (msg) -> Void

It is impossible for a program to recover from a fatal error. Thus
fatal errors do not occur in correct programs.

This point is important as on the highest (and unsafe) optimization
settings, Stanza assumes that your program is correct and hence no
calls to fatal ever occurs. For example, on the highest optimization
settings, the following code:

   if n < 0 :
      fatal("n should not be negative")
   else :
      f()

is allowed to be optimized to the following:

   f()

as Stanza assumes that your program is correct, and therefore it is
impossible for execution to enter the consequent branch of the if
expression.

============================================================
================= Attempt and Failure ======================
============================================================

The attempt and failure functions provide a convenient non-local exit
for users. The fail function exits from the current attempt scope and
calls the current failure handler.

   defn fail () -> Void

The following function calls the conseq function after installing the
alt function as the current failure handler. If the conseq function
runs to completion then its result is returned. Otherwise, if fail is
called during execution of conseq, the alt function is called and its
result is returned.

   defn with-attempt<?T> (conseq: () -> ?T, alt: () -> ?T) -> T

                    Macro Forms
                    ===========

Users will not typically call with-attempt directly and instead use
the standard macro forms. The following form runs the given body with
a failure handler that executes when fail is called.

   attempt :
      body code
   else :
      failure code

If no else branch is provided, then a default else branch is provided
that simply returns false.

============================================================
===================== Equalable ============================
============================================================

Values that support the equal? operation are indicated as subtypes of
Equalable.

   deftype Equalable

The multi equal? takes as argument two Equalable values and returns
true if they are equal or false otherwise.

   defmulti equal? (a:Equalable, b:Equalable) -> True|False

A default method for equal? is provided that simply returns false.

Equality in Stanza is defined to be invariant to substitution. That
is, suppose that our program contains a call to a function, f, with a
value x.

   f(x)

But earlier, we have determined that

   x == y

returns true, indicating that x is equal to y. Then we should we able
to substitute the usage of x with y instead without changing the
behaviour of the program.

   f(y)

Consistent to this definition, in Stanza's core library, values of
immutable types are defined to be equal if their subfields are
equal. Different mutable values, such as Arrays, are never defined to
be equal unless they refer to the same object.

                 Convenience Functions
                 =====================

The following function returns true if its two arguments are not equal
and false otherwise.

   defn not-equal? (a:Equalable, b:Equalable) -> True|False

============================================================
==================== Comparable ============================
============================================================

The Comparable type is used to indicate that a value can compared
against other values using the comparison operations. A value of type
Comparable<T> can be compared against values of type T.

   deftype Comparable<T>

             Fundamental Comparison Operation
             ================================

The following multi compares values of type Comparable<T> against
values of type T. All subtypes of Comparable must implement an
appropriate method for this multi. The multi returns a negative
integer if the item a is less than the item b, zero if the two are
equal, and a positive integer if the item a is greater than the item
b. For values that are subtypes of both Equalable and Comparable, the
compare operation must be consistently defined against the equal?
operation, and return 0 if equal? returns true.

   defmulti compare<?T> (a:Comparable<?T>, b:T) -> Int

              Derived Comparison Operations
              =============================

The following multis are provided for subtypes to provide efficient
implementations. Any defined method must return results consistent
with the compare operation. Default methods are provided for these
multis that are defined in terms of the compare operation.

   defmulti less?<?T> (a:Comparable<?T>, b:T) -> True|False
   defmulti greater?<?T> (a:Comparable<?T>, b:T) -> True|False
   defmulti less-eq?<?T> (a:Comparable<?T>, b:T) -> True|False
   defmulti greater-eq?<?T> (a:Comparable<?T>, b:T) -> True|False

                Convenience Functions
                =====================

The following functions compute the maximum or minimum of their two
given arguments.

   defn max<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T
   defn min<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T

The following functions compute the minimum between an initial value
x0, and a sequence of items xs using the provided comparison
function. If no initial value is provided, then the sequence xs cannot
be empty.

   defn minimum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T
   defn minimum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T

The following functions compute the maximum between an initial value
x0, and a sequence of items xs using the provided comparison
function. If no initial value is provided, then the sequence xs cannot
be empty.

   defn maximum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T
   defn maximum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T

The following functions compute the minimum between an initial value
x0, and a sequence of comparable items xs using the less? multi. If no
initial value is provided, then the sequence xs cannot be empty.

   defn minimum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T
   defn minimum<?T> (xs:Seqable<?T&Comparable>) -> T

The following functions compute the maximum between an initial value
x0, and a sequence of comparable items xs using the less? multi. If no
initial value is provided, then the sequence xs cannot be empty.

   defn maximum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T
   defn maximum<?T> (xs:Seqable<?T&Comparable>) -> T

The following function returns the minimum in a sequence of items xs
by comparing the keys extracted from each item using the provided key
function.

   defn minimum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T

The following function returns the maximum in a sequence of items xs
by comparing the keys extracted from each item using the provided key
function.

   defn maximum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T

============================================================
==================== Hashable ==============================
============================================================

The type Hashable indicates that a value supports the hash multi and
can represented (non-uniquely) as an Int value.

   deftype Hashable

The hash multi takes a Hashable argument and returns an Int. For the
correct operation of HashTable implementations, the definition of hash
must be consistent with the definition of equal?. If two values are
equal, then they must also return the same hash.

   defmulti hash (h:Hashable) -> Int

============================================================
===================== Seq ==================================
============================================================

A Seq represents a possibly finite sequence of items.

   deftype Seq<T> <: Seqable<T>

A Seq supports the following fundamental operations.

   defmulti empty? (s:Seq) -> True|False
   defmulti next<?T> (s:Seq<?T>) -> T
   defmulti peek<?T> (s:Seq<?T>) -> T

The empty? multi returns true if the sequence contains more items, or
false otherwise.

The next multi returns the next item in the sequence. Repeated calls
to next results in successive items in the sequence to be returned. It
is a fatal error to call next on an empty sequence.

The peek multi inspects the next item in the sequence but does not
consume it. Repeated calls to peek results in the same item begin
returned. It is a fatal error to call peek on an empty sequence.

============================================================
=================== Seqable ================================
============================================================

A Seqable represents any value that may be viewed as a sequence of
items. It supports the fundamental operation

   defmulti to-seq<?T> (s:Seqable<?T>) -> Seq<T>

to return a Seq that represents a sequential view of its given
argument.

A value of type Seq is defined to also be a Seqable and trivially
returns itself when called with to-seq.

============================================================
=================== Collection =============================
============================================================

A Collection is defined to be a subtype of Seqable and thus must also
support the to-seq operation. The crucial difference between a
Collection and Seqable is that a Collection must be *repeatedly*
viewable as a sequence of items.

As an example, consider a function, print-all-twice, that iterates
through and prints out the items in a sequence twice.

   defn print-all-twice (xs:Seqable) -> False :
      val seq1 = to-seq(xs)
      while not empty?(seq1) :
         println(next(seq1))

      val seq2 = to-seq(xs)
      while not empty?(seq2) :
         println(next(seq2))

Such a function would not work as expected when called with a
Seq. Recall that calling to-seq on a Seq is a trivial operation that
returns the Seq directly. Thus the first while loop will print out
every item in the sequence, but the second while loop will not
complete a single iteration as the sequence is already empty. The
correct type signature for print-all-twice would be

   defn print-all-twice (xs:Collection) -> False

Seq is a subtype of Seqable, but Seq is not a subtype of
Collection. Thus the new type signature correctly disallows
print-all-twice from being called with Seqs.

============================================================
================= Sequence Library =========================
============================================================

The core package contains a large number of convenience functions that
operate on sequences. The majority of collection datastructures in
Stanza's core library are subtypes of Seqable and thus can be used
with this sequence library.

                 Operating Functions
                 ===================

Operating functions, such as do, seq, and find, are functions with
type signatures compatible with the for macro form. The following
macro form:

   for x in xs do :
      body code

is equivalent to the following direct call to the do operating
function:

   do(fn (x) :
         body code
      xs)

Multi-argument operating functions are used with the following macro
form.

   for (x in xs, y in ys, z in zs) do :
      body code

is equivalent to the following direct call to the do operating
function:

   do(fn (x, y, z) :
         body code
      xs, ys, zs)   

As a matter of style, if the body consists of more than a single
function call then the macro form is used, as in the following
example:

   val x = 671
   val prime? = for i in 2 to x none? :
      x % i == 0

If the body consists of a single function call then the standard
function call form is used instead.

   val x = 671
   defn divides-x? (i:Int) : x % i == 0
   val prime? = none?(divides-x?, 2 to x)

The above example can also be written using anonymous function
notation as follows:

   val x = 671
   val prime? = none?({x % _ == 0}, 2 to x)

              The Do Operating Function
              =========================

The following multi calls the function f on each item in the
sequence xs. A default method defined in terms of the fundamental
sequence operations is provided, but users may provide customized
methods for subtypes of Seqable for efficiency.

   defmulti do<?T> (f:T -> ?, xs:Seqable<?T>) -> False

The following multis operate similarly to the single collection
version of do but instead calls the function f with successive items
from multiple sequences. The sequences are stepped through in parallel
and iteration stops as soon as one of them is empty.

   defmulti do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False
   defmulti do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False

            The Find Operating Function
            ===========================

The following function iterates through the sequence xs and calls the
function f on each item, searching for the first item for which f
returns true. If f returns true on some item, then that item is
returned by find. If f does not return true on any item in the
sequence, then find returns false.

   defn find<?T> (f: T -> True|False, xs:Seqable<?T>) -> T|False

The following function iterates through the sequence xs and ys in
parallel and calls the function f with an item from each
sequence. Iteration stops as soon as either sequence is empty. If f
returns true when called by an item, x, from xs and an item, y, from
ys, then x is returned by find.

   defn find<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> T|False

The following functions behaves identically to find except that it
assumes that their exists an item (or pair of items) for which f
returns true.

   defn find!<?T> (f: T -> True|False, xs:Seqable<?T>) -> T
   defn find!<?T, ?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> T

          The First Operating Function
          ============================

The following function iterates through the sequence xs and calls the
function f on each item, searching for the first item for which f
returns a One object. If f returns a One object on some item, then the
One object is returned. If f returns a None object for all items in
the sequence, then a None object is returned by first.

   defn first<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Maybe<R>

The following function iterates through the sequence xs and ys in
parallel and calls the function f repeatedly with an item from each
sequence. Iteration stops as soon as either sequence is empty. If f
returns a One object on some pair of items, then the One object is
returned. If f returns a None object for all items in the sequences,
then a None object is returned by first.

   defn first<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Maybe<R>

The following functions behave identically to first except that it
assumes that their exists an item (or pair of items) for which f
returns a One object. The wrapped value within the One object is
returned.

   defn first!<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> R
   defn first!<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> R

           The Seq Operating Function
           ==========================

The following function constructs the sequence resulting from calling
the function f on each item in the sequence xs.

   defn seq<?T,?S> (f:T -> ?S, xs:Seqable<?T>) -> Seq<S>

The following multis operate similarly to the single collection
version of seq but instead calls the function f with successive items
from multiple sequences. The sequences are stepped through in parallel
and iteration stops as soon as one of them is empty.

   defn seq<?T,?S,?R> (f:(T,S) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R>
   defn seq<?T,?S,?U,?R> (f:(T,S,U) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R>

          The Seq? Operating Function
          ===========================

The following function constructs a sequence by calling the function f
on each item in the sequence xs. For each item in xs, if f returns a
One object, then the unwrapped value is included in the result
sequence. If f returns a None object then the item is not included in
the result sequence.

   defn seq?<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Seq<R>

The following functions constructs a sequence by iterating through the
given sequences in parallel and calling the function f repeatedly with
an item from each sequence. For each pair (or triplet) of items, if f
returns a One object, then the unwrapped value is included in the
result sequence. If f returns a None object then the item is not
included in the result sequence.

   defn seq?<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R>
   defn seq?<?T,?S,?U,?R> (f: (T,S,U) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R>

          The Filter Operating Function
          =============================

The following function constructs a sequence by calling the function f
on each item in the sequence xs, and including the item in the result
sequence only if the call to f returns true.

   defn filter<?T> (f: T -> True|False, xs:Seqable<?T>) -> Seq<T>

The following function constructs a sequence by iterating through the
xs and ys sequences in parallel and calling the function f repeatedly
with an item from each sequence. For each pair of items, if f returns
true, then the item from the xs sequence is included in the result
sequence.

   defn filter<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<T>

           The Index-When Operating Function
           =================================

The following function iterates through the items in the xs sequence,
calling f on each one, and returns the first index at which the call
to f returns true. If no call to f returns true, then index-when
returns false.

   defn index-when<?T> (f: T -> True|False, xs:Seqable<?T>) -> Int|False

The following function iterates through the xs and ys sequences in
parallel, calling f on each pair of items from xs and ys, and returns
the first index at which the call to f returns true. If no call to f
returns true, then index-when returns false.

   defn index-when<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Int|False

The following functions behaves identically to index-when except that
it assumes there exists an item (or pair of items) for which the call
to f returns true.

   defn index-when!<?T> (f: T -> True|False, xs:Seqable<?T>) -> Int
   defn index-when!<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Int

           The Split Operating Function
           ============================

The following function iterates through the items in the xs sequence,
separating them into two collections depending on whether calling f on
the item returns true or false. The function returns a tuple of two
collections, the first of which contains all items in the sequence for
which f returned true, and the second of which contains all items for
which f returned false.

   defn split<?T> (f: T -> True|False, xs: Seqable<?T>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable]

          The Take-While Operating Function
          =================================

The following function constructs a sequence by taking items
successively from the xs sequence as long as calling f upon the item
returns true. The resulting sequence ends as soon as xs is empty or f
returns false. The item for which f returns false is not included in
the resulting sequence.

   defn take-while<?T> (f: T -> True|False, xs:Seqable<?T>) -> Seq<T>

           The Take-Until Operating Function
           =================================

The following function constructs a sequence by taking items
successively from the xs sequence as long as calling f upon the item
returns false. The resulting sequence ends as soon as xs is empty or f
returns true. The item for which f returns true is included in the
resulting sequence.

   defn take-until<?T> (f: T -> True|False, xs:Seqable<?T>) -> Seq<T>

           The Seq-Cat Operating Function
           ==============================

The following function constructs a sequence by calling f upon each
item on the xs sequence. seq-cat then returns the concatenation of all
sequences returned by f.

   defn seq-cat<?T,?R> (f:T -> Seqable<?R>, xs:Seqable<?T>) -> Seq<R>

The following functions constructs a sequence by iterating through the
given sequences in parallel and calling f upon each pair (or triplet)
of items from each sequence. seq-cat then returns the concatenation of
all sequences returned by f.

   defn seq-cat<?T,?S,?R> (f:(T,S) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R>
   defn seq-cat<?T,?S,?U,?R> (f:(T,S,U) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R>

           The All? Operating Function
           ===========================

The following function iterates through the items in the sequence xs
and calls pred? on each one. If pred? returns true for every item in
the sequence all?  returns true. If pred? returns false for any item,
then all?  immediately returns false.

   defn all?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False

The following functions iterates through the given sequences in
parallel and calls pred? on each pair (or triplet) of items from each
sequence. Iteration stops as soon as any sequence is empty. all?
returns true if all calls to pred? returns true. all? returns false
immediately after a call to pred? returns false.

   defn all?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False
   defn all?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False

         The None? Operating Function
         ============================

The following function iterates through the items in the sequence xs
and calls pred? on each one. If pred? returns true for no item in the
sequence then none?  returns true. If pred? returns true for any item,
then none?  immediately returns false.

   defn none?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False

The following functions iterates through the given sequences in
parallel and calls pred? on each pair (or triplet) of items from each
sequence. Iteration stops as soon as any sequence is empty. none?
returns true if no calls to pred? returns true. none? returns false
immediately after a call to pred? returns true.

   defn none?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False
   defn none?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False


         The Any? Operating Function
         ===========================

The following function iterates through the items in the sequence xs
and calls pred? on each one. If pred? returns true for no item in the
sequence then any?  returns false. If pred? returns true for any item,
then any?  immediately returns true.

   defn any?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False

The following functions iterates through the given sequences in
parallel and calls pred? on each pair (or triplet) of items from each
sequence. Iteration stops as soon as any sequence is empty. any?
returns false if no calls to pred? returns true. any? returns true
immediately after a call to pred? returns true.

   defn any?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False
   defn any?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False

        The Count Operating Function
        ============================

The following function iterates through the items in the sequence xs
and calls pred? on each one. count returns the number of times that
pred? returned true.

   defn count<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> Int


              Sequence Constructors
              =====================

The following function creates an infinite sequence resulting from
repeating x indefinitely.

   defn repeat<?T> (x:?T) -> Seq<T>

The following function creates a sequence resulting from repeating x
for n number of times.

   defn repeat<?T> (x:?T, n:Int) -> Seq<T> & Lengthable

The following function creates an infinite sequence from the results
of calling f repeatedly.

   defn repeatedly<?T> (f:() -> ?T) -> Seq<T>

The following function creates a sequence resulting from the results
of calling f n number of times.

   defn repeatedly<?T> (f:() -> ?T, n:Int) -> Seq<T> & Lengthable

The following function creates a sequence resulting from calling f
repeatedly and including, in the result sequence, the unwrapped values
of every One object returned by f. The sequence ends as soon as f
returns a None object.

   defn repeat-while<?T> (f: () -> Maybe<?T>) -> Seq<T>


              Sequence Operators
              ==================

The following function constructs a sequence by iterating through the
xs and sel sequences in parallel and including items from the xs
sequence in the result sequence only if the corresponding item from
the sel sequence is true.

   defn filter<?T> (xs:Seqable<?T>, sel:Seqable<True|False>) -> Seq<T>

The following function constructs a sequence by taking the first n
items from the xs sequence. The xs sequence must contain at least n
items.

   defn take-n<?T> (n:Int, xs:Seqable<?T>) -> Seq<T>

The following function constructs a new sequence by concatenating the
a sequence with the b sequence.

   defn cat<?T> (a:Seqable<?T>, b:Seqable<?T>) -> Seq<T>

The following function constructs a new sequence by concatenating
together all sequences in the xss sequence.

   defn cat-all<?T> (xss: Seqable<Seqable<?T>>) -> Seq<T>

The following function constructs a new sequence by including the item
y in between each item in xs.

   defn join<?T,?S> (xs:Seqable<?T>, y:?S) -> Seq<T|S>
   
The following function constructs a new sequence by iterating through
the sequences xs and ys in parallel and including the 2 element tuples
formed from the items of each sequence. Iteration stops as soon as
either sequence is empty.

   defn zip<?T,?S> (xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<[T,S]>

The following function constructs a new sequence by iterating through
the sequences xs, ys, and zs, in parallel and including the 3 element
tuples formed from the items of each sequence. Iteration stops as soon
as either sequence is empty.

   defn zip<?T,?S,?U> (xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<[T,S,U]>

The following function constructs a new sequence by iterating through
all sequences in xss in parallel, and including the tuples formed from
the items of each sequence. Iteration stops as soon as any sequence is
empty.

   defn zip-all<?T> (xss:Seqable<Seqable<?T>>) -> Seq<Tuple<T>>

              Sequence Reducers
              =================

The following function returns true if the xs sequence contains the
item y; otherwise it returns false.

   defn contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False

The following function returns the first index at which the item in
the xs sequence is equal to the item y. If no item in xs is equal to y
then index-of returns false.

   defn index-of (xs:Seqable<Equalable>, y:Equalable) -> Int|False

The following function behaves identically to index-of except that it
assumes there exists an item in xs that is equal to y.

   defn index-of! (xs:Seqable<Equalable>, y:Equalable) -> Int

The following function iterates through the items in the xs and ss
sequence in parallel, and separates the items from xs into two
collections depending on whether the corresponding item from ss is
true or false. The function returns a tuple of two collections, the
first of which contains all items in xs for which the corresponding
item in ss is true, and the second of which contains the other items
in xs

   defn split<?T> (xs:Seqable<?T>, ss:Seqable<True|False>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable]

The following function returns the number of items in the given
sequence. If the sequence is a subtype of Lengthable, then the length
is returned directly. Otherwise, the length is calculated by iterating
through the entire sequence.

   defn count (xs:Seqable) -> Int

The following function computes the left oriented reduction using
function f on the sequence xs starting with initial value x0. If xs is
empty then x0 is returned. Otherwise, the function f is applied on x0
and the first element in xs, then f is applied again on that result
and the second element in xs, then f is applied on that result and
third element in xs, and so forth until xs is empty. reduce returns
the final result returned by f.

   defn reduce<?T,?S,?U> (f: (T|U, S) -> ?U, x0: ?T, xs:Seqable<?S>) -> T|U

When no initial value is provided, then the first element in xs is
used as the initial value of the reduction. xs must not be empty.

   defn reduce<?T,?S> (f: (T|S, T) -> ?S, xs:Seqable<?T>) -> T|S

The following function computes the right oriented reduction using
function f on the sequence xs with final value xn. If xs is empty then
xn is returned. If xs has a single element, then f is applied on that
element and xn. If xs has two elements, then f is applied on the first
element and the result of applying f on the second element and xn. If
xs has three elements, then f is applied on the first element and the
result of applying f on the second element and the result of applying
f on the third element and xn. Et cetera. 

   defn reduce-right<?T,?S,?U> (f: (S, T|U) -> ?U, xn:?T, xs:Seqable<?S>) -> T|U

When no final value is provided, then the last element in xs is used
as the final value of the reduction. xs must not be empty.

   defn reduce-right<?T,?S> (f: (T, T|S) -> ?S, xs:Seqable<?T>) -> T|S

The following function returns a list containing all unique items in
the sequence xs.

   defn unique<?T> (xs:Seqable<?T&Equalable>) -> List<T>

The following function iterates through the xs sequence, and looks for
the first KeyValue pair whose key is equal to k. If such a pair is
found, then its value is returned. If not then default is returned.

   defn lookup?<?K,?V,?D> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable, default:?D) -> D|V

If no default value is provided, then false is returned if no
appropriate KeyValue pair is found.

   defn lookup?<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> False|V

The following version assumes that an appropriate KeyValue pair exists
and returns its value.

   defn lookup<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> V

The following function takes a sequence xs, and returns a tuple
containing the results of calling the functions f and g with xs. The
functions f and g are computed concurrently such that xs is iterated
through only once. This function allows multiple values to be computed
from a sequence that can only be iterated through once.

   defn parallel-seq<?T,?X,?Y> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y) -> [X,Y]

The following function takes a sequence xs, and returns a tuple
containing the results of calling the functions f, g, and h with
xs. The functions are computed concurrently such that xs is iterated
through only once.

   defn parallel-seq<?T,?X,?Y,?Z> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y, h:Seq<T> -> ?Z) -> [X,Y,Z]

The following function takes a sequence xs, and returns a tuple
containing the results of calling every function in fs with xs. The
functions are computed concurrently such that xs is iterated through
only once.

   defn parallel-seq<?T,?S> (xs:Seqable<?T>, fs:Collection<(Seq<T> -> ?S)>) -> Tuple<S>

============================================================
=================== Lengthable =============================
============================================================

A Lengthable is a value that has either a fixed or variable length.

   deftype Lengthable

Any subtype of Lengthable must implement an appropriate method for the
length multi.

   defmulti length (l:Lengthable) -> Int

============================================================
====================== Maybe ===============================
============================================================

A Maybe object is used to indicate the presence or absence of an
object.

   deftype Maybe<T> <: Equalable & Comparable<Maybe<T>>

The One subtype of Maybe indicates the presence of an object of type
T.

   deftype One<T> <: Maybe<T>

The None subtype of Maybe indicates the absence of an object.

   deftype None <: Maybe<Void>

                     Construction
                     ============

The following function wraps up the value x in a One object.

   defn defn One<?T> (x:?T) -> One<T>

The following function creates a new None object.

   defn None () -> None

                      Unwrapping
                      ==========

The following function will retrieve the wrapped value in a One
object.

   defn value<?T> (x:One<?T>) -> T

The following function will retrieve the wrapped value in a Maybe
object if one exists, otherwise it returns false.

   defn value?<?T> (x:Maybe<?T>) -> T|False   

The following function assumes that the given Maybe object is a One
object and returns its wrapped value.

   defn value!<?T> (x:Maybe<?T>) -> T

                      Equality
                      ========

Maybe is a subtype of Equalable and implements an appropriate method
for the equal? multi. Two None objects are always equal. Two One
objects are equal if their wrapped values are equal. It is an error to
check whether two Maybe objects are equal if they wrap over values
that are not Equalable.

   defmethod equal? (a:Maybe<Equalable>, b:Maybe<Equalable>) -> True|False

                     Comparable
                     ==========

Maybe is a subtype of Comparable and implements an appropriate method
for the compare multi. None objects are always less than One
objects. Two One objects are compared by comparing their wrapped
values. It is an error to compare two Maybe objects if they wrap over
values that are not Comparable.

   defmethod compare (x:Maybe, y:Maybe) -> True|False

                  Convenience Functions
                  =====================

The following function returns true if the given Maybe object contains
no wrapped value (i.e. it is a None object).

   defn empty? (x:Maybe) -> True|False

============================================================
=========== Liveness Trackers and Markers ==================
============================================================

Stanza's support for automatic garbage collection means that users do
not need to manually delete objects after their use. However, it is
often useful to know when an object has been reclaimed to perform
additional cleanup operations. LivenessTrackers and LivenessMarkers
are used to track whether an object is still live. 

                   Creation
                   ========

A LivenessTracker can be created using the following function. For
convenience, every LivenessTracker may be associated with a value to
indicate the identity of the tracker.

   defn LivenessTracker<?T> (value:?T) -> LivenessTracker<T>

The following function can be used to retrieve the value associated
with a tracker.

   defn value<?T> (tracker:LivenessTracker<?T>) -> T

           Creating and Checking Markers
           =============================

The following function is used to create or check upon a LivenessMarker.

   defn marker (tracker:LivenessTracker) -> False|LivenessMarker

The first time this function is called on a LivenessTracker it is
guaranteed to return its associated LivenessMarker. This marker may
then be stored with an object whose liveness the user wishes to
track. On subsequent calls to marker, the function will either return
the created marker, which indicates that the marker is still live. Or
it will return false, which indicates that the marker is now longer
live, and hence neither is the object in which it is stored.
                
Consider tracking the liveness of values of type Car. Intuitively, it
is helpful to imagine a LivenessTracker as a futuristic pistol that
can shoot a tracking beacon (its LivenessMarker) which sticks to the
Car. Periodically, you may ask the tracker whether it is still
receiving signal from the beacon, in which case the marker and hence
the Car is still live. If the beacon is no longer sending a signal
(marker returns false), then the marker and hence the Car is no longer
live.


============================================================
================= IndexedCollection ========================
============================================================

An IndexedCollection represents a mutable collection containing a
series of items, each of which is associated with an integer index.

   deftype IndexedCollection<T> <: Lengthable & Collection<T>

It is a subtype of Lengthable and all values with type
IndexedCollection must implement an appropriate method for the length
multi.

All IndexedCollections are subtypes of Collection and support the
to-seq operation. A default method for to-seq defined in terms of
length and get is provided. For efficiency purposes, subtypes of
IndexedCollections may provide a customized method of to-seq, but it
is not required.


                 Fundamental Operations
                 ======================

Appropriate methods for getting and setting an item at a given index i
must be provided for all subtypes.

   defmulti get<?T> (a:IndexedCollection<?T>, i:Int) -> T
   defmulti set<?T> (a:IndexedCollection<?T>, i:Int, v:T) -> False

                 Convenience Functions
                 =====================

The following function returns a range of items with an
IndexedCollection. The range must have a step size of 1. If the range
is finite, then the starting index must be less than or equal to the
ending index. If the range is inclusive, than the starting and ending
index must be non-negative and less than the length of the
collection. If the range is exclusive, than the starting and ending
index must be non-negative and less than or equal to the length of the
collection. A default method defined in terms of get is provided, but
subtypes may provide customized methods for efficiency purposes if
desired.

   defmulti get<?T> (a:IndexedCollection<?T>, r:Range) -> Collection<T>

The following function sets a range of indices within the collection
to items taken sequentially from vs. See the definition of get for
restrictions upon the range r. The sequence vs must contain at least
as many items as indices being assigned. A default method defined in
terms of set is provided, but subtypes may provide customized methods
for efficiency purposes if desired.

   defmulti set<?T> (a:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False

The following function iterates through the given collection and
replaces each item with the result of calling f on the item. A default
method defined in terms of get and set is provided, but subtypes may
provide customized methods for efficiency purposes if desired.

   defmulti map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False

The following function returns true if the collection is empty or
false otherwise.

   defn empty? (v:IndexedCollection) -> True|False

The following function reverses the order in which items appear in the
collection.

   defn reverse!<?T> (xs:IndexedCollection<?T>) -> False

The following function returns a sequence containing the items in the
collection in reversed order. The original collection is unchanged.

   defn in-reverse<?T> (xs:IndexedCollection<?T>) -> Seq<T>

============================================================
=================== Sorting ================================
============================================================

The following function sorts the collection using the given comparison
function and the quick sort algorithm.

   defn qsort!<?T> (xs:IndexedCollection<?T>, is-less?:(T,T) -> True|False) -> False

The following function sorts the collection using the less? multi and
the quick sort algorithm.

   defn qsort!<?T> (xs:IndexedCollection<?T&Comparable>) -> False

The following function sorts the collection by comparing keys
extracted using the key function and the quick sort algorithm.

   defn qsort!<?T> (key:T -> Comparable, xs:IndexedCollection<?T>) -> False

The following function returns a lazily sorted sequence of the given
sequence xs using the given comparison function and the quick sort algorithm.

   defn lazy-qsort<?T> (xs:Seqable<?T>, is-less?:(T,T) -> True|False) -> Collection<T> & Lengthable

The following function returns a lazily sorted collection of the given
sequence xs using the less? multi and the quick sort algorithm.

   defn lazy-qsort<?T> (xs:Seqable<?T&Comparable>) -> Collection<T> & Lengthable

The following function returns a lazily sorted collection of the given
sequence xs by comparing keys extracted using the key function and the quick sort algorithm.

   defn lazy-qsort<?T> (key:T -> Comparable, xs:Seqable<?T>) -> Collection<T> & Lengthable

============================================================
==================== Arrays ================================
============================================================

Arrays are the most fundamental IndexedCollection in Stanza,
representing a finite series of items with constant time access to
elements by index.

   deftype Array<T> <: IndexedCollection<T> & Equalable

An array is a subtype of IndexedCollection and hence supports the
fundamental get and set and length operations.

                   Equality
                   ========

Two arrays are defined to be equal only if are the same array.

                   Creation
                   ========

The following function creates an Array with length n for holding
values of type T. It is a fatal error to read from an index that has
not been initialized, and n cannot be negative.

   defn Array<T> (n:Int) -> Array<T>

The following function creates an Array with length n for holding
values of type T with each index initialized to the item x. n cannot
be negative.

   defn Array<T> (n:Int, x:T) -> Array<T>

               Convenience Functions
               =====================

The following function converts a sequence of items of type T to an
array.

   defn to-array<T> (xs:Seqable<T>) -> Array<T>

The following function creates a new array where each item is
initialized to the result of calling the function f on each item in
the given array xs.

   defn map<R,?T> (f:T -> R, xs:Array<?T>) -> Array<R>


============================================================
================== CharArrays ==============================
============================================================

CharArrays are specialized arrays designed specifically for
efficiently storing Chars.

   deftype CharArray <: Array<Char>

CharArrays implement appropriate methods for each of the multis
required by Array and behaves equivalently to an Array<Char>.

                   Creation
                   ========

The following function creates a CharArray of length n, with each
index initialized to the space character.

   defn CharArray (n:Int) -> CharArray

The following function creates a CharArray of length n, with each
index initialized to the given character x.

   defn CharArray (n:Int, x:Char) -> CharArray

             Efficient Char Retrieval
             ========================

The following function allows for efficient retrieval of characters
from a CharArray. See the definition of get for restrictions on the
range r.

   defn get-chars (cs:CharArray, r:Range) -> String
   
The following function allows for efficient assignment of characters
in a CharArray. See the definition of get for restrictions on the
range r.

   defn set-chars (cs:CharArray, r:Range, s:String) -> False

CharArray implements efficient methods for getting and setting
characters which call get-chars and set-chars appropriately.

   defmethod get (cs:CharArray, r:Range) -> String
   defmethod set (cs:CharArray, r:Range, s:String) -> False


============================================================
================== StringBuffer ============================
============================================================

A StringBuffer is an extendable array for holding characters.

   deftype StringBuffer <: IndexedCollection<Char> & OutputStream     

                  Construction
                  ============

The following function creates a StringBuffer with the initial
capacity n. The capacity of a StringBuffer is the number of characters
it may hold before it undergoes resizing.

   defn StringBuffer (n:Int) -> StringBuffer

If no capacity is provided, then the default capacity is 32.

   defn StringBuffer () -> StringBuffer                 

                 IndexedCollection
                 =================

A StringBuffer is a subtype of an IndexedCollection and implements
appropriate methods for retrieving its length, and getting and setting
characters by index.

   defmethod length (s:StringBuffer) -> Int
   defmethod get (s:StringBuffer, i:Int) -> Char
   defmethod set (s:StringBuffer, i:Int, c:Char) -> False

When setting a character at an index i, if i is less than the length
of the buffer, then the character currently at index i will be
overwritten. If i is equal to the length of the buffer, then i will be
added to the end of the buffer, and the buffer's length will increase
by 1.

              Adding and Removing Characters
              ==============================

The following function will add the character c to the end of the
buffer.

   defn add (s:StringBuffer, c:Char) -> False

The following function will add all the characters in the sequence cs
to the end of the buffer.

   defn add-all (s:StringBuffer, cs:Seqable<Char>) -> False

The following function will clear all characters in the StringBuffer.

   defn clear (s:StringBuffer) -> False

                  OutputStream
                  ============

StringBuffer is a subtype of OutputStream and implements
appropriate methods for the print and print-all multi.

   defmethod print (s:StringBuffer, c:Char) -> False
   defmethod print-all (s:StringBuffer, cs:String|StringBuffer|CharArray) -> False

                Convenience Functions
                =====================

A StringBuffer can be efficiently converted into a String by calling
the to-string function.

   defmethod to-string (s:StringBuffer) -> String


============================================================
====================== Timers ==============================
============================================================

Timers are used for measuring elapsed time at various granularities.

   deftype Timer

                 Fundamental Operations
                 ======================

The following function starts the timer. It is an error to start a
Timer that is already running.

   defn start (t:Timer) -> False

The following function stops the timer. It is an error to stop a Timer
that is not running.

   defn stop (t:Timer) -> False

The following function retrieves the current time elapsed of the
timer. The unit of the number returned is dependent upon how the timer
is created.

   defn time (t:Timer) -> Long

                      Creation
                      ========

The following function creates a timer with millisecond granularity
and an associated name.

   defn MillisecondTimer (name:String) -> Timer

The following function creates a timer with microsecond granularity
and an associated name.

   defn MicrosecondTimer (name:String) -> Timer

The following function creates a timer that piggybacks off of the time
measured by another timer. Time only elapses for a piggyback timer if
the timer it is piggybacking is running. A PiggybackTimer returns time
in the same granularity as the timer it is piggybacking.

   defn PiggybackTimer (name:String, t:Timer) -> Timer

============================================================
================= Labeled Scopes ===========================
============================================================

LabeledScopes provide the ability to exit early from a block of
code. The following function executes the thunk function in a new
labeled scope. The thunk function is passed a exit function that when
called will immediately exit the thunk. If the thunk runs to
completion ever calling the exit function then its result is
returned. If the exit function is called during execution of thunk
then the argument passed to the exit function is returned.

   defn LabeledScope<T> (thunk: (T -> Void) -> T) -> T

Users will typically use the standard macro form for creating labeled
scopes instead of directly calling LabeledScope. The following code
will return the first prime number between 100 and 200.

   label<Int> return :
      for i in 100 to 200 do :
         if prime?(i) :
            return(i)
      fatal("No prime found!")      

============================================================
==================== Generators ============================
============================================================

Generators provide the ability to execute a function in a new
coroutine and return its results in the form of a sequence. The
following function executes the thunk function in a new coroutine and
returns a sequence. The thunk function is passed two functions as
arguments. The first argument is the yield function, which takes a
single argument. During execution of thunk, calls to the yield
function will suspend the coroutine, and its argument will be included
in the result sequence. The second argument is the break function,
which takes either zero or one argument. During execution of thunk, a
call to the break function with no arguments will immediately close
the coroutine and end the result sequence. A call to the break
function with one argument will immediately close the coroutine,
include the argument as the last item in the result sequence, and then
end the result sequence.

   defn Generator<T> (thunk : (T -> False, (T -> Void) & (() -> Void)) -> ?) -> Seq<T>

Users will typically use the standard macro form for creating
generators instead of directly calling Generator. The following code
creates a sequence containing the first 100 prime numbers.

   generate<Int> :
      var n = 0
      for i in 2 to false do :
         if prime?(i) :
            n = n + 1
            if n == 100 : break(i)
            else : yield(i)

============================================================
===================== Coroutines ===========================
============================================================

Coroutines provide the ability to execute a function in a context that
can be saved and resumed later. This ability is most often used to
execute a piece of code concurrently with the main program. A
coroutine for which objects of type I are sent to its wrapped function,
and for which objects of type O are sent back from its wrapped
function is represented by the following type.

   deftype Coroutine<I,O> <: Equalable

                        Creation
                        ========

The following function creates a coroutine for which objects of type I
are sent to its wrapped function, and for which objects of type O are
sent back from its wrapped function. The argument represents the
wrapped function of the coroutine.

   defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O>

The first argument to the wrapped function is the coroutine that is
created. The second argument to the wrapped function is the argument
passed in the call to resume on the coroutine. The result of the
function enter is the last value sent back from the wrapped function.

                        Equality
                        ========

Coroutine are a subtype of Equalable and can be compared using
equal?. Two coroutines are equal are they were created by the same
call to Coroutine.

   defmethod equal? (a:Coroutine, b:Coroutine) -> True|False

                    Transferring Control
                    ====================

The following function transfers control flow into a coroutine, and
sends it the value x. The return value of resume is the value that is
sent back by the coroutine.

   defn resume<?I,?O> (c:Coroutine<?I,?O>, x:I) -> O

The following function transfers control flow out of a coroutine, and
back to the main program. The value x is sent back to the main
program. The return value of suspend is the value that is sent to the
coroutine by the next call to resume.

   defn suspend<?I,?O> (c:Coroutine<?I,?O>, x:O) -> I

The following function transfers control flow out of a coroutine, back
to the main program, and closes the coroutine. The value x is sent
back to the main program. break has no return value as the coroutine
is closed and cannot be resumed afterwards.

   defmulti break<?O> (c:Coroutine<?,?O>, x:O) -> Void

The following function closes a coroutine, and disallows any further
calls to resume on the coroutine.

   defn close (c:Coroutine) -> False

                      Coroutine Status
                      ================

The following function returns true if the given coroutine is
currently running. Only active coroutines can be suspended or broken
from.

   defn active? (c:Coroutine) -> True|False

The following function returns true if the given coroutine is not
currently running and open to be resumed. Only open coroutines can be
resumed.

   defn open? (c:Coroutine) -> True|False


============================================================
====================== Dynamic Wind ========================
============================================================

Consider the following code which attempts to ensure that the global variable
X is set to the value 42 while the function f is running, and for X to
be restored after f is done.

   val old-X = X
   X = 42
   f()
   X = old-X

However, because of coroutines it is possible for the above code to
finish during the call to f, (for example, if f calls break, or throws
an exception) and thus leave x unrestored. The dynamic-wind function
allows users to perform operations upon entering or leaving a scope.

The dynamic-wind function takes a body function accompanied by an
optional entering function, in, and an exiting function,
out. dynamic-wind performs a call to body while ensuring that in is
called every time execution enters the scope of body, and that out is
called every time execution exits the scope of body. The exiting
function takes a single boolean argument which takes on the value true
when it can be proven that this is the last time execution will exit
the scope, or false otherwise.

   defn dynamic-wind<?T> (in:False|(() -> ?),
                          body:() -> ?T,
                          out:False|(? -> ?)) -> T

Using dynamic-wind, the above example can be rewritten as follows:

   val old-X = X
   dynamic-wind(
      fn () : X = 42
      f
      fn () : X = old-X)

============================================================
===================== OutputStream =========================
============================================================

An OutputStream represents a destination to which we can print
characters, and write values. The most common output stream used in
daily programming is the standard output stream which represents the
user's terminal.

   deftype OutputStream

                   Fundamental Operation
                   =====================

The fundamental operation for an OutputStream is the function for
printing a specific value x to the output stream.

   defmulti print (o:OutputStream, x) -> False

For all types in the core Stanza library, there is a default
implementation of print for that type that prints each Char
in its string representation to the output stream. Because of this,
the only mandatory method that needs to be implemented by subtypes of
OutputStream is that for Char.

   defmethod print (o:OutputStream, c:Char) -> False

                    Convenience Functions
                    =====================

The following multi prints all the item in the given sequence to the
OutputStream.

   defmulti print-all (o:OutputStream, xs:Seqable) -> False

There is a default method implemented for print-all that calls print
on each item in the sequence. For efficiency purposes, users are free
to provide customized versions of print-all for specific types.

The following function prints the item x to the OutputStream followed
by the newline character.

   defn println (o:OutputStream, x) -> False

The following function prints all items in the sequence xs to the
OutputStream followed by the newline character.

   defn println-all (o:OutputStream, xs:Seqable) -> False

                     Standard Output Streams
                     =======================

The following global value holds the standard output stream
representing the user's terminal.

   val STANDARD-OUTPUT-STREAM : OutputStream

The following global value holds the standard error stream
representing the user's terminal if error messages are not redirected
or the error buffer otherwise.

   val STANDARD-ERROR-STREAM : OutputStream

                    Current Output Stream
                    =====================

The current output stream is, by default, the standard output
stream. The following function will set the current output stream to o
before calling the function f and then restore the current output
stream afterwards.

   defn with-output-stream<?T> (o:OutputStream, f: () -> ?T) -> T

The following functions behave identically to the versions that do not
take an OutputStream argument. Instead they print to the current
output stream.

   defn print (x) -> False
   defn println (x) -> False
   defn print-all (xs:Seqable) -> False
   defn println-all (xs:Seqable) -> False

============================================================
=================== Indented Streams =======================
============================================================

An IndentedStream wraps over an OutputStream to provide the ability to
automatically print indenting spaces as needed.

   deftype IndentedStream <: OutputStream

An IndentedStream is a subtype of OutputStream and implements an
appropriate method for the print multi.

   defmethod print (o:IndentedStream, c:Char) -> False

When asked to print a newline character, an IndentedStream will print
the newline character followed by the number of spaces indicated
during creation of the stream. For all other characters an
IndentedStream simply calls print on its wrapped OutputStream.

                      Creation
                      ========

The following function creates an IndentedStream that indents n spaces
by wrapping over the given OutputStream.

   defn IndentedStream (o:OutputStream, n:Int) -> IndentedStream

                   Convenience Functions
                   =====================

The following function calls the function f with a new IndentedStream
created by wrapping over the given output stream.

   defn do-indented<?T> (f: IndentedStream -> ?T, o:OutputStream) -> T

The following function wraps over the current output stream with an
IndentedStream and then calls the function f. The current output
stream is restored afterwards.

   defn indented<?T> (f: () -> ?T) -> T

============================================================
================== FileOutputStream ========================
============================================================

A FileOutputStream represents an external file with an output stream
interface to which we can write values.

   deftype FileOutputStream <: OutputStream

A FileOutputStream is a subtype of OutputStream and supports the
fundamental operations for printing a character to the stream.

   defmethod print (o:FileOutputStream, c:Char) -> False

                      Creation
                      ========

The following functions creates a new FileOutputStream given the path
to the file, and a boolean flag indicating, in the case that the file
already exists, whether new characters should be appended to the end
of the file or whether the file should be overwritten. If no append
flag is given, then by default, the file is overwritten.

   defn FileOutputStream (filename:String, append?:True|False) -> FileOutputStream
   defn FileOutputStream (filename:String) -> FileOutputStream

                  Writing Functions
                  =================

The following functions write the following values as binary data
following little endian conventions.

   defn put (o:FileOutputStream, x:Byte) -> False
   defn put (o:FileOutputStream, x:Int) -> False
   defn put (o:FileOutputStream, x:Long) -> False
   defn put (o:FileOutputStream, x:Float) -> False
   defn put (o:FileOutputStream, x:Double) -> False

                    Closing a File
                    ==============

The following function closes a FileOutputStream.

   defn close (o:FileOutputStream) -> False

                Convenience Functions
                =====================

The following function sets the given file as the current output
stream, before calling the function f, and then restores the current
output stream and closes the file.

   defn with-output-file<?T> (file:FileOutputStream, f: () -> ?T) -> T

The following function prints the given object to the given file.

   defn spit (filename:String, x) -> False

============================================================
================== Pretty Printing =========================
============================================================

The write multi is used for printing a value in a form that preserves
its structure. For example, Strings are surrounded in quotes and
non-printable characters are escaped. Numbers have suffixes to
indicate their type. For the core types that make up an s-expression,
values are written out in a form that can be read back in using the
reader.

   defmulti write (o:OutputStream, x) -> False

A default method is provided that simply calls print.

                 Convenience Functions
                 =====================

The following function pretty prints every item in the sequence xs
separated by spaces.

   defn write-all (o:OutputStream, xs:Seqable) -> False

============================================================
=================== InputStream ============================
============================================================

An InputStream represents a source from which we can read characters
and values.

   deftype InputStream

                   Fundamental Operations
                   ======================

The following function reads a single character from the given input
stream. False is returned if there are no more characters in the
stream.

   defn get-char (i:InputStream) -> Char|False

The following function reads a single byte from the given input
stream. False is returned if there are no more bytes in the stream.

   defn get-byte (i:InputStream) -> Byte|False

                    Standard Input Streams
                    ======================

The following global value holds the standard input stream
representing the user's terminal.

   val STANDARD-INPUT-STREAM : InputStream

                   Convenience Functions
                   =====================

The following multi reads characters continuously from the input
stream and stores them into the given CharArray at the specified
range. The range must be a dense index range with respect to the
character array. The number of characters read is returned.

   defmulti fill (xs:CharArray, r:Range, i:InputStream) -> Int

A default method implemented in terms of get-char is provided, but for
efficiency purposes, users are free to provide customized methods for
subtypes of InputStream.

============================================================
================= FileInputStreams =========================
============================================================

A FileInputStream represents an external file with an input stream
interface from which we can read values.

   deftype FileInputStream <: InputStream

A FileInputStream is a subtype of InputStream and supports the
fundamental operations for reading a character or a byte from the
stream.

   defmethod get-char (i:FileInputStream) -> Char|False
   defmethod get-byte (i:FileInputStream) -> Byte|False

                     Creation
                     ========

The following function creates a FileInputStream given the name of the
file.

   defn FileInputStream (filename:String) -> FileInputStream

                   Closing a File
                   ==============

The following function closes a FileInputStream.

   defn close (i:FileInputStream) -> False

                   Reading Values
                   ==============

The following functions read the following values as binary data
following little endian conventions.

   defn get-int (i:FileInputStream) -> False|Int
   defn get-long (i:FileInputStream) -> False|Long
   defn get-float (i:FileInputStream) -> False|Float
   defn get-double (i:FileInputStream) -> False|Double

               Convenience Functions
               =====================

The following function reads the entire contents of a file as returns
the contents as String.

   defn slurp (filename:String) -> String

============================================================
=================== String Input Streams ===================
============================================================

A StringInputStream represents an input stream backed by an underlying
string.

   deftype StringInputStream <: InputStream & Lengthable

                        Lengthable
                        ==========

A StringInputStream is a subtype of Lengthable and implements an
appropriate method for the length multi that returns the number of
characters left unread in the underlying string.

   defmethod length (s:StringInputStream) -> Int

                        InputStream
                        ===========

A StringInputStream is a subtype of InputStream and implements
appropriate methods for reading characters and bytes.

   defmethod get-char (s:StringInputStream) -> Char|False
   defmethod get-byte (s:StringInputStream) -> Byte|False

                         Creation
                         ========

The following function creates a StringInputStream given the
underlying string and the name of the file that it comes from. If no
filename is given, then its default value is "UnnamedStream".

   defn StringInputStream (string:String, filename:String) -> StringInputStream
   defn StringInputStream (string:String) -> StringInputStream

                     Additional Operations
                     =====================

A StringInputStream allows for the characters beyond the immediate
following character to be read. The following function returns the
i'th next character in the stream. If the index i is not given, then
its default value is 0.

   defn peek? (s:StringInputStream, i:Int) -> False|Char
   defn peek? (s:StringInputStream) -> False|Char

A StringInputStream keeps track of the current position of its read
marker. The following function returns the FileInfo representing the
current position in the string.

   defn info (s:StringInputStream) -> FileInfo

============================================================
=================== System Utilities =======================
============================================================

                  Command Line Arguments
                  ======================

The command line arguments used to invoke the program can be retrieved
as an array of strings using the following function.

   defn command-line-arguments () -> Array<String>

                    Files and Paths
                    ===============

The following function checks whether the given file exists given its
name.

   defn file-exists? (filename:String) -> True|False

The following function deletes the given file.

   defn delete-file (path:String) -> False

The following function expands all symbolic links in the given path
and returns an absolute path that points to the same file. If such a
file does not exist then false is returned.

   defn resolve-path (path:String) -> String|False

                         Time
                         ====

The following function returns the number of milliseconds elapsed
since January 1, 1970.

   defn current-time-ms () -> Long

The following function returns the number of microseconds elapsed
since January 1, 1970.

   defn current-time-us () -> Long

                  Environment Variables
                  =====================

The following function returns the value associated with the
environment variable with the given name. false is returned if there
is no such variable.

   defn get-env (name:String) -> String|False

The following function associates the environment variable with the
given name with the given value. If the environment variable already
exists then its value is overwritten if the overwrite flag is true,
otherwise its old value is kept. If no overwrite flag is given then
its default value is true.

   defn set-env (name:String, value:String, overwrite:True|False) -> False
   defn set-env (name:String, value:String) -> False

                     System Calls
                     ============

The following function calls the system shell with the given command.

   defn call-system (cmd:String) -> False


############################################################
################ Collections Library #######################
############################################################

The collections package consists of functions and types useful for
managing collections.

============================================================
===================== Vectors ==============================
============================================================

Vectors represent a dynamically growing Array of items. Like arrays,
each item can be accessed using an integer index. However, Vectors can
be resized after creation.

   deftype Vector<T> <: IndexedCollection<T>

                 IndexedCollection
                 =================

Vectors are a subtype of IndexedCollection and thus implements the
appropriate methods for retrieving elements, assigning elements,
and retrieving its length.

   defmethod get<?T> (v:Vector<?T>, i:Int) -> T
   defmethod set<?T> (v:Vector<?T>, i:Int, v:T) -> False
   defmethod length (v:Vector) -> Int

When assigning an item to an index, if i is less than the length of
the vector then the item at that location is overwritten by v. If i is
equal to the length of the vector, then v is added to the end of the
vector.

                     Creation
                     ========

The following function creates a Vector for holding objects of type T
initialized with a capacity of cap.

   defn Vector<T> (cap:Int) -> Vector<T>

If no capacity is given, then the default capacity is 8.

   defn Vector<T> () -> Vector<T>

The following function creates a new Vector from the elements in the
sequence xs.

   defn to-vector<T> (xs:Seqable<T>) -> Vector<T>

                    Operations
                    ==========

The following function adds the given value to the end of the vector.

   defn add<?T> (v:Vector<?T>, value:T) -> False

The following function adds all of the values in the sequence vs to
the end of the vector.

   defn add-all<?T> (v:Vector<?T>, vs:Seqable<T>) -> False

The following function removes every item in the vector.

   defn clear (v:Vector) -> False

The following function removes the last item in the vector and returns
it. The vector must not be empty.

   defn pop<?T> (v:Vector<?T>) -> T

The following function returns the last item in the vector. The vector
must not be empty.

   defn peek<?T> (v:Vector<?T>) -> T

The following function removes the item at index i in the vector. i
must be less than the length of the vector. The operation takes time
proportional to the difference between the length of the vector and i.

   defn remove (v:Vector, i:Int) -> False

The following function removes the items within the range r from the
vector. The range must be a dense index range with respect to the
vector. The operation takes time proportional to the difference
between the length of the vector and the end of the range.

   defn remove (v:Vector, r:Range) -> False

The following function either overwrites or removes items from the
vector by calling the function f on each item in the vector. For each
item in the vector, if f returns a One object, then the item is
overwritten with the wrapped value in the One object. If f returns a
None object, then the item is removed from the vector. update is
compatible with the for macro form.

   defn update<?T> (f: T -> Maybe<T>, v:Vector<?T>) -> False

The following function removes the first occurrence of the item x in
the vector v if it exists.

   defn remove-item<?T> (v:Vector<?T&Equalable>, x:T&Equalable) -> False

The following function calls the function f on every item in the
vector v. Items for which f returned true are removed.

   defn remove-when<?T> (f: T -> True|False, v:Vector<?T>) -> False 

The following function sets the capacity of the vector to be equal to
the size of the vector, thus removing storage for additional elements.

   defn trim (v:Vector) -> False   

The following function truncates the given vector down to the
specified size. The given size must be less than or equal to the
length of the vector.

   defn shorten (v:Vector, size:Int) -> False

The following function pads the given vector up to the specified size
by adding x repeatedly to the end of the vector. The given size must
be greater than or equal to the length of the vector.

   defn lengthen<?T> (v:Vector<?T>, size:Int, x:T) -> False

The following function sets the length of the vector to the new
specified length. If the given length is shorter than the current
length then the vector is truncated. Otherwise the vector is padded
using the item x.

   defn set-length<?T> (v:Vector<?T>, length:Int, x:T) -> False   

The following function creates a new Vector from the results of
applying the function f repeatedly to each item in the given vector v.

   defn map<R,?T> (f: T -> R, v:Vector<?T>) -> Vector<R>


============================================================
======================== Queues ============================
============================================================

Queues represent an indexed collection with support for acting as a
first in last out (FIFO) datastructure.

   deftype Queue<T> <: IndexedCollection<T>

                    IndexedCollection
                    =================

Queues are a subtype of IndexedCollection and thus implements the
appropriate methods for the retrieving elements, assigning elements,
and retrieving its length.

   defmethod get<?T> (q:Queue<?T>, i:Int) -> T
   defmethod set<?T> (q:Queue<?T>, i:Int, v:T) -> False
   defmethod length (q:Queue) -> Int

When assigning an item to an index, if i is not negative and less than
the length of the queue then the item at that location is overwritten
by v. If i is equal to -1, then v is added to the front of the queue.

                        Creation
                        ========

The following function creates a Queue for holding objects of type T
initialized with a capacity of cap.

   defn Queue<T> (cap:Int) -> Queue<T>

If no capacity is given, then the default capacity is 8.

   defn Queue<T> () -> Queue<T>

                       Operations
                       ==========

The following function adds the given item to the front of the
queue. The corresponding indices of all existing entries in the queue
increase by 1.

   defn add<?T> (q:Queue<?T>, x:T) -> False

The following function removes and returns the item at the back of
the queue. The queue must not be empty.

   defn pop<?T> (q:Queue<?T>) -> T

The following function returns the item at the back of the queue. The
queue must not be empty.

   defn peek<?T> (q:Queue<?T>) -> T

The following function removes all items in queue.

   defn clear (q:Queue) -> False

============================================================
====================== Tables ==============================
============================================================

Tables represent a mapping between key objects of type K and value
objects of type V.

   deftype Table<K,V> <: Collection<KeyValue<K,V>> & Lengthable   

                     Collection
                     ==========

A Table is a subtype of a Collection and implements an appropriate
method for the to-seq multi that allows for the table to be viewed as
a sequence of key value pairs.

   defmethod to-seq<?K,?V> (t:Table<?K,?V>) -> Seq<KeyValue<K,V>>

                     Lengthable
                     ==========

A Table is a subtype of Lengthable and implements an appropriate
method for the length multi that returns the number of key value pairs
currently in the table.

   defmethod length (t:Table) -> Int

                 Fundamental Operations
                 ======================

The following multi associates the key object k with the value object
v in the table.

   defmulti set<?K,?V> (t:Table<?K,?V>, k:K, v:V) -> False

The following multi retrieves the value object associated with the key
object k in the table. If there is no such key in the table then the
default value d is returned.

   defmulti get?<?K,?V,?D> (t:Table<?K,?V> k:K, d:?D) -> V|D

The following multi removes the given key and its associated value
from the table. If there is a key then the function returns
true. Otherwise the function returns false.

   efmulti remove<?K> (t:Table<?K,?>, k:K) -> True|False

The following multi removes all keys and all values in the table.

   defmulti clear (t:Table) -> False

                 Convenience Functions
                 =====================

The following multi returns the value associated with the given key if
it exists, otherwise it returns false.

   defn get?<?K,?V> (t:Table<?K,?V>, k:K) -> V|False

The following multi assumes that the given k exists in the table and
returns its associated value. A default method, defined in terms of
get?, is provided but users may provide customized methods for
subtypes of Table for efficiency purposes.

   defmulti get<?K,?V> (t:Table<?K,?V>, k:K) -> V

The following multi returns true if the given k exists in the table. A
default method, defined in terms of get?, is provided but users may
provide customized methods for subtypes of Table for efficiency
purposes.

   defmulti key?<?K> (t:Table<?K,?>, k:K) -> True|False   

The following multi returns a sequence containing all keys in the
table. A default method, defined in terms of to-seq, is provided but
users may provide customized methods for subtypes of Table for
efficiency purposes.

   defmulti keys<?K> (t:Table<?K,?>) -> Seqable<K>   

The following multi returns a sequence containing all values in the
table. A default method, defined in terms of to-seq, is provided but
users may provide customized methods for subtypes of Table for
efficiency purposes.

   defmulti values<?V> (t:Table<?,?V>) -> Seqable<V>

The following function returns true if the table contains no keys or
values.

   defn empty? (t:Table) -> True|False

============================================================
===================== HashTables ===========================
============================================================

HashTables are an efficient implementation of tables for keys of type
Equalable. K must be a subtype of Equalable.

   deftype HashTable<K,V> <: Table<K,V>

                       Table
                       =====

HashTables are subtypes of Table and support all necessary methods for
correct table operations.

                      Creation
                      ========

The following function creates a HashTable with key objects of type K
and value objects of type V. A hash function that maps key objects to
integers, an optional default value, and an initial capacity must be
provided.

If given, the default value is returned for retrieval operations when
the key does not exist.

   defn HashTable<K,V> (hash: K -> Int, default:Maybe<V>, initial-capacity:Int) -> HashTable<K,V>

The following function creates a HashTable from the given hash
function, a default value V, and a default capacity of 32.

   defn HashTable<K,V> (hash: K -> Int, default:V) -> HashTable<K,V>

The following function creates a HashTable from the given hash
function, no default value, and a default capacity of 32.

   defn HashTable<K,V> (hash: K -> Int) -> HashTable<K,V>

The following function creates a HashTable that uses the hash multi to
compute hashes for its keys, and a default value of V. K must be a
subtype of Hashable.

   defn HashTable<K,V> (default:V) -> HashTable<K,V>

The following function creates a HashTable that uses the hash multi to
compute hashes for its keys, and no default value. K must be a subtype
of Hashable.

   defn HashTable<K,V> () -> HashTable<K,V>


############################################################
##################### Reader ###############################
############################################################

The reader package contains the implementation of Stanza's
s-expression reader.

The following function reads in the given file and returns its
contents as a list of s-expressions.

   defn read-file (filename:String) -> List

The following function converts the given string into a list of
s-expressions.

   defn read-all (text:String) -> List

The following function reads in all characters from the given input
stream and returns a list of s-expressions.

   defn read-all (stream:StringInputStream) -> List

The following function reads a single s-expression from the input
stream.

   defn read (eater:StringInputStream) -> ?


############################################################
################## Macro Utilities #########################
############################################################

The macro-utils package contains functions for manipulating
s-expressions useful for macro writers.

============================================================
================== Utility Functions =======================
============================================================

The following function returns true if the given form is a list (or
list wrapped in a Token) whose first element is equal to the
given symbol, or is a token whose wrapped value is equal to the given
symbol.

   defn tagged-list? (form, tag:Symbol) -> True|False

============================================================
============= S-Expression Template Engine =================
============================================================

The template engine is can be thought of as an advanced search and
replace utility that operates on s-expressions instead of on
strings. The following function returns the result of performing
search and replace operations on a template form given a collection of
desired replacements.

   defn fill-template (template, replacements:Collection<KeyValue<Symbol,?>>) -> ?

The replacements are expressed as KeyValue pairs where the key holds the
symbol that should be replaced, and the value holds what the key should
be replaced by. Values can be objects of any type, but there are a set
of distinguished template forms that have special replacement rules.

                   Simple Replacements
                   ===================

Consider the following template :

   val form = `(
      defn myfunction (arg : argtype) :
         body)

and the desired replacements :

   val replacements = [
      `myfunction => `print-int
      `arg => `x
      `argtype => `Int
      `body => `(println("Inside print-int"),
                 println(x))]

Then the following call to fill-template :

   fill-template(form, replacements)

will return the following replaced form :

   `(defn print-int (x : Int) :
        (println("Inside print-int"),
         println(x)))

Observe that occurrences of the keys in replacements in the template
form are systematically replaced with their associated values.
      
                   The Splice Template
                   ===================

The splice template allows for a symbol to be replaced by multiple
values. The following function creates a SpliceTemplate. Note that the
given item must be either a Collection or a Token wrapping over a
Collection.

   defn splice (item:Collection|Token) -> SpliceTemplate

Notice that in the Simple Replacements example, the key `body was
associated with a 2 element list. And in the resulting form, the
occurrence of body was replaced with the 2 element list.

By using the splice template we can replace occurrences of `body
directly with the elements inside the list and avoid an extra pair of
parenthesis.

Consider the following template :

   val form = `(
      defn myfunction (arg : argtype) :
         body)

and the desired replacements :

   val replacements = [
      `myfunction => `print-int
      `arg => `x
      `argtype => `Int
      `body => splice(`(println("Inside print-int"),
                        println(x)))]

Then the following call to fill-template :

   fill-template(form, replacements)

will return the following replaced form :

   `(defn print-int (x : Int) :
        println("Inside print-int")
        println(x))

                  The Nested Template
                  ===================

The nested template allows for a pattern to be repeatedly replaced
using a different set of replacements each time. The following
function creates a NestedTemplate.

   defn nested (items:Collection<Collection<KeyValue<Symbol,?>>>) -> NestedTemplate

Consider the following template :

   val form = `(
      defn myfunction (args{arg : argtype}) :
         body)

and the desired replacements :

   val replacements = [
      `myfunction => `print-int
      `args => nested $ [
         [`arg => `x, `argtype => `Int]
         [`arg => `y, `argtype => `String]
         [`arg => `z, `argtype => `Char]]
      `body => `(println(x))]

Then the following call to fill-template :

   fill-template(form, replacements)

will return the following replaced form :

   `(defn print-int (x:Int, y:String, z:Char) :
        (println(x)))

Note, specially, the syntax in the template when using a
NestedTemplate replacement. If the replacement is a NestedTemplate
object, then the template form key *must* have form :

   key{pattern ...}

Note that the set of replacements used during each replacement of a
NestedTemplate object also includes all the entries from the parent
replacements.

For example, if we use the following replacements on the same template
form :

   val replacements = [
      `myfunction => `print-int
      `argtype => `Int
      `args => nested $ [
         [`arg => `x]
         [`arg => `y]
         [`arg => `z, `argtype => `Char]]
      `body => `(println(x))]

Then the call to fill-template :

   fill-template(form, replacements)

will return the following replaced form :

   `(defn print-int (x:Int, y:Int, z:Char) :
        (println(x)))

Notice that the `argtype replacement value is inherited from the
parent bindings.

                 The Plural Template
                 ===================

The plural template is similar to the nested template allows for a
pattern to be repeatedly replaced using a different set of
replacements each time. The difference is that the plural template
allows the user to specify *for each symbol* what it should be
replaced with each time, whereas the nested template requires the user
to specify *for each replacement* what the set of replacements should
be.

The following function creates a PluralTemplate given a sequence of
replacements, each replacement being a sequence itself. Note that the
length of each replacement value must be equal.

   defn collect (entries: Seqable<KeyValue<Symbol, Seqable>>) -> PluralTemplate

Consider the following template :

   val form = `(
      defn myfunction (args{arg : argtype}) :
         body)

and the desired replacements :

   val replacements = [
      `myfunction => `print-int
      `args => plural $ [
         `arg => `(x y z)
         `argtype => `(Int String Char)]
      `body => `(println(x))]

Then the following call to fill-template :

   fill-template(form, replacements)

will return the following replaced form :

   `(defn print-int (x:Int, y:String, z:Char) :
        (println(x)))

                   The Choice Template
                   ===================

The choice template allows for a symbol to be replaced with a selected
pattern from amongst a list of patterns depending on the replacement
value.

The following function creates a ChoiceTemplate given the choice n.

   defn choice (n:Int) -> ChoiceTemplate

The following convenience function also allows for users to create a
ChoiceTemplate given a boolean value, where false is equivalent to
choice 0 and true is equivalent to choice 1.

   defn choice (b:True|False) -> ChoiceTemplate

Consider the following template :

   val form = `(
      defn myfunction (x:Int) :
         body{
            println(x)
         }{
            x + 1
         }{
            fatal(x)
         })

and the desired replacements :

   val replacements = [
      `myfunction => `print-int
      `body => choice(1)]

Then the following call to fill-template :

   fill-template(form, replacements)

will return the following replaced form :

   `(defn print-int (x:Int) :
        x + 1)

Note, specially, the syntax in the template when using a
ChoiceTemplate replacement. If the replacement is a ChoiceTemplate
object, then the template form key *must* have form :

   key{pattern0 ...}{pattern1 ...}{pattern2 ...}

We can select which pattern is produced by changing the index we use
to create the ChoiceTemplate. The following replacements :

   val replacements = [
      `myfunction => `print-int
      `body => choice(2)]

will result in the following replaced form :

   `(defn print-int (x:Int) :
        fatal(x))
