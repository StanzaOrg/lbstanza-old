defpackage collections :
   import core

;============================================================
;===================== Utilities ============================
;============================================================

deftype Sentinel <: Equalable

;============================================================
;===================== Vectors ==============================
;============================================================

;                     Interface
;                     =========

public deftype Vector<T> <: IndexedCollection<T>
public defmulti add<?T> (v:Vector<?T>, value:T) -> False
public defmulti add-all<?T> (v:Vector<?T>, vs:Seqable<T>) -> False
public defmulti clear (v:Vector) -> False
public defmulti pop<?T> (v:Vector<?T>) -> T
public defmulti peek<?T> (v:Vector<?T>) -> T

public defmulti remove (v:Vector, i:Int) -> False
public defmulti remove (v:Vector, r:Range) -> False
public defmulti update<?T> (f: T -> Maybe<T>, v:Vector<?T>) -> False
public defmulti remove-item<?T> (v:Vector<?T&Equalable>, x:T&Equalable) -> False
public defmulti remove-when<?T> (f: T -> True|False, v:Vector<?T>) -> False
public defmulti trim (v:Vector, size:Int) -> False
public defmulti set-length<?T> (v:Vector<?T>, length:Int, x:T) -> False

;                   Implementation
;                   ==============

public defn Vector<T> (cap:Int) -> Vector<T> :
   core/ensure-non-negative("capacity", cap)
   var array = Array<T>(cap)
   var size = 0

   defn ensure-capacity (c:Int) :
      defn set-capacity (c:Int) :
         val new-array = Array<T>(c)
         new-array[0 to size] = array
         array = new-array
      val cur-c = length(array)
      set-capacity(max(c, 2 * cur-c)) when c > cur-c

   new Vector<T> :
      defmethod get (this, i:Int) :
         core/ensure-index-in-bounds(this, i)
         array[i]

      defmethod set (this, i:Int, value:T) :
         if i == size :
            add(this, value)
         else :
            core/ensure-index-in-bounds(this, i)
            array[i] = value

      defmethod length (this) :
         size

      defmethod set-length (this, len:Int, value:T) :
         core/ensure-non-negative("length", len)
         if len > size :
            add-all(this, repeat(value, len - size))
         else :
            trim(this, len)

      defmethod trim (this, new-size:Int) :
         if new-size > size :
            fatal("Given size (%_) is larger than current size (%_)." % [new-size, size])
         size = new-size

      defmethod add (this, value:T) :
         ensure-capacity(size + 1)
         array[size] = value
         size = size + 1

      defmethod add-all (this, vs:Seqable<T>) :
         match(vs) :
            (vs:Seqable<T> & Lengthable) :
               val n = length(vs)
               ensure-capacity(size + n)
               array[size to (size + n)] = vs
               size = size + n
            (vs) :
               do(add{this, _}, vs)

      defmethod pop (this) :
         fatal("Empty Vector") when size == 0
         size = size - 1
         array[size]

      defmethod peek (this) :
         fatal("Empty Vector") when size == 0
         array[size - 1]

      defmethod clear (this) :
         size = 0

      defmethod remove-when (f: T -> True|False, this) :
         for x in this update :
            if f(x) : None()
            else : One(x)

      defmethod remove (this, i:Int) :
         core/ensure-index-in-bounds(this, i)
         for i in i to (size - 1) do :
            array[i] = array[i + 1]
         size = size - 1

      defmethod remove (this, r:Range) :
         core/ensure-index-range(this, r)
         val [s,e] = core/range-bound(this, r)
         val n = e - s
         if n > 0 :
            for i in s to (size - n) do :
               array[i] = array[i + n]
            size = size - n

      defmethod remove-item (this:Vector<T&Equalable>, x:T&Equalable) :
         match(index-of(this, x)) :
            (i:Int) : remove(this, i)
            (i:False) : false

      defmethod update (f: T -> Maybe<T>, this) :
         defn* loop (dst:Int, src:Int) :
            if src < size :
               match(f(array[src])) :
                  (x:One<T>) :
                     array[dst] = value(x)
                     loop(dst + 1, src + 1)
                  (x:None) :
                     loop(dst, src + 1)
            else :
               size = dst
         loop(0, 0)

public defn Vector<T> () -> Vector<T> :
   Vector<T>(8)

public defn to-vector<T> (xs:Seqable<T>) -> Vector<T> :
   val v = Vector<T>()
   add-all(v, xs)
   v

public defn map<R,?T> (f: T -> R, v:Vector<?T>) -> Vector<R> :
   val ret = Vector<R>(length(v))
   add-all(ret, seq(f, v))
   ret


;============================================================
;====================== Queues ==============================
;============================================================

;                      Interface
;                      =========

public deftype Queue<T> <: IndexedCollection<T>
public defmulti add<?T> (q:Queue<?T>, x:T) -> False
public defmulti clear (q:Queue) -> False
public defmulti pop<?T> (q:Queue<?T>) -> T
public defmulti peek<?T> (q:Queue<?T>) -> T

;                    Implementation
;                    ==============

public defn Queue<T> (initial-cap:Int) -> Queue<T> :
   core/ensure-non-negative("capacity", initial-cap)
   var cap:Int = next-pow2(initial-cap)
   var array:Array<T> = Array<T>(cap)
   var begin:Int = 0
   var size:Int = 0

   defn ensure-capacity (c:Int) :
      defn set-capacity (c:Int) :
         val new-array = Array<T>(c)
         for i in 0 to size do :
            new-array[i] = array[wrapped-index(i)]
         array = new-array
         cap = c
         begin = 0
      if c > cap :
         set-capacity(next-pow2(max(c, cap)))

   defn wrapped-index (i:Int) :
      (begin + i) & (cap - 1)

   new Queue<T> :
      defmethod get (this, i:Int) :
         core/ensure-index-in-bounds(this, i)
         array[wrapped-index(i)]
         
      defmethod set (this, i:Int, value:T) :
         if i == -1 :
            add(this, value)
         else :
            core/ensure-index-in-bounds(this, i)
            array[wrapped-index(i)] = value

      defmethod add (this, x:T) :
         ensure-capacity(size + 1)
         begin = wrapped-index(cap - 1)
         array[begin] = x
         size = size + 1

      defmethod pop (this) :
         fatal("Empty Queue") when size == 0
         val x = array[begin]
         size = size - 1
         begin = wrapped-index(1)
         x
         
      defmethod peek (this) :
         fatal("Empty Queue") when size == 0
         array[begin]

      defmethod length (this) :
         size

      defmethod clear (this) :
         size = 0

public defn Queue<T> () -> Queue<T> :
   Queue<T>(8)


;============================================================
;====================== Tables ==============================
;============================================================

;                     Interface
;                     =========

public deftype Table<K,V> <: Many<KeyValue<K,V>> & Lengthable
public defmulti set<?K,?V> (t:Table<?K,?V>, k:K, v:V) -> False
public defmulti get?<?K,?V,?D> (t:Table<?K,?V> k:K, d:?D) -> V|D
public defmulti get<?K,?V> (t:Table<?K,?V>, k:K) -> V
public defmulti key?<?K> (t:Table<?K,?>, k:K) -> True|False
public defmulti keys<?K> (t:Table<?K,?>) -> Seqable<K>
public defmulti values<?V> (t:Table<?,?V>) -> Seqable<V>
public defmulti remove<?K> (t:Table<?K,?>, k:K) -> True|False
public defmulti clear (t:Table) -> False

;              Abstract Implementations
;              ========================

defmethod keys<?K> (t:Table<?K,?>) : seq(key, t)
defmethod values<?K> (t:Table<?K,?>) : seq(value, t)

public defn empty? (t:Table) :
   length(t) == 0

;============================================================
;==================== Hash Tables ===========================
;============================================================

public deftype HashTable<K,V> <: Table<K,V>
defmulti double-capacity (t:HashTable) -> False

public defn HashTable<K,V> (hash: K -> Int, default:Maybe<V>, initial-capacity:Int) -> HashTable<K,V> :
   var cap = next-pow2(max(32, initial-capacity))
   var keys = Array<K|Sentinel>(cap, new Sentinel)
   var values = Array<V|Sentinel>(cap, new Sentinel)
   var size = 0
   var num-keys = 0

   defn key-index (k:K&Equalable) -> Int :
      defn key-slot (k:K, i:Int) -> Int :
         (hash(k) + i) & (cap - 1)      
      for i in 0 to cap first! :
         val s = key-slot(k, i)
         match(keys[s]) :
            (k2:Sentinel) :
               One(s)
            (k2:K&Equalable) :
               if k == k2 : One(s)
               else : None()

   new HashTable<K,V> :
      defmethod double-capacity (this) :
         val entries = to-seq(this)
         cap = cap * 2
         keys = Array<K|Sentinel>(cap, new Sentinel)
         values = Array<V|Sentinel>(cap, new Sentinel)
         size = 0
         num-keys = 0
         for entry in entries do :
            this[key(entry)] = value(entry)
            
      defmethod clear (this) :
         keys[0 to false] = repeat(new Sentinel)
         values[0 to false] = repeat(new Sentinel)
         size = 0
         num-keys = 0
      
      defmethod set (this, hashkey:K, v:V) :
         fatal("Key %_ does not implement Equalable.") when hashkey not-typeof K&Equalable
         
         ;Get key index
         val k = hashkey as K&Equalable
         val i = key-index(k)
         
         ;Set key
         if keys[i] typeof Sentinel :
            keys[i] = k
            num-keys = num-keys + 1            
               
         ;Set value
         if values[i] typeof Sentinel :
            size = size + 1
         values[i] = v

         ;Ensure capacity
         val limit = (cap * 3) >>> 2
         double-capacity(this) when num-keys > limit
         
      defmethod get?<?D> (this, k:K&Equalable, d:?D) :
         val i = key-index(k)
         match(values[i]) :
            (v:Sentinel) : d
            (v:V) : v

      defmethod get (this, k:K&Equalable) :
         val i = key-index(k)
         match(values[i]) :
            (v:Sentinel) :
               match(default) :
                  (d:One<V>) : value(d)
                  (d:None) : fatal("Key %_ does not exist in table." % [k])
            (v:V) : v

      defmethod remove (this, k:K&Equalable) :
         val i = key-index(k)
         match(values[i]) :
            (v:Sentinel) :
               false
            (v:V) :
               values[i] = new Sentinel
               size = size - 1
               num-keys = num-keys - 1
               true

      defmethod key? (this, k:K&Equalable) :
         val i = key-index(k)
         values[i] not-typeof Sentinel

      defmethod length (this) :
         size
         
      defmethod to-seq (this) :
         for (k in keys, v in values) seq? :
            if v not-typeof Sentinel : One((k as K) => (v as V))
            else : None()    

public defn HashTable<K,V> (hash: K -> Int, default:V) :
   HashTable<K,V>(hash, One(default), 32)

public defn HashTable<K,V> (hash: K -> Int) :
   HashTable<K,V>(hash, None(), 32)

public defn HashTable<K,V> (default:V) :
   HashTable<K&Hashable,V>(hash, One(default), 32)

public defn HashTable<K,V> () :
   HashTable<K&Hashable,V>(hash, None(), 32)

defmethod print (o:OutputStream, h:HashTable) :
   val entries = to-seq(h)
   print(o, "[")
   if not empty?(entries) :
      print(o, next(entries))
   while not empty?(entries) :
      print(o, " ")
      print(o, next(entries))
   print(o, "]")
      