;See License.txt for details about licensing.

defpackage macro-utils :
   import core
   import collections

;================= PUBLIC INTERFACE ========================
public defn splice (item:Seqable|Token) :
   SpliceTemplate(to-list(unwrap-token(item)))

public defn nested (items:Seqable<Seqable<KeyValue<Symbol,?>>>) :
   NestedTemplate(to-list(items))

public defn choice (n:Int) :
   ChoiceTemplate(n)
public defn choice (b:True|False) :
   ChoiceTemplate(0 when b else 1)

public defn collect (entries: Seqable<KeyValue<Symbol, Seqable>>) :
   ;Collect keys and values
   val keys = Vector<Symbol>()
   val values = Vector<Vector<?>>()
   for entry in entries do :
      add(keys, key(entry))
      add(values, to-vector<?>(value(entry)))

   if empty?(keys) :
      nested(List())
   else :      
      ;Ensure that all values have same length
      val n = length(values[0])
      if not all?({length(_) == n}, values) :
         fatal("All entries in a collect template must have same length.")
    
      ;Make templates
      nested $ for i in 0 to n seq :
         to-list $ for (k in keys, v in values) seq :
            k => v[i]

;================== UTILITIES ==============================   
public defn tagged-list? (form, tag:Symbol) -> True|False :
   match(form) :
      (t:Token) : tagged-list?(item(t), tag)
      (t:FullList) : unwrap-token(head(t)) == tag
      (t) : false

defstruct Sentinel
   
;================== TEMPLATES ==============================   
defstruct SpliceTemplate :
   item:List   

defstruct NestedTemplate :
   items:List<Seqable<KeyValue<Symbol,?>>>   

defstruct ChoiceTemplate :
   selection: Int

;================ FILL INTERPRETER =========================
public defn fill-template (template, replacements: Seqable<KeyValue<Symbol,?>>) -> ? :
   ;=== Choice ===
   defn following-do-afns (xs:List) -> [List<List>, List] :
      if empty?(xs) :
         [List(), xs]
      else if tagged-list?(head(xs), `@do-afn) :
         val x = tail(unwrap-token(head(xs)))
         val [xs, rest] = following-do-afns(tail(xs))
         [cons(x,xs), rest]
      else :
         [List(), xs]

   defn select-choice (t:ChoiceTemplate, xs:List) -> [List, List] :
      val [forms, rest*] = following-do-afns(xs)
      if selection(t) >= length(forms) :
         fatal("ChoiceTemplate index is out of bounds.")
      val filled = fill-template(forms[selection(t)], replacements)
      [filled, rest*]   

   ;=== Nested Template ===
   defn replace-nested (t:NestedTemplate, rest:List) -> [List, List] :
      if (not empty?(rest)) and tagged-list?(head(rest), `@do-afn) :
         val form = tail(unwrap-token(head(rest)))
         val rest* = tail(rest)
         val filled = for r in items(t) seq-append :
            val r* = to-list(cat(r, replacements))
            fill-template(form, r*)
         [filled, rest*]   
      else :
         fatal("Nested keyword is not followed with a template.")
         
   ;=== Processing Loop ===
   val flag = Sentinel()
   defn get-template (x) :
      match(unwrap-token(x)) :
         (x:Symbol) :
            val e = lookup?(replacements, x, flag)
            [e not-typeof Sentinel, e]
         (x) :
            [false, false]
         
   defn loop (form) -> ? :
      match(form) :
         (t:Token) :
            Token(loop(item(t)), info(t))
         (xs:FullList) :
            val [t?, t] = get-template(head(xs))
            val rest = tail(xs)
            if t? :
               match(t) :
                  (t:SpliceTemplate) :
                     append(item(t), loop(rest))
                  (t:NestedTemplate) :
                     val [x*, rest*] = replace-nested(t, rest)
                     append(x*, loop(rest*))
                  (t:ChoiceTemplate) :
                     val [x*, rest*] = select-choice(t, rest)
                     append(x*, loop(rest*))
                  (t) :
                     cons(t, loop(rest))
            else :
               cons(loop(head(xs)), loop(rest))
         (x) :
            x
   loop(template)