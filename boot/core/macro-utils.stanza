;See License.txt for details about licensing.

defpackage macro-utils :
   import core
   import collections

;============================================================
;=================== Public Interface =======================
;============================================================

public defn splice (item:Many|Token) :
   match(unwrap-token(item)) :
      (x:Many) : SpliceTemplate(x)
      (x) : fatal("Splicing operator requires a Many.")   

public defn nested (items:Many<Many<KeyValue<Symbol,?>>>) :
   NestedTemplate(items)

public defn choice (n:Int) :
   ChoiceTemplate(n)
   
public defn choice (b:True|False) :
   ChoiceTemplate(0 when b else 1)

public defn collect (entries: Seqable<KeyValue<Symbol, Seqable>>) :
   ;Collect keys and values
   val keys = Vector<Symbol>()
   val values = Vector<Vector<?>>()
   for entry in entries do :
      add(keys, key(entry))
      add(values, to-vector<?>(value(entry)))

   if empty?(keys) :
      nested(List())
   else :      
      ;Ensure that all values have same length
      val n = length(values[0])
      if not all?({length(_) == n}, values) :
         fatal("All entries in a collect template must have same length.")
    
      ;Make templates
      nested $ to-list $ for i in 0 to n seq :
         to-list $ for (k in keys, v in values) seq :
            k => v[i]

public defn fill-template (template, replacements:Many<KeyValue<Symbol,?>>) :
   fill(template, to-list(replacements))

;============================================================
;=================== Utilities ==============================
;============================================================

defn tagged-list? (form, tag:Symbol) -> True|False :
   match(form) :
      (t:Token) : tagged-list?(item(t), tag)
      (t:FullList) : unwrap-token(head(t)) == tag
      (t) : false

defstruct Sentinel

;============================================================
;=================== Templates ==============================
;============================================================
   
defstruct SpliceTemplate :
   item: Many   

defstruct NestedTemplate :
   items: Many<Many<KeyValue<Symbol,?>>>   

defstruct ChoiceTemplate :
   selection: Int

;============================================================
;=================== Fill Interpreter =======================
;============================================================

defn fill (template, replacements:List<KeyValue<Symbol,?>>) -> ? :
   ;                     Choice
   ;                     ======
   defn following-do-afns (xs:List) -> [List<List>, List] :
      if empty?(xs) :
         [List(), xs]
      else if tagged-list?(head(xs), `@do-afn) :
         val x = tail(unwrap-token(head(xs)))
         val [xs, rest] = following-do-afns(tail(xs))
         [cons(x,xs), rest]
      else :
         [List(), xs]

   defn select-choice (t:ChoiceTemplate, xs:List) -> [List, List] :
      val [forms, rest*] = following-do-afns(xs)
      if selection(t) >= length(forms) :
         fatal("ChoiceTemplate index (%_) is out of bounds." % [selection(t)])
      val filled = fill(forms[selection(t)], replacements)
      [filled, rest*]   

   ;                 Nested Template
   ;                 ===============
   defn replace-nested (t:NestedTemplate, rest:List) -> [List, List] :
      if (not empty?(rest)) and tagged-list?(head(rest), `@do-afn) :
         val form = tail(unwrap-token(head(rest)))
         val rest* = tail(rest)
         val filled = for env in items(t) seq-append :
            fill(form, append(env, replacements))
         [filled, rest*]   
      else :
         fatal("Nested keyword is not followed with a template.")
         
   ;                 Processing Loop
   ;                 ===============
   defn get-template (x) -> Maybe :
      match(unwrap-token(x)) :
         (x:Symbol) :
            val e = lookup?(replacements, x, Sentinel())
            if e typeof Sentinel : None()
            else : One(e)
         (x) : None()
         
   defn loop (form) -> ? :
      match(form) :
         (t:Token) :
            Token(loop(item(t)), info(t))
         (xs:FullList) :
            val rest = tail(xs)
            match(get-template(head(xs))) :
               (t:One) :
                  match(value(t)) :
                     (t:SpliceTemplate) :
                        append(item(t), loop(rest))
                     (t:NestedTemplate) :
                        val [x*, rest*] = replace-nested(t, rest)
                        append(x*, loop(rest*))
                     (t:ChoiceTemplate) :
                        val [x*, rest*] = select-choice(t, rest)
                        append(x*, loop(rest*))
                     (t) :
                        cons(t, loop(rest))                     
               (t:None) :
                  cons(loop(head(xs)), loop(rest))               
         (x) :
            x

   ;                     Driver
   ;                     ======
   loop(template)