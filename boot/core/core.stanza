defpackage core

;============================================================
;================== Core Types ==============================
;============================================================

public :
   deftype Seqable<T>                   ;DONE
   deftype Seq<T> <: Seqable<T>         ;DONE
   deftype Many<T> <: Seqable<T>        ;DONE

   deftype Lengthable                   ;DONE

   deftype Eqable                       ;DONE

   deftype Hashable                     ;DONE

   deftype OutputStream                 ;DONE

   lostanza deftype FileOutputStream <: OutputStream :   ;DONE
      file: ptr<?>
      closable?: long
   
   deftype Maybe<T> 
   defstruct None <: Maybe<Void> & Eqable
   defstruct One<T> <: Maybe<T> & Eqable :
      value: T

   deftype Coroutine<I,O> <: Eqable

   deftype Range <: Many<Int> & Eqable

   lostanza deftype Byte <: Eqable :
      value: byte

   lostanza deftype Char <: Eqable :
      value: byte
      
   lostanza deftype Int <: Eqable :
      value: int
      
   lostanza deftype Long <: Eqable :
      value: long
      
   lostanza deftype Float <: Eqable :
      value: float

   lostanza deftype Double <: Eqable :
      value: double
      
   lostanza deftype String <: Lengthable & Many<Char> & Eqable :
      length: long
      hash: int
      chars: byte ...

   ;deftype Symbol <: Lengthable & Many<Char> & Eqable

   deftype List<T> <: Lengthable & Many<T> & Eqable
   lostanza deftype FullList<T> <: List<T> :
      head: ref<T>
      tail: ref<List<T>>
   lostanza deftype NilList <: List<Void>

   lostanza deftype True <: Eqable
   lostanza deftype False <: Eqable
  
   lostanza deftype Tuple<T> <: Lengthable & Many<T> & Eqable & Hashable :
      length: long
      items: ref<T> ...

   deftype Array<T> <: Lengthable & Many<T> & Eqable

   deftype CharArray <: Array<Char>

   deftype StringBuffer <: Lengthable & Many<Char> & Eqable & OutputStream
   
   deftype FileInfo <: Eqable & Hashable

   deftype Exception

;============================================================
;================ Internal Types ============================
;============================================================

lostanza deftype Fn :
   code: ptr<?>
   free: ref<?> ...      
lostanza deftype Box :
   item: ref<?>
lostanza deftype Type :
   code: ptr<?>
   free: ref<?> ...
lostanza deftype Stack :
   position: int
   mark: int
   parent: ref<False|Stack>
   sp: ptr<?>
   frames: StackFrame ...
lostanza deftype StackFrame :
   ret: ptr<?>
   map: ptr<RefMap>
   items: long ...
lostanza deftype RefMap :
   length: long
   bits: long ...
lostanza deftype FileInfoTable :
   length: long
   entries: FileInfoEntry ...
lostanza deftype FileInfoEntry :
   lbl: ptr<?>
   file: ptr<byte>
   line: int
   column: int

;============================================================
;============== Private External Functions ==================
;============================================================
      
extern fclose: (ptr<?>) -> int
extern fputs: (ptr<byte>, ptr<?>) -> int
extern putc: (byte, ptr<?>) -> int
extern fprintf: (ptr<?>, ptr<byte>, ? ...) -> int
extern printf: (ptr<byte>, ? ...) -> int
extern malloc: long -> ptr<?>
extern free: ptr<?> -> int
extern exit: int -> int
extern get_stdout: () -> ptr<?>
extern get_stderr: () -> ptr<?>

;============================================================
;==================== Initialization ========================
;============================================================

lostanza defn initialize-stanza () -> ref<False> :
   initialize-stacks()
   initialize-heaps()
   initialize-constants()
   return false

initialize-stanza()

;                  Stack Initialization
;                  ====================

extern stanza_stack_size: long
lostanza var num-stacks:long

lostanza defn parent (s:ref<Stack>) -> ref<Stack> :
   return s.parent as ref<Stack>

lostanza defn initialize-stacks () -> int :
   ;Create stack pool
   num-stacks = 1024
   val pool:ptr<ref<Stack>> = call-c malloc(sizeof(ref<?>) * num-stacks)
   for (var i:int = 1, i < num-stacks, i = i + 1) :
      val p:ptr<long> = call-c malloc(stanza_stack_size)
      [p] = tagof(Stack) << 3 
      val s = (p + 1) as ref<Stack>
      s.position = i << 3
      s.mark = 0
      pool[i] = s

   ;Initialize current stack
   val s = call-prim stack()
   val p = (addr([s]) - 8) as ptr<long>
   [p] = tagof(Stack) << 3
   s.position = 0
   s.mark = 0
   s.parent = false
   pool[0] = s

   ;Tell Stanza about stack pool
   call-prim set-num-free-stacks(num-stacks - 1)
   call-prim set-free-stacks(addr(pool[1]))
   call-prim set-stack-pool(pool)

   return 0

;                 Heap Initialization
;                 ===================

lostanza var mem-size:long
lostanza var heap-mem:ptr<long> 
lostanza var free-mem:ptr<long>
lostanza var free-ptr:ptr<long>
lostanza defn initialize-heaps () -> int :
   mem-size = 1024 * 1024
   heap-mem = call-c malloc(mem-size)
   free-mem = call-c malloc(mem-size)
   call-prim set-heap(heap-mem)
   call-prim set-heap-limit(heap-mem + mem-size)
   return 0

;                  Constant Initialization
;                  =======================

lostanza var const-ptr:ptr<?>
lostanza defn initialize-constants () -> int :
   ;Initialize read pointer to beginning of the constant table
   ;[num, constants ...]
   const-ptr = call-prim constant-table()
   val n-consts = read-const-int()
   
   ;First n-consts entries in the global table are for constants
   var gs:ptr<ref<?>> = call-prim globals()
   for (var i:int = 0, i < n-consts, i = i + 1) :
      gs[i] = read-const()   
   
   return 0
   
lostanza defn read-const () -> ref<?> :
   val tag = read-const-int()
   if tag == tagof(Byte) :
      return new Byte{read-const-byte()}
   else if tag == tagof(Char) :
      return new Char{read-const-byte()}      
   else if tag == tagof(Int) :
      return new Int{read-const-int()}
   else if tag == tagof(Long) :
      return new Long{read-const-long()}
   else if tag == tagof(Float) :
      return new Float{read-const-float()}
   else if tag == tagof(Double) :
      return new Double{read-const-double()}
   else if tag == tagof(True) :
      return true
   else if tag == tagof(False) :
      return false
   else if tag == tagof(FullList) :
      val len = read-const-int()
      return read-const-list(len)
   else if tag == tagof(String) :
      val len = read-const-long()
      val chars = read-const-chars(len)
      return String(len, chars)
   else if tag == tagof(Symbol) :
      val len = read-const-long()
      val chars = read-const-chars(len)
      return Symbol(len, chars)
   else :   
      call-c printf("Unknown constant tag: %ld\n", tag)      
      return fatal("Unknown constant tag")

lostanza defn read-const-list (n:int) -> ref<List> :
   if n == 0 : return new NilList{}
   else : return new FullList{read-const(), read-const-list(n - 1)}

lostanza defn read-const-byte () -> byte :
   val value = [const-ptr as ptr<byte>]
   const-ptr = const-ptr + sizeof(byte)
   return value

lostanza defn read-const-int () -> int :
   val value = [const-ptr as ptr<int>]
   const-ptr = const-ptr + sizeof(int)
   return value

lostanza defn read-const-long () -> long :
   val value = [const-ptr as ptr<long>]
   const-ptr = const-ptr + sizeof(long)
   return value

lostanza defn read-const-float () -> float :
   val value = [const-ptr as ptr<float>]
   const-ptr = const-ptr + sizeof(float)
   return value

lostanza defn read-const-double () -> double :
   val value = [const-ptr as ptr<double>]
   const-ptr = const-ptr + sizeof(double)
   return value

lostanza defn read-const-chars (len:long) -> ptr<byte> :
   val value = const-ptr as ptr<byte>
   ;length chars + 0 character + pad to nearest 4 bytes
   val n = (len + 4) & -4
   const-ptr = (const-ptr + n) as ptr<?>
   return value

;============================================================
;============== Generated Entry Points ======================
;============================================================

lostanza defn cast-error () -> ref<Void> :
   return fatal("Cannot cast value to type.", call-prim sp())

lostanza defn arity-error () -> ref<Void> :
   return fatal("Wrong number of arguments.", call-prim sp())

lostanza defn branch-error () -> ref<Void> :
   return fatal("Ambiguous or no matching branch.", call-prim sp())

lostanza defn variable-uninitialized-error () -> ref<Void> :
   return fatal("Variable is uninitialized.", call-prim sp())

;============================================================
;================== Stack Traces ============================
;============================================================

lostanza var trace-buffer:ptr<ptr<FileInfoEntry>>
lostanza var trace-size:int
lostanza val null:ptr<?> = 0 as long as ptr<?>

lostanza defn print-stack-trace (end:ptr<?>) -> ref<False> :
   ;Allocate space for storing trace
   ;No trace can be larger than the size of a stack
   trace-buffer = call-c malloc(stanza_stack_size)
   
   ;Print trace starting from current stack
   print-stack-trace(call-prim stack(), end)
   
   ;Free trace buffer and return
   call-c free(trace-buffer)   
   return false

lostanza defn* print-stack-trace (s:ref<Stack>, end:ptr<?>) -> int :
   ;Store trace into buffer
   trace-size = 0
   val f0 = s.frames + frame-size(s.frames) ;Skip intercepted return frame
   store-stack-trace(f0, end)
   
   ;Print out trace
   for (var i:int = trace-size - 1, i >= 0, i = i - 1) :
      val e = trace-buffer[i]
      if e == null :
         call-c printf("   at [Unknown Source Location]\n")
      else :
         call-c printf("   at %s:%d.%d\n", e.file, e.line, e.column)

   ;Print parent stack trace
   match(s.parent) :
      (p:ref<Stack>) : return print-stack-trace(p, p.sp)
      (p:ref<False>) : return 0

lostanza defn* store-stack-trace (stacks:ptr<StackFrame>, end:ptr<?>) -> int :
   ;Store the return address into trace buffer
   trace-buffer[trace-size] = info-entry(stacks.ret)
   trace-size = trace-size + 1

   ;Continue tracing next frame unless end is reached.
   if stacks == end :
      return 0
   else :
      val sz = frame-size(stacks)
      return store-stack-trace(stacks + sz, end)

lostanza defn frame-size (s:ptr<StackFrame>) -> long :
   val map = s.map
   return sizeof(StackFrame) + s.map.length * sizeof(long)

lostanza defn info-entry (p:ptr<?>) -> ptr<FileInfoEntry> :
   val table = call-prim info-table() as ptr<FileInfoTable>
   for (var i:long = 0, i < table.length, i = i + 1) :
      val e = table.entries[i]
      if e.lbl == p :
         return addr(table.entries[i])
   return null

;============================================================
;===================== Errors ===============================
;============================================================

public lostanza defn* fatal (msg: ptr<byte>) -> ref<Void> :
   return fatal(msg, call-prim sp())

public lostanza defn fatal (msg: ptr<byte>, sp:ptr<?>) -> ref<Void> :
   call-c printf("FATAL ERROR: %s\n", msg)
   print-stack-trace(sp)
   call-c exit(-1)
   return null as ref<Void>

;============================================================
;=============== Garbage Collector ==========================
;============================================================

;              Generated Entry Points
;              ======================

;Called when attempting to allocate beyond the heap limit.
lostanza defn extend-heap (sz:long) -> int :
   new-stack<int>{run-garbage-collector()}
   if call-prim heap() + sz > call-prim heap-limit() :
      fatal("Out of heap memory", call-prim sp())
   return 0

;Called when the number of free stacks is 2 or less.
;Running extend-stack uses two stacks (1 for GC, 1 for handling extend-stack during GC).
lostanza defn extend-stack () -> int :
   if gc-running :
      fatal("Stack overflow in garbage collector")
      return 0
   else :
      new-stack<int>{run-garbage-collector()}
      if call-prim num-free-stacks() <= 2 :
         fatal("Stack overflow", call-prim sp())
      return 0

;                   Main Function
;                   =============

;Main function for garbage collector
lostanza var gc-running:long = 0
lostanza defn run-garbage-collector () -> int :
   call-c printf("RUNNING GARBAGE COLLECTOR\n")
   ;Mark GC as running to detect stack extension within GC
   gc-running = 1

   ;Initialize free pointer to point to beginning of free memory before copying starts.
   free-ptr = free-mem

   ;Current stack is the collection stack, the stack that the GC runs in.
   ;Set its mark bit to indicate that it is active.
   val collection-stack = call-prim stack()
   collection-stack.mark = 1

   ;Scan roots
   scan-globals()
   scan-stack(parent(collection-stack))

   ;Scan internal pointers of all heap objects
   scan-heap()

   ;Swap free memory with heap
   val swap = heap-mem
   heap-mem = free-mem
   free-mem = swap
   call-prim set-heap(free-ptr)
   call-prim set-heap-limit(heap-mem + mem-size)

   ;All active stacks have their mark bits set.
   free-unmarked-stacks()

   ;Finish
   call-c printf("DONE RUNNING GARBAGE COLLECTOR\n")
   gc-running = 0   
   return 0

;                 Scanning Functions
;                 ==================

;Copy all global references to the free memory.
lostanza defn scan-globals () -> int :
   ;Get tables
   val globals = call-prim globals() as ptr<long>
   val map = call-prim global-map() as ptr<RefMap>
   ;Scan globals
   scan-map-words(map.bits, map.length, globals)   
   return 0
   
;Copy all stack references in this and parent stacks to free memory.
lostanza defn* scan-stack (s:ref<Stack>) -> int :
   if s.mark == 0 :
      s.mark = 1
      scan-stack-frames(s.frames, s.sp)
      match(s.parent) :
         (p:ref<Stack>) : return scan-stack(p)
         (p:ref<False>) : return 0
   else :      
      return 0

;Copy all internal references in heap to free memory.
lostanza defn scan-heap () -> int :
   var p: ptr<long> = free-mem
   while p < free-ptr :
      val tagbits = [p] & 3
      if tagbits == 0 :
         p = scan-object(p)
      else if tagbits == 1 :
         p = scan-array(p)
      else :
         call-c printf("Invalid tag bits in heap: %lx\n", tagbits)
         call-c exit(-1)
         return 0
   return 0      

;Copy all internal references in object to free memory.
lostanza defn scan-object (p:ptr<long>) -> ptr<long> :
   ;p is [tag-word, cells ...]   
   val tag = p[0] >>> 3
   val map = object-map(tag)
   scan-map-words(base-bits(map), base-nwords(map), p + 8)
   return p + 8 + map.base-size

;Copy all internal references in array to free memory.
lostanza defn scan-array (p:ptr<long>) -> ptr<long> :
   ;p is [len-word, tag-word, cells ...]
   val len = p[0] >>> 3
   val tag = p[1] >>> 3
   
   ;Calculate the total size of object, rounding up to nearest 8 bytes
   val map = object-map(tag)
   val bytes = ((map.base-size + map.tail-size * len) + 7) & -8   

   ;Scan base of array
   scan-map-words(base-bits(map), base-nwords(map), p + 16)
   
   ;Scan tail of array if it contains references.
   if tail-refs?(map) :
      var tail:ptr<long> = p + 16 + map.base-size
      val tbits = tail-bits(map)
      val tnwords = tail-nwords(map)
      for (var i:long = 0, i < len, i = i + 1) :
         scan-map-words(tbits, tnwords, tail)
         tail = tail + map.tail-size

   ;Return end of array
   return p + 16 + bytes

;Copy all internal references in stack frames, fs, until end pointer
lostanza defn* scan-stack-frames (fs:ptr<StackFrame>, end:ptr<?>) -> int :
   if fs < end :
      val map = [fs].map
      scan-map-words(map.bits, map.length, [fs].items)
      val next-fs = addr([fs].items[map.length]) as ptr<StackFrame>
      return scan-stack-frames(next-fs, end)
   else :   
      return 0

;Scan n references (marked with a 1 bit) from the given pointer
lostanza defn* scan-map-words (map:ptr<long>, n:long, refs:ptr<long>) -> int :
   if n > 64 :
      scan-map-word([map], 64, refs)
      return scan-map-words(addr(map[1]), n - 64, addr(refs[1]))
   else if n > 0 :
      scan-map-word([map], n, refs)
      return 0
   else :
      return 0

lostanza defn scan-map-word (map:long, n:long, refs:ptr<long>) -> int :
   var ref-ptr:ptr<long> = refs
   for (var i:long = 0, i < n, i = i + 1) :
      val b = (map >> i) & 1
      if b : [ref-ptr] = post-gc-object([ref-ptr])
      ref-ptr = ref-ptr + sizeof(long)
   return 0

;                Copying Functions
;                =================

lostanza defn post-gc-object (obj:long) -> long :
   val tagbits = obj & 3
   if tagbits == 1 :
      val obj-ptr = (obj - tagbits) as ptr<long>
      val tag = obj-ptr[0] >>> 3
      
      ;If broken heart, then return forwarding pointer
      if tag == -1 :
         return obj-ptr[1]
      ;Otherwise, copy object
      else :
         val map = object-map(tag)
         if tag == tagof(Stack) :
            scan-stack(obj as ref<Stack>)
            return obj
         else if finite?(map) :
            val obj* = copy-object-to-free(obj-ptr, map.base-size) + tagbits
            set-broken-heart(obj-ptr, obj*)
            return obj*
         else :
            val obj* = copy-array-to-free(obj-ptr, map.base-size, map.tail-size) + tagbits
            set-broken-heart(obj-ptr, obj*)
            return obj*
   else :
      return obj

lostanza defn set-broken-heart (old:ptr<long>, new:long) -> int :
   old[0] = -1
   old[1] = new
   return 0
      
lostanza defn copy-object-to-free (obj:ptr<long>, size:long) -> long :
   val ret = free-ptr
   copy-bytes-to-free(obj, size + 8)
   return ret as long

lostanza defn copy-array-to-free (obj:ptr<long>, size:long, tail:long) -> long :
   ;obj: [len, tag, items ...]   
   ;Returned pointer points to the tag word
   val ret = free-ptr + 8   
   val length = obj[-1] >>> 3
   
   ;Calculate the total size of object, rounding up to nearest 8 bytes
   val bytes = ((size + tail * length) + 7) & -8
   
   ;Copy the bytes to free including header
   copy-bytes-to-free(obj - 8, bytes + 16)
   
   return ret as long

lostanza defn copy-bytes-to-free (p:ptr<long>, n:long) -> int :
   if n & 3 != 0 :
      call-c exit(-1)
   val nwords = n >>> 3
   for (var i:long = 0, i < nwords, i = i + 1) :
      free-ptr[i] = p[i]
   free-ptr = free-ptr + n
   return 0

;               Utilities for ObjectMap
;               =======================

lostanza deftype ObjectMap :
   base-size: int
   tail-size: int
   bits: long ...
   
lostanza defn object-map (tag:long) -> ptr<ObjectMap> :
   val table = call-prim object-table() as ptr<ptr<ObjectMap>>
   return table[tag]

lostanza defn finite? (m:ptr<ObjectMap>) -> long :
   return m.tail-size == 0 

lostanza defn base-bits (m:ptr<ObjectMap>) -> ptr<long> :
   return m.bits

lostanza defn base-nwords (m:ptr<ObjectMap>) -> long :
   return m.base-size >>> 3

lostanza defn tail-bits (m:ptr<ObjectMap>) -> ptr<long> :
   return addr(m.bits[base-nwords(m)])

lostanza defn tail-nwords (m:ptr<ObjectMap>) -> long :
   return m.tail-size >>> 3

lostanza defn tail-refs? (m:ptr<ObjectMap>) -> long :
   val n = tail-nwords(m)
   val bits = tail-bits(m)
   for (var i:long = 0, i < n, i = i + 1) :
      if bits[i] != 0 :
         return 1
   return 0

;                  Releasing Stacks
;                  ================

;Free an active stack, and add back to the free stack list.
lostanza defn free-stack (s:ref<Stack>) -> long :
   ;Ensure s is the last active stack
   val stk-pool = call-prim stack-pool()
   val last-stk = (call-prim free-stacks())[-1]
   if s != last-stk :
      ;Swap locations of last-stk with s
      [stk-pool + s.position] = last-stk
      [stk-pool + last-stk.position] = s
      ;Swap positions of last-stk with s
      val s-position = s.position
      s.position = last-stk.position
      last-stk.position = s-position
   ;Free last active stack
   call-prim set-num-free-stacks(call-prim num-free-stacks() + 1)
   call-prim set-free-stacks(call-prim free-stacks() - 8)   
   return 0

;Free all unmarked stacks.
lostanza defn free-unmarked-stacks () -> int :
   var stk-ptr:ptr<ref<Stack>> = call-prim stack-pool()
   while stk-ptr < call-prim free-stacks() :
      val s = [stk-ptr]
      if s.mark == 0 :
         free-stack(s)
      else :
         stk-ptr = stk-ptr + 8
      s.mark = 0
   return 0

;============================================================
;======================= Error ==============================
;============================================================

;TODO: Remove
lostanza defn fatal (msg: ref<String>) -> ref<Void> :
   return fatal(msg.chars)

;============================================================
;===================== Winders ==============================
;============================================================

defn fn-cons-0 (a: False|(() -> ?), b: False|(() -> ?)) -> False|(() -> ?) :
   match(a, b) :
      (a:False, b) : b
      (a, b:False) : a
      (a:() -> ?, b:() -> ?) : fn* () : (a(), b())

defn fn-cons-1 (a: False|(? -> ?), b: False|(? -> ?)) -> False|(? -> ?) :
   match(a, b) :
      (a:False, b) : b
      (a, b:False) : a
      (a:? -> ?, b:? -> ?) : fn* (x) : (a(x), b(x))

defn* call-if-function (f: False|(() -> ?)) :
   match(f) :
      (f:() -> ?) : f()
      (f:False) : false

defn* call-if-function (f: False|(? -> ?), x: ?) :
   match(f) :
      (f:? -> ?) : f(x)
      (f:False) : false

public lostanza defn dynamic-wind<?T> (in:ref<False|(() -> ?)>,
                                       body:ref<(() -> ?T)>,
                                       out:ref<False|(? -> ?)>) -> ref<T> :
   call-if-function(in)
   val w-in = current-coroutine.windin
   val w-out = current-coroutine.windout
   current-coroutine.windin = fn-cons-0(w-in, in)
   current-coroutine.windout = fn-cons-1(out, w-out)
   val result = [body]()
   current-coroutine.windin = w-in
   current-coroutine.windout = w-out
   call-if-function(out, true)
   return result

lostanza defn windin (c:ref<RawCoroutine>) -> ref<False|(() -> ?)> :
   match(c.parent) :
      (p:ref<RawCoroutine>) : return fn-cons-0(c.windin, windin(p))
      (p:ref<False>) : return c.windin

lostanza defn windout (c:ref<RawCoroutine>) -> ref<False|(? -> ?)> :
   match(c.parent) :
      (p:ref<RawCoroutine>) : return fn-cons-1(windout(p), c.windout)
      (p:ref<False>) : return c.windout

;============================================================
;===================== Coroutines ===========================
;============================================================

;                     Interface
;                     =========

public defmulti active? (c:Coroutine) -> True|False
public defmulti open? (c:Coroutine) -> True|False
public defmulti resume<?I,?O> (c:Coroutine<?I,?O>, x:I) -> O
public defmulti suspend<?I,?O> (c:Coroutine<?I,?O>, x:O) -> I
public defmulti break<?O> (c:Coroutine<?,?O>, x:O) -> Void
public defmulti close (c:Coroutine) -> False

;                   Raw Coroutines
;                   ==============

lostanza deftype RawCoroutine <: Coroutine :
   id: long
   parent: ref<False|RawCoroutine>
   top: ref<Stack|False>
   bottom: ref<Stack|False>
   windin: ref<False|(() -> ?)>
   windout: ref<False|(? -> ?)>
   status: long

;                  Wrapped Coroutines
;                  ==================

deftype WrappedCoroutine<I,O> <: Coroutine<I,O>
defmulti raw (c:WrappedCoroutine) -> RawCoroutine

public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
   var rc
   val c = new WrappedCoroutine<I,O> :
      defmethod active? (this) : active?(rc)
      defmethod open? (this) : open?(rc)
      defmethod resume (this, x:I) : resume(rc, x)
      defmethod suspend (this, x:O) : suspend(rc, x)
      defmethod break (this, x:O) : break(rc, x)
      defmethod close (this) : close(rc)
      defmethod equal? (this, b:WrappedCoroutine) : rc == raw(b)
      defmethod raw (this) : rc
   rc = RawCoroutine $ fn (rc, x0) :
      enter(c, x0)
   c
   
;                    Implementation
;                    ==============

lostanza deftype CoResult :
   value: ref<?>
   windout: ref<False|(? -> ?)>
   final?: ref<True|False>

lostanza val COROUTINE-ACTIVE:long = 0
lostanza val COROUTINE-CLOSED:long = 1
lostanza val COROUTINE-SUSPENDED:long = 2
lostanza val COROUTINE-OPEN:long = 3


lostanza var COROUTINE-COUNTER:long = 0
lostanza defn next-coroutine-id () -> long :
   val id = COROUTINE-COUNTER
   COROUTINE-COUNTER = COROUTINE-COUNTER + 1
   return id

lostanza var current-coroutine:ref<RawCoroutine> =
   new RawCoroutine{
      next-coroutine-id()
      false
      call-prim stack()
      call-prim stack()
      false
      false
      COROUTINE-ACTIVE}
   
lostanza defn RawCoroutine (enter: ref<((RawCoroutine, ?) -> ?)>) -> ref<RawCoroutine> :
   return new-stack<ref<RawCoroutine>>{setup-coroutine(enter)}

lostanza defmethod equal? (a:ref<RawCoroutine>, b:ref<RawCoroutine>) -> ref<True|False> :
   if a.id == b.id : return true
   else : return false

lostanza defmethod active? (c:ref<RawCoroutine>) -> ref<True|False> :
   if c.status == COROUTINE-ACTIVE : return true
   else : return false

lostanza defmethod open? (c:ref<RawCoroutine>) -> ref<True|False> :
   if c.status == COROUTINE-OPEN : return true
   else : return false

lostanza defn top (c:ref<RawCoroutine>) -> ref<Stack> :
   return c.top as ref<Stack>

lostanza defn bottom (c:ref<RawCoroutine>) -> ref<Stack> :
   return c.bottom as ref<Stack>

lostanza defn* setup-coroutine (enter: ref<((RawCoroutine,?) -> ?)>) -> ref<?> :
   val s = call-prim stack()
   val p = parent(s)
   s.parent = false
   val c = new RawCoroutine{next-coroutine-id(), false, s, s, false, false, COROUTINE-OPEN}
   val x0 = switch-stack<ref<?>>{p, c}
   return break(c, [enter](c, x0))

lostanza defmethod resume (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
   ;Ensure coroutine is re-entrant
   if c.status != COROUTINE-OPEN :
      return fatal("Unresumable Coroutine")
      
   ;Call its windin
   call-if-function(windin(c))

   ;Connect stacks, and attach coroutine
   current-coroutine.top = call-prim stack()
   bottom(c).parent = current-coroutine.top
   attach(c)

   ;Switch stacks
   val result = switch-stack<CoResult>{top(current-coroutine), x}

   ;Call its windout
   call-if-function(result.windout, result.final?)

   ;Switch stacks
   return result.value

lostanza defmethod* suspend (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
   ;Ensure coroutine is active
   if c.status != COROUTINE-ACTIVE :
      return fatal("Inactive Coroutine")

   ;Disconnect stacks, and Detach coroutine
   bottom(c).parent = false
   detach(c, false)

   ;Return to resume
   val result = CoResult{x, windout(c), false}
   return switch-stack<ref<?>>{top(current-coroutine), result}

lostanza defmethod* break (c:ref<RawCoroutine>, x:ref<?>) -> ref<Void> :
   ;Ensure coroutine is active
   if c.status != COROUTINE-ACTIVE :
      return fatal("Inactive Coroutine")
      
   ;Detach coroutine
   detach(c, false)

   ;Result to return to resume
   val result = CoResult{x, windout(c), true}

   ;Free the coroutine
   free(c)

   ;Switch stacks
   return switch-stack<ref<Void>>{top(current-coroutine), result}

lostanza defmethod close (c:ref<RawCoroutine>) -> ref<False> :
   if c.status == COROUTINE-CLOSED :
      return false
   else if c.status == COROUTINE-ACTIVE :
      return fatal("Cannot close active coroutine")
   else if c.status == COROUTINE-SUSPENDED :
      return fatal("Cannot close suspended coroutine")
   free(c)   
   return false

lostanza defn* attach (c:ref<RawCoroutine>) -> int :
   val p = c.parent
   c.parent = current-coroutine
   c.status = COROUTINE-ACTIVE
   current-coroutine = c
   match(p) :
      (p:ref<RawCoroutine>) : return attach(p)
      (p:ref<False>) : return 0

lostanza defn* detach (c:ref<RawCoroutine>, tail:ref<RawCoroutine|False>) -> int :
   val cc = current-coroutine
   val ccp = current-coroutine.parent as ref<RawCoroutine>
   cc.parent = tail
   current-coroutine = ccp
   if c == cc :
      cc.status = COROUTINE-OPEN
      return 0
   else :
      cc.status = COROUTINE-SUSPENDED
      return detach(c, cc)

lostanza defn* free (c:ref<RawCoroutine>) -> int :
   val parent = c.parent   
   c.status = COROUTINE-CLOSED
   free-stacks(top(c), bottom(c))
   c.top = false
   c.bottom = false
   c.parent = false
   c.windin = false
   c.windout = false
   match(parent) :
      (p:ref<RawCoroutine>) : return free(p)
      (p:ref<False>) : return 0

lostanza defn* free-stacks (top:ref<Stack>, bottom:ref<Stack>) -> int :
   if top == bottom :
      free-stack(top)
      return 0
   else :
      val p = parent(top)
      free-stack(top)
      return free-stacks(p, bottom)

;============================================================
;====================== Lengthable ==========================
;============================================================

public defmulti length (l:Lengthable) -> Int

;============================================================
;======================= Eqable =============================
;============================================================

public defmulti equal? (a:Eqable, b:Eqable) -> True|False
defmethod equal? (a:Eqable, b:Eqable) : false

;============================================================
;================== Seqable/Sequences =======================
;============================================================

public defmulti to-seq<?T> (s:Seqable<?T>) -> Seq<T>
defmethod to-seq<?T> (s:Seq<?T>) : s   

public defmulti next<?T> (s:Seq<?T>) -> T
public defmulti peek<?T> (s:Seq<?T>) -> T
public defmulti empty? (s:Seq) -> True|False
public defmulti close (s:Seq) -> False

;============================================================
;===================== Hashes ===============================
;============================================================

public defmulti hash (h:Hashable) -> Int

;============================================================
;===================== OutputStream =========================
;============================================================

;                   General Interface
;                   =================

public defmulti print (o:OutputStream, x) -> False

defmethod print (o:OutputStream, x) :
   print(o, "[Unprintable Object]")
   
public defn println (o:OutputStream, x) :
   print(o, x)
   print(o, "\n")

public defn print-all (o:OutputStream, xs:Seq) :
   for x in xs do :
      print(o, x)

public defn println-all (o:OutputStream, xs:Seq) :
   print-all(o, xs)
   print(o, "\n")   


;                 File Output Streams
;                 ===================

;TODO: Exception if not closed properly.
public lostanza defn close (o:ref<FileOutputStream>) -> ref<False> : 
   if o.closable? : call-c fclose(o.file)
   else : fatal("System OutputStream is not closable.")
   return false   

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<String>) -> ref<False> :
   call-c fputs(x.chars, o.file)
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   call-c fprintf(o.file, "%d", x.value as int)
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Char>) -> ref<False> :
   call-c putc(x.value, o.file)
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Int>) -> ref<False> :
   call-c fprintf(o.file, "%d", x.value)
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Long>) -> ref<False> :
   call-c fprintf(o.file, "%ld", x.value)
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Float>) -> ref<False> :
   call-c fprintf(o.file, "%f", x.value as double)
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Double>) -> ref<False> :
   call-c fprintf(o.file, "%f", x.value as double)
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<True>) -> ref<False> :
   call-c fprintf(o.file, "true")
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<False>) -> ref<False> :
   call-c fprintf(o.file, "false")
   return false

;                 System Output Streams
;                 =====================

public lostanza val STANDARD-OUTPUT-STREAM : ref<OutputStream> =
   new FileOutputStream{
      call-c get_stdout(), 0}
      
public lostanza val STANDARD-ERROR-STREAM : ref<OutputStream> =
   new FileOutputStream{
      call-c get_stderr(), 0}

;                 Current Output Stream
;                 =====================

public var CURRENT-OUTPUT-STREAM : OutputStream = STANDARD-OUTPUT-STREAM

public defn print (x) :
   print(CURRENT-OUTPUT-STREAM, x)

public defn println (x) :
   print(x)
   print("\n")

public defn print-all (xs:Seq) :
   do(print, xs)

public defn println-all (xs:Seq) :
   print-all(xs)
   print("\n")



;============================================================
;===================== Generators ===========================
;============================================================

lostanza deftype Sentinel 
lostanza var sentinel:ref<Sentinel> = new Sentinel{}
public defn Generator<T> (thunk : (T -> False, (T -> Void) & (() -> Void)) -> ?) -> Seq<T> :
   ;State
   var item = sentinel
   
   ;Generator Coroutine
   val co = Coroutine<False, T|Sentinel> $ fn (co, x0) :
      defn co-yield (x:T) :
         suspend(co, x)
      val co-break = multifn :
         (x:T) : break(co, x)
         () : break(co, sentinel)
      thunk(co-yield, co-break)
      sentinel

   ;Fill state: Returns whether empty
   defn fill () :
      if (item typeof Sentinel) and open?(co) :
         item = resume(co, false)
      item typeof Sentinel

   ;Peek
   defn peek () :
      if item typeof Sentinel :
         fatal("Empty Sequence")
      item as T

   ;Empty bucket
   defn empty () :
      val x = peek()
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         peek()
      defmethod close (this) :
         item = sentinel
         close(co)
      defmethod empty? (this) :
         fill()

;============================================================
;====================== Labels ==============================
;============================================================

public defn* LabeledScope<T> (thunk: (T -> Void) -> T) -> T :
   val c = Coroutine<False,T> $ fn* (c, x0) :
      thunk(break{c, _})
   resume(c, false)

;============================================================
;====================== Maybe ===============================
;============================================================

public defn value!<?T> (x:Maybe<?T>) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : fatal("Object of type None has no value.")

;============================================================
;======================= Identity ===========================
;============================================================

public lostanza defn identical? (a:ref<?>, b:ref<?>) -> ref<True|False> :
   if a == b : return false
   else : return false

;============================================================
;====================== Ranges ==============================
;============================================================

public defmulti start (r:Range) -> Int
public defmulti end (r:Range) -> Int|False
public defmulti step (r:Range) -> Int
public defmulti inclusive? (r:Range) -> True|False

public defn Range (start:Int, end:Int|False, step:Int, inclusive?:True|False) :
   ;Compute the length of the range
   val length = match(end, inclusive?) :
      (end:Int, inc:False) :
         if step == 0 :
            if step == end : 0
            else : false
         else if step == 1 :
            end - start
         else if step == -1 :
            start - end
         else if step > 0 :
            (end - start + step - 1) / step
         else :
            (end - start + step + 1) / step
      (end:Int, inc:True) :
         if step == 0 :
            false            
         else if step == 1 :
            end - start + 1
         else if step == -1 :
            start - end + 1
         else :
            (end - start + step) / step
      (end:False, inc) :
         false
   
   match(length) :
      (length:Int) :
         new Range & Lengthable :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?
            defmethod length (this) : max(length, 0)
      (length:False) :
         new Range :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?         
         
defmethod to-seq (r:Range) :
   match(r) :
      (r:Range & Lengthable) :
         var i = start(r)
         var n = length(r)
         new Seq<Int> & Lengthable :
            defmethod next (this) :
               fatal("Empty Sequence") when n == 0
               val i* = i
               i = i + step(r)
               n = n - 1
               i*
            defmethod peek (this) :
               fatal("Empty Sequence") when n == 0
               i
            defmethod close (this) :
               n = 0
            defmethod empty? (this) :
               n == 0
            defmethod length (this) :
               n
      (r:Range) :
         var i = start(r)
         var closed? = false
         new Seq<Int> :
            defmethod next (this) :
               fatal("Empty Sequence") when closed?
               val i* = i
               i = i + step(r)
               i*
            defmethod peek (this) :
               fatal("Empty Sequence") when closed?
               i
            defmethod close (this) :
               closed? = true
            defmethod empty? (this) :
               closed?            

;defmethod equal? (a:Range, b:Range) :
;   identical?(a, b) or (
;      start(a) == start(b) and
;      end(a) == end(b) and
;      step(a) == step(b) and
;      inclusive?(a) == inclusive?(b))

;============================================================
;===================== Integers =============================
;============================================================

;TEMPORARY
public lostanza defn max (a:ref<Int>, b:ref<Int>) -> ref<Int> :
   if a.value >= b.value : return a
   else : return b

public lostanza defmethod equal? (a:ref<Int>, b:ref<Int>) -> ref<True|False> :
   if a.value == b.value : return true
   else : return false

public lostanza defn greater? (a:ref<Int>, b:ref<Int>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

public lostanza defn plus (a:ref<Int>, b:ref<Int>) -> ref<Int> :
   return new Int{a.value + b.value}

public lostanza defn minus (a:ref<Int>, b:ref<Int>) -> ref<Int> :
   return new Int{a.value - b.value}

public lostanza defn divide (a:ref<Int>, b:ref<Int>) -> ref<Int> :
   return new Int{a.value / b.value}

public lostanza defn complement (a:ref<True|False>) -> ref<True|False> :
   if a == true : return false
   else : return true


;============================================================
;====================== Strings =============================
;============================================================

public lostanza defn String (len:long, chars:ptr<byte>) -> ref<String> :
   val s = new String{len, 0}[len + 1]
   for (var i:long = 0, i < len, i = i + 1) :
      s.chars[i] = chars[i]
   s.chars[len] = 0 as byte
   return s

lostanza defn chars-hash (n:long, p:ptr<byte>) -> int :
   var h:int = 0
   for (var i:long = 0, i < n, i = i + 1) :
      h = (31 * h) + p[i]
   if h == 0 : return 1
   else : return h

public lostanza defn hash (s:ref<String>) -> ref<Int> :
   if s.hash == 0 :
      s.hash = chars-hash(s.length, s.chars)
   return new Int{s.hash}

public lostanza defn string-length (s:ref<String>) -> ref<Int> :
   return new Int{s.length as int}

public lostanza defn get (s:ref<String>, i:ref<Int>) -> ref<Char> :
   return new Char{s.chars[i.value]}

defmethod length (s:String) :
   string-length(s)

defmethod to-seq (s:String) :
   seq({s[_]}, 0 to length(s))

;============================================================
;======================= Lists ==============================
;============================================================

;                      Interface
;                      =========

public defmulti head<?T> (x:List<?T>) -> T
public defmulti tail<?T> (x:List<?T>) -> List<T>

;                    Implementation
;                    ==============

public defn List () -> NilList :
   NilList()

public defn cons<?T> (x:?T, y:?T) -> FullList<T> :
   FullList(x, y)

lostanza defn NilList () -> ref<NilList> :
   return new NilList{}

lostanza defn FullList (x:ref<?>, y:ref<?>) -> ref<FullList> :
   return new FullList{x, y}

defmethod head<?T> (x:FullList<?T>) -> T : list-head(x)
lostanza defn list-head (x:ref<FullList>) -> ref<?> : return x.head

defmethod tail<?T> (x:FullList<?T>) -> List<T> : list-tail(x)
lostanza defn list-tail (x:ref<FullList>) -> ref<?> : return x.tail

defmethod head (x:NilList) : fatal("Object of type NilList has no head.")
defmethod tail (x:NilList) : fatal("Object of type NilList has no tail.")

defmethod length (x:List) :
   defn* loop (x:List, n:Int) :
      match(x) :
         (x:FullList) : loop(tail(x), n + 1)
         (x:NilList) : n
   loop(x, 0)      

defmethod to-seq<?T> (x:List<?T>) :
   var l = x
   new Seq<T> :
      defmethod empty? (this) :
         l typeof NilList
      defmethod next (this) :
         val x = peek(this)
         l = tail(l)
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         head(l)
      defmethod close (this) :
         l = NilList()

;============================================================
;====================== Symbols =============================
;============================================================

lostanza deftype Symbol <: Lengthable & Many<Char> & Eqable :
   length: long
   hash: int
   chars: byte ...      

public lostanza defn Symbol (len:long, chars:ptr<byte>) -> ref<Symbol> :
   return fatal("Not yet implemented")

public lostanza defn hash (s:ref<Symbol>) -> ref<Int> :
   if s.hash == 0 :
      s.hash = chars-hash(s.length, s.chars)
   return new Int{s.hash}

;public lostanza defn println (s:ref<String>) -> ref<False> :
;   call-c printf("%s\n", s.chars)
;   return false
;
;public lostanza defn println (s:ref<String>, x:ref<Int>) -> ref<False> :
;   call-c printf("%s%d\n", s.chars, x.value)
;   return false
;
;public lostanza defn println (s:ref<String>, x:ref<Char>) -> ref<False> :
;   call-c printf("%s%c\n", s.chars, x.value)
;   return false

;============================================================
;==================== Sequences =============================
;============================================================

public defn do<?T> (f:T -> ?, xs:Seqable<?T>) -> False :
   val x-seq = to-seq(xs)
   while not empty?(x-seq) :
      f(next(x-seq))

public defn seq<?T,?S> (f:T -> ?S, xs:Seqable<?T>) -> Seq<S> :
   match(xs) :
      (xs:Seq<T> & Lengthable) :
         new Seq<S> & Lengthable :
            defmethod empty? (this) : empty?(xs)
            defmethod next (this) : f(next(xs))
            defmethod peek (this) : f(peek(xs))
            defmethod close (this) : close(xs)
            defmethod length (this) : length(xs)
      (xs:Seq<T>) :      
         new Seq<S> :
            defmethod empty? (this) : empty?(xs)
            defmethod next (this) : f(next(xs))
            defmethod peek (this) : f(peek(xs))
            defmethod close (this) : close(xs)
      (xs) :
         seq(f, to-seq(xs))



;defn Seq<?T> (next: () -> Maybe<?T>) :
;   ;State
;   var item = sentinel
;
;   defn fill () :
;      if item typeof Sentinel :
;         item = next()
;      item typeof None
;      
;   defn peek () :
;      match(item) :
;         (item:One<T>) : value(item)
;         (item:None) : fatal("Empty Sequence")
;         
;   defn empty () :
;      val x = peek()
;      item = sentinel
;      x
;
;   new Seq<T> :
;      defmethod next (this) :
;         fill()
;         empty()
;      defmethod peek (this) :
;         fill()
;         peek()
;      defmethod close (this) :
;         item = None()         
;      defmethod empty? (this) :
;         fill()


;============================================================
;====================== Scratch =============================
;============================================================

defn nums (n:Int) :
   generate<Int> :
      for i in 0 to n do :
         yield(i)

for i in nums(10) do :
   print("i = ")
   println(i)
;   println("i = ", i)

;defn main () :
;   println("ADD")
;   val a = ($prim add 40 2)
;   println("a = ", a)
;
;   println("SUB")
;   val b = ($prim sub 44 2)
;   println("b = ", b)
;
;   println("MUL")
;   val c = ($prim mul 21 2)
;   val d = ($prim mul -21 -2)
;   println("c = ", c)
;   println("d = ", d)
;
;   println("DIV")
;   val e = ($prim div 10 3)
;   val f = ($prim div -10 -3)
;   println("e = ", e)
;   println("f = ", f)
;
;   println("MOD")
;   val g = ($prim mod 10 3)
;   val h = ($prim mod -10 -3)
;   println("g = ", g)
;   println("h = ", h)
;
;   println("AND/OR/XOR")
;   val i = ($prim and 42 -16)
;   val j = ($prim or 42 -16)
;   val k = ($prim xor 42 -16)
;   println("i = ", i)
;   println("j = ", j)
;   println("k = ", k)
;
;   println("SHL")
;   val l = ($prim shl 21 2)
;   println("l = ", l)
;
;   println("SHR")
;   val m = ($prim shr 42 2)
;   val n = ($prim shr -42 2)
;   val o = ($prim shr -43 2)
;   println("m = ", m)
;   println("n = ", n)
;   println("o = ", o)
;
;   println("ASHR")
;   val p = ($prim ashr 42 2)
;   val q = ($prim ashr -42 2)
;   val r = ($prim ashr -43 2)
;   println("p = ", p)
;   println("q = ", q)
;   println("r = ", r)
;
;   defn cmp (v:String, r:True|False) :
;      println(v)
;      if r : println("true")
;      else : println("false")
;   println("EQ")
;   cmp("a = ", ($prim eq 42 42))
;   cmp("b = ", ($prim eq -42 -42))
;
;   println("NE")
;   cmp("a = ", ($prim ne 42 42))
;   cmp("b = ", ($prim ne -42 -42))
;
;   println("LE")
;   cmp("a = ", ($prim le 5 10))
;   cmp("b = ", ($prim le -5 -10))
;   cmp("c = ", ($prim le 5 5))
;
;   println("LT")
;   cmp("a = ", ($prim lt 5 10))
;   cmp("b = ", ($prim lt -5 -10))
;   cmp("c = ", ($prim lt 5 5))
;
;   println("GE")
;   cmp("a = ", ($prim ge 5 10))
;   cmp("b = ", ($prim ge -5 -10))
;   cmp("c = ", ($prim ge 5 5))
;
;   println("GT")
;   cmp("a = ", ($prim gt 5 10))
;   cmp("b = ", ($prim gt -5 -10))
;   cmp("c = ", ($prim gt 5 5))
;
;main()
;   
;
;
