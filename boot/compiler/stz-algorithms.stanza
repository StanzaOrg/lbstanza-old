;See License.txt for details about licensing.

defpackage stz/algorithms :
   import core
   import collections

public defn* fixpoint<?T> (f: (() -> ?) -> ?T) -> T :
   var progress? = false
   val r = f({progress? = true})
   if progress? : fixpoint(f)
   else : r

public defn* worklist<?S> (f: (S, (S) -> ?) -> ?, xs:Seqable<?S>) -> False :
   val q = Queue<S>(4)
   defn add-x (x:S) : add(q, x)
   do(add-x, xs)   
   while not empty?(q) :
      f(pop(q), add-x)  

defn minus<?T> (xs:List<?T&Equalable>, y:T&Equalable) -> List<T> :
   if empty?(xs) : xs
   else if head(xs) == y : tail(xs) - y
   else : cons(head(xs), tail(xs) - y)

public defn strong-components<?T> (graph: Seqable<KeyValue<?T&Hashable&Equalable, List<?T&Hashable&Equalable>>>) ->
                                   List<List<T>|T> :
   ;Create Neighbour Table
   val vs = Vector<T&Hashable&Equalable>()
   val neighbours = HashTable<T, List<T&Hashable&Equalable>>()
   for entry in graph do :
      val v = key(entry)
      val ns = value(entry)
      add(vs, v)
      neighbours[v] = ns

   ;Active Table
   val active = HashTable<T,True|False>()
   for v in vs do :
      active[v] = true
   defn active? (x:T&Hashable) :
      get?(active, x, false)         

   ;Stack
   val stack = Vector<T&Hashable&Equalable>()
   defn pop-until-v (v:T&Equalable) :
      val x = pop(stack)
      active[x] = false
      if x == v : List(x)
      else : cons(x, pop-until-v(v))

   ;State Tables
   val lowlink = HashTable<T,Int>()
   val index-counter = to-seq(0 to false)
   val components = Vector<List<T>|T>()
   defn get-lowlink (v:T&Hashable&Equalable) -> Int :
      if not key?(lowlink, v) :
         val idx = next(index-counter)
         lowlink[v] = idx
         add(stack, v)

         var cycle? = false
         for n in neighbours[v] do :
            if active?(n) :
               val nl = get-lowlink(n)
               if nl <= lowlink[v] :
                  lowlink[v] = nl
                  cycle? = true

         if lowlink[v] == idx :
            val c = pop-until-v(v)
            add{components, _} $
               if cycle? : c
               else : head(c)
      lowlink[v]

   ;Run connection
   do(get-lowlink, vs)
   to-list(components)




