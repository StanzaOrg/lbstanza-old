defpackage lang/read :
   import core
   import collections
   import stz/il-ir


;               Token Information Propagation
;               =============================

defn fill-info (form) :
   ;Find the first informative info
   defn first-info (a:FileInfo, b:FileInfo) :
      match(a) :
         (a:NoFileInfo) : b
         (a) : a
   defn first-info (x) :
      defn infos (x) :
         generate<FileInfo> :
            defn loop (x) :
               match(x) :
                  (x:Token) :
                     yield(info(x))
                     loop(item(x))
                  (x:List) : do(loop, x)
                  (x) : false
            loop(x)      
      reduce(first-info, FileInfo(), infos(x))

   ;Fill file information up tree
   defn fill-up (x, info:FileInfo) -> Token :
      match(x) :
         (x:Token) :
            fill-up(item(x), core/info(x))
         (x:List) :
            val x* = map(fill-up{_, FileInfo()}, x)
            val info* = first-info(info, first-info(x*))
            Token(x*, info*)
         (x) :
            Token(x, info)

   ;Fill file information down tree
   defn fill-down (x, info:FileInfo) -> Token :
      match(x) :
         (x:Token) :
            fill-down(item(x), first-info(core/info(x), info))
         (x:List) :
            val x* = map(fill-down{_, info}, x)
            Token(x*, info)
         (x) :
            Token(x, info)

   ;Driver
   fill-down(fill-up(form, FileInfo()), FileInfo())


;               FormTable Datastructures
;               ========================

public deftype Form
public defstruct TagForm <: Form :
   tag: Symbol
   fields: Tuple<Field>
   body: (Array, FileInfo) -> ?
public defstruct SForm <: Form :
   body: (Symbol, FileInfo) -> ?
public defstruct VForm <: Form :
   body: (?, FileInfo) -> ?

public deftype Field
public defstruct SField <: Field: (type:Symbol)
public defstruct LField <: Field: (type:Symbol)
public defstruct RField <: Field: (type:Symbol)


;               Production Table Analysis
;               =========================

defstruct ProdTable :
   tagforms: HashTable<Symbol, TagForm>
   sform: False|SForm
   vform: False|VForm

defn tag? (t:ProdTable, x:Symbol) :
   key?(tagforms(t), x)

defn ProdTable (forms:Tuple<Form>) :
   val tagforms = HashTable<Symbol,TagForm>(symbol-hash)
   var sform = false
   var vform = false
   for f in forms do :
      match(f) :
         (f:TagForm) :
            if key?(tagforms, tag(f)) :
               error("Duplicate production for form ~." % [tag(f)])
            tagforms[tag(f)] = f
         (f:SForm) :
            error("Duplicate symbol form.") when sform != false
            sform = f   
         (f:VForm) :
            error("Duplicate value form.") when vform != false
            vform = f
   ProdTable(tagforms, sform, vform)


;                 Read Form to Input IR
;                 =====================
public defn read (form, forms:Tuple<Form>) :

   ;               Analyse productions
   ;               ===================
   val prod-table = ProdTable(forms)
   defn stanza-tag? (tag:Symbol) :
      tag?(prod-table, tag)

   ;                   Error Buffer
   ;                   ============

   val read-errors = Vector<ReadError>()
   defn error! (e:ReadError) :
      add(read-errors, e)
      throw(e)

   defn read-prod (form, prod:Symbol) :   
      if prod == `? : unwrap-all(form)
      else : read-prod(form, prod-table)
      
   defn read-prod (form, table:ProdTable) :
      ;Ensure proper form
      defn ensure-min-arity! (form:List, n:Int) :
         error!(MinArityError(form, n)) when (length(form) - 1) < n
      defn ensure-arity! (form:List, n:Int) :
         error!(ArityError(form, n)) when (length(form) - 1) != n

      ;Read form according to the field descriptors
      defn read-fields (fs:Tuple<Field>, form:List) :
         ;Ensure that x at position i is a list.
         defn list! (x, i:Int) :
            match(unwrap-token(x)) :
               (x:List) : x
               (x) : error!(NotListError(head(form), i, x))

         ;Ensure proper arity of form
         val n = length(fs)
         if any?({_ typeof RField}, fs) :
            ensure-min-arity!(form, n - 1)
         else :
            ensure-arity!(form, n)

         ;Read production and track whether it passed.
         var pass? = true
         defn read-prod? (form, prod:Symbol) :
            try :
               read-prod(form, prod)
            catch (e) :
               pass? = false
         defn read-prods? (form:List, prod:Symbol) :
            map(read-prod?{_, prod}, form)

         ;Read all values according to their field descriptors.
         val values = Array<?>(n)
         defn* loop (i:Int, form:List) :
            if i < n :
               values[i] = match(fs[i]) :
                  (f:SField) : read-prod?(head(form), type(f))
                  (f:LField) : read-prods?(list!(head(form), i), type(f))                     
                  (f:RField) : read-prods?(form, type(f))
               loop(i + 1, tail(form)) when fs[i] not-typeof RField
         loop(0, tail(form))

         ;Return read values, unless they did not pass reading
         if pass? : values
         else : throw(ReadError())

      ;Retrieve the tagform for a given form, or fail
      defn tagform-of (form:List, info:FileInfo) :
         if not empty?(form) :
            match(unwrap-token(head(form))) :
               (tag:Symbol) :
                  match(get?(tagforms(table), tag, false)) :
                     (t:TagForm) :
                        t
                     (t:False) :
                        if stanza-tag?(tag) : error!(InvalidContext(form, info))
                        else : error!(InvalidForm(form, info))
               (tag) : error!(InvalidForm(form, info))
         else : error!(InvalidForm(form, info))

      ;Dispatch based upon the type of the form
      defn r (form, info:FileInfo) :
         match(form) :
            (form:Token) :
               r(item(form), core/info(form))
            (form:List) :
               val f = tagform-of(form, info)
               val values = read-fields(fields(f), form)
               body(f)(values, info)
            (form:Symbol) :
               match(sform(table)) :
                  (f:SForm) : body(f)(form, info)
                  (f:False) : error!(InvalidContext(form, info))
            (form) :
               match(vform(table)) :
                  (f:VForm) : body(f)(form, info)
                  (f:False) : error!(InvalidContext(form, info))                  
      r(form, FileInfo())

   try :
      read-prod(fill-info(form), prod-table)
   catch (e:ReadError) :
      do(println, read-errors)
      throw(ReadError())

;                   Errors
;                   ======

definterface ReadError <: Exception
defn ReadError () :
   new ReadError :
      defmethod print (o:OutputStream, this) :
         print(o, "ReadError")

defn ReadError (msg, info) :
   new ReadError :
      defmethod print (o:OutputStream, this) :
         print(o, "~: ~" << [info, msg])

defn MinArityError (form:List, n:Int) :
   val info = info(head(form) as Token)
   ReadError{_, info} $
      "Stanza form ~ expects at least ~ arguments, but found only ~." << [
         head(form), n, length(form) - 1]

defn ArityError (form:List, n:Int) :
   val info = info(head(form) as Token)
   ReadError{_, info} $
      "Stanza form ~ expects ~ arguments, but found ~." << [
         head(form), n, length(form) - 1]

defn InvalidForm (form:List, info:FileInfo) :
   ReadError{_, info} $
      "Form ~ is not a valid Stanza core form." << [form]

defn NotListError (tag:Token, i:Int, x) :
   ReadError{_, info(tag)} $
      "Stanza form ~ expects a list in argument position ~, but received ~." << [tag, i, x]

defn InvalidContext (form, info:FileInfo) :
   ReadError{_, info} $
      "Inappropriate form ~ for in this context." << [form]
