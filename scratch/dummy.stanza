defpackage dummy :
  import core
  import collections
  import reader
  import core/dynamic-library
  import core/safepoints
  import core/sighandler
  import core/stack-trace

defn load-program (filename:String) -> DynamicLibrary :
  val lib = dynamic-library-open(filename)
  unprotect-extents(lib)
  println("Load program succeeded.")
  lib
  ;set-sighandler(command-loop{lib, true})
  ;try :
  ;  command-loop(lib, false)
  ;catch (e:Exception) :
  ;  println(e)

;<comment>
defn* command-loop (lib:DynamicLibrary,
                    running?:True|False) -> False :
  let loop () :
    val tokens = read-line(LineNoisePrompter("debug> ", "     > "))
    match(tokens:List<Token>) :
      match-syntax(tokens) :
        (safepoints) :
          print-safepoints(lib)
          loop()
        (break ?filename ?line) :
          set-safepoint(lib, unwrap-token(filename) as String, unwrap-token(line) as Int)
          loop()
        (run) :
          if running? :
            println("Program is already running.")
            loop()
          else :
            run-main(lib)
            println("debug> Program finished.")
        (continue) :
          if running? :
            false
          else :
            println("Program is not yet running.")
            loop()
        (stop) :
          println("Stopping the program.")
          throw(Exception("Program Stopped."))
        (_ ...) :
          println("Unrecognized command.")
          loop()
    else :
      println("No command entered.")
      loop()
;<comment>

lostanza val PAGE-SIZE:long = 4096
lostanza defn align-to-page-size (p:ptr<?>) -> ptr<?> :
  val x = p as long
  val y = x & (- PAGE-SIZE)
  return y as ptr<?>

extern mprotect: (ptr<?>, long, int) -> int
lostanza defn unprotect-region (p1:ptr<?>, p2:ptr<?>) -> ref<False> :
  var p:ptr<?> = p1
  while p <= p2 :
    val result = call-c mprotect(p, PAGE-SIZE, 0x7)
    p = p + PAGE-SIZE
  return false

lostanza defn unprotect-extents (lib:ref<DynamicLibrary>) -> ref<False> :
  val start = dynamic-library-symbol(lib, String("stanza_text_section_start"))
  val end = dynamic-library-symbol(lib, String("stanza_text_section_end"))
  val start-address = align-to-page-size(start.address)
  val end-address = align-to-page-size(end.address)
  unprotect-region(start-address, end-address)
  return false

lostanza defn get-safepoint-table (lib:ref<DynamicLibrary>) -> ptr<SafepointTable> :
  val safepoint-sym = dynamic-library-symbol(lib, String("stanza_safepoint_table"))
  return safepoint-sym.address as ptr<SafepointTable>

lostanza defn print-safepoints (lib:ref<DynamicLibrary>) -> ref<False> :
  dump-safepoint-table(get-safepoint-table(lib))
  return false

lostanza defn write-int3 (p:ptr<byte>) -> ref<False> :
  call-c clib/printf("Set breakpoint at %p\n", p)
  [p] = 0xCCY
  return false
lostanza defn set-safepoint (lib:ref<DynamicLibrary>, filename:ref<String>, line:ref<Int>) -> ref<False> :
  val table = get-safepoint-table(lib)
  val address-list = safepoint-addresses(table, addr!(filename.chars), line.value)
  if address-list == null :
    call-c clib/printf("No safepoint at %s:%ld\n", addr!(filename.chars), line.value)
  else :
    for (var i:long = 0, i < address-list.length, i = i + 1) :
      write-int3(address-list.addresses[i].address)
  return false

lostanza deftype SourceBreakpoint :
  line:long    ; 1-based
  column:long  ; 1-based, 0 denotes undefined column
lostanza defn write-noop (p:ptr<byte>) -> ref<False> :
  [p] = 0x90Y
  return false
extern defn set_safepoints (filename:ptr<byte>, breakpoints:ptr<SourceBreakpoint>, length:long, out:ptr<?>) -> int :
  val table = get-safepoint-table(LOADED-PROGRAM)
  val safepoints = file-safepoints(table, filename)
  if safepoints != null :
    ;Clear all safeponts in the file
    for (var i:long = 0, i < safepoints.num-entries, i = i + 1) :
      val address-list = safepoints.entries[i].address-list
      for (var i:long = 0, i < address-list.length, i = i + 1) :
        write-noop(address-list.addresses[i].address)
    for (var i:long = 0, i < length, i = i + 1) :
      val line = breakpoints[i].line  ;Ignore column fo now
      val address-list = safepoint-addresses(safepoints, line)
      if address-list != null :
        for (var i:long = 0, i < address-list.length, i = i + 1) :
          val p = address-list.addresses[i].address
          write-int3(p)
          call-c append_breakpoint(out, p as long, line, 0L) ;0 is for undefined column
  return 0

extern append_stack_frame: (ptr<?>, long, ptr<?>, ptr<?>, long, long) -> int
extern defn create_stack_trace (st:ptr<?>) -> int :
  val vms = app_vms
  val current-stack = vms.heap.current-stack as ref<Stack>
  val buffer = core/stack-trace-frames(vms, current-stack)
  val stack-trace-table = vms.stack-trace-table
  for (var i:long = buffer.length - 1, i >= 0, i = i - 1) :
    val frame = buffer.items[i] as ptr<StackFrame>
    val entry = core/stack-trace-record(frame, stack-trace-table)
    if entry != null and entry.signature != null:
      call-c append_stack_frame(st, frame as long, entry.signature, entry.file, entry.line, entry.column)
  core/free(buffer)
  return 0

lostanza var app_vms:ptr<core/VMState> = null
lostanza defn run-main (lib:ref<DynamicLibrary>) -> ref<Int> :
  app_vms = dynamic-library-symbol(lib, String("stanza_vmstate")).address as ptr<core/VMState>
  val main-sym = dynamic-library-symbol(lib, String("main"))
  val main = main-sym.address as ptr<( (int, ptr<ptr<byte>>) -> int )>
  val result = call-c [main](0, null)
  return new Int{result}

extern stop_at_entry: () -> int
extern next_debug_event: () -> int
extern append_breakpoint: (ptr<?>, long, long, long) -> int
extern send_thread_stopped_at_breakpoint: (long) -> int

lostanza defn stop-at-entry () -> ref<False> :
  call-c stop_at_entry()
  return false

lostanza defn next-debug-event () -> ref<False> :
  call-c next_debug_event()
  return false

extern defn stanza_debugger_pause () -> int :
  dummy-pause()
  return 0

var LOADED-PROGRAM:DynamicLibrary
extern defn stanza_debugger_continue () -> int :
  dummy-continue()
  return 0

;<comment>
;That's a useful function, may need it later
extern defn stanza_debugger_current_source_position (ip:ptr<?>, file:ptr<ptr<byte>>) -> long :
  if (ip != null) :
    val safepoints = get-safepoint-table(LOADED-PROGRAM)
    for (var i:long = 0, i < safepoints.num-files, i = i + 1) :
      val file-safepoints = safepoints.files[i]
      for (var j:long = 0, j < file-safepoints.num-entries, j = j + 1) :
        val entry = file-safepoints.entries[j]
        val address-list = entry.address-list
        for (var k:long = 0, k < address-list.length, k = k + 1) :
          if address-list.addresses[k].address == ip :
            [file] = file-safepoints.filename
            return entry.line
  [file] = null
  return 0L
;<comment>

lostanza defn send-thread-stopped-at-breakpoint (id:ref<Long>) -> ref<False> :
  call-c send_thread_stopped_at_breakpoint(id.value)
  return false

defn hit-breakpoint () :
  send-thread-stopped-at-breakpoint(get-sighandler-instruction-address())
  next-debug-event()

defn dummy-pause () :
  println("Stanza: Simulate a pause")

defn dummy-continue () :
  println("Stanza: Simulate continue")

defn main () :
  val cmd-args = command-line-arguments()
  println("Stanza: Command line arguments = %_" % [cmd-args])

  val program-filename = cmd-args[1]
  LOADED-PROGRAM = load-program(program-filename)

  set-sighandler(hit-breakpoint)

  println("Stanza: Stopping at entry")
  stop-at-entry()

  println("Running main")
  run-main(LOADED-PROGRAM)
  println("run-main has finished")


main()