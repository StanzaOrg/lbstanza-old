defpackage clib

protected extern fclose: (ptr<?>) -> int
protected extern fopen: (ptr<byte>, ptr<byte>) -> ptr<?>
protected extern fputs: (ptr<byte>, ptr<?>) -> int
protected extern fputc: (byte, ptr<?>) -> int
protected extern fgetc: (ptr<?>) -> int
protected extern ferror: (ptr<?>) -> int
protected extern fprintf: (ptr<?>, ptr<byte>, ? ...) -> int
protected extern sprintf: (ptr<byte>, ptr<byte>, ? ...) -> int
protected extern sscanf: (ptr<byte>, ptr<byte>, ptr<?> ...) -> int
protected extern printf: (ptr<byte>, ? ...) -> int
protected extern malloc: long -> ptr<?>
protected extern free: ptr<?> -> int
protected extern exit: int -> int
protected extern get_stdout: () -> ptr<?>
protected extern get_stderr: () -> ptr<?>
protected extern get_eof: () -> int
protected extern rand: () -> int

defpackage core :
   import collections

;============================================================
;================== Core Types ==============================
;============================================================

public :
   deftype Seqable<T>                   
   deftype Seq<T> <: Seqable<T>         
   deftype Many<T> <: Seqable<T>        

   deftype Lengthable                   

   deftype Equalable                       

   deftype Hashable                     

   deftype Comparable<T>                

   deftype OutputStream                 

   lostanza deftype FileOutputStream <: OutputStream :   
      file: ptr<?>
      closable?: long

   deftype InputStream <: Seq<Char>
   deftype FileInputStream <: InputStream
   deftype StringInputStream <: InputStream & Lengthable

   deftype Maybe<T> <: Equalable & Comparable<Maybe<T>>           
   deftype None <: Maybe<Void>
   deftype One<T> <: Maybe<T>

   deftype Coroutine<I,O> <: Equalable     

   deftype Range <: Many<Int> & Equalable  

   lostanza deftype Byte <: Equalable & Hashable & Comparable<Byte> :   
      value: byte

   lostanza deftype Char <: Equalable & Hashable & Comparable<Char> :   
      value: byte

   lostanza deftype Int <: Equalable & Hashable & Comparable<Int> :      
      value: int

   lostanza deftype Long <: Equalable & Hashable & Comparable<Long> :    
      value: long

   lostanza deftype Float <: Equalable & Hashable & Comparable<Float> :   
      value: float

   lostanza deftype Double <: Equalable & Hashable & Comparable<Double> :  
      value: double

   lostanza deftype String <: Lengthable & Many<Char> & Equalable & Hashable & Comparable<String> : 
      length: long
      hash: int
      chars: byte ...

   deftype Symbol <: Equalable & Hashable

   deftype List<T> <: Lengthable & Many<T> & Equalable & Hashable & Comparable<List<T>>   
   lostanza deftype FullList<T> <: List<T> :
      head: ref<T>
      tail: ref<List<T>>
   lostanza deftype NilList <: List<Void>

   lostanza deftype True <: Equalable      
   lostanza deftype False <: Equalable

   lostanza deftype Tuple<T> <: Lengthable & Many<T> & Equalable & Hashable & Comparable<Tuple<T>> : 
      length: long
      items: ref<T> ...

   deftype IndexedCollection<T> <: Lengthable & Many<T>
   
   deftype Array<T> <: IndexedCollection<T> & Equalable  

   lostanza deftype CharArray <: Array<Char> :    
      length: long
      chars: byte ...

   deftype StringBuffer <: IndexedCollection<Char> & OutputStream     

   deftype FileInfo <: Equalable & Hashable & Comparable<FileInfo>  

   deftype Token <: Equalable 

   deftype KeyValue<K,V> 

   deftype Exception  

   ;writer
   ;System File/Dir Handling
   ;Command Prompt Execution
   ;Command Line Arguments
   ;Slices

;============================================================
;================ Internal Types ============================
;============================================================

lostanza deftype Fn :
   code: ptr<?>
   free: ref<?> ...
lostanza deftype Box :
   item: ref<?>
lostanza deftype Type :
   code: ptr<?>
   free: ref<?> ...
lostanza deftype Stack :
   position: int
   mark: int
   parent: ref<False|Stack>
   sp: ptr<?>
   frames: StackFrame ...
lostanza deftype StackFrame :
   ret: ptr<?>
   map: ptr<RefMap>
   items: long ...
lostanza deftype RefMap :
   length: long
   bits: long ...
lostanza deftype FileInfoTable :
   length: long
   entries: FileInfoEntry ...
lostanza deftype FileInfoEntry :
   lbl: ptr<?>
   file: ptr<byte>
   line: int
   column: int

;============================================================
;============== Standard Streams ============================
;============================================================

lostanza val stdout:ptr<?> = call-c clib/get_stdout()
lostanza val stderr:ptr<?> = call-c clib/get_stderr()
lostanza val EOF:int = call-c clib/get_eof()

;============================================================
;=============== Initialization Phase 0 =====================
;============================================================

;                  Stack Initialization
;                  ====================

extern stanza_stack_size: long
lostanza var num-stacks:long = 1024

lostanza defn parent (s:ref<Stack>) -> ref<Stack> :
   return s.parent as ref<Stack>

lostanza defn initialize-stacks () -> int :
   ;Create stack pool
   val pool:ptr<ref<Stack>> = call-c clib/malloc(sizeof(ref<?>) * num-stacks)
   for (var i:int = 1, i < num-stacks, i = i + 1) :
      val p:ptr<long> = call-c clib/malloc(stanza_stack_size)
      [p] = tagof(Stack) << 3
      val s = (p + 1) as ref<Stack>
      s.position = i << 3
      s.mark = 0
      pool[i] = s

   ;Initialize current stack
   val s = call-prim stack()
   val p = (addr([s]) - 8) as ptr<long>
   [p] = tagof(Stack) << 3
   s.position = 0
   s.mark = 0
   s.parent = false
   pool[0] = s

   ;Tell Stanza about stack pool
   call-prim set-num-free-stacks(num-stacks - 1)
   call-prim set-free-stacks(addr(pool[1]))
   call-prim set-stack-pool(pool)

   return 0

;                 Heap Initialization
;                 ===================

lostanza var mem-size:long
lostanza var max-mem-size:long
lostanza var heap-mem:ptr<long>
lostanza var free-mem:ptr<long>
lostanza var free-ptr:ptr<long>

lostanza defn initialize-heaps () -> int :
   mem-size = 1024 * 1024
   max-mem-size = (4 as long) * 1024 * 1024 * 1024
   heap-mem = call-c clib/malloc(mem-size)
   free-mem = call-c clib/malloc(mem-size)
   call-prim set-heap(heap-mem)
   call-prim set-heap-limit(heap-mem + mem-size)
   return 0

;                    Driver
;                    ======

lostanza defn initialize-phase0 () -> int :
   initialize-stacks()
   initialize-heaps()
   return 0

lostanza: initialize-phase0()

;============================================================
;============== Generated Entry Points ======================
;============================================================

lostanza defn cast-error () -> ref<Void> :
   return fatal("Cannot cast value to type.", call-prim sp())

lostanza defn arity-error () -> ref<Void> :
   return fatal("Wrong number of arguments.", call-prim sp())

lostanza defn no-branch-error () -> ref<Void> :
   return fatal("No matching branch.", call-prim sp())

lostanza defn amb-branch-error () -> ref<Void> :
   return fatal("Ambiguous branch.", call-prim sp())

lostanza defn variable-uninitialized-error () -> ref<Void> :
   return fatal("Variable is uninitialized.", call-prim sp())

lostanza defn tuple-length-error () -> ref<Void> :
   return fatal("Tuple has wrong arity for detupling.", call-prim sp())

;============================================================
;================== Stack Traces ============================
;============================================================

lostanza var trace-buffer:ptr<ptr<FileInfoEntry>>
lostanza var trace-size:int
lostanza val null:ptr<?> = 0 as long as ptr<?>

lostanza defn print-stack-trace (end:ptr<?>) -> ref<False> :
   ;Allocate space for storing trace
   ;No trace can be larger than the size of a stack
   trace-buffer = call-c clib/malloc(stanza_stack_size)

   ;Print trace starting from current stack
   print-stack-trace(call-prim stack(), end)

   ;Free trace buffer and return
   call-c clib/free(trace-buffer)
   return false

lostanza defn* print-stack-trace (s:ref<Stack>, end:ptr<?>) -> int :
   ;Store trace into buffer
   trace-size = 0
   val f0 = s.frames + frame-size(s.frames) ;Skip intercepted return frame
   store-stack-trace(f0, end)

   ;Print out trace
   for (var i:int = trace-size - 1, i >= 0, i = i - 1) :
      val e = trace-buffer[i]
      if e == null :
         call-c clib/fprintf(stderr, "   at [Unknown Source Location]\n")
      else :
         call-c clib/fprintf(stderr, "   at %s:%d.%d\n", e.file, e.line, e.column)

   ;Print parent stack trace
   match(s.parent) :
      (p:ref<Stack>) : return print-stack-trace(p, p.sp)
      (p:ref<False>) : return 0

lostanza defn* store-stack-trace (stacks:ptr<StackFrame>, end:ptr<?>) -> int :
   ;Store the return address into trace buffer
   trace-buffer[trace-size] = info-entry(stacks.ret)
   trace-size = trace-size + 1

   ;Continue tracing next frame unless end is reached.
   if stacks == end :
      return 0
   else :
      val sz = frame-size(stacks)
      return store-stack-trace(stacks + sz, end)

lostanza defn frame-size (s:ptr<StackFrame>) -> long :
   val map = s.map
   return sizeof(StackFrame) + s.map.length * sizeof(long)

lostanza defn info-entry (p:ptr<?>) -> ptr<FileInfoEntry> :
   val table = call-prim info-table() as ptr<FileInfoTable>
   for (var i:long = 0, i < table.length, i = i + 1) :
      val e = table.entries[i]
      if e.lbl == p :
         return addr(table.entries[i])
   return null

;============================================================
;===================== Errors ===============================
;============================================================

public lostanza defn* fatal (msg: ptr<byte>) -> ref<Void> :
   return fatal(msg, call-prim sp())

lostanza defn fatal (msg: ptr<byte>, sp:ptr<?>) -> ref<Void> :
   call-c clib/fprintf(stderr, "FATAL ERROR: %s\n", msg)
   print-stack-trace(sp)
   call-c clib/exit(-1)
   return null as ref<Void>

;============================================================
;=============== Garbage Collector ==========================
;============================================================

;              Generated Entry Points
;              ======================

;Called when attempting to allocate beyond the heap limit.
lostanza defn extend-heap (sz:long) -> int :
   if gc-running :
      fatal("Heap access within garbage collector")
   else :   
      new-stack<int>{run-garbage-collector()}
      val new-size = enlarged-size(sz)
      if new-size < 0 : fatal("Out of Memory", call-prim sp())
      else if new-size != mem-size : enlarge-heap(new-size)
   return 0

lostanza defn enlarged-size (sz:long) -> long :
   ;Case 1: Out of memory
   val min-mem-size = call-prim heap() + sz - heap-mem
   if min-mem-size > max-mem-size :
      return -1

   ;Case 2: Safe mem size
   val safe-mem-size = mem-size >>> 1
   if min-mem-size <= safe-mem-size :
      return mem-size

   ;Case 3: Enlarged size
   var new-size:long = mem-size * 2
   while new-size < min-mem-size :
      new-size = new-size * 2
   return min(new-size, max-mem-size)

lostanza defn min (a:long, b:long) -> long :
   if a < b : return a
   else : return b      

lostanza defn enlarge-heap (size:long) -> int :
   ;Set new size
   mem-size = size
      
   ;Enlarge freespace   
   call-c clib/free(free-mem)
   free-mem = call-c clib/malloc(mem-size)

   ;Copy to enlarged freespace
   new-stack<int>{run-garbage-collector()}

   ;Enlarge the new freespace to match the new heapspace
   call-c clib/free(free-mem)
   free-mem = call-c clib/malloc(mem-size)
   return 0

;Called when the number of free stacks is 2 or less.
;Running extend-stack uses two stacks (1 for GC, 1 for handling extend-stack during GC).
lostanza var extending-stack:long = 0
lostanza defn extend-stack () -> int :
   if gc-running :
      fatal("Stack overflow in garbage collector")
   else if extending-stack == 0 :
      extending-stack = 1
      new-stack<int>{run-garbage-collector()}
      if call-prim num-free-stacks() <= 2 :
         fatal("Stack overflow", call-prim sp())
      extending-stack = 0
      
   ;Return   
   return 0

;                   Main Function
;                   =============

;Main function for garbage collector
lostanza var gc-running:long = 0
;lostanza var gc-run-num: long = 0
lostanza defn run-garbage-collector () -> int :
   ;call-c clib/printf("RUNNING GARBAGE COLLECTOR %ld\n", gc-run-num)
   ;call-c clib/printf("mem-size = %ld\n", mem-size)   
   ;call-c clib/printf("heap-mem = %p to %p\n", heap-mem, heap-mem + mem-size)
   ;call-c clib/printf("free-mem = %p to %p\n", free-mem, free-mem + mem-size)
   ;gc-run-num = gc-run-num + 1
   
   ;Mark GC as running to detect stack extension within GC
   gc-running = 1

   ;Initialize free pointer to point to beginning of free memory before copying starts.
   free-ptr = free-mem

   ;Current stack is the collection stack, the stack that the GC runs in.
   ;Set its mark bit to indicate that it should not be scanned.
   ;Make sure the top stack of the current-coroutine is up-to-date
   val current-stack = call-prim stack()
   current-coroutine.top = current-stack
   current-stack.mark = 1

   ;Scan roots
   scan-globals()
   scan-stack(parent(current-stack))

   ;Scan internal pointers of all heap objects
   scan-heap()

   ;Swap free memory with heap
   val swap = heap-mem
   heap-mem = free-mem
   free-mem = swap
   call-prim set-heap(free-ptr)
   call-prim set-heap-limit(heap-mem + mem-size)

   ;All active stacks have their mark bits set.
   free-unmarked-stacks()

   ;Finish
   ;call-c clib/printf("DONE RUNNING GARBAGE COLLECTOR\n")
   gc-running = 0
   return 0

;                 Scanning Functions
;                 ==================

;Copy all global references to the free memory.
lostanza defn scan-globals () -> int :
   ;Get tables
   val globals = call-prim globals() as ptr<long>
   val map = call-prim global-map() as ptr<RefMap>
   ;Scan globals
   scan-map-words(map.bits, map.length, globals)
   return 0

;Copy all stack references in this and parent stacks to free memory.
lostanza defn* scan-stack (s:ref<Stack>) -> int :
   if s.mark == 0 :
      s.mark = 1
      scan-stack-frames(s.frames, s.sp)
      match(s.parent) :
         (p:ref<Stack>) : return scan-stack(p)
         (p:ref<False>) : return 0
   else :
      return 0

;Copy all internal references in heap to free memory.
lostanza defn scan-heap () -> int :
   var p: ptr<long> = free-mem
   while p < free-ptr :
      val tagbits = [p] & 3
      if tagbits == 0 :
         p = scan-object(p)
      else if tagbits == 1 :
         p = scan-array(p)
      else :
         call-c clib/fprintf(stderr, "Invalid tag bits in heap: %lx\n", tagbits)
         call-c clib/exit(-1)
         return 0
   return 0

;Copy all internal references in object to free memory.
lostanza defn scan-object (p:ptr<long>) -> ptr<long> :
   ;p is [tag-word, cells ...]
   val tag = p[0] >>> 3
   val map = object-map(tag)
   scan-map-words(base-bits(map), base-nwords(map), p + 8)
   return p + 8 + map.base-size

;Copy all internal references in array to free memory.
lostanza defn scan-array (p:ptr<long>) -> ptr<long> :
   ;p is [len-word, tag-word, cells ...]
   val len = p[0] >>> 3
   val tag = p[1] >>> 3

   ;Calculate the total size of object, rounding up to nearest 8 bytes
   val map = object-map(tag)
   val bytes = ((map.base-size + map.tail-size * len) + 7) & -8

   ;Scan base of array
   scan-map-words(base-bits(map), base-nwords(map), p + 16)

   ;Scan tail of array if it contains references.
   if tail-refs?(map) :
      var tail:ptr<long> = p + 16 + map.base-size
      val tbits = tail-bits(map)
      val tnwords = tail-nwords(map)
      for (var i:long = 0, i < len, i = i + 1) :
         scan-map-words(tbits, tnwords, tail)
         tail = tail + map.tail-size

   ;Return end of array
   return p + 16 + bytes

;Copy all internal references in stack frames, fs, until end pointer
lostanza defn* scan-stack-frames (fs:ptr<StackFrame>, end:ptr<?>) -> int :
   if fs < end :
      val map = [fs].map
      scan-map-words(map.bits, map.length, [fs].items)
      val next-fs = addr([fs].items[map.length]) as ptr<StackFrame>
      return scan-stack-frames(next-fs, end)
   else :
      return 0

;Scan n references (marked with a 1 bit) from the given pointer
lostanza defn* scan-map-words (map:ptr<long>, n:long, refs:ptr<long>) -> int :
   if n > 64 :
      scan-map-word([map], 64, refs)
      return scan-map-words(addr(map[1]), n - 64, addr(refs[64]))
   else if n > 0 :
      scan-map-word([map], n, refs)
      return 0
   else :
      return 0

lostanza defn scan-map-word (map:long, n:long, refs:ptr<long>) -> int :
   var ref-ptr:ptr<long> = refs
   for (var i:long = 0, i < n, i = i + 1) :
      val b = (map >> i) & 1
      if b : [ref-ptr] = post-gc-object([ref-ptr])
      ref-ptr = ref-ptr + sizeof(long)
   return 0

;                Copying Functions
;                =================

lostanza defn post-gc-object (obj:long) -> long :
   val tagbits = obj & 7
   if tagbits == 1 :
      val obj-ptr = (obj - tagbits) as ptr<long>
      val tag = obj-ptr[0] >>> 3

      ;If broken heart, then return forwarding pointer
      if tag == -1 :
         return obj-ptr[1]
      ;Otherwise, copy object
      else :
         val map = object-map(tag)
         if tag == tagof(Stack) :
            scan-stack(obj as ref<Stack>)
            return obj
         else if finite?(map) :
            val obj* = copy-object-to-free(obj-ptr, map.base-size) + tagbits
            set-broken-heart(obj-ptr, obj*)
            return obj*
         else :
            val obj* = copy-array-to-free(obj-ptr, map.base-size, map.tail-size) + tagbits
            set-broken-heart(obj-ptr, obj*)
            return obj*
   else :
      return obj

lostanza defn set-broken-heart (old:ptr<long>, new-obj:long) -> int :
   old[0] = -1
   old[1] = new-obj
   return 0

lostanza defn copy-object-to-free (obj:ptr<long>, size:long) -> long :
   val ret = free-ptr
   copy-bytes-to-free(obj, size + 8)
   return ret as long

lostanza defn copy-array-to-free (obj:ptr<long>, size:long, tail:long) -> long :
   ;obj: [len, tag, items ...]
   ;Returned pointer points to the tag word
   val ret = free-ptr + 8
   val length = obj[-1] >>> 3

   ;Calculate the total size of object, rounding up to nearest 8 bytes
   val bytes = ((size + tail * length) + 7) & -8

   ;Copy the bytes to free including header
   copy-bytes-to-free(obj - 8, bytes + 16)

   return ret as long

lostanza defn copy-bytes-to-free (p:ptr<long>, n:long) -> int :
   if n & 7 != 0 :
      call-c clib/exit(-1)
   val nwords = n >>> 3
   for (var i:long = 0, i < nwords, i = i + 1) :
      free-ptr[i] = p[i]
   free-ptr = free-ptr + n
   return 0

;               Utilities for ObjectMap
;               =======================

lostanza deftype ObjectMap :
   base-size: int
   tail-size: int
   bits: long ...

lostanza defn object-map (tag:long) -> ptr<ObjectMap> :
   val table = call-prim object-table() as ptr<ptr<ObjectMap>>
   return table[tag]

lostanza defn finite? (m:ptr<ObjectMap>) -> long :
   return m.tail-size == 0

lostanza defn base-bits (m:ptr<ObjectMap>) -> ptr<long> :
   return m.bits

lostanza defn base-nwords (m:ptr<ObjectMap>) -> long :
   return m.base-size >>> 3

lostanza defn tail-bits (m:ptr<ObjectMap>) -> ptr<long> :
   return addr(m.bits[base-nwords(m)])

lostanza defn tail-nwords (m:ptr<ObjectMap>) -> long :
   return m.tail-size >>> 3

lostanza defn tail-refs? (m:ptr<ObjectMap>) -> long :
   val n = tail-nwords(m)
   val bits = tail-bits(m)
   for (var i:long = 0, i < n, i = i + 1) :
      if bits[i] != 0 :
         return 1
   return 0

;                  Releasing Stacks
;                  ================

;Free an active stack, and add back to the free stack list.
lostanza defn free-stack (s:ref<Stack>) -> long :
   ;Ensure s is the last active stack
   val stk-pool = call-prim stack-pool()
   val last-stk = (call-prim free-stacks())[-1]
   if s != last-stk :
      ;Swap locations of last-stk with s
      [stk-pool + s.position] = last-stk
      [stk-pool + last-stk.position] = s
      ;Swap positions of last-stk with s
      val s-position = s.position
      s.position = last-stk.position
      last-stk.position = s-position
   ;Free last active stack
   call-prim set-num-free-stacks(call-prim num-free-stacks() + 1)
   call-prim set-free-stacks(call-prim free-stacks() - 8)
   return 0

;Free all unmarked stacks.
lostanza defn free-unmarked-stacks () -> int :
   var stk-ptr:ptr<ref<Stack>> = call-prim stack-pool()
   while stk-ptr < call-prim free-stacks() :
      val s = [stk-ptr]
      if s.mark == 0 :
         free-stack(s)
      else :
         stk-ptr = stk-ptr + 8
      s.mark = 0
   return 0

;============================================================
;===================== Winders ==============================
;============================================================

defn fn-cons-0 (a: False|(() -> ?), b: False|(() -> ?)) -> False|(() -> ?) :
   match(a, b) :
      (a:False, b) : b
      (a, b:False) : a
      (a:() -> ?, b:() -> ?) : fn* () : (a(), b())

defn fn-cons-1 (a: False|(? -> ?), b: False|(? -> ?)) -> False|(? -> ?) :
   match(a, b) :
      (a:False, b) : b
      (a, b:False) : a
      (a:? -> ?, b:? -> ?) : fn* (x) : (a(x), b(x))

defn* call-if-function (f: False|(() -> ?)) :
   match(f) :
      (f:() -> ?) : f()
      (f:False) : false

defn* call-if-function (f: False|(? -> ?), x: ?) :
   match(f) :
      (f:? -> ?) : f(x)
      (f:False) : false

public lostanza defn dynamic-wind<?T> (in:ref<False|(() -> ?)>,
                                       body:ref<(() -> ?T)>,
                                       out:ref<False|(? -> ?)>) -> ref<T> :
   call-if-function(in)
   val w-in = current-coroutine.windin
   val w-out = current-coroutine.windout
   current-coroutine.windin = fn-cons-0(w-in, in)
   current-coroutine.windout = fn-cons-1(out, w-out)
   val result = [body]()
   current-coroutine.windin = w-in
   current-coroutine.windout = w-out
   call-if-function(out, true)
   return result

lostanza defn windin (c:ref<RawCoroutine>) -> ref<False|(() -> ?)> :
   match(c.parent) :
      (p:ref<RawCoroutine>) : return fn-cons-0(c.windin, windin(p))
      (p:ref<False>) : return c.windin

lostanza defn windout (c:ref<RawCoroutine>) -> ref<False|(? -> ?)> :
   match(c.parent) :
      (p:ref<RawCoroutine>) : return fn-cons-1(windout(p), c.windout)
      (p:ref<False>) : return c.windout

;============================================================
;===================== Coroutines ===========================
;============================================================

;                     Interface
;                     =========

public defmulti active? (c:Coroutine) -> True|False
public defmulti open? (c:Coroutine) -> True|False
public defmulti resume<?I,?O> (c:Coroutine<?I,?O>, x:I) -> O
public defmulti suspend<?I,?O> (c:Coroutine<?I,?O>, x:O) -> I
public defmulti break<?O> (c:Coroutine<?,?O>, x:O) -> Void
public defmulti close (c:Coroutine) -> False

;                   Raw Coroutines
;                   ==============

lostanza deftype RawCoroutine <: Coroutine :
   id: long
   parent: ref<False|RawCoroutine>
   top: ref<Stack|False>
   bottom: ref<Stack|False>
   windin: ref<False|(() -> ?)>
   windout: ref<False|(? -> ?)>
   status: ref<Int>

;                  Wrapped Coroutines
;                  ==================

deftype WrappedCoroutine<I,O> <: Coroutine<I,O>
defmulti raw (c:WrappedCoroutine) -> RawCoroutine

public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
   var rc
   val c = new WrappedCoroutine<I,O> :
      defmethod active? (this) : active?(rc)
      defmethod open? (this) : open?(rc)
      defmethod resume (this, x:I) : resume(rc, x)
      defmethod suspend (this, x:O) : suspend(rc, x)
      defmethod break (this, x:O) : break(rc, x)
      defmethod close (this) : close(rc)
      defmethod is-equal? (this, b:WrappedCoroutine) : rc == raw(b)
      defmethod raw (this) : rc
      defmethod print (o:OutputStream, this) : print(o, rc)
   rc = RawCoroutine $ fn (rc, x0) :
      enter(c, x0)
   c

;                    Implementation
;                    ==============

lostanza deftype CoResult :
   value: ref<?>
   windout: ref<False|(? -> ?)>
   final?: ref<True|False>

val COROUTINE-ACTIVE = 0
val COROUTINE-CLOSED = 1
val COROUTINE-SUSPENDED = 2
val COROUTINE-OPEN = 3

lostanza var COROUTINE-COUNTER:long = 0
lostanza defn next-coroutine-id () -> long :
   val id = COROUTINE-COUNTER
   COROUTINE-COUNTER = COROUTINE-COUNTER + 1
   return id

lostanza var current-coroutine:ref<RawCoroutine> =
   new RawCoroutine{
      next-coroutine-id()
      false
      call-prim stack()
      call-prim stack()
      false
      false
      COROUTINE-ACTIVE}

lostanza defn RawCoroutine (enter: ref<((RawCoroutine, ?) -> ?)>) -> ref<RawCoroutine> :
   return new-stack<ref<RawCoroutine>>{setup-coroutine(enter)}

lostanza defmethod is-equal? (a:ref<RawCoroutine>, b:ref<RawCoroutine>) -> ref<True|False> :
   if a.id == b.id : return true
   else : return false

lostanza defmethod active? (c:ref<RawCoroutine>) -> ref<True|False> :
   if c.status == COROUTINE-ACTIVE : return true
   else : return false

lostanza defmethod open? (c:ref<RawCoroutine>) -> ref<True|False> :
   if c.status == COROUTINE-OPEN : return true
   else : return false

lostanza defn top (c:ref<RawCoroutine>) -> ref<Stack> :
   return c.top as ref<Stack>

lostanza defn bottom (c:ref<RawCoroutine>) -> ref<Stack> :
   return c.bottom as ref<Stack>

lostanza defn* setup-coroutine (enter: ref<((RawCoroutine,?) -> ?)>) -> ref<?> :
   val s = call-prim stack()
   val p = parent(s)
   s.parent = false
   val c = new RawCoroutine{next-coroutine-id(), false, s, s, false, false, COROUTINE-OPEN}
   val x0 = switch-stack<ref<?>>{p, c}
   return break(c, [enter](c, x0))

lostanza defmethod resume (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
   ;Ensure coroutine is re-entrant
   if c.status != COROUTINE-OPEN :
      return fatal("Unresumable Coroutine")

   ;Call its windin
   call-if-function(windin(c))

   ;Connect stacks, and attach coroutine
   current-coroutine.top = call-prim stack()
   bottom(c).parent = current-coroutine.top
   attach(c)

   ;Switch stacks
   val result = switch-stack<CoResult>{top(current-coroutine), x}

   ;Call its windout
   call-if-function(result.windout, result.final?)

   ;Switch stacks
   return result.value

lostanza defmethod* suspend (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
   ;Ensure coroutine is active
   if c.status != COROUTINE-ACTIVE :
      return fatal("Inactive Coroutine")

   ;Disconnect stacks, and Detach coroutine
   current-coroutine.top = call-prim stack()
   bottom(c).parent = false
   detach(c, false)

   ;Return to resume
   val result = CoResult{x, windout(c), false}
   return switch-stack<ref<?>>{top(current-coroutine), result}

lostanza defmethod* break (c:ref<RawCoroutine>, x:ref<?>) -> ref<Void> :
   ;Ensure coroutine is active
   if c.status != COROUTINE-ACTIVE :
      return fatal("Inactive Coroutine")

   ;Detach coroutine
   current-coroutine.top = call-prim stack()
   detach(c, false)

   ;Result to return to resume
   val result = CoResult{x, windout(c), true}

   ;Free the coroutine
   free(c)

   ;Switch stacks
   return switch-stack<ref<Void>>{top(current-coroutine), result}

lostanza defmethod close (c:ref<RawCoroutine>) -> ref<False> :
   if c.status == COROUTINE-CLOSED :
      return false
   else if c.status == COROUTINE-ACTIVE :
      return fatal("Cannot close active coroutine")
   else if c.status == COROUTINE-SUSPENDED :
      return fatal("Cannot close suspended coroutine")
   free(c)
   return false

lostanza defmethod is-equal? (a:ref<RawCoroutine>, b:ref<RawCoroutine>) -> ref<True|False> :
   if a.id == b.id : return true
   else : return false

lostanza defn* attach (c:ref<RawCoroutine>) -> int :
   val p = c.parent
   c.parent = current-coroutine
   c.status = COROUTINE-ACTIVE
   current-coroutine = c
   match(p) :
      (p:ref<RawCoroutine>) : return attach(p)
      (p:ref<False>) : return 0

lostanza defn* detach (c:ref<RawCoroutine>, tail:ref<RawCoroutine|False>) -> int :
   val cc = current-coroutine
   val ccp = current-coroutine.parent as ref<RawCoroutine>
   cc.parent = tail
   current-coroutine = ccp
   if c == cc :
      cc.status = COROUTINE-OPEN
      return 0
   else :
      cc.status = COROUTINE-SUSPENDED
      return detach(c, cc)

lostanza defn* free (c:ref<RawCoroutine>) -> int :
   val parent = c.parent
   c.status = COROUTINE-CLOSED
   free-stacks(top(c), bottom(c))
   c.top = false
   c.bottom = false
   c.parent = false
   c.windin = false
   c.windout = false
   match(parent) :
      (p:ref<RawCoroutine>) : return free(p)
      (p:ref<False>) : return 0

lostanza defn* free-stacks (top:ref<Stack>, bottom:ref<Stack>) -> int :
   if top == bottom :
      free-stack(top)
      return 0
   else :
      val p = parent(top)
      free-stack(top)
      return free-stacks(p, bottom)

defmethod print (o:OutputStream, c:RawCoroutine) :
   val s = switch {status(c) == _} :
      COROUTINE-ACTIVE : "ACTIVE"
      COROUTINE-CLOSED : "CLOSED"
      COROUTINE-SUSPENDED : "SUSPENDED"
      COROUTINE-OPEN : "OPEN"
   print(o, "<Coroutine #%_ : %_>" % [id(c), s])

lostanza defn id (c:ref<RawCoroutine>) -> ref<Int> : return new Int{c.id as int}
lostanza defn status (c:ref<RawCoroutine>) -> ref<Int> : return c.status


;============================================================
;======================= Utilities ==========================
;============================================================

;                       Sentinels
;                       =========

lostanza deftype Sentinel <: Equalable
lostanza val sentinel:ref<Sentinel> = new Sentinel{}

defmethod print (o:OutputStream, s:Sentinel) :
   print(o, '_')

;                       Errors
;                       ======

protected defn ensure-index-in-bounds (xs:Lengthable, i:Int) :
   if i < 0 or i >= length(xs) :
      fatal("Index (%_) out of bounds." % [i])

defn ensure-start-before-end (s:Int, e:Int) :
   if e < s :
      fatal("Given end index (%_) is smaller than start index (%_)." % [e, s])

protected defn ensure-non-negative (quantity:String, n:Int) :
   if n < 0 :
      fatal("Given %_ (%_) is negative." % [quantity, n])

protected defn ensure-positive (quantity:String, n:Int) :
   if n <= 0 :
      fatal("Given %_ (%_) is not positive." % [quantity, n])

protected defn ensure-non-negative-length (n:Int) :
   ensure-non-negative("length", n)   

protected defn ensure-index-range (xs:Lengthable, r:Range) :
   defn ensure-end-index-in-bounds (xs:Lengthable, i:Int) :
      if i < 0 or i > length(xs) :
         fatal("Index (%_) out of bounds." % [i])
      
   if step(r) != 1 :
      fatal("Given index range (%_) does not have a step of 1." % [r])
   val s = start(r)   
   match(end(r), inclusive?(r)) :
      (e:Int, inc?:True) :
         ensure-index-in-bounds(xs, s)
         ensure-index-in-bounds(xs, e)
         ensure-start-before-end(s, e)
      (e:Int, inc?:False) :
         ensure-end-index-in-bounds(xs, s)
         ensure-end-index-in-bounds(xs, e)
         ensure-start-before-end(s, e)
      (e:False, inc?) :
         ensure-index-in-bounds(xs, s)

protected defn range-bound (s:Lengthable, r:Range) -> [Int, Int] :
   match(end(r), inclusive?(r)) :
      (e:Int, i:True) : [start(r), e + 1]
      (e:Int, i:False) : [start(r), e]
      (e:False, i) : [start(r), length(s)]

;============================================================
;================ Initialization Phase 1 ====================
;============================================================

;                  Constant Initialization
;                  =======================

lostanza var const-ptr:ptr<?>
lostanza val BYTE-CONST-TAG : int = 0
lostanza val CHAR-CONST-TAG : int = 1
lostanza val INT-CONST-TAG : int = 2
lostanza val LONG-CONST-TAG : int = 3
lostanza val FLOAT-CONST-TAG : int = 4
lostanza val DOUBLE-CONST-TAG : int = 5
lostanza val TRUE-CONST-TAG : int = 6
lostanza val FALSE-CONST-TAG : int = 7
lostanza val LIST-CONST-TAG : int = 8
lostanza val STRING-CONST-TAG : int = 9
lostanza val SYMBOL-CONST-TAG : int = 10

lostanza defn initialize-constants () -> int :
   ;Initialize read pointer to beginning of the constant table
   ;[num, constants ...]
   const-ptr = call-prim constant-table()
   val n-consts = read-const-int()

   ;Initialize pre symbol table
   initialize-pre-symbol-table()

   ;First n-consts entries in the global table are for constants
   var gs:ptr<ref<?>> = call-prim globals()
   for (var i:int = 0, i < n-consts, i = i + 1) :
      gs[i] = read-const()

   ;Initialize Symbol Table
   initialize-symbol-table()

   return 0

lostanza defn read-const () -> ref<?> :
   val tag = read-const-int()
   if tag == BYTE-CONST-TAG :
      return new Byte{read-const-byte()}
   else if tag == CHAR-CONST-TAG :
      return new Char{read-const-byte()}
   else if tag == INT-CONST-TAG :
      return new Int{read-const-int()}
   else if tag == LONG-CONST-TAG :
      return new Long{read-const-long()}
   else if tag == FLOAT-CONST-TAG :
      return new Float{read-const-float()}
   else if tag == DOUBLE-CONST-TAG :
      return new Double{read-const-double()}
   else if tag == TRUE-CONST-TAG :
      return true
   else if tag == FALSE-CONST-TAG :
      return false
   else if tag == LIST-CONST-TAG :
      val len = read-const-int()
      return read-const-list(len)
   else if tag == STRING-CONST-TAG :
      val len = read-const-long()
      val chars = read-const-chars(len)
      return String(len, chars)
   else if tag == SYMBOL-CONST-TAG :
      val len = read-const-long()
      val chars = read-const-chars(len)
      return init-symbol(String(len, chars))
   else :
      call-c clib/fprintf(stderr, "Unknown constant tag: %ld\n", tag)
      return fatal("Unknown constant tag")

lostanza defn read-const-list (n:int) -> ref<List> :
   if n == 0 : return new NilList{}
   else : return new FullList{read-const(), read-const-list(n - 1)}

lostanza defn read-const-byte () -> byte :
   val value = [const-ptr as ptr<byte>]
   const-ptr = const-ptr + sizeof(byte)
   return value

lostanza defn read-const-int () -> int :
   val value = [const-ptr as ptr<int>]
   const-ptr = const-ptr + sizeof(int)
   return value

lostanza defn read-const-long () -> long :
   val value = [const-ptr as ptr<long>]
   const-ptr = const-ptr + sizeof(long)
   return value

lostanza defn read-const-float () -> float :
   val value = [const-ptr as ptr<float>]
   const-ptr = const-ptr + sizeof(float)
   return value

lostanza defn read-const-double () -> double :
   val value = [const-ptr as ptr<double>]
   const-ptr = const-ptr + sizeof(double)
   return value

lostanza defn read-const-chars (len:long) -> ptr<byte> :
   val value = const-ptr as ptr<byte>
   ;length chars + 0 character + pad to nearest 4 bytes
   val n = (len + 4) & -4
   const-ptr = (const-ptr + n) as ptr<?>
   return value

;                     Driver
;                     ======

lostanza: initialize-constants()

;============================================================
;============= Non-Printable Characters =====================
;============================================================

;TODO: Get rid of this once bootstrapped
val TAB-CHAR = to-char(9)
val BACKSPACE-CHAR = to-char(8)
val CARRIAGE-RETURN-CHAR = to-char(13)

;============================================================
;====================== Lengthable ==========================
;============================================================

public defmulti length (l:Lengthable) -> Int

;============================================================
;======================= Equalable =============================
;============================================================

protected defmulti is-equal? (a:Equalable, b:Equalable) -> True|False
defmethod is-equal? (a:Equalable, b:Equalable) : false

public lostanza defn equal? (a:ref<Equalable>, b:ref<Equalable>) -> ref<True|False> :
   if a == b : return true
   else : return is-equal?(a, b)

public defn not-equal? (a:Equalable, b:Equalable) -> True|False :
   complement(equal?(a, b))

;============================================================
;================== Seqable/Sequences =======================
;============================================================

public defmulti to-seq<?T> (s:Seqable<?T>) -> Seq<T>
defmethod to-seq<?T> (s:Seq<?T>) : s

public defmulti next<?T> (s:Seq<?T>) -> T
public defmulti peek<?T> (s:Seq<?T>) -> T
public defmulti empty? (s:Seq) -> True|False
public defmulti close (s:Seq) -> False

defn* do-seq<?T,?R> (f: Seq<T> -> ?R, s:Seqable<?T>) -> R :
   match(s) :
      (s:Seq<T>) :
         f(s)
      (s) :
         val s-seq = to-seq(s)
         dynamic-wind(
            false,
            fn* () : f(s-seq)
            fn* (final?) : close(s-seq) when final?)

;============================================================
;===================== Hashes ===============================
;============================================================

public defmulti hash (h:Hashable) -> Int

;============================================================
;=================== Comparable =============================
;============================================================

public defmulti compare<?T> (a:Comparable<?T>, b:T&Comparable) -> Int

public defmulti less?<?T> (a:Comparable<?T>, b:T&Comparable) -> True|False
public defmulti greater?<?T> (a:Comparable<?T>, b:T&Comparable) -> True|False
public defmulti less-eq?<?T> (a:Comparable<?T>, b:T&Comparable) -> True|False
public defmulti greater-eq?<?T> (a:Comparable<?T>, b:T&Comparable) -> True|False

defmethod less?<?T> (a:Comparable<?T>, b:T&Comparable) : compare(a, b) < 0
defmethod greater?<?T> (a:Comparable<?T>, b:T&Comparable) : compare(a, b) > 0
defmethod less-eq?<?T> (a:Comparable<?T>, b:T&Comparable) : compare(a, b) <= 0
defmethod greater-eq?<?T> (a:Comparable<?T>, b:T&Comparable) : compare(a, b) >= 0

;============================================================
;====================== ToString ============================
;============================================================

public defmulti to-string (x) -> String

;                Default Implementation
;                ======================

defmethod to-string (x) :
   val s = StringBuffer()
   print(s, x)
   to-string(s)

defmethod to-string (s:String) :
   s

;                  Primitive Values
;                  ================

lostanza val CONVERSION-BUFFER: ptr<byte> = call-c clib/malloc(32)

lostanza defmethod to-string (x:ref<Byte>) -> ref<String> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value as int)
   return String(n, CONVERSION-BUFFER)

defmethod to-string (x:Char) -> String :
   String(1, x)

lostanza defmethod to-string (x:ref<Int>) -> ref<String> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value)
   return String(n, CONVERSION-BUFFER)

lostanza defmethod to-string (x:ref<Long>) -> ref<String> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%ld", x.value)
   return String(n, CONVERSION-BUFFER)

lostanza defmethod to-string (x:ref<Float>) -> ref<String> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%f", x.value as double)
   return String(n, CONVERSION-BUFFER)

lostanza defmethod to-string (x:ref<Double>) -> ref<String> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%f", x.value)
   return String(n, CONVERSION-BUFFER)

defmethod to-string (x:True) :
   "true"

defmethod to-string (x:False) :
   "false"

;============================================================
;===================== OutputStream =========================
;============================================================

;                   General Interface
;                   =================

public defmulti print (o:OutputStream, x) -> False
public defmulti print-all (o:OutputStream, xs:Seqable) -> False

;                Default Implementations
;                =======================

defmethod print (o:OutputStream, x:Byte) : print(o, to-string(x))
defmethod print (o:OutputStream, x:Int) : print(o, to-string(x))
defmethod print (o:OutputStream, x:Long) : print(o, to-string(x))
defmethod print (o:OutputStream, x:Float) : print(o, to-string(x))
defmethod print (o:OutputStream, x:Double) : print(o, to-string(x))
defmethod print (o:OutputStream, x:True) : print(o, to-string(x))
defmethod print (o:OutputStream, x:False) : print(o, to-string(x))
defmethod print (o:OutputStream, x:String) : print-all(o, x)
defmethod print (o:OutputStream, x) : print(o, "[Unprintable Object]")

defmethod print-all (o:OutputStream, xs:Seqable) : do(print{o, _}, xs)

;                 Convenience Functions
;                 =====================

public defn println (o:OutputStream, x) :
   print(o, x)
   print(o, "\n")

public defn println-all (o:OutputStream, xs:Seqable) :
   print-all(o, xs)
   print(o, "\n")

;============================================================
;=================== FileOutputStream =======================
;============================================================

;TODO: Files and Directories.
;FileOutputStream streams are obtained from files.

public lostanza defn FileOutputStream (filename:ref<String>, append?:ref<True|False>) -> ref<FileOutputStream> :
   var file : ptr<?>
   if append? == true : file = call-c clib/fopen(filename.chars, "a")
   else : file = call-c clib/fopen(filename.chars, "w")
   if file == null : throw(FileOpenException(filename))
   return new FileOutputStream{file, 1}

public defn FileOutputStream (filename:String) :
   FileOutputStream(filename, false)

public lostanza defn close (o:ref<FileOutputStream>) -> ref<False> :
   if o.closable? :
      val err = call-c clib/fclose(o.file)
      if err != 0 : throw(FileCloseException())
   else : fatal("System OutputStream is not closable.")
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<String>) -> ref<False> :
   val r = call-c clib/fputs(x.chars, o.file)
   if r == EOF : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value as int)
   if r < 0 : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Char>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Int>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value)
   if r < 0 : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Long>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%ld", x.value)
   if r < 0 : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Float>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%f", x.value as double)
   if r < 0 : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Double>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%f", x.value as double)
   if r < 0 : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<True>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "true")
   if r < 0 : throw(FileWriteException())
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<False>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "false")
   if r < 0 : throw(FileWriteException())
   return false

public defn with-output-file<?T> (file:FileOutputStream, f: () -> ?T) -> T :
   with-output-stream(file, f)   

public defn spit (filename:String, x) -> False :
   val o = FileOutputStream(filename, false)
   try : print(o, x)
   finally : close(o)

;============================================================
;================ System Output Streams =====================
;============================================================

;                 System Output Streams
;                 =====================

public lostanza val STANDARD-OUTPUT-STREAM : ref<OutputStream> =
   new FileOutputStream{stdout, 0}

public lostanza val STANDARD-ERROR-STREAM : ref<OutputStream> =
   new FileOutputStream{stderr, 0}

;                 Current Output Stream
;                 =====================

var CURRENT-OUTPUT-STREAM : OutputStream = STANDARD-OUTPUT-STREAM

public defn with-output-stream<?T> (o:OutputStream, f: () -> ?T) -> T :
   let-var CURRENT-OUTPUT-STREAM = o :
      f()

public defn print (x) :
   print(CURRENT-OUTPUT-STREAM, x)

public defn println (x) :
   print(x)
   print("\n")

public defn print-all (xs:Seqable) :
   do(print, xs)

public defn println-all (xs:Seqable) :
   print-all(xs)
   print("\n")

;============================================================
;=================== Input Streams ==========================
;============================================================

;                      Interface
;                      =========

public defmulti fill (xs:CharArray, r:Range, i:InputStream) -> Int
public defmulti info (i:InputStream) -> FileInfo

;                Abstract Implementations
;                ========================

defmethod fill (xs:CharArray, r:Range, s:InputStream) -> Int :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   defn* loop (i:Int) :
      if i < e :
         if empty?(s) :
            i - b
         else :
            xs[i] = next(s)
            loop(i + 1)
      else : i - b
   loop(b)   

;============================================================
;================= File Input Streams =======================
;============================================================

lostanza deftype InputFile :
   file: ptr<?>
   closable?: long

lostanza defn InputFile (filename:ref<String>) -> ref<InputFile> :
   val file = call-c clib/fopen(filename.chars, "r")
   if file == null : throw(FileOpenException(filename))
   return new InputFile{file, 1}
   
lostanza defn close (i:ref<InputFile>) -> ref<False> :
   if i.closable? :
      val err = call-c clib/fclose(i.file)
      if err != 0 : throw(FileCloseException())
   else : fatal("System Input Stream is not closable.")
   return false

lostanza defn char? (i:ref<InputFile>) -> ref<Maybe<Char>> :
   val c = call-c clib/fgetc(i.file)
   if c == EOF :
      val err = call-c clib/ferror(i.file)
      if err != 0 : throw(FileReadException())
      return None()
   else :
      return One(new Char{c as byte})

defn FileInputStream (file:InputFile, filename:String) :
   val chars = repeat-while(char?{file})
   var line = 1
   var column = 0
   new FileInputStream :
      defmethod next (this) :
         val c = next(chars)
         if c == '\n' :
            line = line + 1
            column = 0
         else :
            column = column + 1
         c
      defmethod peek (this) : peek(chars)
      defmethod close (this) : (close(chars), close(file))
      defmethod empty? (this) : empty?(chars)
      defmethod info (this) : FileInfo(filename, line, column)

public defn FileInputStream (filename:String) :
   FileInputStream(InputFile(filename), filename)

public defn slurp (filename:String) :
   val s = FileInputStream(filename)
   try : string-join(s)
   finally : close(s)

;============================================================
;============== Input/Output Exceptions =====================
;============================================================

public deftype IOException <: Exception

public defstruct FileOpenException <: IOException :
   filename: String

defmethod print (o:OutputStream, e:FileOpenException) :
   print(o, "Error occurred when attempting to open file %~." % [filename(e)])

public defstruct FileCloseException <: IOException

defmethod print (o:OutputStream, e:FileCloseException) :
   print(o, "Error occurred when attempting to close file.")

public defstruct FileReadException <: IOException

defmethod print (o:OutputStream, e:FileReadException) :
   print(o, "Error occurred when attempting to read from file.")

public defstruct FileWriteException <: IOException

defmethod print (o:OutputStream, e:FileWriteException) :
   print(o, "Error occurred when attempting to write to file.")

;============================================================ 
;================ String Input Streams ======================
;============================================================

;                       Interface
;                       =========

public defmulti peek? (s:StringInputStream, i:Int) -> False|Char

;                Abstract Implementations
;                ========================

public defn peek? (s:StringInputStream) :
   peek?(s, 0)

public defn peek (s:StringInputStream, i:Int) :
   match(peek?(s, i)) :
      (c:Char) : c
      (c:False) : fatal("Could not peek at position %_ in stream." % [i])

;                   Implementation
;                   ==============

public defn StringInputStream (string:String, filename:String) :
   var start = 0
   var line = 1
   var column = 0
   val n = length(string)
   
   new StringInputStream :
      defmethod next (this) :
         val c = peek(this)
         start = start + 1
         if c == '\n' :
            line = line + 1
            column = 0
         else :
            column = column + 1
         c
      defmethod peek (this) :
         if start < n : string[start]
         else : fatal("Empty Stream")         
      defmethod info (this) :
         FileInfo(filename, line, column)
      defmethod peek? (this, i:Int) :
         string[start + i] when start + i < n
      defmethod empty? (this) :
         start >= n
      defmethod length (this) :
         start - n
      defmethod close (this) :
         start = n

public defn StringInputStream (string:String) :
   StringInputStream(string, "UnnamedStream")

;============================================================
;==================== Fatal Error ===========================
;============================================================

public lostanza defn fatal (msg:ref<?>) -> ref<Void> :
   call-c clib/fprintf(stderr, "FATAL ERROR: ")
   println(STANDARD-ERROR-STREAM, msg)
   print-stack-trace(call-prim sp())
   call-c clib/exit(-1)
   return null as ref<Void>

;============================================================
;===================== Formatting ===========================
;============================================================

deftype Printable

public defn modulo (format:String, args:Seqable) -> ? :
   new Printable :
      defmethod* print (o:OutputStream, this) :
         val seq = to-seq(args)
         val n = length(format)
         defn* loop (i:Int) :
            if i < n :
               val c = format[i]
               if c == '%' :
                  if i + 1 < n :
                     val modifier = format[i + 1]
                     switch {modifier == _} :
                        '_' : print(o, next(seq))
                        '*' : print-all(o, next(seq))
                        ',' : print-all(o, join(next(seq), ", "))
                        '~' : write(o, next(seq))
                        '@' : write-all(o, next(seq))
                        '%' : print(o, c)
                        else : fatal("Invalid argument specifier %~ in format string %~." % [modifier, format])
                     loop(i + 2)
                  else :
                     fatal("Incomplete argument specifier %% at end of format string %~." % [format])
               else :
                  print(o, c)
                  loop(i + 1)
            else :
               if not empty?(seq) :
                  fatal("Unexpected end of format string %~. More arguments remaining." % [format])
         loop(0)


;============================================================
;=================== Indented Streams =======================
;============================================================

public deftype IndentedStream <: OutputStream
defmulti stream (s:IndentedStream) -> OutputStream
defmulti indent (s:IndentedStream) -> Int

public defn IndentedStream (o:OutputStream, n:Int) :
   match(o) :
      (o:IndentedStream) :
         IndentedStream(stream(o), n + indent(o))
      (o) :
         var start-of-line? = true
         val spaces = String(n, ' ')
         defn put (c:Char) :
            if start-of-line? :
               print(o, spaces)
               start-of-line? = false
            print(o, c)
            if c == '\n' :
               start-of-line? = true
            
         new IndentedStream :
            defmethod stream (this) : o
            defmethod indent (this) : n
            defmethod print (this, c:Char) : put(c)

public defn do-indented (f: IndentedStream -> ?, o:OutputStream) :
   f(IndentedStream(o, 3))
   
public defn indented (f: () -> ?) :
   let-var CURRENT-OUTPUT-STREAM = IndentedStream(CURRENT-OUTPUT-STREAM, 3) :
      f()

;============================================================
;===================== Generators ===========================
;============================================================

public defn Generator<T> (thunk : (T -> False, (T -> Void) & (() -> Void)) -> ?) -> Seq<T> :
   ;State
   var item = sentinel

   ;Generator Coroutine
   val co = Coroutine<False, T|Sentinel> $ fn (co, x0) :
      defn co-yield (x:T) :
         suspend(co, x)
      val co-break = multifn :
         (x:T) : break(co, x)
         () : break(co, sentinel)
      thunk(co-yield, co-break)
      sentinel

   ;Fill state: Returns whether empty
   defn fill () :
      if (item typeof Sentinel) and open?(co) :
         item = resume(co, false)
      item typeof Sentinel

   ;Peek
   defn peek () :
      if item typeof Sentinel :
         fatal("Empty Sequence")
      item as T

   ;Empty bucket
   defn empty () :
      val x = peek()
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         peek()
      defmethod close (this) :
         item = sentinel
         close(co)
      defmethod empty? (this) :
         fill()

;============================================================
;====================== Labels ==============================
;============================================================

public defn* LabeledScope<T> (thunk: (T -> Void) -> T) -> T :
   val c = Coroutine<False,T> $ fn* (c, x0) :
      thunk(break{c, _})
   resume(c, false)

;============================================================
;====================== Maybe ===============================
;============================================================

;                      Interface
;                      =========

public defmulti value<?T> (x:One<?T>) -> T

;                     Constructors
;                     ============

public defn None () :
   new None

public defn One<?T> (x:?T) :
   new One<T> :
      defmethod value (this) : x

;                   Implementation
;                   ==============

public defn value!<?T> (x:Maybe<?T>) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : fatal("Object of type None has no value.")

public defn value?<?T> (x:Maybe<?T>) -> T|False :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : false

public defn empty? (x:Maybe) :
   x typeof None

defmethod is-equal? (a:None, b:None) :
   true

defmethod is-equal? (a:One, b:One) :
   value(a) == value(b)

;                   Comparisons
;                   ===========

defmethod* compare<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : 0
      (x:None, y:One<T>) : -1
      (x:One<T>, y:None) : 1
      (x:One<T&Comparable>, y:One<T&Comparable>) : compare(value(x), value(y))

defmethod less?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable>, y:One<T&Comparable>) : value(x) < value(y)

defmethod less-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable>, y:One<T&Comparable>) : value(x) <= value(y)

defmethod greater?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable>, y:One<T&Comparable>) : value(x) > value(y)

defmethod greater-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable>, y:One<T&Comparable>) : value(x) >= value(y)

;============================================================
;====================== Ranges ==============================
;============================================================

;                      Interface
;                      =========

public defmulti start (r:Range) -> Int
public defmulti end (r:Range) -> Int|False
public defmulti step (r:Range) -> Int
public defmulti inclusive? (r:Range) -> True|False

;                     Constructor
;                     ===========

public defn Range (start:Int, end:Int|False, step:Int, inclusive?:True|False) :
   ;Compute the length of the range
   val length = match(end, inclusive?) :
      (end:Int, inc:False) :
         if step == 0 :
            if step == end : 0
            else : false
         else if step == 1 :
            end - start
         else if step == -1 :
            start - end
         else if step > 0 :
            (end - start + step - 1) / step
         else :
            (end - start + step + 1) / step
      (end:Int, inc:True) :
         if step == 0 :
            false
         else if step == 1 :
            end - start + 1
         else if step == -1 :
            start - end + 1
         else :
            (end - start + step) / step
      (end:False, inc) :
         false

   match(length) :
      (length:Int) :
         new Range & Lengthable :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?
            defmethod length (this) : max(length, 0)
      (length:False) :
         new Range :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?

;                Conversion to Sequence
;                ======================

defmethod to-seq (r:Range) :
   match(r) :
      (r:Range & Lengthable) :
         var i = start(r)
         var n = length(r)
         new Seq<Int> & Lengthable :
            defmethod next (this) :
               val i* = peek(this)
               i = i + step(r)
               n = n - 1
               i*
            defmethod peek (this) :
               fatal("Empty Sequence") when n == 0
               i
            defmethod close (this) :
               n = 0
            defmethod empty? (this) :
               n == 0
            defmethod length (this) :
               n
      (r:Range) :
         var i = start(r)
         var closed? = false
         new Seq<Int> :
            defmethod next (this) :
               fatal("Empty Sequence") when closed?
               val i* = i
               i = i + step(r)
               i*
            defmethod peek (this) :
               fatal("Empty Sequence") when closed?
               i
            defmethod close (this) :
               closed? = true
            defmethod empty? (this) :
               closed?

;                 Comparison
;                 ==========

defmethod is-equal? (a:Range, b:Range) :
   start(a) == start(b) and
   end(a) == end(b) and
   step(a) == step(b) and
   inclusive?(a) == inclusive?(b)

;                  Printing
;                  ========

defmethod print (o:OutputStream, x:Range) :
   val op = "through" when inclusive?(x) else "to"
   if step(x) == 1 : print(o, "%_ %_ %_" % [start(x), op, end(x)])
   else : print(o, "%_ %_ %_ by %_" % [start(x), op, end(x), step(x)])

;                  Mapping
;                  =======

public defn map<?R> (f: Int -> ?R, r:Range) -> List<R> :
   to-list(seq(f, r))

;============================================================
;===================== Tuples ===============================
;============================================================

public lostanza defn Tuple<?T> (n:ref<Int>, x:ref<?T>) -> ref<Tuple<T>> :
   ensure-non-negative-length(n)
   val len = n.value
   val t = new Tuple<T>{len}[len]
   for (var i:long = 0, i < len, i = i + 1) :
      t.items[i] = x
   return t

lostanza defn set<?T> (x:ref<Tuple<?T>>, i:ref<Int>, v:ref<T>) -> ref<False> :
   ensure-index-in-bounds(x, i)
   x.items[i.value] = v
   return false

lostanza defmethod length (x:ref<Tuple>) -> ref<Int> :
   return new Int{x.length as int}

public lostanza defn get<?T> (x:ref<Tuple<?T>>, i:ref<Int>) -> ref<T> :
   ensure-index-in-bounds(x, i)
   return x.items[i.value]

public defn get<?T> (xs:Tuple<?T>, r:Range) -> Tuple<T> :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])   

defmethod to-seq<?T> (x:Tuple<?T>) :
   seq({x[_]}, 0 to length(x))

lostanza defmethod is-equal? (x:ref<Tuple>, y:ref<Tuple>) -> ref<True|False> :
   val n = x.length
   if n != y.length : return false
   for (var i:long = 0, i < n, i = i + 1) :
      if equal?(x.items[i], y.items[i]) == false :
         return false
   return true

defmethod hash (xs:Tuple) :
   var i = length(xs)
   for x in xs do :
      i = (7 * i) + hash(x)
   i

defmethod compare (a:Tuple<Comparable>, b:Tuple<Comparable>) -> Int :
   defn* loop (i:Int, j:Int) :
      if i < length(a) and j < length(b) :
         val c = compare(a[i], b[i])
         if c == 0 : loop(i + 1, j + 1)
         else : c
      else if i < length(a) : 1
      else if j < length(b) : -1
      else : 0
   loop(0, 0)

defmethod print (o:OutputStream, t:Tuple) -> False :
   print(o, "[%@]" % [t])

public defn to-tuple<?T> (xs:Seqable<?T>) -> Tuple<T> :
   match(xs) :
      (xs:Tuple<T>) :
         xs
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val t = Tuple(n, false as ?)
         for (x in xs, i in 0 to n) do :
            t[i] = x
         t
      (xs) :
         to-tuple(to-list(xs))

public defn map<?T,?R> (f:T -> ?R, xs:Tuple<?T>) -> Tuple<R> :
   to-tuple(seq(f, xs))

public defn empty? (t:Tuple) :
   length(t) == 0

;============================================================
;======================= Bytes ==============================
;============================================================

public lostanza defn shift-left (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value << b.value}

public lostanza defn shift-right (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value >> b.value}

public lostanza defn arithmetic-shift-right (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value >>> b.value}

public lostanza defn bit-or (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value | b.value}

public lostanza defn bit-xor (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value & b.value}

public lostanza defn bit-not (a:ref<Byte>) -> ref<Byte> :
   return new Byte{(~ a.value)}

public lostanza defn plus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value + b.value}

public lostanza defn minus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value - b.value}

public lostanza defn times (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value * b.value}

public lostanza defn divide (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value / b.value}

public lostanza defn modulo (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
   return new Byte{a.value % b.value}

lostanza defmethod compare (a:ref<Byte>, b:ref<Byte>) -> ref<Int> :
   return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false

lostanza defmethod is-equal? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
   if a.value == b.value : return true
   else : return false

lostanza defmethod hash (a:ref<Byte>) -> ref<Int> :
   return new Int{a.value}

;============================================================
;======================= Chars ==============================
;============================================================

lostanza defmethod compare (a:ref<Char>, b:ref<Char>) -> ref<Int> :
   return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false

lostanza defmethod is-equal? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
   if a.value == b.value : return true
   else : return false

lostanza defmethod hash (a:ref<Char>) -> ref<Int> :
   return new Int{a.value}

public lostanza defn digit? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= '0' and b <= '9' : return true
   else : return false

public lostanza defn letter? (c:ref<Char>) -> ref<True|False> :
   val b = c.value
   if b >= 'a' and b <= 'z' : return true
   else if b >= 'A' and b <= 'Z' : return true
   else : return false

;============================================================
;======================= Ints ===============================
;============================================================

public defn shift-left (a:Int, b:Int) -> Int :
   ($prim shl a b)

public defn shift-right (a:Int, b:Int) -> Int :
   ($prim shr a b)

public defn arithmetic-shift-right (a:Int, b:Int) -> Int :
   ($prim ashr a b)

public defn bit-or (a:Int, b:Int) -> Int :
   ($prim or a b)

public defn bit-and (a:Int, b:Int) -> Int :
   ($prim and a b)

public defn bit-xor (a:Int, b:Int) -> Int :
   ($prim xor a b)

public defn bit-not (a:Int) -> Int :
   ($prim not a)

public defn negate (a:Int) -> Int :
   ($prim neg a)

public defn plus (a:Int, b:Int) -> Int :
   ($prim add a b)

public defn minus (a:Int, b:Int) -> Int :
   ($prim sub a b)

public defn times (a:Int, b:Int) -> Int :
   ($prim mul a b)

public defn divide (a:Int, b:Int) -> Int :
   ($prim div a b)

public defn modulo (a:Int, b:Int) -> Int :
   ($prim mod a b)

defmethod compare (a:Int, b:Int) -> Int :
   a - b

defmethod less? (a:Int, b:Int) -> True|False :
   ($prim lt a b)

defmethod less-eq? (a:Int, b:Int) -> True|False :
   ($prim le a b)

defmethod greater? (a:Int, b:Int) -> True|False :
   ($prim gt a b)

defmethod greater-eq? (a:Int, b:Int) -> True|False :
   ($prim ge a b)

lostanza defmethod is-equal? (a:ref<Int>, b:ref<Int>) -> ref<True|False> :
   if a.value == b.value : return true
   else : return false

defmethod hash (a:Int) -> Int :
   a

;============================================================
;======================= Longs ==============================
;============================================================

public lostanza defn shift-left (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value << b.value}

public lostanza defn shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value >> b.value}

public lostanza defn arithmetic-shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value >>> b.value}

public lostanza defn bit-or (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value | b.value}

public lostanza defn bit-xor (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value & b.value}

public lostanza defn bit-not (a:ref<Long>) -> ref<Long> :
   return new Long{(~ a.value)}

public lostanza defn negate (a:ref<Long>) -> ref<Long> :
   return new Long{(- a.value)}

public lostanza defn plus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value + b.value}

public lostanza defn minus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value - b.value}

public lostanza defn times (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value * b.value}

public lostanza defn divide (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value / b.value}

public lostanza defn modulo (a:ref<Long>, b:ref<Long>) -> ref<Long> :
   return new Long{a.value % b.value}

lostanza defmethod compare (a:ref<Long>, b:ref<Long>) -> ref<Int> :
   if a.value < b.value : return new Int{-1}
   else if a.value > b.value : return new Int{1}
   else : return new Int{0}

lostanza defmethod less? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false

lostanza defmethod is-equal? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
   if a.value == b.value : return true
   else : return false

lostanza defmethod hash (a:ref<Long>) -> ref<Int> :
   val v = a.value
   return new Int{(v ^ (v >> 32)) as int}

;============================================================
;======================= Floats =============================
;============================================================

public lostanza defn negate (a:ref<Float>) -> ref<Float> :
   return new Float{(- a.value)}

public lostanza defn plus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
   return new Float{a.value + b.value}

public lostanza defn minus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
   return new Float{a.value - b.value}

public lostanza defn times (a:ref<Float>, b:ref<Float>) -> ref<Float> :
   return new Float{a.value * b.value}

public lostanza defn divide (a:ref<Float>, b:ref<Float>) -> ref<Float> :
   return new Float{a.value / b.value}

lostanza defmethod compare (a:ref<Float>, b:ref<Float>) -> ref<Int> :
   if a.value < b.value : return new Int{-1}
   else if a.value > b.value : return new Int{1}
   else : return new Int{0}

lostanza defmethod less? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false

lostanza defmethod is-equal? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
   if a.value == b.value : return true
   else : return false

defmethod hash (a:Float) -> Int :
   bits(a)

;============================================================
;======================= Doubles ============================
;============================================================

public lostanza defn negate (a:ref<Double>) -> ref<Double> :
   return new Double{(- a.value)}

public lostanza defn plus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
   return new Double{a.value + b.value}

public lostanza defn minus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
   return new Double{a.value - b.value}

public lostanza defn times (a:ref<Double>, b:ref<Double>) -> ref<Double> :
   return new Double{a.value * b.value}

public lostanza defn divide (a:ref<Double>, b:ref<Double>) -> ref<Double> :
   return new Double{a.value / b.value}

lostanza defmethod compare (a:ref<Double>, b:ref<Double>) -> ref<Int> :
   if a.value < b.value : return new Int{-1}
   else if a.value > b.value : return new Int{1}
   else : return new Int{0}

lostanza defmethod less? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value < b.value : return true
   else : return false

lostanza defmethod less-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value <= b.value : return true
   else : return false

lostanza defmethod greater? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value > b.value : return true
   else : return false

lostanza defmethod greater-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value >= b.value : return true
   else : return false

lostanza defmethod is-equal? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
   if a.value == b.value : return true
   else : return false

lostanza defmethod hash (a:ref<Double>) -> ref<Int> :
   val v = a.value
   val bits = ($ls-prim bits v)
   return new Int{(bits ^ (bits >> 32)) as int}

;============================================================
;====================== Strings =============================
;============================================================

lostanza defn String (len:long, chars:ptr<byte>) -> ref<String> :
   return init-string(String(len), chars)

lostanza defn String (len:long) -> ref<String> :
   return new String{len, 0}[len + 1]

lostanza defn init-string (s:ref<String>, chars:ptr<byte>) -> ref<String> :
   val n = s.length
   for (var i:long = 0, i < n, i = i + 1) :
      s.chars[i] = chars[i]
   s.chars[n] = 0 as byte
   return s

lostanza defn init-string (s:ref<String>, char:byte) -> ref<String> :
   val n = s.length
   for (var i:long = 0, i < n, i = i + 1) :
      s.chars[i] = char
   s.chars[n] = 0 as byte
   return s

public lostanza defn String (len:long, c:byte) -> ref<String> :
   return init-string(String(len), c)

public lostanza defn String (len:ref<Int>, c:ref<Char>) -> ref<String> :
   ensure-non-negative-length(len)
   return String(len.value, c.value)

lostanza defn set (s:ref<String>, i:ref<Int>, c:ref<Char>) -> ref<False> :
   ensure-index-in-bounds(s, i)
   s.chars[i.value] = c.value
   return false

public defn String (cs:Seqable<Char>) -> String :
   match(cs) :
      (cs:Seqable<Char> & Lengthable) :
         val n = length(cs)
         val s = String(n, ' ')
         for (c in cs, i in 0 to false) do :
            s[i] = c
         s
      (c) :
         String(to-vector<Char>(cs))

lostanza defn chars-hash (n:long, p:ptr<byte>) -> int :
   var h:int = 0
   for (var i:long = 0, i < n, i = i + 1) :
      h = (31 * h) + p[i]
   if h == 0 : return 1
   else : return h

public lostanza defmethod hash (s:ref<String>) -> ref<Int> :
   if s.hash == 0 :
      s.hash = chars-hash(s.length, s.chars)
   return new Int{s.hash}

public lostanza defmethod length (s:ref<String>) -> ref<Int> :
   return new Int{s.length as int}

public lostanza defn get (s:ref<String>, i:ref<Int>) -> ref<Char> :
   ensure-index-in-bounds(s, i)
   return new Char{s.chars[i.value]}

defmethod to-seq (s:String) :
   seq({s[_]}, 0 to length(s))

lostanza defmethod is-equal? (a:ref<String>, b:ref<String>) -> ref<True|False> :
   val n = a.length
   if n == b.length :
      for (var i:long = 0, i < n, i = i + 1) :
         if a.chars[i] != b.chars[i] :
            return false
      return true
   else :
      return false

lostanza defmethod compare (a:ref<String>, b:ref<String>) -> ref<Int> :
   val c = compare-strings(a.chars, b.chars, a.length, b.length)
   return new Int{c}

lostanza defn* compare-strings (a:ptr<byte>, b:ptr<byte>, na:long, nb:long) -> int :
   if (na == 0) and (nb == 0) :
      return 0
   else if na == 0 :
      return -1
   else if nb == 0 :
      return 1
   else :
      val ac = [a]
      val bc = [b]
      if ac < bc : return -1
      else if ac > bc : return 1
      else : return compare-strings(a + 1, b + 1, na - 1, nb - 1)


;============================================================
;======================= Lists ==============================
;============================================================

;                      Interface
;                      =========

public defmulti head<?T> (x:List<?T>) -> T
public defmulti tail<?T> (x:List<?T>) -> List<T>

;                    Constructors
;                    ============

public lostanza defn List () -> ref<NilList> :
   return new NilList{}

public lostanza defn cons<?T> (x:ref<?T>, t:ref<List<?T>>) -> ref<FullList<T>> :
   return new FullList<T>{x, t}

public defn cons<?T> (x:?T, y:?T, t:List<?T>) -> FullList<T> :
   cons(x, cons(y, t))

public defn cons<?T> (x:?T, y:?T, z:?T, t:List<?T>) -> FullList<T> :
   cons(x, cons(y, cons(z, t)))

public defn List<?T> (x:?T) -> FullList<T> :
   cons(x, List())

public defn List<?T> (x:?T, y:?T) -> FullList<T> :
   cons(x, cons(y, List()))

public defn List<?T> (x:?T, y:?T, z:?T) -> FullList<T> :
   cons(x, cons(y, cons(z, List())))

public defn List<?T> (w:?T, x:?T, y:?T, z:?T) -> FullList<T> :
   cons(w, cons(x, cons(y, cons(z, List()))))

;                     Implementation
;                     ==============

public defn empty? (x:List) :
   x typeof NilList

lostanza defmethod head<?T> (x:ref<FullList<?T>>) -> ref<T> :
   return x.head

lostanza defmethod tail<?T> (x:ref<FullList<?T>>) -> ref<List<T>> :
   return x.tail

defmethod head (x:NilList) : fatal("Object of type NilList has no head.")
defmethod tail (x:NilList) : fatal("Object of type NilList has no tail.")

defmethod length (x:List) :
   defn* loop (x:List, n:Int) :
      match(x) :
         (x:FullList) : loop(tail(x), n + 1)
         (x:NilList) : n
   loop(x, 0)

defmethod to-seq<?T> (x:List<?T>) :
   var l = x
   new Seq<T> :
      defmethod empty? (this) :
         l typeof NilList
      defmethod next (this) :
         val x = peek(this)
         l = tail(l)
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         head(l)
      defmethod close (this) :
         l = List()

defmethod is-equal? (a:List, b:List) -> True|False :
   defn* loop (a:List, b:List) :
      match(a, b) :
         (a:NilList, b:NilList) : true
         (a:FullList<Equalable>, b:FullList<Equalable>) :
            if head(a) == head(b) :
               loop(tail(a), tail(b))
         (a, b) : false
   loop(a, b)

defmethod hash (xs:List<Hashable>) -> Int :
   var i = 0
   for x in xs do :
      i = (7 * i) + hash(x)
   i

defmethod compare (xs:List<Comparable>, ys:List<Comparable>) -> Int :
   defn* loop (xs:List<Comparable>, ys:List<Comparable>) :
      match(xs, ys) :
         (xs:NilList, ys:NilList) : 0
         (xs:NilList, ys:FullList) : -1
         (xs:FullList, ys:NilList) : 1
         (xs:FullList<Comparable>, ys:FullList<Comparable>) :
            val c = compare(head(xs), head(ys))
            if c == 0 : loop(tail(xs), tail(ys))
            else : c
   loop(xs, ys)

defmethod print (o:OutputStream, xs:List) -> False :
   print(o, "(%@)" % [xs])

public defn to-list<?T> (xs:Seqable<?T>) -> List<T> :
   match(xs) :
      (xs:List<T>) :
         xs
      (xs) :
         val xs-seq = to-seq(xs)
         defn loop () :
            if empty?(xs-seq) : List()
            else : cons(next(xs-seq), loop())
         loop()

public defn in-reverse<?T> (xs:List<?T>) -> Seq<T> :
   generate<T> :
      defn loop (xs:List<T>) :
         if not empty?(xs) :
            loop(tail(xs))
            yield(head(xs))
      loop(xs)      

;============================================================
;===================== True/False ===========================
;============================================================

public defn complement (a:True|False) -> True|False :
   if a : false
   else : true

;============================================================
;=================== IndexedCollections =====================
;============================================================

;                       Interface
;                       =========

public defmulti get<?T> (a:IndexedCollection<?T>, i:Int) -> T
public defmulti set<?T> (a:IndexedCollection<?T>, i:Int, v:T) -> False
public defmulti get<?T> (a:IndexedCollection<?T>, r:Range) -> Many<T>
public defmulti set<?T> (a:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False
public defmulti map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False

;                 Abstract Implementations
;                 ========================

public defn empty? (v:IndexedCollection) :
   length(v) == 0

defmethod print (o:OutputStream, a:IndexedCollection) -> False :
   print(o, "[%@]" % [a])

defmethod map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False :
   for i in 0 to length(xs) do :
      xs[i] = f(xs[i])

defmethod get<?T> (xs:IndexedCollection<?T>, r:Range) -> Tuple<T> :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])

defmethod set<?T> (xs:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   val vs-seq = to-seq(vs)
   for i in b to e do : xs[i] = next(vs-seq)

defmethod to-seq<?T> (xs:IndexedCollection<?T>) -> Seq<T> :
   seq({xs[_]}, 0 to length(xs))

public defn reverse!<?T> (xs:IndexedCollection<?T>) -> False :
   val n = length(xs)
   for i in 0 to n / 2 do :
      val j = n - 1 - i
      val xi = xs[i]
      val xj = xs[j]
      xs[i] = xj
      xs[j] = xi

public defn in-reverse<?T> (xs:IndexedCollection<?T>) -> Seq<T> :
   val n = length(xs)
   for i in (n - 1) through 0 by -1 seq :
      xs[i]   

;                       Sorting
;                       =======

public defn qsort!<?T> (xs:IndexedCollection<?T>, is-less?:(T,T) -> True|False) -> False :
   ;Swap element i with element j
   defn swap (i:Int, j:Int) :
      if i != j :
         val xi = xs[i]
         val xj = xs[j]
         xs[i] = xj
         xs[j] = xi
      
   ;Rearrange elements from b to e, such that the first elements is less than pivot.
   ;Returns a s.t. all elements from b to a are less than pivot.
   defn partition (b:Int, e:Int, pivot:T) :
      defn* loop (a:Int, b:Int) -> Int :
         if b < e :
            val xb = xs[b]
            if is-less?(xb, pivot) :
               swap(a, b)
               loop(a + 1, b + 1)
            else : loop(a, b + 1)
         else : a
      loop(b, b)

   ;Driver
   defn* sort (b:Int, e:Int) :
      val n = e - b
      if n > 2 :
         swap(rand(b to e), e - 1) when n > 10
         val e1 = partition(b, e - 1, xs[e - 1])
         swap(e1, e - 1)
         sort(b, e1)
         sort(e1 + 1, e)
      else if n == 2 :
         swap(b, b + 1) when is-less?(xs[b + 1], xs[b])
         
   sort(0, length(xs))

public defn qsort!<?T> (xs:IndexedCollection<?T&Comparable>) -> False :
   qsort!(xs, less?)   
         
;                       Lazy Sorting
;                       ============

public defn lazy-qsort<?T> (coll:Seqable<?T>, is-less?:(T,T) -> True|False) -> Many<T> & Lengthable :
   ;Convert to a vector
   val xs = to-vector<T>(coll)

   ;Sort Progress
   defn sort-progress () :
      generate<Int> :
         ;Swap element i with element j
         defn swap (i:Int, j:Int) :
            if i != j :
               val xi = xs[i]
               val xj = xs[j]
               xs[i] = xj
               xs[j] = xi
            
         ;Rearrange elements from b to e, such that the first elements is less than pivot.
         ;Returns a s.t. all elements from b to a are less than pivot.
         defn partition (b:Int, e:Int, pivot:T) :
            defn* loop (a:Int, b:Int) -> Int :
               if b < e :
                  val xb = xs[b]
                  if is-less?(xb, pivot) :
                     swap(a, b)
                     loop(a + 1, b + 1)
                  else : loop(a, b + 1)
               else : a
            loop(b, b)

         ;Driver
         defn* sort (b:Int, e:Int) :
            val n = e - b
            if n > 2 :
               swap(rand(b to e), e - 1) when n > 10
               val e1 = partition(b, e - 1, xs[e - 1])
               swap(e1, e - 1)
               sort(b, e1)
               yield(e1 + 1)
               sort(e1 + 1, e)
            else if n == 2 :
               swap(b, b + 1) when is-less?(xs[b + 1], xs[b])
         
         sort(0, length(xs))
         break(length(xs))

   ;Ensuring Progress
   var sorted = 0
   val sorter = sort-progress()
   defn* ensure-sorted (n:Int) :
      if sorted < n :
         sorted = next(sorter)
         ensure-sorted(n)

   ;Return object
   new Many<T> & Lengthable :
      defmethod length (this) :
         length(xs)
      defmethod to-seq (this) :   
         for i in 0 to length(xs) seq :
            ensure-sorted(i + 1)
            xs[i]

public defn lazy-qsort<?T> (coll:Seqable<?T&Comparable>) :
   lazy-qsort(coll, less?)
      

;============================================================
;======================= Arrays =============================
;============================================================

;                 Abstract Implementations
;                 ========================

public defn to-array<T> (xs:Seqable<T>) -> Array<T> :
   match(xs) :
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val a = Array<T>(n)
         for (x in xs, i in 0 to n) do :
            a[i] = x
         a
      (xs) :
         to-array<T>(to-list(xs))

public defn map<R,?T> (f: T -> R, xs:Array<?T>) -> Array<R> :
   val ret = Array<R>(length(xs))
   for (x in xs, i in 0 to false) do :
      ret[i] = f(x)
   ret   

;                     Implementation
;                     ==============

lostanza deftype RawArray <: Array :
   length: long
   items: ref<?> ...

lostanza defn RawArray (n:ref<Int>, x:ref<?>) -> ref<RawArray> :
   val l = n.value
   val a = new RawArray{l}[l]
   for (var i:long = 0, i < l, i = i + 1) :
      a.items[i] = x
   return a

lostanza defmethod get (a:ref<RawArray>, i:ref<Int>) -> ref<?> :
   ensure-index-in-bounds(a, i)
   match(a.items[i.value]) :
      (x:ref<Sentinel>) :
         uninitialized-element(i)
         return false
      (x) :
         return x

lostanza defmethod set (a:ref<RawArray>, i:ref<Int>, v:ref<?>) -> ref<False> :
   ensure-index-in-bounds(a, i)
   a.items[i.value] = v
   return false

defn uninitialized-element (i:Int) :
   fatal("Index (%_) is uninitialized." % [i])

lostanza defmethod length (a:ref<RawArray>) -> ref<Int> :
   return new Int{a.length as int}

lostanza defn get! (a:ref<RawArray>, i:ref<Int>) -> ref<?> :
   return a.items[i.value]

defmethod print (o:OutputStream, a:RawArray) -> False :
   val xs = seq(get!{a, _}, 0 to length(a))
   print(o, "[%@]" % [xs])

;                     Wrapping
;                     ========

deftype WrappedArray<T> <: Array<T>
defmulti raw (a:WrappedArray) -> RawArray

public defn Array<T> (n:Int) :
   ensure-non-negative("length", n)
   Array<T>(RawArray(n, sentinel))

public defn Array<T> (n:Int, x:T) :
   ensure-non-negative("length", n)
   Array<T>(RawArray(n, x))

defn Array<T> (a:RawArray) -> Array<T> :
   new WrappedArray<T> :
      defmethod raw (this) : a
      defmethod get (this, i:Int) : get(a, i)
      defmethod set (this, i:Int, v:T) : set(a, i, v)
      defmethod length (this) : length(a)
      defmethod print (o:OutputStream, this) : print(o, a)
      defmethod is-equal? (this, x:WrappedArray) : a == raw(x)


;============================================================
;==================== CharArrays ============================
;============================================================

;                     Implementation
;                     ==============

public lostanza defn CharArray (n:ref<Int>, x:ref<Char>) -> ref<CharArray> :
   ensure-non-negative-length(n)
   val l = n.value
   val a = new CharArray{l}[l]
   val c = x.value
   for (var i:long = 0, i < l, i = i + 1) :
      a.chars[i] = c
   return a

public defn CharArray (n:Int) -> CharArray :
   CharArray(n, ' ')

lostanza defmethod get (a:ref<CharArray>, i:ref<Int>) -> ref<Char> :
   ensure-index-in-bounds(a, i)
   return new Char{a.chars[i.value]}

lostanza var char-array-set-num:long = 0
lostanza defmethod set (a:ref<CharArray>, i:ref<Int>, c:ref<Char>) -> ref<False> :
   char-array-set-num = char-array-set-num + 1
   ensure-index-in-bounds(a, i)
   a.chars[i.value] = c.value
   return false

lostanza defmethod length (a:ref<CharArray>) -> ref<Int> :
   return new Int{a.length as int}

;============================================================
;=================== StringBuffer ===========================
;============================================================

;                     Interface
;                     =========

public defmulti add (s:StringBuffer, c:Char) -> False
public defmulti add-all (s:StringBuffer, c:Seqable<Char>) -> False
public defmulti clear (s:StringBuffer) -> False

;               Abstract Implementation
;               =======================

defmethod add-all (s:StringBuffer, xs:Seqable<Char>) :
   do(add{s, _}, xs)

defmethod print (s:StringBuffer, c:Char) :
   add(s, c)

defmethod print-all (s:StringBuffer, cs:String|StringBuffer|CharArray) :
   add-all(s, cs)

defmethod print (o:OutputStream, s:StringBuffer) :
   print-all(o, s)

defmethod write (o:OutputStream, s:StringBuffer) :
   print(o, '"')
   for c in s do :
      escape-for-string(o, c)
   print(o, '"')   

;                   Implementation
;                   ==============

public defn StringBuffer (n:Int) -> StringBuffer :
   ensure-non-negative("length", n)
   var buffer = CharArray(n)
   var len = 0

   defn ensure-capacity (c:Int) :
      defn set-capacity (c:Int) :
         val buffer* = CharArray(c)
         for i in 0 to len do :
            buffer*[i] = buffer[i]
         buffer = buffer*
      val cur-c = length(buffer)
      set-capacity(max(c, 2 * cur-c)) when c > cur-c

   new StringBuffer :
      defmethod add (this, c:Char) :
         ensure-capacity(len + 1)
         buffer[len] = c
         len = len + 1

      defmethod add-all (this, xs:Seqable<Char> & Lengthable) :
         val n = length(xs)
         ensure-capacity(len + n)
         for (x in xs, i in 0 to n) do :
            buffer[len + i] = x
         len = len + n

      defmethod clear (this) :
         len = 0

      defmethod get (this, i:Int) :
         ensure-index-in-bounds(this, i)
         buffer[i]

      defmethod set (this, i:Int, c:Char) :
         if i == len :
            add(this, c)
         else :
            ensure-index-in-bounds(this, i)
            buffer[i] = c

      defmethod length (this) :
         len

      defmethod to-string (this) :
         subchars(len, buffer)

public defn StringBuffer () :
   StringBuffer(32)

lostanza defn subchars (n:ref<Int>, b:ref<CharArray>) -> ref<String> :
   val s = String(n.value)
   return init-string(s, b.chars)

;============================================================
;===================== FileInfo =============================
;============================================================

;                     Interface
;                     =========

public defmulti filename (i:FileInfo) -> String
public defmulti line (i:FileInfo) -> Int
public defmulti column (i:FileInfo) -> Int

;                  Implementation
;                  ==============

public defn FileInfo (f:String, l:Int, c:Int) :
   new FileInfo :
      defmethod filename (this) : f
      defmethod line (this) : l
      defmethod column (this) : c

defmethod is-equal? (a:FileInfo, b:FileInfo) :
   filename(a) == filename(b) and
   line(a) == line(b) and
   column(a) == column(b)

defmethod hash (i:FileInfo) :
   hash(filename(i)) +
   7 * hash(line(i)) +
   49 * hash(column(i))

defmethod compare (a:FileInfo, b:FileInfo) :
   val c = compare(filename(a), filename(b))
   if c == 0 :
      val c = compare(line(a), line(b))
      if c == 0 :
         compare(column(a), column(b))
      else : c
   else : c

defmethod print (o:OutputStream, i:FileInfo) :   
   print(o, filename(i))
   print(o, ":")
   print(o, line(i))
   print(o, ".")
   print(o, column(i))

;============================================================
;====================== Tokens ==============================
;============================================================

;                      Interface
;                      =========

public defmulti item (t:Token) -> ?
public defmulti info (t:Token) -> FileInfo

;                     Constructor
;                     ===========

public defn Token (item, info:FileInfo) :
   new Token :
      defmethod item (this) : item
      defmethod info (this) : info

public defn unwrap-token (t) :
   match(t) :
      (t:Token) : unwrap-token(item(t))
      (t) : t

public defn unwrap-all (t) -> ? :
   match(t) :
      (t:Token) : unwrap-all(item(t))
      (t:List) : map(unwrap-all, t)
      (t) : t

defmethod print (o:OutputStream, t:Token) :
   write(o, item(t))

defmethod is-equal? (a:Token, b:Token) :
   equal?(item(a), item(b))


;============================================================
;==================== KeyValue Pairs ========================
;============================================================

;                       Interface
;                       =========

public defmulti key<?K> (kv:KeyValue<?K,?>) -> K
public defmulti value<?V> (kv:KeyValue<?,?V>) -> V

;                      Constructor
;                      ===========

public defn KeyValue<?K,?V> (k:?K, v:?V) -> KeyValue<K,V> :
   new KeyValue<K,V> :
      defmethod key (this) : k
      defmethod value (this) : v

defmethod print (o:OutputStream, v:KeyValue) :
   write(o, key(v))
   print(o, " => ")
   write(o, value(v))



;============================================================
;===================== Exception ============================
;============================================================

var CURRENT-EXCEPTION-HANDLER : Exception -> Void =
   fn (e:Exception) :
      fatal(e)

defmethod print (o:OutputStream, e:Exception) :
   print(o, "Exception")

public defn throw (e:Exception) :
   CURRENT-EXCEPTION-HANDLER(e)

defstruct ExceptionResult : (exception: Exception)
defstruct NormalResult : (result)

public defn with-exception-handler<?T> (body: () -> ?T,
                                        handler: Exception -> ?T) -> T :
   val r = label<ExceptionResult|NormalResult> break :
      let-var CURRENT-EXCEPTION-HANDLER = break{ExceptionResult(_)} :
         NormalResult(body())
   match(r) :
      (r:ExceptionResult) : handler(exception(r))
      (r:NormalResult) : result(r)

public defn with-finally<?T> (body: () -> ?T, finally: (True|False) -> ?) -> T :
   var entered? = false
   dynamic-wind(
      fn () :
         fatal("Cannot re-enter body with finally clause.") when entered?
         entered? = true
      body
      finally)


;============================================================
;================== Failure Handler =========================
;============================================================

var CURRENT-FAILURE-HANDLER : () -> Void =
   fn () :
      fatal("Uncaught failure")

public defn fail () :
   CURRENT-FAILURE-HANDLER()

public defn with-attempt<?T> (conseq: () -> ?T, alt: () -> ?T) :
   val result = label<Maybe<T>> return :
      let-var CURRENT-FAILURE-HANDLER = fn* () : return(None()) :
         One(conseq())
   match(result) :
      (r:One<T>) : value(r)
      (r:None) : alt()

;============================================================
;==================== Conversions ===========================
;============================================================

;                 Numeric Conversions
;                 ===================

public lostanza defn to-byte (b:ref<Byte>) -> ref<Byte> : return b
public lostanza defn to-byte (c:ref<Char>) -> ref<Byte> : return new Byte{c.value}
public lostanza defn to-byte (i:ref<Int>) -> ref<Byte> : return new Byte{i.value as byte}
public lostanza defn to-byte (l:ref<Long>) -> ref<Byte> : return new Byte{l.value as byte}
public lostanza defn to-byte (f:ref<Float>) -> ref<Byte> : return new Byte{f.value as byte}
public lostanza defn to-byte (d:ref<Double>) -> ref<Byte> : return new Byte{d.value as byte}
public lostanza defn to-char (b:ref<Byte>) -> ref<Char> : return new Char{b.value}
public lostanza defn to-char (c:ref<Char>) -> ref<Char> : return c
public lostanza defn to-char (i:ref<Int>) -> ref<Char> : return new Char{i.value as byte}
public lostanza defn to-int (b:ref<Byte>) -> ref<Int> : return new Int{b.value}
public lostanza defn to-int (c:ref<Char>) -> ref<Int> : return new Int{c.value}
public lostanza defn to-int (i:ref<Int>) -> ref<Int> : return i
public lostanza defn to-int (l:ref<Long>) -> ref<Int> : return new Int{l.value as int}
public lostanza defn to-int (f:ref<Float>) -> ref<Int> : return new Int{f.value as int}
public lostanza defn to-int (d:ref<Double>) -> ref<Int> : return new Int{d.value as int}
public lostanza defn to-long (b:ref<Byte>) -> ref<Long> : return new Long{b.value}
public lostanza defn to-long (i:ref<Int>) -> ref<Long> : return new Long{i.value}
public lostanza defn to-long (l:ref<Long>) -> ref<Long> : return l
public lostanza defn to-long (f:ref<Float>) -> ref<Long> : return new Long{f.value as long}
public lostanza defn to-long (d:ref<Double>) -> ref<Long> : return new Long{d.value as long}
public lostanza defn to-float (b:ref<Byte>) -> ref<Float> : return new Float{b.value as float}
public lostanza defn to-float (i:ref<Int>) -> ref<Float> : return new Float{i.value as float}
public lostanza defn to-float (l:ref<Long>) -> ref<Float> : return new Float{l.value as float}
public lostanza defn to-float (f:ref<Float>) -> ref<Float> : return f
public lostanza defn to-float (d:ref<Double>) -> ref<Float> : return new Float{d.value as float}
public lostanza defn to-double (b:ref<Byte>) -> ref<Double> : return new Double{b.value as double}
public lostanza defn to-double (i:ref<Int>) -> ref<Double> : return new Double{i.value as double}
public lostanza defn to-double (l:ref<Long>) -> ref<Double> : return new Double{l.value as double}
public lostanza defn to-double (f:ref<Float>) -> ref<Double> : return new Double{f.value}
public lostanza defn to-double (d:ref<Double>) -> ref<Double> : return d

;                Numeric Reinterpretations
;                =========================

public lostanza defn bits (f:ref<Float>) -> ref<Int> :
   val v = f.value
   return new Int{($ls-prim bits v)}

public lostanza defn bits (d:ref<Double>) -> ref<Long> :
   val v = d.value
   return new Long{($ls-prim bits v)}

public lostanza defn bits-as-float (i:ref<Int>) -> ref<Float> :
   val v = i.value
   return new Float{($ls-prim fnum v)}

public lostanza defn bits-as-double (i:ref<Long>) -> ref<Double> :
   val v = i.value
   return new Double{($ls-prim fnum v)}


;============================================================
;==================== Number Parsing ========================
;============================================================

;                        Drivers
;                        =======

public defn to-byte (s:String) -> False|Byte :
   match(to-int(s)) :
      (i:Int) : to-byte(i) when i >= 0 and i <= 255
      (i:False) : false

public lostanza defn to-int (s:ref<String>) -> ref<False|Int> :
   if prefix?(s.chars, "-") :
      return neg-to-int(s, 1, 10)
   else if prefix?(s.chars, "0x") :
      return bits-to-int(s, 2, 16, 4)
   else if prefix?(s.chars, "0o") :
      return bits-to-int(s, 2, 8, 3)
   else if prefix?(s.chars, "0b") :
      return bits-to-int(s, 2, 2, 1)
   else :
      return pos-to-int(s, 0, 10)

public lostanza defn to-long (s:ref<String>) -> ref<False|Long> :
   if prefix?(s.chars, "-") :
      return neg-to-long(s, 1, 10)
   else if prefix?(s.chars, "0x") :
      return bits-to-long(s, 2, 16, 4)
   else if prefix?(s.chars, "0o") :
      return bits-to-long(s, 2, 8, 3)
   else if prefix?(s.chars, "0b") :
      return bits-to-long(s, 2, 2, 1)
   else :
      return pos-to-long(s, 0, 10)

;TODO: This is necessary because addresses of local variables don't work yet.
lostanza var DOUBLE-BUFFER : double
lostanza var CHAR-BUFFER : byte
public lostanza defn to-double (s:ref<String>) -> ref<False|Double> :
   val n = call-c clib/sscanf(s.chars, "%lf%c", addr(DOUBLE-BUFFER), addr(CHAR-BUFFER))
   if n != 1 : return false
   else : return new Double{DOUBLE-BUFFER}

lostanza var FLOAT-BUFFER : float
public lostanza defn to-float (s:ref<String>) -> ref<False|Float> :
   val n = call-c clib/sscanf(s.chars, "%f%c", addr(FLOAT-BUFFER), addr(CHAR-BUFFER))
   if n != 1 : return false
   else : return new Float{FLOAT-BUFFER}

;                        Utilities
;                        =========

lostanza defn* prefix? (chars:ptr<byte>, prefix:ptr<byte>) -> int :
   for (var i:long = 0, 1, i = i + 1) :
      if prefix[i] == 0 : return 1
      else if chars[i] == 0 : return 0
      else if prefix[i] != chars[i] : return 0
   return 0   

lostanza defn digit (c:byte, radix:int) -> int :
   var d:int
   if c >= '0' and c <= '9' : d = c - '0'
   else if c >= 'a' and c <= 'f' : d = c - 'a' + 10
   else if c >= 'A' and c <= 'F' : d = c - 'A' + 10
   else : return -1
   if d < radix : return d
   else : return -1

;                        Parsing Integers
;                        ================

lostanza defn pos-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
   var n:int = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Int{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = n * radix + d
            if n < 0 : return false
   fatal("Unreachable")
   return false

lostanza defn neg-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
   var n:int = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Int{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = n * radix - d
            if n > 0 : return false
   fatal("Unreachable")
   return false

lostanza defn bits-to-int (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Int> :
   var n:int = 0
   var nbits:int = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Int{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = (n << bits) | d
            nbits = nbits + bits
            if nbits >= 32 + bits : return false
   fatal("Unreachable")
   return false

;                        Parsing Longs
;                        =============

lostanza defn pos-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
   var n:long = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Long{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = n * radix + d
            if n < 0 : return false
   fatal("Unreachable")
   return false

lostanza defn neg-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
   var n:long = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Long{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = n * radix - d
            if n > 0 : return false
   fatal("Unreachable")
   return false

lostanza defn bits-to-long (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Long> :
   var n:long = 0
   var nbits:int = 0
   for (var i:long = start, 1, i = i + 1) :
      if s.chars[i] == 0 :
         return new Long{n}
      else :
         val d = digit(s.chars[i], radix)
         if d < 0 :
            return false
         else :
            n = (n << bits) | d
            nbits = nbits + bits
            if nbits >= 64 + bits : return false
   fatal("Unreachable")
   return false

;============================================================
;==================== Arithmetic ============================
;============================================================

public defn max<?T> (a:?T&Comparable<?T>, b:T&Comparable) -> T :
   b when a < b else a

public defn min<?T> (a:?T&Comparable<?T>, b:T&Comparable) -> T :
   a when a < b else b

public defn minimum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
   reduce{_, xs} $ fn (x, y) :
      if x < y : x
      else : y

public defn minimum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
   reduce{_, x0, xs} $ fn (x, y) :
      if x < y : x
      else : y

public defn maximum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
   reduce{_, xs} $ fn (x, y) :
      if x < y : y
      else : x

public defn maximum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
   reduce{_, x0, xs} $ fn (x, y) :
      if x < y : y
      else : x

public defn minimum<?T> (xs:Seqable<?T&Comparable>) -> T : minimum(xs, less?)
public defn maximum<?T> (xs:Seqable<?T&Comparable>) -> T : maximum(xs, less?)

public defn minimum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : minimum(x0, xs, less?)
public defn maximum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : maximum(x0, xs, less?)

public defn minimum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T : minimum(xs, {key(_) < key(_)})
public defn maximum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T : maximum(xs, {key(_) < key(_)})


;TODO: Remove uses of to-long, to-float with literals
public defn abs (a:Int) -> Int : (- a) when a < 0 else a
public defn abs (a:Long) -> Long : (- a) when a < 0L else a
public defn abs (a:Float) -> Float : (- a) when a < 0.0f else a
public defn abs (a:Double) -> Double : (- a) when a < 0.0 else a

public lostanza defn rand () -> ref<Int> :
   val i = call-c clib/rand()
   return new Int{i}

public defn rand (n:Int) :
   ensure-positive("limit", n)
   rand() % n

public defn rand (r:Range) :
   val s = start(r)
   match(end(r), inclusive?(r)) :
      (e:Int, inc:True) :
         ensure-start-before-end(s, e)
         rand(e + 1 - s) + s
      (e:Int, inc:False) :
         if e == s : fatal("Empty range.")
         else : ensure-start-before-end(s, e)
         rand(e - s) + s
      (e:False, inc) :
         fatal("Unbounded range.")

public defn ceil-log2 (i:Int) -> Int :
   defn* loop (n:Int, l:Int) :
      if i > n :
         if l == 30 : l + 1
         else : loop(n << 1, l + 1)
      else : l
   fatal("Log of non-positive number!") when i <= 0
   loop(1, 0)

public defn floor-log2 (i:Int) -> Int :
   defn* loop (n:Int, l:Int) :
      if i == n : l
      else if i < n : l - 1
      else if l == 30 : l
      else : loop(n << 1, l + 1)
   fatal("Log of non-positive number!") when i <= 0
   loop(1, 0)

public defn ceil-log2 (i:Long) -> Int :
   defn* loop (n:Long, l:Int) :
      if i > n :
         if l == 62 : l + 1
         else : loop(n << to-long(1), l + 1)
      else : l
   fatal("Log of non-positive number!") when i <= to-long(0)
   loop(to-long(1), 0)

public defn floor-log2 (i:Long) -> Int :
   defn* loop (n:Long, l:Int) :
      if n == i : l
      else if i < n : l - 1
      else if l == 62 : l
      else : loop(n << to-long(1), l + 1)
   fatal("Log of non-positive number!") when i <= to-long(0)
   loop(to-long(1), 0)

public defn next-pow2 (i:Int) -> Int :
   val n = ceil-log2(i)
   if n <= 30 : 1 << n
   else : fatal("Overflow")

public defn prev-pow2 (i:Int) -> Int :
   1 << floor-log2(i)

public defn next-pow2 (i:Long) -> Long :
   val n = ceil-log2(i)
   if n <= 62 : to-long(1) << to-long(n)
   else : fatal("Overflow")

public defn prev-pow2 (i:Long) -> Long :
   to-long(1) << to-long(floor-log2(i))

public defn sum (xs: Seqable<Int>) -> Int : reduce(plus, 0, xs)
public defn sum (xs: Seqable<Long>) -> Long : reduce(plus, 0L, xs)
public defn sum (xs: Seqable<Float>) -> Float : reduce(plus, 0.0f, xs)
public defn sum (xs: Seqable<Double>) -> Double : reduce(plus, 0.0, xs)

public defn product (xs: Seqable<Int>) -> Int : reduce(times, 1, xs)
public defn product (xs: Seqable<Long>) -> Long : reduce(times, 1L, xs)
public defn product (xs: Seqable<Float>) -> Float : reduce(times, 1.0f, xs)
public defn product (xs: Seqable<Double>) -> Double : reduce(times, 1.0, xs)


;============================================================
;================== Sequence Library ========================
;============================================================

public defn do<?T> (f:T -> ?, xs:Seqable<?T>) -> False :
   for xs-seq in xs do-seq :
      while not empty?(xs-seq) :
         f(next(xs-seq))

public defn do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         while (not empty?(xs-seq)) and (not empty?(ys-seq)) :
            f(next(xs-seq), next(ys-seq))

public defn do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            while (not empty?(xs-seq)) and (not empty?(ys-seq)) and (not empty?(zs-seq)) :
               f(next(xs-seq), next(ys-seq), next(zs-seq))

public defn seq<?T,?S> (f:T -> ?S, xs:Seqable<?T>) -> Seq<S> :
   match(xs) :
      (xs:Seq<T> & Lengthable) :
         new Seq<S> & Lengthable :
            defmethod empty? (this) : empty?(xs)
            defmethod next (this) : f(next(xs))
            defmethod peek (this) : f(peek(xs))
            defmethod close (this) : close(xs)
            defmethod length (this) : length(xs)
      (xs:Seq<T>) :
         new Seq<S> :
            defmethod empty? (this) : empty?(xs)
            defmethod next (this) : f(next(xs))
            defmethod peek (this) : f(peek(xs))
            defmethod close (this) : close(xs)
      (xs) :
         seq(f, to-seq(xs))

public defn seq<?T,?S,?R> (f:(T,S) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   match(xs, ys) :
      (xs:Seq<T> & Lengthable, ys:Seq<S> & Lengthable) :
         var len = min(length(xs), length(ys))
         new Seq<R> & Lengthable :
            defmethod empty? (this) :
               empty?(xs) or empty?(ys)
            defmethod next (this) :
               len = len - 1
               f(next(xs), next(ys))
            defmethod peek (this) :
               f(peek(xs), peek(ys))
            defmethod close (this) :
               len = 0
               close(xs)
               close(ys)
            defmethod length (this) :
               len
      (xs:Seq<T>, ys:Seq<S>) :
         new Seq<R> :
            defmethod empty? (this) : empty?(xs) or empty?(ys)
            defmethod next (this) : f(next(xs), next(ys))
            defmethod peek (this) : f(peek(xs), peek(ys))
            defmethod close (this) : (close(xs), close(ys))
      (xs, ys) :
         seq(f, to-seq(xs), to-seq(ys))


public defn seq<?T,?S,?U,?R> (f:(T,S,U) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   match(xs, ys, zs) :
      (xs:Seq<T> & Lengthable, ys:Seq<S> & Lengthable, zs:Seq<U> & Lengthable) :
         var len = min(min(length(xs), length(ys)), length(zs))
         new Seq<R> & Lengthable :
            defmethod empty? (this) :
               empty?(xs) or empty?(ys) or empty?(zs)
            defmethod next (this) :
               len = len - 1
               f(next(xs), next(ys), next(zs))
            defmethod peek (this) :
               f(peek(xs), peek(ys), peek(zs))
            defmethod close (this) :
               len = 0
               close(xs)
               close(ys)
               close(zs)
            defmethod length (this) :
               len
      (xs:Seq<T>, ys:Seq<S>, zs:Seq<U>) :
         new Seq<R> :
            defmethod empty? (this) : empty?(xs) or empty?(ys) or empty?(zs)
            defmethod next (this) : f(next(xs), next(ys), next(zs))
            defmethod peek (this) : f(peek(xs), peek(ys), peek(zs))
            defmethod close (this) : (close(xs), close(ys), close(zs))
      (xs, ys, zs) :
         seq(f, to-seq(xs), to-seq(ys), to-seq(zs))

public defn contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False :
   label<False|True> return :
      for x in xs do :
         return(true) when x == y

public defn find<?T> (f: T -> True|False, xs:Seqable<?T>) -> T|False :
   label<False|T> return :
      for x in xs do :
         return(x) when f(x)

public defn find<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> T|False :
   label<False|T> return :
      for (x in xs, y in ys) do :
         return(x) when f(x, y)

public defn find!<?T> (f: T -> True|False, xs:Seqable<?T>) : find(f, xs) as T
public defn find!<?T, ?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : find(f, xs, ys) as T

public defn first<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Maybe<R> :
   label<Maybe<R>> return :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()      

public defn first<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Maybe<R> :
   label<Maybe<R>> return :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()      

public defn first!<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) : value!(first(f, xs))
public defn first!<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) : value!(first(f, xs, ys))

public defn seq?<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Seq<R> :
   generate<R> :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?U,?R> (f: (T,S,U) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys, z in zs) do :
         match(f(x, y, z)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn filter<?T> (f: T -> True|False, xs:Seqable<?T>) -> Seq<T> :
   generate<T> :
      for x in xs do :
         yield(x) when f(x)

public defn filter<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<T> :
   generate<T> :
      for (x in xs, y in ys) do :
         yield(x) when f(x, y)

public defn filter<?T> (xs:Seqable<?T>, sel:Seqable<True|False>) -> Seq<T> :
   for (x in xs, s in sel) filter : s

public defn index-of (xs:Seqable<Equalable>, y:Equalable) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when x == y

public defn index-of! (xs:Seqable<Equalable>, y:Equalable) : index-of(xs, y) as Int

public defn index-when<?T> (f: T -> True|False, xs:Seqable<?T>) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when f(x)

public defn index-when<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Int|False :
   label<Int|False> return :
      for (x in xs, y in ys, i in 0 to false) do :
         return(i) when f(x, y)

public defn index-when!<?T> (f: T -> True|False, xs:Seqable<?T>) : index-when(f, xs) as Int
public defn index-when!<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : index-when(f, xs, ys) as Int

public defn split<?T> (f: T -> True|False, xs: Seqable<?T>) -> [Many<T>&Lengthable, Many<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for x in xs do :
      add{_, x} $
         if f(x) : true-xs
         else : false-xs
   [true-xs, false-xs]

public defn split<?T> (xs:Seqable<?T>, ss:Seqable<True|False>) -> [Many<T>&Lengthable, Many<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for (x in xs, s in ss) do :
      add{_, x} $
         if s : true-xs
         else : false-xs
   [true-xs, false-xs]   

public defn take-while<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = peek(xs-seq)
               if f(x) :
                  next(xs-seq)
                  yield(x)
                  loop()
         loop()

public defn take-until<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = next(xs-seq)
               yield(x)
               loop() when not f(x)
         loop()

public defn take-n<?T> (n:Int, xs:Seqable<?T>) :
   ensure-non-negative("length", n)
   var len = n
   val xs-seq = to-seq(xs)
   new Seq<T> & Lengthable :
      defmethod next (this) :
         val v = peek(this)
         next(xs-seq)
         len = len - 1
         v
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         peek(xs-seq)
      defmethod close (this) :
         close(xs-seq)
         len = 0
      defmethod empty? (this) :
         len == 0
      defmethod length (this) :
         len

public defn cat<?T> (a:Seqable<?T>, b:Seqable<?T>) -> Seq<T> :
   cat-all([a, b])

public defn cat-all<?T> (xss: Seqable<Seqable<?T>>) -> Seq<T> :
   val ret-seq = generate<T> :
      for xs in xss do :
         do(yield, xs)
   val length? =
      if xss typeof Many :
         if all?({_ typeof Lengthable&Seqable}, xss) :
            sum(seq(length{_ as Lengthable&Seqable}, xss))
   match(length?) :
      (l:Int) : take-n(l, ret-seq)
      (l:False) : ret-seq

public defn seq-cat<?T,?R> (f:T -> Seqable<?R>, xs:Seqable<?T>) -> Seq<R> :
   cat-all(seq(f, xs))

public defn seq-cat<?T,?S,?R> (f:(T,S) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   cat-all(seq(f, xs, ys))

public defn seq-cat<?T,?S,?U,?R> (f:(T,S,U) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   cat-all(seq(f, xs, ys, zs))

public defn all?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   for xs-seq in xs do-seq :
      defn* loop () :
         if empty?(xs-seq) : true
         else : pred?(next(xs-seq)) and loop()
      loop()

public defn all?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         defn* loop () :
            if empty?(xs-seq) or empty?(ys-seq) : true
            else : pred?(next(xs-seq), next(ys-seq)) and loop()
         loop()

public defn all?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            defn* loop () :
               if empty?(xs-seq) or empty?(ys-seq) or empty?(zs-seq) : true
               else : pred?(next(xs-seq), next(ys-seq), next(zs-seq)) and loop()
            loop()

public defn none?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   defn notp (x) : not pred?(x)
   all?(notp, xs)

public defn none?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   defn notp (x1, x2) : not pred?(x1, x2)
   all?(notp, xs, ys)

public defn none?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   defn notp (x1, x2, x3) : not pred?(x1, x2, x3)
   all?(notp, xs, ys, zs)

public defn any?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   not none?(pred?, xs)

public defn any?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   not none?(pred?, xs, ys)

public defn any?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   not none?(pred?, xs, ys, zs)

public defn count (xs:Seqable) -> Int :
   match(xs) :
      (xs:Seqable & Lengthable) :
         length(xs)
       (xs) :
         var accum:Int = 0
         for x in xs do :
            accum = accum + 1
         accum

public defn count<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> Int :
   var accum:Int = 0
   for x in xs do :
      if pred?(x) : accum = accum + 1
   accum

public defn join<?T,?S> (xs:Seqable<?T>, y:?S) -> Seq<T|S> :
   val ret-seq = generate<T|S> :
      val xs-seq = to-seq(xs)
      yield(next(xs-seq)) when not empty?(xs-seq)
      while not empty?(xs-seq) :
         yield(y)
         yield(next(xs-seq))
   match(xs) :
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val n* = n + max(0, n - 1)
         take-n(n*, ret-seq)
      (xs) : ret-seq

public defn reduce<?T,?S,?U> (f: (T|U, S) -> ?U, x0: ?T, xs:Seqable<?S>) -> T|U :
   var accum = x0
   for x in xs do :
      accum = f(accum, x)
   accum

public defn reduce<?T,?S> (f: (T|S, T) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      reduce(f, next(xs-seq), xs-seq)

public defn reduce-right<?T,?S,?U> (f: (S, T|U) -> ?U, xn:?T, xs:Seqable<?S>) -> T|U :
   for xs-seq in xs do-seq :
      defn loop () :
         if empty?(xs-seq) : xn
         else : f(next(xs-seq), loop())
      loop()   

public defn reduce-right<?T,?S> (f: (T, T|S) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      defn loop (x:T) :
         if empty?(xs-seq) : x
         else : f(x, loop(next(xs-seq)))
      loop(next(xs-seq))         

public defn repeat<?T> (x:?T) -> Seq<T> :
   var closed? = false
   new Seq<T> :
      defmethod next (this) :
         peek(this)
      defmethod peek (this) :
         fatal("Closed Sequence") when closed?
         x
      defmethod empty? (this) :
         closed?
      defmethod close (this) :
         closed? = true

public defn repeat<?T> (x:?T, n:Int) :
   ensure-non-negative("length", n)
   var len = n
   new Seq<T> & Lengthable :
      defmethod next (this) :
         fatal("Empty Sequence") when len == 0
         len = len - 1
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         x
      defmethod empty? (this) :
         len == 0
      defmethod close (this) :
         len = 0
      defmethod length (this) :
         len         

public defn repeat-while<?T> (f: () -> Maybe<?T>) -> Seq<T> :
   var item = sentinel
   var closed? = false
   defn fill () :
      if item typeof Sentinel :
         item = f()

   new Seq<T> :
      defmethod next (this) :
         val x = peek(this)
         item = sentinel
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         value(item as One<T>)
      defmethod empty? (this) :
         if closed? :
            true
         else :
            fill()
            item typeof None
      defmethod close (this) :
         closed? = true   

public defn repeatedly<?T> (f:() -> ?T) -> Seq<T> :
   var item = sentinel
   var closed? = false
   defn fill () :
      if item typeof Sentinel :
         item = f()
   defn empty () :
      val x = item as T
      item = sentinel
      x   

   new Seq<T> :
      defmethod next (this) :
         fatal("Closed Sequence") when closed?
         fill()
         empty()
      defmethod peek (this) :
         fatal("Closed Sequence") when closed?
         fill()
         item as T
      defmethod empty? (this) :
         closed?
      defmethod close (this) :
         closed? = true

public defn repeatedly<?T> (f:() -> ?T, n:Int) :
   take-n(n, repeatedly(f))

public defn zip<?T,?S> (xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<[T,S]> :
   for (x in xs, y in ys) seq : [x, y]

public defn zip<?T,?S,?U> (xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<[T,S,U]> :
   for (x in xs, y in ys, z in zs) seq : [x, y, z]

public defn zip-all<?T> (xs:Seqable<Seqable<?T>>) :
   val seqs = to-tuple(seq(to-seq, xs))
   fatal("No Sequences Given") when empty?(seqs)
   val ret-seq = new Seq<Tuple<T>> :
      defmethod next (this) :
         map(next, seqs)
      defmethod peek (this) :
         map(peek, seqs)
      defmethod empty? (this) :
         any?(empty?, seqs)
      defmethod close (this) :
         do(close, seqs)
   if all?({_ typeof Lengthable&Seqable}, seqs) :
      val n = minimum(seq(length{_ as Lengthable&Seqable}, seqs))
      take-n(n, ret-seq)
   else :
      ret-seq

;TODO: Use hash when possible
public defn unique<?T> (xs:Seqable<?T&Equalable>) -> List<T> :
   val ys = Vector<T&Equalable>()
   for x in xs do :
      add(ys, x) when not contains?(ys, x)
   to-list(ys)

public defn lookup?<?K,?V,?D> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable, default:?D) -> D|V :
   label<V|D> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      default   

public defn lookup?<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> False|V :
   lookup?(xs, k, false)

public defn lookup<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> V :
   label<V> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      fatal("Key %~ not found in entries." % [k])

;============================================================
;==================== List Library ==========================
;============================================================

public defn* get<?T> (xs:List<?T>, i:Int) -> T :
   if i == 0 : head(xs)
   else : get(tail(xs), i - 1)

public defn headn<?T> (l:List<?T>, n:Int) -> List<T> :
   if n == 0 : List()
   else : cons(head(l), headn(tail(l), n - 1))

public defn* tailn<?T> (l:List<?T>, n:Int) -> List<T> :
   if n == 0 : l
   else : tailn(tail(l), n - 1)

public defn append<?T> (xs:Seqable<?T>, ys:List<?T>) -> List<T> :
   match(xs) :
      (xs:List<T>) :
         defn loop (xs:List<T>) :
            if empty?(xs) : ys
            else : cons(head(xs), loop(tail(xs)))
         if empty?(ys) : xs
         else : loop(xs)
      (xs) :
         val xs-seq = to-seq(xs)
         defn loop () :
            if empty?(xs-seq) : ys
            else : cons(next(xs-seq), loop())
         loop()   

public defn append-all<?T> (xs:Seqable<List<?T>>) -> List<T> :
   val xs-seq = to-seq(xs)
   defn loop () :
      if empty?(xs-seq) : List()
      else : append(next(xs-seq), loop())
   loop()

public defn seq-append<?T,?R> (f: T -> List<?R>, xs:Seqable<?T>) -> List<R> :
   append-all(seq(f, xs))

public defn seq-append<?T,?S,?R> (f: (T,S) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> List<R> :
   append-all(seq(f, xs, ys))

public defn seq-append<?T,?S,?U,?R> (f: (T,S,U) -> List<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R> :
   append-all(seq(f, xs, ys, zs))

public defn map<?T,?R> (f: T -> ?R, xs:List<?T>) -> List<R> :
   if empty?(xs) : List()
   else : cons(f(head(xs)), map(f, tail(xs)))

public defn map<?T,?S,?R> (f: (T,S) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>) -> List<R> :
   to-list(seq(f, xs, ys))

public defn map<?T,?S,?U,?R> (f: (T,S,U) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> List<R> :
   to-list(seq(f, xs, ys, zs))

public defn transpose<?T> (xs:List<List<?T>>) -> List<List<T>> :
   if empty?(xs) :
      List()
   else if any?(empty?, xs) :
      List()
   else :
      val hs = map(head, xs)
      val ts = map(tail, xs)
      cons(hs, transpose(ts))

public defn last<?T> (xs:List<?T>) -> T :
   fatal("Empty List") when empty?(xs)
   defn* loop (xs:List<T>) :
      if empty?(tail(xs)) : head(xs)
      else : loop(tail(xs))
   loop(xs)

public defn but-last<?T> (xs:List<?T>) -> List<T> :
   fatal("Empty List") when empty?(xs)
   defn* loop (xs:List<T>) :
      if empty?(tail(xs)) : List()
      else : cons(head(xs), but-last(tail(xs)))
   loop(xs)

public defn reverse<?T> (xs:List<?T>) -> List<T> :
   if empty?(xs) :
      xs
   else :
      var accum = List()
      for x in xs do :
         accum = cons(x, accum)
      accum


;============================================================
;=================== String Library =========================
;============================================================

public defn matches? (a:String, start:Int, b:String) :
   ensure-index-in-bounds(a, start)
   val an = length(a)
   val bn = length(b)
   if bn <= an :
      for i in 0 to bn all? :
         a[start + i] == b[i]

public defn prefix? (s:String, prefix:String) :
   matches?(s, 0, prefix)

public defn suffix? (s:String, suffix:String) :
   val start = max(0, length(s) - length(suffix))
   matches?(s, start, suffix)

public defn empty? (s:String) :
   length(s) == 0
      
lostanza defn substring! (str:ref<String>, b:ref<Int>, e:ref<Int>) -> ref<String> :
   val s = b.value
   val n = e.value - s
   val ret = String(n)
   return init-string(ret, str.chars + s)

public defn get (s:String, r:Range) -> String :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   substring!(s, b, e)

public lostanza defn append (a:ref<String>, b:ref<String>) -> ref<String> :
   val al = a.length
   val bl = b.length
   val n = al + bl
   val s = String(n)
   for (var i:long = 0, i < al, i = i + 1) :
      s.chars[i] = a.chars[i]
   for (var i:long = 0, i < bl, i = i + 1) :
      s.chars[al + i] = b.chars[i]
   s.chars[n] = 0 as byte   
   return s   

public defn append-all (xs:Seqable<String>) -> String :
   val xs-seq = to-seq(xs)
   if empty?(xs-seq) : ""
   else : reduce(append, xs-seq)

public defn string-join (xs:Seqable) -> String :
   val s = StringBuffer()
   print-all(s, xs)
   to-string(s)

public defn string-join (xs:Seqable, j) -> String :
   string-join(join(xs, j))

public defn index-of-char (s:String, r:Range, c:Char) -> False|Int :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   for i in b to e find :
      s[i] == c

public defn index-of-char (s:String, c:Char) -> False|Int :
   index-of-char(s, 0 to false, c)

public defn index-of-chars (a:String, r:Range, b:String) -> False|Int :
   ensure-index-range(a, r)
   val [s, e] = range-bound(a, r)
   val an = e - s
   val bn = length(b)
   if bn <= an :
      for i in s to (e - bn) find :
         matches?(a, i, b)

public defn index-of-chars (a:String, b:String) -> False|Int :
   index-of-chars(a, 0 to false, b)

public defn last-index-of-char (s:String, r:Range, c:Char) -> False|Int :
   ensure-index-range(s, r)
   val [b, e] = range-bound(s, r)
   for i in (e - 1) through b by -1 find :
      s[i] == c

public defn last-index-of-char (s:String, c:Char) -> False|Int :
   last-index-of-char(s, 0 to false, c)

public defn last-index-of-chars (a:String, r:Range, b:String) -> False|Int :
   ensure-index-range(a, r)
   val [s, e] = range-bound(a, r)
   val an = e - s
   val bn = length(b)
   if bn <= an :
      for i in (e - bn - 1) through s by -1 find :
         matches?(a, i, b)

public defn last-index-of-chars (a:String, b:String) -> False|Int :
   last-index-of-chars(a, 0 to false, b)

public lostanza defn replace (s:ref<String>, c1:ref<Char>, c2:ref<Char>) -> ref<String> :
   val b1 = c1.value
   val b2 = c2.value
   val n = s.length
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc == b1 : r.chars[i] = b2
      else : r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public defn replace (str:String, s1:String, s2:String) -> String :
   fatal("String to be replaced cannot be empty.") when empty?(s1)      
   val buf = StringBuffer(length(str))
   val n = length(str)
   val s1n = length(s1)
   defn* loop (i:Int) :
      if i < n :
         if matches?(str, i, s1) :
            print(buf, s2)
            loop(i + s1n)
         else :
            print(buf, str[i])
            loop(i + 1)
   loop(0)
   to-string(buf)

public defn split (str:String, s:String) -> Seq<String> :
   generate<String> :
      val strl = length(str)
      val sl = length(s)
      defn loop (b:Int) :
         if b < strl :
            match(index-of-chars(str, b to false, s)) :
               (i:Int) :
                  yield(str[b to i]) when b > 0
                  loop(i + sl)
               (i:False) :
                  yield(str[b to false])
      loop(0)

public defn split (str:String, s:String, n:Int) -> Seq<String> :
   if n <= 0 :
      fatal("Maximum number of splits (%_) is not positive." % [n])
   generate<String> :
      val strl = length(str)
      val sl = length(s)
      defn loop (b:Int, n:Int) :
         if b < strl :
            if n > 1 :
               match(index-of-chars(str, b to false, s)) :
                  (i:Int) :
                     yield(str[b to i]) when b > 0
                     loop(i + sl, n - 1)
                  (i:False) :
                     yield(str[b to false])
            else :
               yield(str[b to false])
      loop(0, n)

public lostanza defn lower-case (s:ref<String>) -> ref<String> :
   val n = s.length
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc >= 'A' and sc <= 'Z' :
         r.chars[i] = sc - 'A' + 'a'
      else :
         r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public lostanza defn upper-case (s:ref<String>) -> ref<String> :
   val n = s.length
   val r = String(n)
   for (var i:long = 0, i < n, i = i + 1) :
      val sc = s.chars[i]
      if sc >= 'a' and sc <= 'z' :
         r.chars[i] = sc - 'a' + 'A'
      else :
         r.chars[i] = sc
   r.chars[n] = 0 as byte
   return r

public defn trim (s:String) -> String :
   defn not-whitespace? (c:Char) :
      (c != ' ') and
      (c != '\n') and
      (c != TAB-CHAR) and
      (c != BACKSPACE-CHAR) and
      (c != CARRIAGE-RETURN-CHAR)
   match(index-when(not-whitespace?, s)) :
      (i:Int) :
         val n = length(s)
         val j = for i in (n - 1) through 0 by -1 find! :
            not-whitespace?(s[i])
         s[i through j]   
      (i:False) : ""

;============================================================
;================= String Backed Symbol =====================
;============================================================

;                       Interface
;                       =========

public defmulti prefix (a:Symbol) -> String
public defmulti qualified? (a:Symbol) -> True|False
public defmulti qualifier (a:Symbol) -> [False|Symbol, Symbol]

;                    General Functions
;                    =================

public defn prefix? (a:Symbol, p:String) -> True|False :
   prefix?(prefix(a), p)

;                     Initialization
;                     ==============

var INITIALIZATION-SYMBOLS: List<Symbol>

defn initialize-pre-symbol-table () :
   INITIALIZATION-SYMBOLS = List()

defn init-symbol (str:String) :
   val sym = for s in INITIALIZATION-SYMBOLS find :
      prefix(s) == str
   match(sym) :
      (sym:Symbol) :
         sym
      (sym:False) :
         val sym* = StringSymbol(str)
         INITIALIZATION-SYMBOLS = cons(sym*, INITIALIZATION-SYMBOLS)
         sym*


;                    Symbol Interning
;                    ================

var INTERNED-SYMBOLS : HashTable<String,Symbol>

defn initialize-symbol-table () :
   INTERNED-SYMBOLS = HashTable<String,Symbol>()
   for s in INITIALIZATION-SYMBOLS do :
      INTERNED-SYMBOLS[prefix(s)] = s
   INITIALIZATION-SYMBOLS = List()   

public defn to-symbol (x) :
   match(x) :
      (x:Symbol) :
         x
      (x:String) :
         match(get?(INTERNED-SYMBOLS, x)) :
            (v:Symbol) :
               v
            (v:False) :
               val sym = StringSymbol(x)
               INTERNED-SYMBOLS[x] = sym
               sym
      (x) :
         to-symbol(to-string(x))

public defn symbol-join (xs:Seqable) -> Symbol :
   to-symbol(string-join(xs))

;                    String Backed Symbol
;                    ====================

defn StringSymbol (s:String) :
   new Symbol :
      defmethod qualified? (this) :
         contains?(s, '/')
      defmethod qualifier (this) :
         match(last-index-of-char(s, '/')) :
            (i:Int) :
               val part1 = to-symbol(s[0 to i])
               val part2 = to-symbol(s[(i + 1) to false])
               [part1, part2]
            (i:False) :
               [false, this]
      defmethod hash (this) :
         hash(s)
      defmethod print (o:OutputStream, this) :
         print(o, s)
      defmethod to-string (this) :
         s
      defmethod prefix (this) :
         s
      defmethod write (o:OutputStream, this) :
         if symbol-needs-escape?(s) :
            print(o, "\\|")
            for c in s do :
               escape-for-symbol(o, c)
            print(o, '|')
         else :
            print(o, s)

;                       Generated Symbol
;                       ================

val ID-COUNTER = to-seq(0 to false)

public defn gensym (x) :
   match(x) :
      (x:Symbol) :
         gensym(prefix(x))
      (s:String) :
         val id = genid()
         new Symbol :
            defmethod qualified? (this) : false
            defmethod qualifier (this) : [false, this]
            defmethod hash (this) : hash(s) + (7 * id)
            defmethod prefix (this) : s   
            defmethod print (o:OutputStream, this) :
               print(o, s)
               print(o, id)
            defmethod write (o:OutputStream, this) :
               if symbol-needs-escape?(s) :
                  print(o, "\\|")
                  for c in s do :
                     escape-for-symbol(o, c)
                  print(o, id)
                  print(o, '|')
               else :
                  print(o, s)
                  print(o, id)
      (x) :
         gensym(to-string(x))

public defn gensym () :
   gensym("$gen")

public defn genid () :
   next(ID-COUNTER)


;============================================================
;=================== Pretty Printer =========================
;============================================================

;                  General Interface
;                  =================

public defmulti write (o:OutputStream, x) -> False

;                Default Implementation
;                ======================

defmethod write (o:OutputStream, x) :
   print(o, x)

public defn write-all (o:OutputStream, xs:Seqable) -> False :
   val xs-seq = to-seq(xs)
   if not empty?(xs-seq) :
      write(o, next(xs-seq))
   while not empty?(xs-seq) :
      print(o, " ")
      write(o, next(xs-seq))

;                    Escape Sequences
;                    ================

defn general-escape (o:OutputStream, c:Char) :
   defn escape (c:Char) :
      print(o, '\\')
      print(o, c)
   switch {c == _} :
      TAB-CHAR : escape('t')
      BACKSPACE-CHAR : escape('b')
      CARRIAGE-RETURN-CHAR : escape('r')
      '\n' : escape('n')
      '\\' : escape('\\')
      else : print(o, c)

defn escape-for-string (o:OutputStream, c:Char) :
   if c == '"' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)   

defn escape-for-symbol (o:OutputStream, c:Char) :
   if c == '|' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)   

defn escape-for-char (o:OutputStream, c:Char) :
   if c == '\'' :
      print(o, '\\')
      print(o, c)
   else :
      general-escape(o, c)   

;              Determination Whether Symbol Requires Escape
;              ============================================

lostanza var SYMBOL-CHARS:ref<String>
lostanza var OPERATOR-CHARS:ref<String>

lostanza defn tag-char (table:ref<String>, c:byte) -> int :
   table.chars[c] = 1 as byte
   return 0
   
lostanza defn tag-chars (table:ref<String>, cs:ptr<byte>) -> int :
   for (var i:long = 0, 1, i = i + 1) :
      val c = cs[i]
      if c == 0 : return 0
      tag-char(table, c)
   fatal("Unreachable")   
   return 0
   
lostanza :
   SYMBOL-CHARS = String(256, 0 as byte)
   OPERATOR-CHARS = String(256, 0 as byte)

   tag-chars(SYMBOL-CHARS, "0123456789")
   tag-chars(SYMBOL-CHARS, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
   tag-chars(SYMBOL-CHARS, "_?")
   tag-chars(SYMBOL-CHARS, "~!@#$%^*+-=/")

   tag-chars(OPERATOR-CHARS, "~!@#$%^*+-=/")
   tag-chars(OPERATOR-CHARS, ".:<>&|")

lostanza defn symbol-char? (c:ref<Char>) -> ref<True|False> :
   if SYMBOL-CHARS.chars[c.value] == 0 : return false
   else : return true

lostanza defn operator-char? (c:ref<Char>) -> ref<True|False> :
   if OPERATOR-CHARS.chars[c.value] == 0 : return false
   else : return true

defn symbol-needs-escape? (str:String) :
   if empty?(str) : true
   else if digit?(str[0]) : true
   else if length(str) >= 2 and str[0] == '-' and digit?(str[1]) : true
   else if all?(symbol-char?, str) : false
   else if all?(operator-char?, str) : false
   else : true

;                  Escaped Primitive Values
;                  ========================

defmethod write (o:OutputStream, c:Char) :
   print(o, '\'')
   escape-for-char(o, c)
   print(o, '\'')      

defmethod write (o:OutputStream, s:String) :
   print(o, '"')
   for c in s do :
      escape-for-char(o, c)
   print(o, '"')      

defmethod write (o:OutputStream, x:Byte) :
   print(o, x)
   print(o, 'Y')

defmethod write (o:OutputStream, x:Long) :
   print(o, x)
   print(o, 'L')

defmethod write (o:OutputStream, b:Float) :
   print(o, b)
   print(o, 'F')

;============================================================
;====================== Scratch =============================
;============================================================

;defn nums (n:Int) :
;   generate<Int> :
;      for i in 0 to n do :
;         yield(i)
;
;;defn main () :
;;   val out = FileOutputStream("myfile.txt", false)
;;   for i in nums(10) do :
;;      println(out, "i = %_ and bob's your %%uncle!" % `(5))
;;   close(out)
;
;;main()
;
;;println(0 to 10)
;;println(0 through 10)
;;println(0 through 10 by 3)
;
;;lostanza val a:ref<Byte> = new Byte{42 as byte}
;;println(a + a)
;;println(a / a)
;;println(a * a)
;;println(a - a)
;;println(a % a)
;;println(a < a)
;;println(compare(a, a))
;
;lostanza defn as-float (a:ref<Int>) -> ref<Float> :
;   val v = a.value
;   return new Float{($ls-prim fnum v)}
;
;defn main () :
;   defn test (v:String, result) :
;      println("%_ = %_" % [v, result])
;
;   println("ADD")
;   test("a", ($prim add 40 2))
;
;   println("SUB")
;   test("b", ($prim sub 44 2))
;
;   println("MUL")
;   test("c", ($prim mul 21 2))
;   test("d", ($prim mul -21 -2))
;
;   println("DIV")
;   test("e", ($prim div 10 3))
;   test("f", ($prim div -10 -3))
;
;   println("MOD")
;   test("g", ($prim mod 10 3))
;   test("h", ($prim mod -10 -3))
;
;   println("AND/OR/XOR")
;   test("i", ($prim and 42 -16))
;   test("j", ($prim or 42 -16))
;   test("k", ($prim xor 42 -16))
;
;   println("NOT")
;   test("a", ($prim not 10))
;   test("b", ($prim not 0))
;
;   println("NEG")
;   test("a", ($prim neg 10))
;   test("b", ($prim neg -10))
;
;   println("SHL")
;   test("l", ($prim shl 21 2))
;
;   println("TRICKY SHL")
;   let :
;      val a = ($prim shl 1 31)
;      println("a = %_" % [a])
;      println(($prim lt a 0))
;      println(($prim gt a 0))
;
;   println("SHR")
;   test("m", ($prim shr 42 2))
;   test("n", ($prim shr -42 2))
;   test("o", ($prim shr -43 2))
;
;   println("ASHR")
;   test("p", ($prim ashr 42 2))
;   test("q", ($prim ashr -42 2))
;   test("r", ($prim ashr -43 2))
;
;   defn cmp (v:String, r:True|False) :
;      println(v)
;      if r : println("true")
;      else : println("false")
;   println("EQ")
;   cmp("a = ", ($prim eq 42 42))
;   cmp("b = ", ($prim eq -42 -42))
;
;   println("NE")
;   cmp("a = ", ($prim ne 42 42))
;   cmp("b = ", ($prim ne -42 -42))
;
;   println("LE")
;   cmp("a = ", ($prim le 5 10))
;   cmp("b = ", ($prim le -5 -10))
;   cmp("c = ", ($prim le 5 5))
;
;   println("LT")
;   cmp("a = ", ($prim lt 5 10))
;   cmp("b = ", ($prim lt -5 -10))
;   cmp("c = ", ($prim lt 5 5))
;
;   println("GE")
;   cmp("a = ", ($prim ge 5 10))
;   cmp("b = ", ($prim ge -5 -10))
;   cmp("c = ", ($prim ge 5 5))
;
;   println("GT")
;   cmp("a = ", ($prim gt 5 10))
;   cmp("b = ", ($prim gt -5 -10))
;   cmp("c = ", ($prim gt 5 5))
;
;   println("FLOAT")
;   let :
;      val a = 23.4
;      println("a = %_" % [a])
;      val b = hash(a)
;      println("b = %_" % [b])
;      val c = as-float(b)
;      println("c = %_" % [c])
;
;   println("STRINGS")
;   let :
;      val a = "Hello World"
;      val b = "My Name is Patrick"
;      test("length", length(a))
;      test("hash", hash(a))
;      test("eq", a == b)
;      test("le", a <= b)
;      for c in a do :
;         print("%_ " % [c])
;      print("\n")
;
;   println("LISTS")
;   let :
;      val a:List<String> = `("this" "is" "my" "turf")
;      val b:List<String> = `("you" "are" "not" "welcome")
;      println("a = %_" % [a])
;      println("b = %_" % [b])
;      test("length(a)", length(a))
;      test("eq", a == b)
;      test("le", a <= b)
;      test("hash", hash(a))
;      for x in a do :
;         print("%_ " % [x])
;      print("\n")
;
;   println("TUPLES")
;   let :
;      val a = [1 "this" 2 3]
;      val b = [2 "hello" 3 4]
;      println("a = %_" % [a])
;      println("b = %_" % [b])
;      test("length(a)", length(a))
;      test("eq", a == b)
;      test("le", a <= b)
;      test("hash", hash(a))
;      for x in a do :
;         print("%_, " % [x])
;      print("\n")
;
;lostanza defn lsmain () -> ref<False> :
;   val a = 15 as byte
;   val b = 15
;   val c = 15 as long
;   call-c clib/printf("a = %d\n", a as int)
;   call-c clib/printf("b = %d\n", b)
;   call-c clib/printf("c = %ld\n", c)
;   call-c clib/printf("not a = %d\n", (~ a) as int)
;   call-c clib/printf("not b = %d\n", (~ b))
;   call-c clib/printf("not c = %ld\n", (~ c))
;   call-c clib/printf("neg b = %d\n", (- b))
;   call-c clib/printf("neg c = %ld\n", (- c))
;
;   val e = 15.0
;   val f = 15.0 as double
;   call-c clib/printf("e = %f\n", e as double)
;   call-c clib/printf("f = %f\n", f)
;   call-c clib/printf("neg e = %f\n", (- e) as double)
;   call-c clib/printf("neg f = %f\n", (- f))
;
;   call-c clib/printf("AND %ld\n", 0 and 0)
;   call-c clib/printf("AND %ld\n", 0 and 1)
;   call-c clib/printf("AND %ld\n", 1 and 0)
;   call-c clib/printf("AND %ld\n", 1 and 1)
;
;   if 0 and 0 : call-c clib/printf("true")
;   else : call-c clib/printf("false")
;   if 0 and 1 : call-c clib/printf("true")
;   else : call-c clib/printf("false")
;   if 1 and 0 : call-c clib/printf("true")
;   else : call-c clib/printf("false")
;   if 1 and 1 : call-c clib/printf("true")
;   else : call-c clib/printf("false")
;
;   call-c clib/printf("OR %ld\n", 0 or 0)
;   call-c clib/printf("OR %ld\n", 0 or 1)
;   call-c clib/printf("OR %ld\n", 1 or 0)
;   call-c clib/printf("OR %ld\n", 1 or 1)
;
;   if 0 or 0 : call-c clib/printf("true")
;   else : call-c clib/printf("false")
;   if 0 or 1 : call-c clib/printf("true")
;   else : call-c clib/printf("false")
;   if 1 or 0 : call-c clib/printf("true")
;   else : call-c clib/printf("false")
;   if 1 or 1 : call-c clib/printf("true")
;   else : call-c clib/printf("false")
;
;
;   return false
;
;defn test-arrays () :
;   println("Arrays")
;   let :
;      val a = Array<Int>(10, -1)
;      val b = Array<Int>(10)
;      a[0] = 5
;      a[3] = 8
;      a[2] = 9
;      b[5] = 5
;      println("length of %_ = %_" % [a, length(a)])
;      println("a == a: %_" % [a == a])
;      println(b)
;
;   println("CharArrays")
;   let :
;      val a = CharArray(10)
;      a[0] = 'h'
;      a[1] = 'e'
;      a[2] = 'l'
;      a[3] = 'l'
;      a[4] = 'l'
;      println("a[4] = %_" % [a[4]])
;      println(a)
;
;defn test-buffer () :
;   val s = StringBuffer()
;   let-var CURRENT-OUTPUT-STREAM = s :
;      test-arrays()
;   println("s = \"%_\"" % [s])
;   test-arrays()
;
;defn positive-plus (a:Int, b:Int) :
;   defn PlusException (x:Int, y:Int) :
;      new Exception :
;         defmethod print (o:OutputStream, this) :
;            print(o, "PlusException: %_ + %_ gives negative result." % [x, y])
;
;   val c = a + b
;   throw(PlusException(a, b)) when c < 0
;   c
;
;defn test-try () :
;   try :
;      println("result 1 = %_" % [positive-plus(10, 3)])
;      println("result 2 = %_" % [positive-plus(10, -20)])
;   catch (e:Exception) :
;      println("Exception thrown: %_" % [e])
;   finally :
;      println("At least we tried.")
;
;defn test-conversions () :
;   val a = to-byte(15)
;   val b = to-char(15)
;   val c = to-long(15)
;   val d = to-float(15)
;   val e = to-double(15)
;   val f = to-int(15)
;   println("a = %_\n" % [a])
;   println("b = %_\n" % [b])
;   println("c = %_\n" % [c])
;   println("d = %_\n" % [d])
;   println("e = %_\n" % [e])
;   println("f = %_\n" % [f])
;
;   val co = Coroutine<Int,False> $ fn (co, x0) :
;      println(x0)
;   println(co)
;
;defn test-parse-int () :
;   println("PARSED INT: %_" % [to-int("-12313")])
;   println("PARSED INT: %_" % [to-int("-152312512312512")])
;   println("PARSED INT: %_" % [to-int("-a124")])
;   println("PARSED INT: %_" % [to-int("-12g124")])
;   println("PARSED INT: %_" % [to-int("0xF")])
;   println("PARSED INT: %_" % [to-int("0xFF")])
;   println("PARSED INT: %_" % [to-int("0xFFFFFFFf")])
;   println("PARSED INT: %_" % [to-int("0xFFFFFFFfF")])
;   println("PARSED INT: %_" % [to-int("0oFF")])
;   println("PARSED INT: %_" % [to-int("0o77")])
;   println("PARSED INT: %_" % [to-int("0b11111111111111111111111111111111")])
;   println("PARSED INT: %_" % [to-int("0b111111111111111111111111111111111")])
;   println("PARSED INT: %_" % [to-int("0b101")])
;   println("PARSED INT: %_" % [to-int("1324")])
;   println("PARSED INT: %_" % [to-int("132415212124123124")])
;   println("PARSED LONG: %_" % [to-long("-12313")])
;   println("PARSED LONG: %_" % [to-long("-152312512312512")])
;   println("PARSED LONG: %_" % [to-long("-a124")])
;   println("PARSED LONG: %_" % [to-long("-12g124")])
;   println("PARSED LONG: %_" % [to-long("0xF")])
;   println("PARSED LONG: %_" % [to-long("0xFF")])
;   println("PARSED LONG: %_" % [to-long("0xFFFFFFFf")])
;   println("PARSED LONG: %_" % [to-long("0xFFFFFFFfF")])
;   println("PARSED LONG: %_" % [to-long("0oFF")])
;   println("PARSED LONG: %_" % [to-long("0o77")])
;   println("PARSED LONG: %_" % [to-long("0b11111111111111111111111111111111")])
;   println("PARSED LONG: %_" % [to-long("0b111111111111111111111111111111111")])
;   println("PARSED LONG: %_" % [to-long("0b101")])
;   println("PARSED LONG: %_" % [to-long("1324")])
;   println("PARSED LONG: %_" % [to-long("132415212124123124")])
;   println("PARSED FLOAT: %_" % [to-float("42.4f")])
;   println("PARSED FLOAT: %_" % [to-float("42.40")])
;   println("PARSED FLOAT: %_" % [to-float("-142.4")])
;   println("PARSED FLOAT: %_" % [to-float("1e3")])
;   println("PARSED FLOAT: %_" % [to-float("-1e3")])
;   println("PARSED FLOAT: %_" % [to-float("1243 ")])
;   println("PARSED FLOAT: %_" % [to-float("1243")])
;   println("PARSED DOUBLE: %_" % [to-double("42.4f")])
;   println("PARSED DOUBLE: %_" % [to-double("42.40")])
;   println("PARSED DOUBLE: %_" % [to-double("-142.4")])
;   println("PARSED DOUBLE: %_" % [to-double("1e3")])
;   println("PARSED DOUBLE: %_" % [to-double("-1e3")])
;   println("PARSED DOUBLE: %_" % [to-double("1243 ")])
;   println("PARSED DOUBLE: %_" % [to-double("1243")])
;
;
;defn test-compound-conv () :
;   val s = "Hello World"
;   val a = to-array<Char>(s)
;   val l = to-list(s)
;   val t = to-tuple(s)
;   println("s = %_" % [s])
;   println("a = %_" % [a])
;   println("l = %_" % [l])
;   println("t = %_" % [t])
;
;
;defn test-minimum () :
;   val a = [14 2 -3 5 10 12]
;   println("a = %_" % [a])
;   println("min(a) = %_" % [minimum(a)])
;   println("max(a) = %_" % [maximum(a)])

;defn test-seqs () :
;   val xs = [2 4 3 5 1 5]
;   val ys = ["hi" "hell" "bye" "51" "one" "five" "2" "zebra"]
;   for (x in xs, y in ys) do :
;      println("do x = %_" % [x])
;      println("do y = %_" % [y])
;   val zs = for (x in xs, y in ys) seq :
;      x == length(y)
;   println("zs = %_" % [to-array<True|False>(zs)])
;   println("contains?(xs, 5) = %_" % [contains?(xs, 5)])
;   println("contains?(xs, \"one\") = %_" % [contains?(xs, "one")])
;   println("contains?(ys, \"bye\") = %_" % [contains?(ys, "bye")])
;   println("contains?(ys, \"five0\") = %_" % [contains?(ys, "five0")])
;   println("find even = %_" % [find({_ % 2 != 0}, xs)])
;   println("find odd length = %_" % [find({length(_) % 2 != 0}, ys)])
;   println("find big = %_" % [find({_ > 10}, xs)])
;   println("find short = %_" % [find({length(_) == 1}, ys)])
;   println("find! even = %_" % [find!({_ % 2 != 0}, xs)])
;   println("find! odd length = %_" % [find!({length(_) % 2 != 0}, ys)])
;
;   ;FIRST
;   let :
;      val a = for y in ys first :
;         if to-int(y) != false :
;            One("Number(%_)" % [y])
;         else : None()   
;      val b = for y in ys first :
;         if length(y) > 10 != false :
;            One("Number(%_)" % [y])
;         else : None()   
;      println("a = %_" % [a])
;      println("b = %_" % [b])
;
;   ;SEQ?
;   let :
;      val xs = for y in ys seq? :
;         if to-int(y) != false :
;            One(y)
;         else : None()   
;      println("xs = %_" % [to-tuple(xs)])
;
;   ;FILTER
;   let :
;      val xs = for y in ys filter :
;         length(y) <= 3
;      println("xs = %," % [xs])
;
;   ;INDEX-OF
;   let :
;      val i = index-of(ys, "zebra")
;      println("i = %_" % [i])
;      
;   ;INDEX-WHEN
;   let :
;      val i = index-when({length(_) >= 5}, ys)
;      println("i = %_" % [i])
;
;   ;SELECT
;   let :
;      val ss = to-list(seq({_[0] == 'h'}, ys))
;      println("ss = %_" % [ss])
;      val sel = select(ys, ss)
;      println("sel = %," % [sel])
;      
;   ;TAKE-WHILE
;   let :
;      val ns = take-while({_ > 1}, xs)
;      println("ns = %," % [ns])
;      
;   ;TAKE-N
;   let :
;      val ns = take-n(3, xs)
;      println("ns = %," % [ns])
;      
;   ;CAT
;   let :
;      val cs = cat(xs, ys)
;      println("cs = %," % [cs])
;      
;   ;SEQ-CAT
;   let :
;      val cs = for y in ys seq-cat :
;         [y "join" y "and"]
;      println("cs = %," % [cs])
;   
;   ;ALL?
;   let :
;      val p = all?({_ > 0}, xs)
;      println("p = %_" % [p])
;
;   ;NONE?
;   let :
;      val p = none?({_ > 0}, xs)
;      println("p = %_" % [p])
;
;   ;ANY?
;   let :
;      val p = any?({_ > 0}, xs)
;      println("p = %_" % [p])
;      
;   ;count
;   let :
;      val xs = for y in ys filter :
;         length(y) <= 3
;      val n = count(xs)
;      println("n = %_" % [n])
;      
;   ;repeat
;   let :
;      val cs = repeat("again", 10)
;      println("cs = %," % [cs])
;      
;   ;zip
;   let :
;      val cs = zip(xs, ys)
;      println("cs = %," % [cs])   

;defn test-strings () :
;   val a = "   Hello world"
;   val b = "My name is Patrick Li   "
;   val c = append-all([a, " ", b])
;   println("a = %_" % [a])
;   println("b = %_" % [b])
;   println("c = %_" % [c])
;   println("trimmed c = '%_'" % [trim(c)])
;   val words = to-list(split(c, " "))
;   println("words = %," % [words])
;   val wordstr = append-all(join(words, ", "))
;   println("wordstr = %_" % [wordstr])
;   val sentence = replace(wordstr, ", ", " and ")
;   println("sentence = %_" % [sentence])
;   val upper-sentence = upper-case(sentence)
;   println("upper sentence = %_" % [upper-sentence])
;   val trimmed = trim(upper-sentence)
;   println("trimmed = '%_'" % [trimmed])

;defn test-symbols () :
;   val xs = `(a (b c "two" "hello") (d e 3))
;   println(xs[0])
;   println(xs[1])
;   println(xs[2])
;   println(xs[0] == `a)

defn test-vectors () :
   val v = Vector<Char>()
   add-all(v, "God is in his heaven. All is right in this world.")
   println("1. v = %_" % [v])
   remove(v, 5 to 10)
   println("2. v = %_" % [v])
   for c in v update : ;Update is wrong.
      if c >= 'A' and c <= 'Z' : None()
      else : One(c)
   println("3. v = %_" % [v])   
   set-length(v, 10, '.')
   println("4. v = %_" % [v])
   set-length(v, 30, '.')
   println("5. v = %_" % [v])
   for c in v map! :
      if c == '.' : ','
      else : c
   println("6. v = %_" % [v])
   remove-item(v, 'o')
   println("7. v = %_" % [v])

defn test-queues () :
   val q = Queue<Int>()
   do(add{q, _}, [1 2 3 4 5])
   println("q = %_" % [q])
   println("popped %_" % [pop(q)])
   println("popped %_" % [pop(q)])
   println("popped %_" % [pop(q)])
   add(q, 10)
   add(q, 23)
   for i in 0 to 30 do :
      add(q, i)
   println("q = %_" % [q])
   println("q[3] = %_" % [q[3]])

defn test-tables () :
   val t = HashTable<Int,String>("default value")
   t[32] = "thirty-two"
   t[10] = "ten"
   t[11] = "eleven"
   println("t = %_" % [t])
   for i in 0 to 60 do :
      t[i] = to-string("Number(%_)" % [i])
   println("t = %_" % [t])
   t[32] = "Thirty Two"
   t[10] = "Ten"
   remove(t, 11)
   println("t = %_" % [t])
   t[11] = "Elevenses"
   println("t = %_" % [t])
   println("key?(104) = %_" % [key?(t, 104)])
   println("t[104] = %_" % [t[104]])

defn test-sort () :
   val xs = to-array<Int>(repeatedly(rand{1 through 100}, 200))
   val ys = lazy-qsort(xs)
   for y in ys do :
      println("y = %_" % [y])
   println("... and again ...")   
   for y in ys do :
      println("y = %_" % [y])
   
;main()
;lsmain()
;test-arrays()
;test-buffer()
;test-try()
;test-conversions()
;test-parse-int()
;test-addr()
;test-compound-conv()
;test-minimum()
;test-seqs()
;test-strings()
;test-symbols()
;test-vectors()
;test-queues()
;test-tables()
;test-sort()



defpackage collections :
   import core

;============================================================
;===================== Utilities ============================
;============================================================

deftype Sentinel <: Equalable

;============================================================
;===================== Vectors ==============================
;============================================================

;                     Interface
;                     =========

public deftype Vector<T> <: IndexedCollection<T>
public defmulti add<?T> (v:Vector<?T>, value:T) -> False
public defmulti add-all<?T> (v:Vector<?T>, vs:Seqable<T>) -> False
public defmulti clear (v:Vector) -> False
public defmulti pop<?T> (v:Vector<?T>) -> T
public defmulti peek<?T> (v:Vector<?T>) -> T

public defmulti remove (v:Vector, i:Int) -> False
public defmulti remove (v:Vector, r:Range) -> False
public defmulti update<?T> (f: T -> Maybe<T>, v:Vector<?T>) -> False
public defmulti remove-item<?T> (v:Vector<?T&Equalable>, x:T&Equalable) -> False
public defmulti remove-when<?T> (f: T -> True|False, v:Vector<?T>) -> False
public defmulti trim (v:Vector, size:Int) -> False
public defmulti set-length<?T> (v:Vector<?T>, length:Int, x:T) -> False

;                   Implementation
;                   ==============

public defn Vector<T> (cap:Int) -> Vector<T> :
   core/ensure-non-negative("capacity", cap)
   var array = Array<T>(cap)
   var size = 0

   defn ensure-capacity (c:Int) :
      defn set-capacity (c:Int) :
         val new-array = Array<T>(c)
         new-array[0 to size] = array
         array = new-array
      val cur-c = length(array)
      set-capacity(max(c, 2 * cur-c)) when c > cur-c

   new Vector<T> :
      defmethod get (this, i:Int) :
         core/ensure-index-in-bounds(this, i)
         array[i]

      defmethod set (this, i:Int, value:T) :
         if i == size :
            add(this, value)
         else :
            core/ensure-index-in-bounds(this, i)
            array[i] = value

      defmethod length (this) :
         size

      defmethod set-length (this, len:Int, value:T) :
         core/ensure-non-negative("length", len)
         if len > size :
            add-all(this, repeat(value, len - size))
         else :
            trim(this, len)

      defmethod trim (this, new-size:Int) :
         if new-size > size :
            fatal("Given size (%_) is larger than current size (%_)." % [new-size, size])
         size = new-size

      defmethod add (this, value:T) :
         ensure-capacity(size + 1)
         array[size] = value
         size = size + 1

      defmethod add-all (this, vs:Seqable<T>) :
         match(vs) :
            (vs:Seqable<T> & Lengthable) :
               val n = length(vs)
               ensure-capacity(size + n)
               array[size to (size + n)] = vs
               size = size + n
            (vs) :
               do(add{this, _}, vs)

      defmethod pop (this) :
         fatal("Empty Vector") when size == 0
         size = size - 1
         array[size]

      defmethod peek (this) :
         fatal("Empty Vector") when size == 0
         array[size - 1]

      defmethod clear (this) :
         size = 0

      defmethod remove-when (f: T -> True|False, this) :
         for x in this update :
            if f(x) : None()
            else : One(x)

      defmethod remove (this, i:Int) :
         core/ensure-index-in-bounds(this, i)
         for i in i to (size - 1) do :
            array[i] = array[i + 1]
         size = size - 1

      defmethod remove (this, r:Range) :
         core/ensure-index-range(this, r)
         val [s,e] = core/range-bound(this, r)
         val n = e - s
         if n > 0 :
            for i in s to (size - n) do :
               array[i] = array[i + n]
            size = size - n

      defmethod remove-item (this:Vector<T&Equalable>, x:T&Equalable) :
         match(index-of(this, x)) :
            (i:Int) : remove(this, i)
            (i:False) : false

      defmethod update (f: T -> Maybe<T>, this) :
         defn* loop (dst:Int, src:Int) :
            if src < size :
               match(f(array[src])) :
                  (x:One<T>) :
                     array[dst] = value(x)
                     loop(dst + 1, src + 1)
                  (x:None) :
                     loop(dst, src + 1)
            else :
               size = dst
         loop(0, 0)

public defn Vector<T> () -> Vector<T> :
   Vector<T>(8)

public defn to-vector<T> (xs:Seqable<T>) -> Vector<T> :
   val v = Vector<T>()
   add-all(v, xs)
   v

public defn map<R,?T> (f: T -> R, v:Vector<?T>) -> Vector<R> :
   val ret = Vector<R>(length(v))
   add-all(ret, seq(f, v))
   ret


;============================================================
;====================== Queues ==============================
;============================================================

;                      Interface
;                      =========

public deftype Queue<T> <: IndexedCollection<T>
public defmulti add<?T> (q:Queue<?T>, x:T) -> False
public defmulti clear (q:Queue) -> False
public defmulti pop<?T> (q:Queue<?T>) -> T
public defmulti peek<?T> (q:Queue<?T>) -> T

;                    Implementation
;                    ==============

public defn Queue<T> (initial-cap:Int) -> Queue<T> :
   core/ensure-non-negative("capacity", initial-cap)
   var cap:Int = next-pow2(initial-cap)
   var array:Array<T> = Array<T>(cap)
   var begin:Int = 0
   var size:Int = 0

   defn ensure-capacity (c:Int) :
      defn set-capacity (c:Int) :
         val new-array = Array<T>(c)
         for i in 0 to size do :
            new-array[i] = array[wrapped-index(i)]
         array = new-array
         cap = c
         begin = 0
      if c > cap :
         set-capacity(next-pow2(max(c, cap)))

   defn wrapped-index (i:Int) :
      (begin + i) & (cap - 1)

   new Queue<T> :
      defmethod get (this, i:Int) :
         core/ensure-index-in-bounds(this, i)
         array[wrapped-index(i)]
         
      defmethod set (this, i:Int, value:T) :
         if i == -1 :
            add(this, value)
         else :
            core/ensure-index-in-bounds(this, i)
            array[wrapped-index(i)] = value

      defmethod add (this, x:T) :
         ensure-capacity(size + 1)
         begin = wrapped-index(cap - 1)
         array[begin] = x
         size = size + 1

      defmethod pop (this) :
         fatal("Empty Queue") when size == 0
         val x = array[begin]
         size = size - 1
         begin = wrapped-index(1)
         x
         
      defmethod peek (this) :
         fatal("Empty Queue") when size == 0
         array[begin]

      defmethod length (this) :
         size

      defmethod clear (this) :
         size = 0

public defn Queue<T> () -> Queue<T> :
   Queue<T>(8)


;============================================================
;====================== Tables ==============================
;============================================================

;                     Interface
;                     =========

public deftype Table<K,V> <: Many<KeyValue<K,V>> & Lengthable
public defmulti set<?K,?V> (t:Table<?K,?V>, k:K, v:V) -> False
public defmulti get?<?K,?V,?D> (t:Table<?K,?V> k:K, d:?D) -> V|D
public defmulti get<?K,?V> (t:Table<?K,?V>, k:K) -> V
public defmulti key?<?K> (t:Table<?K,?>, k:K) -> True|False
public defmulti keys<?K> (t:Table<?K,?>) -> Seqable<K>
public defmulti values<?V> (t:Table<?,?V>) -> Seqable<V>
public defmulti remove<?K> (t:Table<?K,?>, k:K) -> True|False
public defmulti clear (t:Table) -> False

;              Abstract Implementations
;              ========================

defmethod keys<?K> (t:Table<?K,?>) : seq(key, t)
defmethod values<?K> (t:Table<?K,?>) : seq(value, t)

public defn empty? (t:Table) :
   length(t) == 0

public defn get?<?K,?V> (t:Table<?K,?V>, k:K) :
   get?(t, k, false)

;============================================================
;==================== Hash Tables ===========================
;============================================================

public deftype HashTable<K,V> <: Table<K,V>
defmulti double-capacity (t:HashTable) -> False

public defn HashTable<K,V> (hash: K -> Int, default:Maybe<V>, initial-capacity:Int) -> HashTable<K,V> :
   var cap = next-pow2(max(32, initial-capacity))
   var keys = Array<K|Sentinel>(cap, new Sentinel)
   var values = Array<V|Sentinel>(cap, new Sentinel)
   var size = 0
   var num-keys = 0

   defn key-index (k:K&Equalable) -> Int :
      defn key-slot (k:K, i:Int) -> Int :
         (hash(k) + i) & (cap - 1)      
      for i in 0 to cap first! :
         val s = key-slot(k, i)
         match(keys[s]) :
            (k2:Sentinel) :
               One(s)
            (k2:K&Equalable) :
               if k == k2 : One(s)
               else : None()

   new HashTable<K,V> :
      defmethod double-capacity (this) :
         val entries = to-seq(this)
         cap = cap * 2
         keys = Array<K|Sentinel>(cap, new Sentinel)
         values = Array<V|Sentinel>(cap, new Sentinel)
         size = 0
         num-keys = 0
         for entry in entries do :
            this[key(entry)] = value(entry)
            
      defmethod clear (this) :
         keys[0 to false] = repeat(new Sentinel)
         values[0 to false] = repeat(new Sentinel)
         size = 0
         num-keys = 0
      
      defmethod set (this, hashkey:K, v:V) :
         fatal("Key %~ does not implement Equalable.") when hashkey not-typeof K&Equalable
         
         ;Get key index
         val k = hashkey as K&Equalable
         val i = key-index(k)
         
         ;Set key
         if keys[i] typeof Sentinel :
            keys[i] = k
            num-keys = num-keys + 1            
               
         ;Set value
         if values[i] typeof Sentinel :
            size = size + 1
         values[i] = v

         ;Ensure capacity
         val limit = (cap * 3) >>> 2
         double-capacity(this) when num-keys > limit
         
      defmethod get?<?D> (this, k:K&Equalable, d:?D) :
         val i = key-index(k)
         match(values[i]) :
            (v:Sentinel) : d
            (v:V) : v

      defmethod get (this, k:K&Equalable) :
         val i = key-index(k)
         match(values[i]) :
            (v:Sentinel) :
               match(default) :
                  (d:One<V>) : value(d)
                  (d:None) : fatal("Key %~ does not exist in table." % [k])
            (v:V) : v

      defmethod remove (this, k:K&Equalable) :
         val i = key-index(k)
         match(values[i]) :
            (v:Sentinel) :
               false
            (v:V) :
               values[i] = new Sentinel
               size = size - 1
               num-keys = num-keys - 1
               true

      defmethod key? (this, k:K&Equalable) :
         val i = key-index(k)
         values[i] not-typeof Sentinel

      defmethod length (this) :
         size
         
      defmethod to-seq (this) :
         for (k in keys, v in values) seq? :
            if v not-typeof Sentinel : One((k as K) => (v as V))
            else : None()    

public defn HashTable<K,V> (hash: K -> Int, default:V) :
   HashTable<K,V>(hash, One(default), 32)

public defn HashTable<K,V> (hash: K -> Int) :
   HashTable<K,V>(hash, None(), 32)

public defn HashTable<K,V> (default:V) :
   HashTable<K&Hashable,V>(hash, One(default), 32)

public defn HashTable<K,V> () :
   HashTable<K&Hashable,V>(hash, None(), 32)

defmethod print (o:OutputStream, h:HashTable) :
   print(o, "[%@]" % [h])
      
defpackage user :
   import core
   import collections

defn main () :
   val q = Queue<Int>()
   add(q, 1)
   add(q, 2)
   add(q, 3)
   println(q)

main()
