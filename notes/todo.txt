- Prevent package qualified symbols from being binders.
- Hashtable needs update function
- Bools instead of True|False
- Figure out why the following is not inferrable:
     f: (x:A, y:B) -> C
     map: <?T,?S> (f:T -> ?S, x:?T) -> S
     map: <?T,?S> (f:T -> ?S, x:List<?T>) -> List<S>
     x: A
     y: List<B>
     map(f{x, _}, y)
- Checking language needs to be fixed to deal with after-clauses when
  included via plus clauses.
- Check that lostanza struct fields are unique.
- Check that multis have different arities for branches.
- Check that parametric types have correct arity.
- Lower bounds for type constraint solver.
- Tuple needs to be collapsed for subtyping and flow relations.
- "this" needs to have a type during inference.
- Ensure nested tuple destructuring works. Currently it doesn't.
- Lexer should end scope when it sees a line that begins on the same
- indent.
- Call primitive special forms should give a proper error if not a
  recognized primitive.
- LoStanza defmethod
- Weak References : Flag indicates whether the link to the object is
  the only link to the object. (Then toss away the weak reference when
  done).
- Labels and Gotos: Front end must check that variables are never used
  before they are defined. (Because of labels/gotos this is harder
  than a simple scope check). OR restrict the use of labels and gotos.
- Measure statistic: How much are we suffering from unbounded growth
  of type objects? (We can limit this using a counter if necessary).
  e.g. defn* f<T> (...) :
          f<T|Int>(...)
- Need an implementation of Sets.
- defmulti with no arguments should not crash Stanza.
- Issue proper error messages if defmulti is followed by superfluous
  colon.
- Ensure that multifns have differing arity branches.
- LoStanza deref of a HiStanza type should know the expected LoStanza
  type so that multifns can be derefed appropriately.
- match(s) :
      (s:DefWire|DefMemory) : ...
      (s:DefMemory) : ...
   stanza errors very ungracefully with "Duplicate label gen719903."
- sum/product for Floating point arrays
- Check for overflow
- Switch with single else clause gives strange parser error.
- Clean up parser system:
     - No scoping
     - Suffix ops are difficult
     - No types
     - Escape character is weird
     - Error conditions are clunky
     - The following pattern is very difficult to specify because the
       trailing arguments also happen in #exp production.
          callc ?e:#exp (@do ?args:#exp)
     - Fast stop when tagged with primitive form clumsy.
- Carriage Returns and Tabs should issue proper errors in Lexer
- Literal tuples of enormous lengths should be compiled specially.
- Why do the following statements need to be surrounded with
  parenthesis?
  
  if #I(xt) : (RE() when not (#I(yt) or #F(yt)))
  else if #L(xt) : (RE() when not (#L(yt) or #D(yt)))
  else if #F(xt) : (RE() when not (#I(yt) or #F(yt)))
  else if #D(xt) : (RE() when not (#L(yt) or #D(yt)))
  else : RE()
- Return 0/1 from compiler for success/fail
- Package Format
- Macro system scoping/exporting
- Remove usage of casts and to-long/to-byte/to-float on literals
- Public global variables must have a type.
- IntKeyTables
- VLists
- Type Printing
- Const Lostanza struct fields? Cannot assign to fields in primitive
  types.
- == currently calls core/equal?
- != currently calls core/equal?
- if x instanceof Type : should expand specially
- For defstruct: Don't need to gen symbols for parameterized types.
- Named let loop.
- Bool type
- Add $ls-not form and consider it when compiling if expressions
- Error IDs : For (Argument/Return is the wrong type ...)
- Type Names Table
- Error code when compilation fails for scripting compilation.
- Generated install script has an extra newline.
- Retrieve the stanza dir
- #include statements should be relative to file that contains it.
- Either don't generate .s files (file in memory). OR use unique
  prefix for parallel compilation.
- arraycopy
- Good runtime error messages.
- Eliminate quadratic ambiguity-list algorithm.
- Macro support functions should be protected.
- switch{c == x} : etc. Gives bad error message
- INT-MAX, INT-MIN, etc.
- LoStanza cmp operations should return byte instead. If predicates
  should take bytes.
- Check that nested detupling expressions work.
- Address of Stack allocated locals
- Revamp Parser System
- is-equal? for Arrays and other fundamental mutable types. Then
  implement is-equal? for tables/vectors based on them.
- Can't declare argument with Void types.
- Declare C stub. Call Stanza from C.
- NoGC flag. (Disallows uses of new. Extend-stack creates more stack
  instead of calling GC). 
- addr(ref<?>) check. Unstable pointers created from addr of reference types
  should not be allowed to be passed to functions or have intervening
  NEW commands, without being surrounded in GC-SAFE clauses.
- as?/typeof? macro that returns a Maybe<T>
- Better passable? relation:
     x passable? y IF
        x partial-subtype? y OR
        x subtype? y
  WHERE:
     bot partial-subtype? tau DOES NOT HOLD
- Rename typeof to is, not-typeof to is-not
- Underscore in binders means to ignore. (Avoid redundant definitions).
- LoStanza Assignments to HiStanza variables need to be checked.
- run-garbage-collector should not check for stack extension. 
- Disallow creation of unstable pointers. (ie. No addr(_) on ref<?> objects).
