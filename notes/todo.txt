- Prevent package qualified symbols from being binders.
- Hashtable needs update function
- Hashtable needs default value/function
- Bools instead of True|False
- Figure out why the following is not inferrable:
     f: (x:A, y:B) -> C
     map: <?T,?S> (f:T -> ?S, x:?T) -> S
     map: <?T,?S> (f:T -> ?S, x:List<?T>) -> List<S>
     x: A
     y: List<B>
     map(f{x, _}, y)
- Figure out why the following has a cast error:
   defn main () :
      val xs = List<Int>()
      val ys = concat(0 to 10, 0 to 10)
      val zs = for (x in xs, y in ys) map : x
      val hs = myjoin(zs, "H")
      while true :
         println(more?(hs))
         println(next(hs))         
- Checking language needs to be fixed to deal with after-clauses when
  included via plus clauses.
- Check that lostanza struct fields are unique.
- Check that multis have different arities for branches.
- Check that parametric types have correct arity.
- Lower bounds for type constraint solver.
- Tuple needs to be collapsed for subtyping and flow relations.
- "this" needs to have a type during inference.
- Ensure nested tuple destructuring works. Currently it doesn't.
- Lexer should end scope when it sees a line that begins on the same
- indent.
- Call primitive special forms should give a proper error if not a
  recognized primitive.
- LoStanza defmethod
- Weak References : Flag indicates whether the link to the object is
  the only link to the object. (Then toss away the weak reference when
  done).
- Labels and Gotos: Front end must check that variables are never used
  before they are defined. (Because of labels/gotos this is harder
  than a simple scope check). OR restrict the use of labels and gotos.
======================================================
- Return 0/1 from compiler for success/fail
- Call Stanza from LoStanza
- Package Format
- Core/Verse Cleanup
- Macro system scoping/exporting
- Byte|Int|Long|Float|Double lexer values

