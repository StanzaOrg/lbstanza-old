- Prevent package qualified symbols from being binders.
- Hashtable needs update function
- Hashtable needs default value/function
- Bools instead of True|False
- Figure out why the following is not inferrable:
     f: (x:A, y:B) -> C
     map: <?T,?S> (f:T -> ?S, x:?T) -> S
     map: <?T,?S> (f:T -> ?S, x:List<?T>) -> List<S>
     x: A
     y: List<B>
     map(f{x, _}, y)
- Figure out why the following has a cast error:
   defn main () :
      val xs = List<Int>()
      val ys = concat(0 to 10, 0 to 10)
      val zs = for (x in xs, y in ys) map : x
      val hs = myjoin(zs, "H")
      while true :
         println(more?(hs))
         println(next(hs))         
- Checking language needs to be fixed to deal with after-clauses when
  included via plus clauses.
- Check that lostanza struct fields are unique.
- Check that multis have different arities for branches.
- Check that parametric types have correct arity.
- Lower bounds for type constraint solver.
- Tuple needs to be collapsed for subtyping and flow relations.
- "this" needs to have a type during inference.
- Ensure nested tuple destructuring works. Currently it doesn't.
- Lexer should end scope when it sees a line that begins on the same
- indent.
- Call primitive special forms should give a proper error if not a
  recognized primitive.
- LoStanza defmethod
- Weak References : Flag indicates whether the link to the object is
  the only link to the object. (Then toss away the weak reference when
  done).
- Labels and Gotos: Front end must check that variables are never used
  before they are defined. (Because of labels/gotos this is harder
  than a simple scope check). OR restrict the use of labels and gotos.
- Measure statistic: How much are we suffering from unbounded growth
  of type objects? (We can limit this using a counter if necessary).
  e.g. defn* f<T> (...) :
          f<T|Int>(...)
- HashTable needs a default value parameter to return when a key does
  not exist.
- Objects need a default hash function.
- Need an implementation of Sets.
- defmulti with no arguments should not crash Stanza.
- Issue proper error messages if defmulti is followed by superfluous
  colon.
- Arrays can only be created from types with rest fields.
- Structs can only be created from types without rest fields.
- News can only be created from types without rest fields.
- Ensure that multifns have differing arity branches.
- Introduce upcast node for use by macros.
- LoStanza deref of a HiStanza type should know the expected LoStanza
  type so that multifns can be derefed appropriately.
- Try adding in polymorphic return types and see what breaks.
- Hexademical and Binary numbers in Lexer.
- Long literal tuples.
- match(s) :
      (s:DefWire|DefMemory) : ...
      (s:DefMemory) : ...

   stanza errors very ungracefully with "Duplicate label gen719903."
- sum/product for Floating point arrays
- List needs a better name
- rename error() to fatal(), have it accept anything rather than just
  a string.
- Immutable strings? vs. symbols?
- Check for overflow
- Global variables require explicit type. Otherwise code from other
  packages can affect code in imported package.

======================================================
- Return 0/1 from compiler for success/fail
- Call Stanza from LoStanza
- Package Format
- Core/Verse Cleanup
- Macro system scoping/exporting
- Byte|Int|Long|Float|Double lexer values



================== IN PROGRESS =======================
- Literals
- Primitives

