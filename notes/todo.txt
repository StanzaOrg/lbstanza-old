- Prevent package qualified symbols from being binders.
- Hashtable needs update function
- Hashtable needs default value/function
- Bools instead of True|False
- Figure out why the following is not inferrable:
     f: (x:A, y:B) -> C
     map: <?T,?S> (f:T -> ?S, x:?T) -> S
     map: <?T,?S> (f:T -> ?S, x:List<?T>) -> List<S>
     x: A
     y: List<B>
     map(f{x, _}, y)
- Figure out why the following has a cast error:
   defn main () :
      val xs = List<Int>()
      val ys = concat(0 to 10, 0 to 10)
      val zs = for (x in xs, y in ys) map : x
      val hs = myjoin(zs, "H")
      while true :
         println(more?(hs))
         println(next(hs))         
- Checking language needs to be fixed to deal with after-clauses when
  included via plus clauses.
- Check that lostanza struct fields are unique.
- Check that multis have different arities for branches.
- Check that parametric types have correct arity.
- Lower bounds for type constraint solver.
- Tuple needs to be collapsed for subtyping and flow relations.
- "this" needs to have a type during inference.
- Ensure nested tuple destructuring works. Currently it doesn't.
- Lexer should end scope when it sees a line that begins on the same
- indent.
- Call primitive special forms should give a proper error if not a
  recognized primitive.
- LoStanza defmethod
- Weak References : Flag indicates whether the link to the object is
  the only link to the object. (Then toss away the weak reference when
  done).
- Labels and Gotos: Front end must check that variables are never used
  before they are defined. (Because of labels/gotos this is harder
  than a simple scope check). OR restrict the use of labels and gotos.
- Measure statistic: How much are we suffering from unbounded growth
  of type objects? (We can limit this using a counter if necessary).
  e.g. defn* f<T> (...) :
          f<T|Int>(...)
- HashTable needs a default value parameter to return when a key does
  not exist.
- Objects need a default hash function.
- Need an implementation of Sets.
- defmulti with no arguments should not crash Stanza.
- Issue proper error messages if defmulti is followed by superfluous
  colon.
- Arrays can only be created from types with rest fields.
- Structs can only be created from types without rest fields.
- News can only be created from types without rest fields.
- Ensure that multifns have differing arity branches.
- Introduce upcast node for use by macros.
- LoStanza deref of a HiStanza type should know the expected LoStanza
  type so that multifns can be derefed appropriately.
- Try adding in polymorphic return types and see what breaks.
- Hexademical and Binary numbers in Lexer.
- Long literal tuples.
- match(s) :
      (s:DefWire|DefMemory) : ...
      (s:DefMemory) : ...

   stanza errors very ungracefully with "Duplicate label gen719903."
- sum/product for Floating point arrays
- rename error() to fatal(), have it accept anything rather than just
  a string.
- Check for overflow
- Switch with single else clause gives strange parser error.
- Lexer needs to handle other number types gracefully.
- Lexer needs other escape characters.
- Strings/Symbols need to be pretty-printed properly.
- Ambiguity branches for dispatches are wrong currently. Need to
  consider all pairwise intersections.
- Clean up parser system:
     - No scoping
     - Suffix ops are difficult
     - No types
     - Escape character is weird
     - Error conditions are clunky
     - The following pattern is very difficult to specify because the
       trailing arguments also happen in #exp production.
          callc ?e:#exp (@do ?args:#exp)
     - Fast stop when tagged with primitive form clumsy.
- Carriage Returns and Tabs should issue proper errors in Lexer
- Literal tuples of enormous lengths should be compiled specially.
- Upcast expression (for use in If/And/Or predicates).
- Why do the following statements need to be surrounded with
  parenthesis?
  
  if #I(xt) : (RE() when not (#I(yt) or #F(yt)))
  else if #L(xt) : (RE() when not (#L(yt) or #D(yt)))
  else if #F(xt) : (RE() when not (#I(yt) or #F(yt)))
  else if #D(xt) : (RE() when not (#L(yt) or #D(yt)))
  else : RE()
- Return 0/1 from compiler for success/fail
- Package Format
- Core/Verse Cleanup
- Macro system scoping/exporting
- Byte|Int|Long|Float|Double lexer values
- Public global variables must have a type.
- HiStanza primitives.
- IntKeyTables
- Comparable
- VLists
- Type Names Table
- Error IDs : For (Argument/Return is the wrong type ...)
- Type Printing
- Const Lostanza struct fields? Cannot assign to fields in primitive
  types.
- == currently calls core/equal?
- != currently calls core/equal?
- if x instanceof Type : should expand specially
- For defstruct: Don't need to gen symbols for parameterized types.
- Named let loop.
- zip function

- Add $ls-not form and consider it when compiling if expressions
- Add not, neg primitives for LS and HS
- Add (~ _) and (- _) macros for those primitive operations.


