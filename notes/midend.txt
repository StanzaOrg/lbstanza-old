                    The KForm IR
                    ============

The KForm IR represents the intermediate stage of the program after
all macro-expansion, identifier resolution, syntax checking, and type
checking has taken place. It serves the purpose as both an
intermediate IR for separate compilation, and a distribution format.

K-Level Types
-------------

The following represents types that remain after erasure. 

   KType =
      | KOf: (n:Int)
      | KVar: (n:Int)
      | KAnd: (a:KType, b:KType)
      | KOr: (a:KType, b:KType)
      | KBot
      | KTop

K-Level Top Level Expressions
-----------------------------

Define a global value using KDef, KDefVar.

   KDef :
      n: Int
      value: KExp

   KDefVar :
      n: Int
      value: False|KExp

Defining a function. The input argument types are given, and it is
assumed during code generation that the appropriate checks will be
inserted for ensuring arguments satisfy their contract. There is a
field for the return type which is used during type inference and cast
elision.

   KDefn :
      n: Int
      func: Func

   where :
      Func =
         | KFn :
              tail?: True|False
              targs: List<Int>
              a1: List<KType>
              args: List<Int>
              body: KExp
         | Multifn :
              funcs: List<KFn>
         

Defining a multi to which methods will be attached to.

   KDefmulti :
      n: Int
      a1: List<KType>

Defining a method. The rules apply as for functions. The extra fields
multi and thisn are used for specifying the multi to attach to, and
the indicator of the environment variable "this" respectively.

   KDefmethod :
      n: Int 
      multi: Int
      thisn: False|Int
      func: KFn

K-Level Expressions
-------------------

Read and assign the current state of a global variable. Set returns
false.

   KGetGlobal :
      n: Int

   KSetGlobal :
      n: Int
      value: KVar

Read and assign to the current state of a local variable. Set returns
false.

   KGetLocal :
      n: Int

   KSetLocal :
      n: Int
      value: KVar      

Check that a value is a given type, and error if otherwise.

   KCast :
      exp: KVar
      type: KType

Check that a value exists, and error if otherwise.

   KCheckVoid :
      exp: KVar

Check the length of a tuple.

   KCheckLength :
      exp: KVar
      length: Int

Create a local binding. Anonymous functions are encoded using this
form.

   KLet :
      def: KDef|KDefVar|KDefn
      body: KExp

Create mutually recursive functions.

   KLetRec :
      defns: List<KDefn>
      body: KExp

Sequentially executes two expressions, discarding the result of the
first one.

   KSeq :
      a: KExp
      b: KExp

Matches a list of arguments against a list of branches. Dispatch works
similarly to match except that branches will be ordered according to
specificity and error branches will be inserted for overlapping
branches.

   KDispatch :
      args: List<KVar>
      branches: List<KBranch>

   KMatch :
      args: List<KVar>
      branches: List<KBranch>
      
   KBranch :
      args: List<Int>
      types: List<KType>
      body: KExp

Create a new object.

   KNew :
      class: KType
      methods: List<KDefmethod>

Call a function.

   KDo :
      func: KVar
      targs: List<KType>
      args: List<KVar>

Call a LS function.

   KDoLS :
      func: Int
      targs: List<KType>
      args: List<KVar>

Refer to a declared binder.

   KVar :
      n: Int

Perform a primitive operation on arguments.

   KPrim :
      op: Op
      args: List<KVar>

Create a literal value.

   KLiteral :
      value

Create a tuple.

   KTupleExp :
      exps: List<KVar>

Retrieve a specific element in a tuple.

   KTupleGet :
      exp: KVar
      index: Int
