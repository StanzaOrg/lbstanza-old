============================================================
=================== Specification ==========================
============================================================

Vars refer to operands with locations and identifiers used in
instructions.

   Var :
      name: Symbol
      hint: Loc
      must: Loc
      loc: Loc

A reference can either be an integer or a floating point value. This
affects which registers it may be placed into.

   Type =
      | Byte
      | Int
      | Long
      | Ref
      | Float
      | Double

Locations are possible locations that a reference may be assigned to.

   Locations =
      | None           No assigned location
      | Reg(n)         Integer register
      | FReg(n)        Floating point register
      | ArgLoc(n)      Location of argument n
      | NotArgLoc(n)   Not location of argument n

Expressions are the different possible instructions that the register
allocator algorithm is concerned about.

   [Args] (xs ...) = Args
   [Set] x = y
   [Op] (xs ...) = op(ys ...)
   [Do] (xs ...) = f(ys ...)
   [Goto] goto block

Expressions are grouped into blocks. Every block has a name, a list of
expressions, and a list of successor blocks.

   Block :
      name: Symbol
      exps: List<Exp>
      next: List<Symbol>

An allocation unit is a list of variable definitions, and the list of
blocks that comprise the unit. Each variable is defined by its name,
its type, and its stack location if it is stack allocated.

   Unit :
      defs: List<Def>
      blocks: List<Block>

   Def :
      name: Symbol
      type: Type
      sloc: Loc

============================================================
================ Critical Edge Removal =====================
============================================================

Leave for later.

============================================================
================= Block Liveness Analysis ==================
============================================================

This analysis calculates the variables that are live-in and live-out
for each block. For the live-out variables, it also calculates the
distance until their usage.

Results are stored in a HashTable<Symbol, BlockLive> where :

   BlockLive :
      in: List<Symbol>
      out: List<Symbol>
      dist: List<Int>

Algorithm :
   Considering only [Op] constructs: The in 
   
============================================================
================= Finite Allocation ========================
============================================================



=== Phases ===
1. Working Form
2. Infinite Allocation
3. Finite Allocation
4. Stitching
5. Register Assignment
6. Stack Assignment
7. Output Form

=== Save/Emit Phase ===

General Semantics :
   There are an infinite number of registers, but Do calls destroy
   the contents of all registers, thus values must be saved and loaded
   if they are live and used after a function call.

Semantics of Blocks :
   - Values are passed around in registers if possible.
   - Values may be in either in a register or on the stack upon
     live-in or live-out.

Semantics of Do :
   - Arguments may be in a register or on the stack.
   - Return values are always in registers.

Semantics of Save :
   - Argument must be in a register.

Semantics of Load :
   - Argument must be on the stack.


=== Register Assignment ===

Goal: To assign a concrete location (either Stack or RegN) to every
reference in the program.

Input: The block to perform register assignment, and the preferred
locations of the live-in variables.

State: The location table maps each value to a location. The reg-free
table notes for each register whether it is free to be used or
not. The reg-value table notes for each register which value is
currently loaded into it. The exp-list vector holds the list of
assigned expressions.

Basic Operations:
   Free Register (desired location) : If the desired location is a
   free register, then return it. Otherwise return a fresh free
   register.

   Assign Location (ref, location) : Assumes that ref is not
   dead. Return the reference marked with its location, and update the
   location map and reg-free map accordingly. If location is a
   register, then mark that register as no longer free, and if there
   was previously a value assigned to that register, mark it as now on
   the stack.

   Update Location (ref) : Return reference marked with its location
   according to the location map.

Initial State: We need to create the initial state from the list of
live-in variables, their assumed input status, and their preferred
locations.

For each variable, depending on their status, (S,L) :
   
   (*, T) : Means the variable must be in a register, and saved. So
   assign it a free register (preferably its preferred location).
   
   (T, F) : Means the variable must be on the stack. So assign it a
   stack location.   
   
   (F, F) : Means the variable can be anywhere, so give it its
   preferred location.
   
Assigning Expressions: 
   For Args: For each argument, if it is supposed to be in a register
   then assign it its preferred register for that argument. If it is
   supposTed to be in a stack, then keep it on the stack.

   For Set: Update the argument with its location. Assign a register
   for its output, preferring the same one as its argument.

   For Op: Update the arguments with their locations. Assign registers
   for its output, with preferences depending on the Op.

   For Save: Update the argument with its location.
 
   For Load: Assign a register to its output.

   For Release: Release indicates that the register assigned to the
   value can be reused safely.

   For Do: Update the arguments with their locations. All registers
   are free after a Do. All values that were previously mapped to
   registers are now mapped to the Stack. Assign locations to the
   output arguments in the same way as for the Args node.

Computing the Live-out Positions:
   Look up the locations of each live out variable from the location map.


====== Stack Location Calculation ======

Calculating the Interval Extents: For each value we need to know the
minimum and maximum indices (both inclusive) where it is live. Assume
that blocks are laid out in breadth-first order for simplicity.
   
Scanning a Block :
   Live In: Record the starting index of the block.
   
   Arg Expressions : For every output that is on the stack, note that
   the output is used.
   
   Save Expressons : Note that the value is used.
   
   Load Expressions : Note that the value is used.

   Do Expressions : For every input that is on the stack, note that it
   is used. Step the index to indicate that the output happens at a
   later time than the input. Then for every output that is on the
   stack, note that it is used.

   Live Out: Reserve one index to denote the end of the block, and
   record this index.

Connecting Blocks :
   For each block, for every line-in that is on the stack or assumed
   saved, note that the variable is used at the block's starting
   index, as well as the ending indices of each predecessor to the block.

Assign Locations :
   State: Location map, records the stack location associated with
   each value. Location free, records whether a location is free or not.


======= Block Connection ========

Parallel Move :
   Parallel Move occurs in 3 Phases:
      1. Register to Stack Moves:
         For any x where (stack-dst or save-dst) and not (stack-src or save-src) :
            Save(x)
      2. Register to Register Moves:
         For any x where reg-dst and reg-src :
            ParSet(x)
      3. Stack to Register Moves:
         For any x where reg-dst and stack-src :
            Load(x)
