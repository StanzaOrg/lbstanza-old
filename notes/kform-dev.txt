;                    Changes to KForm
;                    ================
;
;- We insert the checkVoid instructions ourselves during code
;  emission. (Not handled by the frontend).
;
;                Overall Structure of Compiler
;                =============================
;
;Compilation of LoStanza :
;   Type Analysis -- Analyze the whole program for all the defined
;   types, and calculate offsets and padding appropriately.
;
;   Global Analysis -- Analyze the program for global definitions to
;   determine which variables are global, and which variables are
;   direct functions.
;
;   Global Readers -- Globals cannot be referred to directly as Vars
;   and must be read using a Read form.
;
;   Call Conversion -- Analyze calls in program and replace them with
;   working nodes that indicate whether we are calling a direct
;   function or not.
;
;   Compilation -- Generate tgt IR from the analyzed program.
;
;                   Compilation of KForm
;                   ====================
;
;Compiling a Stanza program consists of several parts. Here are all the
;possible top-level forms that concern us, divided roughly into those
;that concern high level Stanza, and those that concern low level
;Stanza.
;
;   Stanza Top Level Forms :
;      KDef 
;      KDefVar 
;      KDefn 
;      KDefmulti 
;      KDefmethod 
;      KDefType 
;      KExpComm 
;
;   LoStanza Top Level Forms :
;      KLSDef 
;      KLSDefVar 
;      KLSDefn 
;      KLSDefType 
;      KExtern 
;      KExternFn 
;
;First consider compiling only a program consisting of solely LoStanza
;constructs. The forms can be further divided into forms that produce
;tgt instructions, and those that do not and instead convey information
;of some sort.
;
;   Tgt Producing Forms :
;      KLSDef
;      KLSDefVar
;      KLSDefn
;      
;   Informative Forms :
;      KLSDefType
;      KExtern
;      KExternFn
;
;KLSDef and KLSDefVar forms are compiled to global locations in the
;program. Several concerns must be handled correctly for globals:
;
;   Padding -- In case we take the address of a global, they must be
;   padded appropriately.
;   
;   Reading/Writing -- Globals cannot be directly referred to by Vars
;   in LoStanza commands or expressions. So a preprocessing step must
;   be added to convert these to either Sets or Reads.
;
;   Layout Table -- A layout table that indicates the location of each
;   reference global must be emitted in order for the garbage collector
;   to trace the root set.
;
;   Entry Function -- The initializing values for variables are set by
;   the entry function of the program.
;
;KLSDefn forms make up the majority of the functionality of LoStanza
;and is explained in its own section.
;
;
;                 Compilation of KLSDefn Forms
;                 ============================
;
;In general, the following concerns must be handled properly to compile
;a LoStanza function:
;
;   Arities -- Function arities must be determined based on the number
;   of normal arguments to a call. This is needed for correct handling
;   of multi-arity functions and for arity checks.
;
;   Type Arguments -- Type arguments must be reified and converted to
;   objects that can test the type of its argument, and that can
;   provide a printed representation of its contents. Closed over type
;   variables must be accounted for in this stage.
;
;   Direct Calls -- Directly defined functions must be recognized, and
;   calls must indicate whether they are calling a direct function or
;   through a pointer.
;
;   Global Closures -- References to a global Stanza function must be
;   converted to its closure form.
;
;   Struct Padding -- Struct locals must be padded appropriately and
;   presented to the register allocator grouped.
;
;
;                    Global Read Conversion
;                    ======================
;
;Globals cannot be directly used as arguments to primitive forms, and
;can only be accessed through the Read form to a temporary value first.
;
;
;
;                          Workspace
;                          =========
;
;Type Analysis
;-------------
;Contains utilities for :
;   - Expanding type into constituent tgt types.
;   - Retrieving the padded offsets of constituent tgt types.
;   - Retrieving the padded size of a type.
;   - Retrieving the field offset of a field.
;   - Retrieving the field index of a field.
;   - Retrieving the rest field for a given struct.
;   - Retrieving the integer tag corresponding to each struct.
;
;Variable Management
;-------------------
;A VarTable supports utilities for :
;   - Creating fresh variables given their types.
;   - Mapping names to their variables.
;   - Retrieving variables corresponding to their names.
;
;Function Scan
;-------------
;KLSWDo :
;   arity: Int
;   f: Int|KLSVar
;   args: List<KLSVar>
;   type: KLSType   
;   
;KLSWCallC :
;   f: Int|KLSVar
;   args: List<KLSVar>
;   type: KLSType
;
;KLSWCallClosure :
;   arity: Int
;   f: KLSVar
;   args: List<KLSVar>
;   type: KLSType
;
;
;Required Utilities :
;   - Retrieving the target variables for the expression being compiled.
;   - Determine whether a function is directly defined. (DONE THROUGH PRESCAN)
;
;
;Divided into the following groups:      
;   Type Analysis -- 
;      
;   Bit Tags -- Contains definitions for each tag used during bit
;   tagging.
;   
;   Tgt Commands -- Contains shorthands for :
;      - Emitting tgt instructions into some buffer.
;      - Creating tgt immediates for immediate values.
;      - Interacting with the heap, extension, incrementing, and
;        retrieving the heap-pointer.
;      
;   Value Labels -- Contains utilities for :
;      - Retrieving labels corresponding to compound literals.
;
;
;Compiling the body of a LoStanza function:
;
;   Structure of compiling a command:
;
;      match(c as KLSComm) :
;         (c:KLSCall) :
;            compile the expression but noting that we do not require
;            the output values.
;         (c:KLSTCall) :
;            similar to KLSCall but indicating that it is a tailcall.
;         (c:KLSSet) :
;            If the location is a value :
;               compile the expression but with the desired output values.
;            Otherwise the location is a store :
;               compile the expression getting back the values, and emit and store.
;         (c:KLSLabel) : direct translation
;         (c:KLSGoto) : direct translation
;         (c:KLSReturn) : direct translation
;         (c:KLSLet) :
;            Compile the expression of the def and put the result in the environment.
;            Continue the compilation
;         (c:KLSSeq) :
;            recursive call
;         (c:KLSIf) :
;            Make labels for the consequent and alternate.
;            Compile the consequent and alternate, emitting Label and Goto instructions appropriately.
;         (c:KLSMatch) :
;            This is more complicated and requires calculating the tags of each type, as well as the dispatch trie.            
;         (c:KLSSkip) :
;            nothing
;
;   Structure of compiling an expression: compile takes an LS
;   expression, and a function for retrieving the target values given
;   their types. Accesses the var-table. 
;
;      defn compile (e:KLSExp, target:List<TgtType> -> List<Var>) -> False :
;         match(e) :
;            (e:KLSVar) : ...
;            (e:KLSRef) : ...
;            (e:KLSRefArray) : ...
;            (e:KLSStruct) : ...
;            (e:KLSPtr) : ...
;            (e:KLSRead) : ...
;            (e:KLSDo) : ...
;            (e:KLSCallC) : ...
;            (e:KLSCallS) : ...
;            (e:KLSSizeof) : ...
;            (e:KLSTagof) : ...
;            (e:KLSConv) : ...
;            (e:KLSValue) : ...
;
;   For compiling KLSVar, we emit a Set instruction assigning each
;   expanded var in e to each target value.
;
;   For compiling KLSRef, we note that we return a REF-TYPE value. We
;   first extend the heap. The returned value is the heap-pointer
;   tagged with REF-TAG to indicate it is a reference. Increment the
;   heap-pointer by the struct size. Store the tag of the struct in the
;   first cell in the heap. Store the following argument vars in the
;   following cells in the heap with the appropriate offset.
;
;   If the size of the struct is zero, then it's instead a
;   marker. Create a marker by shifting the tag left by 3 bits and then
;   adding the MARKER-TAG.
;
;   For compiling KLSRefArray, we note that we return a REF-TYPE
;   value. We create a LONG temporary value for storing the size needed
;   for the array. The needed size is (struct-size + length *
;   sizeof(struct-rtype)). We extend the heap by this size. The
;   returned value is the heap-pointer tagged with REF-TAG to indicate
;   it is a reference. Increment the heap-pointer byte the array
;   size. Store the tag of the struct in the first cell in the
;   heap. Store the following argument vars in the following cells in
;   the heap with the appropriate offset.
;
;   For compiling KLSStruct, we expand the types of the struct to get
;   the appropriate struct types, and note that we return values of
;   those types. We then assign each returned value to the expanded
;   argument vars.
;
;   For compiling KLSPtr, we collapse the location down to a base and
;   an accumulated offset. Depending on the base type (Binder, Deref,
;   Deptr, and Slot) we emit different code to retrieve the pointer,
;   and then we add the accumulated offset.
;
;   For compiling KLSRead,
;
;   For compiling KLSDo,
;
;   For compiling KLSCallC,
;
;   For compiling KLSCallS,
;
;   For compiling KLSSizeof
;
;



;               Required Transforms
;               ===================
;
;1. Box mutable variables
;2. Lift objects
;3. Convert multis
;5. Reify types -- Converts call KDo nodes to KCall nodes. Type objects
;   have all been reified. All KFn values have been converted to KCode
;   objects. All input arguments have their type checks inserted.
;6. Lift closures
;7. Convert mixes/curries.


               Type Semantics of Multis and Methods
               ====================================

Multis and Methods are defined using the syntax :

   defmulti f<?T,?S,...> (a:T1<?T>, b:T2<?S>, ...) -> T3
   
   defmethod f<?T, ?S, ...> (a:T1<?T>, b:T2<?S>, ...) -> T3 :
      body

What is the relation between the type arguments of the multi and the
type arguments of the body? How is the submethod relationship related
to this?

1. The most important observation is that the defmulti specifies the
type signature of the function to external callers. Thus the semantics
of defmulti specifies that the external world is always free to treat
the defmulti as a function of that declared type and will expect it to
satisfy that contract.

2. To derive the submethod relationship, consider if the user has
values with types equivalent to the argument types of the method. Is
the user allowed to call the multi with values of these types? And if
he is allowed, will the returned value from the multi satisfy his
expectations as specified by the return type of the method? If both
are true, then this is a valid partial implementation for the multi.

3. To derive the relationship between the multi's type arguments and
the method's type arguments, consider again if the user has values
with types equivalent to the argument types of the method. Thus
because we know these types exactly, we know the true value that the
method's type arguments should take on. However, we can derive what
type arguments will be passed to the multi through the capture
relation. Therefore, we can derive how to map the captured type
arguments back to our true type arguments for the method.

                     

                     Input KForm Language
                     ====================

Summary
-------

Top Level HiStanza Commands :
   KDef(n, value)
   KDefVar(n, value)
   KDefn(n, value)
   KDefmulti(n, targs, a1, a2)
   KDefmethod(n, multi, targs, thisn, func)
   KDefType(n, parent)
   KInit(exp)

KDefn Function :
   KFn(tail?, targs, a1, a2, args, body)
   KMultifn(funcs ...)

Top Level LoStanza Commands :
   KLSDef(n, type)
   KLSDefn(n, targs, a1, a2, args, body)
   KLSDefType(n, parent, fields, rfield)
   KExtern(n, type, lbl)
   KLSInit(comm)

HiStanza Expressions :
   KSet(n, value)
   KCast(exp, targ)
   KCheckLength(exp, length)
   KLet(def, body)
   KLetRec(KDefn(n, value) ..., body)
   KSeq(a, b)
   KMix(exps)
   KCurry(n, targs)
   KMatch(args, KBranch(args, types, body) ...)
   KNew(class, methods ...)
   KDo(func, targs, args)
   KVar(n)
   KPrim(op, args)
   KLiteral(value)
   KTuple(exps)
   KTupleGet(exps, i)

LoStanza Commands :
   KLSCall(exp)
   KLSTCall(exp)
   KLSSet(exp, value)
   KLSLabel(n)
   KLSGoto(n)
   KLSReturn(exp)
   KLSLet(n, value, body)
   KLSLetVar(n, type, body)
   KLSSeq(a, b)
   KLSIf(pred, conseq, alt)
   KLSMatch(args, KLSBranch(args, types, body) ...)
   KLSPrimComm(op, args)
   KLSSkip

LoStanza Expressions :
   KLSVar(n)
   KLSRef(n, args)
   KLSRefArray(n, length, args)
   KLSStruct(n, args)
   KLSPtr(exp)
   KLSRead(exp)
   KLSPrim(op, args, type)
   KLSCall(func, targs, args, type)
   KLSCallClosure(func, targs, args, type)
   KLSCallC(func, args, type)   
   KLSSizeof(type)
   KLSTagof(n)
   KLSConv(exp, type)
   KLSLitByte(value)
   KLSLitInt(value)
   KLSLitLong(value)
   KLSLitFloat(value)
   KLSLitDouble(value)
   KLSLitString(value)
   KLSMix(exps)
   KLSCurry(n, targs)


HiLevel Stanza Commands
-----------------------

KDef/KDefVar :

Casts are required for their initializing expressions. This allows
invariants to be inferred and optimized during KForm.

KDefmulti :

KDefmulti specifies the join point of all its methods. The input types
and output types are specified and are enforced by KForm. 

KDefmethod :

KDefmethod specifies an implementation for an existing multi. The type
arguments given to the multi are mapped by KForm back in relation to
the method. 

KDefn :

KDefn requires functions to be either a KFn or a KMultifn. Note that
return types must be given for KFns. These return types are enforced
by KForm when possible. Tail call positions cannot enforce their
return types.

KLSDefn :

Return types must be given for KLSDefn commands as well. This is used
for KForm to enforce boundary crossings between Stanza and LoStanza.


HiStanza Expressions
--------------------

KSet :

Casts are required for the expression. 

KCheckLength :

Required for tuple destructuring, because Stanza needs to ensure the
proper size of a tuple during destructuring.

KCurry :

Used to specialize a declared polymorphic function with a number of
given type arguments. Note that a curried LoStanza function needs its
argument types enforced BEFORE the call, as there is no checks
inserted on function entries. Note that multi-arity functions cannot
be curried.

KMix :

Used to automatically mix a number of declared functions into a
superfunction with automatically dispatched arguments. The expressions
must be KCurry expressions. Note that for KMixes, no argument type
enforcing is required because the dispatch will fail otherwise.

KDo :

Used to call a function with a number of type arguments and value
arguments. 

LoStanza Expressions
--------------------

KLSVar :

Used to refer to an existing variable. There are a few separate
situations in which this is used:

   1. Referring to a locally declared variable.
   2. Referring to a globally declared variable.
   3. Referring to a globally declared function.

If referring to a globally declared function, KForm will automatically
make it first-class by creating a closure for it.

KLSCall :

Used for calling a given function. There are two different types of
calls that can be made. They are specified differently:

   1. Direct call to a globally declared function.
   2. Indirect call through a pointer to a function.

KLSConv :

Used for converting a value of one type to another type. If converting
to a reference type, then the conversion will fail if the runtime tag
is not correct.

KLSMix/KLSCurry :

The behaviour mirrors the description in HiStanza. 


                Required Transformations for Compilation
                ========================================

Void Check Insertion :
   - Appropriate references are wrapped in a KCheckVoid node.
      - Global Values and Variables
      - Non-initialized Local Variables
   - TupleGet operations are wrapped in a KCheckVoid node.  

Mutable Variable Boxing :
   - DefVars are converted to KBox nodes.
   - Sets are converted to KBoxSet nodes.
   - References are converted to KBoxGet nodes.

Callsite Normalization :
   - Calls to expressions are attempted to be normalized such that we
     branch to different calls, rather than create a closure through a branch.

Global Closure Conversion :
   - References to global functions are converted to references to
     their closures.

KMix/KCurry Conversion :
   - KMix/KCurry expressions are re-expressed as Dispatch expressions.

Method Type Argument Mapping :
   - Type arguments of multis are mapped appropriately to method type
     arguments.

Boundary Guarding :
   - Argument and Return types are enforced through casts.
   - Calling LoStanza functions from HiStanza need casts for enforcing
     argument and return types.
   - Calling closures from HiStanza needs casts for enforcing
     call-site argument and return types.  

Type Reification :
   - Type arguments to polymorphic functions become KTypeObject
     expressions.
   - KFn and KLSDefn nodes are converted to code definitions.
   - Tailcalls are appropriately tagged in the body of the code.

Object Lifting :
   - KNew expressions are converted to KObject expressions.
   - References to free variables are converted to KObjectGet
     expressions.

Multi Conversion :
   - Methods are combined into single functions under a dispatch
     expression.

Closure Lifting :
   - Local Defn functions are converted to KClosure expressions.
   
Call Conversion :
   - KDo nodes are converted to Call nodes with known arity, and
     direct names for global functions.

Rest Field Pointer Conversion :
   - Reads from KField locations of a rest field are converted to
     pointer expressions to the field.

Cast Conversion :
   - Conv expressions with reference target types are converted to
     Cast expressions to enforce tag match.


                     Transformation Ordering
                     =======================

Global Closure Conversion < KMix/KMurry Conversion :
   Global closure conversion is a special case of KMix/KCurry
   conversion where we curry with zero arguments.

Void Check Insertion < Mutable Variable Boxing :
   Only references to non-initialized variables need to be
   checked. But this information is lost after boxing.

Mutable Variable Boxing < Object Lifting &
Mutable Variable Boxing < Closure Lifting :
   Objects and Closures require their free variables to be known which
   includes mutable variables.

Multi/Method Type Mapping < Multi Conversion :
   Multi conversions require all the type mapping to be done so that
   assembling all methods do not require type substitution
   calculations.

Multi/Method Type Mapping < Boundary Guarding :
   Boundary guards require the full type of the method arguments and
   return (including the inherited guards from its multi). 

Type Reification < Object Lifting & Closure Lifting :
   Objects and Closures require their free variables to be known which
   includes first-class type guards.

Type Reification < Call Conversion :
   Converted calls no longer have fields for type arguments. Assumed
   for all type arguments to be first-class by this point.

KMix/KCurry Conversion < Closure Lifting :
   KMix/KCurry may mix locally defined functions. Thus they may
   require local functions to be part of the curried object.

Object Lifting < Closure Lifting :
   Closures require all of its free variables to be known which may
   include objects. 

KMix/KCurry Conversion & Method Type Argument Mapping & Boundary
Guards < Type Reification :
   These transformations require knowing the type argument information
   of functions and function calls which is lost after type
   reification. 

Object Lifting < Multi Conversion :
   Objects must be lifted for all methods to be defined. Multis cannot
   be converted before all methods are discovered.

Closure Lifting < Call Conversion :
   Call conversion requires identifying calls to direct functions. If
   a local function is called, then that is transformed into a call to
   a direct function with the closure as the first argument. This
   cannot be done before closures are identified.

KMix/KCurry Conversion < Boundary Guards :
   KMix/KCurry resolves to calls to functions, some of which may
   require bound guards inserted before and after their calls.

Callsite Normalization < Global Closure Conversion :
   Global closure conversion treats expressions in function calling
   position differently than otherwise. Best results follow from
   ensuring as many global functions are in calling positions as possible.



                    Philosophy of Boundary Checks
                    =============================

Code within LoStanza is considered trusted, and no implicit checks are
ever added. Tag checks are only done through explicit conversion
operations. To maintain the semantics required by HiStanza, we instead
enforce possible boundary crossings between HiStanza and
LoStanza. Whenever HiStanza calls a LoStanza function, the arguments
are checked before entering the call, and the return value is checked
after exiting the call. Similarly, whenever a closure is formed from a
LoStanza function, the arguments are checked before entering the call
and the return value is checked after exiting the call.


                   Input Language to Compilation
                   =============================

Summary
-------

Top Level HiStanza Commands :
   KDef(n, value)
   KDefVar(n, value)
   KDefn(n, value)
   KDefType(n, parent)
   KDefTypeObject(n, args, type)
   KDefConst(n, value)
   KInit(exp)

KDefn Function :
   KCode(arity, args, body)
   KMultifn(codes ...)

Top Level LoStanza Commands :
   KLSDef(n, type)
   KLSDefCode(n, arity, args, types, body)
   KLSDefType(n, parent, fields, rfield)
   KExtern(n, type, lbl)
   KLSInit(comm)

HiStanza Expressions :
   KSet(n, value)
   KCast(exp, targ)
   KCheckVoid(exp)
   KCheckLength(exp, length)
   KLet(KDef(n, value), body)
   KLetRec(KDef(n, KClosure(code, args)) ..., body)
   KSeq(a, b)
   KDispatch(args, KBranch(args, types, body) ...)
   KMatch(args, KBranch(args, types, body) ...)
   KObject(n, args)
   KObjectGet(object, index)
   KTypeObject(n, args)
   KCall(tail?, arity, func, args)
   KVar(n)
   KPrim(op, args)
   KLiteral(value)
   KTuple(exps)
   KTupleGet(exps, i)
   KBox(value)
   KBoxGet(box)
   KBoxSet(box, value)
   KClosure(n, args)
   KClosureGet(exp, i)
   KBranchError()

LoStanza Commands :
   KLSCall(exp)
   KLSTCall(exp)
   KLSSet(exp, value)
   KLSLabel(n)
   KLSGoto(n)
   KLSReturn(exp)
   KLSLet(n, value, body)
   KLSLetVar(n, type, body)
   KLSSeq(a, b)
   KLSIf(pred, conseq, alt)
   KLSMatch(args, KLSBranch(args, types, body) ...)
   KLSDispatch(args, KLSBranch(args, types, body) ...)
   KLSPrimComm(op, args)
   KLSSkip

LoStanza Expressions :
   KLSVar(n)
   KLSRef(n, args)
   KLSRefArray(n, length, args)
   KLSStruct(n, args)
   KLSPtr(exp)
   KLSRead(exp)
   KLSPrim(op, args, type)
   KLSWCall(arity, func, args, type)
   KLSWCallClosure(arity, func, args, type)
   KLSCallC(func, args, type)
   KLSSizeof(type)
   KLSTagof(n)
   KLSConv(exp, type)
   KLSLitByte(value)
   KLSLitInt(value)
   KLSLitLong(value)
   KLSLitFloat(value)
   KLSLitDouble(value)
   KLSLitString(value)
   KLSCast(exp, type)
   KLSTypeObject(n, args)


HiStanza Top Level Commands
---------------------------

The root set -- These commands comprise the root set for
HiStanza. Consts are stored in a separate area for initialization
purposes. Any global functions referenced directly have been converted
to closures and defined using KDef.

   KDef(n, value)
   KDefVar(n, value)
   KDefConst(n, value)

Defining functions -- Functions are defined using KDefn. The bodies
must indicate the number of free variables for referenced by this
function, the arity of the function (not including the type
arguments), all the arguments, and the body. Entry type checks are
assumed to be in the body.

   KDefn(n, value)
   KCode(numfree, arity, args, body)
   KMultifn(codes ...)

Defining types -- Types are defined using KDefType. When types become
first-class and are passed as arguments, they are referenced through a
KDefTypeObject command.

   KDefType(n, parent)
   KDefTypeObject(n, args, type)

Initializing expressions -- Expressions that must be run in order for
the top-level is given by these commands.

   KInit(exp)


LoStanza Top Level Commands
---------------------------

The root set -- The root set is entirely defined by the KLSDef
command. There is no value given, it is assumed to be initialized
using a KLSInit command.

   KLSDef(n, type)

Defining functions -- The arity of the function does not include
reified type arguments. Entry type checks are assumed to be in the
body. Only arguments types are needed. 

   KLSDefCode(n, arity, args, types, body)

Defining types -- LoStanza structs are defined using this.

   KLSDefType(n, parent, fields, rfield)

External definitions -- This command defines external variables and
functions.

   KExtern(n, type, lbl)

Initializing commands -- Commands that must be run in order for
the top-level is given by these commands.

   KLSInit(comm)
   

HiStanza Expressions
--------------------

References -- May be used to refer to global or local
variables/values. Note that a global function (Hi or Lo Stanza) cannot
be referenced directly using KVar. They must be converted to closures.

   KVar(n)

Creating Type Arguments -- Create type objects given the label of
their type definition, and their closed over arguments.

   KTypeObject(n, args)

Calling Functions -- Functions may either be a direct label in which
case it is a simple call, or an expression in which case it is a
closure call.
   
   KCall(tail?, arity, func, args)

Creating Closures -- Given its code definition, and its closed over
variables.

   KClosure(n, args)


LoStanza Expressions
--------------------

References -- May be used to refer to global or local
variables/values. Note that a global function (Hi or Lo Stanza) cannot
be referenced directly using KVar. They must be converted to closures.

   KLSVar(n)

Pointers -- May be used to refer to global/local variables or
functions. Functions may be referred to directly here.

   KLSPtr(exp)

Calling Functions -- Functions may be either a direct label for a
simple call. Or it may be an expression in which case it is an
indirect call.

   KLSWCall(arity, func, args, type)
   KLSCallC(func, args, type)

Calling Closures -- The argument is always given as an
expression. Stanza calls the closure using the appropriate calling
convention.

   KLSWCallClosure(arity, func, args, type)




                     Automatic Stack Extension
                     =========================

Stack Layout
------------

  +---------------------------------+
  | INDEX | PARENT | SP | ITEMS ... |
  +---------------------------------+
  
Stacks Layout
-------------

  +------------------------------------------+
  | FREE FRAMES ...    | ACTIVE FRAMES ...   |
  +------------------------------------------+

Function prelude
----------------

  SMax = RSP + Frame Size + 8
  If SMax > SLim :
     Switch to Free Stack
     (xs ...) = Args
     If number of free stacks < 1 :
        extend-stack()
  else :
     (xs ...) = Args
  function body

Switching to Free Stack
-----------------------
  1. Cap the current stack.
     stack.rsp = rsp
  2. Retrieve the next free stack.
     s = Stacks[num-free - 1]
     num-free = num-free - 1
  3. Link it to the current stack.
     s.parent = stack
  4. Update the stack pointer, limits, and current stack
     rsp = ptr(s.items)
     slim = s + stack-size - REF-TAG
     stack = s

Assembly Code
-------------

  Registers:
     s0 = R0
     i = R1
     s1 = R2
     ss = R3
     lim = R3

  1. Cap the current stack
  s0 = [stack]
  [s0.rsp] = RSP

  2. Retrieve the next free stack
  i = [num-free]
  i = i - 1  
  s1 = i << 3
  ss = [stacks]
  s1 = s1 + ss
  s1 = [s1]
  [num-free] = i

  3. Link it to the current stack
  [s1.parent] = s0
  
  4. Update the stack pointer and limits
  RSP = ptr(s1.items)
  lim = s1 + stack-size - REF-TAG
  [stack-lim] = lim  
  [stack] = s1



   
   


