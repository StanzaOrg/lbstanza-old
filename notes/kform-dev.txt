                   Compilation of LoStanza
                   =======================

Compilation of the Top Level -- KLSDefn constructs are compiled to
DefFn constructs. KLSDefVar and KLSDef constructs are compiled to
DefVar constructs.

Compiling a LoStanza function
-----------------------------

The algorithm state is defined by the following tables:
   Environment - A mapping from variable names to groups of target
   names and their types.   

Compiling a LoStanza function consists of compiling the function
prelude, and then compiling each instruction.

Function Prelude -- The arguments are split into their type
components are assigned from the argument locations.

Function Body -- Compiling the body of the function is split into
two recursive functions, compile(KLSComm) and compile(KLSExp).

   compile(KLSExp) takes an expression and returns a list of values
   and their types, note that these values are not yet added to the
   Environment.



                          Workspace
                          =========

Type Analysis
-------------
Contains utilities for :
   - Expanding type into constituent tgt types.
   - Retrieving the padded offsets of constituent tgt types.
   - Retrieving the padded size of a type.
   - Retrieving the field offset of a field.
   - Retrieving the field index of a field.
   - Retrieving the rest field for a given struct.
   - Retrieving the integer tag corresponding to each struct.

Variable Management
-------------------
A VarTable supports utilities for :
   - Creating fresh variables given their types.
   - Mapping names to their variables.
   - Retrieving variables corresponding to their names.

Function Scan
-------------
KLSWDo :
   arity: Int
   f: Int|KLSVar
   args: List<KLSVar>
   type: KLSType   
   
KLSWCallC :
   f: Int|KLSVar
   args: List<KLSVar>
   type: KLSType

KLSWCallClosure :
   arity: Int
   f: KLSVar
   args: List<KLSVar>
   type: KLSType


Required Utilities :
   - Retrieving the target variables for the expression being compiled.
   - Determine whether a function is directly defined. (DONE THROUGH PRESCAN)


Divided into the following groups:      
   Type Analysis -- 
      
   Bit Tags -- Contains definitions for each tag used during bit
   tagging.
   
   Tgt Commands -- Contains shorthands for :
      - Emitting tgt instructions into some buffer.
      - Creating tgt immediates for immediate values.
      - Interacting with the heap, extension, incrementing, and
        retrieving the heap-pointer.
      
   Value Labels -- Contains utilities for :
      - Retrieving labels corresponding to compound literals.


Compiling the body of a LoStanza function:

   Structure of compiling a command:

      match(c as KLSComm) :
         (c:KLSCall) :
            compile the expression but noting that we do not require
            the output values.
         (c:KLSTCall) :
            similar to KLSCall but indicating that it is a tailcall.
         (c:KLSSet) :
            If the location is a value :
               compile the expression but with the desired output values.
            Otherwise the location is a store :
               compile the expression getting back the values, and emit and store.
         (c:KLSLabel) : direct translation
         (c:KLSGoto) : direct translation
         (c:KLSReturn) : direct translation
         (c:KLSLet) :
            Compile the expression of the def and put the result in the environment.
            Continue the compilation
         (c:KLSSeq) :
            recursive call
         (c:KLSIf) :
            Make labels for the consequent and alternate.
            Compile the consequent and alternate, emitting Label and Goto instructions appropriately.
         (c:KLSMatch) :
            This is more complicated and requires calculating the tags of each type, as well as the dispatch trie.            
         (c:KLSSkip) :
            nothing

   Structure of compiling an expression: compile takes an LS
   expression, and a function for retrieving the target values given
   their types. Accesses the var-table. 

      defn compile (e:KLSExp, target:List<TgtType> -> List<Var>) -> False :
         match(e) :
            (e:KLSVar) : ...
            (e:KLSRef) : ...
            (e:KLSRefArray) : ...
            (e:KLSStruct) : ...
            (e:KLSPtr) : ...
            (e:KLSRead) : ...
            (e:KLSDo) : ...
            (e:KLSCallC) : ...
            (e:KLSCallS) : ...
            (e:KLSSizeof) : ...
            (e:KLSTagof) : ...
            (e:KLSConv) : ...
            (e:KLSValue) : ...

   For compiling KLSVar, we emit a Set instruction assigning each
   expanded var in e to each target value.

   For compiling KLSRef, we note that we return a REF-TYPE value. We
   first extend the heap. The returned value is the heap-pointer
   tagged with REF-TAG to indicate it is a reference. Increment the
   heap-pointer by the struct size. Store the tag of the struct in the
   first cell in the heap. Store the following argument vars in the
   following cells in the heap with the appropriate offset.

   If the size of the struct is zero, then it's instead a
   marker. Create a marker by shifting the tag left by 3 bits and then
   adding the MARKER-TAG.

   For compiling KLSRefArray, we note that we return a REF-TYPE
   value. We create a LONG temporary value for storing the size needed
   for the array. The needed size is (struct-size + length *
   sizeof(struct-rtype)). We extend the heap by this size. The
   returned value is the heap-pointer tagged with REF-TAG to indicate
   it is a reference. Increment the heap-pointer byte the array
   size. Store the tag of the struct in the first cell in the
   heap. Store the following argument vars in the following cells in
   the heap with the appropriate offset.

   For compiling KLSStruct, we expand the types of the struct to get
   the appropriate struct types, and note that we return values of
   those types. We then assign each returned value to the expanded
   argument vars.

   For compiling KLSPtr, we collapse the location down to a base and
   an accumulated offset. Depending on the base type (Binder, Deref,
   Deptr, and Slot) we emit different code to retrieve the pointer,
   and then we add the accumulated offset.

   For compiling KLSRead,

   For compiling KLSDo,

   For compiling KLSCallC,

   For compiling KLSCallS,

   For compiling KLSSizeof
