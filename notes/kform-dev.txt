                    Changes to KForm
                    ================

- We insert the checkVoid instructions ourselves during code
  emission. (Not handled by the frontend).

                Overall Structure of Compiler
                =============================

Compilation of LoStanza :
   Type Analysis -- Analyze the whole program for all the defined
   types, and calculate offsets and padding appropriately.

   Global Analysis -- Analyze the program for global definitions to
   determine which variables are global, and which variables are
   direct functions.

   Global Readers -- Globals cannot be referred to directly as Vars
   and must be read using a Read form.

   Call Conversion -- Analyze calls in program and replace them with
   working nodes that indicate whether we are calling a direct
   function or not.

   Compilation -- Generate tgt IR from the analyzed program.

                   Compilation of KForm
                   ====================

Compiling a Stanza program consists of several parts. Here are all the
possible top-level forms that concern us, divided roughly into those
that concern high level Stanza, and those that concern low level
Stanza.

   Stanza Top Level Forms :
      KDef 
      KDefVar 
      KDefn 
      KDefmulti 
      KDefmethod 
      KDefType 
      KExpComm 

   LoStanza Top Level Forms :
      KLSDef 
      KLSDefVar 
      KLSDefn 
      KLSDefType 
      KExtern 
      KExternFn 

First consider compiling only a program consisting of solely LoStanza
constructs. The forms can be further divided into forms that produce
tgt instructions, and those that do not and instead convey information
of some sort.

   Tgt Producing Forms :
      KLSDef
      KLSDefVar
      KLSDefn
      
   Informative Forms :
      KLSDefType
      KExtern
      KExternFn

KLSDef and KLSDefVar forms are compiled to global locations in the
program. Several concerns must be handled correctly for globals:

   Padding -- In case we take the address of a global, they must be
   padded appropriately.
   
   Reading/Writing -- Globals cannot be directly referred to by Vars
   in LoStanza commands or expressions. So a preprocessing step must
   be added to convert these to either Sets or Reads.

   Layout Table -- A layout table that indicates the location of each
   reference global must be emitted in order for the garbage collector
   to trace the root set.

   Entry Function -- The initializing values for variables are set by
   the entry function of the program.

KLSDefn forms make up the majority of the functionality of LoStanza
and is explained in its own section.


                 Compilation of KLSDefn Forms
                 ============================

In general, the following concerns must be handled properly to compile
a LoStanza function:

   Arities -- Function arities must be determined based on the number
   of normal arguments to a call. This is needed for correct handling
   of multi-arity functions and for arity checks.

   Type Arguments -- Type arguments must be reified and converted to
   objects that can test the type of its argument, and that can
   provide a printed representation of its contents. Closed over type
   variables must be accounted for in this stage.

   Direct Calls -- Directly defined functions must be recognized, and
   calls must indicate whether they are calling a direct function or
   through a pointer.

   Global Closures -- References to a global Stanza function must be
   converted to its closure form.

   Struct Padding -- Struct locals must be padded appropriately and
   presented to the register allocator grouped.


                    Global Read Conversion
                    ======================

Globals cannot be directly used as arguments to primitive forms, and
can only be accessed through the Read form to a temporary value first.



                          Workspace
                          =========

Type Analysis
-------------
Contains utilities for :
   - Expanding type into constituent tgt types.
   - Retrieving the padded offsets of constituent tgt types.
   - Retrieving the padded size of a type.
   - Retrieving the field offset of a field.
   - Retrieving the field index of a field.
   - Retrieving the rest field for a given struct.
   - Retrieving the integer tag corresponding to each struct.

Variable Management
-------------------
A VarTable supports utilities for :
   - Creating fresh variables given their types.
   - Mapping names to their variables.
   - Retrieving variables corresponding to their names.

Function Scan
-------------
KLSWDo :
   arity: Int
   f: Int|KLSVar
   args: List<KLSVar>
   type: KLSType   
   
KLSWCallC :
   f: Int|KLSVar
   args: List<KLSVar>
   type: KLSType

KLSWCallClosure :
   arity: Int
   f: KLSVar
   args: List<KLSVar>
   type: KLSType


Required Utilities :
   - Retrieving the target variables for the expression being compiled.
   - Determine whether a function is directly defined. (DONE THROUGH PRESCAN)


Divided into the following groups:      
   Type Analysis -- 
      
   Bit Tags -- Contains definitions for each tag used during bit
   tagging.
   
   Tgt Commands -- Contains shorthands for :
      - Emitting tgt instructions into some buffer.
      - Creating tgt immediates for immediate values.
      - Interacting with the heap, extension, incrementing, and
        retrieving the heap-pointer.
      
   Value Labels -- Contains utilities for :
      - Retrieving labels corresponding to compound literals.


Compiling the body of a LoStanza function:

   Structure of compiling a command:

      match(c as KLSComm) :
         (c:KLSCall) :
            compile the expression but noting that we do not require
            the output values.
         (c:KLSTCall) :
            similar to KLSCall but indicating that it is a tailcall.
         (c:KLSSet) :
            If the location is a value :
               compile the expression but with the desired output values.
            Otherwise the location is a store :
               compile the expression getting back the values, and emit and store.
         (c:KLSLabel) : direct translation
         (c:KLSGoto) : direct translation
         (c:KLSReturn) : direct translation
         (c:KLSLet) :
            Compile the expression of the def and put the result in the environment.
            Continue the compilation
         (c:KLSSeq) :
            recursive call
         (c:KLSIf) :
            Make labels for the consequent and alternate.
            Compile the consequent and alternate, emitting Label and Goto instructions appropriately.
         (c:KLSMatch) :
            This is more complicated and requires calculating the tags of each type, as well as the dispatch trie.            
         (c:KLSSkip) :
            nothing

   Structure of compiling an expression: compile takes an LS
   expression, and a function for retrieving the target values given
   their types. Accesses the var-table. 

      defn compile (e:KLSExp, target:List<TgtType> -> List<Var>) -> False :
         match(e) :
            (e:KLSVar) : ...
            (e:KLSRef) : ...
            (e:KLSRefArray) : ...
            (e:KLSStruct) : ...
            (e:KLSPtr) : ...
            (e:KLSRead) : ...
            (e:KLSDo) : ...
            (e:KLSCallC) : ...
            (e:KLSCallS) : ...
            (e:KLSSizeof) : ...
            (e:KLSTagof) : ...
            (e:KLSConv) : ...
            (e:KLSValue) : ...

   For compiling KLSVar, we emit a Set instruction assigning each
   expanded var in e to each target value.

   For compiling KLSRef, we note that we return a REF-TYPE value. We
   first extend the heap. The returned value is the heap-pointer
   tagged with REF-TAG to indicate it is a reference. Increment the
   heap-pointer by the struct size. Store the tag of the struct in the
   first cell in the heap. Store the following argument vars in the
   following cells in the heap with the appropriate offset.

   If the size of the struct is zero, then it's instead a
   marker. Create a marker by shifting the tag left by 3 bits and then
   adding the MARKER-TAG.

   For compiling KLSRefArray, we note that we return a REF-TYPE
   value. We create a LONG temporary value for storing the size needed
   for the array. The needed size is (struct-size + length *
   sizeof(struct-rtype)). We extend the heap by this size. The
   returned value is the heap-pointer tagged with REF-TAG to indicate
   it is a reference. Increment the heap-pointer byte the array
   size. Store the tag of the struct in the first cell in the
   heap. Store the following argument vars in the following cells in
   the heap with the appropriate offset.

   For compiling KLSStruct, we expand the types of the struct to get
   the appropriate struct types, and note that we return values of
   those types. We then assign each returned value to the expanded
   argument vars.

   For compiling KLSPtr, we collapse the location down to a base and
   an accumulated offset. Depending on the base type (Binder, Deref,
   Deptr, and Slot) we emit different code to retrieve the pointer,
   and then we add the accumulated offset.

   For compiling KLSRead,

   For compiling KLSDo,

   For compiling KLSCallC,

   For compiling KLSCallS,

   For compiling KLSSizeof
