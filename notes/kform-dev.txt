                    Changes to KForm
                    ================

- We insert the checkVoid instructions ourselves during code
  emission. (Not handled by the frontend).

                Overall Structure of Compiler
                =============================

Compilation of LoStanza :
   Type Analysis -- Analyze the whole program for all the defined
   types, and calculate offsets and padding appropriately.

   Global Analysis -- Analyze the program for global definitions to
   determine which variables are global, and which variables are
   direct functions.

   Global Readers -- Globals cannot be referred to directly as Vars
   and must be read using a Read form.

   Call Conversion -- Analyze calls in program and replace them with
   working nodes that indicate whether we are calling a direct
   function or not.

   Compilation -- Generate tgt IR from the analyzed program.

                   Compilation of KForm
                   ====================

Compiling a Stanza program consists of several parts. Here are all the
possible top-level forms that concern us, divided roughly into those
that concern high level Stanza, and those that concern low level
Stanza.

   Stanza Top Level Forms :
      KDef 
      KDefVar 
      KDefn 
      KDefmulti 
      KDefmethod 
      KDefType 
      KExpComm 

   LoStanza Top Level Forms :
      KLSDef 
      KLSDefVar 
      KLSDefn 
      KLSDefType 
      KExtern 
      KExternFn 

First consider compiling only a program consisting of solely LoStanza
constructs. The forms can be further divided into forms that produce
tgt instructions, and those that do not and instead convey information
of some sort.

   Tgt Producing Forms :
      KLSDef
      KLSDefVar
      KLSDefn
      
   Informative Forms :
      KLSDefType
      KExtern
      KExternFn

KLSDef and KLSDefVar forms are compiled to global locations in the
program. Several concerns must be handled correctly for globals:

   Padding -- In case we take the address of a global, they must be
   padded appropriately.
   
   Reading/Writing -- Globals cannot be directly referred to by Vars
   in LoStanza commands or expressions. So a preprocessing step must
   be added to convert these to either Sets or Reads.

   Layout Table -- A layout table that indicates the location of each
   reference global must be emitted in order for the garbage collector
   to trace the root set.

   Entry Function -- The initializing values for variables are set by
   the entry function of the program.

KLSDefn forms make up the majority of the functionality of LoStanza
and is explained in its own section.


                 Compilation of KLSDefn Forms
                 ============================

In general, the following concerns must be handled properly to compile
a LoStanza function:

   Arities -- Function arities must be determined based on the number
   of normal arguments to a call. This is needed for correct handling
   of multi-arity functions and for arity checks.

   Type Arguments -- Type arguments must be reified and converted to
   objects that can test the type of its argument, and that can
   provide a printed representation of its contents. Closed over type
   variables must be accounted for in this stage.

   Direct Calls -- Directly defined functions must be recognized, and
   calls must indicate whether they are calling a direct function or
   through a pointer.

   Global Closures -- References to a global Stanza function must be
   converted to its closure form.

   Struct Padding -- Struct locals must be padded appropriately and
   presented to the register allocator grouped.


                    Global Read Conversion
                    ======================

Globals cannot be directly used as arguments to primitive forms, and
can only be accessed through the Read form to a temporary value first.



                          Workspace
                          =========

Type Analysis
-------------
Contains utilities for :
   - Expanding type into constituent tgt types.
   - Retrieving the padded offsets of constituent tgt types.
   - Retrieving the padded size of a type.
   - Retrieving the field offset of a field.
   - Retrieving the field index of a field.
   - Retrieving the rest field for a given struct.
   - Retrieving the integer tag corresponding to each struct.

Variable Management
-------------------
A VarTable supports utilities for :
   - Creating fresh variables given their types.
   - Mapping names to their variables.
   - Retrieving variables corresponding to their names.

Function Scan
-------------
KLSWDo :
   arity: Int
   f: Int|KLSVar
   args: List<KLSVar>
   type: KLSType   
   
KLSWCallC :
   f: Int|KLSVar
   args: List<KLSVar>
   type: KLSType

KLSWCallClosure :
   arity: Int
   f: KLSVar
   args: List<KLSVar>
   type: KLSType


Required Utilities :
   - Retrieving the target variables for the expression being compiled.
   - Determine whether a function is directly defined. (DONE THROUGH PRESCAN)


Divided into the following groups:      
   Type Analysis -- 
      
   Bit Tags -- Contains definitions for each tag used during bit
   tagging.
   
   Tgt Commands -- Contains shorthands for :
      - Emitting tgt instructions into some buffer.
      - Creating tgt immediates for immediate values.
      - Interacting with the heap, extension, incrementing, and
        retrieving the heap-pointer.
      
   Value Labels -- Contains utilities for :
      - Retrieving labels corresponding to compound literals.


Compiling the body of a LoStanza function:

   Structure of compiling a command:

      match(c as KLSComm) :
         (c:KLSCall) :
            compile the expression but noting that we do not require
            the output values.
         (c:KLSTCall) :
            similar to KLSCall but indicating that it is a tailcall.
         (c:KLSSet) :
            If the location is a value :
               compile the expression but with the desired output values.
            Otherwise the location is a store :
               compile the expression getting back the values, and emit and store.
         (c:KLSLabel) : direct translation
         (c:KLSGoto) : direct translation
         (c:KLSReturn) : direct translation
         (c:KLSLet) :
            Compile the expression of the def and put the result in the environment.
            Continue the compilation
         (c:KLSSeq) :
            recursive call
         (c:KLSIf) :
            Make labels for the consequent and alternate.
            Compile the consequent and alternate, emitting Label and Goto instructions appropriately.
         (c:KLSMatch) :
            This is more complicated and requires calculating the tags of each type, as well as the dispatch trie.            
         (c:KLSSkip) :
            nothing

   Structure of compiling an expression: compile takes an LS
   expression, and a function for retrieving the target values given
   their types. Accesses the var-table. 

      defn compile (e:KLSExp, target:List<TgtType> -> List<Var>) -> False :
         match(e) :
            (e:KLSVar) : ...
            (e:KLSRef) : ...
            (e:KLSRefArray) : ...
            (e:KLSStruct) : ...
            (e:KLSPtr) : ...
            (e:KLSRead) : ...
            (e:KLSDo) : ...
            (e:KLSCallC) : ...
            (e:KLSCallS) : ...
            (e:KLSSizeof) : ...
            (e:KLSTagof) : ...
            (e:KLSConv) : ...
            (e:KLSValue) : ...

   For compiling KLSVar, we emit a Set instruction assigning each
   expanded var in e to each target value.

   For compiling KLSRef, we note that we return a REF-TYPE value. We
   first extend the heap. The returned value is the heap-pointer
   tagged with REF-TAG to indicate it is a reference. Increment the
   heap-pointer by the struct size. Store the tag of the struct in the
   first cell in the heap. Store the following argument vars in the
   following cells in the heap with the appropriate offset.

   If the size of the struct is zero, then it's instead a
   marker. Create a marker by shifting the tag left by 3 bits and then
   adding the MARKER-TAG.

   For compiling KLSRefArray, we note that we return a REF-TYPE
   value. We create a LONG temporary value for storing the size needed
   for the array. The needed size is (struct-size + length *
   sizeof(struct-rtype)). We extend the heap by this size. The
   returned value is the heap-pointer tagged with REF-TAG to indicate
   it is a reference. Increment the heap-pointer byte the array
   size. Store the tag of the struct in the first cell in the
   heap. Store the following argument vars in the following cells in
   the heap with the appropriate offset.

   For compiling KLSStruct, we expand the types of the struct to get
   the appropriate struct types, and note that we return values of
   those types. We then assign each returned value to the expanded
   argument vars.

   For compiling KLSPtr, we collapse the location down to a base and
   an accumulated offset. Depending on the base type (Binder, Deref,
   Deptr, and Slot) we emit different code to retrieve the pointer,
   and then we add the accumulated offset.

   For compiling KLSRead,

   For compiling KLSDo,

   For compiling KLSCallC,

   For compiling KLSCallS,

   For compiling KLSSizeof



                     Automatic Stack Extension
                     =========================

Stack Layout
------------

  +---------------------------------+
  | INDEX | PARENT | SP | ITEMS ... |
  +---------------------------------+
  
Stacks Layout
-------------

  +------------------------------------------+
  | FREE FRAMES ...    | ACTIVE FRAMES ...   |
  +------------------------------------------+

Function prelude
----------------

  SMax = RSP + Frame Size + 8
  If SMax > SLim :
     Switch to Free Stack
     (xs ...) = Args
     If number of free stacks < 1 :
        extend-stack()
  else :
     (xs ...) = Args
  function body

Switching to Free Stack
-----------------------
  1. Cap the current stack.
     stack.rsp = rsp
  2. Retrieve the next free stack.
     s = Stacks[num-free - 1]
     num-free = num-free - 1
  3. Link it to the current stack.
     s.parent = stack
  4. Update the stack pointer, limits, and current stack
     rsp = ptr(s.items)
     slim = s + stack-size - REF-TAG
     stack = s

Assembly Code
-------------

  Registers:
     s0 = R0
     i = R1
     s1 = R2
     ss = R3
     lim = R3

  1. Cap the current stack
  s0 = [stack]
  [s0.rsp] = RSP

  2. Retrieve the next free stack
  i = [num-free]
  i = i - 1  
  s1 = i << 3
  ss = [stacks]
  s1 = s1 + ss
  s1 = [s1]
  [num-free] = i

  3. Link it to the current stack
  [s1.parent] = s0
  
  4. Update the stack pointer and limits
  RSP = ptr(s1.items)
  lim = s1 + stack-size - REF-TAG
  [stack-lim] = lim  
  [stack] = s1



                   Input Language to Compilation
                   =============================

Summary
-------

Top Level HiStanza Commands :
   KDef(n, value)
   KDefVar(n, value)
   KDefn(n, value)
   KDefType(n, parent)
   KDefTypeObject(n, args, type)
   KDefConst(n, value)
   KInit(exp)

KDefn Function :
   KCode(numfree, arity, args, body)
   KMultifn(codes ...)

Top Level LoStanza Commands :
   KLSDef(n, type)
   KLSDefCode(n, arity, args, types, body)
   KLSDefType(n, parent, fields, rfield)
   KExtern(n, type, lbl)
   KLSInit(comm)

HiStanza Expressions :
   KSet(n, value)
   KCast(exp, targ)
   KCheckVoid(exp)
   KCheckLength(exp, length)
   KLet(KDef(n, value), body)
   KLetRec(KDef(n, KClosure(code, args)) ..., body)
   KSeq(a, b)
   KDispatch(args, KBranch(args, types, body) ...)
   KMatch(args, KBranch(args, types, body) ...)
   KObject(n, args)
   KObjectGet(object, index)
   KTypeObject(n, args)
   KCall(tail?, arity, func, args)
   KVar(n)
   KPrim(op, args)
   KLiteral(value)
   KTuple(exps)
   KTupleGet(exps, i)
   KBox(value)
   KBoxGet(box)
   KBoxSet(box, value)
   KClosure(n, args)
   KBranchError()

LoStanza Commands :
   KLSCall(exp)
   KLSTCall(exp)
   KLSSet(exp, value)
   KLSLabel(n)
   KLSGoto(n)
   KLSReturn(exp)
   KLSLet(n, value, body)
   KLSLetVar(n, type, body)
   KLSSeq(a, b)
   KLSIf(pred, conseq, alt)
   KLSMatch(args, KLSBranch(args, types, body) ...)
   KLSDispatch(args, KLSBranch(args, types, body) ...)
   KLSPrimComm(op, args)
   KLSSkip

LoStanza Expressions :
   KLSVar(n)
   KLSRef(n, args)
   KLSRefArray(n, length, args)
   KLSStruct(n, args)
   KLSPtr(exp)
   KLSRead(exp)
   KLSPrim(op, args, type)
   KLSWCall(arity, func, args, type)
   KLSWCallClosure(arity, func, args, type)
   KLSCallC(func, args, type)
   KLSSizeof(type)
   KLSTagof(n)
   KLSConv(exp, type)
   KLSLitByte(value)
   KLSLitInt(value)
   KLSLitLong(value)
   KLSLitFloat(value)
   KLSLitDouble(value)
   KLSLitString(value)
   


HiStanza Top Level Commands
---------------------------

The root set -- These commands comprise the root set for
HiStanza. Consts are stored in a separate area for initialization
purposes. Any global functions referenced directly have been converted
to closures and defined using KDef.

   KDef(n, value)
   KDefVar(n, value)
   KDefConst(n, value)

Defining functions -- Functions are defined using KDefn. The bodies
must indicate the number of free variables for referenced by this
function, the arity of the function (not including the type
arguments), all the arguments, and the body. Entry type checks are
assumed to be in the body.

   KDefn(n, value)
   KCode(numfree, arity, args, body)
   KMultifn(codes ...)

Defining types -- Types are defined using KDefType. When types become
first-class and are passed as arguments, they are referenced through a
KDefTypeObject command.

   KDefType(n, parent)
   KDefTypeObject(n, args, type)

Initializing expressions -- Expressions that must be run in order for
the top-level is given by these commands.

   KInit(exp)


LoStanza Top Level Commands
---------------------------

The root set -- The root set is entirely defined by the KLSDef
command. There is no value given, it is assumed to be initialized
using a KLSInit command.

   KLSDef(n, type)

Defining functions -- The arity of the function does not include
reified type arguments. Entry type checks are assumed to be in the
body. Only arguments types are needed. 

   KLSDefCode(n, arity, args, types, body)

Defining types -- LoStanza structs are defined using this.

   KLSDefType(n, parent, fields, rfield)

External definitions -- This command defines external variables and
functions.

   KExtern(n, type, lbl)

Initializing commands -- Commands that must be run in order for
the top-level is given by these commands.

   KLSInit(comm)
   

HiStanza Expressions
--------------------

References -- May be used to refer to global or local
variables/values. Note that a global function (Hi or Lo Stanza) cannot
be referenced directly using KVar. They must be converted to closures.

   KVar(n)

Creating Type Arguments -- Create type objects given the label of
their type definition, and their closed over arguments.

   KTypeObject(n, args)

Calling Functions -- Functions may either be a direct label in which
case it is a simple call, or an expression in which case it is a
closure call.
   
   KCall(tail?, arity, func, args)

Creating Closures -- Given its code definition, and its closed over
variables.

   KClosure(n, args)


LoStanza Expressions
--------------------

References -- May be used to refer to global or local
variables/values. Note that a global function (Hi or Lo Stanza) cannot
be referenced directly using KVar. They must be converted to closures.

   KLSVar(n)

Pointers -- May be used to refer to global/local variables or
functions. Functions may be referred to directly here.

   KLSPtr(exp)

Calling Functions -- Functions may be either a direct label for a
simple call. Or it may be an expression in which case it is an
indirect call.

   KLSWCall(arity, func, args, type)
   KLSCallC(func, args, type)

Calling Closures -- The argument is always given as an
expression. Stanza calls the closure using the appropriate calling
convention.

   KLSWCallClosure(arity, func, args, type)



   
   
               Required Transforms
               ===================

1. Box mutable variables
2. Lift objects
3. Convert multis
4. Convert dispatches
5. Reify types -- Converts call KDo nodes to KCall nodes. Type objects
   have all been reified. All KFn values have been converted to KCode
   objects. All input arguments have their type checks inserted.
6. Lift closures
7. Convert calls

