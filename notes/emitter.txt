Register Names :
   R0 : rax
   R1 : rbx
   R2 : rcx
   R3 : rdx
   R4 : rsi
   R5 : rdi
   R6 : rbp
   R7 : r8
   R8 : r9
   R9 : r10
   R10 : r11
   R11 : r12
   R12 : r13
   R13 : r14
   R14 : r15
   R15 : xmm0
   R16 : xmm1
   R17 : xmm2
   R18 : xmm3
   R19 : xmm4
   R20 : xmm5
   R21 : xmm6
   R22 : xmm7
   R23 : xmm8
   R24 : xmm9
   R25 : xmm10
   R26 : xmm11
   R27 : xmm12
   R28 : xmm13
   R29 : xmm14
   R30 : xmm15

Size Suffix :
   Byte : "b"
   Int : "l"
   Long : "q"
   Float : "s"
   Double : "d"

Generating Float Set Operations :
   Emit: movs y, x

Generating Float Load Instructions :
   Form: T: x = [y:reg/rsp + o]
   Emit: movs o(y), x
   
   Form: T: x = [y:mem + o]
   Emit: movs (L<n> + o)(%rip), x

   Form: T: x = [y:exmem + o]
   Emit: movs (L<name> + o)(%rip), x

Generating Float Store Instructions :
   Assume: y:reg
   Form: T: [x:reg/rsp + o] = y
   Emit: movs y, o(x)

   Form: T: [x:mem + o] = y
   Emit: movs y, (L<n> + o)(%rip)

   Form: T: [x:exmem + o] = y
   Emit: movs y, (L<name> + o)(%rip)

Generating Set Operations :
   Emit: mov y, x

Generating Float Binary Operations :
   Command for :
      add : "adds"
      sub : "subs"
      mul : "muls"
      div : "divs"
      le : "be"
      lt : "b"
      ge : "ae"
      gt : "a"
      eq : "e"
      ne : "ne"

   Generating Comparative Ops:
      Form: x = y < z
      Assume: y, z:flo-reg
              x:int-reg
      Emit: cmps z, y
            movq $0, x
            setop x(byte)

   Generating Commutative Ops:
      Assume: x, y, z: flo-reg
      
      Form: x = x + z
      Emit: op z, x
      
      Form: x = y + x
      Emit: op y, x

      Form: x = y + z
      Emit: movs y, x
            op z, x

   Generating Non-commutative Ops:
      Assume: x, y, z: flo-reg
      
      Form: x = x - z
      Emit: op z, x

      Form: x = y - x
      Error!

      Form: x = y - z
      Emit: movs y, x
            op z, x      

Generating Binary Operations :
   Command for :
      add : "add"
      sub : "sub"
      mul : "imul"
      and : "and"
      or : "or"
      xor : "xor"
      shl : "shl" 
      shr : "shr" 
      ashr : "sar"
      le : "le"
      lt : "l"
      ge : "ge"
      gt : "g"
      eq : "e"
      ne : "ne"
      ule : "be"
      ult : "b"
      uge : "ae"
      ugt : "a"
      
   Generating Comparative Ops:
      Form: x = y < z
      Emit: cmp z, y
            movq $0, x
            setop x(byte)
            
   Generating Commutative Ops:
      Form: x = x + z
      Emit: op z, x

      Form: x = y + x
      Emit: op y, x

      Form: x = y + z
      Emit: mov y, x
            op z, x

   Generating Non-Commutative Ops:
      Form: x = x - z
      Emit: op z, x

      Form: x = y - x
      Error!

      Form: x = y - z
      Emit: mov y, x
            op z, x

   Generating Shift Ops :
      Form: x = x >> 8
      Emit: op 8, x

      Form: x = x >> cl
      Emit: op cl, x

      Form: x = y >> 8
      Emit: mov y, x
            op 8, x

      Form: x = y >> cl
      Emit: mov y, x
            op cl, x

   Generating Div Op:
      Form: al = y / al
      Error!
      
      Form: al = y % al
      Error!
      
      Form: al = al / z
      Emit: movz al, ax
            idivb z

      Form: al = y / z
      Emit: movz y, ax
            idivb z

      Form: al = al % z
      Emit: movz al, ax
            idivb z
            shrw $8, ax

      Form: al = y % z
      Emit: movz y, ax
            idivb z
            shrw $8, ax

Generating Dual Operations :
   Form: (eax, edx) = eax /% y
   Emit: cdq
         idivl y

   Form: (rax, rdx) = rax /% y
   Emit: cqo
         idivq y
            
Generating Zero Extend :
   Byte => Int :
      Emit: movzbl
   Byte => Long
      Emit: movzbq
   Int => Long
      Emit: movzlq

Generating Sign Extend :
   Byte => Int :
      Emit: movsbl
   Byte => Long :
      Emit: movsbq
   Int => Long :
      Emit: movslq

Generating Goto Instructions :
   Form: goto L<n> :
   Emit: jmp L<n>

   Form: goto L<name> :
   Emit: jmp L<name>
    
   Form: goto reg :
   Emit: jmp *reg

Generating Value Definition :
   DefByte : .byte value
   DefInt : .long value
   DefLong : .quad value
   DefString : .byte char1 char2 char3 ... 0
   DefSpace : .space size
   DefLabel : .quad name
   DefData : .data
   DefText : .text

