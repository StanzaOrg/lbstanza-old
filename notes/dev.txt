                        Infrastructure
                        ==============

First we need a method of testing and poking the system so we will
design the IR datastructures, write a parser for it, and write a
printer to view the datastructures.

We will start the design simply. A program consists of a number of
top level DefIns instructions, and the name of the entry
point. Currently there is only a single DefIns instruction, the
DefFn instruction for defining single-arity functions.

A DefFn instruction represents the definition of a function once
compiled to the target IR. It has:
   - The name of the function
   - The arity of the function
   - The arguments of the function
   - The locals in the function
   - And instructions that make up the body of the function

The arity needs to be given in addition to the arguments because of
struct-valued arguments which span more than a single
Var. Arguments and Locals are defined using the DefVar structure,
which tells us both the name and type of the variable.

The types of the variables are represented by TgtType, and there is
one to represent each of the primitive types, and an additional one
to represent a reference to a heap object.


                    Function Instructions
                    =====================

Immediates
----------

Immediates are used as operands in instructions, and represent values
that can be directly encoded in the instruction. Here is a listing of
the different kinds:

ByteImm/IntImm/LongImm/FloatImm/DoubleImm -- These immediates allow us
to create primitive values.

Mem(name) -- These denote the address of a declared function.

Var -- These refer to a declared argument or local in the
function. Note that instruction return values are always stored in a
Var.


Basic Instructions
------------------

SetIns: x = y -- This instruction just assigns an immediate to a
declared variable.

BinOp: x = op(y, z) -- This instruction performs a binary operation on
two immediates and stores the result in x. A listing of possible
operators are given in the next section.


Calling Instructions
--------------------

Call: (arity) (xs ...) = f(ys ...) -- This instruction calls the
function f with the arguments ys, and stores the results in xs. The
arity of the function call is given.

Return: return (xs ...) --- This instruction returns the given values
to the calling function.


Control Flow Instructions
-------------------------

Label: label<name> -- This instruction marks a specific position in
the instruction stream with a name.

Goto: goto label<name> -- This instruction jumps to the position
associated with the given name.

Branch: branch label<name> when op(x, y) -- This instruction jumps to
the position associated with the given name, when the given predicate
is true.



                       Basic Block IR
                       ==============

The next step is to translate the parsed target IR,
function-by-function, into the intermediate representation used for
register allocation.

An allocation unit is comprised of a number of local variable
definitions, and a number of basic blocks. Each variable definition
has a name and a type. Each basic block is comprised of a name, a
number of instructions, and the names of the successor blocks.

Vars
----

Variables represent operands and return values in instructions. They
do *not* represent immediates, which must be handled by the
translation into the RegAlloc IR.


Basic Instructions
------------------

SetIns: x = y -- This instruction assigns an immediate to a declared
variable.

BinOp: (xs ...) = op(ys ...) -- This instruction performs a primitive
operation on the given arguments, and returns the given results. The
operation is defined as one of a number of classes that have similar
register characteristics.


Control Flow Instructions
-------------------------

Branch: branch name when op(xs ...) else name -- This instruction jumps
to one of two basic blocks depending upon the given predicate.

Note that Gotos are NOT part of the RegAlloc IR. It is assumed that if
a basic block has only a single successor block, then implicit GOTOs
are inserted as necessary to weave the basic blocks.


Calling Instructions
--------------------

Args: (xs ...) = Args -- This instruction reads in the function
arguments. No values are allowed to be live during this instruction.

Call: (arity) (xs ...) = f(ys ...) -- This instruction calls the
function f with the arguments ys, and stores the results in xs. The
arity of the function call is given.

Return: return (xs ...) -- This instruction returns the given values
to the calling function.



                    Translation to Basic Block IR
                    =============================

The overall algorithm structure is to iterate through instructions and
add the translated instructions to the currently active block. Control
flow instructions have the effect of closing the currently active
block, and starting a new active block.

   initialize defs and type-table

   var active-block = fresh block
   for each instruction e :
      match(e) :
         (e:WArgs) : translate
         (e:SetIns) : translate
         (e:BinOp) : translate
         (e:ConvertIns) : translate
         (e:Load) : translate
         (e:Store) : translate
         (e:Addr) : translate
         (e:WCall) : translate
         (e:WCallC) : translate
         (e:WTCall) : translate and create new block
         (e:Return) : translate and create new block
         (e:Label) : translate and create new block
         (e:Goto) : translate and create new block
         (e:Branch) : translate and create new block

For BinOp instructions, the exact form depends on the type and class
of the operator:

   case int com : no restriction
   case int ncom : requires nop for prolonging liveness of second argument      
   case byte div :
      requires variables for arguments.
      requires nop for prolonging liveness of second argument.
   case int div :
      if operator is DIV :
         requires variables for arguments.
         requires nop for prolonging liveness of second argument.
         requires dualop where x is first, tmp is second.
      if operator is MOD :
         requires variables for arguments.
         requires nop for prolonging liveness of second argument.
         requires dualop where tmp is first, x is second.
   case int cmp : cannot have two vals as arguments      
   case int shf : requires nop for prolonging liveness of second argument
   case float com : no restriction
   case float cmp : no restriction
   case float ncom : requires nop for prolonging liveness of second argument      
   case float div : requires nop for prolonging liveness of second argument      


                        Position Marker
                        ===============

A Position marker indicates a specific point in the instruction
stream.

   Position i indicates the beginning of an instruction, before any
   use has occurred.

   Position i.5 indicates right after the uses have occured, but
   before any defs have occured.

It supports a hash, less?, and less-eq? functions.



                      List Table Structure
                      ====================

This datastructure offers associates each key K with a list of items
T. It offers functions for retrieving the list associated with a given
key, adding an item to the list of a given key, and querying the
length of the list associated with a given key.


                    Usage Table Calculation
                    =======================

Algorithm is split into two phases:
   1. Computing a sorted list of usages for each variable, where each
      usage is either a Use or a Kill.
   2. Computing for a given variable and starting position, the
      distance until its next use.

Computing List of Usages
------------------------

Algorithm structure:

   for each instruction e with index i :
      if e is not a Save :
         for each used variable :
            mark it as used at position i
      for each defined variable :
         mark it as killed at position i.5

   for each output port with distance d :
      mark it as used at position (n + d)


Computing Distance until Use
----------------------------

   In the list of usages of a variable, we find the first use whose
   position is greater than or equal to the given position. We assume
   that it is a Use and return its index, otherwise the variable is
   not used after the given position and it is an error.


                   Release Table Calculation
                   =========================

Algorithm is split into two phases:
   1. Computing a sorted list of every release with their position.
   2. Computing the list of releases for a given position range.

Computing Releases and Positions
--------------------------------

General algorithm structure :

   Mark appropriate outgoing ports as loaded.
   Then for each instruction e with at index i in reverse :
      For each defined value :
         If the value is not loaded, then mark it as released at position (i + 1).
         Mark the value as no longer loaded.
      If it is a call :
         Then mark all values as not loaded.
      For each used value :
         If the value is not loaded, then mark it as released at position i.5.
         Mark the value as loaded.

The instructions that can be seen are :

   match(e) :
      (e:Set) : ...
      (e:WArgs) : ...
      (e:WCall) : ...
      (e:Return) : ...
      (e:Op) : ...
      (e:Branch) : ...
      (e:Save) : ...
      (e:Load) : ...

Computing Release for Position Range
------------------------------------

Computing the array index given a position: The index corresponding to
a position is the first index at which the given position is less than
the array position.

To optimize this scan, we can begin the scan at the last cached index,
if the cached position is less than or equal to the given
position. Otherwise, we can restart the scan from 0.


                     Critical Edge Removal
                     =====================

The algorithm is split into three phases:
   Block Forwarding: For each empty block with a single successor, we
   forward it to its successor.
   
   Predecessor Counting: For each block we count how many predecessors
   it has.
   
   Safe Block Insertion: Then we insert safe blocks to remove critical
   edges.


Save Block Insertion
--------------------

   For each block, we update it by adjusting its successors :
      If the block has multiple successors :
         For each successor :
            If a successor has multiple ins :
               Then create a safe block that goes to the successor.
            Otherwise successor is unchanged.
      Otherwise successors are unchanged
      

                    Block Liveness Analysis
                    =======================

The algorithm proceeds in three phases.
   Gathering Summaries: For each block we note which variables have
   been defined, which are live-in, what predecessors it has, and how
   many instructions are in the block.

   Propagation: A live-in variable to a block b implies that this
   variable is live-out for every predecessor of b. A live-out for a
   block b implies that this variable is live-in for b if it is not
   defined in b. Proceed until fixpoint.

   Result Table: Convert the live-in and live-out tables into lists of
   variables per block.


Gathering Summaries
-------------------

Overall algorithm structure:

   for each instruction e in reverse :
      for every variable defined by e :
         mark it as defined in this block
         mark it as not live-in to this block
      for every variable used by e :
         mark it as live-in to this block

Propagation
-----------

Overal algorithm structure:
   loop until fixpoint :
      for each live-in x, in block b, with distance d :
         for each predecessor p of b :
            note that x is live-out in p
      for each live-out x, in block b, with distance d :
         if x is not defined in b :
            note that x is live-in in b with dist len(b) + d

Note about indicating progress:
   For indicating progress we only record a change if the new distance
   is less than the original distance.



                         Save Emission
                         =============

The algorithm state is defined by :
   Live Table : Indicates whether each value is live or not.
   
   Save Required Table : Indicates for each value whether we require
   it to be saved when it is defined.
   
   Load Preferred Table : Indicates for each value whether we prefer
   for it to be loaded or whether we don't care.

Overall algorithm structure :
   The algorithm state 

   note for each live-out variable that it is live
   for each instruction e in reverse :
      for any variables defined by e :
         if we require the variable to be saved :
            then emit a Save instruction
            
      emit the instruction
      
      update the state of the algorithm :
         if a variable is defined :
            then it is no longer live
            it does not require a save
            it does not prefer to be loaded
         if a variable is used :
            then it is live
            it does prefer to be loaded
         if a variable is live through a call boundary :
            then it requires a save
            it does not prefer to be loaded

Instructions to be handled :
   match(e) :
      (e:Set) : ...
      (e:Args) : ...
      (e:Call) : ...
      (e:Return) : ...
      (e:Op) : ...
      (e:Branch) : ...

A note about the state of the ports :
   The current state of the port, x, is derived from the algorithm
   state:
      - If x is not live, then its a DeadPort
      - If x is required to be saved, then its save status is true,
        otherwise its any.
      - If x does not prefer to be loaded, then its load status is
        false, otherwise its any.
   
            


                       Class Allocation
                       ================

The algorithm is split into the following layers:

   Layer 1: Provides a mini-language for updating the state of the
   system. Functions are provided for killing, saving, loading,
   unloading, defining variables and ports, and querying the currently
   loaded variables.

   Layer 2: Provides the functions needed for computing the number of
   spills required in a given context, for spilling a number of
   variables, and for spilling over-committed variables. Layer 2 uses
   Layer 1 to control the algorithm state.

   Layer 3: Iterates through the instructions and uses Layer 1 and
   Layer 2 appropriately to emit Saves and Loads as needed to balance
   the register pressure.

Layer 1
-------

The algorithm context is maintained by the following quantities:
   Save Table : Tracks whether a variable is saved, not saved, or unknown.
   Load Table : Tracks whether a variable is loaded, not loaded, or unknown.
   Num Free Registers : Tracks the number of registers available.
   Num Free FRegisters : Tracks the number of floating point registers available.
   Output Vector : Tracks the emitted instructions.

The following fundamental functions are provided:
   emit(i)
   kill(x)
   save(x)
   load(x)
   unload(x)
   define(x)
   currently-loaded()

Layer 2
-------

Computing the number of spills required for a given context: The
context is given by the used immediates, the released variables, and
the defined variables. We maintain a net and a peak register use as we
load, release, and load registers for the used, released, and defined
quantities.

Spilling a given number of registers:

Layer 3
-------

First we define the incoming ports, and issue spills for all
overcommitted registers.

Then we iterate through the instructions in the block and dispatch
upon them.

   match(e) :
      (e:Set) :
         Spill as required so as to define the result.
      (e:Op) :
         Spill as required so as to load the arguments, and define the
         result.
      (e:Branch) :
         Spill as required so as to load the arguments.
      (e:Return) :
         Spill as required so as to load the arguments.
      (e:Save) :
         Emit save if necessary.
      (e:WArgs) :
         Define the results.
      (e:WCall|WCallC) :
         Spill as required so as to load the arguments.
         Define the results.

Then read out the final state of the block output ports.


                   Assumption Propagation
                   ======================

The algorithm state is held in two maps:
   Save Assumptions : The save assumptions for each variable.
   Load Assumptions : The load assumptions for each variable.

An assumption is either an assumed value (which may be true, false, or
any), or open for accepting values.

Iterate through each instruction e, tracking when values are saved,
loaded, and defined. When we hit an assumption barrier, WArgs or
WCall, we process the accumulated assumptions before continuing on to
the next instruction.

Thus the overall structure starts with iterating through the
instructions and dispatching upon the type of instruction.

   for each instruction e :
      match(e) :
         (e:Save) : ...
         (e:Load) : ...
         (e:Unload) : ...
         (e:WArgs) : ...
         (e:WCall) : ...
         (e) : ...


                     Register Assignment
                     ===================

Register Assignment for a Single Block
--------------------------------------

The algorithm is broken into three layers.
   Layer 1: Tracks the locations assigned to each variable, and which
   registers are currently occupied. Provides functions for filling a
   variable with its location, for assigning variables to new
   locations, and for freeing a register for use again.

   Layer 2: Utilities for issuing exchanges to respect certain
   register restrictions.

   Layer 3: Uses layer 1 and layer 2 to assign registers to each
   variable and emit updated instructions.

Layer 1
-------

The algorithm state is maintained in the following maps:
   Location map: Maps each variable to its current location.
   Register slots: Indicates what value is held in each register.
   FRegister slots: Indicates what value is held in each floating
                    point register.

Functions provided:
   fill(x) -- Fills the given quantity with the currently assigned
   location.

   free(x) -- Indicates that the given value need not be in a register
   anymore.

   assign(x, loc) -- Assigns a given value to a location.
   assign(xs, locs) -- Assigns a list of values to a list of locations.

Layer 2
-------

Two functions are provided:
   ensure-free-reg(regs, rs) -- Ensures that after the release of
   variables rs, then the given integer registers regs will be free.

   ensure-reg(x, r) -- Ensures that the value x is assigned to the
   integer register r.

Both functions make use of the helper function:
   swap-reg(src, dst) -- Which swaps the contents of the src with the
   dst registers. It is assumed that the src register is never
   unoccupied.

Layer 3
-------

1. Assign locations to each input port, carrying over its previous
assigned position if appropriate.

2. Iterate through each instruction, and assign registers to the
variables. The only complication is issuing exchange operations to
satisfy certain instruction restrictions.

   for each instruction e do :
      match(e) :
         (e:Set) : ...
         (e:Op) : ...
         (e:Branch) : ...
         (e:Return) : ...
         (e:Save) : ...
         (e:Load) : ...
         (e:WArgs) : ...
         (e:WCall) : ...

For an instruction (xs ...) = op(ys ...), we need to do this overall:

   Assign registers to xs, and emit the updated instruction.
   - This requires filling in the locations of xs, and ys.
   - And assignment of xs must be done before filling in xs.
   - And freeing released quantities must be done before assigning to xs.
   - And assignment of xs requires the filled locations of ys for
     preferred locations.
   - And necessary exchanges for restrictions must be done before
     filling in ys.

Therefore the actual order is:

   1. Emit necessary exchanges.
   2. Fill ys.
   3. Free released quantities.
   4. Assign to xs using locations of filled ys.
   5. Emit updated instruction with filled xs.

If there are no results then the order can be simplified to:
   1. Emit updated instruction with filled ys.
   2. Free released quantities.

For Op instructions, the behaviour differs according to the operator
class. Thus:

   match(op(e)) :
      (opc:CmpOp) : no restrictions
      (opc:LoadOp) : no restrictions
      (opc:StoreOp) : no restrictions
      (opc:AddrOp) : no restrictions
      (opc:ConvOp) : no restrictions
      (opc:ComOp) : prefers either of the operand registers.
      (opc:NComOp) : prefers the register of the first operand.
      (opc:DivOp) : result must be in register 0.
      (opc:ShfOp) : second operand must be in register 2.
      (opc:DivModOp) : first result must be in register 0.
                       second result must be in resister 3.


Register Assignment for a Program Unit
--------------------------------------

First maintain a list of blocks to be assigned. The algorithm proceeds
by mutual recursion of the following two functions:

   assign-regs(b, ports-in) -- Assign registers to block b using the
   given locations of the incoming ports. Add the updated block to the
   updated list, and remove the block from the active list.

   assign-successors(b) -- Assumes that the block b has already been
   assigned, and assigns registers to all of its successors in the
   active list using the locations of b's outgoing ports. Then
   recursively calls assign-successors to all the newly updated
   blocks.

The algorithm is started off by assigning registers to the first
block, and then assigning its successors.


                    Assignment Verification
                    =======================

The algorithm is split into two layers:
   Layer 1:
   Layer 2: Uses layer 1 to iteratively check through every
   instruction in the block.

Layer 1
-------

The algorithm state is tracked in the following tables:
   Register Slots -- Holds the current value in each of the integer
   register slots.
   FRegister Slots -- Holds the current value in each of the floating
   point register slots.
   Saved Values -- Indicates for each value whether the most recent
   version has been saved or not.

Provides the following functions for updating the state:

   xchg(x, y)
   define(x)
   mov(x, y)
   save(x)
   load(y)
   clear-registers()

And the following function for checking location consistency:

   check!(x)
   saved!(x)

Layer 2
-------

General algorithm structure:

   define all input ports

   for each instruction e :
      match(e) :
         (e:Set) : ...
         (e:Xchg) : ...
         (e:Op) : ...
         (e:Branch) : ...
         (e:Return) : ...
         (e:Save) : ...
         (e:Load) : ...
         (e:WArgs) : ...
         (e:WCall) : ...

   check all output ports


                  Stack Interval Calculation
                  ==========================

Algorithm is split into two phases:
   1. Noting the start and end stack usages of each variable.
   2. Sorting the start and end intervals by position.

Noting start and end usages
---------------------------

The algorithm is structured generally as:

   for b in reverse-post-order(blocks) do :
      note-any-usages(in(b), next(ins-counter))
      for i in ins(b) do :
         note-any-usages(i, next(ins-counter))
      note-any-usages(out(b), next(ins-counter))

Sorting Start and End Intervals
-------------------------------

The algorithm is structured generally as:

   val positions:Array<List<Interval>>
   for int in end-intervals do :
      positions[i(int)] += int
   for int in start-intervals do :
      positions[i(int)] += int



                    Stack Map Calculation
                    =====================

The algorithm is split into two phases:
   1. Assigning each variable a stack location.
   2. Computing the stack offsets from the stack locations.


Assigning Stack Locations
-------------------------

The algorithm maintains a mapping from stack locations to whether the
location is occupied or not. The main algorithm is structured:

   for i in ints do :
      if i is a starting interval :
         assign i to the next free stack location
      else if i is an end interval :
         mark i's location as no longer occupied.

Computing Stack Offsets
-----------------------

First create the vector of PadItems representing each of the stack
locations. These items are sorted according to their type size to try
to fill the stack space. The padder is used to insert pad each item to
respect their alignment.

Next we compute the cumulative offset of each stack item using a
running accumulator. After adding each items size to the accumulator,
the accumulator will hold the size of the frame.


                       Block Collapsing
                       ================

Block collapsing happens in two phases.
   1. Glue port discovery
   2. Instruction linearization

Glue Port Discovery
-------------------

If a block has a single successor, then this block has outgoing
glue ports.

If a block has multiple successors, then each of them have incoming
glue ports.


Instruction Linearization
-------------------------

Now we simply iterate through each block and emit the necessary
instructions. The following instructions are handled specially:

WArgs/WCall: The liveports that are in registers but still require
saving have explicit Save instructions inserted.

Branch: The two destination Branch instruction is transformed into a
one destination Break instruction with fall-through semantics.


                     Compilation to ASM IR
                     =====================

Interface
---------

Supplied Tables:
   Variable Type Table -- A table that holds the defined target types
   of all variables in the unit.

   Stack Map -- The computed stack map for this unit. Holds the stack
   offsets of each stack allocated variable, and the size of the
   frame.

   Instruction List -- The collapsed and linearized basic blocks are
   given as a flat list of instructions.

Output:
   Output List -- ASM instructions should be generated in the given
   output buffer.


Structure
---------

The algorithm begins with a dispatch upon the type of instruction.

   match(i) :
      (i:Set) : ...
      (i:Return) : ...
      (i:Op) : ...
      (i:WArgs) : ...
      (i:WCall) : ...
      (i:Save) : ...
      (i:Load) : ...
      (i:Xchg) : ...
      (i:Shuffle) : ...
      (i:Label) : ...
      (i:Goto) : ...
      (i:Break) : ...


Value Engine
------------

These translate BB immediates into a unique indicator of position.

   AVal = ArgAV(n, type)                ;Memory
        | StackAV(offset, type)         ;Memory
        | Swap                          ;Memory
        | FSwap                         ;Memory
        | RegAV(n, type)                ;Immediate
        | FRegAV(n, type)               ;Immediate
        | RSPAV(type)                   ;Immediate
        | ImmAV(v, type)                ;Immediate
        | NoneAV(type)
        | MemAV(n, type)

Translation Functions:

   aval (imm:Imm|Port) -> AVal
   stack-aval (v:Var) -> AVal

   where Imms are either Var(n, loc) or Val(value). Vars are in
   locations Reg, FReg, Stack. Vals contains either ByteImm, IntImm,
   LongImm, Mem.

Functions that operate on argument AVals.

   av-mov(x, y)
   av-mov(xs, ys)
   av-binop(x, op, y, z)
   av-add(x, y, z)
   av-sub(x, y, z)
   av-divmod(x1, x2, y, z)
   av-load(v, a, o)
   av-store(a, v, o)
   av-conv(x, y, sign)
   av-label(n)
   av-goto(v)
   av-break(n, op, x, y)
   av-long(v)
   av-arity()
   av-return()
   av-call(f)


Calling Conventions
-------------------

These functions return AVals representing the locations of calling
convention positions. Arguments must be moved into these call
locations before calling the function. And results must be moved out
of these call locations after calling a function. If the function is
not an immediate, then there is a specific location that it needs to
be moved to as well.

   call-locations(xs)
   call-locations(f, xs)


Parallel Move Engine
--------------------

The steps proceed in this order.

   1. Save
   2. Swap
   3. Shuffle
   4. Load

The first step is to save as many registers to memory as
possible. This frees up registers to be used for swapping and breaking
cycles.

The second step is to swap memory locations. First find a free swap
register, if one is found, then swaps go through this register. If one
is not found, ...

The third step shuffles registers in place through the use of a swap
register for breaking cycles.

The fourth step loads registers from memory locations.


======================================================================
==================== Separate Compilation ============================
======================================================================


Ultimate Goal:

   - There are a bunch of .stanza files in a directory. These are the
     files that constitute my program.
   - Somewhere else, there is a cache of .pkg files, generated and
     saved by the Stanza compiler. I probably do not need to be aware
     of these.
   - I update some code in a single .stanza file and then run the
     compiler.
   - The executable is produced very quickly because most of the files
     are unchanged.  

Complications:

   - .stanza files contain macros. It would be nice to avoid
     macroexpansion as much as possible, but they may contain
     necessary side effects. And it is hard to predict what packages
     are contained in what files because of macros.
   - There are separate sets of compiled .pkg files for unoptimized
     and optimized settings.

First Attempt:
   - Don't bother avoiding macro expansion.
   - Assume only a single set of .pkg files.

   - 1. Given a set of files .stanza.
   - 2. Expand them all and convert to input IR.
   - 3. Read necessary .pkg files for stubs of includes.
   - 4. Compile and bundle into executable.

Therefore:
   - Multiple sets of .pkg files is a separate problem. Leave that off
     the table for now.

   - Given a set of files, we can always produce the associated .pkg
     files.

Solution for Multiple sets of .pkg files:
   - Just put the optimized and unoptimized files into different
     folders.
   - Refer to these folders possibly through different environment
     variables. e.g. STANZA_PKG_DIR, and STANZA_FAST_PKG_DIR.
   - When users have finished compiling their packages and want to put
     them in a central location on their computer, then just copy the
     pkgs to the proper location.


               Information That Requires Saving
               ================================

Consider only type checking for now. KForm information can be added
later. The important part is the type signatures and names needed for
reconstructing the type checking information.

So for all top-level definitions, we require their namemap
information:
   - Name
   - Package Name
   - Visibility
   - Definition Type
   - File Information
   - Identifier

Note that we do not require type stubs for non-top-level definitions,
and private definitions. (Though for KForm information, we might). 

Concerning the identifier, note that it cannot be relied upon, as
different runs of the compiler assigns identifiers independently. 
   
Required type information:
   - HiStanza type declarations.
   - LoStanza type declataions including field information.
   - Types of global values and variables.
   - Types of global functions.
   - Types of lostanza variables and values.
   - Types of lostanza functions.
   - Types of lostanza external functions.
   - Types of lostanza external variables.   

Note that some types contain references to type variables; for
example, for polymorphic functions and deftype declarations. These
variables need names, packages, and file information declarations as
well.

Designing the Pkg Language

   defnodes PkgComm :
      DefInfo:
         n: Int
         name: Symbol
         package: Symbol
         visibility: Vis
         category: EType
         info: FileInfo
      DefVal:
         n: Int
         type: Type|LSType
      DefType :
         n: Int
         args: List<Int>
         parent: False|Type
      DefLSType :
         n: Int
         args: List<Int>
         parent: False|Type
         fields: List<Field>

   defstruct Field :
      name: Symbol
      type: LSType
   
                     Complications
                     =============

Note that the absolute identifier can sometimes be significant. For
example, identifiers that correspond to system
classes/functions/variables are significant and cannot be
changed. This can be handled by classifying ids as stable or
not. Stable ids have an absolute meaning and do not need to be renamed.

DefType needs to be handled properly, since types can have new parents
using the defchild form. Packages need to be kept all the way through
to preserve KForm information.

                   Current Progress
                   ================

Package type information are saved properly to pkg files. These pkg
files are read back in during symbol resolution and thus we avoid
rename checks, resolve checks, and type checks on pre-compiled
code. It currently does not hold the KForm information, so there we
cannot yet produce a finished executable using .pkg files yet. 

                User Interface Design
                =====================

1. Configuration File .stanza : Contains extra settings, pkg-dir, and
fast-pkg-dir, that contains a listing of directories in which to find
compiled .pkg files. Directories are searched in order from first to
last in the list.

2. During compilation, the optional -pkg-path flag can be used to
append additional directories to the *appropriate* package directories
(depending on whether the -optimize flag is set). If no -pkg-path is
given, the current working directory is implicitly appended to the package
directories. 

3. During compilation, the optional -pkg flag can be used to specify
the output folder in which to put the compiled .pkg files. If the flag
is not given, then the default output folder is the current working directory.

4. For input during compilation, users can specify both .pkg files and
.stanza files. .pkg files will be loaded using package loading
semantics. .stanza files will be loaded using code loading
semantics. Packages are loaded depth first. (The first time that a
package is imported it is loaded). 

                Windows 64-Bit Backend
                ======================

* When converting TGT IR into BB IR, we need to attach register
  locations to the C call.
* For variable arity functions, remember that floating point values
  need to be mirrored in the integer registers using the windows
  calling convention.
- For variable arity functions, remember that floats need to be
  converted to doubles, and bytes need to be converted to ints under
  the linux calling convention.
* For extern functions, we need to attach register locations to the
  incoming arguments.
* During spilling of call-args, we need to spill extra arguments to
  loads and stores from memory. Don't forget that windows calling
  convention has more context saved on the stack.
* When generating the TGT IR remember to put variable arity arguments
  in the varargs field in a CallC expression.
* Remember that the within Stanza portion of the W64Backend is the
  same as the existing code, so make sure that is still working.
- Gradually test the C library functions that we're relying on by
  writing stand-alone C programs.
* In the conversion to BB IR, when creating the Args and Return
  expressions, we require register locations for the C context. C
  context for Args requires stack in R6 upon entry.
* When entering an extern function, the stack is saved in R6 for the
  SysV convention. It needs to be put somewhere else for the W64
  convention.
* SaveCContextOp needs to be updated for W64 convention.
* Make sure that varargs are handled identically by the register allocator.

                 RandomAccessFile
                 ================

* defn RandomAccessFile (filename:String, writable:True|False) -> RandomAccessFile
* defn close (file:RandomAccessFile) -> False
* defn length (file:RandomAccessFile) -> Long
* defn set-length (file:RandomAccessFile, len:Long) -> False
* defn seek (file:RandomAccessFile, pos:Long) -> False
* defn skip (file:RandomAccessFile, n:Long) -> False
* defn fill (b:ByteArray, r:Range, file:RandomAccessFile) -> Long
* defn fill (b:ByteArray, file:RandomAccessFile) -> Long
* defn put (file:RandomAccessFile, b:ByteArray, r:Range) -> False
* defn put (file:RandomAccessFile, b:ByteArray) -> False
* defn get-byte (file:RandomAccessFile) -> Byte|False
* defn get-char (file:RandomAccessFile) -> Char|False
* defn get-int (file:RandomAccessFile) -> Int|False
* defn get-long (file:RandomAccessFile) -> Long|False
* defn get-float (file:RandomAccessFile) -> Float|False
* defn get-double (file:RandomAccessFile) -> Double|False
* defn put (file:RandomAccessFile, x:Byte) -> False
* defn put (file:RandomAccessFile, x:Char) -> False
* defn put (file:RandomAccessFile, x:Int) -> False
* defn put (file:RandomAccessFile, x:Long) -> False
* defn put (file:RandomAccessFile, x:Float) -> False
* defn put (file:RandomAccessFile, x:Double) -> False

TODO:
* error conditions
- windows

                   ByteArray
                   =========

Just like CharArray





