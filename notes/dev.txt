                        Infrastructure
                        ==============

First we need a method of testing and poking the system so we will
design the IR datastructures, write a parser for it, and write a
printer to view the datastructures.

We will start the design simply. A program consists of a number of
top level DefIns instructions, and the name of the entry
point. Currently there is only a single DefIns instruction, the
DefFn instruction for defining single-arity functions.

A DefFn instruction represents the definition of a function once
compiled to the target IR. It has:
   - The name of the function
   - The arity of the function
   - The arguments of the function
   - The locals in the function
   - And instructions that make up the body of the function

The arity needs to be given in addition to the arguments because of
struct-valued arguments which span more than a single
Var. Arguments and Locals are defined using the DefVar structure,
which tells us both the name and type of the variable.

The types of the variables are represented by TgtType, and there is
one to represent each of the primitive types, and an additional one
to represent a reference to a heap object.


                    Function Instructions
                    =====================

Immediates
----------

Immediates are used as operands in instructions, and represent values
that can be directly encoded in the instruction. Here is a listing of
the different kinds:

ByteImm/IntImm/LongImm/FloatImm/DoubleImm -- These immediates allow us
to create primitive values.

Mem(name) -- These denote the address of a declared function.

Var -- These refer to a declared argument or local in the
function. Note that instruction return values are always stored in a
Var.


Basic Instructions
------------------

SetIns: x = y -- This instruction just assigns an immediate to a
declared variable.

BinOp: x = op(y, z) -- This instruction performs a binary operation on
two immediates and stores the result in x. A listing of possible
operators are given in the next section.


Calling Instructions
--------------------

Call: (arity) (xs ...) = f(ys ...) -- This instruction calls the
function f with the arguments ys, and stores the results in xs. The
arity of the function call is given.

Return: return (xs ...) --- This instruction returns the given values
to the calling function.


Control Flow Instructions
-------------------------

Label: label<name> -- This instruction marks a specific position in
the instruction stream with a name.

Goto: goto label<name> -- This instruction jumps to the position
associated with the given name.

Branch: branch label<name> when op(x, y) -- This instruction jumps to
the position associated with the given name, when the given predicate
is true.



                       Translation to RegAlloc IR
                       ==========================

The next step is to translate the parsed target IR,
function-by-function, into the intermediate representation used for
register allocation.

An allocation unit is comprised of a number of local variable
definitions, and a number of basic blocks. Each variable definition
has a name and a type. Each basic block is comprised of a name, a
number of instructions, and the names of the successor blocks.


Vars
----

Variables represent operands and return values in instructions. They
do *not* represent immediates, which must be handled by the
translation into the RegAlloc IR.


Basic Instructions
------------------

SetIns: x = y -- This instruction assigns an immediate to a declared
variable.

BinOp: (xs ...) = op(ys ...) -- This instruction performs a primitive
operation on the given arguments, and returns the given results. The
operation is defined as one of a number of classes that have similar
register characteristics.


Control Flow Instructions
-------------------------

Branch: branch name when op(xs ...) else name -- This instruction jumps
to one of two basic blocks depending upon the given predicate.

Note that Gotos are NOT part of the RegAlloc IR. It is assumed that if
a basic block has only a single successor block, then implicit GOTOs
are inserted as necessary to weave the basic blocks.


Calling Instructions
--------------------

Args: (xs ...) = Args -- This instruction reads in the function
arguments. No values are allowed to be live during this instruction.

Call: (arity) (xs ...) = f(ys ...) -- This instruction calls the
function f with the arguments ys, and stores the results in xs. The
arity of the function call is given.

Return: return (xs ...) -- This instruction returns the given values
to the calling function.


                        Position Marker
                        ===============

A Position marker indicates a specific point in the instruction
stream.

   Position i indicates the beginning of an instruction, before any
   use has occurred.

   Position i.5 indicates right after the uses have occured, but
   before any defs have occured.

It supports a hash, less?, and less-eq? functions.


                      List Table Structure
                      ====================

This datastructure offers associates each key K with a list of items
T. It offers functions for retrieving the list associated with a given
key, adding an item to the list of a given key, and querying the
length of the list associated with a given key.


                    Usage Table Calculation
                    =======================

Algorithm is split into two phases:
   1. Computing a sorted list of usages for each variable, where each
      usage is either a Use or a Kill.
   2. Computing for a given variable and starting position, the
      distance until its next use.

Computing List of Usages
------------------------

Algorithm structure:

   for each instruction e with index i :
      if e is not a Save :
         for each used variable :
            mark it as used at position i
      for each defined variable :
         mark it as killed at position i.5

   for each output port with distance d :
      mark it as used at position (n + d)


Computing Distance until Use
----------------------------

   In the list of usages of a variable, we find the first use whose
   position is greater than or equal to the given position. We assume
   that it is a Use and return its index, otherwise the variable is
   not used after the given position and it is an error.


                   Release Table Calculation
                   =========================

Algorithm is split into two phases:
   1. Computing a sorted list of every release with their position.
   2. Computing the list of releases for a given position range.

Computing Releases and Positions
--------------------------------

General algorithm structure :

   Mark appropriate outgoing ports as loaded.
   Then for each instruction e with at index i in reverse :
      For each defined value :
         If the value is not loaded, then mark it as released at position (i + 1).
         Mark the value as no longer loaded.
      If it is a call :
         Then mark all values as not loaded.
      For each used value :
         If the value is not loaded, then mark it as released at position i.5.
         Mark the value as loaded.

The instructions that can be seen are :

   match(e) :
      (e:Set) : ...
      (e:WArgs) : ...
      (e:WCall) : ...
      (e:Return) : ...
      (e:Op) : ...
      (e:Branch) : ...
      (e:Save) : ...
      (e:Load) : ...

Computing Release for Position Range
------------------------------------

Computing the array index given a position: The index corresponding to
a position is the first index at which the given position is less than
the array position.

To optimize this scan, we can begin the scan at the last cached index,
if the cached position is less than or equal to the given
position. Otherwise, we can restart the scan from 0.


                     Critical Edge Removal
                     =====================

The algorithm is split into three phases:
   Block Forwarding: For each empty block with a single successor, we
   forward it to its successor.
   
   Predecessor Counting: For each block we count how many predecessors
   it has.
   
   Safe Block Insertion: Then we insert safe blocks to remove critical
   edges.


Save Block Insertion
--------------------

   For each block, we update it by adjusting its successors :
      If the block has multiple successors :
         For each successor :
            If a successor has multiple ins :
               Then create a safe block that goes to the successor.
            Otherwise successor is unchanged.
      Otherwise successors are unchanged
      

                    Block Liveness Analysis
                    =======================

The algorithm proceeds in three phases.
   Gathering Summaries: For each block we note which variables have
   been defined, which are live-in, what predecessors it has, and how
   many instructions are in the block.

   Propagation: A live-in variable to a block b implies that this
   variable is live-out for every predecessor of b. A live-out for a
   block b implies that this variable is live-in for b if it is not
   defined in b. Proceed until fixpoint.

   Result Table: Convert the live-in and live-out tables into lists of
   variables per block.


Gathering Summaries
-------------------

Overall algorithm structure:

   for each instruction e in reverse :
      for every variable defined by e :
         mark it as defined in this block
         mark it as not live-in to this block
      for every variable used by e :
         mark it as live-in to this block

Propagation
-----------

Overal algorithm structure:
   loop until fixpoint :
      for each live-in x, in block b, with distance d :
         for each predecessor p of b :
            note that x is live-out in p
      for each live-out x, in block b, with distance d :
         if x is not defined in b :
            note that x is live-in in b with dist len(b) + d

Note about indicating progress:
   For indicating progress we only record a change if the new distance
   is less than the original distance.



                         Save Emission
                         =============

The algorithm state is defined by :
   Live Table : Indicates whether each value is live or not.
   
   Save Required Table : Indicates for each value whether we require
   it to be saved when it is defined.
   
   Load Preferred Table : Indicates for each value whether we prefer
   for it to be loaded or whether we don't care.

Overall algorithm structure :
   The algorithm state 

   note for each live-out variable that it is live
   for each instruction e in reverse :
      for any variables defined by e :
         if we require the variable to be saved :
            then emit a Save instruction
            
      emit the instruction
      
      update the state of the algorithm :
         if a variable is defined :
            then it is no longer live
            it does not require a save
            it does not prefer to be loaded
         if a variable is used :
            then it is live
            it does prefer to be loaded
         if a variable is live through a call boundary :
            then it requires a save
            it does not prefer to be loaded

Instructions to be handled :
   match(e) :
      (e:Set) : ...
      (e:Args) : ...
      (e:Call) : ...
      (e:Return) : ...
      (e:Op) : ...
      (e:Branch) : ...

A note about the state of the ports :
   The current state of the port, x, is derived from the algorithm
   state:
      - If x is not live, then its a DeadPort
      - If x is required to be saved, then its save status is true,
        otherwise its any.
      - If x does not prefer to be loaded, then its load status is
        false, otherwise its any.
   
            


                       Class Allocation
                       ================

The algorithm is split into the following layers:

   Layer 1: Provides a mini-language for updating the state of the
   system. Functions are provided for killing, saving, loading,
   unloading, defining variables and ports, and querying the currently
   loaded variables.

   Layer 2: Provides the functions needed for computing the number of
   spills required in a given context, for spilling a number of
   variables, and for spilling over-committed variables. Layer 2 uses
   Layer 1 to control the algorithm state.

   Layer 3: Iterates through the instructions and uses Layer 1 and
   Layer 2 appropriately to emit Saves and Loads as needed to balance
   the register pressure.

Layer 1
-------

The algorithm context is maintained by the following quantities:
   Save Table : Tracks whether a variable is saved, not saved, or unknown.
   Load Table : Tracks whether a variable is loaded, not loaded, or unknown.
   Num Free Registers : Tracks the number of registers available.
   Num Free FRegisters : Tracks the number of floating point registers available.
   Output Vector : Tracks the emitted instructions.

The following fundamental functions are provided:
   emit(i)
   kill(x)
   save(x)
   load(x)
   unload(x)
   define(x)
   currently-loaded()

Layer 2
-------

Computing the number of spills required for a given context: The
context is given by the used immediates, the released variables, and
the defined variables. We maintain a net and a peak register use as we
load, release, and load registers for the used, released, and defined
quantities.

Spilling a given number of registers:

Layer 3
-------

First we define the incoming ports, and issue spills for all
overcommitted registers.

Then we iterate through the instructions in the block and dispatch
upon them.

   match(e) :
      (e:Set) :
         Spill as required so as to define the result.
      (e:Op) :
         Spill as required so as to load the arguments, and define the
         result.
      (e:Branch) :
         Spill as required so as to load the arguments.
      (e:Return) :
         Nothing
      (e:Save) :
         Emit save if necessary.
      (e:WArgs) :
         Define the resultant ports.
         Spill overcomitted registers.
      (e:WCall) :
         Define the resultant ports.
         Spill overcomitted registers.

Then read out the final state of the block output ports.


                   Assumption Propagation
                   ======================

The algorithm state is held in two maps:
   Save Assumptions : The save assumptions for each variable.
   Load Assumptions : The load assumptions for each variable.

An assumption is either an assumed value (which may be true, false, or
any), or open for accepting values.

Iterate through each instruction e, tracking when values are saved,
loaded, and defined. When we hit an assumption barrier, WArgs or
WCall, we process the accumulated assumptions before continuing on to
the next instruction.

Thus the overall structure starts with iterating through the
instructions and dispatching upon the type of instruction.

   for each instruction e :
      match(e) :
         (e:Save) : ...
         (e:Load) : ...
         (e:Unload) : ...
         (e:WArgs) : ...
         (e:WCall) : ...
         (e) : ...


                     Register Assignment
                     ===================

Register Assignment for a Single Block
--------------------------------------

The algorithm is broken into three layers.
   Layer 1: Tracks the locations assigned to each variable, and which
   registers are currently occupied. Provides functions for filling a
   variable with its location, for assigning variables to new
   locations, and for freeing a register for use again.

   Layer 2: Utilities for issuing exchanges to respect certain
   register restrictions.

   Layer 3: Uses layer 1 and layer 2 to assign registers to each
   variable and emit updated instructions.

Layer 1
-------

The algorithm state is maintained in the following maps:
   Location map: Maps each variable to its current location.
   Register slots: Indicates what value is held in each register.
   FRegister slots: Indicates what value is held in each floating
                    point register.

Functions provided:
   fill(x) -- Fills the given quantity with the currently assigned
   location.

   free(x) -- Indicates that the given value need not be in a register
   anymore.

   assign(x, loc) -- Assigns a given value to a location.
   assign(xs, locs) -- Assigns a list of values to a list of locations.

Layer 2
-------

Two functions are provided:
   ensure-free-reg(regs, rs) -- Ensures that after the release of
   variables rs, then the given integer registers regs will be free.

   ensure-reg(x, r) -- Ensures that the value x is assigned to the
   integer register r.

Both functions make use of the helper function:
   swap-reg(src, dst) -- Which swaps the contents of the src with the
   dst registers. It is assumed that the src register is never
   unoccupied.

Layer 3
-------

1. Assign locations to each input port, carrying over its previous
assigned position if appropriate.

2. Iterate through each instruction, and assign registers to the
variables. The only complication is issuing exchange operations to
satisfy certain instruction restrictions.

   for each instruction e do :
      match(e) :
         (e:Set) : ...
         (e:Op) : ...
         (e:Branch) : ...
         (e:Return) : ...
         (e:Save) : ...
         (e:Load) : ...
         (e:WArgs) : ...
         (e:WCall) : ...

For an instruction (xs ...) = op(ys ...), we need to do this overall:

   Assign registers to xs, and emit the updated instruction.
   - This requires filling in the locations of xs, and ys.
   - And assignment of xs must be done before filling in xs.
   - And freeing released quantities must be done before assigning to xs.
   - And assignment of xs requires the filled locations of ys for
     preferred locations.
   - And necessary exchanges for restrictions must be done before
     filling in ys.

Therefore the actual order is:

   1. Emit necessary exchanges.
   2. Fill ys.
   3. Free released quantities.
   4. Assign to xs using locations of filled ys.
   5. Emit updated instruction with filled xs.

If there are no results then the order can be simplified to:
   1. Emit updated instruction with filled ys.
   2. Free released quantities.

For Op instructions, the behaviour differs according to the operator
class. Thus:

   match(op(e)) :
      (opc:CmpOp) : no restrictions
      (opc:LoadOp) : no restrictions
      (opc:StoreOp) : no restrictions
      (opc:AddrOp) : no restrictions
      (opc:ConvOp) : no restrictions
      (opc:ComOp) : prefers either of the operand registers.
      (opc:NComOp) : prefers the register of the first operand.
      (opc:DivOp) : result must be in register 0.
      (opc:ShfOp) : second operand must be in register 2.
      (opc:DivModOp) : first result must be in register 0.
                       second result must be in resister 3.


Register Assignment for a Program Unit
--------------------------------------

First maintain a list of blocks to be assigned. The algorithm proceeds
by mutual recursion of the following two functions:

   assign-regs(b, ports-in) -- Assign registers to block b using the
   given locations of the incoming ports. Add the updated block to the
   updated list, and remove the block from the active list.

   assign-successors(b) -- Assumes that the block b has already been
   assigned, and assigns registers to all of its successors in the
   active list using the locations of b's outgoing ports. Then
   recursively calls assign-successors to all the newly updated
   blocks.

The algorithm is started off by assigning registers to the first
block, and then assigning its successors.


                    Assignment Verification
                    =======================

The algorithm is split into two layers:
   Layer 1:
   Layer 2: Uses layer 1 to iteratively check through every
   instruction in the block.

Layer 1
-------

The algorithm state is tracked in the following tables:
   Register Slots -- Holds the current value in each of the integer
   register slots.
   FRegister Slots -- Holds the current value in each of the floating
   point register slots.
   Saved Values -- Indicates for each value whether the most recent
   version has been saved or not.

Provides the following functions for updating the state:

   xchg(x, y)
   define(x)
   mov(x, y)
   save(x)
   load(y)
   clear-registers()

And the following function for checking location consistency:

   check!(x)
   saved!(x)

Layer 2
-------

General algorithm structure:

   define all input ports

   for each instruction e :
      match(e) :
         (e:Set) : ...
         (e:Xchg) : ...
         (e:Op) : ...
         (e:Branch) : ...
         (e:Return) : ...
         (e:Save) : ...
         (e:Load) : ...
         (e:WArgs) : ...
         (e:WCall) : ...

   check all output ports


                  Stack Interval Calculation
                  ==========================

Algorithm is split into two phases:
   1. Noting the start and end stack usages of each variable.
   2. Sorting the start and end intervals by position.

Noting start and end usages
---------------------------

The algorithm is structured generally as:

   for b in reverse-post-order(blocks) do :
      note-any-usages(in(b), next(ins-counter))
      for i in ins(b) do :
         note-any-usages(i, next(ins-counter))
      note-any-usages(out(b), next(ins-counter))

Sorting Start and End Intervals
-------------------------------

The algorithm is structured generally as:

   val positions:Array<List<Interval>>
   for int in end-intervals do :
      positions[i(int)] += int
   for int in start-intervals do :
      positions[i(int)] += int



                    Stack Map Calculation
                    =====================

The algorithm is split into two phases:
   1. Assigning each variable a stack location.
   2. Computing the stack offsets from the stack locations.


Assigning Stack Locations
-------------------------

The algorithm maintains a mapping from stack locations to whether the
location is occupied or not. The main algorithm is structured:

   for i in ints do :
      if i is a starting interval :
         assign i to the next free stack location
      else if i is an end interval :
         mark i's location as no longer occupied.

Computing Stack Offsets
-----------------------

First create the vector of PadItems representing each of the stack
locations. These items are sorted according to their type size to try
to fill the stack space. The padder is used to insert pad each item to
respect their alignment.

Next we compute the cumulative offset of each stack item using a
running accumulator. After adding each items size to the accumulator,
the accumulator will hold the size of the frame.


                       Block Collapsing
                       ================

Block collapsing happens in two phases.
   1. Glue port discovery
   2. Instruction linearization

Glue Port Discovery
-------------------

If a block has a single successor, then this block has outgoing
glue ports.

If a block has multiple successors, then each of them have incoming
glue ports.


Instruction Linearization
-------------------------

Now we simply iterate through each block and emit the necessary
instructions. The following instructions are handled specially:

WArgs/WCall: The liveports that are in registers but still require
saving have explicit Save instructions inserted.

Branch: The two destination Branch instruction is transformed into a
one destination Break instruction with fall-through semantics.


                     Compilation to ASM IR
                     =====================

Interface
---------

Supplied Tables:
   Variable Type Table -- A table that holds the defined target types
   of all variables in the unit.

   Stack Map -- The computed stack map for this unit. Holds the stack
   offsets of each stack allocated variable, and the size of the
   frame.

   Instruction List -- The collapsed and linearized basic blocks are
   given as a flat list of instructions.

Output:
   Output List -- ASM instructions should be generated in the given
   output buffer.


Structure
---------

The algorithm begins with a dispatch upon the type of instruction.

   match(i) :
      (i:Set) : ...
      (i:Return) : ...
      (i:Op) : ...
      (i:WArgs) : ...
      (i:WCall) : ...
      (i:Save) : ...
      (i:Load) : ...
      (i:Xchg) : ...
      (i:Shuffle) : ...
      (i:Label) : ...
      (i:Goto) : ...
      (i:Break) : ...


Value Engine
------------

These translate BB immediates into a unique indicator of position.

   AVal = ArgAV(n, type)                ;Memory
        | StackAV(offset, type)         ;Memory
        | Swap                          ;Memory
        | FSwap                         ;Memory
        | RegAV(n, type)                ;Immediate
        | FRegAV(n, type)               ;Immediate
        | RSPAV(type)                   ;Immediate
        | ImmAV(v, type)                ;Immediate
        | NoneAV(type)
        | MemAV(n, type)

Translation Functions:

   aval (imm:Imm|Port) -> AVal
   stack-aval (v:Var) -> AVal

   where Imms are either Var(n, loc) or Val(value). Vars are in
   locations Reg, FReg, Stack. Vals contains either ByteImm, IntImm,
   LongImm, Mem.

Functions that operate on argument AVals.

   av-mov(x, y)
   av-mov(xs, ys)
   av-binop(x, op, y, z)
   av-add(x, y, z)
   av-sub(x, y, z)
   av-divmod(x1, x2, y, z)
   av-load(v, a, o)
   av-store(a, v, o)
   av-conv(x, y, sign)
   av-label(n)
   av-goto(v)
   av-break(n, op, x, y)
   av-long(v)
   av-arity()
   av-return()
   av-call(f)


Calling Conventions
-------------------

These functions return AVals representing the locations of calling
convention positions. Arguments must be moved into these call
locations before calling the function. And results must be moved out
of these call locations after calling a function. If the function is
not an immediate, then there is a specific location that it needs to
be moved to as well.

   call-locations(xs)
   call-locations(f, xs)


Parallel Move Engine
--------------------

The steps proceed in this order.

   1. Save
   2. Swap
   3. Shuffle
   4. Load

The first step is to save as many registers to memory as
possible. This frees up registers to be used for swapping and breaking
cycles.

The second step is to swap memory locations. First find a free swap
register, if one is found, then swaps go through this register. If one
is not found, ...

The third step shuffles registers in place through the use of a swap
register for breaking cycles.

The fourth step loads registers from memory locations.
