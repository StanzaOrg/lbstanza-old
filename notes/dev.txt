                        Infrastructure
                        ==============

First we need a method of testing and poking the system so we will
design the IR datastructures, write a parser for it, and write a
printer to view the datastructures.

We will start the design simply. A program consists of a number of
top level DefIns instructions, and the name of the entry
point. Currently there is only a single DefIns instruction, the
DefFn instruction for defining single-arity functions.

A DefFn instruction represents the definition of a function once
compiled to the target IR. It has:
   - The name of the function
   - The arity of the function
   - The arguments of the function
   - The locals in the function
   - And instructions that make up the body of the function
   
The arity needs to be given in addition to the arguments because of
struct-valued arguments which span more than a single
Var. Arguments and Locals are defined using the DefVar structure,
which tells us both the name and type of the variable.

The types of the variables are represented by TgtType, and there is
one to represent each of the primitive types, and an additional one
to represent a reference to a heap object. 


                    Function Instructions
                    =====================

Immediates
----------

Immediates are used as operands in instructions, and represent values
that can be directly encoded in the instruction. Here is a listing of
the different kinds:

ByteImm/IntImm/LongImm/FloatImm/DoubleImm -- These immediates allow us
to create primitive values.

Mem(name) -- These denote the address of a declared function.

Var -- These refer to a declared argument or local in the
function. Note that instruction return values are always stored in a
Var.


Basic Instructions
------------------

SetIns: x = y -- This instruction just assigns an immediate to a
declared variable.

BinOp: x = op(y, z) -- This instruction performs a binary operation on
two immediates and stores the result in x. A listing of possible
operators are given in the next section.


Calling Instructions
--------------------

Call: (arity) (xs ...) = f(ys ...) -- This instruction calls the
function f with the arguments ys, and stores the results in xs. The
arity of the function call is given. 

Return: return (xs ...) --- This instruction returns the given values
to the calling function.


Control Flow Instructions
-------------------------

Label: label<name> -- This instruction marks a specific position in
the instruction stream with a name.

Goto: goto label<name> -- This instruction jumps to the position
associated with the given name.

Branch: branch label<name> when op(x, y) -- This instruction jumps to
the position associated with the given name, when the given predicate
is true. 



                       Translation to RegAlloc IR
                       ==========================

The next step is to translate the parsed target IR,
function-by-function, into the intermediate representation used for
register allocation.

An allocation unit is comprised of a number of local variable
definitions, and a number of basic blocks. Each variable definition
has a name and a type. Each basic block is comprised of a name, a
number of instructions, and the names of the successor blocks. 


Vars
----

Variables represent operands and return values in instructions. They
do *not* represent immediates, which must be handled by the
translation into the RegAlloc IR. 


Basic Instructions
------------------

SetIns: x = y -- This instruction assigns an immediate to a declared
variable.

BinOp: (xs ...) = op(ys ...) -- This instruction performs a primitive
operation on the given arguments, and returns the given results. The
operation is defined as one of a number of classes that have similar
register characteristics. 


Control Flow Instructions
-------------------------

Branch: branch name when op(xs ...) else name -- This instruction jumps
to one of two basic blocks depending upon the given predicate.

Note that Gotos are NOT part of the RegAlloc IR. It is assumed that if
a basic block has only a single successor block, then implicit GOTOs
are inserted as necessary to weave the basic blocks.


Calling Instructions
--------------------

Args: (xs ...) = Args -- This instruction reads in the function
arguments. No values are allowed to be live during this instruction.

Call: (arity) (xs ...) = f(ys ...) -- This instruction calls the
function f with the arguments ys, and stores the results in xs. The
arity of the function call is given.

Return: return (xs ...) -- This instruction returns the given values
to the calling function.


================================================================================

                  Adding Memory Instructions
                  ==========================

Mem(n): This immediate denotes the address of a particular 

Load: x = [y + offset]

Store: [x + offset] = y

Addr: x = addr(y) + offset


                  Adding Stack Allocated Values
                  =============================

Add ability to register allocation IR, and etc.
