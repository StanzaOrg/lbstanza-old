                        Infrastructure
                        ==============

First we need a method of testing and poking the system so we will
design the IR datastructures, write a parser for it, and write a
printer to view the datastructures.

We will start the design simply. A program consists of a number of
top level DefIns instructions, and the name of the entry
point. Currently there is only a single DefIns instruction, the
DefFn instruction for defining single-arity functions.

A DefFn instruction represents the definition of a function once
compiled to the target IR. It has:
   - The name of the function
   - The arity of the function
   - The arguments of the function
   - The locals in the function
   - And instructions that make up the body of the function
   
The arity needs to be given in addition to the arguments because of
struct-valued arguments which span more than a single
Var. Arguments and Locals are defined using the DefVar structure,
which tells us both the name and type of the variable.

The types of the variables are represented by TgtType, and there is
one to represent each of the primitive types, and an additional one
to represent a reference to a heap object. 


                    Function Instructions
                    =====================

Immediates
----------

Immediates are used as operands in instructions, and represent values
that can be directly encoded in the instruction. Here is a listing of
the different kinds:

ByteImm/IntImm/LongImm/FloatImm/DoubleImm -- These immediates allow us
to create primitive values.

Mem(name) -- These denote the address of a declared function.

Var -- These refer to a declared argument or local in the
function. Note that instruction return values are always stored in a
Var.


Basic Instructions
------------------

SetIns: x = y -- This instruction just assigns an immediate to a
declared variable.

BinOp: x = op(y, z) -- This instruction performs a binary operation on
two immediates and stores the result in x. A listing of possible
operators are given in the next section.


Calling Instructions
--------------------

Call: (arity) (xs ...) = f(ys ...) -- This instruction calls the
function f with the arguments ys, and stores the results in xs. The
arity of the function call is given. 

Return: return (xs ...) --- This instruction returns the given values
to the calling function.


Control Flow Instructions
-------------------------

Label: label<name> -- This instruction marks a specific position in
the instruction stream with a name.

Goto: goto label<name> -- This instruction jumps to the position
associated with the given name.

Branch: branch label<name> when op(x, y) -- This instruction jumps to
the position associated with the given name, when the given predicate
is true. 



                       Translation to RegAlloc IR
                       ==========================

The next step is to translate the parsed target IR,
function-by-function, into the intermediate representation used for
register allocation.

An allocation unit is comprised of a number of local variable
definitions, and a number of basic blocks. Each variable definition
has a name and a type. Each basic block is comprised of a name, a
number of instructions, and the names of the successor blocks. 


Vars
----

Variables represent operands and return values in instructions. They
do *not* represent immediates, which must be handled by the
translation into the RegAlloc IR. 


Basic Instructions
------------------

SetIns: x = y -- This instruction assigns an immediate to a declared
variable.

BinOp: (xs ...) = op(ys ...) -- This instruction performs a primitive
operation on the given arguments, and returns the given results. The
operation is defined as one of a number of classes that have similar
register characteristics. 


Control Flow Instructions
-------------------------

Branch: branch name when op(xs ...) else name -- This instruction jumps
to one of two basic blocks depending upon the given predicate.

Note that Gotos are NOT part of the RegAlloc IR. It is assumed that if
a basic block has only a single successor block, then implicit GOTOs
are inserted as necessary to weave the basic blocks.


Calling Instructions
--------------------

Args: (xs ...) = Args -- This instruction reads in the function
arguments. No values are allowed to be live during this instruction.

Call: (arity) (xs ...) = f(ys ...) -- This instruction calls the
function f with the arguments ys, and stores the results in xs. The
arity of the function call is given.

Return: return (xs ...) -- This instruction returns the given values
to the calling function.


                       Block Collapsing
                       ================

Block collapsing happens in two phases.
   1. Glue port discovery
   2. Instruction linearization

Glue Port Discovery
-------------------

If a block has a single successor, then this block has outgoing
glue ports.

If a block has multiple successors, then each of them have incoming
glue ports.


Instruction Linearization
-------------------------

Now we simply iterate through each block and emit the necessary
instructions. The following instructions are handled specially:

WArgs/WCall: The liveports that are in registers but still require
saving have explicit Save instructions inserted.

Branch: The two destination Branch instruction is transformed into a
one destination Break instruction with fall-through semantics.


                     Compilation to ASM IR
                     =====================

Interface
---------

Supplied Tables:
   Variable Type Table -- A table that holds the defined target types
   of all variables in the unit.
   
   Stack Map -- The computed stack map for this unit. Holds the stack
   offsets of each stack allocated variable, and the size of the
   frame.
   
   Instruction List -- The collapsed and linearized basic blocks are
   given as a flat list of instructions.

Output:
   Output List -- ASM instructions should be generated in the given
   output buffer.


Structure
---------

The algorithm begins with a dispatch upon the type of instruction.

   match(i) :
      (i:Set) : ... 
      (i:Return) : ...
      (i:Op) : ...      
      (i:WArgs) : ...
      (i:WCall) : ...
      (i:Save) : ...
      (i:Load) : ...
      (i:Xchg) : ...
      (i:Shuffle) : ...
      (i:Label) : ...
      (i:Goto) : ...
      (i:Break) : ...


Value Engine
------------

These translate BB immediates into a unique indicator of position.

   AVal = ArgAV(n, type)                ;Memory
        | StackAV(offset, type)         ;Memory
        | Swap                          ;Memory
        | FSwap                         ;Memory
        | RegAV(n, type)                ;Immediate
        | FRegAV(n, type)               ;Immediate
        | RSPAV(type)                   ;Immediate
        | ImmAV(v, type)                ;Immediate
        | NoneAV(type)
        | MemAV(n, type)

Translation Functions:

   aval (imm:Imm|Port) -> AVal
   stack-aval (v:Var) -> AVal

   where Imms are either Var(n, loc) or Val(value). Vars are in
   locations Reg, FReg, Stack. Vals contains either ByteImm, IntImm,
   LongImm, Mem.   

Functions that operate on argument AVals. 

   av-mov(x, y)
   av-mov(xs, ys)
   av-binop(x, op, y, z)
   av-add(x, y, z)
   av-sub(x, y, z)
   av-divmod(x1, x2, y, z)
   av-load(v, a, o)
   av-store(a, v, o)
   av-conv(x, y, sign)
   av-label(n)
   av-goto(v)
   av-break(n, op, x, y)
   av-long(v)
   av-arity()
   av-return()
   av-call(f)


Calling Conventions
-------------------

These functions return AVals representing the locations of calling
convention positions. Arguments must be moved into these call
locations before calling the function. And results must be moved out
of these call locations after calling a function. If the function is
not an immediate, then there is a specific location that it needs to
be moved to as well.

   call-locations(xs)
   call-locations(f, xs)


Parallel Move Engine
--------------------

The steps proceed in this order.

   1. Save
   2. Swap
   3. Shuffle
   4. Load
   
The first step is to save as many registers to memory as
possible. This frees up registers to be used for swapping and breaking
cycles.

The second step is to swap memory locations. First find a free swap
register, if one is found, then swaps go through this register. If one
is not found, ...

The third step shuffles registers in place through the use of a swap
register for breaking cycles.

The fourth step loads registers from memory locations.



Concerns
--------

- Are ports from WArgs/WCall saved?
